diff --git a/aws-java-sdk-core/pom.xml b/aws-java-sdk-core/pom.xml
new file mode 100644
index 0000000000..4da2c863ff
--- /dev/null
+++ b/aws-java-sdk-core/pom.xml
@@ -0,0 +1,80 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.amazonaws</groupId>
+  <artifactId>aws-java-sdk-core</artifactId>
+  <packaging>jar</packaging>
+  <name>AWS SDK for Java - Core Runtime</name>
+  <description>The AWS SDK for Android - Core module holds the classes that is used by the individual service clients to interact with Amazon Web Services. Users need to depend on aws-java-sdk artifact for accessing individual client classes.</description>
+  <url>http://aws.amazon.com/sdkforandroid</url>
+
+  <parent>
+    <groupId>com.amazonaws</groupId>
+    <artifactId>aws-android-sdk-pom</artifactId>
+    <version>2.6.19</version>
+  </parent>
+
+  <dependencies>
+    <dependency>
+      <groupId>commons-logging</groupId>
+      <artifactId>commons-logging</artifactId>
+      <version>1.1.1</version>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-core</artifactId>
+      <version>2.1.1</version>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.2.4</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <version>2.3.3</version>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.12</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>joda-time</groupId>
+      <artifactId>joda-time</artifactId>
+      <version>2.3</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>2.4</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easymock</groupId>
+      <artifactId>easymock</artifactId>
+      <version>3.1</version>
+      <scope>test</scope>
+    </dependency>  
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AbortedException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AbortedException.java
new file mode 100644
index 0000000000..af474dcb08
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AbortedException.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * SDK operation aborted exception.
+ */
+public class AbortedException extends AmazonClientException {
+
+    /** Default serial version UID. */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor.
+     * @param message the exception message.
+     * @param t the throwable.
+     */
+    public AbortedException(final String message, final Throwable t) {
+        super(message, t);
+    }
+
+    /**
+     * Constructor.
+     * @param t the throwable.
+     */
+    public AbortedException(final Throwable t) {
+        super("", t);
+    }
+
+    /**
+     * Constructor.
+     * @param message the exception message.
+     */
+    public AbortedException(final String message) {
+        super(message);
+    }
+
+    /**
+     * Constructor.
+     */
+    public AbortedException() {
+        super("");
+    }
+
+    /**
+     * {@inheritDoc} An aborted exception is not intended to be retried.
+     * @return true if it is retryable.
+     */
+    @Override
+    public boolean isRetryable() {
+        return false;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonClientException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonClientException.java
new file mode 100644
index 0000000000..9a8a0d9760
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonClientException.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * Base exception class for any errors that occur while attempting to use an AWS
+ * client to make service calls to Amazon Web Services.
+ * <p>
+ * Error responses from services will be handled as AmazonServiceExceptions.
+ * This class is primarily for errors that occur when unable to get a response
+ * from a service, or when the client is unable to understand a response from a
+ * service. For example, if a caller tries to use a client to make a service
+ * call, but no network connection is present, an AmazonClientException will be
+ * thrown to indicate that the client wasn't able to successfully make the
+ * service call, and no information from the service is available.
+ * <p>
+ * Callers should typically deal with exceptions through AmazonServiceException,
+ * which represent error responses returned by services. AmazonServiceException
+ * has much more information available for callers to appropriately deal with
+ * different types of errors that can occur.
+ *
+ * @see AmazonServiceException
+ */
+public class AmazonClientException extends RuntimeException {
+
+    /** Default serial version UID. */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Creates a new AmazonClientException with the specified message, and root
+     * cause.
+     *
+     * @param message An error message describing why this exception was thrown.
+     * @param t The underlying cause of this exception.
+     */
+    public AmazonClientException(final String message, final Throwable t) {
+        super(message, t);
+    }
+
+    /**
+     * Creates a new AmazonClientException with the specified message.
+     *
+     * @param message An error message describing why this exception was thrown.
+     */
+    public AmazonClientException(final String message) {
+        super(message);
+    }
+
+    /**
+     * Create an AmazonClientException with an exception cause.
+     *
+     * @param throwable the cause of the exception.
+     */
+    public AmazonClientException(final Throwable throwable) {
+        super(throwable);
+    }
+
+    /**
+     * Returns a hint as to whether it makes sense to retry upon this exception.
+     * Default is true, but subclass may override.
+     * @return true if it is retryable.
+     */
+    public boolean isRetryable() {
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonServiceException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonServiceException.java
new file mode 100644
index 0000000000..07974cc3b1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonServiceException.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * Extension of AmazonClientException that represents an error response returned
+ * by an Amazon web service. Receiving an exception of this type indicates that
+ * the caller's request was correctly transmitted to the service, but for some
+ * reason, the service was not able to process it, and returned an error
+ * response instead.
+ * <p>
+ * AmazonServiceException provides callers several pieces of information that
+ * can be used to obtain more information about the error and why it occurred.
+ * In particular, the errorType field can be used to determine if the caller's
+ * request was invalid, or the service encountered an error on the server side
+ * while processing it.
+ */
+public class AmazonServiceException extends AmazonClientException {
+
+    /** Default serial version UID. */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Indicates who is responsible (if known) for a failed request.
+     * <p>
+     * For example, if a client is using an invalid AWS access key, the returned
+     * exception will indicate that there is an error in the request the caller
+     * is sending. Retrying that same request will *not* result in a successful
+     * response. The Client ErrorType indicates that there is a problem in the
+     * request the user is sending (ex: incorrect access keys, invalid parameter
+     * value, missing parameter, etc.), and that the caller must take some
+     * action to correct the request before it should be resent. Client errors
+     * are typically associated an HTTP error code in the 4xx range.
+     * <p>
+     * The Service ErrorType indicates that although the request the caller sent
+     * was valid, the service was unable to fulfill the request because of
+     * problems on the service's side. These types of errors can be retried by
+     * the caller since the caller's request was valid and the problem occurred
+     * while processing the request on the service side. Service errors will be
+     * accompanied by an HTTP error code in the 5xx range.
+     * <p>
+     * Finally, if there isn't enough information to determine who's fault the
+     * error response is, an Unknown ErrorType will be set.
+     */
+    public enum ErrorType {
+        /** Client. */
+        Client,
+
+        /** Service. */
+        Service,
+
+        /** Unknown. */
+        Unknown
+    }
+
+    /**
+     * The unique AWS identifier for the service request the caller made. The
+     * AWS request ID can uniquely identify the AWS request, and is used for
+     * reporting an error to AWS support team.
+     */
+    private String requestId;
+
+    /**
+     * The AWS error code represented by this exception (ex:
+     * InvalidParameterValue).
+     */
+    private String errorCode;
+
+    /**
+     * Indicates (if known) whether this exception was the fault of the caller
+     * or the service.
+     *
+     * @see ErrorType
+     */
+    private ErrorType errorType = ErrorType.Unknown;
+
+    /**
+     * The error message as returned by the service.
+     */
+    private String errorMessage;
+
+    /** The HTTP status code that was returned with this error. */
+    private int statusCode;
+
+    /**
+     * The name of the Amazon service that sent this error response.
+     */
+    private String serviceName;
+
+    /**
+     * Constructs a new AmazonServiceException with the specified message.
+     *
+     * @param errorMessage An error message describing what went wrong.
+     */
+    public AmazonServiceException(final String errorMessage) {
+        super(errorMessage);
+        this.errorMessage = errorMessage;
+    }
+
+    /**
+     * Constructs a new AmazonServiceException with the specified message and
+     * exception indicating the root cause.
+     *
+     * @param errorMessage An error message describing what went wrong.
+     * @param cause The root exception that caused this exception to be thrown.
+     */
+    public AmazonServiceException(final String errorMessage,
+                                  final Exception cause) {
+        super(null, cause);
+        this.errorMessage = errorMessage;
+    }
+
+    /**
+     * Sets the AWS requestId for this exception.
+     *
+     * @param requestId The unique identifier for the service request the caller
+     *            made.
+     */
+    public void setRequestId(final String requestId) {
+        this.requestId = requestId;
+    }
+
+    /**
+     * Returns the AWS request ID that uniquely identifies the service request
+     * the caller made.
+     *
+     * @return The AWS request ID that uniquely identifies the service request
+     *         the caller made.
+     */
+    public String getRequestId() {
+        return requestId;
+    }
+
+    /**
+     * Sets the name of the service that sent this error response.
+     *
+     * @param serviceName The name of the service that sent this error response.
+     */
+    public void setServiceName(final String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    /**
+     * Returns the name of the service that sent this error response.
+     *
+     * @return The name of the service that sent this error response.
+     */
+    public String getServiceName() {
+        return serviceName;
+    }
+
+    /**
+     * Sets the AWS error code represented by this exception.
+     *
+     * @param errorCode The AWS error code represented by this exception.
+     */
+    public void setErrorCode(final String errorCode) {
+        this.errorCode = errorCode;
+    }
+
+    /**
+     * Returns the AWS error code represented by this exception.
+     *
+     * @return The AWS error code represented by this exception.
+     */
+    public String getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Sets the type of error represented by this exception (sender, receiver,
+     * or unknown), indicating if this exception was the caller's fault, or the
+     * service's fault.
+     *
+     * @param errorType The type of error represented by this exception (sender
+     *            or receiver), indicating if this exception was the caller's
+     *            fault or the service's fault.
+     */
+    public void setErrorType(final ErrorType errorType) {
+        this.errorType = errorType;
+    }
+
+    /**
+     * Indicates who is responsible for this exception (caller, service, or
+     * unknown).
+     *
+     * @return A value indicating who is responsible for this exception (caller,
+     *         service, or unknown).
+     */
+    public ErrorType getErrorType() {
+        return errorType;
+    }
+
+    /**
+     * @return the human-readable error message provided by the service
+     */
+    public String getErrorMessage() {
+        return errorMessage;
+    }
+
+    /**
+     * Sets the HTTP status code that was returned with this service exception.
+     *
+     * @param statusCode The HTTP status code that was returned with this
+     *            service exception.
+     */
+    public void setStatusCode(final int statusCode) {
+        this.statusCode = statusCode;
+    }
+
+    /**
+     * Returns the HTTP status code that was returned with this service
+     * exception.
+     *
+     * @return The HTTP status code that was returned with this service
+     *         exception.
+     */
+    public int getStatusCode() {
+        return statusCode;
+    }
+
+    @Override
+    public String getMessage() {
+        return getErrorMessage()
+                + " (Service: " + getServiceName()
+                + "; Status Code: " + getStatusCode()
+                + "; Error Code: " + getErrorCode()
+                + "; Request ID: " + getRequestId() + ")";
+    }
+
+    /**
+     * @param errorMessage sets the error message.
+     */
+    public void setErrorMessage(final String errorMessage) {
+        this.errorMessage = errorMessage;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceClient.java
new file mode 100644
index 0000000000..39fa3afc56
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceClient.java
@@ -0,0 +1,849 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static com.amazonaws.SDKGlobalConfiguration.PROFILING_SYSTEM_PROPERTY;
+
+import com.amazonaws.auth.RegionAwareSigner;
+import com.amazonaws.auth.Signer;
+import com.amazonaws.auth.SignerFactory;
+import com.amazonaws.handlers.RequestHandler;
+import com.amazonaws.handlers.RequestHandler2;
+import com.amazonaws.http.AmazonHttpClient;
+import com.amazonaws.http.ExecutionContext;
+import com.amazonaws.http.HttpClient;
+import com.amazonaws.http.UrlHttpClient;
+import com.amazonaws.metrics.AwsSdkMetrics;
+import com.amazonaws.metrics.RequestMetricCollector;
+import com.amazonaws.regions.Region;
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+import com.amazonaws.util.AwsHostNameUtils;
+import com.amazonaws.util.Classes;
+import com.amazonaws.util.StringUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * Abstract base class for Amazon Web Service Java clients.
+ * <p>
+ * Responsible for basic client capabilities that are the same across all AWS
+ * SDK Java clients (ex: setting the client endpoint).
+ */
+public abstract class AmazonWebServiceClient {
+
+    /** Constant for Amazon. */
+    private static final String AMAZON = "Amazon";
+
+    /** Constant for AWS. */
+    private static final String AWS = "AWS";
+
+    /** Boolean for logging AWS request metrics. */
+    public static final boolean LOGGING_AWS_REQUEST_METRIC = true;
+
+    /** Log. */
+    private static final Log LOG =
+            LogFactory.getLog(AmazonWebServiceClient.class);
+
+    /**
+     * The service endpoint to which this client will send requests.
+     * <p>
+     * Subclass should only read but not assign to this field, at least not
+     * without synchronization on the enclosing object for thread-safety reason.
+     * </p>
+     */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    protected volatile URI endpoint;
+
+    /**
+     * Used to explicitly override the internal signer region computed by the
+     * default implementation. This field is typically null.
+     */
+    private volatile String signerRegionOverride;
+
+    /** The client configuration. */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    protected ClientConfiguration clientConfiguration;
+
+    /** Low level client for sending requests to AWS services. */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    protected AmazonHttpClient client;
+
+    /** Optional request handlers for additional request processing. */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    protected final List<RequestHandler2> requestHandler2s;
+
+    /** Optional offset (in seconds) to use when signing requests. */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    protected int timeOffset;
+
+    /** AWS signer for authenticating requests. */
+    private volatile Signer signer;
+
+    /**
+     * The cached service abbreviation for this service, used for identifying
+     * service endpoints by region, identifying the necessary signer, etc.
+     * Thread safe so it's backward compatible.
+     */
+    private volatile String serviceName;
+
+    protected volatile String endpointPrefix;
+
+    /**
+     * Constructs a new AmazonWebServiceClient object using the specified
+     * configuration.
+     *
+     * @param clientConfiguration The client configuration for this client.
+     */
+    protected AmazonWebServiceClient(
+            final ClientConfiguration clientConfiguration) {
+        this(clientConfiguration, new UrlHttpClient(clientConfiguration));
+    }
+
+    /**
+     * Constructs a new AmazonWebServiceClient object using the specified
+     * configuration and request metric collector.
+     *
+     * @param clientConfiguration The client configuration for this client.
+     * @param requestMetricCollector optional request metric collector to be
+     *            used at the http client level; can be null.
+     */
+    @Deprecated
+    protected AmazonWebServiceClient(
+            final ClientConfiguration clientConfiguration,
+            final RequestMetricCollector requestMetricCollector) {
+        this(clientConfiguration, new UrlHttpClient(clientConfiguration), null);
+    }
+
+    /**
+     * Constructs a new AmazonWebServiceClient object using the specified
+     * configuration.
+     *
+     * @param clientConfiguration The client configuration for this client.
+     * @param httpClient The HTTP client.
+     */
+    protected AmazonWebServiceClient(
+            final ClientConfiguration clientConfiguration,
+            final HttpClient httpClient) {
+        this.clientConfiguration = clientConfiguration;
+        client = new AmazonHttpClient(clientConfiguration, httpClient);
+        requestHandler2s = new CopyOnWriteArrayList<RequestHandler2>();
+    }
+
+    /**
+     * Constructs a new AmazonWebServiceClient object using the specified
+     * configuration.
+     *
+     * @param clientConfiguration The client configuration for this client.
+     * @param httpClient The HTTP client.
+     * @param requestMetricCollector optional request metric collector to be
+     *            used at the http client level; can be null.
+     */
+    @Deprecated
+    protected AmazonWebServiceClient(
+            final ClientConfiguration clientConfiguration,
+            final HttpClient httpClient,
+            final RequestMetricCollector requestMetricCollector) {
+        this.clientConfiguration = clientConfiguration;
+        client = new AmazonHttpClient(
+                clientConfiguration,
+                httpClient,
+                requestMetricCollector);
+        requestHandler2s = new CopyOnWriteArrayList<RequestHandler2>();
+    }
+
+    /**
+     * Returns the signer.
+     * <p>
+     * Note, however, the signer configured for S3 is incomplete at this stage
+     * as the information on the S3 bucket and key is not yet known.
+     * @return Signer.
+     */
+    protected Signer getSigner() {
+        return signer;
+    }
+
+    /**
+     * Overrides the default endpoint for this client. Callers can use this
+     * method to control which AWS region they want to work with.
+     * <p>
+     * <b>This method is not threadsafe. Endpoints should be configured when the
+     * client is created and before any service requests are made. Changing it
+     * afterwards creates inevitable race conditions for any service requests in
+     * transit.</b>
+     * <p>
+     * Callers can pass in just the endpoint (ex: "ec2.amazonaws.com") or a full
+     * URL, including the protocol (ex: "https://ec2.amazonaws.com"). If the
+     * protocol is not specified here, the default protocol from this client's
+     * {@link ClientConfiguration} will be used, which by default is HTTPS.
+     * <p>
+     * For more information on using AWS regions with the AWS SDK for Java, and
+     * a complete list of all available endpoints for all AWS services, see: <a
+     * href=
+     * "http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912"
+     * > http://developer.amazonwebservices.com/connect/entry.jspa?externalID=
+     * 3912</a>
+     *
+     * @param endpoint The endpoint (ex: "ec2.amazonaws.com") or a full URL,
+     *            including the protocol (ex: "https://ec2.amazonaws.com") of
+     *            the region specific AWS endpoint this client will communicate
+     *            with.
+     * @throws IllegalArgumentException If any problems are detected with the
+     *             specified endpoint.
+     */
+    public void setEndpoint(final String endpoint) {
+        final URI uri = toURI(endpoint);
+
+        @SuppressWarnings("checkstyle:hiddenfield")
+        final Signer signer = computeSignerByURI(uri, signerRegionOverride, false);
+        synchronized (this) {
+            this.endpoint = uri;
+            this.signer = signer;
+        }
+    }
+
+    /**
+     * Returns the endpoint for the service.
+     *
+     * @return the endpoint for the service.
+     */
+    public String getEndpoint() {
+        synchronized (this) {
+            return this.endpoint.toString();
+        }
+    }
+
+    /**
+     * Returns the endpoint prefix for the service.
+     *
+     * @return the endpoint prefix.
+     */
+    public String getEndpointPrefix() {
+        return endpointPrefix;
+    }
+
+    /**
+     * @param endpoint the endpoint.
+     * @return the endpoint as a URI.
+     */
+    @SuppressWarnings({"checkstyle:finalparameters", "checkstyle:hiddenfield"})
+    private URI toURI(String endpoint) {
+        /*
+         * If the endpoint doesn't explicitly specify a protocol to use, then
+         * we'll defer to the default protocol specified in the client
+         * configuration.
+         */
+        if (!endpoint.contains("://")) {
+            endpoint = clientConfiguration.getProtocol().toString() + "://" + endpoint;
+        }
+
+        try {
+            return new URI(endpoint);
+        } catch (final URISyntaxException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * An internal method that is not expected to be normally called except for
+     * AWS internal development purposes.
+     * <p>
+     * Overrides the default endpoint for this client
+     * ("http://dynamodb.us-east-1.amazonaws.com/") and explicitly provides an
+     * AWS region ID and AWS service name to use when the client calculates a
+     * signature for requests. In almost all cases, this region ID and service
+     * name are automatically determined from the endpoint, and callers should
+     * use the simpler one-argument form of setEndpoint instead of this method.
+     * <p>
+     * Callers can pass in just the endpoint (ex:
+     * "dynamodb.us-east-1.amazonaws.com/") or a full URL, including the
+     * protocol (ex: "http://dynamodb.us-east-1.amazonaws.com/"). If the
+     * protocol is not specified here, the default protocol from this client's
+     * {@link ClientConfiguration} will be used, which by default is HTTPS.
+     * <p>
+     * For more information on using AWS regions with the AWS SDK for Java, and
+     * a complete list of all available endpoints for all AWS services, see: <a
+     * href=
+     * "http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912"
+     * > http://developer.amazonwebservices.com/connect/entry.jspa?externalID=
+     * 3912</a>
+     *
+     * @param endpoint The endpoint (ex: "dynamodb.us-east-1.amazonaws.com/") or
+     *            a full URL, including the protocol (ex:
+     *            "http://dynamodb.us-east-1.amazonaws.com/") of the region
+     *            specific AWS endpoint this client will communicate with.
+     * @param serviceName This parameter is ignored.
+     * @param regionId The ID of the region in which this service resides AND
+     *            the overriding region for signing purposes.
+     * @throws IllegalArgumentException If any problems are detected with the
+     *             specified endpoint.
+     */
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setEndpoint(final String endpoint,
+                            final String serviceName,
+                            final String regionId) {
+        final URI uri = toURI(endpoint);
+        final Signer signer = computeSignerByServiceRegion(serviceName, regionId,
+                regionId, true);
+        synchronized (this) {
+            this.signer = signer;
+            this.endpoint = uri;
+            this.signerRegionOverride = regionId;
+        }
+    }
+
+    /**
+     * @deprecated this method is now a no-op, as overriding the signer from
+     *             sublcass is no longer supported.
+     */
+    @Deprecated
+    protected void configSigner(final URI uri) {
+    }
+
+    /**
+     * @deprecated this method is now a no-op, as overriding the signer from
+     *             sublcass is no longer supported.
+     */
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    protected void configSigner(final String serviceName, String regionId) {
+    }
+
+    /**
+     * Returns the signer based on the given URI and the current AWS client
+     * configuration. Currently only the SQS client can have different region on
+     * a per request basis. For other AWS clients, the region remains the same
+     * on a per AWS client level.
+     * <p>
+     * Note, however, the signer returned for S3 is incomplete at this stage as
+     * the information on the S3 bucket and key is not yet known.
+     * @param uri the URI.
+     * @return the signer based on the given URI and the current AWS client configuration.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Signer getSignerByURI(final URI uri) {
+        return computeSignerByURI(uri, signerRegionOverride, true);
+    }
+
+    /**
+     * Returns the signer for the given uri and the current client
+     * configuration.
+     * <p>
+     * Note, however, the signer returned for S3 is incomplete at this stage as
+     * the information on the S3 bucket and key is not yet known.
+     *
+     * @param signerRegionOverride the overriding signer region; or null if
+     *            there is none.
+     * @param isRegionIdAsSignerParam true if the "regionId" is used to
+     *            configure the signer if applicable; false if this method is
+     *            called for the purpose of purely setting the communication end
+     *            point of this AWS client, and therefore the "regionId"
+     *            parameter will not be used directly for configuring the
+     *            signer.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    private Signer computeSignerByURI(final URI uri, String signerRegionOverride,
+            boolean isRegionIdAsSignerParam) {
+        if (uri == null) {
+            throw new IllegalArgumentException(
+                    "Endpoint is not set. Use setEndpoint to set an endpoint before performing any request.");
+        }
+        final String service = getServiceNameIntern();
+        final String region = AwsHostNameUtils.parseRegionName(uri.getHost(), service);
+        return computeSignerByServiceRegion(
+                service, region, signerRegionOverride, isRegionIdAsSignerParam);
+    }
+
+    /**
+     * Returns the signer for the given service name, region id, and the current
+     * client configuration.
+     * <p>
+     * Note, however, the signer returned for S3 is incomplete at this stage as
+     * the information on the S3 bucket and key is not yet known.
+     *
+     * @param regionId the region for sending AWS requests
+     * @param signerRegionOverride the overriding signer region; or null if
+     *            there is none.
+     * @param isRegionIdAsSignerParam true if the "regionId" is used to
+     *            configure the signer if applicable; false if this method is
+     *            called for the purpose of purely setting the communication end
+     *            point of this AWS client, and therefore the "regionId"
+     *            parameter will not be used directly for configuring the
+     *            signer.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    private Signer computeSignerByServiceRegion(
+            final String serviceName, final String regionId,
+            final String signerRegionOverride,
+            final boolean isRegionIdAsSignerParam) {
+        final String signerType = clientConfiguration.getSignerOverride();
+        final Signer signer = signerType == null
+                ? SignerFactory.getSigner(serviceName, regionId)
+                : SignerFactory.getSignerByTypeAndService(signerType, serviceName);
+        if (signer instanceof RegionAwareSigner) {
+            // Overrides the default region computed
+            final RegionAwareSigner regionAwareSigner = (RegionAwareSigner) signer;
+            // (signerRegionOverride != null) means that it is likely to be AWS
+            // internal dev work, as "signerRegionOverride" is typically null
+            // when used in the external release
+            if (signerRegionOverride != null) {
+                regionAwareSigner.setRegionName(signerRegionOverride);
+            } else if (regionId != null && isRegionIdAsSignerParam) {
+                regionAwareSigner.setRegionName(regionId);
+            }
+        }
+        return signer;
+    }
+
+    /**
+     * An alternative to {@link AmazonWebServiceClient#setEndpoint(String)},
+     * sets the regional endpoint for this client's service calls. Callers can
+     * use this method to control which AWS region they want to work with.
+     * <p>
+     * <b>This method is not threadsafe. A region should be configured when the
+     * client is created and before any service requests are made. Changing it
+     * afterwards creates inevitable race conditions for any service requests in
+     * transit or retrying.</b>
+     * <p>
+     * By default, all service endpoints in all regions use the https protocol.
+     * To use http instead, specify it in the {@link ClientConfiguration}
+     * supplied at construction.
+     *
+     * @param region The region this client will communicate with. See
+     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
+     *            accessing a given region.
+     * @throws java.lang.IllegalArgumentException If the given region is null,
+     *             or if this service isn't available in the given region. See
+     *             {@link Region#isServiceSupported(String)}
+     * @see Region#getRegion(com.amazonaws.regions.Regions)
+     * @see Region#createClient(Class,
+     *      com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setRegion(final Region region) {
+        if (region == null) {
+            throw new IllegalArgumentException("No region provided");
+        }
+
+        final String serviceName = getServiceNameIntern();
+        String serviceEndpoint;
+
+        if (region.isServiceSupported(serviceName)) {
+            serviceEndpoint = region.getServiceEndpoint(serviceName);
+            final int protocolIdx = serviceEndpoint.indexOf("://");
+            // Strip off the protocol to allow the client config to specify it
+            if (protocolIdx >= 0) {
+                serviceEndpoint = serviceEndpoint.substring(protocolIdx + "://".length());
+            }
+        } else {
+            serviceEndpoint = String.format("%s.%s.%s",
+                getEndpointPrefix(),
+                region.getName(),
+                region.getDomain());
+
+        }
+
+        final URI uri = toURI(serviceEndpoint);
+        final Signer signer = computeSignerByServiceRegion(serviceName,
+                region.getName(), signerRegionOverride, false);
+        synchronized (this) {
+            this.endpoint = uri;
+            this.signer = signer;
+        }
+    }
+
+
+
+    /**
+     * @deprecated by client configuration via the constructor. This method will
+     *             be removed later on.
+     * @param clientConfiguration the client configuration.
+     */
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setConfiguration(final ClientConfiguration clientConfiguration) {
+        final AmazonHttpClient existingClient = this.client;
+        RequestMetricCollector requestMetricCollector = null;
+        if (existingClient != null) {
+            requestMetricCollector = existingClient.getRequestMetricCollector();
+            existingClient.shutdown();
+        }
+        this.clientConfiguration = clientConfiguration;
+        this.client = new AmazonHttpClient(clientConfiguration, requestMetricCollector);
+    }
+
+    /**
+     * Shuts down this client object, releasing any resources that might be held
+     * open. This is an optional method, and callers are not expected to call
+     * it, but can if they want to explicitly release any open resources. Once a
+     * client has been shutdown, it should not be used to make any more
+     * requests.
+     */
+    public void shutdown() {
+        client.shutdown();
+    }
+
+    /**
+     * @deprecated by {@link #addRequestHandler(RequestHandler2)}. Appends a
+     *             request handler to the list of registered handlers that are
+     *             run as part of a request's lifecycle.
+     * @param requestHandler The new handler to add to the current list of
+     *            request handlers.
+     */
+    @Deprecated
+    public void addRequestHandler(final RequestHandler requestHandler) {
+        requestHandler2s.add(RequestHandler2.adapt(requestHandler));
+    }
+
+    /**
+     * Appends a request handler to the list of registered handlers that are run
+     * as part of a request's lifecycle.
+     *
+     * @param requestHandler2 The new handler to add to the current list of
+     *            request handlers.
+     */
+    public void addRequestHandler(final RequestHandler2 requestHandler2) {
+        requestHandler2s.add(requestHandler2);
+    }
+
+    /**
+     * Removes a request handler from the list of registered handlers that are
+     * run as part of a request's lifecycle.
+     *
+     * @param requestHandler The handler to remove from the current list of
+     *            request handlers.
+     */
+    @Deprecated
+    public void removeRequestHandler(final RequestHandler requestHandler) {
+        requestHandler2s.remove(RequestHandler2.adapt(requestHandler));
+    }
+
+    /**
+     * Removes a request handler from the list of registered handlers that are
+     * run as part of a request's lifecycle.
+     *
+     * @param requestHandler2 The handler to remove from the current list of
+     *            request handlers.
+     */
+    public void removeRequestHandler(final RequestHandler2 requestHandler2) {
+        requestHandler2s.remove(requestHandler2);
+    }
+
+    protected ExecutionContext createExecutionContext(final AmazonWebServiceRequest req) {
+        final boolean isMetricsEnabled = isRequestMetricsEnabled(req) || isProfilingEnabled();
+        return new ExecutionContext(requestHandler2s, isMetricsEnabled, this);
+    }
+
+    protected final ExecutionContext createExecutionContext(final Request<?> req) {
+        return createExecutionContext(req.getOriginalRequest());
+    }
+
+    /**
+     * @deprecated by {@link #createExecutionContext(AmazonWebServiceRequest)}.
+     *             This method exists only for backward compatiblity reason, so
+     *             that clients compiled against the older version of this class
+     *             won't get {@link NoSuchMethodError} at runtime. However,
+     *             calling this methods would effectively ignore and disable the
+     *             request metric collector, if any, specified at the request
+     *             level. Request metric collector specified at the service
+     *             client or AWS SDK level will still be honored.
+     */
+    @Deprecated
+    protected final ExecutionContext createExecutionContext() {
+        final boolean isMetricsEnabled = isRMCEnabledAtClientOrSdkLevel() || isProfilingEnabled();
+        return new ExecutionContext(requestHandler2s, isMetricsEnabled, this);
+    }
+
+    /* Check the profiling system property and return true if set */
+    @Deprecated
+    protected static boolean isProfilingEnabled() {
+        return System.getProperty(PROFILING_SYSTEM_PROPERTY) != null;
+    }
+
+    /**
+     * Returns true if request metric collection is applicable to the given
+     * request; false otherwise.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    protected final boolean isRequestMetricsEnabled(final AmazonWebServiceRequest req) {
+        final RequestMetricCollector c = req.getRequestMetricCollector(); // request
+                                                                    // level
+                                                                    // collector
+        if (c != null && c.isEnabled()) {
+            return true;
+        }
+        return isRMCEnabledAtClientOrSdkLevel();
+    }
+
+    /**
+     * Returns true if request metric collection is enabled at the service
+     * client or AWS SDK level request; false otherwise.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    private boolean isRMCEnabledAtClientOrSdkLevel() {
+        final RequestMetricCollector c = requestMetricCollector();
+        return c != null && c.isEnabled();
+    }
+
+    /**
+     * Sets the optional value for time offset for this client. This value will
+     * be applied to all requests processed through this client. Value is in
+     * seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     *
+     * @param timeOffset The optional value for time offset (in seconds) for
+     *            this client.
+     */
+    public void setTimeOffset(final int timeOffset) {
+        this.timeOffset = timeOffset;
+    }
+
+    /**
+     * Sets the optional value for time offset for this client. This value will
+     * be applied to all requests processed through this client. Value is in
+     * seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     *
+     * @param timeOffset The optional value for time offset (in seconds) for
+     *            this client.
+     * @return the updated web service client
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public AmazonWebServiceClient withTimeOffset(final int timeOffset) {
+        setTimeOffset(timeOffset);
+        return this;
+    }
+
+    /**
+     * Returns the optional value for time offset for this client. This value
+     * will be applied to all requests processed through this client. Value is
+     * in seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     *
+     * @return The optional value for time offset (in seconds) for this client.
+     */
+    public int getTimeOffset() {
+        return timeOffset;
+    }
+
+    /**
+     * @return the client specific {@link RequestMetricCollector}; or null if
+     * there is none.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    public RequestMetricCollector getRequestMetricsCollector() {
+        return client.getRequestMetricCollector();
+    }
+
+    /**
+     * @return the client specific request metric collector if there is one; or
+     * the one at the AWS SDK level otherwise.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    protected RequestMetricCollector requestMetricCollector() {
+        final RequestMetricCollector mc = client.getRequestMetricCollector();
+        return mc == null ? AwsSdkMetrics.getRequestMetricCollector() : mc;
+    }
+
+    /**
+     * @return the most specific request metric collector, starting from the
+     * request level, then client level, then finally the AWS SDK level.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    protected final RequestMetricCollector findRequestMetricCollector(final Request<?> req) {
+        final AmazonWebServiceRequest origReq = req.getOriginalRequest();
+        RequestMetricCollector mc = origReq.getRequestMetricCollector();
+        if (mc != null) {
+            return mc;
+        }
+        mc = getRequestMetricsCollector();
+        return mc == null ? AwsSdkMetrics.getRequestMetricCollector() : mc;
+    }
+
+    /**
+     * Convenient method to end the client execution without logging the
+     * awsRequestMetrics.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    protected final void endClientExecution(
+            final AWSRequestMetrics awsRequestMetrics,
+            final Request<?> request,
+            final Response<?> response) {
+        this.endClientExecution(awsRequestMetrics, request, response,
+                !LOGGING_AWS_REQUEST_METRIC);
+    }
+
+    /**
+     * Common routine to end a client AWS request/response execution and collect
+     * the request metrics. Caller of this routine is responsible for starting
+     * the event for {@link Field#ClientExecuteTime} and call this method in a
+     * try-finally block.
+     *
+     * @param loggingAwsRequestMetrics true to LOG the awsRequestMetrics; false
+     *            otherwise.
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    protected final void endClientExecution(
+            AWSRequestMetrics awsRequestMetrics, Request<?> request,
+            Response<?> response, boolean loggingAwsRequestMetrics) {
+        if (request != null) {
+            awsRequestMetrics.endEvent(Field.ClientExecuteTime);
+            awsRequestMetrics.getTimingInfo().endTiming();
+            final RequestMetricCollector c = findRequestMetricCollector(request);
+            c.collectMetrics(request, response);
+        }
+        if (loggingAwsRequestMetrics) {
+            awsRequestMetrics.log();
+        }
+    }
+
+    /**
+     * @deprecated by {@link #getServiceName()}.
+     */
+    @Deprecated
+    protected String getServiceAbbreviation() {
+        return getServiceNameIntern();
+    }
+
+    /**
+     * @return the service abbreviation for this service, used for identifying
+     * service endpoints by region, identifying the necessary signer, etc. Used
+     * to be call "getServiceAbbreviation".
+     */
+    public String getServiceName() {
+        return getServiceNameIntern();
+    }
+
+    /**
+     * Internal method for implementing {@link #getServiceName()}. Method is
+     * protected by intent so peculiar subclass that don't follow the class
+     * naming convention can choose to return whatever service name as needed.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    protected String getServiceNameIntern() {
+        if (serviceName == null) {
+            synchronized (this) {
+                if (serviceName == null) {
+                    serviceName = computeServiceName();
+                    return serviceName;
+                }
+            }
+        }
+        return serviceName;
+    }
+
+    /**
+     * An internal method used to explicitly override the service name computed
+     * by the default implementation. This method is not expected to be normally
+     * called except for AWS internal development purposes.
+     * @param serviceName the service name.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public final void setServiceNameIntern(final String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    /**
+     * Returns the service name of this AWS http client by first looking it up
+     * from the SDK internal configuration, and if not found, derive it from the
+     * class name of the immediate subclass of {@link AmazonWebServiceClient}.
+     * No configuration is necessary if the simple class name of the http client
+     * follows the convention of <code>(Amazon|AWS).*(JavaClient|Client)</code>.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    private String computeServiceName() {
+        final Class<?> httpClientClass = Classes.childClassOf(
+                AmazonWebServiceClient.class, this);
+        final String httpClientName = httpClientClass.getSimpleName();
+        final String service = ServiceNameFactory.getServiceName(httpClientName);
+        if (service != null) {
+            return service; // only if it is so explicitly configured
+        }
+        // Otherwise, make use of convention over configuration
+        int j = httpClientName.indexOf("JavaClient");
+        if (j == -1) {
+            j = httpClientName.indexOf("Client");
+            if (j == -1) {
+                throw new IllegalStateException(
+                        "Unrecognized suffix for the AWS http client class name "
+                                + httpClientName);
+            }
+        }
+        int i = httpClientName.indexOf(AMAZON);
+        int len;
+        if (i == -1) {
+            i = httpClientName.indexOf(AWS);
+            if (i == -1) {
+                throw new IllegalStateException(
+                        "Unrecognized prefix for the AWS http client class name "
+                                + httpClientName);
+            }
+            len = AWS.length();
+        } else {
+            len = AMAZON.length();
+        }
+        if (i >= j) {
+            throw new IllegalStateException(
+                    "Unrecognized AWS http client class name " + httpClientName);
+        }
+        final String serviceName = httpClientName.substring(i + len, j);
+        return StringUtils.lowerCase(serviceName);
+    }
+
+    /**
+     * @return the signer region override.
+     *
+     * @see #setSignerRegionOverride(String).
+     */
+    public final String getSignerRegionOverride() {
+        return signerRegionOverride;
+    }
+
+    /**
+     * An internal method used to explicitly override the internal signer region
+     * computed by the default implementation. This method is not expected to be
+     * normally called except for AWS internal development purposes.
+     * @param signerRegionOverride  the signer region override.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public final void setSignerRegionOverride(final String signerRegionOverride) {
+        final Signer signer = computeSignerByURI(endpoint, signerRegionOverride, true);
+        synchronized (this) {
+            this.signer = signer;
+            this.signerRegionOverride = signerRegionOverride;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceRequest.java
new file mode 100644
index 0000000000..6922ef71c6
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceRequest.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.event.ProgressListener;
+import com.amazonaws.metrics.RequestMetricCollector;
+
+/**
+ * Base class for all user facing web service requests.
+ */
+public abstract class AmazonWebServiceRequest implements Cloneable {
+
+    /**
+     * The optional progress listener for receiving updates about object
+     * download status.
+     */
+    private ProgressListener generalProgressListener;
+
+    /**
+     * Arbitrary options storage for individual {@link AmazonWebServiceRequest}
+     * s. This field is not intended to be used by clients.
+     */
+    private final RequestClientOptions requestClientOptions = new RequestClientOptions();
+
+    /**
+     * A request metric collector used for this specific service request; or
+     * null if there is none. This collector always takes precedence over the
+     * ones specified at the http client level and AWS SDK level.
+     */
+    @Deprecated
+    private RequestMetricCollector requestMetricCollector;
+
+    /**
+     * The optional credentials to use for this request - overrides the default
+     * credentials set at the client level.
+     */
+    private AWSCredentials credentials;
+
+    /**
+     * Sets the optional credentials to use for this request, overriding the
+     * default credentials set at the client level.
+     *
+     * @param credentials The optional AWS security credentials to use for this
+     *            request, overriding the default credentials set at the client
+     *            level.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setRequestCredentials(AWSCredentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * Returns the optional credentials to use to sign this request, overriding
+     * the default credentials set at the client level.
+     *
+     * @return The optional credentials to use to sign this request, overriding
+     *         the default credentials set at the client level.
+     */
+    public AWSCredentials getRequestCredentials() {
+        return credentials;
+    }
+
+    /**
+     * @return the options stored with this request object. Intended for internal
+     * use only.
+     */
+    public RequestClientOptions getRequestClientOptions() {
+        return requestClientOptions;
+    }
+
+    /**
+     * @return a request level metric collector; or null if not specified.
+     *
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    public RequestMetricCollector getRequestMetricCollector() {
+        return requestMetricCollector;
+    }
+
+    /**
+     * Sets a request level request metric collector which takes precedence over
+     * the ones at the http client level and AWS SDK level.
+     *
+     * @param requestMetricCollector the request metric collector.
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    public void setRequestMetricCollector(RequestMetricCollector requestMetricCollector) {
+        this.requestMetricCollector = requestMetricCollector;
+    }
+
+    /**
+     * Specifies a request level metric collector which takes precedence over
+     * the ones at the http client level and AWS SDK level.
+     *
+     * @param metricCollector the request metric collector.
+     * @param <T> class type.
+     * @return this for method chaining.
+     * @deprecated metrics is deprecated
+     */
+    @Deprecated
+    public <T extends AmazonWebServiceRequest> T withRequestMetricCollector(
+            RequestMetricCollector metricCollector) {
+        setRequestMetricCollector(metricCollector);
+        @SuppressWarnings("unchecked")
+        final T t = (T) this;
+        return t;
+    }
+
+    /**
+     * Sets the optional progress listener for receiving updates about object
+     * upload status.
+     *
+     * @param generalProgressListener The new progress listener.
+     */
+    public void setGeneralProgressListener(ProgressListener generalProgressListener) {
+        this.generalProgressListener = generalProgressListener;
+    }
+
+    /**
+     * Returns the optional progress listener for receiving updates about object
+     * upload status.
+     *
+     * @return the optional progress listener for receiving updates about object
+     *         upload status.
+     */
+    public ProgressListener getGeneralProgressListener() {
+        return generalProgressListener;
+    }
+
+    /**
+     * Sets the optional progress listener for receiving updates about the progress of the request,
+     * and returns a reference to this object so that method calls can be chained together.
+     *
+     * @param generalProgressListener The new progress listener.
+     * @param <T> class type.
+     * @return This updated PutObjectRequest object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public <T extends AmazonWebServiceRequest> T withGeneralProgressListener(
+            ProgressListener generalProgressListener) {
+        setGeneralProgressListener(generalProgressListener);
+        @SuppressWarnings("unchecked")
+        final T t = (T) this;
+        return t;
+    }
+
+    /**
+     * Copies the internal state of this base class to that of the target
+     * request.
+     *
+     * @return the target request
+     */
+    protected final <T extends AmazonWebServiceRequest> T copyBaseTo(T target) {
+        target.setGeneralProgressListener(this.generalProgressListener);
+        target.setRequestMetricCollector(requestMetricCollector);
+        return target;
+    }
+
+    /**
+     * The source object from which the current object was cloned; or null if
+     * there isn't one.
+     */
+    private AmazonWebServiceRequest cloneSource;
+
+    /**
+     * @return the source object from which the current object was cloned; or
+     * null if there isn't one.
+     */
+    public AmazonWebServiceRequest getCloneSource() {
+        return cloneSource;
+    }
+
+    /**
+     * @return the root object from which the current object was cloned; or null
+     * if there isn't one.
+     */
+    public AmazonWebServiceRequest getCloneRoot() {
+        AmazonWebServiceRequest cloneRoot = cloneSource;
+        if (cloneRoot != null) {
+            while (cloneRoot.getCloneSource() != null) {
+                cloneRoot = cloneRoot.getCloneSource();
+            }
+        }
+        return cloneRoot;
+    }
+
+    private void setCloneSource(AmazonWebServiceRequest cloneSource) {
+        this.cloneSource = cloneSource;
+    }
+
+    /**
+     * Creates a shallow clone of this request. Explicitly does <em>not</em>
+     * clone the deep structure of the request object.
+     *
+     * @see Object#clone()
+     */
+    @Override
+    public AmazonWebServiceRequest clone() {
+        try {
+            final AmazonWebServiceRequest cloned = (AmazonWebServiceRequest) super.clone();
+            cloned.setCloneSource(this);
+            return cloned;
+        } catch (final CloneNotSupportedException e) {
+            throw new IllegalStateException(
+                    "Got a CloneNotSupportedException from Object.clone() "
+                            + "even though we're Cloneable!",
+                    e);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceResponse.java b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceResponse.java
new file mode 100644
index 0000000000..b8dd2cb4e8
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/AmazonWebServiceResponse.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * Represents the response from an AWS service, including the result payload and
+ * any response metadata. AWS response metadata consists primarily of the AWS
+ * request ID, which can be used for debugging purposes when services aren't
+ * acting as expected.
+ *
+ * @param <T> The type of result contained by this response.
+ */
+public class AmazonWebServiceResponse<T> {
+
+    /** The result contained by this response */
+    private T result;
+
+    /** Additional AWS metadata for this response */
+    private ResponseMetadata responseMetadata;
+
+    /**
+     * Returns the result contained by this response.
+     *
+     * @return The result contained by this response.
+     */
+    public T getResult() {
+        return result;
+    }
+
+    /**
+     * Sets the result contained by this response.
+     *
+     * @param result The result contained by this response.
+     */
+    public void setResult(T result) {
+        this.result = result;
+    }
+
+    /**
+     * Sets the response metadata associated with this response.
+     *
+     * @param responseMetadata The response metadata for this response.
+     */
+    public void setResponseMetadata(ResponseMetadata responseMetadata) {
+        this.responseMetadata = responseMetadata;
+    }
+
+    /**
+     * Returns the response metadata for this response. Response metadata
+     * provides additional information about a response that isn't necessarily
+     * directly part of the data the service is returning. Response metadata is
+     * primarily used for debugging issues with AWS support when a service isn't
+     * working as expected.
+     *
+     * @return The response metadata for this response.
+     */
+    public ResponseMetadata getResponseMetadata() {
+        return responseMetadata;
+    }
+
+    /**
+     * Returns the AWS request ID from the response metadata section of an AWS
+     * response.
+     *
+     * @return The AWS request ID from the response metadata section of an AWS
+     *         response.
+     */
+    public String getRequestId() {
+        if (responseMetadata == null)
+            return null;
+        return responseMetadata.getRequestId();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/ClientConfiguration.java b/aws-java-sdk-core/src/main/java/com/amazonaws/ClientConfiguration.java
new file mode 100644
index 0000000000..debe3229c8
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/ClientConfiguration.java
@@ -0,0 +1,1135 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.http.IdleConnectionReaper;
+import com.amazonaws.retry.PredefinedRetryPolicies;
+import com.amazonaws.retry.RetryPolicy;
+import com.amazonaws.util.VersionInfoUtils;
+
+import java.net.InetAddress;
+
+import javax.net.ssl.TrustManager;
+
+/**
+ * Client configuration options such as proxy settings, user agent string, max
+ * retry attempts, etc.
+ */
+public class ClientConfiguration {
+
+    /** The default timeout for creating new connections. */
+    public static final int DEFAULT_CONNECTION_TIMEOUT = 15 * 1000;
+
+    /** The default timeout for reading from a connected socket. */
+    public static final int DEFAULT_SOCKET_TIMEOUT = 15 * 1000;
+
+    /** The default max connection pool size. */
+    public static final int DEFAULT_MAX_CONNECTIONS = 10;
+
+    /** The default HTTP user agent header for AWS Java SDK clients. */
+    public static final String DEFAULT_USER_AGENT = VersionInfoUtils.getUserAgent();
+
+    /**
+     * Default request retry policy, including the maximum retry count of 3, the
+     * default retry condition and the default back-off strategy.
+     * <p>
+     * Note this default policy might be overridden by a service-specific
+     * default policy, if the user doesn't provide a custom RetryPolicy
+     * implementation by {@link #setRetryPolicy(RetryPolicy)}. For example,
+     * AmazonDynamoDBClient by default uses a different retry policy
+     * {@link PredefinedRetryPolicies#DYNAMODB_DEFAULT}.
+     *
+     * @see PredefinedRetryPolicies#DEFAULT
+     * @see PredefinedRetryPolicies#DYNAMODB_DEFAULT
+     */
+    public static final RetryPolicy DEFAULT_RETRY_POLICY = PredefinedRetryPolicies.DEFAULT;
+
+    /**
+     * The default on whether to use the {@link IdleConnectionReaper} to manage
+     * stale connections
+     *
+     * @see IdleConnectionReaper
+     */
+    public static final boolean DEFAULT_USE_REAPER = true;
+
+    /** The HTTP user agent header passed with all HTTP requests. */
+    private String userAgent = DEFAULT_USER_AGENT;
+
+    /**
+     * The maximum number of times that a retryable failed request (ex: a 5xx
+     * response from a service) will be retried. Or -1 if the user has not
+     * explicitly set this value, in which case the configured RetryPolicy will
+     * be used to control the retry count.
+     */
+    private int maxErrorRetry = -1;
+
+    /** The retry policy upon failed requests. **/
+    private RetryPolicy retryPolicy = DEFAULT_RETRY_POLICY;
+
+    /** Optionally specifies the local address to bind to */
+    private InetAddress localAddress;
+
+    /**
+     * The protocol to use when connecting to Amazon Web Services.
+     * <p>
+     * The default configuration is to use HTTPS for all requests for increased
+     * security.
+     */
+    private Protocol protocol = Protocol.HTTPS;
+
+    /** Optionally specifies the proxy host to connect through. */
+    private String proxyHost = null;
+
+    /** Optionally specifies the port on the proxy host to connect through. */
+    private int proxyPort = -1;
+
+    /**
+     * Optionally specifies the user name to use when connecting through a
+     * proxy.
+     */
+    private String proxyUsername = null;
+
+    /**
+     * Optionally specifies the password to use when connecting through a proxy.
+     */
+    private String proxyPassword = null;
+
+    /** Optional Windows domain name for configuring NTLM proxy support. */
+    @Deprecated
+    private String proxyDomain = null;
+
+    /** Optional Windows workstation name for configuring NTLM proxy support. */
+    @Deprecated
+    private String proxyWorkstation = null;
+
+    /**
+     * Whether to pre-emptively authenticate against a proxy server using basic
+     * authentication
+     */
+    private boolean preemptiveBasicProxyAuth;
+
+    /** The maximum number of open HTTP connections. */
+    private int maxConnections = DEFAULT_MAX_CONNECTIONS;
+
+    /**
+     * The amount of time to wait (in milliseconds) for data to be transfered
+     * over an established, open connection before the connection is timed out.
+     * A value of 0 means infinity, and is not recommended.
+     */
+    private int socketTimeout = DEFAULT_SOCKET_TIMEOUT;
+
+    /**
+     * The amount of time to wait (in milliseconds) when initially establishing
+     * a connection before giving up and timing out. A value of 0 means
+     * infinity, and is not recommended.
+     */
+    private int connectionTimeout = DEFAULT_CONNECTION_TIMEOUT;
+
+    /**
+     * Optional size hint (in bytes) for the low level TCP send buffer. This is
+     * an advanced option for advanced users who want to tune low level TCP
+     * parameters to try and squeeze out more performance.
+     */
+    private int socketSendBufferSizeHint = 0;
+
+    /**
+     * Optional size hint (in bytes) for the low level TCP receive buffer. This
+     * is an advanced option for advanced users who want to tune low level TCP
+     * parameters to try and squeeze out more performance.
+     */
+    private int socketReceiveBufferSizeHint = 0;
+
+    /**
+     * Optional whether to use the {@link IdleConnectionReaper} to manage stale
+     * connections. A reason for not running the {@link IdleConnectionReaper}
+     * can be if running in an environment where the modifyThread and
+     * modifyThreadGroup permissions are not allowed.
+     */
+    private boolean useReaper = DEFAULT_USE_REAPER;
+
+    /**
+     * Optional override to control which signature algorithm should be used to
+     * sign requests to the service. If not explicitly set, the client will
+     * determine the algorithm to use by inspecting a configuration file baked
+     * in to the SDK.
+     */
+    private String signerOverride;
+
+    /**
+     * Optional override to control how to perform authentication for secure
+     * connections.
+     */
+    private TrustManager trustManager = null;
+
+    /**
+     * Enable/disable logging.
+     */
+    private boolean curlLogging = false;
+
+    /**
+     * Optional whether to use gzip compression when making HTTP requests.
+     */
+    private boolean enableGzip = false;
+
+    /**
+     * Constructor.
+     */
+    public ClientConfiguration() {
+    }
+
+    /**
+     * Constructor.
+     * @param other the client configuration.
+     */
+    public ClientConfiguration(ClientConfiguration other) {
+        this.connectionTimeout = other.connectionTimeout;
+        this.maxConnections = other.maxConnections;
+        this.maxErrorRetry = other.maxErrorRetry;
+        this.retryPolicy = other.retryPolicy;
+        this.localAddress = other.localAddress;
+        this.protocol = other.protocol;
+        this.proxyDomain = other.proxyDomain;
+        this.proxyHost = other.proxyHost;
+        this.proxyPassword = other.proxyPassword;
+        this.proxyPort = other.proxyPort;
+        this.proxyUsername = other.proxyUsername;
+        this.proxyWorkstation = other.proxyWorkstation;
+        this.preemptiveBasicProxyAuth = other.preemptiveBasicProxyAuth;
+        this.socketTimeout = other.socketTimeout;
+        this.userAgent = other.userAgent;
+        this.useReaper = other.useReaper;
+        this.socketReceiveBufferSizeHint = other.socketReceiveBufferSizeHint;
+        this.socketSendBufferSizeHint = other.socketSendBufferSizeHint;
+        this.signerOverride = other.signerOverride;
+        this.trustManager = other.trustManager;
+        this.curlLogging = other.curlLogging;
+        this.enableGzip = other.enableGzip;
+    }
+
+    /**
+     * Returns the protocol (HTTP or HTTPS) to use when connecting to Amazon Web
+     * Services.
+     * <p>
+     * The default configuration is to use HTTPS for all requests for increased
+     * security.
+     * <p>
+     * Individual clients can also override this setting by explicitly including
+     * the protocol as part of the endpoint URL when calling
+     * {@link AmazonWebServiceClient#setEndpoint(String)}.
+     *
+     * @return The protocol to use when connecting to Amazon Web Services.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Protocol getProtocol() {
+        return protocol;
+    }
+
+    /**
+     * Sets the protocol (i.e. HTTP or HTTPS) to use when connecting to Amazon
+     * Web Services.
+     * <p>
+     * The default configuration is to use HTTPS for all requests for increased
+     * security.
+     * <p>
+     * Individual clients can also override this setting by explicitly including
+     * the protocol as part of the endpoint URL when calling
+     * {@link AmazonWebServiceClient#setEndpoint(String)}.
+     *
+     * @param protocol The protocol to use when connecting to Amazon Web
+     *            Services.
+     */
+    public void setProtocol(Protocol protocol) {
+        this.protocol = protocol;
+    }
+
+    /**
+     * Sets the protocol (i.e. HTTP or HTTPS) to use when connecting to Amazon
+     * Web Services, and returns the updated ClientConfiguration object so that
+     * additional calls may be chained together.
+     * <p>
+     * The default configuration is to use HTTPS for all requests for increased
+     * security.
+     * <p>
+     * Individual clients can also override this setting by explicitly including
+     * the protocol as part of the endpoint URL when calling
+     * {@link AmazonWebServiceClient#setEndpoint(String)}.
+     *
+     * @param protocol The protocol to use when connecting to Amazon Web
+     *            Services.
+     * @return The updated ClientConfiguration object with the new max HTTP
+     *         connections setting.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProtocol(Protocol protocol) {
+        setProtocol(protocol);
+        return this;
+    }
+
+    /**
+     * Returns the maximum number of allowed open HTTP connections.
+     *
+     * @return The maximum number of allowed open HTTP connections.
+     */
+    public int getMaxConnections() {
+        return maxConnections;
+    }
+
+    /**
+     * Sets the maximum number of allowed open HTTP connections.
+     *
+     * @param maxConnections The maximum number of allowed open HTTP
+     *            connections.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setMaxConnections(int maxConnections) {
+        this.maxConnections = maxConnections;
+    }
+
+    /**
+     * Sets the maximum number of allowed open HTTP connections and returns the
+     * updated ClientConfiguration object.
+     *
+     * @param maxConnections The maximum number of allowed open HTTP
+     *            connections.
+     * @return The updated ClientConfiguration object with the new max HTTP
+     *         connections setting.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withMaxConnections(int maxConnections) {
+        setMaxConnections(maxConnections);
+        return this;
+    }
+
+    /**
+     * Returns the HTTP user agent header to send with all requests.
+     *
+     * @return The user agent string to use when sending requests.
+     */
+    public String getUserAgent() {
+        return userAgent;
+    }
+
+    /**
+     * Sets the HTTP user agent header to send with all requests.
+     *
+     * @param userAgent The user agent string to use when sending requests.
+     */
+    public void setUserAgent(String userAgent) {
+        this.userAgent = userAgent;
+    }
+
+    /**
+     * Sets the HTTP user agent header used in requests and returns the updated
+     * ClientConfiguration object.
+     *
+     * @param userAgent The user agent string to use when sending requests.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withUserAgent(String userAgent) {
+        setUserAgent(userAgent);
+        return this;
+    }
+
+    /**
+     * Returns the optional local address the client will bind to.
+     *
+     * @return The local address the client will bind to.
+     */
+    public InetAddress getLocalAddress() {
+        return localAddress;
+    }
+
+    /**
+     * Sets the optional local address the client will bind to.
+     *
+     * @param localAddress The local address the client will bind to.
+     */
+    public void setLocalAddress(InetAddress localAddress) {
+        this.localAddress = localAddress;
+    }
+
+    /**
+     * Sets the optional local address the client will bind to and returns the
+     * updated ClientConfiguration object.
+     *
+     * @param localAddress The local address the client will bind to.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withLocalAddress(InetAddress localAddress) {
+        setLocalAddress(localAddress);
+        return this;
+    }
+
+    /**
+     * Returns the optional proxy host the client will connect through.
+     *
+     * @return The proxy host the client will connect through.
+     */
+    public String getProxyHost() {
+        return proxyHost;
+    }
+
+    /**
+     * Sets the optional proxy host the client will connect through.
+     *
+     * @param proxyHost The proxy host the client will connect through.
+     */
+    public void setProxyHost(String proxyHost) {
+        this.proxyHost = proxyHost;
+    }
+
+    /**
+     * Sets the optional proxy host the client will connect through and returns
+     * the updated ClientConfiguration object.
+     *
+     * @param proxyHost The proxy host the client will connect through.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyHost(String proxyHost) {
+        setProxyHost(proxyHost);
+        return this;
+    }
+
+    /**
+     * Returns the optional proxy port the client will connect through.
+     *
+     * @return The proxy port the client will connect through.
+     */
+    public int getProxyPort() {
+        return proxyPort;
+    }
+
+    /**
+     * Sets the optional proxy port the client will connect through.
+     *
+     * @param proxyPort The proxy port the client will connect through.
+     */
+    public void setProxyPort(int proxyPort) {
+        this.proxyPort = proxyPort;
+    }
+
+    /**
+     * Sets the optional proxy port the client will connect through and returns
+     * the updated ClientConfiguration object.
+     *
+     * @param proxyPort The proxy port the client will connect through.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyPort(int proxyPort) {
+        setProxyPort(proxyPort);
+        return this;
+    }
+
+    /**
+     * Returns the optional proxy user name to use if connecting through a
+     * proxy.
+     *
+     * @return The optional proxy user name the configured client will use if
+     *         connecting through a proxy.
+     */
+    public String getProxyUsername() {
+        return proxyUsername;
+    }
+
+    /**
+     * Sets the optional proxy user name to use if connecting through a proxy.
+     *
+     * @param proxyUsername The proxy user name to use if connecting through a
+     *            proxy.
+     */
+    public void setProxyUsername(String proxyUsername) {
+        this.proxyUsername = proxyUsername;
+    }
+
+    /**
+     * Sets the optional proxy user name and returns the updated
+     * ClientConfiguration object.
+     *
+     * @param proxyUsername The proxy user name to use if connecting through a
+     *            proxy.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyUsername(String proxyUsername) {
+        setProxyUsername(proxyUsername);
+        return this;
+    }
+
+    /**
+     * Returns the optional proxy password to use when connecting through a
+     * proxy.
+     *
+     * @return The password to use when connecting through a proxy.
+     */
+    public String getProxyPassword() {
+        return proxyPassword;
+    }
+
+    /**
+     * Sets the optional proxy password to use when connecting through a proxy.
+     *
+     * @param proxyPassword The password to use when connecting through a proxy.
+     */
+    public void setProxyPassword(String proxyPassword) {
+        this.proxyPassword = proxyPassword;
+    }
+
+    /**
+     * Sets the optional proxy password to use when connecting through a proxy,
+     * and returns the updated ClientConfiguration object.
+     *
+     * @param proxyPassword The password to use when connecting through a proxy.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyPassword(String proxyPassword) {
+        setProxyPassword(proxyPassword);
+        return this;
+    }
+
+    /**
+     * Returns the optional Windows domain name for configuring an NTLM proxy.
+     * If you aren't using a Windows NTLM proxy, you do not need to set this
+     * field.
+     *
+     * @return The optional Windows domain name for configuring an NTLM proxy.
+     */
+    @Deprecated
+    public String getProxyDomain() {
+        return proxyDomain;
+    }
+
+    /**
+     * Sets the optional Windows domain name for configuration an NTLM proxy. If
+     * you aren't using a Windows NTLM proxy, you do not need to set this field.
+     *
+     * @param proxyDomain The optional Windows domain name for configuring an
+     *            NTLM proxy.
+     */
+    @Deprecated
+    public void setProxyDomain(String proxyDomain) {
+        this.proxyDomain = proxyDomain;
+    }
+
+    /**
+     * Sets the optional Windows domain name for configuration an NTLM proxy and
+     * returns a reference to this updated ClientConfiguration object so that
+     * additional method calls can be chained together. If you aren't using a
+     * Windows NTLM proxy, you do not need to set this field.
+     *
+     * @param proxyDomain The optional Windows domain name for configuring an
+     *            NTLM proxy.
+     * @return The updated ClientConfiguration object.
+     */
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyDomain(String proxyDomain) {
+        setProxyDomain(proxyDomain);
+        return this;
+    }
+
+    /**
+     * Returns the optional Windows workstation name for configuring NTLM proxy
+     * support. If you aren't using a Windows NTLM proxy, you do not need to set
+     * this field.
+     *
+     * @return The optional Windows workstation name for configuring NTLM proxy
+     *         support.
+     */
+    public String getProxyWorkstation() {
+        return proxyWorkstation;
+    }
+
+    /**
+     * Sets the optional Windows workstation name for configuring NTLM proxy
+     * support. If you aren't using a Windows NTLM proxy, you do not need to set
+     * this field.
+     *
+     * @param proxyWorkstation The optional Windows workstation name for
+     *            configuring NTLM proxy support.
+     */
+    @Deprecated
+    public void setProxyWorkstation(String proxyWorkstation) {
+        this.proxyWorkstation = proxyWorkstation;
+    }
+
+    /**
+     * Sets the optional Windows workstation name for configuring NTLM proxy
+     * support, and returns the updated ClientConfiguration object so that
+     * additional method calls can be chained together. If you aren't using a
+     * Windows NTLM proxy, you do not need to set this field.
+     *
+     * @param proxyWorkstation The optional Windows workstation name for
+     *            configuring NTLM proxy support.
+     * @return The updated ClientConfiguration object.
+     */
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withProxyWorkstation(String proxyWorkstation) {
+        setProxyWorkstation(proxyWorkstation);
+        return this;
+    }
+
+    /**
+     * Returns the retry policy upon failed requests.
+     *
+     * @return The retry policy upon failed requests.
+     */
+    public RetryPolicy getRetryPolicy() {
+        return retryPolicy;
+    }
+
+    /**
+     * Sets the retry policy upon failed requests. User could specify whether
+     * the RetryPolicy should honor maxErrorRetry set by
+     * {@link #setMaxErrorRetry(int)}.
+     *
+     * @param retryPolicy The retry policy upon failed requests.
+     */
+    public void setRetryPolicy(RetryPolicy retryPolicy) {
+        this.retryPolicy = retryPolicy;
+    }
+
+    /**
+     * Sets the retry policy upon failed requests, and returns the updated
+     * ClientConfiguration object. User could specify whether the RetryPolicy
+     * should honor maxErrorRetry set by {@link #setMaxErrorRetry(int)}
+     *
+     * @param retryPolicy The retry policy upon failed requests.
+     * @return the client configuration.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withRetryPolicy(RetryPolicy retryPolicy) {
+        setRetryPolicy(retryPolicy);
+        return this;
+    }
+
+    /**
+     * Returns the maximum number of retry attempts for failed retryable
+     * requests (ex: 5xx error responses from a service). This method returns -1
+     * before a maxErrorRetry value is explicitly set by
+     * {@link #setMaxErrorRetry(int)}, in which case the configured RetryPolicy
+     * will be used to control the retry count.
+     *
+     * @return The maximum number of retry attempts for failed retryable
+     *         requests, or -1 if maxErrorRetry has not been set by
+     *         {@link #setMaxErrorRetry(int)}.
+     */
+    public int getMaxErrorRetry() {
+        return maxErrorRetry;
+    }
+
+    /**
+     * Sets the maximum number of retry attempts for failed retryable requests
+     * (ex: 5xx error responses from services).
+     *
+     * @param maxErrorRetry The maximum number of retry attempts for failed
+     *            retryable requests. This value should not be negative.
+     */
+    public void setMaxErrorRetry(int maxErrorRetry) {
+        if (maxErrorRetry < 0) {
+            throw new IllegalArgumentException("maxErrorRetry shoud be non-negative");
+        }
+        this.maxErrorRetry = maxErrorRetry;
+    }
+
+    /**
+     * Sets the maximum number of retry attempts for failed retryable requests
+     * (ex: 5xx error responses from services), and returns the updated
+     * ClientConfiguration object.
+     *
+     * @param maxErrorRetry The maximum number of retry attempts for failed
+     *            retryable requests. This value should not be negative.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withMaxErrorRetry(int maxErrorRetry) {
+        setMaxErrorRetry(maxErrorRetry);
+        return this;
+    }
+
+    /**
+     * Returns the amount of time to wait (in milliseconds) for data to be
+     * transfered over an established, open connection before the connection
+     * times out and is closed. A value of 0 means infinity, and isn't
+     * recommended.
+     *
+     * @return The amount of time to wait (in milliseconds) for data to be
+     *         transfered over an established, open connection before the
+     *         connection times out and is closed.
+     */
+    public int getSocketTimeout() {
+        return socketTimeout;
+    }
+
+    /**
+     * Sets the amount of time to wait (in milliseconds) for data to be
+     * transfered over an established, open connection before the connection
+     * times out and is closed. A value of 0 means infinity, and isn't
+     * recommended.
+     *
+     * @param socketTimeout The amount of time to wait (in milliseconds) for
+     *            data to be transfered over an established, open connection
+     *            before the connection is times out and is closed.
+     */
+    public void setSocketTimeout(int socketTimeout) {
+        this.socketTimeout = socketTimeout;
+    }
+
+    /**
+     * Sets the amount of time to wait (in milliseconds) for data to be
+     * transfered over an established, open connection before the connection
+     * times out and is closed, and returns the updated ClientConfiguration
+     * object so that additional method calls may be chained together.
+     *
+     * @param socketTimeout The amount of time to wait (in milliseconds) for
+     *            data to be transfered over an established, open connection
+     *            before the connection is times out and is closed.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withSocketTimeout(int socketTimeout) {
+        setSocketTimeout(socketTimeout);
+        return this;
+    }
+
+    /**
+     * Returns the amount of time to wait (in milliseconds) when initially
+     * establishing a connection before giving up and timing out. A value of 0
+     * means infinity, and is not recommended.
+     *
+     * @return The amount of time to wait (in milliseconds) when initially
+     *         establishing a connection before giving up and timing out.
+     */
+    public int getConnectionTimeout() {
+        return connectionTimeout;
+    }
+
+    /**
+     * Sets the amount of time to wait (in milliseconds) when initially
+     * establishing a connection before giving up and timing out. A value of 0
+     * means infinity, and is not recommended.
+     *
+     * @param connectionTimeout The amount of time to wait (in milliseconds)
+     *            when initially establishing a connection before giving up and
+     *            timing out.
+     */
+    public void setConnectionTimeout(int connectionTimeout) {
+        this.connectionTimeout = connectionTimeout;
+    }
+
+    /**
+     * Sets the amount of time to wait (in milliseconds) when initially
+     * establishing a connection before giving up and timing out, and returns
+     * the updated ClientConfiguration object so that additional method calls
+     * may be chained together.
+     *
+     * @param connectionTimeout the amount of time to wait (in milliseconds)
+     *            when initially establishing a connection before giving up and
+     *            timing out.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withConnectionTimeout(int connectionTimeout) {
+        setConnectionTimeout(connectionTimeout);
+        return this;
+    }
+
+    /**
+     * Checks if the {@link IdleConnectionReaper} is to be started
+     *
+     * @return if the {@link IdleConnectionReaper} is to be started
+     */
+    public boolean useReaper() {
+        return useReaper;
+    }
+
+    /**
+     * Sets whether the {@link IdleConnectionReaper} is to be started as a
+     * daemon thread
+     *
+     * @param use whether the {@link IdleConnectionReaper} is to be started as a
+     *            daemon thread
+     * @see IdleConnectionReaper
+     */
+    public void setUseReaper(boolean use) {
+        this.useReaper = use;
+    }
+
+    /**
+     * Sets whether the {@link IdleConnectionReaper} is to be started as a
+     * daemon thread
+     *
+     * @param use the {@link IdleConnectionReaper} is to be started as a daemon
+     *            thread
+     * @return The updated ClientConfiguration object.
+     */
+    public ClientConfiguration withReaper(boolean use) {
+        setUseReaper(use);
+        return this;
+    }
+
+    /**
+     * Returns the optional size hints (in bytes) for the low level TCP send and
+     * receive buffers. This is an advanced option for advanced users who want
+     * to tune low level TCP parameters to try and squeeze out more performance.
+     * <p>
+     * The optimal TCP buffer sizes for a particular application are highly
+     * dependent on network configuration and operating system configuration and
+     * capabilities. For example, most modern operating systems provide
+     * auto-tuning functionality for TCP buffer sizes, which can have a big
+     * impact on performance for TCP connections that are held open long enough
+     * for the auto-tuning to optimize buffer sizes.
+     * <p>
+     * Large buffer sizes (ex: 2MB) will allow the operating system to buffer
+     * more data in memory without requiring the remote server to acknowledge
+     * receipt of that information, so can be particularly useful when the
+     * network has high latency.
+     * <p>
+     * This is only a <b>hint</b>, and the operating system may choose not to
+     * honor it. When using this option, users should <b>always</b> check the
+     * operating system's configured limits and defaults. Most OS's have a
+     * maximum TCP buffer size limit configured, and won't let you go beyond
+     * that limit unless you explicitly raise the max TCP buffer size limit.
+     * <p>
+     * There are many resources available online to help with configuring TCP
+     * buffer sizes and operating system specific TCP settings, including:
+     * <ul>
+     * <li>http://onlamp.com/pub/a/onlamp/2005/11/17/tcp_tuning.html</li>
+     * <li>http://fasterdata.es.net/TCP-tuning/</li>
+     * </ul>
+     *
+     * @return A two element array containing first the TCP send buffer size
+     *         hint and then the TCP receive buffer size hint.
+     */
+    public int[] getSocketBufferSizeHints() {
+        return new int[] {
+            socketSendBufferSizeHint, socketReceiveBufferSizeHint
+        };
+    }
+
+    /**
+     * Sets the optional size hints (in bytes) for the low level TCP send and
+     * receive buffers. This is an advanced option for advanced users who want
+     * to tune low level TCP parameters to try and squeeze out more performance.
+     * <p>
+     * The optimal TCP buffer sizes for a particular application are highly
+     * dependent on network configuration and operating system configuration and
+     * capabilities. For example, most modern operating systems provide
+     * auto-tuning functionality for TCP buffer sizes, which can have a big
+     * impact on performance for TCP connections that are held open long enough
+     * for the auto-tuning to optimize buffer sizes.
+     * <p>
+     * Large buffer sizes (ex: 2MB) will allow the operating system to buffer
+     * more data in memory without requiring the remote server to acknowledge
+     * receipt of that information, so can be particularly useful when the
+     * network has high latency.
+     * <p>
+     * This is only a <b>hint</b>, and the operating system may choose not to
+     * honor it. When using this option, users should <b>always</b> check the
+     * operating system's configured limits and defaults. Most OS's have a
+     * maximum TCP buffer size limit configured, and won't let you go beyond
+     * that limit unless you explicitly raise the max TCP buffer size limit.
+     * <p>
+     * There are many resources available online to help with configuring TCP
+     * buffer sizes and operating system specific TCP settings, including:
+     * <ul>
+     * <li>http://onlamp.com/pub/a/onlamp/2005/11/17/tcp_tuning.html</li>
+     * <li>http://fasterdata.es.net/TCP-tuning/</li>
+     * </ul>
+     *
+     * @param socketSendBufferSizeHint The size hint (in bytes) for the low
+     *            level TCP send buffer.
+     * @param socketReceiveBufferSizeHint The size hint (in bytes) for the low
+     *            level TCP receive buffer.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setSocketBufferSizeHints(
+            int socketSendBufferSizeHint, int socketReceiveBufferSizeHint) {
+        this.socketSendBufferSizeHint = socketSendBufferSizeHint;
+        this.socketReceiveBufferSizeHint = socketReceiveBufferSizeHint;
+    }
+
+    /**
+     * Sets the optional size hints (in bytes) for the low level TCP send and
+     * receive buffers, and returns the updated ClientConfiguration object so
+     * that additional method calls may be chained together.
+     * <p>
+     * This is an advanced option for advanced users who want to tune low level
+     * TCP parameters to try and squeeze out more performance.
+     * <p>
+     * The optimal TCP buffer sizes for a particular application are highly
+     * dependent on network configuration and operating system configuration and
+     * capabilities. For example, most modern operating systems provide
+     * auto-tuning functionality for TCP buffer sizes, which can have a big
+     * impact on performance for TCP connections that are held open long enough
+     * for the auto-tuning to optimize buffer sizes.
+     * <p>
+     * Large buffer sizes (ex: 2MB) will allow the operating system to buffer
+     * more data in memory without requiring the remote server to acknowledge
+     * receipt of that information, so can be particularly useful when the
+     * network has high latency.
+     * <p>
+     * This is only a <b>hint</b>, and the operating system may choose not to
+     * honor it. When using this option, users should <b>always</b> check the
+     * operating system's configured limits and defaults. Most OS's have a
+     * maximum TCP buffer size limit configured, and won't let you go beyond
+     * that limit unless you explicitly raise the max TCP buffer size limit.
+     * <p>
+     * There are many resources available online to help with configuring TCP
+     * buffer sizes and operating system specific TCP settings, including:
+     * <ul>
+     * <li>http://onlamp.com/pub/a/onlamp/2005/11/17/tcp_tuning.html</li>
+     * <li>http://fasterdata.es.net/TCP-tuning/</li>
+     * </ul>
+     *
+     * @param socketSendBufferSizeHint The size hint (in bytes) for the low
+     *            level TCP send buffer.
+     * @param socketReceiveBufferSizeHint The size hint (in bytes) for the low
+     *            level TCP receive buffer.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withSocketBufferSizeHints(
+            int socketSendBufferSizeHint, int socketReceiveBufferSizeHint) {
+        setSocketBufferSizeHints(socketSendBufferSizeHint, socketReceiveBufferSizeHint);
+        return this;
+    }
+
+    /**
+     * Returns the name of the signature algorithm to use for signing requests
+     * made by this client. If not set or explicitly set to null, the client
+     * will choose a signature algorithm to use based on a configuration file of
+     * supported signature algorithms for the service and region.
+     * <p>
+     * Most users do not need to concern themselves with which signature
+     * algorithm is being used, as the defaults will be sufficient. This setting
+     * exists only so advanced users can opt in to newer signature protocols
+     * which have not yet been made the default for a particular service/region.
+     * <p>
+     * Not all services support all signature algorithms, and configuring an
+     * unsupported signature algorithm will lead to authentication failures. Use
+     * me at your own risk, and only after consulting the documentation for the
+     * service to ensure it actually does supports your chosen algorithm.
+     * <p>
+     * If non-null, the name returned from this method is used to look up a
+     * {@code Signer} class implementing the chosen algorithm by the
+     * {@code com.amazonaws.auth.SignerFactory} class.
+     *
+     * @return The signature algorithm to use for this client, or null to use
+     *         the default.
+     */
+    public String getSignerOverride() {
+        return signerOverride;
+    }
+
+    /**
+     * Sets the name of the signature algorithm to use for signing requests made
+     * by this client. If not set or explicitly set to null, the client will
+     * choose a signature algorithm to use based on a configuration file of
+     * supported signature algorithms for the service and region.
+     * <p>
+     * Most users do not need to concern themselves with which signature
+     * algorithm is being used, as the defaults will be sufficient. This setting
+     * exists only so advanced users can opt in to newer signature protocols
+     * which have not yet been made the default for a particular service/region.
+     * <p>
+     * Not all services support all signature algorithms, and configuring an
+     * unsupported signature algorithm will lead to authentication failures. Use
+     * me at your own risk, and only after consulting the documentation for the
+     * service to ensure it actually does supports your chosen algorithm.
+     * <p>
+     * If non-null, the name returned from this method is used to look up a
+     * {@code Signer} class implementing the chosen algorithm by the
+     * {@code com.amazonaws.auth.SignerFactory} class.
+     *
+     * @param value The signature algorithm to use for this client, or null to
+     *            use the default.
+     */
+    public void setSignerOverride(final String value) {
+        signerOverride = value;
+    }
+
+    /**
+     * Sets the name of the signature algorithm to use for signing requests made
+     * by this client. If not set or explicitly set to null, the client will
+     * choose a signature algorithm to use based on a configuration file of
+     * supported signature algorithms for the service and region.
+     * <p>
+     * Most users do not need to concern themselves with which signature
+     * algorithm is being used, as the defaults will be sufficient. This setting
+     * exists only so advanced users can opt in to newer signature protocols
+     * which have not yet been made the default for a particular service/region.
+     * <p>
+     * Not all services support all signature algorithms, and configuring an
+     * unsupported signature algorithm will lead to authentication failures. Use
+     * me at your own risk, and only after consulting the documentation for the
+     * service to ensure it actually does supports your chosen algorithm.
+     * <p>
+     * If non-null, the name returned from this method is used to look up a
+     * {@code Signer} class implementing the chosen algorithm by the
+     * {@code com.amazonaws.auth.SignerFactory} class.
+     *
+     * @param value The signature algorithm to use for this client, or null to
+     *            use the default.
+     * @return The updated ClientConfiguration object.
+     */
+    public ClientConfiguration withSignerOverride(final String value) {
+        setSignerOverride(value);
+        return this;
+    }
+
+    /**
+     * Returns whether to attempt to authenticate preemptively against proxy
+     * servers using basic authentication
+     *
+     * @return Whether to authenticate preemptively against proxy server.
+     */
+    public boolean isPreemptiveBasicProxyAuth() {
+        return preemptiveBasicProxyAuth;
+    }
+
+    /**
+     * Sets whether to attempt to authenticate preemptively against proxy
+     * servers using basic authentication
+     *
+     * @param preemptiveBasicProxyAuth Whether to authenticate preemptively
+     *            against proxy server.
+     */
+    public void setPreemptiveBasicProxyAuth(Boolean preemptiveBasicProxyAuth) {
+        this.preemptiveBasicProxyAuth = preemptiveBasicProxyAuth;
+    }
+
+    /**
+     * Sets whether to attempt to authenticate preemptively against proxy
+     * servers using basic authentication, and returns the updated
+     * ClientConfiguration object so that additional method calls may be chained
+     * together.
+     *
+     * @param preemptiveBasicProxyAuth Whether to authenticate preemptively
+     *            against proxy server.
+     * @return The updated ClientConfiguration objectt=
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withPreemptiveBasicProxyAuth(boolean preemptiveBasicProxyAuth) {
+        setPreemptiveBasicProxyAuth(preemptiveBasicProxyAuth);
+        return this;
+    }
+
+    /**
+     * Gets the trust manager to use for secure connections from this client. If
+     * null the default authentication will be used.
+     *
+     * @return The trust manager to use for this client, or null to use the
+     *         default authentication for secure connections.
+     */
+    public TrustManager getTrustManager() {
+        return trustManager;
+    }
+
+    /**
+     * Sets the trust manager to use for secure connections from this client. If
+     * null the default authentication will be used.
+     *
+     * @param trustManager The trust manager to use for this client.
+     */
+    public void setTrustManager(TrustManager trustManager) {
+        this.trustManager = trustManager;
+    }
+
+    /**
+     * Sets the trust manager to use for secure connections from this client,
+     * and returns the updated ClientConfiguration object so that additional
+     * calls may be chained together. If null the default authentication will be
+     * used.
+     *
+     * @param trustManager The trust manager to use for this client.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withTrustManager(TrustManager trustManager) {
+        setTrustManager(trustManager);
+        return this;
+    }
+
+    /**
+     * Tells whether or not the client should be logging anything. Currently,
+     * logging will print curl commands to replay http requests.
+     *
+     * @return Whether or not the client will be logging.
+     */
+    public boolean isCurlLogging() {
+        return curlLogging;
+    }
+
+    /**
+     * Sets whether or not the client should be logging any information. This
+     * should be used for debug builds only. Defaults to false.
+     *
+     * @param curlLogging Whether or not the client should be logging operations.
+     */
+    public void setCurlLogging(boolean curlLogging) {
+        this.curlLogging = curlLogging;
+    }
+
+    /**
+     * Sets whether or not the client should be logging any information. This
+     * should be used for debug builds only, and returns the updated
+     * ClientConfiguration object so that additional calls may be chained
+     * together. Defaults to false.
+     *
+     * @param curlLogging Whether or not the client should be logging operations.
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withCurlLogging(boolean curlLogging) {
+        this.curlLogging = curlLogging;
+        return this;
+    }
+
+    /**
+     * @return if gzip compression is used.
+     */
+    public boolean isEnableGzip() {
+        return enableGzip;
+    }
+
+    /**
+     * Sets whether gzip compression should be used
+     *
+     * @param enableGzip true if it is a gzip.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setEnableGzip(boolean enableGzip) {
+        this.enableGzip = enableGzip;
+    }
+
+    /**
+     * Sets whether gzip compression should be used
+     *
+     * @param enableGzip whether gzip compression should be used
+     * @return The updated ClientConfiguration object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public ClientConfiguration withEnableGzip(boolean enableGzip) {
+        setEnableGzip(enableGzip);
+        return this;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/DefaultRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/DefaultRequest.java
new file mode 100644
index 0000000000..db35af1a3b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/DefaultRequest.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.http.HttpMethodName;
+import com.amazonaws.util.AWSRequestMetrics;
+
+import java.io.InputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Default implementation of the {@linkplain com.amazonaws.Request} interface.
+ * <p>
+ * This class is only intended for internal use inside the AWS client libraries.
+ * Callers shouldn't ever interact directly with objects of this class.
+ * @param <T> class type.
+ */
+public class DefaultRequest<T> implements Request<T> {
+
+    /** The resource path being requested */
+    private String resourcePath;
+
+    private boolean streaming = false;
+    /**
+     * Map of the parameters being sent as part of this request.
+     * <p>
+     * Note that a LinkedHashMap is used, since we want to preserve the
+     * insertion order so that members of a list parameter will still be ordered
+     * by their indices when they are marshalled into the query string.
+     */
+    private final Map<String, String> parameters = new LinkedHashMap<String, String>();
+
+    /** Map of the headers included in this request */
+    private final Map<String, String> headers = new HashMap<String, String>();
+
+    /** The service endpoint to which this request should be sent */
+    private URI endpoint;
+
+    /** The name of the service to which this request is being sent */
+    private String serviceName;
+
+    /**
+     * The original, user facing request object which this internal request
+     * object is representing
+     */
+    private final AmazonWebServiceRequest originalRequest;
+
+    /** The HTTP method to use when sending this request. */
+    private HttpMethodName httpMethod = HttpMethodName.POST;
+
+    /** An optional stream from which to read the request payload. */
+    private InputStream content;
+
+    /** An optional time offset to account for clock skew */
+    private int timeOffset;
+
+    /** All AWS Request metrics are collected into this object. */
+    private AWSRequestMetrics metrics;
+
+    /**
+     * Constructs a new DefaultRequest with the specified service name and the
+     * original, user facing request object.
+     *
+     * @param serviceName The name of the service to which this request is being
+     *            sent.
+     * @param originalRequest The original, user facing, AWS request being
+     *            represented by this internal request object.
+     */
+    public DefaultRequest(AmazonWebServiceRequest originalRequest, String serviceName) {
+        this.serviceName = serviceName;
+        this.originalRequest = originalRequest;
+    }
+
+    /**
+     * Constructs a new DefaultRequest with the specified service name and no
+     * specified original, user facing request object.
+     *
+     * @param serviceName The name of the service to which this request is being
+     *            sent.
+     */
+    public DefaultRequest(String serviceName) {
+        this(null, serviceName);
+    }
+
+    /**
+     * Returns the original, user facing request object which this internal
+     * request object is representing.
+     *
+     * @return The original, user facing request object which this request
+     *         object is representing.
+     */
+    @Override
+    public AmazonWebServiceRequest getOriginalRequest() {
+        return originalRequest;
+    }
+
+    /**
+     * @see com.amazonaws.Request#addHeader(java.lang.String, java.lang.String)
+     */
+    @Override
+    public void addHeader(String name, String value) {
+        headers.put(name, value);
+    }
+
+    /**
+     * @see com.amazonaws.Request#getHeaders()
+     */
+    @Override
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    /**
+     * @see com.amazonaws.Request#setResourcePath(java.lang.String)
+     */
+    @Override
+    public void setResourcePath(String resourcePath) {
+        this.resourcePath = resourcePath;
+    }
+
+    /**
+     * @see com.amazonaws.Request#getResourcePath()
+     */
+    @Override
+    public String getResourcePath() {
+        return resourcePath;
+    }
+
+    /**
+     * @see com.amazonaws.Request#addParameter(java.lang.String,
+     *      java.lang.String)
+     */
+    @Override
+    public void addParameter(String name, String value) {
+        parameters.put(name, value);
+    }
+
+    /**
+     * @see com.amazonaws.Request#getParameters()
+     */
+    @Override
+    public Map<String, String> getParameters() {
+        return parameters;
+    }
+
+    /**
+     * @see com.amazonaws.Request#withParameter(java.lang.String,
+     *      java.lang.String)
+     */
+    @Override
+    public Request<T> withParameter(String name, String value) {
+        addParameter(name, value);
+        return this;
+    }
+
+    /**
+     * @see com.amazonaws.Request#getHttpMethod()
+     */
+    @Override
+    public HttpMethodName getHttpMethod() {
+        return httpMethod;
+    }
+
+    /**
+     * @see com.amazonaws.Request#setHttpMethod(com.amazonaws.http.HttpMethodName)
+     */
+    @Override
+    public void setHttpMethod(HttpMethodName httpMethod) {
+        this.httpMethod = httpMethod;
+    }
+
+    /**
+     * @see com.amazonaws.Request#setEndpoint(java.net.URI)
+     */
+    @Override
+    public void setEndpoint(URI endpoint) {
+        this.endpoint = endpoint;
+    }
+
+    /**
+     * @see com.amazonaws.Request#getEndpoint()
+     */
+    @Override
+    public URI getEndpoint() {
+        return endpoint;
+    }
+
+    /**
+     * @see com.amazonaws.Request#getServiceName()
+     */
+    @Override
+    public String getServiceName() {
+        return serviceName;
+    }
+
+    /**
+     * @see com.amazonaws.Request#getContent()
+     */
+    @Override
+    public InputStream getContent() {
+        return content;
+    }
+
+    /**
+     * @see com.amazonaws.Request#setContent(java.io.InputStream)
+     */
+    @Override
+    public void setContent(InputStream content) {
+        this.content = content;
+    }
+
+    /**
+     * @see com.amazonaws.Request#setHeaders(java.util.Map)
+     */
+    @Override
+    public void setHeaders(Map<String, String> headers) {
+        this.headers.clear();
+        this.headers.putAll(headers);
+    }
+
+    /**
+     * @see com.amazonaws.Request#setParameters(java.util.Map)
+     */
+    @Override
+    public void setParameters(Map<String, String> parameters) {
+        this.parameters.clear();
+        this.parameters.putAll(parameters);
+    }
+
+    /**
+     * @see com.amazonaws.Request#getTimeOffset
+     */
+    @Override
+    public int getTimeOffset() {
+        return timeOffset;
+    }
+
+    /**
+     * @see Request#setTimeOffset(int)
+     */
+    @Override
+    public void setTimeOffset(int timeOffset) {
+        this.timeOffset = timeOffset;
+    }
+
+    /**
+     * @see Request#setTimeOffset(int)
+     */
+    @Override
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Request<T> withTimeOffset(int timeOffset) {
+        setTimeOffset(timeOffset);
+        return this;
+    }
+
+    @Override
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public String toString() {
+        final StringBuilder builder = new StringBuilder();
+        builder.append(getHttpMethod()).append(" ");
+        builder.append(getEndpoint()).append(" ");
+        final String resourcePath = getResourcePath();
+
+        if (resourcePath == null) {
+            builder.append("/");
+        }
+        else {
+            if (!resourcePath.startsWith("/")) {
+                builder.append("/");
+            }
+            builder.append(resourcePath);
+        }
+        builder.append(" ");
+        if (!getParameters().isEmpty()) {
+            builder.append("Parameters: (");
+            for (final String key : getParameters().keySet()) {
+                final String value = getParameters().get(key);
+                builder.append(key).append(": ").append(value).append(", ");
+            }
+            builder.append(") ");
+        }
+
+        if (!getHeaders().isEmpty()) {
+            builder.append("Headers: (");
+            for (final String key : getHeaders().keySet()) {
+                final String value = getHeaders().get(key);
+                builder.append(key).append(": ").append(value).append(", ");
+            }
+            builder.append(") ");
+        }
+
+        return builder.toString();
+    }
+
+    @Override
+    @Deprecated
+    public AWSRequestMetrics getAWSRequestMetrics() {
+        return metrics;
+    }
+
+    @Override
+    @Deprecated
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setAWSRequestMetrics(AWSRequestMetrics metrics) {
+        if (this.metrics == null) {
+            this.metrics = metrics;
+        } else {
+            throw new IllegalStateException(
+                    "AWSRequestMetrics has already been set on this request");
+        }
+    }
+
+    @Override
+    public boolean isStreaming() {
+        return this.streaming;
+    }
+
+    @Override
+    public void setStreaming(boolean streaming) {
+        this.streaming = streaming;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/HttpMethod.java b/aws-java-sdk-core/src/main/java/com/amazonaws/HttpMethod.java
new file mode 100644
index 0000000000..c0cd5371f4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/HttpMethod.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * Enumeration of valid HTTP methods.
+ */
+public enum HttpMethod {
+
+    /** Get. */
+    GET,
+
+    /** Post. */
+    POST,
+
+    /** Put. */
+    PUT,
+
+    /** Delete. */
+    DELETE,
+
+    /** Head. */
+    HEAD,
+
+    /** Patch. */
+    PATCH;
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/Protocol.java b/aws-java-sdk-core/src/main/java/com/amazonaws/Protocol.java
new file mode 100644
index 0000000000..baee177eda
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/Protocol.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+/**
+ * Represents the communication protocol to use when sending requests to AWS.
+ * <p>
+ * Communication over HTTPS is the default, and is more secure than HTTP, which
+ * is why AWS recommends using HTTPS. HTTPS connections can use more system
+ * resources because of the extra work to encrypt network traffic, so the option
+ * to use HTTP is available in case users need it.
+ */
+public enum Protocol {
+
+    /**
+     * HTTP Protocol - Using the HTTP protocol is less secure than HTTPS, but
+     * can slightly reduce the system resources used when communicating with
+     * AWS.
+     */
+    HTTP("http"),
+
+    /**
+     * HTTPS Protocol - Using the HTTPS protocol is more secure than using the
+     * HTTP protocol, but may use slightly more system resources. AWS recommends
+     * using HTTPS for maximize security.
+     */
+    HTTPS("https");
+
+    private final String protocol;
+
+    private Protocol(String protocol) {
+        this.protocol = protocol;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.lang.Enum#toString()
+     */
+    @Override
+    public String toString() {
+        return protocol;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/Request.java b/aws-java-sdk-core/src/main/java/com/amazonaws/Request.java
new file mode 100644
index 0000000000..3246fd83f7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/Request.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.http.HttpMethodName;
+import com.amazonaws.util.AWSRequestMetrics;
+
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Map;
+
+/**
+ * Represents a request being sent to an Amazon Web Service, including the
+ * parameters being sent as part of the request, the endpoint to which the
+ * request should be sent, etc.
+ * <p>
+ * This class is only intended for internal use inside the AWS client libraries.
+ * Callers shouldn't ever interact directly with objects of this class.
+ *
+ * @param <T> The type of original, user facing request represented by this
+ *            request.
+ */
+public interface Request<T> {
+
+    /**
+     * Sets the specified header for this request.
+     *
+     * @param name The name of the header to set.
+     * @param value The header's value.
+     */
+    public void addHeader(String name, String value);
+
+    /**
+     * Returns a map of all the headers included in this request.
+     *
+     * @return A map of all the headers included in this request.
+     */
+    public Map<String, String> getHeaders();
+
+    /**
+     * Sets all headers, clearing any existing ones.
+     * @param headers the headers.
+     */
+    public void setHeaders(Map<String, String> headers);
+
+    /**
+     * Sets the path to the resource being requested.
+     *
+     * @param path The path to the resource being requested.
+     */
+    public void setResourcePath(String path);
+
+    /**
+     * Returns the path to the resource being requested.
+     *
+     * @return The path to the resource being requested.
+     */
+    public String getResourcePath();
+
+    /**
+     * Adds the specified request parameter to this request.
+     *
+     * @param name The name of the request parameter.
+     * @param value The value of the request parameter.
+     */
+    public void addParameter(String name, String value);
+
+    /**
+     * Adds the specified request parameter to this request, and returns the
+     * updated request object.
+     *
+     * @param name The name of the request parameter.
+     * @param value The value of the request parameter.
+     * @return The updated request object.
+     */
+    public Request<T> withParameter(String name, String value);
+
+    /**
+     * Returns a map of all parameters in this request.
+     *
+     * @return A map of all parameters in this request.
+     */
+    public Map<String, String> getParameters();
+
+    /**
+     * Sets all parameters, clearing any existing values.
+     * @param parameters the parameters.
+     */
+    public void setParameters(Map<String, String> parameters);
+
+    /**
+     * Returns the service endpoint (ex: "https://ec2.amazonaws.com") to which
+     * this request should be sent.
+     *
+     * @return The service endpoint to which this request should be sent.
+     */
+    public URI getEndpoint();
+
+    /**
+     * Sets the service endpoint (ex: "https://ec2.amazonaws.com") to which this
+     * request should be sent.
+     *
+     * @param endpoint The service endpoint to which this request should be
+     *            sent.
+     */
+    public void setEndpoint(URI endpoint);
+
+    /**
+     * Returns the HTTP method (GET, POST, etc) to use when sending this
+     * request.
+     *
+     * @return The HTTP method to use when sending this request.
+     */
+    public HttpMethodName getHttpMethod();
+
+    /**
+     * Sets the HTTP method (GET, POST, etc) to use when sending this request.
+     *
+     * @param httpMethod The HTTP method to use when sending this request.
+     */
+    public void setHttpMethod(HttpMethodName httpMethod);
+
+    /**
+     * Returns the optional stream containing the payload data to include for
+     * this request. Not all requests will contain payload data.
+     *
+     * @return The optional stream containing the payload data to include for
+     *         this request.
+     */
+    public InputStream getContent();
+
+    /**
+     * Sets the optional stream containing the payload data to include for this
+     * request. Not all requests will contain payload data.
+     *
+     * @param content The optional stream containing the payload data to include
+     *            for this request.
+     */
+    public void setContent(InputStream content);
+
+    /**
+     * Returns the name of the Amazon service this request is for.
+     *
+     * @return The name of the Amazon service this request is for.
+     */
+    public String getServiceName();
+
+    /**
+     * Returns the original, user facing request object which this internal
+     * request object is representing.
+     *
+     * @return The original, user facing request object which this request
+     *         object is representing.
+     */
+    public AmazonWebServiceRequest getOriginalRequest();
+
+    /**
+     * Returns the optional value for time offset for this request. This will be
+     * used by the signer to adjust for potential clock skew. Value is in
+     * seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     *
+     * @return The optional value for time offset (in seconds) for this request.
+     */
+    public int getTimeOffset();
+
+    /**
+     * Sets the optional value for time offset for this request. This will be
+     * used by the signer to adjust for potential clock skew. Value is in
+     * seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     *
+     * @param timeOffset The optional value for time offset (in seconds) for
+     *            this request.
+     */
+    public void setTimeOffset(int timeOffset);
+
+    /**
+     * Sets the optional value for time offset for this request. This will be
+     * used by the signer to adjust for potential clock skew. Value is in
+     * seconds, positive values imply the current clock is "fast", negative
+     * values imply clock is slow.
+     * @param timeOffset the time offset for the request.
+     *
+     * @return The updated request object.
+     */
+    public Request<T> withTimeOffset(int timeOffset);
+
+    /**
+     * @return the request metrics.
+     */
+    public AWSRequestMetrics getAWSRequestMetrics();
+
+    /**
+     * Bind the request metrics to the request. Note metrics can be captured
+     * before the request is created.
+     *
+     * @param metrics the request metrics.
+     * @throws IllegalStateException if the binding has already occurred
+     */
+    public void setAWSRequestMetrics(AWSRequestMetrics metrics);
+
+    /**
+     * Flag that indicates that request is streaming request
+     *
+     * @return true if request is streaming request.
+     */
+    public boolean isStreaming();
+
+    /**
+     * Set streaming flag
+     *
+     * @param streaming the streaming flag.
+     */
+    public void setStreaming(boolean streaming);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/RequestClientOptions.java b/aws-java-sdk-core/src/main/java/com/amazonaws/RequestClientOptions.java
new file mode 100644
index 0000000000..15495d6726
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/RequestClientOptions.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2011-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import java.util.EnumMap;
+import java.util.Map;
+
+/**
+ * Client markers for individual {@link AmazonWebServiceRequest}s.
+ */
+public final class RequestClientOptions {
+
+    private static final int STREAM_BUFFER_SHIFT_VAL = 17;
+    /**
+     * Used to enable mark-and-reset for non-mark-and-resettable non-file input
+     * stream for up to 128K memory buffering by default. Add 1 to get around an
+     * implementation quirk of BufferedInputStream. Retries after reading
+     * {@link #DEFAULT_STREAM_BUFFER_SIZE} bytes would fail to reset the
+     * underlying input stream as the mark position would have been invalidated.
+     */
+    public static final int DEFAULT_STREAM_BUFFER_SIZE = (1 << STREAM_BUFFER_SHIFT_VAL) + 1;
+
+    /**
+     * Marker enum.
+     */
+    public static enum Marker {
+        /**
+         * Used to specify the http user_agent value. This marker is intended
+         * only for internal use by the AWS SDK.
+         */
+        USER_AGENT;
+    }
+
+    private final Map<Marker, String> markers = new EnumMap<Marker, String>(Marker.class);
+
+    /**
+     * @deprecated by {@link #getClientMarker(Marker)}. This method is intended
+     *             only for internal use by the AWS SDK. Returns the
+     *             "USER_AGENT" marker as a space-delimited string.
+     * @return the client marker.
+     */
+    @Deprecated
+    public String getClientMarker() {
+        return getClientMarker(Marker.USER_AGENT);
+    }
+
+    /**
+     * @param marker the marker.
+     * @return the value of the specified marker; or null if there is no such
+     * value.
+     */
+    public String getClientMarker(Marker marker) {
+        return markers.get(marker);
+    }
+
+    /**
+     * Associates the given value with the given marker. Note the
+     * {@link Marker#USER_AGENT} is only intended for internal use by the AWS
+     * SDK.
+     * @param marker the marker.
+     * @param value the value.
+     */
+    public void putClientMarker(Marker marker, String value) {
+        markers.put(marker, value);
+    }
+
+    /**
+     * @deprecated by {@link #appendUserAgent(String)}. This method is intended
+     *             only for internal use by the AWS SDK. Adds a "USER_AGENT"
+     *             client marker, if it wasn't already present.
+     * @param clientMarker the client marker.
+     */
+    @Deprecated
+    public void addClientMarker(String clientMarker) {
+        appendUserAgent(clientMarker);
+    }
+
+    /**
+     * Appends a user agent to the USER_AGENT client marker. This method is
+     * intended only for internal use by the AWS SDK.
+     * @param userAgent the user agent.
+     */
+    public void appendUserAgent(String userAgent) {
+        String marker = markers.get(Marker.USER_AGENT);
+        if (marker == null) {
+            marker = "";
+        }
+        marker = createUserAgentMarkerString(marker, userAgent);
+        putClientMarker(Marker.USER_AGENT, marker);
+    }
+
+    /**
+     * Appends the given client marker string to the existing one and returns
+     * it.
+     * @param marker the marker.
+     * @param userAgent the user agent.
+     * @return the marker string with the given client marker appended.
+     */
+    private String createUserAgentMarkerString(final String marker, String userAgent) {
+        return marker.contains(userAgent) ? marker : marker + " " + userAgent;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/Response.java b/aws-java-sdk-core/src/main/java/com/amazonaws/Response.java
new file mode 100644
index 0000000000..3b88640466
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/Response.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.http.HttpResponse;
+
+/**
+ * Response wrapper to provide access to not only the original AWS response but
+ * also the associated http response.
+ *
+ * @param <T> the underlying AWS response type.
+ */
+public final class Response<T> {
+    private final T response;
+    private final HttpResponse httpResponse;
+
+    /**
+     * Constructor.
+     * @param response the response.
+     * @param httpResponse the HTTP response.
+     */
+    public Response(T response, HttpResponse httpResponse) {
+        this.response = response;
+        this.httpResponse = httpResponse;
+    }
+
+    public T getAwsResponse() {
+        return response;
+    }
+
+    public HttpResponse getHttpResponse() {
+        return httpResponse;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/ResponseMetadata.java b/aws-java-sdk-core/src/main/java/com/amazonaws/ResponseMetadata.java
new file mode 100644
index 0000000000..d22755ac7a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/ResponseMetadata.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import java.util.Map;
+
+/**
+ * Represents additional metadata included with a response from AWS. Response
+ * metadata varies by service, but all services return an AWS request ID that
+ * can be used in the event a service call isn't working as expected and you
+ * need to work with AWS support to debug an issue.
+ * <p>
+ * Access to AWS request IDs is also available through the com.amazonaws.request
+ * logger in the AWS SDK for Java.
+ */
+public class ResponseMetadata {
+
+    /** Constant for the AWS Request ID. */
+    public static final String AWS_REQUEST_ID = "AWS_REQUEST_ID";
+
+    protected final Map<String, String> metadata;
+
+    /**
+     * Creates a new ResponseMetadata object from a specified map of raw
+     * metadata information.
+     *
+     * @param metadata The raw metadata for the new ResponseMetadata object.
+     */
+    public ResponseMetadata(Map<String, String> metadata) {
+        this.metadata = metadata;
+    }
+
+    /**
+     * Creates a new ResponseMetadata object from an existing ResponseMetadata
+     * object.
+     *
+     * @param originalResponseMetadata The ResponseMetadata object from which to
+     *            create the new object.
+     */
+    public ResponseMetadata(ResponseMetadata originalResponseMetadata) {
+        this(originalResponseMetadata.metadata);
+    }
+
+    /**
+     * Returns the AWS request ID contained in this response metadata object.
+     * AWS request IDs can be used in the event a service call isn't working as
+     * expected and you need to work with AWS support to debug an issue.
+     *
+     * @return The AWS request ID contained in this response metadata object.
+     */
+    public String getRequestId() {
+        return metadata.get(AWS_REQUEST_ID);
+    }
+
+    @Override
+    public String toString() {
+        if (metadata == null)
+            return "{}";
+        return metadata.toString();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/SDKGlobalConfiguration.java b/aws-java-sdk-core/src/main/java/com/amazonaws/SDKGlobalConfiguration.java
new file mode 100644
index 0000000000..0ae5705a57
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/SDKGlobalConfiguration.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * SDKGlobalConfiguration is to configure any global settings
+ */
+public class SDKGlobalConfiguration {
+    // ///////////////////// System Properties ///////////////////////
+
+    /**
+     * Disable validation of server certificates when using the HTTPS protocol.
+     * This should ONLY be used to do quick smoke tests against endpoints which
+     * don't yet have valid certificates; it should NEVER be used in production.
+     */
+    public static final String DISABLE_CERT_CHECKING_SYSTEM_PROPERTY =
+            "com.amazonaws.sdk.disableCertChecking";
+
+    /**
+     * System property used when starting up the JVM to enable the default
+     * metrics collected by the AWS SDK, which uploads the derived statistics to
+     * Amazon CloudWatch.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics
+     * </pre>
+     */
+    public static final String DEFAULT_METRICS_SYSTEM_PROPERTY =
+            "com.amazonaws.sdk.enableDefaultMetrics";
+
+    /** System property name for the AWS access key ID */
+    public static final String ACCESS_KEY_SYSTEM_PROPERTY = "aws.accessKeyId";
+
+    /** System property name for the AWS secret key */
+    public static final String SECRET_KEY_SYSTEM_PROPERTY = "aws.secretKey";
+
+    /**
+     * System property for overriding the Amazon EC2 Instance Metadata Service
+     * endpoint.
+     */
+    public static final String EC2_METADATA_SERVICE_OVERRIDE_SYSTEM_PROPERTY =
+            "com.amazonaws.sdk.ec2MetadataServiceEndpointOverride";
+
+    /**
+     * Path to an override file for the region metadata loaded by the SDK that
+     * maps service/region pairs to endpoints and vice versa.
+     *
+     * @deprecated The SDK no longer supports a regions.xml override
+     */
+    @Deprecated
+    public static final String REGIONS_FILE_OVERRIDE_SYSTEM_PROPERTY =
+            "com.amazonaws.regions.RegionUtils.fileOverride";
+
+    /**
+     * By default, the SDK will attempt to download an up-to-date set of region
+     * metadata from Amazon CloudFront when first required. This allows you to
+     * look up information about new regions and services without having to
+     * download a new version of the SDK every time.
+     * <p>
+     * If the SDK cannot download region metadata from Amazon CloudFront, it
+     * will fall back to loading the region metadata bundled with the SDK when
+     * it was released, which may be out of date.
+     * <p>
+     * Setting this system property to anything other than {@code null} will
+     * <i>disable</i> this remote fetching, and will <i>only</i> load region
+     * metadata that was bundled with the SDK. This gives you control over when
+     * new region metadata will be picked up by your application, and isolates
+     * you from potential issues if your application depends on being able to
+     * load metadata about a region which is not included in your version of the
+     * SDK and therefore may not be available in the event of network outages.
+     */
+    public static final String DISABLE_REMOTE_REGIONS_FILE_SYSTEM_PROPERTY =
+            "com.amazonaws.regions.RegionUtils.disableRemote";
+
+    /**
+     * By default, the AmazonS3Client will continue to use the legacy S3Signer
+     * to authenticate requests it makes to S3 in regions that support the older
+     * protocol. Setting this property to anything other than null will cause
+     * the client to upgrade to Signature Version 4 whenever it has been
+     * configured with an explicit region (which is a required parameter for
+     * Signature Version 4). The client will continue to use the older signature
+     * protocol when not configured with a region to avoid breaking existing
+     * applications.
+     * <p>
+     * Signature Version 4 is more secure than the legacy S3Signer, but requires
+     * calculating a SHA-256 hash of the entire request body which can be
+     * expensive for large upload requests.
+     */
+    @Deprecated
+    public static final String ENABLE_S3_SIGV4_SYSTEM_PROPERTY =
+            "com.amazonaws.services.s3.enableV4";
+
+    /**
+     * Like {@link #ENABLE_S3_SIGV4_SYSTEM_PROPERTY}, but causes the client to
+     * always use Signature Version 4, assuming a region of
+     * &quot;us-east-1&quot; if no explicit region has been configured. This
+     * guarantees that the more secure authentication protocol will be used, but
+     * will cause authentication failures in code that accesses buckets in
+     * regions other than US Standard without explicitly configuring a region.
+     */
+    @Deprecated
+    public static final String ENFORCE_S3_SIGV4_SYSTEM_PROPERTY =
+            "com.amazonaws.services.s3.enforceV4";
+
+    /**
+     * The default size of the buffer when uploading data from a stream. A
+     * buffer of this size will be created and filled with the first bytes from
+     * a stream being uploaded so that any transmit errors that occur in that
+     * section of the data can be automatically retried without the caller's
+     * intervention.
+     * <p>
+     * If not set, the default value of 128 KB will be used.
+     */
+    public static final String DEFAULT_S3_STREAM_BUFFER_SIZE =
+            "com.amazonaws.sdk.s3.defaultStreamBufferSize";
+
+    /**
+     * @deprecated by {@link #DEFAULT_METRICS_SYSTEM_PROPERTY}. Internal system
+     *             property to enable timing info collection.
+     */
+    @Deprecated
+    public static final String PROFILING_SYSTEM_PROPERTY =
+            "com.amazonaws.sdk.enableRuntimeProfiling";
+
+    // ///////////////////// Environment Variables ///////////////////////
+    /** Environment variable name for the AWS access key ID */
+    public static final String ACCESS_KEY_ENV_VAR = "AWS_ACCESS_KEY_ID";
+
+    /** Alternate environment variable name for the AWS access key ID */
+    public static final String ALTERNATE_ACCESS_KEY_ENV_VAR = "AWS_ACCESS_KEY";
+
+    /** Environment variable name for the AWS secret key */
+    public static final String SECRET_KEY_ENV_VAR = "AWS_SECRET_KEY";
+
+    /** Alternate environment variable name for the AWS secret key */
+    public static final String ALTERNATE_SECRET_KEY_ENV_VAR = "AWS_SECRET_ACCESS_KEY";
+
+    /** Environment variable name for the AWS session token */
+    public static final String AWS_SESSION_TOKEN_ENV_VAR = "AWS_SESSION_TOKEN";
+
+    /**
+     * GLOBAL_TIME_OFFSET is a time offset that is used to globally adjust the
+     * client clock skew. Java SDK already provides timeOffset and accessor
+     * methods in {@link Request} class but those are used per request, whereas
+     * this variable will adjust clock skew globally. Java SDK detects clock
+     * skew errors and adjusts global clock skew automatically.
+     */
+    private static final AtomicInteger GLOBAL_TIME_OFFSET = new AtomicInteger(0);
+
+    /**
+     * Sets the global time offset. If this value is set then all the subsequent
+     * requests will use this value to generate timestamps. To adjust clock skew
+     * per request use {@link Request#setTimeOffset(int)}
+     *
+     * @param timeOffset the time difference between local client and server
+     */
+    public static void setGlobalTimeOffset(int timeOffset) {
+        GLOBAL_TIME_OFFSET.set(timeOffset);
+    }
+
+    /**
+     * Gets the global time offset. See {@link Request#getTimeOffset()} if
+     * global time offset is not set.
+     *
+     * @return GLOBAL_TIME_OFFSET an AtomicInteger that holds the value of time
+     *         offset
+     */
+    public static int getGlobalTimeOffset() {
+        return GLOBAL_TIME_OFFSET.get();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/ServiceNameFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/ServiceNameFactory.java
new file mode 100644
index 0000000000..a57e96f012
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/ServiceNameFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws;
+
+import com.amazonaws.internal.config.HttpClientConfig;
+import com.amazonaws.internal.config.InternalConfig;
+
+/**
+ * An internal service name factory.
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+enum ServiceNameFactory {
+    ;
+
+    /**
+     * Returns a non-null signer for the specified service and region.
+     *
+     * @throws UnsupportedOperationException if the internal signer type
+     *             configured is not currently supported.
+     */
+    static String getServiceName(String httpClientName) {
+        InternalConfig config = InternalConfig.Factory.getInternalConfig();
+        HttpClientConfig clientConfig = config.getHttpClientConfig(httpClientName);
+        return clientConfig == null ? null : clientConfig.getServiceName();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS3Signer.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS3Signer.java
new file mode 100644
index 0000000000..938b5fb7a6
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS3Signer.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.util.DateUtils;
+import com.amazonaws.util.HttpUtils;
+import com.amazonaws.util.StringUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.net.MalformedURLException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.UUID;
+
+/**
+ * Signer implementation that signs requests with the AWS3 signing protocol.
+ */
+public class AWS3Signer extends AbstractAWSSigner {
+    private static final String AUTHORIZATION_HEADER = "X-Amzn-Authorization";
+    private static final String NONCE_HEADER = "x-amz-nonce";
+    private static final String HTTP_SCHEME = "AWS3";
+    private static final String HTTPS_SCHEME = "AWS3-HTTPS";
+
+    /**
+     * For internal testing only - allows the request's date to be overridden
+     * for testing.
+     */
+    private String overriddenDate;
+
+    private static final Log log = LogFactory.getLog(AWS3Signer.class);
+
+    /**
+     * Signs the specified request with the AWS3 signing protocol by using the
+     * AWS account credentials specified when this object was constructed and
+     * adding the required AWS3 headers to the request.
+     *
+     * @param request The request to sign.
+     */
+    @Override
+    public void sign(Request<?> request, AWSCredentials credentials) {
+        // annonymous credentials, don't sign
+        if (credentials instanceof AnonymousAWSCredentials) {
+            return;
+        }
+
+        AWSCredentials sanitizedCredentials = sanitizeCredentials(credentials);
+
+        SigningAlgorithm algorithm = SigningAlgorithm.HmacSHA256;
+        String nonce = UUID.randomUUID().toString();
+
+        int timeOffset = getTimeOffset(request);
+        Date dateValue = getSignatureDate(timeOffset);
+        String date = DateUtils.formatRFC822Date(dateValue);
+        boolean isHttps = false;
+
+        if (overriddenDate != null)
+            date = overriddenDate;
+        request.addHeader("Date", date);
+        request.addHeader("X-Amz-Date", date);
+
+        // AWS3 HTTP requires that we sign the Host header
+        // so we have to have it in the request by the time we sign.
+        String hostHeader = request.getEndpoint().getHost();
+        if (HttpUtils.isUsingNonDefaultPort(request.getEndpoint())) {
+            hostHeader += ":" + request.getEndpoint().getPort();
+        }
+        request.addHeader("Host", hostHeader);
+
+        if (sanitizedCredentials instanceof AWSSessionCredentials) {
+            addSessionCredentials(request, (AWSSessionCredentials) sanitizedCredentials);
+        }
+        byte[] bytesToSign;
+        String stringToSign;
+        if (isHttps) {
+            request.addHeader(NONCE_HEADER, nonce);
+            stringToSign = date + nonce;
+            bytesToSign = stringToSign.getBytes(UTF8);
+        } else {
+            String path = HttpUtils.appendUri(request.getEndpoint().getPath(),
+                    request.getResourcePath());
+
+            /*
+             * AWS3 requires all query params to be listed on the third line of
+             * the string to sign, even if those query params will be sent in
+             * the request body and not as a query string. POST formatted query
+             * params should *NOT* be included in the request payload.
+             */
+            stringToSign = request.getHttpMethod().toString() + "\n"
+                    + getCanonicalizedResourcePath(path) + "\n"
+                    + getCanonicalizedQueryString(request.getParameters()) + "\n"
+                    + getCanonicalizedHeadersForStringToSign(request) + "\n"
+                    + getRequestPayloadWithoutQueryParams(request);
+            bytesToSign = hash(stringToSign);
+        }
+        log.debug("Calculated StringToSign: " + stringToSign);
+
+        String signature = signAndBase64Encode(bytesToSign, sanitizedCredentials.getAWSSecretKey(),
+                algorithm);
+
+        StringBuilder builder = new StringBuilder();
+        builder.append(isHttps ? HTTPS_SCHEME : HTTP_SCHEME).append(" ");
+        builder.append("AWSAccessKeyId=" + sanitizedCredentials.getAWSAccessKeyId() + ",");
+        builder.append("Algorithm=" + algorithm.toString() + ",");
+
+        if (!isHttps) {
+            builder.append(getSignedHeadersComponent(request) + ",");
+        }
+
+        builder.append("Signature=" + signature);
+        request.addHeader(AUTHORIZATION_HEADER, builder.toString());
+    }
+
+    private String getSignedHeadersComponent(Request<?> request) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("SignedHeaders=");
+        boolean first = true;
+        for (String header : getHeadersForStringToSign(request)) {
+            if (!first)
+                builder.append(";");
+            builder.append(header);
+            first = false;
+        }
+        return builder.toString();
+    }
+
+    protected List<String> getHeadersForStringToSign(Request<?> request) {
+        List<String> headersToSign = new ArrayList<String>();
+        for (Map.Entry<String, String> entry : request.getHeaders().entrySet()) {
+            String key = entry.getKey();
+            String lowerCaseKey = StringUtils.lowerCase(key);
+            if (lowerCaseKey.startsWith("x-amz")
+                    || "host".equals(lowerCaseKey)) {
+                headersToSign.add(key);
+            }
+        }
+
+        Collections.sort(headersToSign);
+        return headersToSign;
+    }
+
+    /**
+     * For internal testing only - allows the date to be overridden for internal
+     * tests.
+     *
+     * @param date The RFC822 date string to use when signing requests.
+     */
+    void overrideDate(String date) {
+        this.overriddenDate = date;
+    }
+
+    protected String getCanonicalizedHeadersForStringToSign(Request<?> request) {
+        List<String> headersToSign = getHeadersForStringToSign(request);
+
+        for (int i = 0; i < headersToSign.size(); i++) {
+            headersToSign.set(i, StringUtils.lowerCase(headersToSign.get(i)));
+        }
+
+        SortedMap<String, String> sortedHeaderMap = new TreeMap<String, String>();
+        for (Map.Entry<String, String> entry : request.getHeaders().entrySet()) {
+            if (headersToSign.contains(StringUtils.lowerCase(entry.getKey()))) {
+                sortedHeaderMap.put(StringUtils.lowerCase(entry.getKey()), entry.getValue());
+            }
+        }
+
+        StringBuilder builder = new StringBuilder();
+        for (Map.Entry<String, String> entry : sortedHeaderMap.entrySet()) {
+            builder.append(StringUtils.lowerCase(entry.getKey())).append(":")
+                    .append(entry.getValue()).append("\n");
+        }
+
+        return builder.toString();
+    }
+
+    boolean shouldUseHttpsScheme(Request<?> request) {
+        try {
+            String protocol = StringUtils.lowerCase(request.getEndpoint().toURL().getProtocol());
+            if ("http".equals(protocol)) {
+                return false;
+            } else if ("https".equals(protocol)) {
+                return true;
+            } else {
+                throw new AmazonClientException("Unknown request endpoint protocol " +
+                        "encountered while signing request: " + protocol);
+            }
+        } catch (MalformedURLException e) {
+            throw new AmazonClientException("Unable to parse request endpoint during signing", e);
+        }
+    }
+
+    @Override
+    protected void addSessionCredentials(Request<?> request, AWSSessionCredentials credentials) {
+        request.addHeader("x-amz-security-token", credentials.getSessionToken());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS4Signer.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS4Signer.java
new file mode 100644
index 0000000000..b2c4f6cfce
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWS4Signer.java
@@ -0,0 +1,498 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.util.AwsHostNameUtils;
+import com.amazonaws.util.BinaryUtils;
+import com.amazonaws.util.DateUtils;
+import com.amazonaws.util.HttpUtils;
+import com.amazonaws.util.StringUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * Signer implementation that signs requests with the AWS4 signing protocol.
+ */
+public class AWS4Signer extends AbstractAWSSigner
+        implements ServiceAwareSigner, RegionAwareSigner, Presigner {
+
+    protected static final String ALGORITHM = "AWS4-HMAC-SHA256";
+    protected static final String TERMINATOR = "aws4_request";
+    private static final String DATE_PATTERN = "yyyyMMdd";
+    private static final String TIME_PATTERN = "yyyyMMdd'T'HHmmss'Z'";
+    private static final long MILLISEC = 1000L;
+
+    /** Seconds in a week, which is the max expiration time Sig-v4 accepts */
+    private static final long MAX_EXPIRATION_TIME_IN_SECONDS = 60 * 60 * 24 * 7;
+    /**
+     * Service name override for use when the endpoint can't be used to
+     * determine the service name.
+     */
+    protected String serviceName;
+
+    /**
+     * Region name override for use when the endpoint can't be used to determine
+     * the region name.
+     */
+    protected String regionName;
+
+    /** Date override for testing only */
+    protected Date overriddenDate;
+
+    /**
+     * Whether double url-encode the resource path when constructing the
+     * canonical request. By default, we enable double url-encoding. TODO:
+     * Different sigv4 services seem to be inconsistent on this. So for services
+     * that want to suppress this, they should use new AWS4Signer(false).
+     */
+    protected boolean doubleUrlEncode;
+
+    /**
+     * Construct a new AWS4 signer instance. By default, enable double
+     * url-encoding.
+     */
+    public AWS4Signer() {
+        this(true);
+    }
+
+    /**
+     * Construct a new AWS4 signer instance.
+     *
+     * @param doubleUrlEncoding Whether double url-encode the resource path when
+     *            constructing the canonical request.
+     */
+    public AWS4Signer(boolean doubleUrlEncoding) {
+        this.doubleUrlEncode = doubleUrlEncoding;
+    }
+
+    protected static final Log log = LogFactory.getLog(AWS4Signer.class);
+
+    @Override
+    public void sign(Request<?> request, AWSCredentials credentials) {
+        // annonymous credentials, don't sign
+        if (credentials instanceof AnonymousAWSCredentials) {
+            return;
+        }
+
+        final AWSCredentials sanitizedCredentials = sanitizeCredentials(credentials);
+        if (sanitizedCredentials instanceof AWSSessionCredentials) {
+            addSessionCredentials(request, (AWSSessionCredentials) sanitizedCredentials);
+        }
+
+        addHostHeader(request);
+
+        final long dateMilli = getDateFromRequest(request);
+
+        final String dateStamp = getDateStamp(dateMilli);
+        final String scope = getScope(request, dateStamp);
+
+        final String contentSha256 = calculateContentHash(request);
+
+        final String timeStamp = getTimeStamp(dateMilli);
+        request.addHeader("X-Amz-Date", timeStamp);
+
+        if (request.getHeaders().get("x-amz-content-sha256") != null
+                && "required".equals(request.getHeaders().get("x-amz-content-sha256"))) {
+            request.addHeader("x-amz-content-sha256", contentSha256);
+        }
+
+        final String signingCredentials = sanitizedCredentials.getAWSAccessKeyId() + "/" + scope;
+
+        final HeaderSigningResult headerSigningResult = computeSignature(
+                request,
+                dateStamp,
+                timeStamp,
+                ALGORITHM,
+                contentSha256,
+                sanitizedCredentials);
+
+        final String credentialsAuthorizationHeader =
+                "Credential=" + signingCredentials;
+        final String signedHeadersAuthorizationHeader =
+                "SignedHeaders=" + getSignedHeadersString(request);
+        final String signatureAuthorizationHeader =
+                "Signature=" + BinaryUtils.toHex(headerSigningResult.getSignature());
+
+        final String authorizationHeader = ALGORITHM + " "
+                + credentialsAuthorizationHeader + ", "
+                + signedHeadersAuthorizationHeader + ", "
+                + signatureAuthorizationHeader;
+
+        request.addHeader("Authorization", authorizationHeader);
+
+        processRequestPayload(request, headerSigningResult);
+    }
+
+    /**
+     * Sets the service name that this signer should use when calculating
+     * request signatures. This can almost always be determined directly from
+     * the request's end point, so you shouldn't need this method, but it's
+     * provided for the edge case where the information is not in the endpoint.
+     *
+     * @param serviceName The service name to use when calculating signatures in
+     *            this signer.
+     */
+    @Override
+    public void setServiceName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    /**
+     * Sets the region name that this signer should use when calculating request
+     * signatures. This can almost always be determined directly from the
+     * request's end point, so you shouldn't need this method, but it's provided
+     * for the edge case where the information is not in the endpoint.
+     *
+     * @param regionName The region name to use when calculating signatures in
+     *            this signer.
+     */
+    @Override
+    public void setRegionName(String regionName) {
+        this.regionName = regionName;
+    }
+
+    @Override
+    protected void addSessionCredentials(Request<?> request, AWSSessionCredentials credentials) {
+        request.addHeader("x-amz-security-token", credentials.getSessionToken());
+    }
+
+    protected String extractRegionName(URI endpoint) {
+        if (regionName != null) {
+            return regionName;
+        }
+
+        return AwsHostNameUtils.parseRegionName(endpoint.getHost(),
+                serviceName);
+    }
+
+    protected String extractServiceName(URI endpoint) {
+        if (serviceName != null) {
+            return serviceName;
+        }
+
+        // This should never actually be called, as we should always be setting
+        // a service name on the signer; retain it for now in case anyone is
+        // using the AWS4Signer directly and not setting a service name
+        // explicitly.
+
+        return AwsHostNameUtils.parseServiceName(endpoint);
+    }
+
+    @SuppressWarnings("checkstyle:hiddenfield")
+    void overrideDate(Date overriddenDate) {
+        this.overriddenDate = overriddenDate;
+    }
+
+    protected String getCanonicalizedHeaderString(Request<?> request) {
+        final List<String> sortedHeaders = new ArrayList<String>();
+        sortedHeaders.addAll(request.getHeaders().keySet());
+        Collections.sort(sortedHeaders, String.CASE_INSENSITIVE_ORDER);
+
+        final StringBuilder buffer = new StringBuilder();
+        for (final String header : sortedHeaders) {
+            if (needsSign(header)) {
+                final String key = StringUtils.lowerCase(header).replaceAll("\\s+", " ");
+                final String value = request.getHeaders().get(header);
+
+                buffer.append(key).append(":");
+                if (value != null) {
+                    buffer.append(value.replaceAll("\\s+", " "));
+                }
+
+                buffer.append("\n");
+            }
+        }
+
+        return buffer.toString();
+    }
+
+    protected String getSignedHeadersString(Request<?> request) {
+        final List<String> sortedHeaders = new ArrayList<String>();
+        sortedHeaders.addAll(request.getHeaders().keySet());
+        Collections.sort(sortedHeaders, String.CASE_INSENSITIVE_ORDER);
+
+        final StringBuilder buffer = new StringBuilder();
+        for (final String header : sortedHeaders) {
+            if (needsSign(header)) {
+                if (buffer.length() > 0) {
+                    buffer.append(";");
+                }
+                buffer.append(StringUtils.lowerCase(header));
+            }
+        }
+
+        return buffer.toString();
+    }
+
+    protected String getCanonicalRequest(Request<?> request, String contentSha256) {
+        /* This would url-encode the resource path for the first time */
+        final String path = HttpUtils.appendUri(request.getEndpoint().getPath(),
+                request.getResourcePath());
+
+        final String canonicalRequest =
+                request.getHttpMethod().toString() + "\n" +
+                        /*
+                         * This would optionally double url-encode the resource
+                         * path
+                         */
+                        getCanonicalizedResourcePath(path, doubleUrlEncode) + "\n" +
+                        getCanonicalizedQueryString(request) + "\n" +
+                        getCanonicalizedHeaderString(request) + "\n" +
+                        getSignedHeadersString(request) + "\n" +
+                        contentSha256;
+        log.debug("AWS4 Canonical Request: '\"" + canonicalRequest + "\"");
+        return canonicalRequest;
+    }
+
+    protected String getStringToSign(String algorithm, String dateTime, String scope,
+            String canonicalRequest) {
+        final String stringToSign =
+                algorithm + "\n" +
+                        dateTime + "\n" +
+                        scope + "\n" +
+                        BinaryUtils.toHex(hash(canonicalRequest));
+        log.debug("AWS4 String to Sign: '\"" + stringToSign + "\"");
+        return stringToSign;
+    }
+
+    @SuppressWarnings("checkstyle:hiddenfield")
+    protected final HeaderSigningResult computeSignature(
+            Request<?> request,
+            String dateStamp,
+            String timeStamp,
+            String algorithm,
+            String contentSha256,
+            AWSCredentials sanitizedCredentials) {
+        final String regionName = extractRegionName(request.getEndpoint());
+        final String serviceName = extractServiceName(request.getEndpoint());
+        final String scope = dateStamp + "/" + regionName + "/" + serviceName + "/" + TERMINATOR;
+
+        final String stringToSign = getStringToSign(algorithm, timeStamp, scope,
+                getCanonicalRequest(request, contentSha256));
+
+        // AWS4 uses a series of derived keys, formed by hashing different
+        // pieces of data
+        final byte[] kSecret = ("AWS4" + sanitizedCredentials.getAWSSecretKey())
+                .getBytes(StringUtils.UTF8);
+        final byte[] kDate = sign(dateStamp, kSecret, SigningAlgorithm.HmacSHA256);
+        final byte[] kRegion = sign(regionName, kDate, SigningAlgorithm.HmacSHA256);
+        final byte[] kService = sign(serviceName, kRegion, SigningAlgorithm.HmacSHA256);
+        final byte[] kSigning = sign(TERMINATOR, kService, SigningAlgorithm.HmacSHA256);
+
+        final byte[] signature = sign(stringToSign.getBytes(StringUtils.UTF8), kSigning,
+                SigningAlgorithm.HmacSHA256);
+        return new HeaderSigningResult(timeStamp, scope, kSigning, signature);
+    }
+
+    protected final String getTimeStamp(long dateMilli) {
+        return DateUtils.format(TIME_PATTERN, new Date(dateMilli));
+    }
+
+    protected final String getDateStamp(long dateMilli) {
+        return DateUtils.format(DATE_PATTERN, new Date(dateMilli));
+    }
+
+    protected final long getDateFromRequest(Request<?> request) {
+        final int timeOffset = getTimeOffset(request);
+        Date date = getSignatureDate(timeOffset);
+        if (overriddenDate != null) {
+            date = overriddenDate;
+        }
+        return date.getTime();
+    }
+
+    protected void addHostHeader(Request<?> request) {
+        // AWS4 requires that we sign the Host header so we
+        // have to have it in the request by the time we sign.
+        String hostHeader = request.getEndpoint().getHost();
+        if (HttpUtils.isUsingNonDefaultPort(request.getEndpoint())) {
+            hostHeader += ":" + request.getEndpoint().getPort();
+        }
+        request.addHeader("Host", hostHeader);
+    }
+
+    @SuppressWarnings("checkstyle:hiddenfield")
+    protected String getScope(Request<?> request, String dateStamp) {
+        final String regionName = extractRegionName(request.getEndpoint());
+        final String serviceName = extractServiceName(request.getEndpoint());
+        final String scope = dateStamp + "/" + regionName + "/" + serviceName + "/" + TERMINATOR;
+        return scope;
+    }
+
+    /**
+     * Calculate the hash of the request's payload. Subclass could override this
+     * method to provide different values for "x-amz-content-sha256" header or
+     * do any other necessary set-ups on the request headers. (e.g. aws-chunked
+     * uses a pre-defined header value, and needs to change some headers
+     * relating to content-encoding and content-length.)
+     */
+    protected String calculateContentHash(Request<?> request) {
+        final InputStream payloadStream = getBinaryRequestPayloadStream(request);
+        payloadStream.mark(-1);
+        final String contentSha256 = BinaryUtils.toHex(hash(payloadStream));
+        try {
+            payloadStream.reset();
+        } catch (final IOException e) {
+            throw new AmazonClientException(
+                    "Unable to reset stream after calculating AWS4 signature", e);
+        }
+        return contentSha256;
+    }
+
+    /**
+     * Subclass could override this method to perform any additional procedure
+     * on the request payload, with access to the result from signing the
+     * header. (e.g. Signing the payload by chunk-encoding). The default
+     * implementation doesn't need to do anything.
+     */
+    protected void processRequestPayload(Request<?> request, HeaderSigningResult headerSigningResult) {
+        return;
+    }
+
+    protected static class HeaderSigningResult {
+
+        private final String dateTime;
+        private final String scope;
+        private final byte[] kSigning;
+        private final byte[] signature;
+
+        public HeaderSigningResult(String dateTime, String scope, byte[] kSigning, byte[] signature) {
+            this.dateTime = dateTime;
+            this.scope = scope;
+            this.kSigning = kSigning;
+            this.signature = signature;
+        }
+
+        public String getDateTime() {
+            return dateTime;
+        }
+
+        public String getScope() {
+            return scope;
+        }
+
+        public byte[] getKSigning() {
+            final byte[] kSigningCopy = new byte[kSigning.length];
+            System.arraycopy(kSigning, 0, kSigningCopy, 0, kSigning.length);
+            return kSigningCopy;
+        }
+
+        public byte[] getSignature() {
+            final byte[] signatureCopy = new byte[signature.length];
+            System.arraycopy(signature, 0, signatureCopy, 0, signature.length);
+            return signatureCopy;
+        }
+    }
+
+    @Override
+    public void presignRequest(Request<?> request, AWSCredentials credentials,
+            Date expiration) {
+
+        // annonymous credentials, don't sign
+        if (credentials instanceof AnonymousAWSCredentials) {
+            return;
+        }
+
+        long expirationInSeconds = MAX_EXPIRATION_TIME_IN_SECONDS;
+
+        if (expiration != null) {
+            expirationInSeconds = (expiration.getTime() - System
+                    .currentTimeMillis()) / MILLISEC;
+        }
+
+        if (expirationInSeconds > MAX_EXPIRATION_TIME_IN_SECONDS) {
+            throw new AmazonClientException(
+                    "Requests that are pre-signed by SigV4 algorithm are valid for at most 7 days. "
+                            + "The expiration date set on the current request ["
+                            + getTimeStamp(expiration.getTime())
+                            + "] has exceeded this limit.");
+        }
+
+        addHostHeader(request);
+
+        final AWSCredentials sanitizedCredentials = sanitizeCredentials(credentials);
+
+        if (sanitizedCredentials instanceof AWSSessionCredentials) {
+            // For SigV4 pre-signing URL, we need to add "x-amz-security-token"
+            // as a query string parameter, before constructing the canonical
+            // request.
+            request.addParameter("X-Amz-Security-Token",
+                    ((AWSSessionCredentials) sanitizedCredentials)
+                            .getSessionToken());
+        }
+
+        final long dateMilli = getDateFromRequest(request);
+        final String dateStamp = getDateStamp(dateMilli);
+
+        final String scope = getScope(request, dateStamp);
+
+        final String signingCredentials = sanitizedCredentials.getAWSAccessKeyId()
+                + "/" + scope;
+
+        // Add the important parameters for v4 signing
+        final String timeStamp = getTimeStamp(dateMilli);
+        request.addParameter("X-Amz-Algorithm", ALGORITHM);
+        request.addParameter("X-Amz-Date", timeStamp);
+        request.addParameter("X-Amz-SignedHeaders",
+                getSignedHeadersString(request));
+        request.addParameter("X-Amz-Expires",
+                Long.toString(expirationInSeconds));
+        request.addParameter("X-Amz-Credential", signingCredentials);
+
+        final String contentSha256 = calculateContentHashPresign(request);
+
+        final HeaderSigningResult headerSigningResult = computeSignature(request,
+                dateStamp, timeStamp, ALGORITHM, contentSha256,
+                sanitizedCredentials);
+        request.addParameter("X-Amz-Signature",
+                BinaryUtils.toHex(headerSigningResult.getSignature()));
+    }
+
+    /**
+     * Calculate the hash of the request's payload. In case of pre-sign, the
+     * existing code would generate the hash of an empty byte array and returns
+     * it. This method can be overridden by sub classes to provide different
+     * values (e.g) For S3 pre-signing, the content hash calculation is
+     * different from the general implementation.
+     */
+    protected String calculateContentHashPresign(Request<?> request) {
+        return calculateContentHash(request);
+    }
+
+    /**
+     * Determine if a header needs to be signed. The headers must be signed
+     * according to sigv4 spec are host, date, Content-MD5and all x-amz headers.
+     *
+     * @param header header key
+     * @return true if it should be sign, false otherwise
+     */
+    boolean needsSign(String header) {
+        return "date".equalsIgnoreCase(header) || "Content-MD5".equalsIgnoreCase(header)
+                || "host".equalsIgnoreCase(header)
+                || header.startsWith("x-amz") || header.startsWith("X-Amz");
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoDeveloperIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoDeveloperIdentityProvider.java
new file mode 100644
index 0000000000..388df11587
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoDeveloperIdentityProvider.java
@@ -0,0 +1,120 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.regions.Region;
+import com.amazonaws.regions.Regions;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentity;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+
+/**
+ * An extension of the AbstractCognitoProvider that provides a class which
+ * developers can extend for implementing a developer provider, when using
+ * developer authenticated identities
+ */
+public abstract class AWSAbstractCognitoDeveloperIdentityProvider extends
+        AWSAbstractCognitoIdentityProvider {
+
+    /**
+     * Wraps around the AbstractIdentityProvider to cover some back end code
+     * that is consistent across all providers, utilizing the CIB client to
+     * handle the identity management.
+     *
+     * @deprecated please use AWSAbstractCognitoDeveloperIdentityProvider(String
+     *             accountId, String identityPoolId, Regions region) instead
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     */
+    @Deprecated
+    public AWSAbstractCognitoDeveloperIdentityProvider(String accountId, String identityPoolId) {
+        this(accountId, identityPoolId, new ClientConfiguration());
+    }
+
+    /**
+     * Wraps around the AbstractIdentityProvider to cover some back end code
+     * that is consistent across all providers, utilizing the CIB client to
+     * handle the identity management.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param region the region the cib client will use
+     */
+    public AWSAbstractCognitoDeveloperIdentityProvider(String accountId, String identityPoolId,
+            Regions region) {
+        this(accountId, identityPoolId, new ClientConfiguration(), region);
+    }
+
+    /**
+     * Wraps around the AbstractIdentityProvider to cover some back end code
+     * that is consistent across all providers, utilizing the CIB client to
+     * handle the identity management.
+     *
+     * @deprecated please use AWSAbstractCognitoDeveloperIdentityProvider(String
+     *             accountId, String identityPoolId, ClientConfiguration
+     *             clientConfiguration, Regions region) instead
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param clientConfiguration the configuration to apply to service clients
+     *            created
+     */
+    @Deprecated
+    public AWSAbstractCognitoDeveloperIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+    }
+
+    /**
+     * Wraps around the AbstractIdentityProvider to cover some back end code
+     * that is consistent across all providers, utilizing the CIB client to
+     * handle the identity management.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param clientConfiguration the configuration to apply to service clients
+     *            created
+     * @param region the region the cib client will use
+     */
+    public AWSAbstractCognitoDeveloperIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration, Regions region) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+        this.cib.setRegion(Region.getRegion(region));
+    }
+
+    /**
+     * Wraps around the AbstractIdentityProvider to cover some back end code
+     * that is consistent across all providers, utilizing the CIB client to
+     * handle the identity management.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param cibClient the cib client which will be used to contact the cib
+     *            back end
+     */
+    public AWSAbstractCognitoDeveloperIdentityProvider(String accountId, String identityPoolId,
+            AmazonCognitoIdentity cibClient) {
+        super(accountId, identityPoolId, cibClient);
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSBasicCognitoIdentityProvider#getProviderName()
+     */
+    @Override
+    public abstract String getProviderName();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoIdentityProvider.java
new file mode 100644
index 0000000000..b5c06901ce
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSAbstractCognitoIdentityProvider.java
@@ -0,0 +1,320 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.regions.Region;
+import com.amazonaws.regions.Regions;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentity;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+import com.amazonaws.services.cognitoidentity.model.GetIdRequest;
+import com.amazonaws.services.cognitoidentity.model.GetIdResult;
+import com.amazonaws.services.cognitoidentity.model.GetOpenIdTokenRequest;
+import com.amazonaws.services.cognitoidentity.model.GetOpenIdTokenResult;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * This class utilizes Cognito as a means to get an identity and dispense an
+ * identityId and token. It also handles the refreshing of the token and
+ * identityId.
+ */
+public abstract class AWSAbstractCognitoIdentityProvider implements AWSCognitoIdentityProvider {
+
+    /** The client for communication with Cognito */
+    protected final AmazonCognitoIdentity cib;
+
+    /**
+     * The data structures that won't vary between cognito and developer
+     * providers
+     */
+    protected String identityId;
+    private final String accountId;
+    private final String identityPoolId;
+    protected String token;
+
+    protected List<IdentityChangedListener> listeners;
+    protected Map<String, String> loginsMap;
+
+    /**
+     * Sets up an AWSAbstractCognitoIdentityProvider, which will serve as the
+     * baseline for both Cognito and developer trusted identity providers.
+     * Custom providers should not extend this class, but should extend
+     * AWSAbstractCognitoDeveloperIdentityProvider
+     *
+     * @param accountId the accountId of the developer
+     * @param identityPoolId the identityPoolId to be used
+     * @param cibClient the cib client which will communicate with cognito
+     */
+    public AWSAbstractCognitoIdentityProvider(String accountId, String identityPoolId,
+            AmazonCognitoIdentity cibClient) {
+        this.accountId = accountId;
+        this.identityPoolId = identityPoolId;
+        this.loginsMap = new HashMap<String, String>();
+        this.listeners = new ArrayList<IdentityChangedListener>();
+        this.cib = cibClient;
+    }
+
+    /**
+     * Sets up an AWSAbstractCognitoIdentityProvider, which will serve as the
+     * baseline for both Cognito and developer trusted identity providers.
+     * Custom providers should not extend this class, but should extend
+     * AWSAbstractCognitoDeveloperIdentityProvider
+     *
+     * @deprecated please use AWSAbstractCognitoIdentityProvider(String
+     *             accountId, String identityPoolId, ClientConfiguration
+     *             clientConfiguration, Regions region) instead.
+     * @param accountId the accountId of the developer
+     * @param identityPoolId the identityPoolId to be used
+     * @param clientConfiguration the client configuration to be used by the
+     *            client
+     */
+    @Deprecated
+    public AWSAbstractCognitoIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+    }
+
+    /**
+     * Sets up an AWSAbstractCognitoIdentityProvider, which will serve as the
+     * baseline for both Cognito and developer trusted identity providers.
+     * Custom providers should not extend this class, but should extend
+     * AWSAbstractCognitoDeveloperIdentityProvider
+     *
+     * @param accountId the accountId of the developer
+     * @param identityPoolId the identityPoolId to be used
+     * @param clientConfiguration the client configuration to be used by the
+     *            client
+     * @param region the region cognito will use
+     */
+    public AWSAbstractCognitoIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration,
+            Regions region) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+        this.cib.setRegion(Region.getRegion(region));
+    }
+
+    /**
+     * Sets up an AWSAbstractCognitoIdentityProvider, which will serve as the
+     * baseline for both Cognito and developer trusted identity providers.
+     * Custom providers should not extend this class, but should extend
+     * AWSAbstractCognitoDeveloperIdentityProvider
+     *
+     * @deprecated please use AWSAbstractCognitoIdentityProvider(String
+     *             accountId, String identityPoolId, Regions region) instead.
+     * @param accountId the accountId of the developer
+     * @param identityPoolId the identityPoolId to be used
+     */
+    @Deprecated
+    public AWSAbstractCognitoIdentityProvider(String accountId, String identityPoolId) {
+        this(accountId, identityPoolId, new ClientConfiguration());
+    }
+
+    /**
+     * Sets up an AWSAbstractCognitoIdentityProvider, which will serve as the
+     * baseline for both Cognito and developer trusted identity providers.
+     * Custom providers should not extend this class, but should extend
+     * AWSAbstractCognitoDeveloperIdentityProvider
+     *
+     * @param accountId the accountId of the developer
+     * @param identityPoolId the identityPoolId to be used
+     * @param region the region cib will use
+     */
+    public AWSAbstractCognitoIdentityProvider(String accountId, String identityPoolId,
+            Regions region) {
+        this(accountId, identityPoolId, new ClientConfiguration(), region);
+    }
+
+    /**
+     * Gets a string with the name of the provider being used. For example,
+     * Cognito would return "Cognito"
+     *
+     * @return the name of the provider in a string
+     */
+    public abstract String getProviderName();
+
+    /**
+     * Gets a reference to the identityId of the user (sending a new request if
+     * it isn't yet set), using the dev accountId, identityPoolId, and the
+     * user's loginsMap to identify.
+     */
+    @Override
+    public String getIdentityId() {
+        if (identityId == null) {
+            GetIdRequest getIdRequest = new GetIdRequest()
+                    .withAccountId(getAccountId())
+                    .withIdentityPoolId(getIdentityPoolId())
+                    .withLogins(loginsMap);
+
+            appendUserAgent(getIdRequest, getUserAgent());
+
+            GetIdResult getIdResult = cib.getId(getIdRequest);
+
+            if (getIdResult.getIdentityId() != null) {
+                identityChanged(getIdResult.getIdentityId());
+            }
+        }
+        return identityId;
+    }
+
+    protected void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * With the logins and identityId to mark the user, it builds a request to
+     * the cognito back end, and returns the token cib hands back
+     */
+    @Override
+    public String getToken() {
+        if (this.token == null) {
+            GetOpenIdTokenRequest getTokenRequest = new GetOpenIdTokenRequest()
+                    .withIdentityId(getIdentityId()).withLogins(loginsMap);
+
+            appendUserAgent(getTokenRequest, getUserAgent());
+
+            GetOpenIdTokenResult getTokenResult = cib
+                    .getOpenIdToken(getTokenRequest);
+
+            if (!getTokenResult.getIdentityId().equals(getIdentityId())) {
+                identityChanged(getTokenResult.getIdentityId());
+            }
+            this.token = getTokenResult.getToken();
+        }
+        return token;
+    }
+
+    protected void setToken(String token) {
+        this.token = token;
+    }
+
+    @Override
+    public String getIdentityPoolId() {
+        return identityPoolId;
+    }
+
+    public String getAccountId() {
+        return accountId;
+    }
+
+    @Override
+    public Map<String, String> getLogins() {
+        return loginsMap;
+    }
+
+    @Override
+    public void setLogins(Map<String, String> logins) {
+        loginsMap = logins;
+    }
+
+    @Override
+    public boolean isAuthenticated() {
+        return ((loginsMap != null) && (loginsMap.size() > 0));
+    }
+
+    @Override
+    public void unregisterIdentityChangedListener(IdentityChangedListener listener) {
+        listeners.remove(listener);
+    }
+
+    @Override
+    public void registerIdentityChangedListener(IdentityChangedListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Updates the listeners and establishes the new identityId as the stored
+     * identityId
+     *
+     * @param newIdentityId the identityId to be saved
+     */
+    @Override
+    public void identityChanged(String newIdentityId) {
+        if (identityId != null && identityId.equals(newIdentityId)) {
+            return;
+        }
+        String oldIdentityId = identityId;
+        identityId = newIdentityId;
+        for (IdentityChangedListener listener: listeners) {
+            listener.identityChanged(oldIdentityId, identityId);
+        }
+    }
+
+    /**
+     * Append user agent string to the request. The final string is what is set
+     * in the ClientCofniguration concatenated with the given userAgent string.
+     *
+     * @param request the request object to be appended
+     * @param userAgent additional user agent string to append
+     */
+    protected void appendUserAgent(AmazonWebServiceRequest request, String userAgent) {
+        request.getRequestClientOptions().appendUserAgent(userAgent);
+    }
+
+    @Override
+    public void clearListeners() {
+        listeners.clear();
+    }
+
+    /**
+     * Gets the user agent string to append to all requests made by this
+     * provider. Default is an empty string.
+     * 
+     * @return the user agent string
+     */
+    protected String getUserAgent() {
+        return "";
+    }
+
+    /**
+     * To be used to update the identityId and token after a call to refresh
+     * from an identityProvider. Note, this is the only call that is needed
+     * after the refresh call terminates, and it is explicitly necessary. Do not
+     * call setIdentity and/or setToken in addition to this, or it could cause
+     * unexpected behavior.
+     *
+     * @param identityId the new identityId to be used for the user
+     * @param token the new token to be used with STS
+     */
+    protected void update(String identityId, String token) {
+        if (this.identityId == null || !this.identityId.equals(identityId)) {
+            identityChanged(identityId);
+        }
+        if (this.token == null || !this.token.equals(token)) {
+            this.token = token;
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSIdentityProvider#refresh()
+     */
+    @Override
+    public String refresh() {
+        getIdentityId();
+        String token = getToken();
+        update(getIdentityId(), token);
+        return token;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSBasicCognitoIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSBasicCognitoIdentityProvider.java
new file mode 100644
index 0000000000..5ebb2f4e8d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSBasicCognitoIdentityProvider.java
@@ -0,0 +1,80 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentity;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+
+/**
+ * An extension of the AbstractCognitoProvider that is used to communicate with
+ * Cognito. All other functionality is the same as that of
+ * AbstractCognitoIdentityProvider
+ */
+public class AWSBasicCognitoIdentityProvider extends AWSAbstractCognitoIdentityProvider {
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     */
+    public AWSBasicCognitoIdentityProvider(String accountId, String identityPoolId) {
+        this(accountId, identityPoolId, new ClientConfiguration());
+    }
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param clientConfiguration the configuration to apply to service clients
+     *            created
+     */
+    public AWSBasicCognitoIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+    }
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param cibClient the cib client which will be used to contact the cib
+     *            back end
+     */
+    public AWSBasicCognitoIdentityProvider(String accountId, String identityPoolId,
+            AmazonCognitoIdentity cibClient) {
+        super(accountId, identityPoolId, cibClient);
+    }
+
+    @Override
+    public String getProviderName() {
+        return "Cognito";
+    }
+
+    @Override
+    public String refresh() {
+        setToken(null);
+        return super.refresh();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCognitoIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCognitoIdentityProvider.java
new file mode 100644
index 0000000000..082bf49239
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCognitoIdentityProvider.java
@@ -0,0 +1,93 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import java.util.Map;
+
+/**
+ * A container of data pertinent to a single provider, and will handle most of
+ * the interactions with said provider and the client. This includes some more
+ * logic for custom identity providers, but shouldn't be implemented to do so.
+ * It is utilized by the AWSAbstractCognitoIdentityProvider, which is what
+ * should be extended to do so.
+ */
+public interface AWSCognitoIdentityProvider extends AWSIdentityProvider {
+
+    /**
+     * Gets the identityId of the user
+     *
+     * @return the identityId of the user
+     */
+    public String getIdentityId();
+
+    /**
+     * Get the identityPoolId from the provider
+     *
+     * @return the identityPoolId
+     */
+    public String getIdentityPoolId();
+
+    /**
+     * Pass the logins to the provider
+     *
+     * @param loginsMap the logins map
+     */
+    public void setLogins(Map<String, String> loginsMap);
+
+    /**
+     * Get the logins from the provider
+     *
+     * @return the logins map
+     */
+    public Map<String, String> getLogins();
+
+    /**
+     * Checks if the current identityId belongs to an authenticated user
+     *
+     * @return true if the identity is authenticated
+     */
+    public boolean isAuthenticated();
+
+    /**
+     * Handles the new version of an identity changed listener to be handled by
+     * the provider
+     * 
+     * @param listener the new listener to be registered
+     */
+    public void registerIdentityChangedListener(IdentityChangedListener listener);
+
+    /**
+     * Handles the removing of a version of an identity changed listener from
+     * the list with the provider
+     * 
+     * @param listener the listener to be removed
+     */
+    public void unregisterIdentityChangedListener(IdentityChangedListener listener);
+
+
+    /**
+     * Handles the updating of the identityId locally once it has been changed
+     * for one reason or another
+     *
+     * @param newIdentity the new identityId for the user
+     */
+    public void identityChanged(String newIdentity);
+
+    /**
+     * To be used to empty all registered listeners from the identity provider
+     */
+    public void clearListeners();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentials.java
new file mode 100644
index 0000000000..9151d1bc11
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentials.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Provides access to the AWS credentials used for accessing AWS services: AWS
+ * access key ID and secret access key. These credentials are used to securely
+ * sign requests to AWS services.
+ * <p>
+ * A basic implementation of this interface is provided in
+ * {@link BasicAWSCredentials}, but callers are free to provide their own
+ * implementation, for example, to load AWS credentials from an encrypted file.
+ * <p>
+ * For more details on AWS access keys, see: <a href=
+ * "http://docs.amazonwebservices.com/AWSSecurityCredentials/1.0/AboutAWSCredentials.html#AccessKeys"
+ * >http://docs.amazonwebservices.com/AWSSecurityCredentials/1.0/
+ * AboutAWSCredentials.html#AccessKeys</a>
+ */
+public interface AWSCredentials {
+
+    /**
+     * Returns the AWS access key ID for this credentials object.
+     *
+     * @return The AWS access key ID for this credentials object.
+     */
+    public String getAWSAccessKeyId();
+
+    /**
+     * Returns the AWS secret access key for this credentials object.
+     *
+     * @return The AWS secret access key for this credentials object.
+     */
+    public String getAWSSecretKey();
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProvider.java
new file mode 100644
index 0000000000..bf44cf2002
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProvider.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Interface for providing AWS credentials. Implementations are free to use any
+ * strategy for providing AWS credentials, such as simply providing static
+ * credentials that don't change, or more complicated implementations, such as
+ * integrating with existing key management systems.
+ */
+public interface AWSCredentialsProvider {
+
+    /**
+     * Returns AWSCredentials which the caller can use to authorize an AWS
+     * request. Each implementation of AWSCredentialsProvider can chose its own
+     * strategy for loading credentials. For example, an implementation might
+     * load credentials from an existing key management system, or load new
+     * credentials when credentials are rotated.
+     *
+     * @return AWSCredentials which the caller can use to authorize an AWS
+     *         request.
+     */
+    public AWSCredentials getCredentials();
+
+    /**
+     * Forces this credentials provider to refresh its credentials. For many
+     * implementations of credentials provider, this method may simply be a
+     * no-op, such as any credentials provider implementation that vends
+     * static/non-changing credentials. For other implementations that vend
+     * different credentials through out their lifetime, this method should
+     * force the credentials provider to refresh its credentials.
+     */
+    public void refresh();
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProviderChain.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProviderChain.java
new file mode 100644
index 0000000000..6cfc9ebee2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSCredentialsProviderChain.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonClientException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * {@link AWSCredentialsProvider} implementation that chains together multiple
+ * credentials providers. When a caller first requests credentials from this
+ * provider, it calls all the providers in the chain, in the original order
+ * specified, until one can provide credentials, and then returns those
+ * credentials. If all of the credential providers in the chain have been
+ * called, and none of them can provide credentials, then this class will throw
+ * an exception indicated that no credentials are available.
+ * <p>
+ * By default, this class will remember the first credentials provider in the
+ * chain that was able to provide credentials, and will continue to use that
+ * provider when credentials are requested in the future, instead of traversing
+ * the chain each time. This behavior can be controlled through the
+ * {@link #setReuseLastProvider(boolean)} method.
+ */
+public class AWSCredentialsProviderChain implements AWSCredentialsProvider {
+
+    private static final Log log = LogFactory.getLog(AWSCredentialsProviderChain.class);
+
+    private List<AWSCredentialsProvider> credentialsProviders =
+            new LinkedList<AWSCredentialsProvider>();
+
+    private boolean reuseLastProvider = true;
+    private AWSCredentialsProvider lastUsedProvider;
+
+    /**
+     * Constructs a new AWSCredentialsProviderChain with the specified
+     * credential providers. When credentials are requested from this provider,
+     * it will call each of these credential providers in the same order
+     * specified here until one of them returns AWS security credentials.
+     *
+     * @param credentialsProviders The chain of credentials providers.
+     */
+    public AWSCredentialsProviderChain(AWSCredentialsProvider... credentialsProviders) {
+        if (credentialsProviders == null || credentialsProviders.length == 0)
+            throw new IllegalArgumentException("No credential providers specified");
+
+        for (AWSCredentialsProvider provider : credentialsProviders) {
+            this.credentialsProviders.add(provider);
+        }
+    }
+
+    /**
+     * Returns true if this chain will reuse the last successful credentials
+     * provider for future credentials requests, otherwise, false if it will
+     * search through the chain each time.
+     *
+     * @return True if this chain will reuse the last successful credentials
+     *         provider for future credentials requests.
+     */
+    public boolean getReuseLastProvider() {
+        return reuseLastProvider;
+    }
+
+    /**
+     * Enables or disables caching of the last successful credentials provider
+     * in this chain. Reusing the last successful credentials provider will
+     * typically return credentials faster than searching through the chain.
+     *
+     * @param b Whether to enable or disable reusing the last successful
+     *            credentials provider for future credentials requests instead
+     *            of searching through the whole chain.
+     */
+    public void setReuseLastProvider(boolean b) {
+        this.reuseLastProvider = b;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        if (reuseLastProvider && lastUsedProvider != null) {
+            return lastUsedProvider.getCredentials();
+        }
+
+        for (AWSCredentialsProvider provider : credentialsProviders) {
+            try {
+                AWSCredentials credentials = provider.getCredentials();
+
+                if (credentials.getAWSAccessKeyId() != null &&
+                        credentials.getAWSSecretKey() != null) {
+                    log.debug("Loading credentials from " + provider.toString());
+
+                    lastUsedProvider = provider;
+                    return credentials;
+                }
+            } catch (Exception e) {
+                // Ignore any exceptions and move onto the next provider
+                log.debug("Unable to load credentials from " + provider.toString() +
+                        ": " + e.getMessage());
+            }
+        }
+
+        throw new AmazonClientException(
+                "Unable to load AWS credentials from any provider in the chain");
+    }
+
+    @Override
+    public void refresh() {
+        for (AWSCredentialsProvider provider : credentialsProviders) {
+            provider.refresh();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSEnhancedCognitoIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSEnhancedCognitoIdentityProvider.java
new file mode 100644
index 0000000000..3e06536462
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSEnhancedCognitoIdentityProvider.java
@@ -0,0 +1,81 @@
+/**
+ * Copyright 2011-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentity;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+
+/**
+ * An extension of the AbstractCognitoProvider that is used to communicate with
+ * Cognito when using the enhanced authentication flow. All other functionality
+ * is the same as that of AbstractCognitoIdentityProvider.
+ */
+public final class AWSEnhancedCognitoIdentityProvider extends AWSAbstractCognitoIdentityProvider {
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     */
+    public AWSEnhancedCognitoIdentityProvider(String accountId, String identityPoolId) {
+        this(accountId, identityPoolId, new ClientConfiguration());
+    }
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param clientConfiguration the configuration to apply to service clients
+     *            created
+     */
+    public AWSEnhancedCognitoIdentityProvider(String accountId, String identityPoolId,
+            ClientConfiguration clientConfiguration) {
+        this(accountId, identityPoolId, new AmazonCognitoIdentityClient
+                (new AnonymousAWSCredentials(), clientConfiguration));
+    }
+
+    /**
+     * An extension of the AbstractCognitoProvider that is used to communicate
+     * with Cognito.
+     *
+     * @param accountId the account id of the developer
+     * @param identityPoolId the identity pool id of the app/user in question
+     * @param cibClient the cib client which will be used to contact the cib
+     *            back end
+     */
+    public AWSEnhancedCognitoIdentityProvider(String accountId, String identityPoolId,
+            AmazonCognitoIdentity cibClient) {
+        super(accountId, identityPoolId, cibClient);
+    }
+
+    @Override
+    public String getProviderName() {
+        return "Cognito";
+    }
+
+    @Override
+    public String refresh() {
+        getIdentityId();
+        // This flow doesn't request a token
+        return null;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSIdentityProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSIdentityProvider.java
new file mode 100644
index 0000000000..2025bf380c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSIdentityProvider.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * A container of data pertinent to a single provider, and will handle most of
+ * the interactions with said provider and the client. Note, this will only
+ * implement token and identityId interactions. It should not be used for
+ * implementing a custom IdentityProvider. Instead, extend
+ * AbstractCognitoIdentityProvider.
+ */
+public interface AWSIdentityProvider {
+
+    /**
+     * Get the token from the relevant provider
+     *
+     * @return the token which was retrieved from the provider
+     */
+    public String getToken();
+
+    /**
+     * To be used to call the provider back end to get a token and identityId.
+     * Once that has returned, a call to the superclass' update(String, Token)
+     * method should be called
+     *
+     * @return token returns the token that was updated in the refresh
+     */
+    public String refresh();
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSRefreshableSessionCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSRefreshableSessionCredentials.java
new file mode 100644
index 0000000000..c11315de91
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSRefreshableSessionCredentials.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Session credentials that can be refreshed upon request.
+ */
+public interface AWSRefreshableSessionCredentials extends AWSSessionCredentials {
+
+    /**
+     * Forces a refresh of these session credentials.
+     */
+    public void refreshCredentials();
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSSessionCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSSessionCredentials.java
new file mode 100644
index 0000000000..be327a478f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AWSSessionCredentials.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2011-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * AWS session credentials object.
+ */
+public interface AWSSessionCredentials extends AWSCredentials {
+
+    /**
+     * @return the session token for this session.
+     */
+    public String getSessionToken();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AbstractAWSSigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AbstractAWSSigner.java
new file mode 100644
index 0000000000..85404d1304
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AbstractAWSSigner.java
@@ -0,0 +1,474 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.SDKGlobalConfiguration;
+import com.amazonaws.internal.SdkDigestInputStream;
+import com.amazonaws.util.Base64;
+import com.amazonaws.util.BinaryUtils;
+import com.amazonaws.util.HttpUtils;
+import com.amazonaws.util.StringInputStream;
+import com.amazonaws.util.StringUtils;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.net.URI;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * Abstract base class for AWS signing protocol implementations. Provides
+ * utilities commonly needed by signing protocols such as computing
+ * canonicalized host names, query string parameters, etc.
+ * <p>
+ * Not intended to be sub-classed by developers.
+ */
+public abstract class AbstractAWSSigner implements Signer {
+
+    /** Empty sha256 hex. */
+    public static final String EMPTY_STRING_SHA256_HEX;
+    private static final ThreadLocal<MessageDigest> SHA256_MESSAGE_DIGEST;
+    private static final int DEFAULT_BUFFER_SIZE = 1024;
+    private static final int BUFFER_SIZE_MULTIPLIER = 5;
+    private static final int TIME_MILLISEC = 1000;
+
+    static {
+        SHA256_MESSAGE_DIGEST = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("SHA-256");
+                } catch (final NoSuchAlgorithmException e) {
+                    throw new AmazonClientException(
+                            "Unable to get SHA256 Function"
+                                    + e.getMessage(),
+                            e);
+                }
+            }
+        };
+        EMPTY_STRING_SHA256_HEX = BinaryUtils.toHex(doHash(""));
+    }
+
+    /**
+     * Computes an RFC 2104-compliant HMAC signature and returns the result as a
+     * Base64 encoded string.
+     */
+    protected String signAndBase64Encode(String data, String key,
+            SigningAlgorithm algorithm) {
+        return signAndBase64Encode(data.getBytes(UTF8),
+                key, algorithm);
+    }
+
+    /**
+     * Computes an RFC 2104-compliant HMAC signature for an array of bytes and
+     * returns the result as a Base64 encoded string.
+     */
+    protected String signAndBase64Encode(byte[] data, String key, SigningAlgorithm algorithm) {
+        try {
+            final byte[] signature = sign(data, key.getBytes(UTF8), algorithm);
+            return Base64.encodeAsString(signature);
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to calculate a request signature: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Signs using the given signing algorithm.
+     * @param stringData the data.
+     * @param key the key in bytes.
+     * @param algorithm the signing algorithm.
+     * @return signed result in bytes.
+     */
+    public byte[] sign(String stringData, byte[] key, SigningAlgorithm algorithm) {
+        try {
+            final byte[] data = stringData.getBytes(UTF8);
+            return sign(data, key, algorithm);
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to calculate a request signature: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    protected byte[] sign(byte[] data, byte[] key, SigningAlgorithm algorithm) {
+        try {
+            final Mac mac = Mac.getInstance(algorithm.toString());
+            mac.init(new SecretKeySpec(key, algorithm.toString()));
+            return mac.doFinal(data);
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to calculate a request signature: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Hashes the string contents (assumed to be UTF-8) using the SHA-256
+     * algorithm.
+     *
+     * @param text The string to hash.
+     * @return The hashed bytes from the specified string.
+     */
+    public byte[] hash(String text) {
+        return AbstractAWSSigner.doHash(text);
+    }
+
+    private static byte[] doHash(String text) {
+        try {
+            final MessageDigest md = getMessageDigestInstance();
+            md.update(text.getBytes(UTF8));
+            return md.digest();
+        } catch (final Exception e) {
+            throw new AmazonClientException(
+                    "Unable to compute hash while signing request: "
+                            + e.getMessage(),
+                    e);
+        }
+    }
+
+    @SuppressWarnings("checkstyle:emptystatement")
+    protected byte[] hash(InputStream input) {
+        try {
+            final MessageDigest md = getMessageDigestInstance();
+            @SuppressWarnings("resource")
+            final DigestInputStream digestInputStream = new SdkDigestInputStream(input, md);
+            final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
+            while (digestInputStream.read(buffer) > -1) {
+                ;
+            }
+            return digestInputStream.getMessageDigest().digest();
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to compute hash while signing request: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Hashes the binary data using the SHA-256 algorithm.
+     *
+     * @param data The binary data to hash.
+     * @return The hashed bytes from the specified data.
+     * @throws AmazonClientException If the hash cannot be computed.
+     */
+    public byte[] hash(byte[] data) {
+        try {
+            final MessageDigest md = MessageDigest.getInstance("SHA-256");
+            md.update(data);
+            return md.digest();
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to compute hash while signing request: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Examines the specified query string parameters and returns a
+     * canonicalized form.
+     * <p>
+     * The canonicalized query string is formed by first sorting all the query
+     * string parameters, then URI encoding both the key and value and then
+     * joining them, in order, separating key value pairs with an '&'.
+     *
+     * @param parameters The query string parameters to be canonicalized.
+     * @return A canonicalized form for the specified query string parameters.
+     */
+    protected String getCanonicalizedQueryString(Map<String, String> parameters) {
+
+        final SortedMap<String, String> sorted = new TreeMap<String, String>();
+
+        Iterator<Map.Entry<String, String>> pairs = parameters.entrySet().iterator();
+        while (pairs.hasNext()) {
+            final Map.Entry<String, String> pair = pairs.next();
+            final String key = pair.getKey();
+            final String value = pair.getValue();
+            sorted.put(HttpUtils.urlEncode(key, false), HttpUtils.urlEncode(value, false));
+        }
+
+        final StringBuilder builder = new StringBuilder();
+        pairs = sorted.entrySet().iterator();
+        while (pairs.hasNext()) {
+            final Map.Entry<String, String> pair = pairs.next();
+            builder.append(pair.getKey());
+            builder.append("=");
+            builder.append(pair.getValue());
+            if (pairs.hasNext()) {
+                builder.append("&");
+            }
+        }
+
+        return builder.toString();
+    }
+
+    protected String getCanonicalizedQueryString(Request<?> request) {
+        /*
+         * If we're using POST and we don't have any request payload content,
+         * then any request query parameters will be sent as the payload, and
+         * not in the actual query string.
+         */
+        if (HttpUtils.usePayloadForQueryParameters(request)) {
+            return "";
+        } else {
+            return this.getCanonicalizedQueryString(request.getParameters());
+        }
+    }
+
+    /**
+     * Returns the request's payload as binary data.
+     *
+     * @param request The request
+     * @return The data from the request's payload, as binary data.
+     */
+    protected byte[] getBinaryRequestPayload(Request<?> request) {
+        if (HttpUtils.usePayloadForQueryParameters(request)) {
+            final String encodedParameters = HttpUtils.encodeParameters(request);
+            if (encodedParameters == null) {
+                return new byte[0];
+            }
+
+            return encodedParameters.getBytes(UTF8);
+        }
+
+        return getBinaryRequestPayloadWithoutQueryParams(request);
+    }
+
+    /**
+     * Returns the request's payload as a String.
+     *
+     * @param request The request
+     * @return The data from the request's payload, as a string.
+     */
+    protected String getRequestPayload(Request<?> request) {
+        return newString(getBinaryRequestPayload(request));
+    }
+
+    /**
+     * Returns the request's payload contents as a String, without processing
+     * any query string params (i.e. no form encoding for query params).
+     *
+     * @param request The request
+     * @return the request's payload contents as a String, not including any
+     *         form encoding of query string params.
+     */
+    protected String getRequestPayloadWithoutQueryParams(Request<?> request) {
+        return newString(getBinaryRequestPayloadWithoutQueryParams(request));
+    }
+
+    /**
+     * Returns the request's payload contents as binary data, without processing
+     * any query string params (i.e. no form encoding for query params).
+     *
+     * @param request The request
+     * @return The request's payload contents as binary data, not including any
+     *         form encoding of query string params.
+     */
+    protected byte[] getBinaryRequestPayloadWithoutQueryParams(Request<?> request) {
+        final InputStream content = getBinaryRequestPayloadStreamWithoutQueryParams(request);
+
+        try {
+            content.mark(-1);
+            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+            final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE * BUFFER_SIZE_MULTIPLIER];
+            while (true) {
+                final int bytesRead = content.read(buffer);
+                if (bytesRead == -1) {
+                    break;
+                }
+
+                byteArrayOutputStream.write(buffer, 0, bytesRead);
+            }
+
+            byteArrayOutputStream.close();
+            content.reset();
+
+            return byteArrayOutputStream.toByteArray();
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to read request payload to sign request: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    protected InputStream getBinaryRequestPayloadStream(Request<?> request) {
+        if (HttpUtils.usePayloadForQueryParameters(request)) {
+            final String encodedParameters = HttpUtils.encodeParameters(request);
+            if (encodedParameters == null) {
+                return new ByteArrayInputStream(new byte[0]);
+            }
+
+            return new ByteArrayInputStream(
+                    encodedParameters.getBytes(UTF8));
+        }
+
+        return getBinaryRequestPayloadStreamWithoutQueryParams(request);
+    }
+
+    protected InputStream getBinaryRequestPayloadStreamWithoutQueryParams(Request<?> request) {
+        try {
+            final InputStream content = request.getContent();
+            if (content == null) {
+                return new ByteArrayInputStream(new byte[0]);
+            }
+
+            if (content instanceof StringInputStream) {
+                return content;
+            }
+
+            if (!content.markSupported()) {
+                throw new AmazonClientException("Unable to read request payload to sign request.");
+            }
+
+            return request.getContent();
+        } catch (final Exception e) {
+            throw new AmazonClientException("Unable to read request payload to sign request: "
+                    + e.getMessage(), e);
+        }
+    }
+
+    protected String getCanonicalizedResourcePath(String resourcePath) {
+        return getCanonicalizedResourcePath(resourcePath, true);
+    }
+
+    protected String getCanonicalizedResourcePath(String resourcePath, boolean urlEncode) {
+        if (resourcePath == null || resourcePath.length() == 0) {
+            return "/";
+        } else {
+            final String value = urlEncode ? HttpUtils.urlEncode(resourcePath, true) : resourcePath;
+            if (value.startsWith("/")) {
+                return value;
+            } else {
+                return "/".concat(value);
+            }
+        }
+    }
+
+    protected String getCanonicalizedEndpoint(URI endpoint) {
+        String endpointForStringToSign = StringUtils.lowerCase(endpoint.getHost());
+        /*
+         * Apache HttpClient will omit the port in the Host header for default
+         * port values (i.e. 80 for HTTP and 443 for HTTPS) even if we
+         * explicitly specify it, so we need to be careful that we use the same
+         * value here when we calculate the string to sign and in the Host
+         * header we send in the HTTP request.
+         */
+        if (HttpUtils.isUsingNonDefaultPort(endpoint)) {
+            endpointForStringToSign += ":" + endpoint.getPort();
+        }
+
+        return endpointForStringToSign;
+    }
+
+    /**
+     * Loads the individual access key ID and secret key from the specified
+     * credentials, ensuring that access to the credentials is synchronized on
+     * the credentials object itself, and trimming any extra whitespace from the
+     * credentials.
+     * <p>
+     * Returns either a {@link BasicSessionCredentials} or a
+     * {@link BasicAWSCredentials} object, depending on the input type.
+     *
+     * @param credentials
+     * @return A new credentials object with the sanitized credentials.
+     */
+    protected AWSCredentials sanitizeCredentials(AWSCredentials credentials) {
+        String accessKeyId = null;
+        String secretKey = null;
+        String token = null;
+        synchronized (credentials) {
+            accessKeyId = credentials.getAWSAccessKeyId();
+            secretKey = credentials.getAWSSecretKey();
+            if (credentials instanceof AWSSessionCredentials) {
+                token = ((AWSSessionCredentials) credentials).getSessionToken();
+            }
+        }
+        if (secretKey != null) {
+            secretKey = secretKey.trim();
+        }
+        if (accessKeyId != null) {
+            accessKeyId = accessKeyId.trim();
+        }
+        if (token != null) {
+            token = token.trim();
+        }
+
+        if (credentials instanceof AWSSessionCredentials) {
+            return new BasicSessionCredentials(accessKeyId, secretKey, token);
+        }
+
+        return new BasicAWSCredentials(accessKeyId, secretKey);
+    }
+
+    /**
+     * Safely converts a UTF-8 encoded byte array into a String.
+     *
+     * @param bytes UTF-8 encoded binary character data.
+     * @return The converted String object.
+     */
+    protected String newString(byte[] bytes) {
+        return new String(bytes, UTF8);
+    }
+
+    protected Date getSignatureDate(int timeOffset) {
+        Date dateValue = new Date();
+        if (timeOffset != 0) {
+            long epochMillis = dateValue.getTime();
+            epochMillis -= timeOffset * TIME_MILLISEC;
+            dateValue = new Date(epochMillis);
+        }
+        return dateValue;
+    }
+
+    protected int getTimeOffset(Request<?> request) {
+        int timeOffset = request.getTimeOffset();
+        if (SDKGlobalConfiguration.getGlobalTimeOffset() != 0) {
+            // if global time offset is set then use that (For clock skew
+            // issues)
+            timeOffset = SDKGlobalConfiguration.getGlobalTimeOffset();
+        }
+        return timeOffset;
+    }
+
+    /**
+     * Adds session credentials to the request given.
+     *
+     * @param request The request to add session credentials information to
+     * @param credentials The session credentials to add to the request
+     */
+    protected abstract void addSessionCredentials(Request<?> request,
+            AWSSessionCredentials credentials);
+
+    /**
+     * Returns the re-usable thread local version of MessageDigest.
+     *
+     * @return
+     */
+    private static MessageDigest getMessageDigestInstance() {
+        final MessageDigest messageDigest = SHA256_MESSAGE_DIGEST.get();
+        messageDigest.reset();
+        return messageDigest;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AnonymousAWSCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AnonymousAWSCredentials.java
new file mode 100644
index 0000000000..98ffd22232
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/AnonymousAWSCredentials.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Basic implementation of the AWSCredentials interface that allows use of
+ * "anonymous" credentials. Using anonymous credentials will result in requests
+ * not being signed before sending to the service. Any service that does not
+ * accept unsigned requests will return a service exception in this case.
+ */
+public class AnonymousAWSCredentials implements AWSCredentials {
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSAccessKeyId()
+     */
+    @Override
+    public String getAWSAccessKeyId() {
+        return null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSSecretKey()
+     */
+    @Override
+    public String getAWSSecretKey() {
+        return null;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicAWSCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicAWSCredentials.java
new file mode 100644
index 0000000000..9887aae4df
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicAWSCredentials.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Basic implementation of the AWSCredentials interface that allows callers to
+ * pass in the AWS access key and secret access in the constructor.
+ */
+public class BasicAWSCredentials implements AWSCredentials {
+
+    private final String accessKey;
+    private final String secretKey;
+
+    /**
+     * Constructs a new BasicAWSCredentials object, with the specified AWS
+     * access key and AWS secret key.
+     *
+     * @param accessKey The AWS access key.
+     * @param secretKey The AWS secret access key.
+     */
+    public BasicAWSCredentials(String accessKey, String secretKey) {
+        if (accessKey == null) {
+            throw new IllegalArgumentException("Access key cannot be null.");
+        }
+        if (secretKey == null) {
+            throw new IllegalArgumentException("Secret key cannot be null.");
+        }
+
+        this.accessKey = accessKey;
+        this.secretKey = secretKey;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSAccessKeyId()
+     */
+    @Override
+    public String getAWSAccessKeyId() {
+        return accessKey;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSSecretKey()
+     */
+    @Override
+    public String getAWSSecretKey() {
+        return secretKey;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicSessionCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicSessionCredentials.java
new file mode 100644
index 0000000000..c3bbf73f26
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/BasicSessionCredentials.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2011-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Simple session credentials with keys and session token.
+ */
+public class BasicSessionCredentials implements AWSSessionCredentials {
+
+    private final String awsAccessKey;
+    private final String awsSecretKey;
+    private final String sessionToken;
+
+    /**
+     * Constructor.
+     * @param awsAccessKey the AWS access key.
+     * @param awsSecretKey the AWS secret key.
+     * @param sessionToken the session token.
+     */
+    public BasicSessionCredentials(String awsAccessKey, String awsSecretKey, String sessionToken) {
+        this.awsAccessKey = awsAccessKey;
+        this.awsSecretKey = awsSecretKey;
+        this.sessionToken = sessionToken;
+    }
+
+    @Override
+    public String getAWSAccessKeyId() {
+        return awsAccessKey;
+    }
+
+    @Override
+    public String getAWSSecretKey() {
+        return awsSecretKey;
+    }
+
+    @Override
+    public String getSessionToken() {
+        return sessionToken;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ClasspathPropertiesFileCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ClasspathPropertiesFileCredentialsProvider.java
new file mode 100644
index 0000000000..8b7242ef28
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ClasspathPropertiesFileCredentialsProvider.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonClientException;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * {@link AWSCredentialsProvider} implementation that loads AWS security
+ * credentials from a properties file on the classpath. The default constructor
+ * creates a credentials provider that loads the credentials from a file named
+ * <code>AwsCredentials.properties</code> on the classpath, but which file to
+ * use from the classpath can also be controled through the one-argument
+ * constructor.
+ * <p>
+ * The AWS access key ID is expected to be in the <code>accessKey</code>
+ * property and the AWS secret key is expected to be in the
+ * <code>secretKey</code> property.
+ *
+ * @deprecated This is unsafe in mobile applications and should not be used. Use
+ *             temporary credentials provided by services such as Cognito
+ *             Identity
+ *             (http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide
+ *             /cognito-auth.html)
+ */
+@Deprecated
+public class ClasspathPropertiesFileCredentialsProvider implements AWSCredentialsProvider {
+
+    /** The name of the properties file to check for credentials */
+    private static String defaultPropertiesFile = "AwsCredentials.properties";
+
+    private final String credentialsFilePath;
+
+    /**
+     * Creates a new ClasspathPropertiesFileCredentialsProvider that will
+     * attempt to load the <code>AwsCredentials.properties</code> file from the
+     * classpath to read AWS security credentials.
+     */
+    public ClasspathPropertiesFileCredentialsProvider() {
+        this(defaultPropertiesFile);
+    }
+
+    /**
+     * Creates a new ClasspathPropertiesFileCredentialsProvider that will
+     * attempt to load a custom file from the classpath to read AWS security
+     * credentials.
+     *
+     * @param credentialsFilePath The custom classpath resource path to a
+     *            properties file from which the AWS security credentials should
+     *            be loaded. For example,
+     *            <ul>
+     *            <li>com/mycompany/credentials.properties</li>
+     *            <li>beta-credentials.properties</li>
+     *            <li>AwsCredentials.properties</li>
+     *            </ul>
+     */
+    public ClasspathPropertiesFileCredentialsProvider(String credentialsFilePath) {
+        if (credentialsFilePath == null)
+            throw new IllegalArgumentException("Credentials file path cannot be null");
+
+        // Make sure the path is absolute
+        if (!credentialsFilePath.startsWith("/")) {
+            this.credentialsFilePath = "/" + credentialsFilePath;
+        } else {
+            this.credentialsFilePath = credentialsFilePath;
+        }
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        InputStream inputStream = getClass().getResourceAsStream(credentialsFilePath);
+        if (inputStream == null) {
+            throw new AmazonClientException("Unable to load AWS credentials from the "
+                    + credentialsFilePath + " file on the classpath");
+        }
+
+        try {
+            return new PropertiesCredentials(inputStream);
+        } catch (IOException e) {
+            throw new AmazonClientException("Unable to load AWS credentials from the "
+                    + credentialsFilePath + " file on the classpath", e);
+        }
+    }
+
+    @Override
+    public void refresh() {
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + "(" + credentialsFilePath + ")";
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java
new file mode 100644
index 0000000000..148d15b7ae
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java
@@ -0,0 +1,666 @@
+/**
+ * Copyright 2011-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.util.Log;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.mobile.config.AWSConfiguration;
+import com.amazonaws.regions.Regions;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+import com.amazonaws.services.cognitoidentity.model.NotAuthorizedException;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.util.VersionInfoUtils;
+
+import java.util.Date;
+import java.util.Map;
+
+/**
+ * This credentials provider is intended for Android applications. It offers the
+ * ability to persist the Cognito identity id in {@link android.content.SharedPreferences}.
+ * Furthermore, it caches session credentials so as to reduce the number of
+ * network requests. This is the provider to use with a custom identity
+ * provider, which should be an extension of AWSAbstractCognitoIdentityProvider.
+ * This will consume an identity provider, as well. If one is passed in to a
+ * constructor, then that one is the one that is consumed, but if not/a
+ * constructor that doesn't take an identity provider is used, then the Cognito
+ * identity provider is used by default.
+ * <p>
+ * Note: if you haven't yet associated your IAM roles with your identity pool,
+ * please do so via the Cognito console before using this constructor. You will
+ * get an InvalidIdentityPoolConfigurationException if you use it and have not.
+ * </p>
+ *
+ * <pre>
+ * // initiate a credentials provider
+ * CognitoCachingCredentialsProvider provider = new CognitoCachingCredentialsProvider(
+ *         context,
+ *         &quot;identityPoolId&quot;,
+ *         Regions.US_EAST_1);
+ *
+ * // use the provider to instantiate an AWS client
+ * AmazonSNS snsClient = new AmazonSNSClient(provider);
+ *
+ * // If the user is authenticated through login with Amazon, you can set the map
+ * // of token to the provider
+ * Map&lt;String, String&gt; logins = new HashMap&lt;String, String&gt;();
+ * logins.put(""www.amazon.com", "login with Amazon token");
+ * provider.setLogins(logins);
+ *
+ * // Note: Please reuse the provider when possible.
+ *
+ * //The existing constructor will work without doing so, but will not use the enhanced flow:
+ * CognitoCachingCredentialsProvider provider = new CognitoCachingCredentialsProvider(
+ *         context,
+ *         &quot;awsAccountId&quot;,
+ *         &quot;identityPoolId&quot;,
+ *         &quot;unauthRoleArn&quot;,
+ *         &quot;authRoleArn&quot;,
+ *         Regions.US_EAST_1);
+ * </pre>
+ */
+public class CognitoCachingCredentialsProvider
+        extends CognitoCredentialsProvider {
+
+    private final String DEFAULT_SHAREDPREFERENCES_NAME = "com.amazonaws.android.auth";
+    private static final String USER_AGENT = CognitoCachingCredentialsProvider.class.getName()
+            + "/" + VersionInfoUtils.getVersion();
+    private final SharedPreferences prefs;
+    private String identityId;
+
+    private static final String ID_KEY = "identityId";
+    private static final String AK_KEY = "accessKey";
+    private static final String SK_KEY = "secretKey";
+    private static final String ST_KEY = "sessionToken";
+    private static final String EXP_KEY = "expirationDate";
+
+    volatile boolean needIdentityRefresh = false;
+
+    private static final String TAG = "CognitoCachingCredentialsProvider";
+
+    private final IdentityChangedListener listener = new IdentityChangedListener() {
+        @Override
+        public void identityChanged(String oldIdentityId, String newIdentityId) {
+            Log.d(TAG, "Identity id is changed");
+            saveIdentityId(newIdentityId);
+            clearCredentials();
+        }
+    };
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request, using
+     * the basic authentication flow, to the AWS Security Token Service (STS) to
+     * request short-lived session credentials, which will then be returned by
+     * this class's {@link #getCredentials()} method.
+     *
+     * @param context The Android context to be used for the caching
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cogntio identity pool to use
+     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authRoleArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCachingCredentialsProvider(Context context, String accountId,
+            String identityPoolId, String unauthRoleArn, String authRoleArn, Regions region) {
+        super(accountId, identityPoolId, unauthRoleArn, authRoleArn, region);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request, using
+     * the basic authentication flow, to the AWS Security Token Service (STS) to
+     * request short-lived session credentials, which will then be returned by
+     * this class's {@link #getCredentials()} method.
+     * <p>
+     * This version of the constructor allows you to specify a client
+     * configuration for the Amazon Cognito and STS clients.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authRoleArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param region The region to use when contacting Cognito Identity
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     */
+    public CognitoCachingCredentialsProvider(Context context, String accountId,
+            String identityPoolId, String unauthRoleArn, String authRoleArn, Regions region,
+            ClientConfiguration clientConfiguration) {
+        super(accountId, identityPoolId, unauthRoleArn, authRoleArn, region, clientConfiguration);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request to
+     * Cognito, using the enhanced flow, to get short lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     * <p>
+     * Note: if you haven't yet associated your IAM roles with your identity
+     * pool, please do so via the Cognito console before using this constructor.
+     * You will get an InvalidIdentityPoolConfigurationException if you use it
+     * and have not. The existing constructor (mirroring this one but with roles
+     * and an account id) will work without doing so, but will not use the
+     * enhanced flow.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCachingCredentialsProvider(Context context, String identityPoolId, Regions region) {
+        super(identityPoolId, region);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request to
+     * Cognito, using the enhanced flow, to get short lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     * <p>
+     * Note: if you haven't yet associated your IAM roles with your identity
+     * pool, please do so via the Cognito console before using this constructor.
+     * You will get an InvalidIdentityPoolConfigurationException if you use it
+     * and have not. The existing constructor (mirroring this one but with roles
+     * and an account id) will work without doing so, but will not use the
+     * enhanced flow.
+     * </p>
+     *
+     * Example json file:
+     * {
+     *     "CredentialsProvider": {
+     *         "CognitoIdentity": {
+     *             "Default": {
+     *                 "PoolId": "us-east-1:example-pool-id1234",
+     *                 "Region": "us-east-1"
+     *             }
+     *         }
+     *     }
+     * }
+     *
+     * @param context The Android context to be used for the caching
+     * @param awsConfiguration The configuration holding you identity pool id
+     *                         and the region to use when contacting
+     *                         Cognito Identity
+     */
+    public CognitoCachingCredentialsProvider(Context context, AWSConfiguration awsConfiguration) {
+        super(awsConfiguration);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request to
+     * Cognito, using the enhanced flow, to get short lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     * <p>
+     * This version of the constructor allows you to specify a client
+     * configuration for the Amazon Cognito client.
+     * </p>
+     * <p>
+     * Note: if you haven't yet associated your IAM roles with your identity
+     * pool, please do so via the Cognito console before using this constructor.
+     * You will get an InvalidIdentityPoolConfigurationException if you use it
+     * and have not. The existing constructor (mirroring this one but with roles
+     * and an account id) will work without doing so, but will not use the
+     * enhanced flow.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param region The region to use when contacting Cognito Identity
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     */
+    public CognitoCachingCredentialsProvider(Context context, String identityPoolId,
+            Regions region, ClientConfiguration clientConfiguration) {
+        super(identityPoolId, region, clientConfiguration);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * use the specified Amazon Cognito identity pool to make a request to the
+     * AWS Security Token Service (STS) to get short-lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     * <p>
+     * This version of the constructor allows you to specify the Amazon Cognito
+     * and STS client to use.
+     * </p>
+     * <p>
+     * Set the roles and stsClient to null to use the enhanced authentication
+     * flow, not contacting STS. Otherwise the basic flow will be used.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cogntio identity pool to use
+     * @param unauthArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param cibClient Preconfigured CognitoIdentity client to make requests
+     *            with
+     * @param stsClient Preconfigured STS client to make requests with
+     */
+    public CognitoCachingCredentialsProvider(Context context, String accountId,
+            String identityPoolId, String unauthArn, String authArn,
+            AmazonCognitoIdentityClient cibClient, AWSSecurityTokenService stsClient) {
+        super(accountId, identityPoolId, unauthArn, authArn, cibClient, stsClient);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * set up a link to the provider passed in using the basic authentication
+     * flow to get get short-lived credentials from STS, which can be retrieved
+     * from {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with STS
+     * @param unauthArn the unauthArn, for use with the STS call
+     * @param authArn the authArn, for use with the STS call
+     */
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
+            String unauthArn, String authArn) {
+        super(provider, unauthArn, authArn);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * set up a link to the provider passed in to use the basic authentication
+     * flow to get short-lived credentials from STS, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class, and the STS client to use.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with STS
+     * @param unauthArn the unauthArn, for use with the STS call
+     * @param authArn the authArn, for use with the STS call
+     * @param stsClient the sts endpoint to get session credentials from
+     */
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
+            String unauthArn, String authArn, AWSSecurityTokenService stsClient) {
+        super(provider, unauthArn, authArn, stsClient);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * set up a link to the provider passed in using the enhanced authentication
+     * flow to get short-lived credentials from Amazon Cognito, which can be
+     * retrieved from {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class.
+     * </p>
+     * <p>
+     * Note: if you haven't yet associated your IAM roles with your identity
+     * pool, please do so via the Cognito console before using this constructor.
+     * You will get an InvalidIdentityPoolConfigurationException if you use it
+     * and have not. The existing constructor (mirroring this one but with
+     * roles) will work without doing so, but will not use the enhanced flow.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with Amazon
+     *            Cognito
+     * @param region The region to use when contacting Cognito
+     */
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
+            Regions region) {
+        super(provider, region);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    /**
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
+     * set up a link to the provider passed in using the enhanced authentication
+     * flow to get short-lived credentials from Amazon Cognito, which can be
+     * retrieved from {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class and the configuration for the Amazon Cognito client.
+     * </p>
+     * <p>
+     * Note: if you haven't yet associated your IAM roles with your identity
+     * pool, please do so via the Cognito console before using this constructor.
+     * You will get an InvalidIdentityPoolConfigurationException if you use it
+     * and have not. The existing constructor (mirroring this one but with
+     * roles) will work without doing so, but will not use the enhanced flow.
+     * </p>
+     *
+     * @param context The Android context to be used for the caching
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with Amazon
+     *            Cognito
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
+            Regions region, ClientConfiguration clientConfiguration) {
+        super(provider, region, clientConfiguration);
+        if (context == null) {
+            throw new IllegalArgumentException("context can't be null");
+        }
+        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
+                Context.MODE_PRIVATE);
+        initialize();
+    }
+
+    private void initialize() {
+        checkUpgrade();
+        this.identityId = getCachedIdentityId();
+        loadCachedCredentials();
+        registerIdentityChangedListener(listener);
+    }
+
+    /**
+     * Gets the Cognito identity id of the user. The first time when this method
+     * is called, a network request will be made to retrieve a new identity id.
+     * After that it's saved in {@link android.content.SharedPreferences}. Please don't call it
+     * in the main thread.
+     *
+     * @return identity id of the user
+     */
+    @Override
+    public String getIdentityId() {
+        // If a login has been added, this condition is met
+        // and refresh is called to update the id
+        if (needIdentityRefresh) {
+            needIdentityRefresh = false;
+            refresh();
+            identityId = super.getIdentityId();
+            saveIdentityId(identityId);
+        }
+
+        // try to get the ID from SharedPreferences
+        this.identityId = getCachedIdentityId();
+        if (this.identityId == null) {
+            identityId = super.getIdentityId();
+            saveIdentityId(identityId);
+        }
+        return identityId;
+    }
+
+    @Override
+    public AWSSessionCredentials getCredentials() {
+    	credentialsLock.writeLock().lock();
+        try {
+        	// return only if the credentials are valid
+        	if (sessionCredentials == null) {
+        		loadCachedCredentials();
+        	}
+
+        	if ((sessionCredentialsExpiration != null) && !needsNewSession()) {
+        		return sessionCredentials;
+        	}
+        	// super will validate loaded credentials
+        	// and fetch if necessary
+        	super.getCredentials();
+
+        	// null check before saving credentials
+        	if (sessionCredentialsExpiration != null) {
+        		saveCredentials(sessionCredentials, 
+        				sessionCredentialsExpiration.getTime());
+        	}
+        	return sessionCredentials;
+        } catch (NotAuthorizedException e) {
+            Log.e(TAG, "Failure to get credentials", e);
+            if (getLogins() != null) {
+                // If the fetch failed then the credentials don't
+                // match the current id, so clear them
+                super.setIdentityId(null);
+                super.getCredentials();
+                return sessionCredentials;
+            }
+            else {
+                throw e;
+            }
+        } finally {
+        	credentialsLock.writeLock().unlock();
+        }
+    }
+    
+    @Override
+    public void refresh() {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		super.refresh();
+
+    		// null check before saving credentials
+    		if (sessionCredentialsExpiration != null) {
+    			saveCredentials(sessionCredentials,
+    					sessionCredentialsExpiration.getTime());
+    		}
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    @Override
+    public void setLogins(Map<String, String> logins) {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		super.setLogins(logins);
+    		// A new login has been added, so an identity refresh is necessary
+    		needIdentityRefresh = true;
+    		// clear cached credentials
+    		clearCredentials();
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.CognitoCredentialsProvider#clear() Clears the AWS
+     * credentials and the identity id.
+     */
+    @Override
+    public void clear() {
+        super.clear();
+
+        // clear cached identity id and credentials
+        prefs.edit().clear().apply();
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.CognitoCredentialsProvider#clearCredentials()
+     * Clears the AWS credentials
+     */
+    @Override
+    public void clearCredentials() {
+    	credentialsLock.writeLock().lock();
+    	try {
+	        super.clearCredentials();
+	        Log.d(TAG, "Clearing credentials from SharedPreferences");
+	        prefs.edit()
+	                .remove(namespace(AK_KEY))
+	                .remove(namespace(SK_KEY))
+	                .remove(namespace(ST_KEY))
+	                .remove(namespace(EXP_KEY))
+	                .apply();
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /**
+     * Gets the cached identity id without making a network request.
+     *
+     * @return cached identity id, null if it doesn't exist
+     */
+    public String getCachedIdentityId() {
+        String cachedIdentityId = prefs.getString(namespace(ID_KEY), null);
+        if (cachedIdentityId != null && identityId == null) {
+            super.setIdentityId(cachedIdentityId);
+        }
+        return cachedIdentityId;
+    }
+
+    /**
+     * Load the credentials from prefs
+     */
+    void loadCachedCredentials() {
+        Log.d(TAG, "Loading credentials from SharedPreferences");
+        sessionCredentialsExpiration = new Date(prefs.getLong(namespace(EXP_KEY), 0));
+        // make sure we have valid data in prefs
+        boolean hasAK = prefs.contains(namespace(AK_KEY));
+        boolean hasSK = prefs.contains(namespace(SK_KEY));
+        boolean hasST = prefs.contains(namespace(ST_KEY));
+        if (!hasAK || !hasSK || !hasST) {
+            Log.d(TAG, "No valid credentials found in SharedPreferences");
+            sessionCredentialsExpiration = null;
+            return;
+        }
+        String AK = prefs.getString(namespace(AK_KEY), null);
+        String SK = prefs.getString(namespace(SK_KEY), null);
+        String ST = prefs.getString(namespace(ST_KEY), null);
+
+        sessionCredentials = new BasicSessionCredentials(AK, SK, ST);
+    }
+
+    /**
+     * Save the credentials to {@link android.content.SharedPreferences}.
+     */
+    private void saveCredentials(AWSSessionCredentials sessionCredentials,
+            long time) {
+        Log.d(TAG, "Saving credentials to SharedPreferences");
+        if (sessionCredentials != null) {
+            prefs.edit()
+                    .putString(namespace(AK_KEY), sessionCredentials.getAWSAccessKeyId())
+                    .putString(namespace(SK_KEY), sessionCredentials.getAWSSecretKey())
+                    .putString(namespace(ST_KEY), sessionCredentials.getSessionToken())
+                    .putLong(namespace(EXP_KEY), time)
+                    .apply();
+        }
+    }
+
+    /**
+     * clear cached identity id and credentials Save the Amazon Cognito Identity
+     * Id to {@link android.content.SharedPreferences}.
+     */
+    private void saveIdentityId(String identityId) {
+        Log.d(TAG, "Saving identity id to SharedPreferences");
+        this.identityId = identityId;
+
+        prefs.edit()
+                .putString(namespace(ID_KEY), identityId)
+                .apply();
+    }
+
+    @Override
+    protected String getUserAgent() {
+        return USER_AGENT;
+    }
+
+    // To support multiple identity pools in the same app, namespacing the keys
+    // in shared preferences is required. However, in order to keep previously
+    // saved identity id, unauthenticated id in particular, a check of the id
+    // under the old key is performed. If there is one, save it under the new
+    // namespace.
+    private void checkUpgrade() {
+        // check identity id without namespace
+        if (prefs.contains(ID_KEY)) {
+            Log.i(TAG,
+                    "Identity id without namespace is detected. It will be saved under new namespace.");
+            // save identity id
+            String identityId = prefs.getString(ID_KEY, null);
+            prefs.edit().clear() // clear old data
+                    .putString(namespace(ID_KEY), identityId)
+                    .apply();
+        }
+    }
+
+    // prefix the key with identity pool id
+    private String namespace(String key) {
+        return getIdentityPoolId() + "." + key;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCredentialsProvider.java
new file mode 100644
index 0000000000..4be75d75e3
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/CognitoCredentialsProvider.java
@@ -0,0 +1,863 @@
+/**
+ * Copyright 2011-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.SDKGlobalConfiguration;
+import com.amazonaws.mobile.config.AWSConfiguration;
+import com.amazonaws.regions.Region;
+import com.amazonaws.regions.Regions;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentity;
+import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
+import com.amazonaws.services.cognitoidentity.model.GetCredentialsForIdentityRequest;
+import com.amazonaws.services.cognitoidentity.model.GetCredentialsForIdentityResult;
+import com.amazonaws.services.cognitoidentity.model.ResourceNotFoundException;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
+import com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest;
+import com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityResult;
+import com.amazonaws.services.securitytoken.model.Credentials;
+
+import org.json.JSONObject;
+
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * AWSCredentialsProvider implementation that uses the Amazon Cognito Identity
+ * service and AWS Security Token Service to create temporary, short-lived
+ * sessions to use for authentication
+ */
+public class CognitoCredentialsProvider implements AWSCredentialsProvider {
+
+    /** Used in the enhanced get credentials flow */
+    private AmazonCognitoIdentity cib;
+
+    /** Handle the identity-specific interactions */
+    private final AWSCognitoIdentityProvider identityProvider;
+
+    /** Default duration for started sessions */
+    public static final int DEFAULT_DURATION_SECONDS = 3600;
+
+    /** Default threshold for refreshing session credentials */
+    public static final int DEFAULT_THRESHOLD_SECONDS = 500;
+
+    /** The current session credentials */
+    protected AWSSessionCredentials sessionCredentials;
+
+    /** The expiration time for the current session credentials */
+    protected Date sessionCredentialsExpiration;
+
+    /** The current Token */
+    protected String token;
+
+    /**
+     * The client for starting STS sessions, used in the basic (non-enhanced
+     * flow)
+     */
+    protected AWSSecurityTokenService securityTokenService;
+
+    protected int sessionDuration;
+    protected int refreshThreshold;
+    protected String unauthRoleArn;
+    protected String authRoleArn;
+    protected String customRoleArn;
+
+    protected boolean useEnhancedFlow;
+    
+    protected ReentrantReadWriteLock credentialsLock;
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request, using the basic
+     * authentication flow, to the AWS Security Token Service (STS) to request
+     * short-lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     *
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cogntio identity pool to use
+     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authRoleArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCredentialsProvider(String accountId, String identityPoolId,
+            String unauthRoleArn, String authRoleArn, Regions region) {
+        this(accountId, identityPoolId, unauthRoleArn, authRoleArn, region,
+                new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request, using the basic
+     * authentication flow, to the AWS Security Token Service (STS) to request
+     * short-lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     * <p>
+     * This version of the constructor allows you to specify a client
+     * configuration for the Amazon Cognito and STS clients.
+     * </p>
+     *
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authRoleArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param region The region to use when contacting Cognito Identity
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     */
+    public CognitoCredentialsProvider(String accountId, String identityPoolId,
+            String unauthRoleArn, String authRoleArn, Regions region,
+            ClientConfiguration clientConfiguration) {
+        this(accountId, identityPoolId, unauthRoleArn, authRoleArn, 
+                new AmazonCognitoIdentityClient(new AnonymousAWSCredentials(), clientConfiguration),
+                (unauthRoleArn == null && authRoleArn == null) ? 
+                        null : new AWSSecurityTokenServiceClient(new AnonymousAWSCredentials(), clientConfiguration));
+        this.cib.setRegion(Region.getRegion(region));
+    }
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request to Cognito,
+     * using the enhanced flow, to get short lived session credentials, which
+     * will then be returned by this class's {@link #getCredentials()} method.
+     * 
+     * Example json file:
+     * {
+     *     "CredentialsProvider": {
+     *         "CognitoIdentity": {
+     *             "Default": {
+     *                 "PoolId": "us-east-1:example-pool-id1234",
+     *                 "Region": "us-east-1"
+     *             }
+     *         }
+     *     }
+     * }
+     *
+     * @param awsConfiguration The configuration holding you identity pool id
+     *                         and the region to use when contacting
+     *                         Cognito Identity
+     */
+    public CognitoCredentialsProvider(AWSConfiguration awsConfiguration) {
+        this(null, getIdentityPoolId(awsConfiguration), null, null, getRegions(awsConfiguration), getClientConfiguration(awsConfiguration));
+    }
+
+    private static String getIdentityPoolId(AWSConfiguration awsConfiguration) {
+        try {
+            final JSONObject ccpConfig = awsConfiguration.optJsonObject("CredentialsProvider")
+                                                         .optJSONObject("CognitoIdentity")
+                                                         .getJSONObject(awsConfiguration.getConfiguration());
+            return ccpConfig.getString("PoolId");
+        } catch (Exception e) {
+            throw new IllegalArgumentException("Failed to read CognitoIdentity please check your setup or awsconfiguration.json file", e);
+        }
+    }
+
+    private static Regions getRegions(AWSConfiguration awsConfiguration) {
+        try {
+            final JSONObject ccpConfig = awsConfiguration.optJsonObject("CredentialsProvider")
+                                                         .optJSONObject("CognitoIdentity")
+                                                         .getJSONObject(awsConfiguration.getConfiguration());
+            return Regions.fromName(ccpConfig.getString("Region"));
+        } catch (Exception e) {
+            throw new IllegalArgumentException("Failed to read CognitoIdentity please check your setup or awsconfiguration.json file", e);
+        }
+    }
+
+    private static ClientConfiguration getClientConfiguration(AWSConfiguration awsConfiguration) {
+        final ClientConfiguration clientConfig = new ClientConfiguration();
+        clientConfig.setUserAgent(awsConfiguration.getUserAgent());
+        return clientConfig;
+    }
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request to Cognito,
+     * using the enhanced flow, to get short lived session credentials, which
+     * will then be returned by this class's {@link #getCredentials()} method.
+     *
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCredentialsProvider(String identityPoolId, Regions region) {
+        this(null, identityPoolId, null, null, region, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request to Cognito,
+     * using the enhanced flow, to get short lived session credentials, which
+     * will then be returned by this class's {@link #getCredentials()} method.
+     * <p>
+     * This version of the constructor allows you to specify a client
+     * configuration for the Amazon Cognito client.
+     * </p>
+     *
+     * @param identityPoolId The Amazon Cognito identity pool to use
+     * @param region The region to use when contacting Cognito Identity
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     */
+    public CognitoCredentialsProvider(String identityPoolId, Regions region,
+            ClientConfiguration clientConfiguration) {
+        this(null, identityPoolId, null, null, region, clientConfiguration);
+    }
+
+    /**
+     * Constructs a new {@link CognitoCredentialsProvider}, which will use the
+     * specified Amazon Cognito identity pool to make a request to the AWS
+     * Security Token Service (STS) to get short-lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     * <p>
+     * This version of the constructor allows you to specify the Amazon Cognito
+     * and STS client to use.
+     * </p>
+     * <p>
+     * Set the roles and stsClient to null to use the enhanced authentication
+     * flow, not contacting STS. Otherwise the basic flow will be used.
+     * </p>
+     *
+     * @param accountId The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId The Amazon Cogntio identity pool to use
+     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
+     *            unauthenticated
+     * @param authRoleArn The ARN of the IAM Role that will be assumed when
+     *            authenticated
+     * @param cibClient Preconfigured CognitoIdentity client to make requests
+     *            with
+     * @param stsClient Preconfigured STS client to make requests with
+     */
+    public CognitoCredentialsProvider(String accountId, String identityPoolId,
+            String unauthRoleArn, String authRoleArn, AmazonCognitoIdentityClient cibClient,
+            AWSSecurityTokenService stsClient) {
+
+        // No need to specify parameters for Region and ClientConfig because we
+        // don't create the clients
+        this.cib = cibClient;
+        this.securityTokenService = stsClient;
+
+        this.unauthRoleArn = unauthRoleArn;
+        this.authRoleArn = authRoleArn;
+        this.sessionDuration = DEFAULT_DURATION_SECONDS;
+        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;
+
+        this.useEnhancedFlow = (unauthRoleArn == null && authRoleArn == null);
+
+        if (this.useEnhancedFlow) {
+            this.identityProvider = new AWSEnhancedCognitoIdentityProvider(accountId,
+                    identityPoolId,
+                    cibClient);
+        } else {
+            this.identityProvider = new AWSBasicCognitoIdentityProvider(accountId, identityPoolId,
+                    cibClient);
+        }
+        this.credentialsLock = new ReentrantReadWriteLock(true);
+    }
+
+    /**
+     * Constructs a new CognitoCredentialsProvider, which will set up a link to
+     * the provider passed in using the basic authentication flow to get get
+     * short-lived credentials from STS, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class.
+     * </p>
+     *
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with STS
+     * @param unauthArn the unauthArn, for use with the STS call
+     * @param authArn the authArn, for use with the STS call
+     */
+    public CognitoCredentialsProvider(AWSCognitoIdentityProvider provider,
+            String unauthArn, String authArn) {
+        this(provider, unauthArn, authArn, new AWSSecurityTokenServiceClient(
+                new AnonymousAWSCredentials(), new ClientConfiguration()));
+    }
+
+    /**
+     * Constructs a new CognitoCredentialsProvider, which will set up a link to
+     * the provider passed in to use the basic authentication flow to get
+     * short-lived credentials from STS, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class, and the STS client to use.
+     * </p>
+     *
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with STS
+     * @param unauthArn the unauthArn, for use with the STS call
+     * @param authArn the authArn, for use with the STS call
+     * @param stsClient the sts endpoint to get session credentials from
+     */
+    public CognitoCredentialsProvider(AWSCognitoIdentityProvider provider,
+            String unauthArn, String authArn, AWSSecurityTokenService stsClient) {
+        this.identityProvider = provider;
+        this.unauthRoleArn = unauthArn;
+        this.authRoleArn = authArn;
+        this.securityTokenService = stsClient;
+        this.sessionDuration = DEFAULT_DURATION_SECONDS;
+        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;
+        this.useEnhancedFlow = false;
+        this.credentialsLock = new ReentrantReadWriteLock(true);
+    }
+
+    /**
+     * Constructs a new CognitoCredentialsProvider, which will set up a link to
+     * the provider passed in using the enhanced authentication flow to get
+     * short-lived credentials from Amazon Cognito, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class.
+     * </p>
+     *
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with Amazon
+     *            Cognito
+     * @param region The region to use when contacting Cognito
+     */
+    public CognitoCredentialsProvider(AWSCognitoIdentityProvider provider, Regions region) {
+        this(provider, region, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new CognitoCredentialsProvider, which will set up a link to
+     * the provider passed in using the enhanced authentication flow to get
+     * short-lived credentials from Amazon Cognito, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class and the configuration for the Amazon Cognito client.
+     * </p>
+     *
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with Amazon
+     *            Cognito
+     * @param clientConfiguration Configuration to apply to service clients
+     *            created
+     * @param region The region to use when contacting Cognito Identity
+     */
+    public CognitoCredentialsProvider(AWSCognitoIdentityProvider provider,
+            Regions region, ClientConfiguration clientConfiguration) {
+        this(provider, new AmazonCognitoIdentityClient(
+                new AnonymousAWSCredentials(), clientConfiguration));
+        this.cib.setRegion(Region.getRegion(region));
+    }
+    
+    /**
+     * Constructs a new CognitoCredentialsProvider, which will set up a link to
+     * the provider passed in using the enhanced authentication flow to get
+     * short-lived credentials from Amazon Cognito, which can be retrieved from
+     * {@link #getCredentials()}
+     * <p>
+     * This version of the constructor allows you to specify your own Identity
+     * Provider class and the Amazon Cognito client.
+     * </p>
+     *
+     * @param provider a reference to the provider in question, including what's
+     *            needed to interact with it to later connect with Amazon
+     *            Cognito
+     * @param cibClient Preconfigured CognitoIdentity client to make requests
+     *            with
+     */
+    public CognitoCredentialsProvider(AWSCognitoIdentityProvider provider,
+            AmazonCognitoIdentityClient cibClient) {
+
+        this.cib = cibClient;
+        this.identityProvider = provider;
+        this.unauthRoleArn = null;
+        this.authRoleArn = null;
+        this.securityTokenService = null;
+        this.sessionDuration = DEFAULT_DURATION_SECONDS;
+        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;
+        this.useEnhancedFlow = true;
+        this.credentialsLock = new ReentrantReadWriteLock(true);
+    }
+
+    public String getIdentityId() {
+        return identityProvider.getIdentityId();
+    }
+
+    public String getToken() {
+        return identityProvider.getToken();
+    }
+
+    public AWSIdentityProvider getIdentityProvider() {
+        return identityProvider;
+    }
+
+    public void setSessionCredentialsExpiration(Date expiration) {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		sessionCredentialsExpiration = expiration;
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    public Date getSessionCredentitalsExpiration() {
+    	credentialsLock.readLock().lock();
+    	try {
+    		return sessionCredentialsExpiration;
+    	} finally {
+    		credentialsLock.readLock().unlock();
+    	}
+    }
+
+    public String getIdentityPoolId() {
+        return identityProvider.getIdentityPoolId();
+    }
+
+    /**
+     * If the current session has expired/credentials are invalid, a new session
+     * is started, establishing the credentials. In either case, those
+     * credentials are returned
+     */
+    @Override
+    public AWSSessionCredentials getCredentials() {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		if (needsNewSession()) {
+    			startSession();
+    		}
+    		return sessionCredentials;
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /**
+     * Set the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param sessionDuration The new duration for session credentials created
+     *            by this provider
+     */
+    public void setSessionDuration(int sessionDuration) {
+        this.sessionDuration = sessionDuration;
+    }
+
+    /**
+     * Set the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     * Returns reference to object so methods can be chained together.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param sessionDuration The new duration for session credentials created
+     *            by this provider
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public CognitoCredentialsProvider withSessionDuration(int sessionDuration) {
+        this.setSessionDuration(sessionDuration);
+        return this;
+    }
+
+    /**
+     * Get the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @return The duration for session credentials created by this provider
+     */
+    public int getSessionDuration() {
+        return this.sessionDuration;
+    }
+
+    /**
+     * Set the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param refreshThreshold The new refresh threshold for session credentials
+     *            created by this provider
+     */
+    public void setRefreshThreshold(int refreshThreshold) {
+        this.refreshThreshold = refreshThreshold;
+    }
+
+    /**
+     * Set the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS. Returns a reference to the object
+     * so methods can be chained.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param refreshThreshold The new refresh threshold for session credentials
+     *            created by this provider
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public CognitoCredentialsProvider withRefreshThreshold(int refreshThreshold) {
+        this.setRefreshThreshold(refreshThreshold);
+        return this;
+    }
+
+    /**
+     * Get the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @return The refresh threshold for session credentials created by this
+     *         provider
+     */
+    public int getRefreshThreshold() {
+        return this.refreshThreshold;
+    }
+
+    protected void setIdentityId(String identityId) {
+        identityProvider.identityChanged(identityId);
+    }
+
+    /**
+     * Set the logins map used to authenticated with Amazon Cognito. Note: You
+     * should manually call refresh on on the credentials provider after adding
+     * logins to the provider as your Identity Id may have changed.
+     *
+     * @param logins The new logins map (providerName, providerToken) to use to
+     *            communicate with Amazon Cognito
+     */
+    public void setLogins(Map<String, String> logins) {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		identityProvider.setLogins(logins);
+    		clearCredentials();
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+        
+    /**
+     * Get the custom role arn associated with the credentials provider.
+     * 
+     * @return Custom role arn.
+     */
+    public String getCustomRoleArn() {
+        return customRoleArn;
+    }
+
+    /**
+     * Set the custom role arn that will be used to get credentials with Amazon
+     * Cognito. This parameter needs to be set when idp provides roles in the
+     * token (eg: SAML Assertion) and there are multiple roles. Roles set by the
+     * method will be assumed when it matches with the roles received in the
+     * token from IdP.
+     * 
+     * @param customRoleArn The role arn to be used to get the credentials.
+     */
+    public void setCustomRoleArn(String customRoleArn) {
+        this.customRoleArn = customRoleArn;
+    }
+
+	/**
+     * Set the logins map used to authenticated with Amazon Cognito. Returns a
+     * reference to the object so methods can be chained. Note: You should
+     * manually call refresh on on the credentials provider after adding logins
+     * to the provider as your Identity Id may have changed.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param logins The new logins map (providerName, providerToken) to use to
+     *            communicate with Amazon Cognito
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AWSCredentialsProvider withLogins(Map<String, String> logins) {
+        this.setLogins(logins);
+        return this;
+    }
+
+    /**
+     * Get the logins map used to authenticated with Amazon Cognito
+     *
+     * @return The logins map (providerName, providerToken) to use to
+     *         communicate with Amazon Cognito
+     */
+    public Map<String, String> getLogins() {
+        return identityProvider.getLogins();
+    }
+
+    @Override
+    public void refresh() {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		startSession();
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /**
+     * Clear all in-memory and saved state for the credentials provider. Will
+     * destroy any saved Amazon Cognito Identity Id and associated AWS
+     * credentials.
+     */
+    public void clear() {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		clearCredentials();
+    		setIdentityId(null);
+    		identityProvider.setLogins(new HashMap<String, String>());
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /**
+     * Clear credentials. This will destroy all the saved AWS credentials but
+     * not the identity Id.
+     */
+    public void clearCredentials() {
+    	credentialsLock.writeLock().lock();
+    	try {
+    		sessionCredentials = null;
+    		sessionCredentialsExpiration = null;
+    	} finally {
+    		credentialsLock.writeLock().unlock();
+    	}
+    }
+
+    /**
+     * Starts a new session by getting short lived session credentials.
+     */
+    protected void startSession() {
+
+        // make sure we have an identityId. In the case of cognito identity,
+        // the try catch will handle a deleted or corrupted id.
+        // Developer authenticated won't throw amazon exceptions,
+        // and for 2hop, it will be handled below, as the getId call
+        // won't fail since it is set.
+        try {
+            token = identityProvider.refresh();
+        } catch (ResourceNotFoundException rnfe) {
+            // If the identity id or identity pool is non-existant, this is
+            // thrown
+            token = retryRefresh();
+        } catch (AmazonServiceException ase) {
+            // If it's a corrupt id, then a validation exception is thrown
+            if (ase.getErrorCode().equals("ValidationException")) {
+                token = retryRefresh();
+            }
+            else {
+                throw ase;
+            }
+        }
+
+        if (useEnhancedFlow) {
+            populateCredentialsWithCognito(token);
+        } else {
+            populateCredentialsWithSts(token);
+        }
+
+    }
+
+    /**
+     * To be used to call the provider back end to get identifiers.
+     * Specifically, this is the helper that handles the case for when a refresh
+     * call ran into the corrupt identity id case, either a deleted id or a
+     * malformed id. If that happens, this is called, a new id and token are
+     * fetched, and the process is resumed.
+     *
+     * @return the new token gotten by the service
+     */
+    private String retryRefresh() {
+
+        // Ensure we get a new id and token
+        setIdentityId(null);
+        token = identityProvider.refresh();
+        return token;
+    }
+
+    /**
+     * To be used to help the calling of the 2hop flow in event of the identity
+     * id being either missing or deleted. Once that is caught as having
+     * happened, this call is made, which will clear the old id, get a new
+     * one/token, and get the flow going back to where it was with a new request
+     *
+     * @return the result of the new request
+     */
+    private GetCredentialsForIdentityResult retryGetCredentialsForIdentity() {
+        token = retryRefresh();
+
+        Map<String, String> logins;
+        if (token != null && !token.isEmpty()) {
+            logins = new HashMap<String, String>();
+            logins.put("cognito-identity.amazonaws.com", token);
+        } else {
+            logins = getLogins();
+        }
+
+        GetCredentialsForIdentityRequest request = new GetCredentialsForIdentityRequest()
+                .withIdentityId(getIdentityId())
+                .withLogins(logins).withCustomRoleArn(customRoleArn);
+
+        return cib.getCredentialsForIdentity(request);
+    }
+
+    /**
+     * Gets the session credentials from Amazon Cognito.
+     */
+    private void populateCredentialsWithCognito(String token) {
+
+        // For Cognito-authenticated identities token will always be null, but
+        // for developer-authenticated identities, refresh() may return a token
+        // that the the developer backend has received from Cognito and we have
+        // to send back in our request.
+        Map<String, String> logins;
+        if (token != null && !token.isEmpty()) {
+            logins = new HashMap<String, String>();
+            logins.put("cognito-identity.amazonaws.com", token);
+        } else {
+            logins = getLogins();
+        }
+
+        GetCredentialsForIdentityRequest request = new GetCredentialsForIdentityRequest()
+                .withIdentityId(getIdentityId())
+                .withLogins(logins).withCustomRoleArn(customRoleArn);
+
+        GetCredentialsForIdentityResult result = null;
+
+        try {
+            result = cib.getCredentialsForIdentity(request);
+        } catch (ResourceNotFoundException rnfe) {
+            // If the identity id or identity pool is non-existant, this is
+            // thrown
+            result = retryGetCredentialsForIdentity();
+        } catch (AmazonServiceException ase) {
+            // If it's a corrupt id, then a validation exception is thrown
+            if (ase.getErrorCode().equals("ValidationException")) {
+                result = retryGetCredentialsForIdentity();
+            }
+            else {
+                throw ase;
+            }
+        }
+
+        com.amazonaws.services.cognitoidentity.model.Credentials credentials = result
+                .getCredentials();
+        sessionCredentials = new BasicSessionCredentials(credentials.getAccessKeyId(),
+                credentials.getSecretKey(), credentials.getSessionToken());
+        setSessionCredentialsExpiration(credentials.getExpiration());
+
+        if (!result.getIdentityId().equals(getIdentityId())) {
+            setIdentityId(result.getIdentityId());
+        }
+
+    }
+
+    /**
+     * Gets the session credentials by requesting an OpenId Connect token from
+     * Amazon Cognito and then trading it with AWS Secure Token Service for the
+     * short lived session credentials.
+     */
+    private void populateCredentialsWithSts(String token) {
+
+        boolean isAuthenticated = identityProvider.isAuthenticated();
+        String roleArn = (isAuthenticated) ? authRoleArn : unauthRoleArn;
+
+        AssumeRoleWithWebIdentityRequest sessionTokenRequest = new AssumeRoleWithWebIdentityRequest()
+                .withWebIdentityToken(token)
+                .withRoleArn(roleArn)
+                .withRoleSessionName("ProviderSession")
+                .withDurationSeconds(sessionDuration);
+        appendUserAgent(sessionTokenRequest, getUserAgent());
+        AssumeRoleWithWebIdentityResult sessionTokenResult = securityTokenService
+                .assumeRoleWithWebIdentity(sessionTokenRequest);
+        Credentials stsCredentials = sessionTokenResult.getCredentials();
+
+        sessionCredentials = new BasicSessionCredentials(
+                stsCredentials.getAccessKeyId(),
+                stsCredentials.getSecretAccessKey(),
+                stsCredentials.getSessionToken());
+        setSessionCredentialsExpiration(stsCredentials.getExpiration());
+
+    }
+
+    /**
+     * Returns true if a new STS session needs to be started. A new STS session
+     * is needed when no session has been started yet, or if the last session is
+     * within the configured refresh threshold.
+     * 
+     * @return True if a new STS session needs to be started.
+     */
+    protected boolean needsNewSession() {
+    	// NOTE: Do not try to acquire a lock in this method. A thread calling this 
+        // method can already have a read or a write lock.
+        if (sessionCredentials == null) {
+            return true;
+        }
+        long currentTime = System.currentTimeMillis()
+                - SDKGlobalConfiguration.getGlobalTimeOffset() * 1000;
+        long timeRemaining = sessionCredentialsExpiration.getTime()
+                - currentTime;
+        return timeRemaining < (refreshThreshold * 1000);
+    }
+
+    /**
+     * Append user agent string to the request. The final string is what is set
+     * in the ClientCofniguration concatenated with the given userAgent string.
+     *
+     * @param request the request object to be appended
+     * @param userAgent additional user agent string to append
+     */
+    private void appendUserAgent(AmazonWebServiceRequest request,
+            String userAgent) {
+        request.getRequestClientOptions().appendUserAgent(userAgent);
+    }
+
+    /**
+     * Gets the user agent string to append to all requests made by this
+     * provider. Default is an empty string.
+     * 
+     * @return the user agent string
+     */
+    protected String getUserAgent() {
+        return "";
+    }
+
+    /**
+     * Adds a new identity changed listener to process some event when the 
+     * identity has changed. 
+     * 
+     * @param listener the listener to be triggered on id change
+     */
+    public void registerIdentityChangedListener(IdentityChangedListener listener) {
+        identityProvider.registerIdentityChangedListener(listener);
+    }
+
+    /**
+     * Removes an identity changed listener from being triggered when the 
+     * identity has changed. 
+     * 
+     * @param listener the listener to be removed
+     */
+    public void unregisterIdentityChangedListener(IdentityChangedListener listener) {
+        identityProvider.unregisterIdentityChangedListener(listener);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.java
new file mode 100644
index 0000000000..1b790b2c1a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * AWS credentials provider chain that looks for credentials in this order:
+ * <ul>
+ * <li>System Properties - aws.accessKeyId and aws.secretKey</li>
+ * <li>Classpath Properties File - AwsCredentials.properties in classpath</li>
+ * </ul>
+ *
+ * @see SystemPropertiesCredentialsProvider
+ * @see ClasspathPropertiesFileCredentialsProvider
+ */
+@Deprecated
+public class DefaultAWSCredentialsProviderChain extends AWSCredentialsProviderChain {
+
+    /**
+     * Constructor.
+     */
+    public DefaultAWSCredentialsProviderChain() {
+        super(new SystemPropertiesCredentialsProvider(),
+                new ClasspathPropertiesFileCredentialsProvider());
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/IdentityChangedListener.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/IdentityChangedListener.java
new file mode 100644
index 0000000000..5081164f88
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/IdentityChangedListener.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * The interface to handle the appropriate updates when an identity change event
+ * was caught
+ */
+public interface IdentityChangedListener {
+
+    /**
+     * Defines the actions to be taken after an identity change event has been
+     * captured to update data appropriately
+     *
+     * @param oldIdentityId the old identity, now out of date
+     * @param newIdentityId the new identity which is to be kept
+     */
+    void identityChanged(String oldIdentityId, String newIdentityId);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoOpSigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoOpSigner.java
new file mode 100644
index 0000000000..0d62d42ad4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoOpSigner.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.Request;
+
+/**
+ * A No-Op Signer Implementation.
+ */
+public class NoOpSigner implements Signer {
+
+    @Override
+    public void sign(Request<?> request, AWSCredentials credentials) {
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoSessionSupportCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoSessionSupportCredentials.java
new file mode 100644
index 0000000000..877eb63fa7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/NoSessionSupportCredentials.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2011-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Marker interface for credentials that should not be used to start AWS
+ * Security Token Service sessions.
+ */
+public interface NoSessionSupportCredentials {
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Presigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Presigner.java
new file mode 100644
index 0000000000..c776588bdd
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Presigner.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.Request;
+
+import java.util.Date;
+
+/**
+ * A request signer that has special-case logic to presign requests, generating
+ * a URL which embeds the signature suitable for hyperlinking.
+ */
+public interface Presigner {
+    /**
+     * Signs the request by adding the signature to the URL rather than as a
+     * header. This method is expected to modify the passed-in request to add
+     * the signature.
+     *
+     * @param request The request to sign.
+     * @param credentials The credentials to sign it with.
+     * @param expiration The time when this presigned URL will expire.
+     */
+    public void presignRequest(Request<?> request,
+            AWSCredentials credentials,
+            Date expiration);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesCredentials.java
new file mode 100644
index 0000000000..7aca85b7b0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesCredentials.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
+
+/**
+ * Simple implementation AWSCredentials that reads in AWS access keys from a
+ * properties file. The AWS access key is expected to be in the "accessKey"
+ * property and the AWS secret key id is expected to be in the "secretKey"
+ * property.
+ */
+public class PropertiesCredentials implements AWSCredentials {
+
+    private final String accessKey;
+    private final String secretAccessKey;
+
+    /**
+     * Reads the specified file as a Java properties file and extracts the AWS
+     * access key from the "accessKey" property and AWS secret access key from
+     * the "secretKey" property. If the specified file doesn't contain the AWS
+     * access keys an IOException will be thrown.
+     *
+     * @param file The file from which to read the AWS credentials properties.
+     * @throws FileNotFoundException If the specified file isn't found.
+     * @throws IOException If any problems are encountered reading the AWS
+     *             access keys from the specified file.
+     * @throws IllegalArgumentException If the specified properties file does
+     *             not contain the required keys.
+     */
+    @SuppressWarnings("checkstyle:emptyblock")
+    public PropertiesCredentials(File file) throws IOException {
+        if (!file.exists()) {
+            throw new FileNotFoundException("File doesn't exist:  "
+                    + file.getAbsolutePath());
+        }
+
+        FileInputStream stream = new FileInputStream(file);
+        try {
+
+            Properties accountProperties = new Properties();
+            accountProperties.load(stream);
+
+            if (accountProperties.getProperty("accessKey") == null ||
+                    accountProperties.getProperty("secretKey") == null) {
+                throw new IllegalArgumentException(
+                        "The specified file (" + file.getAbsolutePath()
+                                + ") doesn't contain the expected properties 'accessKey' "
+                                + "and 'secretKey'.");
+            }
+
+            accessKey = accountProperties.getProperty("accessKey");
+            secretAccessKey = accountProperties.getProperty("secretKey");
+
+        } finally {
+            try {
+                stream.close();
+            } catch (IOException e) {
+            }
+        }
+    }
+
+    /**
+     * Reads the specified input stream as a stream of Java properties file
+     * content and extracts the AWS access key ID and secret access key from the
+     * properties.
+     *
+     * @param inputStream The input stream containing the AWS credential
+     *            properties.
+     * @throws IOException If any problems occur while reading from the input
+     *             stream.
+     */
+    @SuppressWarnings("checkstyle:emptyblock")
+    public PropertiesCredentials(InputStream inputStream) throws IOException {
+        Properties accountProperties = new Properties();
+        try {
+            accountProperties.load(inputStream);
+        } finally {
+            try {
+                inputStream.close();
+            } catch (Exception e) {
+            }
+        }
+
+        if (accountProperties.getProperty("accessKey") == null ||
+                accountProperties.getProperty("secretKey") == null) {
+            throw new IllegalArgumentException("The specified properties data " +
+                    "doesn't contain the expected properties 'accessKey' and 'secretKey'.");
+        }
+
+        accessKey = accountProperties.getProperty("accessKey");
+        secretAccessKey = accountProperties.getProperty("secretKey");
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSAccessKeyId()
+     */
+    @Override
+    public String getAWSAccessKeyId() {
+        return accessKey;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.AWSCredentials#getAWSSecretKey()
+     */
+    @Override
+    public String getAWSSecretKey() {
+        return secretAccessKey;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesFileCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesFileCredentialsProvider.java
new file mode 100644
index 0000000000..c216f75c64
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/PropertiesFileCredentialsProvider.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonClientException;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * {@link AWSCredentialsProvider} implementation that loads AWS security
+ * credentials from a properties file provided on initialization.
+ * <p>
+ * The AWS access key ID is expected to be in the <code>accessKey</code>
+ * property and the AWS secret key is expected to be in the
+ * <code>secretKey</code> property.
+ */
+public class PropertiesFileCredentialsProvider implements
+        AWSCredentialsProvider {
+
+    private final String credentialsFilePath;
+
+    /**
+     * Creates a new PropertiesFileCredentialsProvider that will attempt to load
+     * a custom file from the path specified to read AWS security credentials.
+     *
+     * @param credentialsFilePath The custom classpath resource path to a
+     *            properties file from which the AWS security credentials should
+     *            be loaded. For example,
+     *            <ul>
+     *            <li>/etc/somewhere/credentials.properties</li>
+     *            </ul>
+     */
+    public PropertiesFileCredentialsProvider(String credentialsFilePath) {
+        if (credentialsFilePath == null)
+            throw new IllegalArgumentException(
+                    "Credentials file path cannot be null");
+        this.credentialsFilePath = credentialsFilePath;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        try {
+            return new PropertiesCredentials(new File(this.credentialsFilePath));
+        } catch (IOException e) {
+            throw new AmazonClientException(
+                    "Unable to load AWS credentials from the "
+                            + credentialsFilePath + " file", e);
+        }
+    }
+
+    @Override
+    public void refresh() {
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + "(" + credentialsFilePath + ")";
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/QueryStringSigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/QueryStringSigner.java
new file mode 100644
index 0000000000..50d4c862a7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/QueryStringSigner.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+
+import java.net.URI;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TimeZone;
+import java.util.TreeMap;
+
+/**
+ * Signer implementation responsible for signing an AWS query string request
+ * according to the various signature versions and hashing algorithms.
+ */
+public class QueryStringSigner extends AbstractAWSSigner implements Signer {
+    /** Date override for testing only */
+    private Date overriddenDate;
+
+    /**
+     * This signer will add "Signature" parameter to the request. Default
+     * signature version is "2" and default signing algorithm is "HmacSHA256".
+     * AWSAccessKeyId SignatureVersion SignatureMethod Timestamp Signature
+     *
+     * @param request request to be signed.
+     * @param credentials The credentials used to use to sign the request.
+     */
+    @Override
+    public void sign(Request<?> request, AWSCredentials credentials) {
+        sign(request, SignatureVersion.V2, SigningAlgorithm.HmacSHA256, credentials);
+    }
+
+    /**
+     * This signer will add following authentication parameters to the request:
+     * AWSAccessKeyId SignatureVersion SignatureMethod Timestamp Signature
+     *
+     * @param request request to be signed.
+     * @param version signature version. "2" is recommended.
+     * @param algorithm signature algorithm. "HmacSHA256" is recommended.
+     * @param credentials AWS credentials.
+     */
+    public void sign(Request<?> request, SignatureVersion version, SigningAlgorithm algorithm,
+            AWSCredentials credentials) {
+        // annonymous credentials, don't sign
+        if (credentials instanceof AnonymousAWSCredentials) {
+            return;
+        }
+
+        AWSCredentials sanitizedCredentials = sanitizeCredentials(credentials);
+        request.addParameter("AWSAccessKeyId", sanitizedCredentials.getAWSAccessKeyId());
+        request.addParameter("SignatureVersion", version.toString());
+
+        int timeOffset = getTimeOffset(request);
+        request.addParameter("Timestamp", getFormattedTimestamp(timeOffset));
+
+        if (sanitizedCredentials instanceof AWSSessionCredentials) {
+            addSessionCredentials(request, (AWSSessionCredentials) sanitizedCredentials);
+        }
+
+        String stringToSign = null;
+        if (version.equals(SignatureVersion.V1)) {
+            stringToSign = calculateStringToSignV1(request.getParameters());
+        } else if (version.equals(SignatureVersion.V2)) {
+            request.addParameter("SignatureMethod", algorithm.toString());
+            stringToSign = calculateStringToSignV2(request);
+        } else {
+            throw new AmazonClientException("Invalid Signature Version specified");
+        }
+
+        String signatureValue = signAndBase64Encode(stringToSign,
+                sanitizedCredentials.getAWSSecretKey(), algorithm);
+        request.addParameter("Signature", signatureValue);
+    }
+
+    /**
+     * Calculates string to sign for signature version 1.
+     *
+     * @param parameters request parameters
+     * @return String to sign
+     */
+    private String calculateStringToSignV1(Map<String, String> parameters) {
+        StringBuilder data = new StringBuilder();
+        SortedMap<String, String> sorted =
+                new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
+        sorted.putAll(parameters);
+
+        for (Map.Entry<String, String> entry : sorted.entrySet()) {
+            data.append(entry.getKey());
+            data.append(entry.getValue());
+        }
+
+        return data.toString();
+    }
+
+    /**
+     * Calculate string to sign for signature version 2.
+     *
+     * @param request The request being signed.
+     * @return String to sign
+     * @throws AmazonClientException If the string to sign cannot be calculated.
+     */
+    private String calculateStringToSignV2(Request<?> request) {
+        URI endpoint = request.getEndpoint();
+        Map<String, String> parameters = request.getParameters();
+
+        StringBuilder data = new StringBuilder();
+        data.append("POST").append("\n");
+        data.append(getCanonicalizedEndpoint(endpoint)).append("\n");
+        data.append(getCanonicalizedResourcePath(request)).append("\n");
+        data.append(getCanonicalizedQueryString(parameters));
+        return data.toString();
+    }
+
+    private String getCanonicalizedResourcePath(Request<?> request) {
+        String resourcePath = "";
+
+        if (request.getEndpoint().getPath() != null) {
+            resourcePath += request.getEndpoint().getPath();
+        }
+
+        if (request.getResourcePath() != null) {
+            if (resourcePath.length() > 0 &&
+                    !resourcePath.endsWith("/") &&
+                    !request.getResourcePath().startsWith("/")) {
+                resourcePath += "/";
+            }
+
+            resourcePath += request.getResourcePath();
+        } else if (!resourcePath.endsWith("/")) {
+            resourcePath += "/";
+        }
+
+        if (!resourcePath.startsWith("/")) {
+            resourcePath = "/" + resourcePath;
+        }
+
+        if (resourcePath.startsWith("//")) {
+            resourcePath = resourcePath.substring(1);
+        }
+
+        return resourcePath;
+    }
+
+    /**
+     * Formats date as ISO 8601 timestamp
+     */
+    private String getFormattedTimestamp(int offset) {
+        SimpleDateFormat df = new SimpleDateFormat(
+                "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
+        df.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        if (overriddenDate != null) {
+            return df.format(overriddenDate);
+        } else {
+            return df.format(getSignatureDate(offset));
+        }
+    }
+
+    /** For testing purposes only, to control the date used in signing. */
+    void overrideDate(Date date) {
+        this.overriddenDate = date;
+    }
+
+    @Override
+    protected void addSessionCredentials(Request<?> request, AWSSessionCredentials credentials) {
+        request.addParameter("SecurityToken", credentials.getSessionToken());
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/RegionAwareSigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/RegionAwareSigner.java
new file mode 100644
index 0000000000..00600bf1a7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/RegionAwareSigner.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * A signer that needs to know which region it is talking to.
+ */
+public interface RegionAwareSigner extends Signer {
+    /**
+     * Configure this signer with the name of the region it will be used to sign
+     * requests for.
+     *
+     * @param value The name of the region.
+     */
+    void setRegionName(String value);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSAssumeRoleSessionCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSAssumeRoleSessionCredentialsProvider.java
new file mode 100644
index 0000000000..7555885146
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSAssumeRoleSessionCredentialsProvider.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
+import com.amazonaws.services.securitytoken.model.AssumeRoleRequest;
+import com.amazonaws.services.securitytoken.model.AssumeRoleResult;
+import com.amazonaws.services.securitytoken.model.Credentials;
+
+import java.util.Date;
+
+/**
+ * AWSCredentialsProvider implementation that uses the AWS Security Token
+ * Service to assume a Role and create temporary, short-lived sessions to use
+ * for authentication.
+ */
+public class STSAssumeRoleSessionCredentialsProvider implements AWSCredentialsProvider {
+
+    /** Default duration for started sessions. */
+    public static final int DEFAULT_DURATION_SECONDS = 900;
+
+    /** Time before expiry within which credentials will be renewed. */
+    private static final int EXPIRY_TIME_MILLIS = 60 * 1000;
+
+    /** The client for starting STS sessions. */
+    private final AWSSecurityTokenService securityTokenService;
+
+    /** The current session credentials. */
+    private AWSSessionCredentials sessionCredentials;
+
+    /** The expiration time for the current session credentials. */
+    private Date sessionCredentialsExpiration;
+
+    /** The arn of the role to be assumed. */
+    private String roleArn;
+
+    /** An identifier for the assumed role session. */
+    private String roleSessionName;
+
+    /**
+     * Constructs a new STSAssumeRoleSessionCredentialsProvider, which makes a
+     * request to the AWS Security Token Service (STS), uses the provided
+     * {@link #roleArn} to assume a role and then request short lived session
+     * credentials, which will then be returned by this class's
+     * {@link #getCredentials()} method.
+     *
+     * @param roleArn The ARN of the Role to be assumed.
+     * @param roleSessionName An identifier for the assumed role session.
+     */
+    public STSAssumeRoleSessionCredentialsProvider(String roleArn, String roleSessionName) {
+        this.roleArn = roleArn;
+        this.roleSessionName = roleSessionName;
+        securityTokenService = new AWSSecurityTokenServiceClient();
+    }
+
+    /**
+     * Constructs a new STSAssumeRoleSessionCredentialsProvider, which will use
+     * the specified long lived AWS credentials to make a request to the AWS
+     * Security Token Service (STS), uses the provided {@link #roleArn} to
+     * assume a role and then request short lived session credentials, which
+     * will then be returned by this class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentials The main AWS credentials for a user's
+     *            account.
+     * @param roleArn The ARN of the Role to be assumed.
+     * @param roleSessionName An identifier for the assumed role session.
+     */
+    public STSAssumeRoleSessionCredentialsProvider(AWSCredentials longLivedCredentials,
+            String roleArn,
+            String roleSessionName) {
+        this(longLivedCredentials, roleArn, roleSessionName, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new STSAssumeRoleSessionCredentialsProvider, which will use
+     * the specified long lived AWS credentials to make a request to the AWS
+     * Security Token Service (STS), uses the provided {@link #roleArn} to
+     * assume a role and then request short lived session credentials, which
+     * will then be returned by this class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentials The main AWS credentials for a user's
+     *            account.
+     * @param roleArn The ARN of the Role to be assumed.
+     * @param roleSessionName An identifier for the assumed role session.
+     * @param clientConfiguration Client configuration connection parameters.
+     */
+    public STSAssumeRoleSessionCredentialsProvider(AWSCredentials longLivedCredentials,
+            String roleArn,
+            String roleSessionName, ClientConfiguration clientConfiguration) {
+        this.roleArn = roleArn;
+        this.roleSessionName = roleSessionName;
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentials,
+                clientConfiguration);
+    }
+
+    /**
+     * Constructs a new STSAssumeRoleSessionCredentialsProvider, which will use
+     * the specified credentials provider (which vends long lived AWS
+     * credentials) to make a request to the AWS Security Token Service (STS),
+     * usess the provided {@link #roleArn} to assume a role and then request
+     * short lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentialsProvider Credentials provider for the main AWS
+     *            credentials for a user's account.
+     * @param roleArn The ARN of the Role to be assumed.
+     * @param roleSessionName An identifier for the assumed role session.
+     */
+    public STSAssumeRoleSessionCredentialsProvider(
+            AWSCredentialsProvider longLivedCredentialsProvider, String roleArn,
+            String roleSessionName) {
+        this.roleArn = roleArn;
+        this.roleSessionName = roleSessionName;
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentialsProvider);
+    }
+
+    /**
+     * Constructs a new STSAssumeRoleSessionCredentialsProvider, which will use
+     * the specified credentials provider (which vends long lived AWS
+     * credentials) to make a request to the AWS Security Token Service (STS),
+     * uses the provided {@link #roleArn} to assume a role and then request
+     * short lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentialsProvider Credentials provider for the main AWS
+     *            credentials for a user's account.
+     * @param roleArn The ARN of the Role to be assumed.
+     * @param roleSessionName An identifier for the assumed role session.
+     * @param clientConfiguration Client configuration connection parameters.
+     */
+    public STSAssumeRoleSessionCredentialsProvider(
+            AWSCredentialsProvider longLivedCredentialsProvider, String roleArn,
+            String roleSessionName, ClientConfiguration clientConfiguration) {
+        this.roleArn = roleArn;
+        this.roleSessionName = roleSessionName;
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentialsProvider,
+                clientConfiguration);
+    }
+
+    /**
+     * Sets the AWS Security Token Service (STS) endpoint where session
+     * credentials are retrieved from.
+     * <p>
+     * </p>
+     * The default AWS Security Token Service (STS) endpoint
+     * ("sts.amazonaws.com") works for all accounts that are not for China
+     * (Beijing) region or GovCloud. You only need to change the endpoint to
+     * "sts.cn-north-1.amazonaws.com.cn" when you are requesting session
+     * credentials for services in China(Beijing) region or
+     * "sts.us-gov-west-1.amazonaws.com" for GovCloud.
+     * <p>
+     * </p>
+     * Setting this invalidates existing session credentials.
+     */
+    public void setSTSClientEndpoint(String endpoint) {
+        securityTokenService.setEndpoint(endpoint);
+        sessionCredentials = null;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        if (needsNewSession()) {
+            startSession();
+        }
+        return sessionCredentials;
+    }
+
+    @Override
+    public void refresh() {
+        startSession();
+    }
+
+    /**
+     * Starts a new session by sending a request to the AWS Security Token
+     * Service (STS) to assume a Role using the long lived AWS credentials. This
+     * class then vends the short lived session credentials for the assumed Role
+     * sent back from STS.
+     */
+    private void startSession() {
+        AssumeRoleResult assumeRoleResult = securityTokenService.assumeRole(new AssumeRoleRequest()
+                .withRoleArn(roleArn).withDurationSeconds(DEFAULT_DURATION_SECONDS)
+                .withRoleSessionName(roleSessionName));
+        Credentials stsCredentials = assumeRoleResult.getCredentials();
+
+        sessionCredentials = new BasicSessionCredentials(stsCredentials.getAccessKeyId(),
+                stsCredentials.getSecretAccessKey(), stsCredentials.getSessionToken());
+        sessionCredentialsExpiration = stsCredentials.getExpiration();
+    }
+
+    /**
+     * Returns true if a new STS session needs to be started. A new STS session
+     * is needed when no session has been started yet, or if the last session is
+     * within {@link #EXPIRY_TIME_MILLIS} seconds of expiring.
+     *
+     * @return True if a new STS session needs to be started.
+     */
+    private boolean needsNewSession() {
+        if (sessionCredentials == null) {
+            return true;
+        }
+        long timeRemaining = sessionCredentialsExpiration.getTime() - System.currentTimeMillis();
+        return timeRemaining < EXPIRY_TIME_MILLIS;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentials.java
new file mode 100644
index 0000000000..6344846dfd
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentials.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2011-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
+import com.amazonaws.services.securitytoken.model.Credentials;
+import com.amazonaws.services.securitytoken.model.GetSessionTokenRequest;
+import com.amazonaws.services.securitytoken.model.GetSessionTokenResult;
+
+import java.util.Date;
+
+/**
+ * Session credentials periodically refreshed by AWS SecurityTokenService.
+ * <p>
+ * Calls to {@link STSSessionCredentials#getAWSAccessKeyId()},
+ * {@link STSSessionCredentials#getAWSSecretKey()}, and
+ * {@link STSSessionCredentials#getSessionToken()} should be synchronized on
+ * this object to prevent races on the boundary of session expiration.
+ * Alternately, clients can call
+ * {@link STSSessionCredentials#getImmutableCredentials()} to ensure a
+ * consistent set of access key, secret key, and token.
+ * <p>
+ * This class is deprecated and should not be used anymore. Instead, use
+ * {@link STSSessionCredentialsProvider}.
+ */
+@Deprecated
+public class STSSessionCredentials implements AWSRefreshableSessionCredentials {
+
+    private final AWSSecurityTokenService securityTokenService;
+    private final int sessionDurationSeconds;
+
+    private Credentials sessionCredentials;
+
+    public static final int DEFAULT_DURATION_SECONDS = 3600;
+
+    /**
+     * Create a new credentials object that will periodically and automatically
+     * obtain a session from STS.
+     *
+     * @param credentials Primary AWS account credentials.
+     */
+    public STSSessionCredentials(AWSCredentials credentials) {
+        this(credentials, DEFAULT_DURATION_SECONDS);
+    }
+
+    /**
+     * Create a new credentials object that will periodically and automatically
+     * obtain a session from STS.
+     *
+     * @param credentials Primary AWS account credentials.
+     * @param sessionDurationSeconds The duration, in seconds, for each session
+     *            to last.
+     */
+    public STSSessionCredentials(AWSCredentials credentials, int sessionDurationSeconds) {
+        this.securityTokenService = new AWSSecurityTokenServiceClient(credentials);
+        this.sessionDurationSeconds = sessionDurationSeconds;
+    }
+
+    /**
+     * Create a new credentials object that will periodically and automatically
+     * obtain a session from STS, using a preconfigured STS client.
+     *
+     * @param stsClient A pre-configured STS client from which to get
+     *            credentials.
+     */
+    public STSSessionCredentials(AWSSecurityTokenService stsClient) {
+        this(stsClient, DEFAULT_DURATION_SECONDS);
+    }
+
+    /**
+     * Create a new credentials object that will periodically and automatically
+     * obtain a session from STS, using a preconfigured STS client.
+     *
+     * @param stsClient A pre-configured STS client from which to get
+     *            credentials.
+     * @param settings Session settings for all sessions created
+     */
+    public STSSessionCredentials(AWSSecurityTokenService stsClient, int sessionDuratinSeconds) {
+        this.securityTokenService = stsClient;
+        this.sessionDurationSeconds = sessionDuratinSeconds;
+    }
+
+    /**
+     * Returns the AWS access key for the current STS session, beginning a new
+     * one if necessary.
+     * <p>
+     * Clients are encouraged to call the atomic
+     * {@link RenewableAWSSessionCredentials#getImmutableCredentials()} as a
+     * proxy to this method.
+     */
+    @Override
+    public synchronized String getAWSAccessKeyId() {
+        return getSessionCredentials().getAccessKeyId();
+    }
+
+    /**
+     * Returns the AWS secret key for the current STS session, beginning a new
+     * one if necessary.
+     * <p>
+     * Clients are encouraged to call the atomic
+     * {@link RenewableAWSSessionCredentials#getImmutableCredentials()} as a
+     * proxy to this method.
+     */
+    @Override
+    public synchronized String getAWSSecretKey() {
+        return getSessionCredentials().getSecretAccessKey();
+    }
+
+    /**
+     * Returns the session token for the current STS session, beginning a new
+     * one if necessary.
+     * <p>
+     * Clients are encouraged to call the atomic
+     * {@link RenewableAWSSessionCredentials#getImmutableCredentials()} as a
+     * proxy to this method.
+     */
+    @Override
+    public synchronized String getSessionToken() {
+        return getSessionCredentials().getSessionToken();
+    }
+
+    /**
+     * Returns immutable session credentials for this session, beginning a new
+     * one if necessary.
+     */
+    public synchronized AWSSessionCredentials getImmutableCredentials() {
+        Credentials creds = getSessionCredentials();
+        return new BasicSessionCredentials(creds.getAccessKeyId(), creds.getSecretAccessKey(),
+                creds.getSessionToken());
+    }
+
+    /**
+     * Refreshes the session credentials from STS.
+     */
+    @Override
+    public synchronized void refreshCredentials() {
+        GetSessionTokenResult sessionTokenResult = securityTokenService
+                .getSessionToken(new GetSessionTokenRequest()
+                        .withDurationSeconds(sessionDurationSeconds));
+        sessionCredentials = sessionTokenResult.getCredentials();
+    }
+
+    /**
+     * Gets a current session credentials object, reinitializing if necessary.
+     */
+    private synchronized Credentials getSessionCredentials() {
+        if (needsNewSession())
+            refreshCredentials();
+        return sessionCredentials;
+    }
+
+    private boolean needsNewSession() {
+        if (sessionCredentials == null)
+            return true;
+
+        Date expiration = sessionCredentials.getExpiration();
+        long timeRemaining = expiration.getTime() - System.currentTimeMillis();
+        if (timeRemaining < (60 * 1000))
+            return true;
+
+        return false;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentialsProvider.java
new file mode 100644
index 0000000000..d5661a7439
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/STSSessionCredentialsProvider.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2011-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
+import com.amazonaws.services.securitytoken.model.Credentials;
+import com.amazonaws.services.securitytoken.model.GetSessionTokenRequest;
+import com.amazonaws.services.securitytoken.model.GetSessionTokenResult;
+
+import java.util.Date;
+
+/**
+ * AWSCredentialsProvider implementation that uses the AWS Security Token
+ * Service to create temporary, short-lived sessions to use for authentication.
+ */
+public class STSSessionCredentialsProvider implements AWSCredentialsProvider {
+
+    /** Default duration for started sessions */
+    public static final int DEFAULT_DURATION_SECONDS = 3600;
+
+    /** The client for starting STS sessions */
+    private final AWSSecurityTokenService securityTokenService;
+
+    /** The current session credentials */
+    private AWSSessionCredentials sessionCredentials;
+
+    /** The expiration time for the current session credentials */
+    private Date sessionCredentialsExpiration;
+
+    /**
+     * Constructs a new STSSessionCredentialsProvider, which will use the
+     * specified long lived AWS credentials to make a request to the AWS
+     * Security Token Service (STS) to request short lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     *
+     * @param longLivedCredentials The main AWS credentials for a user's
+     *            account.
+     */
+    public STSSessionCredentialsProvider(AWSCredentials longLivedCredentials) {
+        this(longLivedCredentials, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new STSSessionCredentialsProvider, which will use the
+     * specified long lived AWS credentials to make a request to the AWS
+     * Security Token Service (STS) to request short lived session credentials,
+     * which will then be returned by this class's {@link #getCredentials()}
+     * method.
+     *
+     * @param longLivedCredentials The main AWS credentials for a user's
+     *            account.
+     * @param clientConfiguration Client configuration connection parameters.
+     */
+    public STSSessionCredentialsProvider(AWSCredentials longLivedCredentials,
+            ClientConfiguration clientConfiguration) {
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentials,
+                clientConfiguration);
+    }
+
+    /**
+     * Constructs a new STSSessionCredentialsProvider, which will use the
+     * specified credentials provider (which vends long lived AWS credentials)
+     * to make a request to the AWS Security Token Service (STS) to request
+     * short lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentialsProvider Credentials provider for the main AWS
+     *            credentials for a user's account.
+     */
+    public STSSessionCredentialsProvider(AWSCredentialsProvider longLivedCredentialsProvider) {
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentialsProvider);
+    }
+
+    /**
+     * Constructs a new STSSessionCredentialsProvider, which will use the
+     * specified credentials provider (which vends long lived AWS credentials)
+     * to make a request to the AWS Security Token Service (STS) to request
+     * short lived session credentials, which will then be returned by this
+     * class's {@link #getCredentials()} method.
+     *
+     * @param longLivedCredentialsProvider Credentials provider for the main AWS
+     *            credentials for a user's account.
+     * @param clientConfiguration Client configuration connection parameters.
+     */
+    public STSSessionCredentialsProvider(AWSCredentialsProvider longLivedCredentialsProvider,
+            ClientConfiguration clientConfiguration) {
+        securityTokenService = new AWSSecurityTokenServiceClient(longLivedCredentialsProvider,
+                clientConfiguration);
+    }
+
+    /**
+     * Sets the AWS Security Token Service (STS) endpoint where session
+     * credentials are retrieved from.
+     * <p>
+     * </p>
+     * The default AWS Security Token Service (STS) endpoint
+     * ("sts.amazonaws.com") works for all accounts that are not for China
+     * (Beijing) region or GovCloud. You only need to change the endpoint to
+     * "sts.cn-north-1.amazonaws.com.cn" when you are requesting session
+     * credentials for services in China(Beijing) region or
+     * "sts.us-gov-west-1.amazonaws.com" for GovCloud.
+     * <p>
+     * </p>
+     * Setting this invalidates existing session credentials.
+     */
+    public void setSTSClientEndpoint(String endpoint) {
+        securityTokenService.setEndpoint(endpoint);
+        sessionCredentials = null;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        if (needsNewSession())
+            startSession();
+
+        return sessionCredentials;
+    }
+
+    @Override
+    public void refresh() {
+        startSession();
+    }
+
+    /**
+     * Starts a new session by sending a request to the AWS Security Token
+     * Service (STS) with the long lived AWS credentials. This class then vends
+     * the short lived session credentials sent back from STS.
+     */
+    private void startSession() {
+        GetSessionTokenResult sessionTokenResult = securityTokenService
+                .getSessionToken(new GetSessionTokenRequest()
+                        .withDurationSeconds(DEFAULT_DURATION_SECONDS));
+        Credentials stsCredentials = sessionTokenResult.getCredentials();
+
+        sessionCredentials = new BasicSessionCredentials(
+                stsCredentials.getAccessKeyId(),
+                stsCredentials.getSecretAccessKey(),
+                stsCredentials.getSessionToken());
+        sessionCredentialsExpiration = stsCredentials.getExpiration();
+    }
+
+    /**
+     * Returns true if a new STS session needs to be started. A new STS session
+     * is needed when no session has been started yet, or if the last session is
+     * within 60 seconds of expiring.
+     *
+     * @return True if a new STS session needs to be started.
+     */
+    private boolean needsNewSession() {
+        if (sessionCredentials == null)
+            return true;
+
+        long timeRemaining = sessionCredentialsExpiration.getTime() - System.currentTimeMillis();
+        return timeRemaining < (60 * 1000);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ServiceAwareSigner.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ServiceAwareSigner.java
new file mode 100644
index 0000000000..043cc6a3f1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/ServiceAwareSigner.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * A signer that needs to know which service it is talking to.
+ */
+public interface ServiceAwareSigner extends Signer {
+    /**
+     * Configure this signer with the name of the service it will be used to
+     * sign requests for.
+     *
+     * @param value The name of the service.
+     */
+    void setServiceName(String value);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SessionCredentialsProviderFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SessionCredentialsProviderFactory.java
new file mode 100644
index 0000000000..80e903ba54
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SessionCredentialsProviderFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Session credentials provider factory to share providers across potentially
+ * many clients.
+ */
+public class SessionCredentialsProviderFactory {
+
+    /**
+     * Key object for the cache combines the access key and the service
+     * endpoint.
+     */
+    private static final class Key {
+
+        private final String awsAccessKeyId;
+        private final String serviceEndpoint;
+
+        public Key(String awsAccessKeyId, String serviceEndpoint) {
+            this.awsAccessKeyId = awsAccessKeyId;
+            this.serviceEndpoint = serviceEndpoint;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((awsAccessKeyId == null) ? 0 : awsAccessKeyId.hashCode());
+            result = prime * result + ((serviceEndpoint == null) ? 0 : serviceEndpoint.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            Key other = (Key) obj;
+            if (awsAccessKeyId == null) {
+                if (other.awsAccessKeyId != null)
+                    return false;
+            } else if (!awsAccessKeyId.equals(other.awsAccessKeyId))
+                return false;
+            if (serviceEndpoint == null) {
+                if (other.serviceEndpoint != null)
+                    return false;
+            } else if (!serviceEndpoint.equals(other.serviceEndpoint))
+                return false;
+            return true;
+        }
+    }
+
+    private static final Map<Key, STSSessionCredentialsProvider> cache = new HashMap<SessionCredentialsProviderFactory.Key, STSSessionCredentialsProvider>();
+
+    /**
+     * Gets a session credentials provider for the long-term credentials and
+     * service endpoint given. These are shared globally to support reuse of
+     * session tokens.
+     *
+     * @param longTermCredentials The long-term AWS account credentials used to
+     *            initiate a session.
+     * @param serviceEndpoint The service endpoint for the service the session
+     *            credentials will be used to access.
+     * @param stsClientConfiguration Client configuration for the
+     *            {@link AWSSecurityTokenService} used to fetch session
+     *            credentials.
+     */
+    public static synchronized STSSessionCredentialsProvider getSessionCredentialsProvider(
+            AWSCredentials longTermCredentials,
+            String serviceEndpoint,
+            ClientConfiguration stsClientConfiguration) {
+        Key key = new Key(longTermCredentials.getAWSAccessKeyId(), serviceEndpoint);
+        if (!cache.containsKey(key)) {
+            cache.put(key, new STSSessionCredentialsProvider(longTermCredentials,
+                    stsClientConfiguration));
+        }
+        return cache.get(key);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignatureVersion.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignatureVersion.java
new file mode 100644
index 0000000000..efa563a4df
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignatureVersion.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/**
+ * Enum for the signature version.
+ */
+public enum SignatureVersion {
+
+    /** Version 1. */
+    V1("1"),
+
+    /** Version 2. */
+    V2("2");
+
+    private String value;
+
+    private SignatureVersion(String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return this.value;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Signer.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Signer.java
new file mode 100644
index 0000000000..ee01dc913f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/Signer.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.Request;
+
+/**
+ * A strategy for applying cryptographic signatures to a request, proving that
+ * the request was made by someone in posession of the given set of credentials
+ * without transmitting the secret key over the wire.
+ */
+public interface Signer {
+    /**
+     * Sign the given request with the given set of credentials. Modifies the
+     * passed-in request to apply the signature.
+     *
+     * @param request The request to sign.
+     * @param credentials The credentials to sign the request with.
+     */
+    public void sign(Request<?> request, AWSCredentials credentials);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignerFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignerFactory.java
new file mode 100644
index 0000000000..05e1338091
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SignerFactory.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.internal.config.InternalConfig;
+import com.amazonaws.internal.config.SignerConfig;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/** Signer factory. */
+public final class SignerFactory {
+
+    private static final String QUERY_STRING_SIGNER = "QueryStringSignerType";
+    private static final String VERSION_THREE_SIGNER = "AWS3SignerType";
+    private static final String VERSION_FOUR_SIGNER = "AWS4SignerType";
+    private static final String NO_OP_SIGNER = "NoOpSignerType";
+
+    private static final Map<String, Class<? extends Signer>> SIGNERS = new ConcurrentHashMap<String, Class<? extends Signer>>();
+
+    static {
+        // Register the standard signer types.
+        SIGNERS.put(QUERY_STRING_SIGNER, QueryStringSigner.class);
+        SIGNERS.put(VERSION_THREE_SIGNER, AWS3Signer.class);
+        SIGNERS.put(VERSION_FOUR_SIGNER, AWS4Signer.class);
+        SIGNERS.put(NO_OP_SIGNER, NoOpSigner.class);
+    }
+
+    /**
+     * Private so you're not tempted to instantiate me.
+     */
+    private SignerFactory() {
+    }
+
+    /**
+     * Register an implementation class for the given signer type.
+     *
+     * @param signerType The name of the signer type to register.
+     * @param signerClass The class implementing the given signature protocol.
+     */
+    public static void registerSigner(
+            final String signerType,
+            final Class<? extends Signer> signerClass) {
+
+        if (signerType == null) {
+            throw new IllegalArgumentException("signerType cannot be null");
+        }
+        if (signerClass == null) {
+            throw new IllegalArgumentException("signerClass cannot be null");
+        }
+
+        SIGNERS.put(signerType, signerClass);
+    }
+
+    /**
+     *
+     * @param serviceName The name of the service to talk to.
+     * @param regionName The name of the region to talk to; not necessarily the
+     *            region used for signing.
+     *
+     * @return a non-null signer for the specified service and region according
+     * to the internal configuration which provides a basic default algorithm
+     * used for signer determination.
+     */
+    public static Signer getSigner(String serviceName, String regionName) {
+        return lookupAndCreateSigner(serviceName, regionName);
+    }
+
+    /**
+     * Returns an instance of the given signer type and configures it with the
+     * given service name (if applicable).
+     *
+     * @param signerType The type of signer to create.
+     * @param serviceName The name of the service to configure on the signer.
+     * @return a non-null signer.
+     */
+    public static Signer getSignerByTypeAndService(String signerType,
+            final String serviceName) {
+        return createSigner(signerType, serviceName);
+    }
+
+    /**
+     * Internal implementation for looking up and creating a signer by service
+     * name and region.
+     */
+    private static Signer lookupAndCreateSigner(String serviceName, String regionName) {
+        InternalConfig config = InternalConfig.Factory.getInternalConfig();
+        SignerConfig signerConfig =
+                config.getSignerConfig(serviceName, regionName);
+        String signerType = signerConfig.getSignerType();
+        return createSigner(signerType, serviceName);
+    }
+
+    /**
+     * Internal implementation to create a signer by type and service name, and
+     * configuring it with the service name if applicable.
+     */
+    private static Signer createSigner(String signerType,
+            final String serviceName) {
+        Class<? extends Signer> signerClass = SIGNERS.get(signerType);
+        if (signerClass == null)
+            throw new IllegalArgumentException();
+        Signer signer;
+        try {
+            signer = signerClass.newInstance();
+        } catch (InstantiationException ex) {
+            throw new IllegalStateException(
+                    "Cannot create an instance of " + signerClass.getName(),
+                    ex);
+        } catch (IllegalAccessException ex) {
+            throw new IllegalStateException(
+                    "Cannot create an instance of " + signerClass.getName(),
+                    ex);
+        }
+
+        if (signer instanceof ServiceAwareSigner) {
+            ((ServiceAwareSigner) signer).setServiceName(serviceName);
+        }
+        return signer;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SigningAlgorithm.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SigningAlgorithm.java
new file mode 100644
index 0000000000..c968d5f609
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SigningAlgorithm.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+/** Enum for the signing algorithm. */
+public enum SigningAlgorithm {
+
+    /** HMAC SHA 1. */
+    HmacSHA1,
+
+    /** HMAC SHA 256. */
+    HmacSHA256;
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SystemPropertiesCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SystemPropertiesCredentialsProvider.java
new file mode 100644
index 0000000000..baa9acb03b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/SystemPropertiesCredentialsProvider.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static com.amazonaws.SDKGlobalConfiguration.ACCESS_KEY_SYSTEM_PROPERTY;
+import static com.amazonaws.SDKGlobalConfiguration.SECRET_KEY_SYSTEM_PROPERTY;
+
+import com.amazonaws.AmazonClientException;
+
+/**
+ * {@link AWSCredentialsProvider} implementation that provides credentials by
+ * looking at the <code>aws.accessKeyId</code> and <code>aws.secretKey</code>
+ * Java system properties.
+ */
+@Deprecated
+public class SystemPropertiesCredentialsProvider implements AWSCredentialsProvider {
+
+    @Override
+    public AWSCredentials getCredentials() {
+        if (System.getProperty(ACCESS_KEY_SYSTEM_PROPERTY) != null &&
+                System.getProperty(SECRET_KEY_SYSTEM_PROPERTY) != null) {
+            return new BasicAWSCredentials(
+                    System.getProperty(ACCESS_KEY_SYSTEM_PROPERTY),
+                    System.getProperty(SECRET_KEY_SYSTEM_PROPERTY));
+        }
+
+        throw new AmazonClientException(
+                "Unable to load AWS credentials from Java system properties " +
+                        "(" + ACCESS_KEY_SYSTEM_PROPERTY + " and " + SECRET_KEY_SYSTEM_PROPERTY
+                        + ")");
+    }
+
+    @Override
+    public void refresh() {
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/WebIdentityFederationSessionCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/WebIdentityFederationSessionCredentialsProvider.java
new file mode 100644
index 0000000000..5669e7ca49
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/WebIdentityFederationSessionCredentialsProvider.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright 2011-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
+import com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest;
+import com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityResult;
+import com.amazonaws.services.securitytoken.model.Credentials;
+
+import java.util.Date;
+
+/**
+ * AWSCredentialsProvider implementation that uses the AWS Security Token
+ * Service to create temporary, short-lived sessions to use for authentication.
+ */
+public class WebIdentityFederationSessionCredentialsProvider implements AWSCredentialsProvider {
+
+    /** Default duration for started sessions */
+    public static final int DEFAULT_DURATION_SECONDS = 3600;
+
+    /** Default threshold for refreshing session credentials */
+    public static final int DEFAULT_THRESHOLD_SECONDS = 500;
+
+    /** The client for starting STS sessions */
+    private final AWSSecurityTokenService securityTokenService;
+
+    /** The current session credentials */
+    private AWSSessionCredentials sessionCredentials;
+
+    /** The expiration time for the current session credentials */
+    private Date sessionCredentialsExpiration;
+
+    private final String wifToken;
+    private final String wifProvider;
+    private final String roleArn;
+    private int sessionDuration;
+    private int refreshThreshold;
+    private String subjectFromWIF;
+
+    /**
+     * Constructs a new WebIdentityFederationSessionCredentialsProvider, which
+     * will use the specified 3rd-party web identity provider to make a request
+     * to the AWS Security Token Service (STS) to request short lived session
+     * credentials, which will then be returned by this class's
+     * {@link #getCredentials()} method.
+     *
+     * @param wifToken The OAuth/OpenID token from the the Identity Provider
+     * @param wifProvider The name of the Identity Provider (null for OpenID
+     *            providers)
+     * @param roleArn The ARN of the IAM Role that will be assumed
+     */
+    public WebIdentityFederationSessionCredentialsProvider(String wifToken, String wifProvider,
+            String roleArn) {
+        this(wifToken, wifProvider, roleArn, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new WebIdentityFederationSessionCredentialsProvider, which
+     * will use the specified 3rd-party web identity provider to make a request
+     * to the AWS Security Token Service (STS) to request short lived session
+     * credentials, which will then be returned by this class's
+     * {@link #getCredentials()} method.
+     *
+     * @param wifToken The OAuth/OpenID token from the the Identity Provider
+     * @param wifProvider The name of the Identity Provider (null for OpenID
+     *            providers)
+     * @param roleArn The ARN of the IAM Role that will be assumed
+     * @param clientConfiguation Configuration to apply to STS client created
+     */
+    public WebIdentityFederationSessionCredentialsProvider(String wifToken, String wifProvider,
+            String roleArn, ClientConfiguration clientConfiguration) {
+        this(wifToken, wifProvider, roleArn, new AWSSecurityTokenServiceClient(
+                new AnonymousAWSCredentials(), clientConfiguration));
+    }
+
+    /**
+     * Constructs a new WebIdentityFederationSessionCredentialsProvider, which
+     * will use the specified 3rd-party web identity provider to make a request
+     * to the AWS Security Token Service (STS) using the provided client to
+     * request short lived session credentials, which will then be returned by
+     * this class's {@link #getCredentials()} method.
+     *
+     * @param wifToken The OAuth/OpenID token from the the Identity Provider
+     * @param wifProvider The name of the Identity Provider (null for OpenID
+     *            providers)
+     * @param roleArn The ARN of the IAM Role that will be assumed
+     * @param stsClient Preconfigured STS client to make requests with
+     */
+    public WebIdentityFederationSessionCredentialsProvider(String wifToken, String wifProvider,
+            String roleArn, AWSSecurityTokenService stsClient) {
+        this.securityTokenService = stsClient;
+        this.wifProvider = wifProvider;
+        this.wifToken = wifToken;
+        this.roleArn = roleArn;
+        this.sessionDuration = DEFAULT_DURATION_SECONDS;
+        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        if (needsNewSession())
+            startSession();
+
+        return sessionCredentials;
+    }
+
+    @Override
+    public void refresh() {
+        startSession();
+    }
+
+    /**
+     * Set the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param sessionDuration The new duration for session credentials created by
+     *            this provider
+     */
+    public void setSessionDuration(int sessionDuration) {
+        this.sessionDuration = sessionDuration;
+    }
+
+    /**
+     * Set the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     * Returns refreence to object so methods can be chained together.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param sessionDuration The new duration for session credentials created by
+     *            this provider
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public WebIdentityFederationSessionCredentialsProvider withSessionDuration(int sessionDuration) {
+        this.setSessionDuration(sessionDuration);
+        return this;
+    }
+
+    /**
+     * Get the duration of the session credentials created by this client in
+     * seconds. Values must be supported by AssumeRoleWithWebIdentityRequest.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @return The duration for session credentials created by this provider
+     */
+    public int getSessionDuration() {
+        return this.sessionDuration;
+    }
+
+    /**
+     * Set the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param refreshThreshold The new refresh threshold for session credentials
+     *            created by this provider
+     */
+    public void setRefreshThreshold(int refreshThreshold) {
+        this.refreshThreshold = refreshThreshold;
+    }
+
+    /**
+     * Set the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS. Returns a refrence to the object
+     * so methods can be chained.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @param refreshThreshold The new refresh threshold for session credentials
+     *            created by this provider
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public WebIdentityFederationSessionCredentialsProvider withRefreshThreshold(int refreshThreshold) {
+        this.setRefreshThreshold(refreshThreshold);
+        return this;
+    }
+
+    /**
+     * Get the refresh threshold for the session credentials created by this
+     * client in seconds. This value will be used internally to determine if new
+     * credentials should be fetched from STS.
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest
+     * @return The refresh threshold for session credentials created by this
+     *         provider
+     */
+    public int getRefreshThreshold() {
+        return this.refreshThreshold;
+    }
+
+    /**
+     * Get the identifier returned from the Identity Provider for the
+     * authenticated user. This value is returned as part of the
+     * AssumeRoleWithIdentityResult
+     *
+     * @see com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityResult
+     * @return The identifier returned from Identity Provider
+     */
+    public String getSubjectFromWIF() {
+        return this.subjectFromWIF;
+    }
+
+    /**
+     * Starts a new session by sending a request to the AWS Security Token
+     * Service (STS) with the long lived AWS credentials. This class then vends
+     * the short lived session credentials sent back from STS.
+     */
+    private void startSession() {
+        AssumeRoleWithWebIdentityResult sessionTokenResult = securityTokenService
+                .assumeRoleWithWebIdentity(new AssumeRoleWithWebIdentityRequest()
+                        .withWebIdentityToken(wifToken)
+                        .withProviderId(wifProvider)
+                        .withRoleArn(roleArn)
+                        .withRoleSessionName("ProviderSession")
+                        .withDurationSeconds(this.sessionDuration));
+        Credentials stsCredentials = sessionTokenResult.getCredentials();
+
+        subjectFromWIF = sessionTokenResult.getSubjectFromWebIdentityToken();
+
+        sessionCredentials = new BasicSessionCredentials(
+                stsCredentials.getAccessKeyId(),
+                stsCredentials.getSecretAccessKey(),
+                stsCredentials.getSessionToken());
+        sessionCredentialsExpiration = stsCredentials.getExpiration();
+    }
+
+    /**
+     * Returns true if a new STS session needs to be started. A new STS session
+     * is needed when no session has been started yet, or if the last session is
+     * within the configured refresh threshold.
+     *
+     * @return True if a new STS session needs to be started.
+     */
+    private boolean needsNewSession() {
+        if (sessionCredentials == null)
+            return true;
+
+        long timeRemaining = sessionCredentialsExpiration.getTime() - System.currentTimeMillis();
+        return timeRemaining < (this.refreshThreshold * 1000);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Action.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Action.java
new file mode 100644
index 0000000000..591542c953
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Action.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+/**
+ * An access control policy action identifies a specific action in a service
+ * that can be performed on a resource. For example, sending a message to a
+ * queue.
+ * <p>
+ * Actions allow you to limit what your access control policy statement affects.
+ * For example, you could create a policy statement that enables a certain group
+ * of users to send messages to your queue, but not allow them to perform any
+ * other actions on your queue.
+ * <p>
+ * The action is B in the statement
+ * "A has permission to do B to C where D applies."
+ * <p>
+ * Free form access control policy actions may include a wildcard (*) to match
+ * multiple actions.
+ * <p>
+ * This class is not intended to be directly implemented, instead developers
+ * should see the classes available in com.amazonaws.auth.policy.actions for
+ * more information on the available actions for each service.
+ */
+public interface Action {
+
+    /**
+     * Returns the name of this action. For example, 'sqs:SendMessage' is the
+     * name corresponding to the SQS action that enables users to send a message
+     * to an SQS queue.
+     *
+     * @return The name of this action.
+     */
+    public String getActionName();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Condition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Condition.java
new file mode 100644
index 0000000000..93641f26d5
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Condition.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import com.amazonaws.auth.policy.conditions.ConditionFactory;
+import com.amazonaws.auth.policy.conditions.NumericCondition;
+import com.amazonaws.auth.policy.conditions.NumericCondition.NumericComparisonType;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * AWS access control policy conditions are contained in {@link Statement}
+ * objects, and affect when a statement is applied. For example, a statement
+ * that allows access to an Amazon SQS queue could use a condition to only apply
+ * the effect of that statement for requests that are made before a certain
+ * date, or that originate from a range of IP addresses.
+ * <p>
+ * Multiple conditions can be included in a single statement, and all conditions
+ * must evaluate to true in order for the statement to take effect.
+ * <p>
+ * The set of conditions is D in the statement
+ * "A has permission to do B to C where D applies."
+ * <p>
+ * A condition is composed of three parts:
+ * <ul>
+ * <li><b>Condition Key</b> - The condition key declares which value of a
+ * request to pull in and compare against when a policy is evaluated by AWS. For
+ * example, using {@link ConditionFactory#SOURCE_IP_CONDITION_KEY} will cause
+ * AWS to pull in the current request's source IP as the first value to compare
+ * against every time your policy is evaluated.
+ * <li><b>Comparison Type</b> - Most condition types allow several ways to
+ * compare the value obtained from the condition key and the comparison value.
+ * For example, the {@link NumericComparisonType} enumerates the ways a
+ * {@link NumericCondition} can be evaluated (less than, greater than, equals,
+ * etc).
+ * <li><b>Comparison Value</b> - This is a static value used as the second value
+ * in the comparison when your policy is evaluated. Depending on the comparison
+ * type, this value can optionally use wildcards. See the documentation for
+ * individual comparison types for more information.
+ * </ul>
+ * <p>
+ * There are many expressive conditions available in the
+ * <code>com.amazonaws.auth.policy.conditions</code> package to use in access
+ * control policy statements.
+ * <p>
+ * This class is not intended to be directly subclassed by users, instead users
+ * should use the many available conditions and condition factories in the
+ * com.amazonaws.auth.policy.conditions package.
+ */
+public class Condition {
+    protected String type;
+    protected String conditionKey;
+    protected List<String> values;
+
+    /**
+     * Returns the type of this condition.
+     *
+     * @return The type of this condition.
+     */
+    public String getType() {
+        return type;
+    }
+
+    /**
+     * Sets the type of this condition.
+     *
+     * @param type The type of this condition.
+     */
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    /**
+     * Returns the name of the condition key involved in this condition.
+     * Condition keys are predefined values supported by AWS that provide input
+     * to a condition's evaluation, such as the current time, or the IP address
+     * of the incoming request.
+     * <p>
+     * Your policy is evaluated for each incoming request, and condition keys
+     * specify what information to pull out of those incoming requests and plug
+     * into the conditions in your policy.
+     *
+     * @return The name of the condition key involved in this condition.
+     */
+    public String getConditionKey() {
+        return conditionKey;
+    }
+
+    /**
+     * Sets the name of the condition key involved in this condition. Condition
+     * keys are predefined values supported by AWS that provide input to a
+     * condition's evaluation, such as the current time, or the IP address of
+     * the incoming request.
+     * <p>
+     * Your policy is evaluated for each incoming request, and condition keys
+     * specify what information to pull out of those incoming requests and plug
+     * into the conditions in your policy.
+     *
+     * @param conditionKey The name of the condition key involved in this
+     *            condition.
+     */
+    public void setConditionKey(String conditionKey) {
+        this.conditionKey = conditionKey;
+    }
+
+    /**
+     * Returns the values specified for this access control policy condition.
+     * For example, in a condition that compares the incoming IP address of a
+     * request to a specified range of IP addresses, the range of IP addresses
+     * is the single value in the condition.
+     * <p>
+     * Most conditions accept only one value, but multiple values are possible.
+     *
+     * @return The values specified for this access control policy condition.
+     */
+    public List<String> getValues() {
+        return values;
+    }
+
+    /**
+     * Sets the values specified for this access control policy condition. For
+     * example, in a condition that compares the incoming IP address of a
+     * request to a specified range of IP addresses, the range of IP addresses
+     * is the single value in the condition.
+     * <p>
+     * Most conditions accept only one value, but multiple values are possible.
+     *
+     * @param values The values specified for this access control policy
+     *            condition.
+     */
+    public void setValues(List<String> values) {
+        this.values = values;
+    }
+
+    /**
+     * Fluent version of {@link Condition#setType(String)}
+     * @param type the type.
+     * @return this
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Condition withType(String type) {
+        setType(type);
+        return this;
+    }
+
+    /**
+     * Fluent version of {@link Condition#setConditionKey(String)}
+     * @param key the key.
+     * @return this
+     */
+    public Condition withConditionKey(String key) {
+        setConditionKey(key);
+        return this;
+    }
+
+    /**
+     * Fluent version of {@link Condition#setValues(List)}
+     * @param values the values.
+     * @return this
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Condition withValues(String... values) {
+        setValues(Arrays.asList(values));
+        return this;
+    }
+
+    /**
+     * Fluent version of {@link Condition#setValues(List)}
+     * @param values the values.
+     * @return this
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Condition withValues(List<String> values) {
+        setValues(values);
+        return this;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Policy.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Policy.java
new file mode 100644
index 0000000000..a20edff276
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Policy.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import com.amazonaws.auth.policy.internal.JsonPolicyReader;
+import com.amazonaws.auth.policy.internal.JsonPolicyWriter;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * An AWS access control policy is a object that acts as a container for one or
+ * more statements, which specify fine grained rules for allowing or denying
+ * various types of actions from being performed on your AWS resources.
+ * <p>
+ * By default, all requests to use your resource coming from anyone but you are
+ * denied. Access control polices can override that by allowing different types
+ * of access to your resources, or by explicitly denying different types of
+ * access.
+ * <p>
+ * Each statement in an AWS access control policy takes the form:
+ * "A has permission to do B to C where D applies".
+ * <ul>
+ * <li>A is the <b>principal</b> - the AWS account that is making a request to
+ * access or modify one of your AWS resources.
+ * <li>B is the <b>action</b> - the way in which your AWS resource is being
+ * accessed or modified, such as sending a message to an Amazon SQS queue, or
+ * storing an object in an Amazon S3 bucket.
+ * <li>C is the <b>resource</b> - your AWS entity that the principal wants to
+ * access, such as an Amazon SQS queue, or an object stored in Amazon S3.
+ * <li>D is the set of <b>conditions</b> - optional constraints that specify
+ * when to allow or deny access for the principal to access your resource. Many
+ * expressive conditions are available, some specific to each service. For
+ * example you can use date conditions to allow access to your resources only
+ * after or before a specific time.
+ * </ul>
+ * <p>
+ * Note that an AWS access control policy should not be confused with the
+ * similarly named "POST form policy" concept used in Amazon S3.
+ */
+public class Policy {
+
+    /** The default policy version */
+    private static final String DEFAULT_POLICY_VERSION = "2012-10-17";
+
+    private String id;
+    private String version = DEFAULT_POLICY_VERSION;
+    private List<Statement> statements = new ArrayList<Statement>();
+
+    /**
+     * Constructs an empty AWS access control policy ready to be populated with
+     * statements.
+     */
+    public Policy() {
+    }
+
+    /**
+     * Constructs a new AWS access control policy with the specified policy ID.
+     * The policy ID is a user specified string that serves to help developers
+     * keep track of multiple polices. Policy IDs are often used as a human
+     * readable name for a policy.
+     *
+     * @param id The policy ID for the new policy object. Policy IDs serve to
+     *            help developers keep track of multiple policies, and are often
+     *            used to give the policy a meaningful, human readable name.
+     */
+    public Policy(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Constructs a new AWS access control policy with the specified policy ID
+     * and collection of statements. The policy ID is a user specified string
+     * that serves to help developers keep track of multiple polices. Policy IDs
+     * are often used as a human readable name for a policy.
+     * <p>
+     * Any statements that don't have a statement ID yet will automatically be
+     * assigned a unique ID within this policy.
+     *
+     * @param id The policy ID for the new policy object. Policy IDs serve to
+     *            help developers keep track of multiple policies, and are often
+     *            used to give the policy a meaningful, human readable name.
+     * @param statements The statements to include in the new policy.
+     */
+    public Policy(String id, Collection<Statement> statements) {
+        this(id);
+        setStatements(statements);
+    }
+
+    /**
+     * Returns the policy ID for this policy. Policy IDs serve to help
+     * developers keep track of multiple policies, and are often used as human
+     * readable name for a policy.
+     *
+     * @return The policy ID for this policy.
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Sets the policy ID for this policy. Policy IDs serve to help developers
+     * keep track of multiple policies, and are often used as human readable
+     * name for a policy.
+     *
+     * @param id The policy ID for this policy.
+     */
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Sets the policy ID for this policy and returns the updated policy so that
+     * multiple calls can be chained together.
+     * <p>
+     * Policy IDs serve to help developers keep track of multiple policies, and
+     * are often used as human readable name for a policy.
+     *
+     * @param id The policy ID for this policy.
+     * @return The updated Policy object so that additional calls can be chained
+     *         together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Policy withId(String id) {
+        setId(id);
+        return this;
+    }
+
+    /**
+     * Returns the version of this AWS policy.
+     *
+     * @return The version of this AWS policy.
+     */
+    public String getVersion() {
+        return version;
+    }
+
+    /**
+     * Returns the collection of statements contained by this policy. Individual
+     * statements in a policy are what specify the rules that enable or disable
+     * access to your AWS resources.
+     *
+     * @return The collection of statements contained by this policy.
+     */
+    public Collection<Statement> getStatements() {
+        return statements;
+    }
+
+    /**
+     * Sets the collection of statements contained by this policy. Individual
+     * statements in a policy are what specify the rules that enable or disable
+     * access to your AWS resources.
+     * <p>
+     * Any statements that don't have a statement ID yet will automatically be
+     * assigned a unique ID within this policy.
+     *
+     * @param statements The collection of statements included in this policy.
+     */
+    public void setStatements(Collection<Statement> statements) {
+        this.statements = new ArrayList<Statement>(statements);
+        assignUniqueStatementIds();
+    }
+
+    /**
+     * Sets the collection of statements contained by this policy and returns
+     * this policy object so that additional method calls can be chained
+     * together.
+     * <p>
+     * Individual statements in a policy are what specify the rules that enable
+     * or disable access to your AWS resources.
+     * <p>
+     * Any statements that don't have a statement ID yet will automatically be
+     * assigned a unique ID within this policy.
+     *
+     * @param statements The collection of statements included in this policy.
+     * @return The updated policy object, so that additional method calls can be
+     *         chained together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Policy withStatements(Statement... statements) {
+        setStatements(Arrays.asList(statements));
+        return this;
+    }
+
+    /**
+     * Returns a JSON string representation of this AWS access control policy,
+     * suitable to be sent to an AWS service as part of a request to set an
+     * access control policy.
+     *
+     * @return A JSON string representation of this AWS access control policy.
+     */
+    public String toJson() {
+        return new JsonPolicyWriter().writePolicyToString(this);
+    }
+
+    /**
+     * Returns an AWS access control policy object generated from JSON string.
+     *
+     * @param jsonString The JSON string representation of this AWS access
+     *            control policy.
+     * @return An AWS access control policy object.
+     * @throws IllegalArgumentException If the specified JSON string is null or
+     *             invalid and cannot be converted to an AWS policy object.
+     */
+    public static Policy fromJson(String jsonString) {
+        return new JsonPolicyReader().createPolicyFromJsonString(jsonString);
+    }
+
+    @SuppressWarnings("checkstyle:emptystatement")
+    private void assignUniqueStatementIds() {
+        Set<String> usedStatementIds = new HashSet<String>();
+        for (Statement statement : statements) {
+            if (statement.getId() != null)
+                usedStatementIds.add(statement.getId());
+        }
+
+        int counter = 0;
+        for (Statement statement : statements) {
+            if (statement.getId() != null)
+                continue;
+
+            while (usedStatementIds.contains(Integer.toString(++counter)))
+                ;
+            statement.setId(Integer.toString(counter));
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Principal.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Principal.java
new file mode 100644
index 0000000000..edfb0ebcff
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Principal.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+/**
+ * A principal is an AWS account or AWS web serivce, which is being allowed or
+ * denied access to a resource through an access control policy. The principal
+ * is a property of the {@link Statement} object, not directly the
+ * {@link Policy} object.
+ * <p>
+ * The principal is A in the statement
+ * "A has permission to do B to C where D applies."
+ * <p>
+ * In an access control policy statement, you can set the principal to all
+ * authenticated AWS users through the {@link Principal#AllUsers} member. This
+ * is useful when you don't want to restrict access based on the identity of the
+ * requester, but instead on other identifying characteristics such as the
+ * requester's IP address.
+ */
+public class Principal {
+
+    /**
+     * Principal instance that includes all users, including anonymous users.
+     * <p>
+     * This is useful when you don't want to restrict access based on the
+     * identity of the requester, but instead on other identifying
+     * characteristics such as the requester's IP address.
+     */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final Principal AllUsers = new Principal("AWS", "*");
+
+    /**
+     * Principal instance that includes all AWS web services.
+     */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final Principal AllServices = new Principal("Service", "*");
+
+    /**
+     * Principal instance that includes all the web identity providers.
+     */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final Principal AllWebProviders = new Principal("Federated", "*");
+
+    /**
+     * Principal instance that includes all the AWS accounts, AWS web services
+     * and web identity providers.
+     */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final Principal All = new Principal("*", "*");
+
+    private final String id;
+    private final String provider;
+
+    /**
+     * Constructs a new principal with the specified AWS web service which is
+     * being allowed or denied access to a resource through an access control
+     * policy.
+     *
+     * @param service An AWS service.
+     */
+    public Principal(Services service) {
+        if (service == null) {
+            throw new IllegalArgumentException("Null AWS service name specified");
+        }
+        id = service.getServiceId();
+        provider = "Service";
+    }
+
+    /**
+     * Constructs a new principal with the specified id and provider.
+     * @param provider the provider.
+     * @param id the id.
+     */
+    public Principal(String provider, String id) {
+        this.provider = provider;
+        if ("AWS".equals(provider)) {
+            id = id.replaceAll("-", "");
+        }
+        this.id = id;
+    }
+
+    /**
+     * Constructs a new principal with the specified AWS account ID.
+     *
+     * @param accountId An AWS account ID.
+     */
+    public Principal(String accountId) {
+        if (accountId == null) {
+            throw new IllegalArgumentException("Null AWS account ID specified");
+        }
+
+        this.id = accountId.replaceAll("-", "");
+        provider = "AWS";
+    }
+
+    /**
+     * Constructs a new principal with the specified web identity provider.
+     *
+     * @param webIdentityProvider An web identity provider.
+     */
+    public Principal(WebIdentityProviders webIdentityProvider) {
+        if (webIdentityProvider == null) {
+            throw new IllegalArgumentException("Null web identity provider specified");
+        }
+        this.id = webIdentityProvider.getWebIdentityProvider();
+        provider = "Federated";
+    }
+
+    /**
+     * Returns the provider for this principal, which indicates in what group of
+     * users this principal resides.
+     *
+     * @return The provider for this principal.
+     */
+    public String getProvider() {
+        return provider;
+    }
+
+    /**
+     * Returns the unique ID for this principal.
+     *
+     * @return The unique ID for this principal.
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * The services who have the right to do the assume the role action. The
+     * AssumeRole action returns a set of temporary security credentials that
+     * you can use to access resources that are defined in the role's policy.
+     * The returned credentials consist of an Access Key ID, a Secret Access
+     * Key, and a security token.
+     */
+    public static enum Services {
+
+        /** AWS Data Pipeline. */
+        AWSDataPipeline("datapipeline.amazonaws.com"),
+
+        /** Amazon Elastic Transcoder. */
+        AmazonElasticTranscoder("elastictranscoder.amazonaws.com"),
+
+        /** Amazon EC2. */
+        AmazonEC2("ec2.amazonaws.com"),
+
+        /** AWS Ops Works. */
+        AWSOpsWorks("opsworks.amazonaws.com"),
+
+        /** AWS Cloud HSM. */
+        AWSCloudHSM("cloudhsm.amazonaws.com"),
+
+        /** All services. */
+        AllServices("*");
+
+        private String serviceId;
+
+        /**
+         * The service which has the right to assume the role.
+         */
+        private Services(String serviceId) {
+            this.serviceId = serviceId;
+        }
+
+        public String getServiceId() {
+            return serviceId;
+        }
+
+        /**
+         * Construct the Services object from a string representing the service
+         * id.
+         * @param serviceId the service ID.
+         * @return the Services object.
+         */
+        public static Services fromString(String serviceId) {
+            if (serviceId != null) {
+                for (Services s : Services.values()) {
+                    if (s.getServiceId().equalsIgnoreCase(serviceId)) {
+                        return s;
+                    }
+                }
+            }
+
+            return null;
+        }
+
+    }
+
+    /**
+     * Web identity providers, such as Login with Amazon, Facebook, or Google.
+     */
+    public static enum WebIdentityProviders {
+
+        /** Facebook. */
+        Facebook("graph.facebook.com"),
+
+        /** Google. */
+        Google("accounts.google.com"),
+
+        /** Amazon. */
+        Amazon("www.amazon.com"),
+
+        /** All providers. */
+        AllProviders("*");
+
+        private String webIdentityProvider;
+
+        /**
+         * The web identity provider which has the right to assume the role.
+         */
+        private WebIdentityProviders(String webIdentityProvider) {
+            this.webIdentityProvider = webIdentityProvider;
+        }
+
+        public String getWebIdentityProvider() {
+            return webIdentityProvider;
+        }
+
+        /**
+         * Construct the Services object from a string representing web identity
+         * provider.
+         * @param webIdentityProvider string representing web identity provider.
+         * @return WebIdentityProviders object.
+         */
+        public static WebIdentityProviders fromString(String webIdentityProvider) {
+            if (webIdentityProvider != null) {
+                for (WebIdentityProviders provider : WebIdentityProviders.values()) {
+                    if (provider.getWebIdentityProvider().equalsIgnoreCase(webIdentityProvider)) {
+                        return provider;
+                    }
+                }
+            }
+
+            return null;
+        }
+
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + provider.hashCode();
+        hashCode = prime * hashCode + id.hashCode();
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object principal) {
+        if (this == principal) {
+            return true;
+        }
+
+        if (principal == null) {
+            return false;
+        }
+
+        if (!(principal instanceof Principal)) {
+            return false;
+        }
+
+        Principal other = (Principal) principal;
+
+        if (this.getProvider().equals(other.getProvider())
+                && this.getId().equals(other.getId())) {
+            return true;
+        }
+
+        return false;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Resource.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Resource.java
new file mode 100644
index 0000000000..1c57d64943
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Resource.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+/**
+ * Represents a resource involved in an AWS access control policy statement.
+ * Resources are the service specific AWS entities owned by your account. Amazon
+ * SQS queues, Amazon S3 buckets and objects, and Amazon SNS topics are all
+ * examples of AWS resources.
+ * <p>
+ * The standard way of specifying an AWS resource is with an Amazon Resource
+ * Name (ARN).
+ * <p>
+ * The resource is C in the statement
+ * "A has permission to do B to C where D applies."
+ */
+public class Resource {
+    private final String resource;
+
+    /**
+     * Constructs a new AWS access control policy resource. Resources are
+     * typically specified as Amazon Resource Names (ARNs).
+     * <p>
+     * You specify the resource using the following Amazon Resource Name (ARN)
+     * format:
+     * <b>arn:aws:&lt;vendor>:&lt;region>:&lt;namespace>:&lt;relative-id></b>
+     * <p>
+     * <ul>
+     * <li>vendor identifies the AWS product (e.g., sns)</li>
+     * <li>region is the AWS Region the resource resides in (e.g., us-east-1),
+     * if any
+     * <li>namespace is the AWS account ID with no hyphens (e.g., 123456789012)
+     * <li>relative-id is the service specific portion that identifies the
+     * specific resource
+     * </ul>
+     * <p>
+     * For example, an Amazon SQS queue might be addressed with the following
+     * ARN: <b>arn:aws:sqs:us-east-1:987654321000:MyQueue</b>
+     * <p>
+     * Some resources may not use every field in an ARN. For example, resources
+     * in Amazon S3 are global, so they omit the region field:
+     * <b>arn:aws:s3:::bucket/*</b>
+     *
+     * @param resource The Amazon Resource Name (ARN) uniquely identifying the
+     *            desired AWS resource.
+     */
+    public Resource(String resource) {
+        this.resource = resource;
+    }
+
+    /**
+     * Returns the resource ID, typically an Amazon Resource Name (ARN),
+     * identifying this resource.
+     *
+     * @return The resource ID, typically an Amazon Resource Name (ARN),
+     *         identifying this resource.
+     */
+    public String getId() {
+        return resource;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/STSActions.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/STSActions.java
new file mode 100644
index 0000000000..db1340cbb4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/STSActions.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
+
+/**
+ * The available AWS access control policy actions for Amazon Security Token
+ * Service.
+ *
+ * @see Statement#setActions(java.util.Collection)
+ * @deprecated in favor of
+ *             {@link com.amazonaws.auth.policy.actions.SecurityTokenServiceActions}
+ */
+@Deprecated
+public enum STSActions implements Action {
+
+    /**
+     * Action for assuming role to do cross-account access or federation.
+     *
+     * @see AWSSecurityTokenService#assumeRole(com.amazonaws.services.securitytoken.model.AssumeRoleRequest)
+     */
+    AssumeRole("sts:AssumeRole"),
+
+    /**
+     * Action for assuming role with web federation to get a set of temporary
+     * security credentials for users who have been authenticated in a mobile or
+     * web application with a web identity provider.
+     *
+     * @see AWSSecurityTokenService#assumeRoleWithWebIdentity(com.amazonaws.services.securitytoken.model.AssumeRoleWithWebIdentityRequest)
+     */
+    AssumeRoleWithWebIdentity("sts:AssumeRoleWithWebIdentity");
+
+    private final String action;
+
+    private STSActions(String action) {
+        this.action = action;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.auth.policy.Action#getId()
+     */
+    @Override
+    public String getActionName() {
+        return this.action;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Statement.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Statement.java
new file mode 100644
index 0000000000..854b80a1ab
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/Statement.java
@@ -0,0 +1,411 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * A statement is the formal description of a single permission, and is always
+ * contained within a policy object.
+ * <p>
+ * A statement describes a rule for allowing or denying access to a specific AWS
+ * resource based on how the resource is being accessed, and who is attempting
+ * to access the resource. Statements can also optionally contain a list of
+ * conditions that specify when a statement is to be honored.
+ * <p>
+ * For example, consider a statement that:
+ * <ul>
+ * <li>allows access (the effect)
+ * <li>for a list of specific AWS account IDs (the principals)
+ * <li>when accessing an SQS queue (the resource)
+ * <li>using the SendMessage operation (the action)
+ * <li>and the request occurs before a specific date (a condition)
+ * </ul>
+ * <p>
+ * Statements takes the form: "A has permission to do B to C where D applies".
+ * <ul>
+ * <li>A is the <b>principal</b> - the AWS account that is making a request to
+ * access or modify one of your AWS resources.
+ * <li>B is the <b>action</b> - the way in which your AWS resource is being
+ * accessed or modified, such as sending a message to an Amazon SQS queue, or
+ * storing an object in an Amazon S3 bucket.
+ * <li>C is the <b>resource</b> - your AWS entity that the principal wants to
+ * access, such as an Amazon SQS queue, or an object stored in Amazon S3.
+ * <li>D is the set of <b>conditions</b> - optional constraints that specify
+ * when to allow or deny access for the principal to access your resource. Many
+ * expressive conditions are available, some specific to each service. For
+ * example you can use date conditions to allow access to your resources only
+ * after or before a specific time.
+ * </ul>
+ * <p>
+ * There are many resources and conditions available for use in statements, and
+ * you can combine them to form fine grained custom access control polices.
+ */
+public class Statement {
+
+    /**
+     * The effect is the result that you want a policy statement to return at
+     * evaluation time. A policy statement can either allow access or explicitly
+     * deny access.
+     */
+    public static enum Effect {
+
+        /** Allow. */
+        Allow(),
+
+        /** Deny. */
+        Deny();
+    }
+
+    private String id;
+    private Effect effect;
+    private List<Principal> principals = new ArrayList<Principal>();
+    private List<Action> actions = new ArrayList<Action>();
+    private List<Resource> resources;
+    private List<Condition> conditions = new ArrayList<Condition>();
+
+    /**
+     * Constructs a new access control policy statement with the specified
+     * effect.
+     * <p>
+     * Before a statement is valid and can be sent to AWS, callers must set the
+     * principals, resources, and actions (as well as any optional conditions)
+     * involved in the statement.
+     *
+     * @param effect The effect this statement has (allowing access or denying
+     *            access) when all conditions, resources, principals, and
+     *            actions are matched.
+     */
+    public Statement(Effect effect) {
+        this.effect = effect;
+        this.id = null;
+    }
+
+    /**
+     * Returns the ID for this statement. Statement IDs serve to help keep track
+     * of multiple statements, and are often used to give the statement a
+     * meaningful, human readable name.
+     * <p>
+     * Statement IDs must be unique within a policy, but are not required to be
+     * globally unique.
+     * <p>
+     * If you do not explicitly assign an ID to a statement, a unique ID will be
+     * automatically assigned when the statement is added to a policy.
+     * <p>
+     * Developers should be careful to not use the same statement ID for
+     * multiple statements in the same policy. Reusing the same statement ID in
+     * different policies is not a problem.
+     *
+     * @return The statement ID.
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Sets the ID for this statement. Statement IDs serve to help keep track of
+     * multiple statements, and are often used to give the statement a
+     * meaningful, human readable name.
+     * <p>
+     * Statement IDs must be unique within a policy, but are not required to be
+     * globally unique.
+     * <p>
+     * If you do not explicitly assign an ID to a statement, a unique ID will be
+     * automatically assigned when the statement is added to a policy.
+     * <p>
+     * Developers should be careful to not use the same statement ID for
+     * multiple statements in the same policy. Reusing the same statement ID in
+     * different policies is not a problem.
+     *
+     * @param id The new statement ID for this statement.
+     */
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Sets the ID for this statement and returns the updated statement so
+     * multiple calls can be chained together.
+     * <p>
+     * Statement IDs serve to help keep track of multiple statements, and are
+     * often used to give the statement a meaningful, human readable name.
+     * <p>
+     * If you do not explicitly assign an ID to a statement, a unique ID will be
+     * automatically assigned when the statement is added to a policy.
+     * <p>
+     * Developers should be careful to not use the same statement ID for
+     * multiple statements in the same policy. Reusing the same statement ID in
+     * different policies is not a problem.
+     *
+     * @param id The new statement ID for this statement.
+     * @return the Statement.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Statement withId(String id) {
+        setId(id);
+        return this;
+    }
+
+    /**
+     * Returns the result effect of this policy statement when it is evaluated.
+     * A policy statement can either allow access or explicitly
+     *
+     * @return The result effect of this policy statement.
+     */
+    public Effect getEffect() {
+        return effect;
+    }
+
+    /**
+     * Sets the result effect of this policy statement when it is evaluated. A
+     * policy statement can either allow access or explicitly
+     *
+     * @param effect The result effect of this policy statement.
+     */
+    public void setEffect(Effect effect) {
+        this.effect = effect;
+    }
+
+    /**
+     * Returns the list of actions to which this policy statement applies.
+     * Actions limit a policy statement to specific service operations that are
+     * being allowed or denied by the policy statement. For example, you might
+     * want to allow any AWS user to post messages to your SQS queue using the
+     * SendMessage action, but you don't want to allow those users other actions
+     * such as ReceiveMessage or DeleteQueue.
+     *
+     * @return The list of actions to which this policy statement applies.
+     */
+    public List<Action> getActions() {
+        return actions;
+    }
+
+    /**
+     * Sets the list of actions to which this policy statement applies. Actions
+     * limit a policy statement to specific service operations that are being
+     * allowed or denied by the policy statement. For example, you might want to
+     * allow any AWS user to post messages to your SQS queue using the
+     * SendMessage action, but you don't want to allow those users other actions
+     * such as ReceiveMessage or DeleteQueue.
+     *
+     * @param actions The list of actions to which this policy statement
+     *            applies.
+     */
+    public void setActions(Collection<Action> actions) {
+        this.actions = new ArrayList<Action>(actions);
+    }
+
+    /**
+     * Sets the list of actions to which this policy statement applies and
+     * returns this updated Statement object so that additional method calls can
+     * be chained together.
+     * <p>
+     * Actions limit a policy statement to specific service operations that are
+     * being allowed or denied by the policy statement. For example, you might
+     * want to allow any AWS user to post messages to your SQS queue using the
+     * SendMessage action, but you don't want to allow those users other actions
+     * such as ReceiveMessage or DeleteQueue.
+     *
+     * @param actions The list of actions to which this statement applies.
+     * @return The updated Statement object so that additional method calls can
+     *         be chained together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Statement withActions(Action... actions) {
+        setActions(Arrays.asList(actions));
+        return this;
+    }
+
+    /**
+     * Returns the resources associated with this policy statement. Resources
+     * are what a policy statement is allowing or denying access to, such as an
+     * Amazon SQS queue or an Amazon SNS topic.
+     * <p>
+     * Note that some services allow only one resource to be specified per
+     * policy statement.
+     *
+     * @return The resources associated with this policy statement.
+     */
+    public List<Resource> getResources() {
+        return resources;
+    }
+
+    /**
+     * Sets the resources associated with this policy statement. Resources are
+     * what a policy statement is allowing or denying access to, such as an
+     * Amazon SQS queue or an Amazon SNS topic.
+     * <p>
+     * Note that some services allow only one resource to be specified per
+     * policy statement.
+     *
+     * @param resources The resources associated with this policy statement.
+     */
+    public void setResources(Collection<Resource> resources) {
+        this.resources = new ArrayList<Resource>(resources);
+    }
+
+    /**
+     * Sets the resources associated with this policy statement and returns this
+     * updated Statement object so that additional method calls can be chained
+     * together.
+     * <p>
+     * Resources are what a policy statement is allowing or denying access to,
+     * such as an Amazon SQS queue or an Amazon SNS topic.
+     * <p>
+     * Note that some services allow only one resource to be specified per
+     * policy statement.
+     *
+     * @param resources The resources associated with this policy statement.
+     * @return The updated Statement object so that additional method calls can
+     *         be chained together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Statement withResources(Resource... resources) {
+        setResources(Arrays.asList(resources));
+        return this;
+    }
+
+    /**
+     * Returns the conditions associated with this policy statement. Conditions
+     * allow policy statements to be conditionally evaluated based on the many
+     * available condition types.
+     * <p>
+     * For example, a statement that allows access to an Amazon SQS queue could
+     * use a condition to only apply the effect of that statement for requests
+     * that are made before a certain date, or that originate from a range of IP
+     * addresses.
+     * <p>
+     * When multiple conditions are included in a single statement, all
+     * conditions must evaluate to true in order for the statement to take
+     * effect.
+     *
+     * @return The conditions associated with this policy statement.
+     */
+    public List<Condition> getConditions() {
+        return conditions;
+    }
+
+    /**
+     * Sets the conditions associated with this policy statement. Conditions
+     * allow policy statements to be conditionally evaluated based on the many
+     * available condition types.
+     * <p>
+     * For example, a statement that allows access to an Amazon SQS queue could
+     * use a condition to only apply the effect of that statement for requests
+     * that are made before a certain date, or that originate from a range of IP
+     * addresses.
+     * <p>
+     * Multiple conditions can be included in a single statement, and all
+     * conditions must evaluate to true in order for the statement to take
+     * effect.
+     *
+     * @param conditions The conditions associated with this policy statement.
+     */
+    public void setConditions(List<Condition> conditions) {
+        this.conditions = conditions;
+    }
+
+    /**
+     * Sets the conditions associated with this policy statement, and returns
+     * this updated Statement object so that additional method calls can be
+     * chained together.
+     * <p>
+     * Conditions allow policy statements to be conditionally evaluated based on
+     * the many available condition types.
+     * <p>
+     * For example, a statement that allows access to an Amazon SQS queue could
+     * use a condition to only apply the effect of that statement for requests
+     * that are made before a certain date, or that originate from a range of IP
+     * addresses.
+     * <p>
+     * Multiple conditions can be included in a single statement, and all
+     * conditions must evaluate to true in order for the statement to take
+     * effect.
+     *
+     * @param conditions The conditions associated with this policy statement.
+     * @return The updated Statement object so that additional method calls can
+     *         be chained together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Statement withConditions(Condition... conditions) {
+        setConditions(Arrays.asList(conditions));
+        return this;
+    }
+
+    /**
+     * Returns the principals associated with this policy statement, indicating
+     * which AWS accounts are affected by this policy statement.
+     *
+     * @return The list of principals associated with this policy statement.
+     */
+    public List<Principal> getPrincipals() {
+        return principals;
+    }
+
+    /**
+     * Sets the principals associated with this policy statement, indicating
+     * which AWS accounts are affected by this policy statement.
+     * <p>
+     * If you don't want to restrict your policy to specific users, you can use
+     * {@link Principal#AllUsers} to apply the policy to any user trying to
+     * access your resource.
+     *
+     * @param principals The list of principals associated with this policy
+     *            statement.
+     */
+    public void setPrincipals(Collection<Principal> principals) {
+        this.principals = new ArrayList<Principal>(principals);
+    }
+
+    /**
+     * Sets the principals associated with this policy statement, indicating
+     * which AWS accounts are affected by this policy statement.
+     * <p>
+     * If you don't want to restrict your policy to specific users, you can use
+     * {@link Principal#AllUsers} to apply the policy to any user trying to
+     * access your resource.
+     *
+     * @param principals The list of principals associated with this policy
+     *            statement.
+     */
+    public void setPrincipals(Principal... principals) {
+        setPrincipals(new ArrayList<Principal>(Arrays.asList(principals)));
+    }
+
+    /**
+     * Sets the principals associated with this policy statement, and returns
+     * this updated Statement object. Principals control which AWS accounts are
+     * affected by this policy statement.
+     * <p>
+     * If you don't want to restrict your policy to specific users, you can use
+     * {@link Principal#AllUsers} to apply the policy to any user trying to
+     * access your resource.
+     *
+     * @param principals The list of principals associated with this policy
+     *            statement.
+     * @return The updated Statement object so that additional method calls can
+     *         be chained together.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public Statement withPrincipals(Principal... principals) {
+        setPrincipals(principals);
+        return this;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/SecurityTokenServiceActions.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/SecurityTokenServiceActions.java
new file mode 100644
index 0000000000..afe0a8a591
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/SecurityTokenServiceActions.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.actions;
+
+import com.amazonaws.auth.policy.Action;
+
+/**
+ * The available AWS access control policy actions for AWS Security Token
+ * Service.
+ */
+public enum SecurityTokenServiceActions implements Action {
+    /** Represents any action executed on AWS Security Token Service. */
+    AllSecurityTokenServiceActions("sts:*"),
+
+    /** Action for the AssumeRole operation. */
+    AssumeRole("sts:AssumeRole"),
+
+    /** Action for the AssumeRoleWithWebIdentity operation. */
+    AssumeRoleWithWebIdentity("sts:AssumeRoleWithWebIdentity"),
+
+    /** Action for the GetCallerIdentity operation. */
+    GetCallerIdentity("sts:GetCallerIdentity"),
+
+    /** Action for the GetFederationToken operation. */
+    GetFederationToken("sts:GetFederationToken"),
+
+    /** Action for the GetSessionToken operation. */
+    GetSessionToken("sts:GetSessionToken");
+
+    private final String action;
+
+    private SecurityTokenServiceActions(String action) {
+        this.action = action;
+    }
+
+    public String getActionName() {
+        return this.action;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/package-info.java
new file mode 100644
index 0000000000..f4c5831c0a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/actions/package-info.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * Collection of actions for AWS access control policies.  Actions describe how
+ * AWS resources are being accessed or modified when an AWS access control policy
+ * is evaluated for an incoming request.
+ */
+
+package com.amazonaws.auth.policy.actions;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ArnCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ArnCondition.java
new file mode 100644
index 0000000000..628ec35e18
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ArnCondition.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+
+import java.util.Arrays;
+
+/**
+ * AWS access control policy condition that allows an access control statement
+ * to be conditionally applied based on the comparison of an Amazon Resource
+ * Name (ARN).
+ * <p>
+ * An Amazon Resource Name (ARN) takes the following format:
+ * <b>arn:aws:&lt;vendor>:&lt;region>:&lt;namespace>:&lt;relative-id></b>
+ * <p>
+ * <ul>
+ * <li>vendor identifies the AWS product (e.g., sns)</li>
+ * <li>region is the AWS Region the resource resides in (e.g., us-east-1), if
+ * any
+ * <li>namespace is the AWS account ID with no hyphens (e.g., 123456789012)
+ * <li>relative-id is the service specific portion that identifies the specific
+ * resource
+ * </ul>
+ * <p>
+ * For example, an Amazon SQS queue might be addressed with the following ARN:
+ * <b>arn:aws:sqs:us-east-1:987654321000:MyQueue</b>
+ * <p>
+ * <p>
+ * Currently the only valid condition key to use in an ARN condition is
+ * {@link ConditionFactory#SOURCE_ARN_CONDITION_KEY}, which indicates the source
+ * resource that is modifying another resource, for example, an SNS topic is the
+ * source ARN when publishing messages from the topic to an SQS queue.
+ */
+public class ArnCondition extends Condition {
+
+    /**
+     * Enumeration of the supported ways an ARN comparison can be evaluated.
+     */
+    public static enum ArnComparisonType {
+        /** Exact matching */
+        ArnEquals,
+
+        /**
+         * Loose case-insensitive matching of the ARN. Each of the six
+         * colon-delimited components of the ARN is checked separately and each
+         * can include a multi-character match wildcard (*) or a
+         * single-character match wildcard (?).
+         */
+        ArnLike,
+
+        /** Negated form of {@link #ArnEquals} */
+        ArnNotEquals,
+
+        /** Negated form of {@link #ArnLike} */
+        ArnNotLike;
+    };
+
+    /**
+     * Constructs a new access control policy condition that compares ARNs
+     * (Amazon Resource Names).
+     *
+     * @param type The type of comparison to perform.
+     * @param key The access policy condition key specifying where to get the
+     *            first ARN for the comparison (ex:
+     *            {@link ConditionFactory#SOURCE_ARN_CONDITION_KEY}).
+     * @param value The second ARN to compare against. When using
+     *            {@link ArnComparisonType#ArnLike} or
+     *            {@link ArnComparisonType#ArnNotLike} this may contain the
+     *            multi-character wildcard (*) or the single-character wildcard
+     *            (?).
+     */
+    public ArnCondition(ArnComparisonType type, String key, String value) {
+        super.type = type.toString();
+        super.conditionKey = key;
+        super.values = Arrays.asList(new String[] {
+            value
+        });
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/BooleanCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/BooleanCondition.java
new file mode 100644
index 0000000000..367be05206
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/BooleanCondition.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+
+import java.util.Arrays;
+
+/**
+ * AWS access control policy condition that allows an access control statement
+ * to be conditionally applied based on a comparison of boolean values.
+ */
+public class BooleanCondition extends Condition {
+
+    /**
+     * Constructs a new access policy condition that performs a boolean
+     * comparison.
+     *
+     * @param key The access policy condition key specifying where to get the
+     *            first boolean value for the comparison (ex:
+     *            aws:SecureTransport).
+     * @param value The boolean to compare against.
+     */
+    public BooleanCondition(String key, boolean value) {
+        super.type = "Bool";
+        super.conditionKey = key;
+        super.values = Arrays.asList(new String[] {
+            Boolean.toString(value)
+        });
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ConditionFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ConditionFactory.java
new file mode 100644
index 0000000000..486c818fa3
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/ConditionFactory.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+import com.amazonaws.auth.policy.conditions.ArnCondition.ArnComparisonType;
+import com.amazonaws.auth.policy.conditions.StringCondition.StringComparisonType;
+
+/**
+ * Factory for creating common AWS access control policy conditions. These
+ * conditions are common for AWS services and can be expected to work across any
+ * service that supports AWS access control policies.
+ */
+public final class ConditionFactory {
+
+    /**
+     * Condition key for the current time.
+     * <p>
+     * This condition key should only be used with {@link DateCondition}
+     * objects.
+     */
+    public static final String CURRENT_TIME_CONDITION_KEY = "aws:CurrentTime";
+
+    /**
+     * Condition key for whether or not an incoming request is using a secure
+     * transport to make the request (i.e. HTTPS instead of HTTP).
+     * <p>
+     * This condition key should only be used with {@link BooleanCondition}
+     * objects.
+     */
+    public static final String SECURE_TRANSPORT_CONDITION_KEY = "aws:SecureTransport";
+
+    /**
+     * Condition key for the source IP from which a request originates.
+     * <p>
+     * This condition key should only be used with {@link IpAddressCondition}
+     * objects.
+     */
+    public static final String SOURCE_IP_CONDITION_KEY = "aws:SourceIp";
+
+    /**
+     * Condition key for the user agent included in a request.
+     * <p>
+     * This condition key should only be used with {@link StringCondition}
+     * objects.
+     */
+    public static final String USER_AGENT_CONDITION_KEY = "aws:UserAgent";
+
+    /**
+     * Condition key for the current time, in epoch seconds.
+     * <p>
+     * This condition key should only be used with {@link NumericCondition}
+     * objects.
+     */
+    public static final String EPOCH_TIME_CONDITION_KEY = "aws:EpochTime";
+
+    /**
+     * Condition key for the referer specified by a request.
+     * <p>
+     * This condition key should only be used with {@link StringCondition}
+     * objects.
+     */
+    public static final String REFERER_CONDITION_KEY = "aws:Referer";
+
+    /**
+     * Condition key for the Amazon Resource Name (ARN) of the source specified
+     * in a request. The source ARN indicates which resource is affecting the
+     * resource listed in your policy. For example, an SNS topic is the source
+     * ARN when publishing messages from the topic to an SQS queue.
+     * <p>
+     * This condition key should only be used with {@link ArnCondition} objects.
+     */
+    public static final String SOURCE_ARN_CONDITION_KEY = "aws:SourceArn";
+
+    private ConditionFactory() {
+    }
+
+    /**
+     * Constructs a new access policy condition that compares the Amazon
+     * Resource Name (ARN) of the source of an AWS resource that is modifying
+     * another AWS resource with the specified pattern.
+     * <p>
+     * For example, the source ARN could be an Amazon SNS topic ARN that is
+     * sending messages to an Amazon SQS queue. In that case, the SNS topic ARN
+     * would be compared the ARN pattern specified here.
+     * <p>
+     * The endpoint pattern may optionally contain the multi-character wildcard
+     * (*) or the single-character wildcard (?). Each of the six colon-delimited
+     * components of the ARN is checked separately and each can include a
+     * wildcard.
+     *
+     * <pre class="brush: java">
+     * Policy policy = new Policy(&quot;MyQueuePolicy&quot;);
+     * policy.withStatements(new Statement(&quot;AllowSNSMessages&quot;, Effect.Allow)
+     *         .withPrincipals(new Principal(&quot;*&quot;)).withActions(SQSActions.SendMessage)
+     *         .withResources(new Resource(myQueueArn))
+     *         .withConditions(ConditionFactory.newSourceArnCondition(myTopicArn)));
+     * </pre>
+     *
+     * @param arnPattern The ARN pattern against which the source ARN will be
+     *            compared. Each of the six colon-delimited components of the
+     *            ARN is checked separately and each can include a wildcard.
+     * @return A new access control policy condition that compares the ARN of the
+     *         source specified in an incoming request with the ARN pattern
+     *         specified here.
+     */
+    public static Condition newSourceArnCondition(String arnPattern) {
+        return new ArnCondition(ArnComparisonType.ArnLike, SOURCE_ARN_CONDITION_KEY, arnPattern);
+    }
+
+    /**
+     * Constructs a new access control policy condition that tests if the
+     * incoming request was sent over a secure transport (HTTPS).
+     *
+     * @return A new access control policy condition that tests if the incoming
+     *         request was sent over a secure transport (HTTPS).
+     */
+    public static Condition newSecureTransportCondition() {
+        return new BooleanCondition(SECURE_TRANSPORT_CONDITION_KEY, true);
+    }
+
+    /**
+     * Constructs a new access control policy condition that tests the incoming
+     * request's user agent field against the specified value, using the
+     * specified comparison type. This condition can be used to allow or deny
+     * access to a resource based on what user agent is specified in the
+     * request.
+     *
+     * @param comparisonType The type of string comparison to perform when
+     *            testing an incoming request's user agent field with the
+     *            specified value.
+     * @param value The value against which to compare the incoming request's
+     *            user agent.
+     * @return A new access control policy condition that tests an incoming
+     *         request's user agent field.
+     */
+    public static Condition newUserAgentCondition(StringComparisonType comparisonType, String value) {
+        return new StringCondition(comparisonType, USER_AGENT_CONDITION_KEY, value);
+    }
+
+    /**
+     * Constructs a new access control policy condition that tests the incoming
+     * request's referer field against the specified value, using the specified
+     * comparison type.
+     *
+     * @param comparisonType The type of string comparison to perform when
+     *            testing an incoming request's referer field with the specified
+     *            value.
+     * @param value The value against which to compare the incoming request's
+     *            referer field.
+     * @return A new access control policy condition that tests an incoming
+     *         request's referer field.
+     */
+    public static Condition newRefererCondition(StringComparisonType comparisonType, String value) {
+        return new StringCondition(comparisonType, REFERER_CONDITION_KEY, value);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/DateCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/DateCondition.java
new file mode 100644
index 0000000000..1f27176764
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/DateCondition.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+import com.amazonaws.util.DateUtils;
+
+import java.util.Arrays;
+import java.util.Date;
+
+/**
+ * AWS access control policy condition that allows an access control statement
+ * to be conditionally applied based on the comparison of the current time at
+ * which a request is received, and a specific date.
+ */
+public class DateCondition extends Condition {
+
+    /**
+     * Enumeration of the supported ways a date comparison can be evaluated.
+     */
+    public static enum DateComparisonType {
+
+        /** Date equals. */
+        DateEquals,
+
+        /** Date greater than. */
+        DateGreaterThan,
+
+        /** Date greater than or equals. */
+        DateGreaterThanEquals,
+
+        /** Date less than. */
+        DateLessThan,
+
+        /** Date less than or equals. */
+        DateLessThanEquals,
+
+        /** Date not equals. */
+        DateNotEquals;
+    };
+
+    /**
+     * Constructs a new access policy condition that compares the current time
+     * (on the AWS servers) to the specified date.
+     *
+     * @param type The type of comparison to perform. For example,
+     *            {@link DateComparisonType#DateLessThan} will cause this policy
+     *            condition to evaluate to true if the current date is less than
+     *            the date specified in the second argument.
+     * @param date The date to compare against.
+     */
+    public DateCondition(DateComparisonType type, Date date) {
+        super.type = type.toString();
+        super.conditionKey = ConditionFactory.CURRENT_TIME_CONDITION_KEY;
+        super.values = Arrays.asList(new String[] {
+            DateUtils.formatISO8601Date(date)
+        });
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/IpAddressCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/IpAddressCondition.java
new file mode 100644
index 0000000000..754eed3150
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/IpAddressCondition.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+
+import java.util.Arrays;
+
+/**
+ * AWS access control policy condition that allows an access control statement
+ * to be conditionally applied based on the comparison of the the incoming
+ * source IP address at the time of a request against a CIDR IP range.
+ * <p>
+ * For more information about CIDR IP ranges, see <a
+ * href="http://en.wikipedia.org/wiki/CIDR_notation">
+ * http://en.wikipedia.org/wiki/CIDR_notation</a>
+ */
+public class IpAddressCondition extends Condition {
+
+    /**
+     * Enumeration of the supported ways an IP address comparison can be
+     * evaluated.
+     */
+    public static enum IpAddressComparisonType {
+        /**
+         * Matches an IP address against a CIDR IP range, evaluating to true if
+         * the IP address being tested is in the condition's specified CIDR IP
+         * range.
+         * <p>
+         * For more information about CIDR IP ranges, see <a
+         * href="http://en.wikipedia.org/wiki/CIDR_notation">
+         * http://en.wikipedia.org/wiki/CIDR_notation</a>
+         */
+        IpAddress,
+
+        /** Negated form of {@link #IpAddress} */
+        NotIpAddress,
+    }
+
+    /**
+     * Constructs a new access policy condition that compares the source IP
+     * address of the incoming request to an AWS service against the specified
+     * CIDR range. The condition evaluates to true (meaning the policy statement
+     * containing it will be applied) if the incoming source IP address is
+     * within that range.
+     * <p>
+     * To achieve the opposite effect (i.e. cause the condition to evaluate to
+     * true when the incoming source IP is <b>not</b> in the specified CIDR
+     * range) use the alternate constructor form and specify
+     * {@link IpAddressComparisonType#NotIpAddress}
+     * <p>
+     * For more information about CIDR IP ranges, see <a
+     * href="http://en.wikipedia.org/wiki/CIDR_notation">
+     * http://en.wikipedia.org/wiki/CIDR_notation</a>
+     *
+     * @param ipAddressRange The CIDR IP range involved in the policy condition.
+     */
+    public IpAddressCondition(String ipAddressRange) {
+        this(IpAddressComparisonType.IpAddress, ipAddressRange);
+    }
+
+    /**
+     * Constructs a new access policy condition that compares the source IP
+     * address of the incoming request to an AWS service against the specified
+     * CIDR range. When the condition evaluates to true (i.e. when the incoming
+     * source IP address is within the CIDR range or not) depends on the
+     * specified {@link IpAddressComparisonType}.
+     * <p>
+     * For more information about CIDR IP ranges, see <a
+     * href="http://en.wikipedia.org/wiki/CIDR_notation">
+     * http://en.wikipedia.org/wiki/CIDR_notation</a>
+     *
+     * @param type The type of comparison to to perform.
+     * @param ipAddressRange The CIDR IP range involved in the policy condition.
+     */
+    public IpAddressCondition(IpAddressComparisonType type, String ipAddressRange) {
+        super.type = type.toString();
+        super.conditionKey = ConditionFactory.SOURCE_IP_CONDITION_KEY;
+        super.values = Arrays.asList(new String[] {
+            ipAddressRange
+        });
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/NumericCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/NumericCondition.java
new file mode 100644
index 0000000000..c6e167bd68
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/NumericCondition.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+
+import java.util.Arrays;
+
+/**
+ * AWS access control policy condition that allows an access control statement
+ * to be conditionally applied based on a numeric comparison.
+ */
+public class NumericCondition extends Condition {
+
+    /** Enumeration of the supported ways a numeric comparison can be evaluated */
+    public static enum NumericComparisonType {
+
+        /** Numeric equals. */
+        NumericEquals,
+
+        /** Numeric greater than. */
+        NumericGreaterThan,
+
+        /** Numeric greater than or equals. */
+        NumericGreaterThanEquals,
+
+        /** Numeric less than. */
+        NumericLessThan,
+
+        /** Numeric less than or equals. */
+        NumericLessThanEquals,
+
+        /** Numeric not equals. */
+        NumericNotEquals;
+    };
+
+    /**
+     * Constructs a new access policy condition that compares two numbers.
+     *
+     * @param type The type of comparison to perform.
+     * @param key The access policy condition key specifying where to get the
+     *            first number for the comparison.
+     * @param value The second number to compare against.
+     */
+    public NumericCondition(NumericComparisonType type, String key, String value) {
+        super.type = type.toString();
+        super.conditionKey = key;
+        super.values = Arrays.asList(new String[] {
+            value
+        });
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/StringCondition.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/StringCondition.java
new file mode 100644
index 0000000000..6dce6e6b71
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/StringCondition.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
+import com.amazonaws.auth.policy.Condition;
+
+import java.util.Arrays;
+
+/**
+ * String conditions let you constrain AWS access control policy statements
+ * using string matching rules.
+ */
+public class StringCondition extends Condition {
+
+    /**
+     * Enumeration of the supported ways a string comparison can be evaluated.
+     */
+    public static enum StringComparisonType {
+        /** Case-sensitive exact string matching */
+        StringEquals,
+
+        /** Case-insensitive string matching */
+        StringEqualsIgnoreCase,
+
+        /**
+         * Loose case-insensitive matching. The values can include a
+         * multi-character match wildcard (*) or a single-character match
+         * wildcard (?) anywhere in the string.
+         */
+        StringLike,
+
+        /** Negated form of {@link #StringEquals} */
+        StringNotEquals,
+
+        /** Negated form of {@link #StringEqualsIgnoreCase} */
+        StringNotEqualsIgnoreCase,
+
+        /** Negated form of {@link #StringLike} */
+        StringNotLike;
+    }
+
+    /**
+     * Constructs a new access control policy condition that compares two
+     * strings.
+     *
+     * @param type The type of comparison to perform.
+     * @param key The access policy condition key specifying where to get the
+     *            first string for the comparison (ex: aws:UserAgent). See
+     *            {@link ConditionFactory} for a list of the condition keys
+     *            available for all services.
+     * @param value The second string to compare against. When using
+     *            {@link StringComparisonType#StringLike} or
+     *            {@link StringComparisonType#StringNotLike} this may contain
+     *            the multi-character wildcard (*) or the single-character
+     *            wildcard (?).
+     */
+    public StringCondition(StringComparisonType type, String key, String value) {
+        super.type = type.toString();
+        super.conditionKey = key;
+        super.values = Arrays.asList(new String[] {
+            value
+        });
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/package-info.java
new file mode 100644
index 0000000000..4be78ef3fb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/conditions/package-info.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * Collection of AWS access control policy conditions.  The primary access policy
+ * conditions are:
+ * <ul>
+ *    <li> {@link com.amazonaws.auth.policy.conditions.ArnCondition}
+ *    <li> {@link com.amazonaws.auth.policy.conditions.BooleanCondition}
+ *    <li> {@link com.amazonaws.auth.policy.conditions.DateCondition}
+ *    <li> {@link com.amazonaws.auth.policy.conditions.IpAddressCondition}
+ *    <li> {@link com.amazonaws.auth.policy.conditions.NumericCondition}
+ *    <li> {@link com.amazonaws.auth.policy.conditions.StringCondition}
+ * </ul>
+ *
+ * <p>
+ * In addition to the primary condition types, service specific functionality
+ * is also provided.
+ */
+
+package com.amazonaws.auth.policy.conditions;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonDocumentFields.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonDocumentFields.java
new file mode 100644
index 0000000000..f1e15e0f0c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonDocumentFields.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.internal;
+
+public class JsonDocumentFields {
+    public static final String VERSION = "Version";
+    public static final String POLICY_ID = "Id";
+    public static final String STATEMENT = "Statement";
+    public static final String STATEMENT_EFFECT = "Effect";
+    public static final String EFFECT_VALUE_ALLOW = "Allow";
+    public static final String STATEMENT_ID = "Sid";
+    public static final String PRINCIPAL = "Principal";
+    public static final String ACTION = "Action";
+    public static final String RESOURCE = "Resource";
+    public static final String CONDITION = "Condition";
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyReader.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyReader.java
new file mode 100644
index 0000000000..fc14b5e5ee
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyReader.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.internal;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.auth.policy.Action;
+import com.amazonaws.auth.policy.Condition;
+import com.amazonaws.auth.policy.Policy;
+import com.amazonaws.auth.policy.Principal;
+import com.amazonaws.auth.policy.Principal.WebIdentityProviders;
+import com.amazonaws.auth.policy.Resource;
+import com.amazonaws.auth.policy.Statement;
+import com.amazonaws.auth.policy.Statement.Effect;
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.JsonUtils;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Generate an AWS policy object by parsing the given JSON string.
+ */
+public class JsonPolicyReader {
+
+    private static final String PRINCIPAL_SCHEMA_USER = "AWS";
+
+    private static final String PRINCIPAL_SCHEMA_SERVICE = "Service";
+
+    private static final String PRINICIPAL_SCHEMA_FEDERATED = "Federated";
+
+    private AwsJsonReader reader;
+
+    /**
+     * Converts the specified JSON string to an AWS policy object. For more
+     * information see, @see http://docs.aws.amazon.com/AWSSdkDocsJava/latest
+     * /DeveloperGuide/java-dg-access-control.html
+     *
+     * @param jsonString the specified JSON string representation of this AWS
+     *            access control policy.
+     * @return An AWS policy object.
+     * @throws IllegalArgumentException If the specified JSON string is null or
+     *             invalid and cannot be converted to an AWS policy object.
+     */
+    public Policy createPolicyFromJsonString(String jsonString) {
+
+        if (jsonString == null) {
+            throw new IllegalArgumentException("JSON string cannot be null");
+        }
+
+        reader = JsonUtils.getJsonReader(new StringReader(jsonString));
+        Policy policy = new Policy();
+        List<Statement> statements = new LinkedList<Statement>();
+
+        try {
+            reader.beginObject();
+            while (reader.hasNext()) {
+                String name = reader.nextName();
+                if (JsonDocumentFields.POLICY_ID.equals(name)) {
+                    policy.setId(reader.nextString());
+                } else if (JsonDocumentFields.STATEMENT.equals(name)) {
+                    reader.beginArray();
+                    while (reader.hasNext()) {
+                        statements.add(statementOf(reader));
+                    }
+                    reader.endArray();
+                } else {
+                    reader.skipValue();
+                }
+            }
+            reader.endObject();
+
+        } catch (Exception e) {
+            String message = "Unable to generate policy object fron JSON string "
+                    + e.getMessage();
+            throw new IllegalArgumentException(message, e);
+        } finally {
+            try {
+                reader.close();
+            } catch (IOException e) {
+            }
+        }
+        policy.setStatements(statements);
+        return policy;
+    }
+
+    /**
+     * Creates a <code>Statement<code> instance from the statement node.
+     *
+     * A statement consists of an Effect, id (optional), principal, action, resource,
+     * and conditions.
+     * <p>
+     * principal is the AWS account that is making a request to access or modify one of your AWS resources.
+     * <p>
+     * action is the way in which your AWS resource is being accessed or modified, such as sending a message to an Amazon SQS queue, or storing an object in an Amazon S3 bucket.
+     * <p>
+     * resource is the AWS entity that the principal wants to access, such as an Amazon SQS queue, or an object stored in Amazon S3.
+     * <p>
+     * conditions are the optional constraints that specify when to allow or deny access for the principal to access your resource. Many expressive conditions are available, some specific to each service. For example, you can use date conditions to allow access to your resources only after or before a specific time.
+     *
+     * @param jStatement JsonNode representing the statement.
+     * @return a reference to the statement instance created.
+     * @throws IOException
+     */
+    private Statement statementOf(AwsJsonReader reader) throws IOException {
+
+        Statement statement = new Statement(null);
+
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (JsonDocumentFields.STATEMENT_EFFECT.equals(name)) {
+                statement.setEffect(Effect.valueOf(reader.nextString()));
+            } else if (JsonDocumentFields.STATEMENT_ID.equals(name)) {
+                statement.setId(reader.nextString());
+            } else if (JsonDocumentFields.ACTION.equals(name)) {
+                statement.setActions(actionsOf(reader));
+            } else if (JsonDocumentFields.RESOURCE.equals(name)) {
+                statement.setResources(resourcesOf(reader));
+            } else if (JsonDocumentFields.PRINCIPAL.equals(name)) {
+                statement.setPrincipals(principalOf(reader));
+            } else if (JsonDocumentFields.CONDITION.equals(name)) {
+                statement.setConditions(conditionsOf(reader));
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+
+        return statement.getEffect() == null ? null : statement;
+    }
+
+    /**
+     * Generates a list of actions from the Action JSON Node.
+     *
+     * @param actionNodes the action JSON node to be parsed.
+     * @return the list of actions.
+     * @throws IOException
+     */
+    private List<Action> actionsOf(AwsJsonReader reader) throws IOException {
+        List<Action> actions = new LinkedList<Action>();
+
+        if (reader.isContainer()) {
+            reader.beginArray();
+            while (reader.hasNext()) {
+                actions.add(new NamedAction(reader.nextString()));
+            }
+            reader.endArray();
+        } else {
+            actions.add(new NamedAction(reader.nextString()));
+        }
+
+        return actions;
+    }
+
+    /**
+     * Generates a list of resources from the Resource JSON Node.
+     *
+     * @param resourceNodes the resource JSON node to be parsed.
+     * @return the list of resources.
+     */
+    private List<Resource> resourcesOf(AwsJsonReader reader) throws IOException {
+        List<Resource> resources = new LinkedList<Resource>();
+
+        if (reader.isContainer()) {
+            reader.beginArray();
+            while (reader.hasNext()) {
+                resources.add(new Resource(reader.nextString()));
+            }
+            reader.endArray();
+        } else {
+            resources.add(new Resource(reader.nextString()));
+        }
+
+        return resources;
+    }
+
+    /**
+     * Generates a list of principals from the Principal JSON Node
+     *
+     * @param principalNodes the principal JSON to be parsed
+     * @return a list of principals
+     * @throws IOException
+     */
+    private List<Principal> principalOf(AwsJsonReader reader) throws IOException {
+        List<Principal> principals = new LinkedList<Principal>();
+
+        if (reader.isContainer()) {
+            reader.beginObject();
+            String schema;
+            while (reader.hasNext()) {
+                schema = reader.nextName();
+                if (reader.isContainer()) {
+                    reader.beginArray();
+                    while (reader.hasNext()) {
+                        principals.add(createPrincipal(schema, reader.nextString()));
+                    }
+                    reader.endArray();
+                } else {
+                    principals.add(createPrincipal(schema, reader.nextString()));
+                }
+            }
+            reader.endObject();
+        } else {
+            String s = reader.nextString();
+            if ("*".equals(s)) {
+                principals.add(Principal.All);
+            } else {
+                throw new IllegalArgumentException("Invalid principals: " + s);
+            }
+        }
+
+        return principals;
+    }
+
+    /**
+     * Creates a new principal instance for the given schema and the JSON node.
+     *
+     * @param schema the schema for the principal instance being created.
+     * @param principalNode the node indicating the AWS account that is making
+     *            the request.
+     * @return a principal instance.
+     */
+    private Principal createPrincipal(String schema, String principal) {
+        if (schema.equalsIgnoreCase(PRINCIPAL_SCHEMA_USER)) {
+            return new Principal(principal);
+        } else if (schema.equalsIgnoreCase(PRINCIPAL_SCHEMA_SERVICE)) {
+            return new Principal(schema, principal);
+        } else if (schema.equalsIgnoreCase(PRINICIPAL_SCHEMA_FEDERATED)) {
+            if (WebIdentityProviders.fromString(principal) != null) {
+                return new Principal(
+                        WebIdentityProviders.fromString(principal));
+            } else {
+                return new Principal(PRINICIPAL_SCHEMA_FEDERATED, principal);
+            }
+        }
+        throw new AmazonClientException("Schema " + schema
+                + " is not a valid value for the principal.");
+    }
+
+    /**
+     * Generates a list of condition from the JSON node.
+     *
+     * @param conditionNodes the condition JSON node to be parsed.
+     * @return the list of conditions.
+     * @throws IOException
+     */
+    private List<Condition> conditionsOf(AwsJsonReader reader) throws IOException {
+
+        List<Condition> conditionList = new LinkedList<Condition>();
+
+        reader.beginObject();
+        while (reader.hasNext()) {
+            convertConditionRecord(conditionList, reader.nextName(), reader);
+        }
+        reader.endObject();
+
+        return conditionList;
+    }
+
+    /**
+     * Generates a condition instance for each condition type under the
+     * Condition JSON node.
+     *
+     * @param conditions the complete list of conditions
+     * @param conditionType the condition type for the condition being created.
+     * @param conditionNode each condition node to be parsed.
+     * @throws IOException
+     */
+    private void convertConditionRecord(List<Condition> conditions,
+            String conditionType, AwsJsonReader reader) throws IOException {
+
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            List<String> values = new LinkedList<String>();
+            if (reader.isContainer()) {
+                reader.beginArray();
+                while (reader.hasNext()) {
+                    values.add(reader.nextString());
+                }
+                reader.endArray();
+            } else {
+                values.add(reader.nextString());
+            }
+            conditions.add(new Condition().withType(conditionType).withConditionKey(name)
+                    .withValues(values));
+        }
+        reader.endObject();
+    }
+
+    /**
+     * An auxiliary class to help instantiate the action object.
+     */
+    private static class NamedAction implements Action {
+
+        private final String actionName;
+
+        public NamedAction(String actionName) {
+            this.actionName = actionName;
+        }
+
+        @Override
+        public String getActionName() {
+            return actionName;
+        }
+
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyWriter.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyWriter.java
new file mode 100644
index 0000000000..f189f90de1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/internal/JsonPolicyWriter.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.auth.policy.internal;
+
+import com.amazonaws.auth.policy.Action;
+import com.amazonaws.auth.policy.Condition;
+import com.amazonaws.auth.policy.Policy;
+import com.amazonaws.auth.policy.Principal;
+import com.amazonaws.auth.policy.Resource;
+import com.amazonaws.auth.policy.Statement;
+import com.amazonaws.util.json.AwsJsonWriter;
+import com.amazonaws.util.json.JsonUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Serializes an AWS policy object to a JSON string, suitable for sending to an
+ * AWS service.
+ */
+public class JsonPolicyWriter {
+
+    /** The JSON Generator to generator a JSON string. */
+    private AwsJsonWriter jsonWriter = null;
+
+    /** The output writer to which the JSON String is written. */
+    private final Writer writer;
+
+    /** Logger used to log exceptions that occurs while writing the JSON policy. */
+    private static final Log log = LogFactory.getLog("com.amazonaws.auth.policy");
+
+    /**
+     * Constructs a new instance of JSONPolicyWriter.
+     */
+    public JsonPolicyWriter() {
+        writer = new StringWriter();
+        jsonWriter = JsonUtils.getJsonWriter(writer);
+    }
+
+    /**
+     * Converts the specified AWS policy object to a JSON string, suitable for
+     * passing to an AWS service.
+     *
+     * @param policy The AWS policy object to convert to a JSON string.
+     * @return The JSON string representation of the specified policy object.
+     * @throws IllegalArgumentException If the specified policy is null or
+     *             invalid and cannot be serialized to a JSON string.
+     */
+    public String writePolicyToString(Policy policy) {
+
+        if (!isNotNull(policy))
+            throw new IllegalArgumentException("Policy cannot be null");
+
+        try {
+            return jsonStringOf(policy);
+        } catch (Exception e) {
+            String message = "Unable to serialize policy to JSON string: "
+                    + e.getMessage();
+            throw new IllegalArgumentException(message, e);
+        } finally {
+            try {
+                writer.close();
+            } catch (Exception e) {
+            }
+        }
+    }
+
+    /**
+     * Converts the given <code>Policy</code> into a JSON String.
+     *
+     * @param policy the policy to be converted.
+     * @return a JSON String of the specified policy object.
+     */
+    private String jsonStringOf(Policy policy) throws IOException {
+        jsonWriter.beginObject();
+
+        writeJsonKeyValue(JsonDocumentFields.VERSION, policy.getVersion());
+
+        if (isNotNull(policy.getId()))
+            writeJsonKeyValue(JsonDocumentFields.POLICY_ID, policy.getId());
+
+        writeJsonArrayStart(JsonDocumentFields.STATEMENT);
+
+        for (Statement statement : policy.getStatements()) {
+            jsonWriter.beginObject();
+
+            if (isNotNull(statement.getId())) {
+                writeJsonKeyValue(JsonDocumentFields.STATEMENT_ID, statement.getId());
+            }
+            writeJsonKeyValue(JsonDocumentFields.STATEMENT_EFFECT, statement
+                    .getEffect().toString());
+
+            List<Principal> principals = statement.getPrincipals();
+            if (isNotNull(principals) && !principals.isEmpty())
+                writePrincipals(principals);
+
+            List<Action> actions = statement.getActions();
+            if (isNotNull(actions) && !actions.isEmpty())
+                writeActions(actions);
+
+            List<Resource> resources = statement.getResources();
+            if (isNotNull(resources) && !resources.isEmpty())
+                writeResources(resources);
+
+            List<Condition> conditions = statement.getConditions();
+            if (isNotNull(conditions) && !conditions.isEmpty())
+                writeConditions(conditions);
+
+            jsonWriter.endObject();
+        }
+
+        writeJsonArrayEnd();
+
+        jsonWriter.endObject();
+
+        jsonWriter.flush();
+
+        return writer.toString();
+
+    }
+
+    /**
+     * Writes the list of conditions to the JSONGenerator.
+     *
+     * @param conditions the conditions to be written.
+     */
+    private void writeConditions(List<Condition> conditions) throws IOException {
+        Map<String, ConditionsByKey> conditionsByType = groupConditionsByTypeAndKey(conditions);
+
+        writeJsonObjectStart(JsonDocumentFields.CONDITION);
+
+        ConditionsByKey conditionsByKey;
+        for (Map.Entry<String, ConditionsByKey> entry : conditionsByType
+                .entrySet()) {
+            conditionsByKey = conditionsByType.get(entry.getKey());
+
+            writeJsonObjectStart(entry.getKey());
+            for (String key : conditionsByKey.keySet()) {
+                writeJsonArray(key, conditionsByKey.getConditionsByKey(key));
+            }
+            writeJsonObjectEnd();
+        }
+        writeJsonObjectEnd();
+    }
+
+    /**
+     * Writes the list of <code>Resource</code>s to the JSONGenerator.
+     *
+     * @param resources the list of resources to be written.
+     */
+    private void writeResources(List<Resource> resources)
+            throws IOException {
+
+        List<String> resourceStrings = new ArrayList<String>();
+
+        for (Resource resource : resources) {
+            resourceStrings.add(resource.getId());
+        }
+        writeJsonArray(JsonDocumentFields.RESOURCE, resourceStrings);
+    }
+
+    /**
+     * Writes the list of <code>Action</code>s to the JSONGenerator.
+     *
+     * @param actions the list of the actions to be written.
+     */
+    private void writeActions(List<Action> actions)
+            throws IOException {
+        List<String> actionStrings = new ArrayList<String>();
+
+        for (Action action : actions) {
+            actionStrings.add(action.getActionName());
+        }
+        writeJsonArray(JsonDocumentFields.ACTION, actionStrings);
+    }
+
+    /**
+     * Writes the list of <code>Principal</code>s to the JSONGenerator.
+     *
+     * @param principals the list of principals to be written.
+     */
+    private void writePrincipals(List<Principal> principals)
+            throws IOException {
+        if (principals.size() == 1 && principals.get(0).equals(Principal.All)) {
+            writeJsonKeyValue(JsonDocumentFields.PRINCIPAL, Principal.All.getId());
+        } else {
+            writeJsonObjectStart(JsonDocumentFields.PRINCIPAL);
+
+            Map<String, List<String>> principalsByScheme = groupPrincipalByScheme(principals);
+
+            List<String> principalValues;
+            for (Map.Entry<String, List<String>> entry : principalsByScheme.entrySet()) {
+                principalValues = principalsByScheme.get(entry.getKey());
+
+                if (principalValues.size() == 1) {
+                    writeJsonKeyValue(entry.getKey(), principalValues.get(0));
+                } else {
+                    writeJsonArray(entry.getKey(), principalValues);
+                }
+
+            }
+            writeJsonObjectEnd();
+        }
+    }
+
+    /**
+     * Groups the list of <code>Principal</code>s by the Scheme.
+     *
+     * @param principals the list of <code>Principal</code>s
+     * @return a map grouped by scheme of the principal.
+     */
+    private Map<String, List<String>> groupPrincipalByScheme(
+            List<Principal> principals) {
+        Map<String, List<String>> principalsByScheme = new HashMap<String, List<String>>();
+
+        String provider;
+        List<String> principalValues;
+        for (Principal principal : principals) {
+            provider = principal.getProvider();
+            if (!principalsByScheme.containsKey(provider)) {
+                principalsByScheme.put(provider, new ArrayList<String>());
+            }
+            principalValues = principalsByScheme.get(provider);
+            principalValues.add(principal.getId());
+        }
+
+        return principalsByScheme;
+    }
+
+    /**
+     * Inner class to hold condition values for each key under a condition type.
+     */
+    static class ConditionsByKey {
+        private Map<String, List<String>> conditionsByKey;
+
+        public ConditionsByKey() {
+            conditionsByKey = new HashMap<String, List<String>>();
+        }
+
+        public Map<String, List<String>> getConditionsByKey() {
+            return conditionsByKey;
+        }
+
+        public void setConditionsByKey(Map<String, List<String>> conditionsByKey) {
+            this.conditionsByKey = conditionsByKey;
+        }
+
+        public boolean containsKey(String key) {
+            return conditionsByKey.containsKey(key);
+        }
+
+        public List<String> getConditionsByKey(String key) {
+            return conditionsByKey.get(key);
+        }
+
+        public Set<String> keySet() {
+            return conditionsByKey.keySet();
+        }
+
+        public void addValuesToKey(String key, List<String> values) {
+
+            List<String> conditionValues = getConditionsByKey(key);
+            if (conditionValues == null)
+                conditionsByKey.put(key, new ArrayList<String>(values));
+            else
+                conditionValues.addAll(values);
+        }
+    }
+
+    /**
+     * Groups the list of <code>Condition</code>s by the condition type and
+     * condition key.
+     *
+     * @param conditions the list of conditions to be grouped
+     * @return a map of conditions grouped by type and then key.
+     */
+    private Map<String, ConditionsByKey> groupConditionsByTypeAndKey(
+            List<Condition> conditions) {
+        Map<String, ConditionsByKey> conditionsByType = new HashMap<String, ConditionsByKey>();
+
+        String type;
+        String key;
+        ConditionsByKey conditionsByKey;
+        for (Condition condition : conditions) {
+            type = condition.getType();
+            key = condition.getConditionKey();
+
+            if (!(conditionsByType.containsKey(type))) {
+                conditionsByType.put(type, new ConditionsByKey());
+            }
+
+            conditionsByKey = conditionsByType.get(type);
+            conditionsByKey.addValuesToKey(key, condition.getValues());
+        }
+        return conditionsByType;
+    }
+
+    /**
+     * Writes an array along with its values to the JSONGenerator.
+     *
+     * @param arrayName name of the JSON array.
+     * @param values values of the JSON array.
+     */
+    private void writeJsonArray(String arrayName, List<String> values)
+            throws IOException {
+        writeJsonArrayStart(arrayName);
+        for (String value : values)
+            jsonWriter.value(value);
+        writeJsonArrayEnd();
+    }
+
+    /**
+     * Writes the Start of Object String to the JSONGenerator along with Object
+     * Name.
+     *
+     * @param fieldName name of the JSON Object.
+     */
+    private void writeJsonObjectStart(String fieldName)
+            throws IOException {
+        jsonWriter.name(fieldName);
+        jsonWriter.beginObject();
+    }
+
+    /**
+     * Writes the End of Object String to the JSONGenerator.
+     */
+    private void writeJsonObjectEnd() throws IOException {
+        jsonWriter.endObject();
+    }
+
+    /**
+     * Writes the Start of Array String to the JSONGenerator along with Array
+     * Name.
+     *
+     * @param fieldName name of the JSON array
+     */
+    private void writeJsonArrayStart(String fieldName)
+            throws IOException {
+        jsonWriter.name(fieldName);
+        jsonWriter.beginArray();
+    }
+
+    /**
+     * Writes the End of Array String to the JSONGenerator.
+     */
+    private void writeJsonArrayEnd() throws IOException {
+        jsonWriter.endArray();
+    }
+
+    /**
+     * Writes the given field and the value to the JsonGenerator
+     *
+     * @param fieldName the JSON field name
+     * @param value value for the field
+     */
+    private void writeJsonKeyValue(String fieldName, String value)
+            throws IOException {
+        jsonWriter.name(fieldName);
+        jsonWriter.value(value);
+    }
+
+    /**
+     * Checks if the given object is not null.
+     *
+     * @param object the object compared to null.
+     * @return true if the object is not null else false
+     */
+    private boolean isNotNull(Object object) {
+        return null != object;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/package-info.java
new file mode 100644
index 0000000000..e5078e7e50
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/package-info.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * Classes for creating custom AWS access control policies.  Policies allow you to specify fine grained
+ * access controls on your AWS resources.  You can allow or deny access to your AWS resources based on:
+ * <ul>
+ *   <li>what <b>resource</b> is being accessed
+ *   <li>who is accessing the resource (i.e. the <b>principal</b>)
+ *   <li>what <b>action</b> is being taken on the resource
+ *   <li>a variety of <b>conditions</b> including date restrictions, IP address restrictions, etc.
+ * </ul>
+ *
+ * <p>
+ * Access control policies are a collection of statements.
+ * Each statement takes the form:  "A has permission to do B to C where D applies".
+ * <ul>
+ *   <li>A is the <b>principal</b> - the AWS account that is making a request to
+ *       access or modify one of your AWS resources.
+ *   <li>B is the <b>action</b> - the way in which your AWS resource is being accessed or modified, such
+ *       as sending a message to an Amazon SQS queue, or storing an object in an Amazon S3 bucket.
+ *   <li>C is the <b>resource</b> - your AWS entity that the principal wants to access, such
+ *       as an Amazon SQS queue, or an object stored in Amazon S3.
+ *   <li>D is the set of <b>conditions</b> - optional constraints that specify when to allow or deny
+ *       access for the principal to access your resource.  Many expressive conditions are available,
+ *       some specific to each service.  For example you can use date conditions to allow access to
+ *       your resources only after or before a specific time.
+ * </ul>
+ *
+ * <p>
+ * The following code creates a policy to allow a specific AWS account to send
+ * and receive messages using one of your Amazon SQS queues:
+ * <pre class="brush: java">
+ *    Policy policy = new Policy("MyQueuePolicy");
+ *    policy.withStatements(new Statement(Effect.Allow)
+ *           .withPrincipals(new Principal("123456789012"))
+ *           .withActions(SQSActions.SendMessage, SQSActions.ReceiveMessage)
+ *           .withResources(new SQSQueueResource("987654321000", "queue2")));
+ * </pre>
+ *
+ * <p>
+ * Once you've created a policy, you need to use methods on the service to upload your policy to AWS.
+ */
+
+package com.amazonaws.auth.policy;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/resources/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/resources/package-info.java
new file mode 100644
index 0000000000..84b9032ad9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/auth/policy/resources/package-info.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * Collection of resources for AWS access control policies.  Resources describe
+ * what AWS entities are being accessed or modified when an AWS access control policy
+ * is evaluated for an incoming request.  Amazon SQS queues, Amazon SNS topics, and
+ * Amazon S3 buckets and objects are all examples of AWS resources.
+ */
+
+package com.amazonaws.auth.policy.resources;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressEvent.java b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressEvent.java
new file mode 100644
index 0000000000..84ff7cee4d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressEvent.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+/**
+ * Notification of a progress change on a transfer. Typically this means notice
+ * that another chunk of bytes was transferred, but it also signals other types
+ * of progress events such as a transfer starting, or failing.
+ * <p>
+ * This class could be used for both Amazon S3 and Amazon Glacier clients. The
+ * legacy Amazon S3 progress event com.amazonaws.services.s3.model.ProgressEvent
+ * has been deprecated in favor of this new class.
+ * </p>
+ */
+public class ProgressEvent {
+
+    /** Event code for preparing. */
+    public static final int PREPARING_EVENT_CODE = 1;
+
+    /** Event code for started. */
+    public static final int STARTED_EVENT_CODE = 2;
+
+    /** Event code for completed. */
+    public static final int COMPLETED_EVENT_CODE = 4;
+
+    /** Event code for failed. */
+    public static final int FAILED_EVENT_CODE = 8;
+
+    /** Event code for canceled. */
+    public static final int CANCELED_EVENT_CODE = 16;
+
+    /** Event code for reset. */
+    public static final int RESET_EVENT_CODE = 32;
+
+    // Multipart event codes
+    /** Event code for multipart started. */
+    public static final int PART_STARTED_EVENT_CODE = 1024;
+
+    /** Event code for  multipart completed. */
+    public static final int PART_COMPLETED_EVENT_CODE = 2048;
+
+    /** Event code for multipart failed. */
+    public static final int PART_FAILED_EVENT_CODE = 4096;
+
+    /** The number of bytes transferred since the last progress event. */
+    protected long bytesTransferred;
+
+    /**
+     * The unique event code identifying the type of event this object
+     * represents.
+     */
+    protected int eventCode;
+
+    /**
+     * Constructor.
+     * @param bytesTransferred the bytes transferred.
+     */
+    public ProgressEvent(long bytesTransferred) {
+        this.bytesTransferred = bytesTransferred;
+    }
+
+    /**
+     * Constructor.
+     * @param eventCode the event code.
+     * @param bytesTransferred the bytes transferred.
+     */
+    public ProgressEvent(int eventCode, long bytesTransferred) {
+        this.eventCode = eventCode;
+        this.bytesTransferred = bytesTransferred;
+    }
+
+    /**
+     * Sets the number of bytes transferred since the last progress event.
+     *
+     * @param bytesTransferred The number of bytes transferred since the last
+     *            progress event.
+     */
+    public void setBytesTransferred(long bytesTransferred) {
+        this.bytesTransferred = bytesTransferred;
+    }
+
+    /**
+     * Returns the number of bytes transferred since the last progress event.
+     *
+     * @return The number of bytes transferred since the last progress event.
+     */
+    public long getBytesTransferred() {
+        return bytesTransferred;
+    }
+
+    /**
+     * Returns the unique event code identifying the type of event this object
+     * represents.
+     *
+     * @return The unique event code that identifies what type of specific type
+     *         of event this object represents.
+     */
+    public int getEventCode() {
+        return eventCode;
+    }
+
+    /**
+     * Sets the unique event code identifying the type of event this object
+     * represents.
+     *
+     * @param eventType The unique event code that identifies what type of
+     *            specific type of event this object represents.
+     */
+    public void setEventCode(int eventType) {
+        this.eventCode = eventType;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListener.java b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListener.java
new file mode 100644
index 0000000000..d83395d6c8
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListener.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+/**
+ * Listener interface for transfer progress events.
+ * <p>
+ * This class could be used for both Amazon S3 and Amazon Glacier clients. The
+ * legacy Amazon S3 progress listener
+ * com.amazonaws.services.s3.model.ProgressListener has been deprecated in favor
+ * of this new class.
+ * </p>
+ *
+ * @see ProgressEvent
+ */
+public interface ProgressListener {
+
+    /**
+     * Called when progress has changed, such as additional bytes transferred,
+     * transfer failed, etc. The execution of the callback of this listener is
+     * managed by {@link ProgressListenerCallbackExecutor} class, which
+     * maintains a single thread to sequentially execute all progressChanged
+     * callbacks.
+     *
+     * @param progressEvent The event describing the progress change.
+     * @see ProgressListenerCallbackExecutor
+     */
+    public void progressChanged(ProgressEvent progressEvent);
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerCallbackExecutor.java b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerCallbackExecutor.java
new file mode 100644
index 0000000000..7c17b4af64
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerCallbackExecutor.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * This class wraps a ProgressListener object, and manages all its callback
+ * execution. Callbacks are executed sequentially in a separate single thread.
+ */
+public class ProgressListenerCallbackExecutor {
+
+    /** The wrapped ProgressListener **/
+    private final ProgressListener listener;
+
+    /** A single thread pool for executing all ProgressListener callbacks. **/
+    static ExecutorService executor = createNewExecutorService();
+
+    /**
+     * Used to submit a task to publish a progress event to the given listener.
+     *
+     * @param listener the progress listener.
+     * @param progressEvent the process event.
+     * @return the future of the submitted task; or null if there is no
+     *         listener.
+     */
+    public static Future<?> progressChanged(final ProgressListener listener,
+            final ProgressEvent progressEvent) {
+        if (listener == null)
+            return null;
+        return executor.submit(new Runnable() {
+            @Override
+            public void run() {
+                listener.progressChanged(progressEvent);
+            }
+        });
+    }
+
+    // ///////////////////////
+
+    /**
+     * Constructor.
+     * @param listener the progress listener.
+     */
+    public ProgressListenerCallbackExecutor(ProgressListener listener) {
+        this.listener = listener;
+    }
+
+    /**
+     * Constructor.
+     */
+    public ProgressListenerCallbackExecutor() {
+        this.listener = null;
+    }
+
+    /**
+     * @param progressEvent the progress event.
+     */
+    public void progressChanged(final ProgressEvent progressEvent) {
+        if (listener == null)
+            return;
+        executor.submit(new Runnable() {
+            @Override
+            public void run() {
+                listener.progressChanged(progressEvent);
+            }
+        });
+    }
+
+    /**
+     * @return the listener associated with the callback executor.
+     */
+    protected ProgressListener getListener() {
+        return listener;
+    }
+
+    /**
+     * @return the executor service used for performing the callbacks.
+     */
+    protected static ExecutorService getExecutorService() {
+        return executor;
+    }
+
+    /**
+     * @param listener the progress listener.
+     * @return a new ProgressListenerCallbackExecutor instance that wraps the
+     * specified ProgressListener if it is not null, otherwise directly returns
+     * null.
+     */
+    public static ProgressListenerCallbackExecutor wrapListener(ProgressListener listener) {
+        return listener == null ?
+                null : new ProgressListenerCallbackExecutor(listener);
+    }
+
+    /**
+     * Creates a new single threaded executor service for performing the
+     * callbacks.
+     */
+    static ExecutorService createNewExecutorService() {
+        return Executors.newSingleThreadExecutor(new ThreadFactory() {
+            @Override
+            public Thread newThread(Runnable r) {
+                Thread t = new Thread(r);
+                t.setName("android-sdk-progress-listener-callback-thread");
+                t.setDaemon(true);
+                return t;
+            }
+        });
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerChain.java b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerChain.java
new file mode 100644
index 0000000000..63f12f80a7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressListenerChain.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * An implementation of ProgressListener interface that delegates
+ * progressChanged callback to multiple listeners. It also takes an optional
+ * ProgressEventFilter to filter incoming events before passing them to the
+ * listeners.
+ * <p>
+ * This class could be used for both Amazon S3 and Amazon Glacier clients. The
+ * legacy Amazon S3 progress listener chain
+ * com.amazonaws.services.s3.transfer.internal.ProgressListenerChain has been
+ * deprecated in favor of this new class.
+ * </p>
+ */
+public class ProgressListenerChain implements ProgressListener {
+    private final List<ProgressListener> listeners = new CopyOnWriteArrayList<ProgressListener>();
+    private final ProgressEventFilter progressEventFilter;
+
+    private static final Log log = LogFactory.getLog(ProgressListenerChain.class);
+
+    /**
+     * Create a listener chain that directly passes all the progress events to
+     * the specified listeners.
+     * @param listeners the progress listener.
+     */
+    public ProgressListenerChain(ProgressListener... listeners) {
+        this(null, listeners);
+    }
+
+    /**
+     * Create a listener chain with a ProgressEventFilter.
+     * @param listeners the progress listener.
+     * @param progressEventFilter the progress event filter.
+     */
+    public ProgressListenerChain(ProgressEventFilter progressEventFilter,
+            ProgressListener... listeners) {
+        if (listeners == null) {
+            throw new IllegalArgumentException(
+                    "Progress Listeners cannot be null.");
+        }
+        for (ProgressListener listener : listeners)
+            addProgressListener(listener);
+        this.progressEventFilter = progressEventFilter;
+    }
+
+    /**
+     * Adds the progress listener.
+     * @param listener the progress listener.
+     */
+    public synchronized void addProgressListener(ProgressListener listener) {
+        if (listener == null)
+            return;
+        this.listeners.add(listener);
+    }
+
+    /**
+     * Removes the progress listeners.
+     * @param listener the progress listener.
+     */
+    public synchronized void removeProgressListener(ProgressListener listener) {
+        if (listener == null)
+            return;
+        this.listeners.remove(listener);
+    }
+
+    /**
+     * @return the listeners associated with this listener chain.
+     */
+    protected List<ProgressListener> getListeners() {
+        return listeners;
+    }
+
+    @Override
+    public void progressChanged(final ProgressEvent progressEvent) {
+        ProgressEvent filteredEvent = progressEvent;
+        if (progressEventFilter != null) {
+            filteredEvent = progressEventFilter.filter(progressEvent);
+            if (filteredEvent == null)
+                return;
+        }
+
+        for (ProgressListener listener : listeners) {
+            try {
+                listener.progressChanged(filteredEvent);
+            } catch (RuntimeException e) {
+                log.warn("Couldn't update progress listener", e);
+            }
+        }
+    }
+
+    /**
+     * An interface that filters the incoming events before passing them into
+     * the registered listeners.
+     */
+    public static interface ProgressEventFilter {
+
+        /**
+         * @param progressEvent the progress event.
+         * @return the filtered event object that will be actually passed into
+         * the listeners. Returns null if the event should be completely
+         * blocked.
+         */
+        public ProgressEvent filter(ProgressEvent progressEvent);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressReportingInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressReportingInputStream.java
new file mode 100644
index 0000000000..35c247869c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/event/ProgressReportingInputStream.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Simple InputStream wrapper that occasionally notifies a progress listener
+ * about the number of bytes transferred.
+ * <p>
+ * This class could be used for both Amazon S3 and Amazon Glacier clients. The
+ * legacy Amazon Amazon S3
+ * com.amazonaws.services.s3.internal.ProgressReportingInputStream has been
+ * deprecated in favor of this new class.
+ * </p>
+ */
+public class ProgressReportingInputStream extends SdkFilterInputStream {
+
+    /** Constant to represent 1KB. */
+    private static final int BYTES_IN_KB = 1024;
+
+    /** Constant to represent the Notification Threshold in KB. */
+    private static final int THRESHOLD_IN_KB = 8;
+
+    /** The threshold of bytes between notifications. */
+    private int notificationThreshold = THRESHOLD_IN_KB * BYTES_IN_KB;
+
+    /** The listener callback executor */
+    private final ProgressListenerCallbackExecutor listenerCallbackExecutor;
+
+    /**
+     * The number of bytes read that the listener hasn't been notified about
+     * yet.
+     */
+    private int unnotifiedByteCount;
+
+    /**
+     * True if this stream should fire a completed progress event when the
+     * stream runs out.
+     */
+    private boolean fireCompletedEvent;
+
+    /**
+     * Creates a new progress reporting input stream that simply wraps the
+     * specified input stream and uses the specified listener callback executor
+     * to asynchronously notify the listener about the number of bytes
+     * transferred.
+     *
+     * @param in The input stream to wrap.
+     * @param listenerCallbackExecutor The listener callback executor that wraps
+     *            the listener to notify about progress.
+     */
+    public ProgressReportingInputStream(final InputStream in,
+            final ProgressListenerCallbackExecutor listenerCallbackExecutor) {
+        super(in);
+        this.listenerCallbackExecutor = listenerCallbackExecutor;
+    }
+
+    /**
+     * Sets the number of Kbytes that need to be written before updates to the
+     * listener occur.
+     *
+     * @param threshold Number of Kbytes that needs to be written before
+     *            write update notification occurs.
+     */
+    public void setNotificationThreshold(final int threshold) {
+        this.notificationThreshold = threshold * BYTES_IN_KB;
+    }
+
+    /**
+     * Sets whether this input stream should fire an event with code
+     * {@link ProgressEvent#COMPLETED_EVENT_CODE} when this stream runs out of
+     * data. By default, completed events are not fired by this stream.
+     *
+     * @param fireCompletedEvent Whether this input stream should fire an event
+     *            to indicate that the stream has been fully read.
+     */
+    public void setFireCompletedEvent(boolean fireCompletedEvent) {
+        this.fireCompletedEvent = fireCompletedEvent;
+    }
+
+    /**
+     * Returns whether this input stream should fire an event with code
+     * {@link ProgressEvent#COMPLETED_EVENT_CODE} when this stream runs out of
+     * data. By default, completed events are not fired by this stream.
+     *
+     * @return Whether this input stream should fire an event to indicate that
+     *         the stream has been fully read.
+     */
+    public boolean getFireCompletedEvent() {
+        return fireCompletedEvent;
+    }
+
+    @Override
+    public int read() throws IOException {
+        int data = super.read();
+        if (data == -1) {
+            notifyCompleted();
+        } else {
+            notify(1);
+        }
+        return data;
+    }
+
+    @Override
+    public void reset() throws IOException {
+        super.reset();
+        ProgressEvent event = new ProgressEvent(unnotifiedByteCount);
+        event.setEventCode(ProgressEvent.RESET_EVENT_CODE);
+        listenerCallbackExecutor.progressChanged(event);
+        unnotifiedByteCount = 0;
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        int bytesRead = super.read(b, off, len);
+        if (bytesRead == -1)
+            notifyCompleted();
+        if (bytesRead != -1)
+            notify(bytesRead);
+        return bytesRead;
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (unnotifiedByteCount > 0) {
+            listenerCallbackExecutor.progressChanged(new ProgressEvent(unnotifiedByteCount));
+            unnotifiedByteCount = 0;
+        }
+        super.close();
+    }
+
+    private void notifyCompleted() {
+        if (!fireCompletedEvent)
+            return;
+
+        ProgressEvent event = new ProgressEvent(unnotifiedByteCount);
+        event.setEventCode(ProgressEvent.COMPLETED_EVENT_CODE);
+        unnotifiedByteCount = 0;
+        listenerCallbackExecutor.progressChanged(event);
+    }
+
+    private void notify(int bytesRead) {
+        unnotifiedByteCount += bytesRead;
+
+        if (unnotifiedByteCount >= this.notificationThreshold) {
+            listenerCallbackExecutor.progressChanged(new ProgressEvent(unnotifiedByteCount));
+            unnotifiedByteCount = 0;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AbstractRequestHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AbstractRequestHandler.java
new file mode 100644
index 0000000000..c8da67e71b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AbstractRequestHandler.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.util.TimingInfo;
+
+/**
+ * @deprecated by {@link RequestHandler2}.
+ *             <p>
+ *             Simple implementation of RequestHandler to stub out required
+ *             methods.
+ */
+@Deprecated
+public abstract class AbstractRequestHandler implements RequestHandler {
+    @Override
+    public void beforeRequest(Request<?> request) {
+    }
+
+    @Override
+    public void afterResponse(Request<?> request, Object response, TimingInfo timingInfo) {
+    }
+
+    @Override
+    public void afterError(Request<?> request, Exception e) {
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AsyncHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AsyncHandler.java
new file mode 100644
index 0000000000..65abe73c92
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/AsyncHandler.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ * http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * Callback interface for notification on web service requests executed with the
+ * asynchronous clients in the AWS SDK for Java.
+ * @param <REQUEST> the request type.
+ * @param <RESULT> the result type.
+ */
+public interface AsyncHandler<REQUEST extends AmazonWebServiceRequest, RESULT> {
+
+    /**
+     * Invoked after an asynchronous request
+     *
+     * @param exception the exception.
+     */
+    public void onError(Exception exception);
+
+    /**
+     * Invoked after an asynchronous request has completed successfully. Callers
+     * have access to the original request object and the returned response
+     * object.
+     *
+     * @param request The initial request created by the caller
+     * @param result The successful result of the executed operation.
+     */
+    public void onSuccess(REQUEST request, RESULT result);
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/CredentialsRequestHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/CredentialsRequestHandler.java
new file mode 100644
index 0000000000..1f77606b1c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/CredentialsRequestHandler.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.auth.AWSCredentials;
+
+/**
+ * A special type of
+ * <code>RequestHandler2</code> that takes in <code>AWSCredentials</code>.
+ */
+public abstract class CredentialsRequestHandler extends RequestHandler2 {
+
+    /** AWSCredentials to be used in the RequestHandler. */
+    protected AWSCredentials awsCredentials;
+
+    /**
+     * Sets the AWSCredentials.
+     * @param awsCredentials the AWS credentials.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setCredentials(AWSCredentials awsCredentials) {
+        this.awsCredentials = awsCredentials;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/HandlerChainFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/HandlerChainFactory.java
new file mode 100644
index 0000000000..4eb75148ef
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/HandlerChainFactory.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.util.ClassLoaderHelper;
+import com.amazonaws.util.StringUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Factory for creating request/response handler chains.
+ */
+public class HandlerChainFactory {
+
+    /**
+     * For backward compatibility, constructs a new request handler chain
+     * adapted to {@link RequestHandler2} by analyzing the specified classpath
+     * resource.
+     *
+     * @param resource The resource to load from the classpath containing the
+     *            list of request handlers to instantiate.
+     * @return A list of request handlers based on the handlers referenced in
+     *         the specified resource.
+     */
+    public List<RequestHandler2> newRequestHandlerChain(String resource) {
+        return createRequestHandlerChain(resource, RequestHandler.class);
+    }
+
+    /**
+     * Constructs a new request handler (v2) chain by analyzing the specified
+     * classpath resource.
+     *
+     * @param resource The resource to load from the classpath containing the
+     *            list of request handlers to instantiate.
+     * @return A list of request handlers based on the handlers referenced in
+     *         the specified resource.
+     */
+    public List<RequestHandler2> newRequestHandler2Chain(String resource) {
+        return createRequestHandlerChain(resource, RequestHandler2.class);
+    }
+
+    @SuppressWarnings("checkstyle:emptyblock")
+    private List<RequestHandler2> createRequestHandlerChain(String resource,
+            Class<?> handlerApiClass) {
+        List<RequestHandler2> handlers = new ArrayList<RequestHandler2>();
+        BufferedReader reader = null;
+
+        try {
+            InputStream input = getClass().getResourceAsStream(resource);
+            if (input == null)
+                return handlers;
+
+            reader = new BufferedReader(new InputStreamReader(input, StringUtils.UTF8));
+            while (true) {
+                String requestHandlerClassName = reader.readLine();
+                if (requestHandlerClassName == null)
+                    break;
+                requestHandlerClassName = requestHandlerClassName.trim();
+                if ("".equals(requestHandlerClassName))
+                    continue;
+                Class<?> requestHandlerClass = ClassLoaderHelper.loadClass(
+                        requestHandlerClassName,
+                        handlerApiClass, getClass());
+                Object requestHandlerObject = requestHandlerClass.newInstance();
+                if (handlerApiClass.isInstance(requestHandlerObject)) {
+                    if (handlerApiClass == RequestHandler2.class) {
+                        RequestHandler2 h = (RequestHandler2) requestHandlerObject;
+                        handlers.add(h);
+                    } else if (handlerApiClass == RequestHandler.class) {
+                        RequestHandler h = (RequestHandler) requestHandlerObject;
+                        handlers.add(RequestHandler2.adapt(h));
+                    } else {
+                        throw new IllegalStateException();
+                    }
+                } else {
+                    throw new AmazonClientException(
+                            "Unable to instantiate request handler chain for client.  "
+                                    + "Listed request handler ('"
+                                    + requestHandlerClassName + "') "
+                                    + "does not implement the "
+                                    + handlerApiClass + " API.");
+                }
+            }
+        } catch (Exception e) {
+            throw new AmazonClientException(
+                    "Unable to instantiate request handler chain for client: "
+                            + e.getMessage(), e);
+        } finally {
+            try {
+                if (reader != null) {
+                    reader.close();
+                }
+            } catch (IOException e) {
+            }
+        }
+        return handlers;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler.java
new file mode 100644
index 0000000000..2c6a27e94b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.util.TimingInfo;
+
+/**
+ * @deprecated by {@link RequestHandler2}. Interface for addition request
+ *             handling in clients. A request handler is executed on a request
+ *             object <b>before</b> it is sent to the client runtime to be
+ *             executed.
+ */
+@Deprecated
+public interface RequestHandler {
+
+    /**
+     * Runs any additional processing logic on the specified request (before it
+     * is executed by the client runtime).
+     *
+     * @param request The low level request being processed.
+     */
+    public void beforeRequest(Request<?> request);
+
+    /**
+     * Runs any additional processing logic on the specified request (after is
+     * has been executed by the client runtime).
+     *
+     * @param request The low level request being processed.
+     * @param response The response generated from the specified request.
+     * @param timingInfo Timing information on the request's processing.
+     */
+    public void afterResponse(Request<?> request, Object response, TimingInfo timingInfo);
+
+    /**
+     * Runs any additional processing logic on a request after it has failed.
+     *
+     * @param request The request that generated an error.
+     * @param e The error that resulted from executing the request.
+     */
+    public void afterError(Request<?> request, Exception e);
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2.java
new file mode 100644
index 0000000000..a480976b0b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.Response;
+import com.amazonaws.util.TimingInfo;
+
+/**
+ * Interface for addition request handling in clients. A request handler is
+ * executed on a request object <b>before</b> it is sent to the client runtime
+ * to be executed.
+ * <p>
+ * This interface deprecates {@link RequestHandler} by providing access to not
+ * only the AWS response, but also the associated http response via
+ * {@link Response}.
+ * <p>
+ * Note {@link TimingInfo} is accessible via
+ * {@link Request#getAWSRequestMetrics()} and hence is omitted from the
+ * interface to reduce duplication by design.
+ */
+public abstract class RequestHandler2 {
+
+    /**
+     * Runs any additional processing logic on the specified request (before it
+     * is executed by the client runtime).
+     *
+     * @param request The low level request being processed.
+     */
+    public abstract void beforeRequest(Request<?> request);
+
+    /**
+     * Runs any additional processing logic on the specified request (after is
+     * has been executed by the client runtime).
+     *
+     * @param request The low level request being processed.
+     * @param response The response generated from the specified request.
+     */
+    public abstract void afterResponse(Request<?> request, Response<?> response);
+
+    /**
+     * Runs any additional processing logic on a request after it has failed.
+     *
+     * @param request The request that generated an error.
+     * @param response the response or null if the failure occurred before the
+     *            response is made available
+     * @param e The error that resulted from executing the request.
+     */
+    public abstract void afterError(Request<?> request, Response<?> response,
+            Exception e);
+
+    /**
+     * @return an instance of request handler adapted to the
+     * {@link RequestHandler2} interface from the given request handler
+     * implementing the deprecated {@link RequestHandler} interface.
+     * @param old the request handler.
+     */
+    public static RequestHandler2 adapt(
+            @SuppressWarnings("deprecation")
+            RequestHandler old) {
+        return new RequestHandler2Adaptor(old);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2Adaptor.java b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2Adaptor.java
new file mode 100644
index 0000000000..499216a63b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/handlers/RequestHandler2Adaptor.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.Response;
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.TimingInfo;
+
+/**
+ * Internal class used to adapt a request handler that implements the deprecated
+ * {@link RequestHandler} interface to the deprecating {@link RequestHandler2}
+ * interface.
+ */
+final class RequestHandler2Adaptor extends RequestHandler2 {
+    @SuppressWarnings("deprecation")
+    private final RequestHandler old;
+
+    RequestHandler2Adaptor(@SuppressWarnings("deprecation") RequestHandler old) {
+        if (old == null)
+            throw new IllegalArgumentException();
+        this.old = old;
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void beforeRequest(Request<?> request) {
+        old.beforeRequest(request);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void afterResponse(Request<?> request, Response<?> response) {
+        AWSRequestMetrics awsRequestMetrics = request == null ? null : request
+                .getAWSRequestMetrics();
+        Object awsResponse = response == null ? null : response
+                .getAwsResponse();
+        TimingInfo timingInfo = awsRequestMetrics == null ? null
+                : awsRequestMetrics.getTimingInfo();
+        old.afterResponse(request, awsResponse, timingInfo);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void afterError(Request<?> request, Response<?> response,
+            Exception e) {
+        old.afterError(request, e);
+    }
+
+    @Override
+    public int hashCode() {
+        return old.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof RequestHandler2Adaptor))
+            return false;
+        RequestHandler2Adaptor that = (RequestHandler2Adaptor) o;
+        return this.old.equals(that.old);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/AmazonHttpClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/AmazonHttpClient.java
new file mode 100644
index 0000000000..46631f7070
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/AmazonHttpClient.java
@@ -0,0 +1,834 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.Request;
+import com.amazonaws.RequestClientOptions;
+import com.amazonaws.RequestClientOptions.Marker;
+import com.amazonaws.Response;
+import com.amazonaws.ResponseMetadata;
+import com.amazonaws.SDKGlobalConfiguration;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.Signer;
+import com.amazonaws.handlers.CredentialsRequestHandler;
+import com.amazonaws.handlers.RequestHandler2;
+import com.amazonaws.internal.CRC32MismatchException;
+import com.amazonaws.metrics.AwsSdkMetrics;
+import com.amazonaws.metrics.RequestMetricCollector;
+import com.amazonaws.retry.RetryPolicy;
+import com.amazonaws.retry.RetryUtils;
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+import com.amazonaws.util.DateUtils;
+import com.amazonaws.util.TimingInfo;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * The Amazon HTTP Client class.
+ */
+public class AmazonHttpClient {
+
+    private static final String HEADER_USER_AGENT = "User-Agent";
+    private static final String HEADER_SDK_TRANSACTION_ID = "aws-sdk-invocation-id";
+    private static final String HEADER_SDK_RETRY_INFO = "aws-sdk-retry";
+
+    private static final int HTTP_STATUS_OK = 200;
+    private static final int HTTP_STATUS_TEMP_REDIRECT = 307;
+    private static final int HTTP_STATUS_MULTIPLE_CHOICES = 300;
+    private static final int HTTP_STATUS_REQ_TOO_LONG = 413;
+    private static final int HTTP_STATUS_SERVICE_UNAVAILABLE = 503;
+
+    private static final int TIME_MILLISEC = 1000;
+
+    /**
+     * Logger providing detailed information on requests/responses. Users can
+     * enable this logger to get access to AWS request IDs for responses,
+     * individual requests and parameters sent to AWS, etc.
+     */
+    private static final Log REQUEST_LOG = LogFactory.getLog("com.amazonaws.request");
+
+    /**
+     * Logger for more detailed debugging information, that might not be as
+     * useful for end users (ex: HTTP client configuration, etc).
+     */
+    static final Log log = LogFactory.getLog(AmazonHttpClient.class);
+
+    /** Internal client for sending HTTP requests */
+    final HttpClient httpClient;
+
+    /** Client configuration options, such as proxy settings, max retries, etc. */
+    final ClientConfiguration config;
+
+    /**
+     * A request metric collector used specifically for this http client; or
+     * null if there is none. This collector, if specified, always takes
+     * precedence over the one specified at the AWS SDK level.
+     *
+     * @see AwsSdkMetrics
+     */
+    private final RequestMetricCollector requestMetricCollector;
+
+    private final HttpRequestFactory requestFactory = new HttpRequestFactory();
+
+    /**
+     * Constructs a new AWS client using the specified client configuration
+     * options (ex: max retry attempts, proxy settings, etc).
+     *
+     * @param config Configuration options specifying how this client will
+     *            communicate with AWS (ex: proxy settings, retry count, etc.).
+     */
+    public AmazonHttpClient(ClientConfiguration config) {
+        this(config, new UrlHttpClient(config));
+    }
+
+    /**
+     * Constructs a new AWS client using the specified client configuration
+     * options (ex: max retry attempts, proxy settings, etc), and request metric
+     * collector.
+     *
+     * @param config Configuration options specifying how this client will
+     *            communicate with AWS (ex: proxy settings, retry count, etc.).
+     * @param requestMetricCollector client specific request metric collector,
+     *            which takes precedence over the one at the AWS SDK level; or
+     *            null if there is none.
+     */
+    @Deprecated
+    public AmazonHttpClient(ClientConfiguration config,
+            RequestMetricCollector requestMetricCollector) {
+        this(config, new UrlHttpClient(config), requestMetricCollector);
+    }
+
+    /**
+     * Constructs a new AWS client using the specified client configuration
+     * options (ex: max retry attempts, proxy settings, etc), and request metric
+     * collector.
+     *
+     * @param config Configuration options specifying how this client will
+     *            communicate with AWS (ex: proxy settings, retry count, etc.).
+     * @param httpClient client specific HttpClient
+     */
+    public AmazonHttpClient(ClientConfiguration config, HttpClient httpClient) {
+        this.config = config;
+        this.httpClient = httpClient;
+        this.requestMetricCollector = null;
+    }
+
+    /**
+     * Constructs a new AWS client using the specified client configuration
+     * options (ex: max retry attempts, proxy settings, etc), and request metric
+     * collector.
+     *
+     * @param config Configuration options specifying how this client will
+     *            communicate with AWS (ex: proxy settings, retry count, etc.).
+     * @param httpClient client specific HttpClient
+     * @param requestMetricCollector client specific request metric collector,
+     *            which takes precedence over the one at the AWS SDK level; or
+     *            null if there is none.
+     */
+    @Deprecated
+    public AmazonHttpClient(ClientConfiguration config, HttpClient httpClient,
+            RequestMetricCollector requestMetricCollector) {
+        this.config = config;
+        this.httpClient = httpClient;
+        this.requestMetricCollector = requestMetricCollector;
+    }
+
+    /**
+     * Returns additional response metadata for an executed request. Response
+     * metadata isn't considered part of the standard results returned by an
+     * operation, so it's accessed instead through this diagnostic interface.
+     * Response metadata is typically used for troubleshooting issues with AWS
+     * support staff when services aren't acting as expected.
+     *
+     * @param request A previously executed AmazonWebServiceRequest object,
+     *            whose response metadata is desired.
+     * @return The response metadata for the specified request, otherwise null
+     *         if there is no response metadata available for the request.
+     * @deprecated ResponseMetadata cache can hold up to 50 requests and
+     *             responses in memory and will cause memory issue. This method
+     *             now always returns null.
+     */
+    @Deprecated
+    public ResponseMetadata getResponseMetadataForRequest(AmazonWebServiceRequest request) {
+        return null;
+    }
+
+    /**
+     * Executes the request and returns the result.
+     *
+     * @param request The AmazonWebServices request to send to the remote server
+     * @param responseHandler A response handler to accept a successful response
+     *            from the remote server
+     * @param errorResponseHandler A response handler to accept an unsuccessful
+     *            response from the remote server
+     * @param executionContext Additional information about the context of this
+     *            web service call
+     * @param <T> the response type.
+     * @return the result of the request.
+     */
+    public <T> Response<T> execute(Request<?> request,
+            HttpResponseHandler<AmazonWebServiceResponse<T>> responseHandler,
+            HttpResponseHandler<AmazonServiceException> errorResponseHandler,
+            ExecutionContext executionContext) {
+        if (executionContext == null) {
+            throw new AmazonClientException(
+                    "Internal SDK Error: No execution context parameter specified.");
+        }
+        final List<RequestHandler2> requestHandler2s = requestHandler2s(request, executionContext);
+        final AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        Response<T> response = null;
+        try {
+            response = executeHelper(request, responseHandler, errorResponseHandler,
+                    executionContext);
+            final TimingInfo timingInfo = awsRequestMetrics.getTimingInfo().endTiming();
+            afterResponse(request, requestHandler2s, response, timingInfo);
+            return response;
+        } catch (final AmazonClientException e) {
+            afterError(request, response, requestHandler2s, e);
+            throw e;
+        }
+    }
+
+    void afterError(Request<?> request, Response<?> response,
+            List<RequestHandler2> requestHandler2s, AmazonClientException e) {
+        for (final RequestHandler2 handler2 : requestHandler2s) {
+            handler2.afterError(request, response, e);
+        }
+    }
+
+    <T> void afterResponse(Request<?> request,
+            List<RequestHandler2> requestHandler2s,
+            Response<T> response,
+            TimingInfo timingInfo) {
+        for (final RequestHandler2 handler2 : requestHandler2s) {
+            handler2.afterResponse(request, response);
+        }
+    }
+
+    List<RequestHandler2> requestHandler2s(Request<?> request,
+            ExecutionContext executionContext) {
+        final List<RequestHandler2> requestHandler2s = executionContext
+                .getRequestHandler2s();
+        if (requestHandler2s == null) {
+            return Collections.emptyList();
+        }
+        // Apply any additional service specific request handlers that need
+        // to be run
+        for (final RequestHandler2 requestHandler2 : requestHandler2s) {
+            // If the request handler is a type of CredentialsRequestHandler,
+            // then set the credentials in the request handler.
+            if (requestHandler2 instanceof CredentialsRequestHandler) {
+                ((CredentialsRequestHandler) requestHandler2)
+                        .setCredentials(executionContext.getCredentials());
+            }
+            requestHandler2.beforeRequest(request);
+        }
+        return requestHandler2s;
+    }
+
+    /**
+     * Internal method to execute the HTTP method given.
+     *
+     * @see AmazonHttpClient#execute(Request, HttpResponseHandler,
+     *      HttpResponseHandler)
+     * @see AmazonHttpClient#execute(Request, HttpResponseHandler,
+     *      HttpResponseHandler, ExecutionContext)
+     */
+    @SuppressWarnings("checkstyle:methodlength")
+    <T> Response<T> executeHelper(Request<?> request,
+            HttpResponseHandler<AmazonWebServiceResponse<T>> responseHandler,
+            HttpResponseHandler<AmazonServiceException> errorResponseHandler,
+            ExecutionContext executionContext) {
+        /*
+         * Depending on which response handler we end up choosing to handle the
+         * HTTP response, it might require us to leave the underlying HTTP
+         * connection open, depending on whether or not it reads the complete
+         * HTTP response stream from the HTTP connection, or if delays reading
+         * any of the content until after a response is returned to the caller.
+         */
+        boolean leaveHttpConnectionOpen = false;
+        final AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        /*
+         * add the service endpoint to the logs. You can infer service name from
+         * service endpoint
+         */
+        awsRequestMetrics.addProperty(Field.ServiceName, request.getServiceName());
+        awsRequestMetrics.addProperty(Field.ServiceEndpoint, request.getEndpoint());
+
+        // Apply whatever request options we know how to handle, such as
+        // user-agent.
+        setUserAgent(request);
+        request.addHeader(HEADER_SDK_TRANSACTION_ID, UUID.randomUUID().toString());
+        int requestCount = 0;
+        long lastBackoffDelay = 0;
+        URI redirectedURI = null;
+        AmazonClientException retriedException = null;
+
+        // Make a copy of the original request params and headers so that we can
+        // permute it in this loop and start over with the original every time.
+        final Map<String, String> originalParameters = new LinkedHashMap<String, String>(
+                request.getParameters());
+        final Map<String, String> originalHeaders = new HashMap<String, String>(request.getHeaders());
+        // mark input stream if supported
+        final InputStream originalContent = request.getContent();
+        if (originalContent != null && originalContent.markSupported()) {
+            originalContent.mark(-1);
+        }
+
+        final AWSCredentials credentials = executionContext.getCredentials();
+        Signer signer = null;
+        HttpResponse httpResponse = null;
+        HttpRequest httpRequest = null;
+
+        while (true) {
+            ++requestCount;
+            awsRequestMetrics.setCounter(Field.RequestCount, requestCount);
+            if (requestCount > 1) { // retry
+                request.setParameters(originalParameters);
+                request.setHeaders(originalHeaders);
+                request.setContent(originalContent);
+            }
+            if (redirectedURI != null && request.getEndpoint() == null
+                    && request.getResourcePath() == null) {
+                request.setEndpoint(URI.create(
+                        redirectedURI.getScheme() + "://" + redirectedURI.getAuthority()));
+                request.setResourcePath(redirectedURI.getPath());
+            }
+
+            try {
+                if (requestCount > 1) { // retry
+                    awsRequestMetrics.startEvent(Field.RetryPauseTime);
+                    try {
+                        lastBackoffDelay = pauseBeforeNextRetry(request.getOriginalRequest(),
+                                retriedException,
+                                requestCount,
+                                config.getRetryPolicy());
+                    } finally {
+                        awsRequestMetrics.endEvent(Field.RetryPauseTime);
+                    }
+                    final InputStream content = request.getContent();
+                    if (content != null && content.markSupported()) {
+                        content.reset();
+                    }
+                }
+                request.addHeader(HEADER_SDK_RETRY_INFO,
+                        (requestCount - 1) + "/" + lastBackoffDelay);
+
+                // Sign the request if a signer was provided
+                if (signer == null) {
+                    signer = executionContext.getSignerByURI(request.getEndpoint());
+                }
+                if (signer != null && credentials != null) {
+                    awsRequestMetrics.startEvent(Field.RequestSigningTime);
+                    try {
+                        signer.sign(request, credentials);
+                    } finally {
+                        awsRequestMetrics.endEvent(Field.RequestSigningTime);
+                    }
+                }
+
+                if (REQUEST_LOG.isDebugEnabled()) {
+                    REQUEST_LOG.debug("Sending Request: " + request.toString());
+                }
+
+                httpRequest = requestFactory.createHttpRequest(request, config,
+                        executionContext);
+
+                retriedException = null;
+                awsRequestMetrics.startEvent(Field.HttpRequestTime);
+                try {
+                    httpResponse = httpClient.execute(httpRequest);
+                } finally {
+                    awsRequestMetrics.endEvent(Field.HttpRequestTime);
+                }
+
+                if (isRequestSuccessful(httpResponse)) {
+                    awsRequestMetrics.addProperty(Field.StatusCode, httpResponse.getStatusCode());
+                    /*
+                     * If we get back any 2xx status code, then we know we
+                     * should treat the service call as successful.
+                     */
+                    leaveHttpConnectionOpen = responseHandler.needsConnectionLeftOpen();
+                    final T response = handleResponse(request, responseHandler,
+                            httpResponse,
+                            executionContext);
+                    return new Response<T>(response, httpResponse);
+                } else if (isTemporaryRedirect(httpResponse)) {
+                    /*
+                     * S3 sends 307 Temporary Redirects if you try to delete an
+                     * EU bucket from the US endpoint. If we get a 307, we'll
+                     * point the HTTP method to the redirected location, and let
+                     * the next retry deliver the request to the right location.
+                     */
+                    final String redirectedLocation = httpResponse.getHeaders().get("Location");
+                    log.debug("Redirecting to: " + redirectedLocation);
+                    // set redirect uri and retry
+                    redirectedURI = URI.create(redirectedLocation);
+                    request.setEndpoint(null);
+                    request.setResourcePath(null);
+                    awsRequestMetrics.addProperty(Field.StatusCode, httpResponse.getStatusCode());
+                    awsRequestMetrics.addProperty(Field.RedirectLocation, redirectedLocation);
+                    awsRequestMetrics.addProperty(Field.AWSRequestID, null);
+                } else {
+                    leaveHttpConnectionOpen = errorResponseHandler.needsConnectionLeftOpen();
+                    final AmazonServiceException ase = handleErrorResponse(request, errorResponseHandler,
+                            httpResponse);
+                    awsRequestMetrics.addProperty(Field.AWSRequestID, ase.getRequestId());
+                    awsRequestMetrics.addProperty(Field.AWSErrorCode, ase.getErrorCode());
+                    awsRequestMetrics.addProperty(Field.StatusCode, ase.getStatusCode());
+
+                    if (!shouldRetry(request.getOriginalRequest(),
+                            httpRequest.getContent(),
+                            ase,
+                            requestCount,
+                            config.getRetryPolicy())) {
+                        throw ase;
+                    }
+
+                    // Cache the retryable exception
+                    retriedException = ase;
+                    /*
+                     * Checking for clock skew error again because we don't want
+                     * to set the global time offset for every service
+                     * exception.
+                     */
+                    if (RetryUtils.isClockSkewError(ase)) {
+                        final int timeOffset = parseClockSkewOffset(httpResponse, ase);
+                        SDKGlobalConfiguration.setGlobalTimeOffset(timeOffset);
+                    }
+                    resetRequestAfterError(request, ase);
+                }
+            } catch (final IOException ioe) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unable to execute HTTP request: " + ioe.getMessage(), ioe);
+                }
+                awsRequestMetrics.incrementCounter(Field.Exception);
+                awsRequestMetrics.addProperty(Field.Exception, ioe);
+                awsRequestMetrics.addProperty(Field.AWSRequestID, null);
+
+                final AmazonClientException ace = new AmazonClientException(
+                        "Unable to execute HTTP request: " + ioe.getMessage(), ioe);
+                if (!shouldRetry(request.getOriginalRequest(),
+                        httpRequest.getContent(),
+                        ace,
+                        requestCount,
+                        config.getRetryPolicy())) {
+                    throw ace;
+                }
+
+                // Cache the retryable exception
+                retriedException = ace;
+                resetRequestAfterError(request, ioe);
+            } catch (final RuntimeException e) {
+                throw handleUnexpectedFailure(e, awsRequestMetrics);
+            } catch (final Error e) {
+                throw handleUnexpectedFailure(e, awsRequestMetrics);
+            } finally {
+                /*
+                 * Some response handlers need to manually manage the HTTP
+                 * connection and will take care of releasing the connection on
+                 * their own, but if this response handler doesn't need the
+                 * connection left open, we go ahead and release the it to free
+                 * up resources.
+                 */
+                if (!leaveHttpConnectionOpen && httpResponse != null) {
+                    try {
+                        if (httpResponse.getRawContent() != null) {
+                            httpResponse.getRawContent().close();
+                        }
+                    } catch (final IOException e) {
+                        log.warn("Cannot close the response content.", e);
+                    }
+                }
+            }
+        } /* end while (true) */
+    }
+
+    /**
+     * Handles an unexpected failure, returning the Throwable instance as given.
+     */
+    private <T extends Throwable> T handleUnexpectedFailure(T t, AWSRequestMetrics awsRequestMetrics) {
+        awsRequestMetrics.incrementCounter(Field.Exception);
+        awsRequestMetrics.addProperty(Field.Exception, t);
+        return t;
+    }
+
+    /**
+     * Resets the specified request, so that it can be sent again, after
+     * receiving the specified error. If a problem is encountered with resetting
+     * the request, then an AmazonClientException is thrown with the original
+     * error as the cause (not an error about being unable to reset the stream).
+     *
+     * @param request The request being executed that failed and needs to be
+     *            reset.
+     * @param cause The original error that caused the request to fail.
+     * @throws AmazonClientException If the request can't be reset.
+     */
+    void resetRequestAfterError(Request<?> request, Exception cause) {
+        if (request.getContent() == null) {
+            return; // no reset needed
+        }
+        if (!request.getContent().markSupported()) {
+            throw new AmazonClientException(
+                    "Encountered an exception and stream is not resettable", cause);
+        }
+        try {
+            request.getContent().reset();
+        } catch (final IOException e) {
+            // This exception comes from being unable to reset the input stream,
+            // so throw the original, more meaningful exception
+            throw new AmazonClientException(
+                    "Encountered an exception and couldn't reset the stream to retry", cause);
+        }
+    }
+
+    /**
+     * Sets a User-Agent for the specified request, taking into account any
+     * custom data.
+     */
+    void setUserAgent(Request<?> request) {
+        String userAgent = ClientConfiguration.DEFAULT_USER_AGENT;
+        // append request specific user agent marker
+        final AmazonWebServiceRequest awsreq = request.getOriginalRequest();
+        if (awsreq != null) {
+            final RequestClientOptions opts = awsreq.getRequestClientOptions();
+            if (opts != null) {
+                final String userAgentMarker = opts.getClientMarker(Marker.USER_AGENT);
+                if (userAgentMarker != null) {
+                    userAgent = createUserAgentString(userAgent, userAgentMarker);
+                }
+            }
+        }
+        // if custom user agent is set via ClientConfiguration, append it to the end
+        if (!ClientConfiguration.DEFAULT_USER_AGENT.equals(config.getUserAgent())) {
+            userAgent = createUserAgentString(userAgent, config.getUserAgent());
+        }
+        request.addHeader(HEADER_USER_AGENT, userAgent);
+    }
+
+    /**
+     * Appends the given user-agent string to the existing one and returns it.
+     */
+    static String createUserAgentString(String existingUserAgentString, String userAgent) {
+        if (existingUserAgentString.contains(userAgent)) {
+            return existingUserAgentString;
+        } else {
+            return existingUserAgentString.trim() + " " + userAgent.trim();
+        }
+    }
+
+    /**
+     * Shuts down this HTTP client object, releasing any resources that might be
+     * held open. This is an optional method, and callers are not expected to
+     * call it, but can if they want to explicitly release any open resources.
+     * Once a client has been shutdown, it cannot be used to make more requests.
+     */
+    public void shutdown() {
+        httpClient.shutdown();
+    }
+
+    /**
+     * Returns true if a failed request should be retried.
+     *
+     * @param originalRequest The original service request that is being
+     *            executed.
+     * @param method The current HTTP method being executed.
+     * @param exception The client/service exception from the failed request.
+     * @param requestCount The number of times the current request has been
+     *            attempted.
+     * @return True if the failed request should be retried.
+     */
+    private boolean shouldRetry(AmazonWebServiceRequest originalRequest,
+            InputStream inputStream,
+            AmazonClientException exception,
+            int requestCount,
+            RetryPolicy retryPolicy) {
+        final int retries = requestCount - 1;
+
+        int maxErrorRetry = config.getMaxErrorRetry();
+        // We should use the maxErrorRetry in
+        // the RetryPolicy if either the user has not explicitly set it in
+        // ClientConfiguration, or the RetryPolicy is configured to take
+        // higher precedence.
+        if (maxErrorRetry < 0
+                || !retryPolicy.isMaxErrorRetryInClientConfigHonored()) {
+            maxErrorRetry = retryPolicy.getMaxErrorRetry();
+        }
+
+        // Immediately fails when it has exceeds the max retry count.
+        if (retries >= maxErrorRetry) {
+            return false;
+        }
+
+        // Never retry on requests containing non-repeatable entity
+        if (inputStream != null && !inputStream.markSupported()) {
+            if (log.isDebugEnabled()) {
+                log.debug("Content not repeatable");
+            }
+            return false;
+        }
+
+        // Pass all the context information to the RetryCondition and let it
+        // decide whether it should be retried.
+        return retryPolicy.getRetryCondition().shouldRetry(originalRequest,
+                exception,
+                retries);
+    }
+
+    private static boolean isTemporaryRedirect(HttpResponse response) {
+        final int statusCode = response.getStatusCode();
+        final String location = response.getHeaders().get("Location");
+        return statusCode == HTTP_STATUS_TEMP_REDIRECT &&
+                location != null && !location.isEmpty();
+    }
+
+    private boolean isRequestSuccessful(HttpResponse response) {
+        final int statusCode = response.getStatusCode();
+        return statusCode >= HTTP_STATUS_OK && statusCode < HTTP_STATUS_MULTIPLE_CHOICES;
+    }
+
+    /**
+     * Handles a successful response from a service call by unmarshalling the
+     * results using the specified response handler.
+     *
+     * @param <T> The type of object expected in the response.
+     * @param request The original request that generated the response being
+     *            handled.
+     * @param responseHandler The response unmarshaller used to interpret the
+     *            contents of the response.
+     * @param method The HTTP method that was invoked, and contains the contents
+     *            of the response.
+     * @param executionContext Extra state information about the request
+     *            currently being executed.
+     * @return The contents of the response, unmarshalled using the specified
+     *         response handler.
+     * @throws IOException If any problems were encountered reading the response
+     *             contents from the HTTP method object.
+     */
+    <T> T handleResponse(Request<?> request,
+            HttpResponseHandler<AmazonWebServiceResponse<T>> responseHandler,
+            HttpResponse response,
+            ExecutionContext executionContext) throws IOException {
+        try {
+            final AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+            AmazonWebServiceResponse<? extends T> awsResponse;
+            awsRequestMetrics.startEvent(Field.ResponseProcessingTime);
+            try {
+                awsResponse = responseHandler.handle(response);
+            } finally {
+                awsRequestMetrics.endEvent(Field.ResponseProcessingTime);
+            }
+
+            if (awsResponse == null) {
+                throw new RuntimeException(
+                        "Unable to unmarshall response metadata. Response Code: " +
+                                response.getStatusCode() + ", Response Text: "
+                                + response.getStatusText());
+            }
+
+            if (REQUEST_LOG.isDebugEnabled()) {
+                REQUEST_LOG.debug("Received successful response: " + response.getStatusCode()
+                        + ", AWS Request ID: " + awsResponse.getRequestId());
+            }
+            awsRequestMetrics.addProperty(Field.AWSRequestID, awsResponse.getRequestId());
+
+            return awsResponse.getResult();
+        } catch (final CRC32MismatchException e) {
+            throw e;
+        } catch (final IOException e) {
+            throw e;
+        } catch (final Exception e) {
+            final String errorMessage = "Unable to unmarshall response (" + e.getMessage()
+                    + "). Response Code: " +
+                    response.getStatusCode() + ", Response Text: " + response.getStatusText();
+            throw new AmazonClientException(errorMessage, e);
+        }
+    }
+
+    /**
+     * Responsible for handling an error response, including unmarshalling the
+     * error response into the most specific exception type possible, and
+     * throwing the exception.
+     *
+     * @param request The request that generated the error response being
+     *            handled.
+     * @param errorResponseHandler The response handler responsible for
+     *            unmarshalling the error response.
+     * @param method The HTTP method containing the actual response content.
+     * @throws IOException If any problems are encountering reading the error
+     *             response.
+     */
+    AmazonServiceException handleErrorResponse(Request<?> request,
+            HttpResponseHandler<AmazonServiceException> errorResponseHandler,
+            HttpResponse response) throws IOException {
+        final int status = response.getStatusCode();
+
+        AmazonServiceException exception = null;
+        try {
+            exception = errorResponseHandler.handle(response);
+            REQUEST_LOG.debug("Received error response: " + exception.toString());
+        } catch (final Exception e) {
+            // If the errorResponseHandler doesn't work, then check for error
+            // responses that don't have any content
+            if (status == HTTP_STATUS_REQ_TOO_LONG) {
+                exception = new AmazonServiceException("Request entity too large");
+                exception.setServiceName(request.getServiceName());
+                exception.setStatusCode(HTTP_STATUS_REQ_TOO_LONG);
+                exception.setErrorType(ErrorType.Client);
+                exception.setErrorCode("Request entity too large");
+            } else if (status == HTTP_STATUS_SERVICE_UNAVAILABLE
+                    && "Service Unavailable".equalsIgnoreCase(response.getStatusText())) {
+                exception = new AmazonServiceException("Service unavailable");
+                exception.setServiceName(request.getServiceName());
+                exception.setStatusCode(HTTP_STATUS_SERVICE_UNAVAILABLE);
+                exception.setErrorType(ErrorType.Service);
+                exception.setErrorCode("Service unavailable");
+            } else if (e instanceof IOException) {
+                throw (IOException) e;
+            } else {
+                final String errorMessage = "Unable to unmarshall error response (" + e.getMessage()
+                        + "). Response Code: " + status
+                        + ", Response Text: " + response.getStatusText()
+                        + ", Response Headers: " + response.getHeaders();
+                throw new AmazonClientException(errorMessage, e);
+            }
+        }
+
+        exception.setStatusCode(status);
+        exception.setServiceName(request.getServiceName());
+        exception.fillInStackTrace();
+        return exception;
+    }
+
+    /**
+     * Sleep for a period of time on failed request to avoid flooding a service
+     * with retries.
+     *
+     * @param originalRequest The original service request that is being
+     *            executed.
+     * @param previousException Exception information for the previous attempt,
+     *            if any.
+     * @param requestCount current request count (including the next attempt
+     *            after the delay)
+     * @param retryPolicy The retry policy configured in this http client.
+     */
+    private long pauseBeforeNextRetry(AmazonWebServiceRequest originalRequest,
+            AmazonClientException previousException,
+            int requestCount,
+            RetryPolicy retryPolicy) {
+        final int retries = requestCount // including next attempt
+                - 1 // number of attempted requests
+                - 1; // number of attempted retries
+
+        final long delay = retryPolicy.getBackoffStrategy().delayBeforeNextRetry(
+                originalRequest, previousException, retries);
+
+        if (log.isDebugEnabled()) {
+            log.debug("Retriable error detected, " +
+                    "will retry in " + delay + "ms, attempt number: " + retries);
+        }
+
+        try {
+            Thread.sleep(delay);
+            return delay;
+        } catch (final InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new AmazonClientException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Returns date string from the exception message body in form of
+     * yyyyMMdd'T'HHmmss'Z' We needed to extract date from the message body
+     * because SQS is the only service that does not provide date header in the
+     * response. Example, when device time is behind than the server time than
+     * we get a string that looks something like this:
+     * "Signature expired: 20130401T030113Z is now earlier than 20130401T034613Z (20130401T040113Z - 15 min.)"
+     *
+     * @param body The message from where the server time is being extracted
+     * @return Return datetime in string format (yyyyMMdd'T'HHmmss'Z')
+     */
+    private String getServerDateFromException(String body) {
+        final int startPos = body.indexOf("(");
+        int endPos = 0;
+        if (body.contains(" + 15")) {
+            endPos = body.indexOf(" + 15");
+        } else {
+            endPos = body.indexOf(" - 15");
+        }
+        final String msg = body.substring(startPos + 1, endPos);
+        return msg;
+    }
+
+    int parseClockSkewOffset(HttpResponse response, AmazonServiceException exception) {
+        final Date deviceDate = new Date();
+        Date serverDate = null;
+        String serverDateStr = null;
+        final String responseDateHeader = response.getHeaders().get("Date");
+
+        try {
+
+            if (responseDateHeader == null || responseDateHeader.isEmpty()) {
+                // SQS doesn't return Date header
+                serverDateStr = getServerDateFromException(exception.getMessage());
+                serverDate = DateUtils.parseCompressedISO8601Date(serverDateStr);
+            } else {
+                serverDateStr = responseDateHeader;
+                serverDate = DateUtils.parseRFC822Date(serverDateStr);
+            }
+        } catch (final RuntimeException e) {
+            log.warn("Unable to parse clock skew offset from response: "
+                    + serverDateStr,
+                    e);
+            return 0;
+        }
+
+        final long diff = deviceDate.getTime() - serverDate.getTime();
+        return (int) (diff / TIME_MILLISEC);
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        this.shutdown();
+        super.finalize();
+    }
+
+    /**
+     * @return the http client specific request metric collector; or null if
+     * there is none.
+     */
+    public RequestMetricCollector getRequestMetricCollector() {
+        return requestMetricCollector;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/ApacheHttpClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ApacheHttpClient.java
new file mode 100644
index 0000000000..c2e218376e
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ApacheHttpClient.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.ClientConfiguration;
+
+import org.apache.http.Header;
+import org.apache.http.client.methods.HttpDelete;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpHead;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.client.methods.HttpPut;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.apache.http.client.params.ClientPNames;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.impl.client.AbstractHttpClient;
+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpParams;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * An implementation of {@link HttpClient} backed by Apache HttpClient.
+ */
+public class ApacheHttpClient implements HttpClient {
+
+    private final org.apache.http.client.HttpClient httpClient;
+
+    /**
+     * Constructor.
+     * @param config the client configuration.
+     */
+    public ApacheHttpClient(ClientConfiguration config) {
+        HttpClientFactory httpClientFactory = new HttpClientFactory();
+        httpClient = httpClientFactory.createHttpClient(config);
+        // disable retry
+        ((AbstractHttpClient) httpClient)
+                .setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler(0, false));
+
+        SchemeRegistry schemeRegistry = httpClient.getConnectionManager().getSchemeRegistry();
+        Scheme https = schemeRegistry.getScheme("https");
+        ((SSLSocketFactory) https.getSocketFactory())
+                .setHostnameVerifier(SSLSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
+    }
+
+    @Override
+    public HttpResponse execute(HttpRequest request) throws IOException {
+        HttpUriRequest httpRequest = createHttpRequest(request);
+        org.apache.http.HttpResponse httpResponse = httpClient.execute(httpRequest);
+
+        String statusText = httpResponse.getStatusLine().getReasonPhrase();
+        int statusCode = httpResponse.getStatusLine().getStatusCode();
+        InputStream content = null;
+        if (httpResponse.getEntity() != null) {
+            content = httpResponse.getEntity().getContent();
+        }
+
+        HttpResponse.Builder builder = HttpResponse.builder()
+                .statusCode(statusCode)
+                .statusText(statusText)
+                .content(content);
+        for (Header header : httpResponse.getAllHeaders()) {
+            builder.header(header.getName(), header.getValue());
+        }
+
+        return builder.build();
+    }
+
+    @Override
+    public void shutdown() {
+        httpClient.getConnectionManager().shutdown();
+    }
+
+    private HttpParams params = null;
+
+    private HttpUriRequest createHttpRequest(HttpRequest request) {
+        HttpUriRequest httpRequest;
+        String method = request.getMethod();
+        if ("POST".equals(method)) {
+            HttpPost postRequest = new HttpPost(request.getUri());
+            if (request.getContent() != null) {
+                postRequest.setEntity(new InputStreamEntity(request.getContent(),
+                        request.getContentLength()));
+            }
+            httpRequest = postRequest;
+        } else if ("GET".equals(method)) {
+            httpRequest = new HttpGet(request.getUri());
+        } else if ("PUT".equals(method)) {
+            HttpPut putRequest = new HttpPut(request.getUri());
+            if (request.getContent() != null) {
+                putRequest.setEntity(new InputStreamEntity(request.getContent(),
+                        request.getContentLength()));
+            }
+            httpRequest = putRequest;
+        } else if ("DELETE".equals(method)) {
+            httpRequest = new HttpDelete(request.getUri());
+        } else if ("HEAD".equals(method)) {
+            httpRequest = new HttpHead(request.getUri());
+        } else {
+            throw new UnsupportedOperationException("Unsupported method: " + method);
+        }
+
+        if (request.getHeaders() != null && !request.getHeaders().isEmpty()) {
+            for (Map.Entry<String, String> header : request.getHeaders().entrySet()) {
+                String key = header.getKey();
+                /*
+                 * HttpClient4 fills in the Content-Length header and complains
+                 * if it's already present, so we skip it here. We also skip the
+                 * Host header to avoid sending it twice, which will interfere
+                 * with some signing schemes.
+                 */
+                if (key.equals(HttpHeader.CONTENT_LENGTH) || key.equals(HttpHeader.HOST)) {
+                    continue;
+                }
+                httpRequest.addHeader(header.getKey(), header.getValue());
+            }
+        }
+
+        // disable redirect
+        if (params == null) {
+            params = new BasicHttpParams();
+            params.setParameter(ClientPNames.HANDLE_REDIRECTS, false);
+        }
+        httpRequest.setParams(params);
+        return httpRequest;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/ConnectionManagerFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ConnectionManagerFactory.java
new file mode 100644
index 0000000000..e01d19b8bb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ConnectionManagerFactory.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.ClientConfiguration;
+
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.conn.params.ConnPerRouteBean;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.HttpParams;
+
+/**
+ * Responsible for creating and configuring instances of Apache HttpClient 4.0's
+ * Connection Manager.
+ */
+class ConnectionManagerFactory {
+
+    private static final int DEFAULT_HTTP_PORT = 80;
+    private static final int DEFAULT_HTTPS_PORT = 443;
+
+    public static ThreadSafeClientConnManager createThreadSafeClientConnManager(
+            ClientConfiguration config, HttpParams httpClientParams) {
+        ConnManagerParams.setMaxConnectionsPerRoute(httpClientParams,
+                new ConnPerRouteBean(config.getMaxConnections()));
+        ConnManagerParams.setMaxTotalConnections(httpClientParams, config.getMaxConnections());
+
+        SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSocketFactory();
+        sslSocketFactory.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+
+        SchemeRegistry registry = new SchemeRegistry();
+        registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), DEFAULT_HTTP_PORT));
+        registry.register(new Scheme("https", sslSocketFactory, DEFAULT_HTTPS_PORT));
+
+        ThreadSafeClientConnManager connectionManager = new ThreadSafeClientConnManager(
+                httpClientParams, registry);
+        if (config.useReaper()) {
+            IdleConnectionReaper.registerConnectionManager(connectionManager);
+        }
+        return connectionManager;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/DefaultErrorResponseHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/DefaultErrorResponseHandler.java
new file mode 100644
index 0000000000..4e66debd6d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/DefaultErrorResponseHandler.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.util.IOUtils;
+import com.amazonaws.util.XpathUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Implementation of HttpResponseHandler that handles only error responses from
+ * Amazon Web Services. A list of unmarshallers is passed into the constructor,
+ * and while handling a response, each unmarshaller is tried, in order, until
+ * one is found that can successfully unmarshall the error response. If no
+ * unmarshaller is found that can unmarshall the error response, a generic
+ * AmazonServiceException is created and populated with the AWS error response
+ * information (error message, AWS error code, AWS request ID, etc).
+ */
+public class DefaultErrorResponseHandler
+        implements HttpResponseHandler<AmazonServiceException> {
+    private static final Log log = LogFactory.getLog(DefaultErrorResponseHandler.class);
+
+    /**
+     * The list of error response unmarshallers to try to apply to error
+     * responses.
+     */
+    private List<Unmarshaller<AmazonServiceException, Node>> unmarshallerList;
+
+    /**
+     * Constructs a new DefaultErrorResponseHandler that will handle error
+     * responses from Amazon services using the specified list of unmarshallers.
+     * Each unmarshaller will be tried, in order, until one is found that can
+     * unmarshall the error response.
+     *
+     * @param unmarshallerList The list of unmarshallers to try using when
+     *            handling an error response.
+     */
+    public DefaultErrorResponseHandler(
+            List<Unmarshaller<AmazonServiceException, Node>> unmarshallerList) {
+        this.unmarshallerList = unmarshallerList;
+    }
+
+    @Override
+    public AmazonServiceException handle(HttpResponse errorResponse) throws Exception {
+        // Try to read the error response
+        String content = "";
+        try {
+            content = IOUtils.toString(errorResponse.getContent());
+        } catch (IOException ex) {
+            if (log.isDebugEnabled())
+                log.debug("Failed in reading the error response", ex);
+            return newAmazonServiceException(
+                    "Unable to unmarshall error response", errorResponse, ex);
+        }
+        // Try to parse the error response as XML
+        Document document;
+        try {
+            document = XpathUtils.documentFrom(content);
+        } catch (Exception e) {
+            return newAmazonServiceException(String.format(
+                    "Unable to unmarshall error response (%s)", content),
+                    errorResponse, e);
+        }
+
+        /*
+         * We need to select which exception unmarshaller is the correct one to
+         * use from all the possible exceptions this operation can throw.
+         * Currently we rely on the unmarshallers to return null if they can't
+         * unmarshall the response, but we might need something a little more
+         * sophisticated in the future.
+         */
+        for (Unmarshaller<AmazonServiceException, Node> unmarshaller : unmarshallerList) {
+            AmazonServiceException ase = unmarshaller.unmarshall(document);
+            if (ase != null) {
+                ase.setStatusCode(errorResponse.getStatusCode());
+                return ase;
+            }
+        }
+
+        throw new AmazonClientException("Unable to unmarshall error response from service");
+    }
+
+    /**
+     * Used to create an {@link newAmazonServiceException} when we failed to
+     * read the error response or parsed the error response as XML.
+     */
+    private AmazonServiceException newAmazonServiceException(String errmsg,
+            HttpResponse httpResponse, Exception readFailure) {
+        AmazonServiceException exception = new AmazonServiceException(errmsg, readFailure);
+        final int statusCode = httpResponse.getStatusCode();
+        exception.setErrorCode(statusCode + " " + httpResponse.getStatusText());
+        exception.setErrorType(AmazonServiceException.ErrorType.Unknown);
+        exception.setStatusCode(statusCode);
+        return exception;
+    }
+
+    /**
+     * Since this response handler completely consumes all the data from the
+     * underlying HTTP connection during the handle method, we don't need to
+     * keep the HTTP connection open.
+     *
+     * @see com.amazonaws.http.HttpResponseHandler#needsConnectionLeftOpen()
+     */
+    @Override
+    public boolean needsConnectionLeftOpen() {
+        return false;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/ExecutionContext.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ExecutionContext.java
new file mode 100644
index 0000000000..55e2c64f9e
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/ExecutionContext.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonWebServiceClient;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.Signer;
+import com.amazonaws.handlers.RequestHandler2;
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.AWSRequestMetricsFullSupport;
+
+import java.net.URI;
+import java.util.List;
+
+/**
+ * The execution context.
+ */
+public class ExecutionContext {
+    private final AWSRequestMetrics awsRequestMetrics;
+    private final List<RequestHandler2> requestHandler2s;
+    private String contextUserAgent;
+    private final AmazonWebServiceClient awsClient;
+
+    /**
+     * Optional credentials to enable the runtime layer to handle signing
+     * requests (and resigning on retries).
+     */
+    private AWSCredentials credentials;
+
+    /** For testing purposes.
+     * @param isMetricEnabled true if metric is enabled.
+     */
+    @Deprecated
+    public ExecutionContext(boolean isMetricEnabled) {
+        this(null, isMetricEnabled, null);
+    }
+
+    /** For testing purposes. */
+    public ExecutionContext() {
+        this(null, false, null);
+    }
+
+    /**
+     * Constructor.
+     * @param requestHandler2s the list of request handlers.
+     * @param isMetricEnabled true if metric is enabled.
+     * @param awsClient the AWS client.
+     */
+    public ExecutionContext(List<RequestHandler2> requestHandler2s,
+            boolean isMetricEnabled, AmazonWebServiceClient awsClient) {
+        this.requestHandler2s = requestHandler2s;
+        awsRequestMetrics = isMetricEnabled
+                ? new AWSRequestMetricsFullSupport()
+                : new AWSRequestMetrics();
+        this.awsClient = awsClient;
+    }
+
+    public String getContextUserAgent() {
+        return contextUserAgent;
+    }
+
+    public void setContextUserAgent(String contextUserAgent) {
+        this.contextUserAgent = contextUserAgent;
+    }
+
+    public List<RequestHandler2> getRequestHandler2s() {
+        return requestHandler2s;
+    }
+
+    @Deprecated
+    public AWSRequestMetrics getAwsRequestMetrics() {
+        return awsRequestMetrics;
+    }
+
+    /**
+     * There is in general no need to set the signer in the execution context,
+     * since the signer for each request may differ depending on the URI of the
+     * request. The exception is S3 where the signer is currently determined
+     * only when the S3 client is constructed. Hence the need for this method.
+     * We may consider supporting a per request level signer determination for
+     * S3 later on.
+     * @param signer the signer.
+     */
+    public void setSigner(Signer signer) {
+    }
+
+    /**
+     * @param uri the URI.
+     * @return the signer for the given uri. Note S3 in particular overrides
+     * this method.
+     */
+    public Signer getSignerByURI(URI uri) {
+        return awsClient == null ? null : awsClient.getSignerByURI(uri);
+    }
+
+    /**
+     * Returns the optional credentials used to sign the associated request.
+     *
+     * @return The optional credentials used to sign the associated request.
+     */
+    public AWSCredentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * Sets the optional credentials used to sign the associated request. If no
+     * credentials are specified as part of a request's ExecutionContext, then
+     * the runtime layer will not attempt to sign (or resign on retries)
+     * requests.
+     *
+     * @param credentials The optional credentials used to sign the associated
+     *            request.
+     */
+    public void setCredentials(AWSCredentials credentials) {
+        this.credentials = credentials;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClient.java
new file mode 100644
index 0000000000..58f492369d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClient.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+import org.apache.http.conn.ssl.BrowserCompatHostnameVerifier;
+
+import java.io.IOException;
+
+/**
+ * Interface for an HTTP client. Its main responsibility is to execute an
+ * {@link HttpRequest} and return a {@link HttpResponse}. There are some
+ * requirements for its implementation.
+ * <ul>
+ * <li>Execute the request without any modification. An {@link HttpRequest} is
+ * converted from an {@link AmazonWebServiceRequest} with signature information.
+ * If modified, the request is likely to be rejected by AWS service.</li>
+ * <li>Disable retry logic and redirect which are handled by the service client
+ * itself.</li>
+ * <li>Enable {@link BrowserCompatHostnameVerifier} so that a wildcard (such as
+ * "*.amazonaws.com") matches all subdomains, including "a.b.amazonaws.com".
+ * This is needed for S3 virtual hosting. See <a
+ * href="http://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html"
+ * >Virtual Hosting of Buckets</a> for more details.</li>
+ * <li>Beware of the Expect 100-continue header. Currently it's only used in <a
+ * href="http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUT.html">S3's
+ * Put Object API</a>. S3 can fail the request with a status code other than 100
+ * (continue) or 417 (reject) an an error message in the body.</li>
+ * <li>Cache is unnecessary and isn't recommended to implement until it's
+ * supported by AWS service.</li>
+ * </ul>
+ */
+public interface HttpClient {
+
+    /**
+     * Executes a {@link HttpRequest} and returns a {@link HttpResponse}.
+     *
+     * @param request a HTTP request
+     * @return the response object
+     * @throws IOException in case of a connection problem
+     */
+    HttpResponse execute(HttpRequest request) throws IOException;
+
+    /**
+     * Forcefully shutdown this HTTP client and release all underlying
+     * resources.
+     */
+    void shutdown();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClientFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClientFactory.java
new file mode 100644
index 0000000000..2e82b9cea4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpClientFactory.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.http.impl.client.HttpRequestNoRetryHandler;
+import com.amazonaws.http.impl.client.SdkHttpClient;
+
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.NTCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.conn.params.ConnRoutePNames;
+import org.apache.http.conn.params.ConnRouteParams;
+import org.apache.http.conn.scheme.PlainSocketFactory;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultRedirectHandler;
+import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HttpContext;
+
+/** Responsible for creating and configuring instances of Apache HttpClient4. */
+class HttpClientFactory {
+
+    private static final int HTTP_PORT = 80;
+    private static final int HTTPS_PORT = 443;
+
+    /**
+     * Creates a new HttpClient object using the specified AWS
+     * ClientConfiguration to configure the client.
+     *
+     * @param config Client configuration options (ex: proxy settings,
+     *            connection limits, etc).
+     * @return The new, configured HttpClient.
+     */
+    public HttpClient createHttpClient(ClientConfiguration config) {
+        /* Set HTTP client parameters */
+        final HttpParams httpClientParams = new BasicHttpParams();
+        HttpConnectionParams.setConnectionTimeout(httpClientParams, config.getConnectionTimeout());
+        HttpConnectionParams.setSoTimeout(httpClientParams, config.getSocketTimeout());
+        HttpConnectionParams.setStaleCheckingEnabled(httpClientParams, true);
+        HttpConnectionParams.setTcpNoDelay(httpClientParams, true);
+
+        final int socketSendBufferSizeHint = config.getSocketBufferSizeHints()[0];
+        final int socketReceiveBufferSizeHint = config.getSocketBufferSizeHints()[1];
+        if (socketSendBufferSizeHint > 0 || socketReceiveBufferSizeHint > 0) {
+            HttpConnectionParams.setSocketBufferSize(httpClientParams,
+                    Math.max(socketSendBufferSizeHint, socketReceiveBufferSizeHint));
+        }
+
+        final ThreadSafeClientConnManager connectionManager = ConnectionManagerFactory
+                .createThreadSafeClientConnManager(config, httpClientParams);
+        final SdkHttpClient httpClient = new SdkHttpClient(connectionManager, httpClientParams);
+        httpClient.setHttpRequestRetryHandler(HttpRequestNoRetryHandler.Singleton);
+        httpClient.setRedirectHandler(new LocationHeaderNotRequiredRedirectHandler());
+
+        if (config.getLocalAddress() != null) {
+            ConnRouteParams.setLocalAddress(httpClientParams, config.getLocalAddress());
+        }
+
+        final Scheme http = new Scheme("http", PlainSocketFactory.getSocketFactory(), HTTP_PORT);
+        final SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSocketFactory();
+        sslSocketFactory.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
+        final Scheme https = new Scheme("https", sslSocketFactory, HTTPS_PORT);
+        final SchemeRegistry sr = connectionManager.getSchemeRegistry();
+        sr.register(http);
+        sr.register(https);
+
+        /*
+         * If SSL cert checking for endpoints has been explicitly disabled,
+         * register a new scheme for HTTPS that won't cause self-signed certs to
+         * error out.
+         */
+        /*
+         * Commented as per https://support.google.com/faqs/answer/6346016. Uncomment for testing.
+         */
+        /*
+        if (System.getProperty(DISABLE_CERT_CHECKING_SYSTEM_PROPERTY) != null) {
+            SSLSocketFactory sf = getTrustAllSSLSocketFactory();
+            sf.setHostnameVerifier(SSLSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
+            Scheme sch = new Scheme("https", sf, 443);
+            httpClient.getConnectionManager().getSchemeRegistry().register(sch);
+        }
+        */
+        /* Set proxy if configured */
+        final String proxyHost = config.getProxyHost();
+        final int proxyPort = config.getProxyPort();
+        if (proxyHost != null && proxyPort > 0) {
+            AmazonHttpClient.log.info("Configuring Proxy. Proxy Host: " + proxyHost + " "
+                    + "Proxy Port: " + proxyPort);
+            final HttpHost proxyHttpHost = new HttpHost(proxyHost, proxyPort);
+            httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHttpHost);
+
+            final String proxyUsername = config.getProxyUsername();
+            final String proxyPassword = config.getProxyPassword();
+            final String proxyDomain = config.getProxyDomain();
+            final String proxyWorkstation = config.getProxyWorkstation();
+
+            if (proxyUsername != null && proxyPassword != null) {
+                httpClient.getCredentialsProvider().setCredentials(
+                        new AuthScope(proxyHost, proxyPort),
+                        new NTCredentials(proxyUsername, proxyPassword, proxyWorkstation,
+                                proxyDomain));
+            }
+
+            // TODO: support preemptive proxy auth?
+        }
+
+        return httpClient;
+    }
+
+    /**
+     * Customization of the default redirect strategy provided by HttpClient to
+     * be a little less strict about the Location header to account for S3 not
+     * sending the Location header with 301 responses.
+     */
+    private static final class LocationHeaderNotRequiredRedirectHandler
+            extends DefaultRedirectHandler {
+
+        @Override
+        public boolean isRedirectRequested(HttpResponse response, HttpContext context) {
+            final int statusCode = response.getStatusLine().getStatusCode();
+            final Header locationHeader = response.getFirstHeader("location");
+
+            // Instead of throwing a ProtocolException in this case, just
+            // return false to indicate that this is not redirected
+            if (locationHeader == null &&
+                    statusCode == HttpStatus.SC_MOVED_PERMANENTLY) {
+                return false;
+            }
+
+            return super.isRedirectRequested(response, context);
+        }
+    }
+
+
+    /**
+     * Gets an SSLSocketFactory that bypasses SSL certificate checks.
+     *
+     * @return SSLSocketFactory
+     */
+    /*
+    private static SSLSocketFactory getTrustAllSSLSocketFactory() {
+        try {
+            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            trustStore.load(null, null);
+            SSLSocketFactory sf = new TrustAllSSLSocketFactory(trustStore);
+            return sf;
+        } catch (Exception e) {
+            throw new AmazonClientException("Failed to create trust all socket factory", e);
+        }
+    }
+    */
+    /**
+     * An SSLSocketFactory that bypasses SSL certificate checks. This class is
+     * only intended to be used for testing purposes.
+     */
+    /*
+    private static class TrustAllSSLSocketFactory extends SSLSocketFactory {
+        private final SSLContext sslContext;
+
+        public TrustAllSSLSocketFactory(KeyStore keystore) throws NoSuchAlgorithmException,
+                KeyManagementException, KeyStoreException, UnrecoverableKeyException {
+            super(keystore);
+            sslContext = SSLContext.getInstance("TLS");
+            sslContext.init(null, new TrustManager[] {
+                    new TrustingX509TrustManager()
+            }, null);
+        }
+
+        @Override
+        public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
+                throws IOException, UnknownHostException {
+            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
+        }
+
+        @Override
+        public Socket createSocket() throws IOException {
+            return sslContext.getSocketFactory().createSocket();
+        }
+    }
+    */
+    /**
+     * Simple implementation of X509TrustManager that trusts all certificates.
+     * This class is only intended to be used for testing purposes.
+     */
+    /*
+    private static class TrustingX509TrustManager implements X509TrustManager {
+        private static final X509Certificate[] X509_CERTIFICATES = new X509Certificate[0];
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return X509_CERTIFICATES;
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            // No-op, to trust all certs
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            // No-op, to trust all certs
+        }
+    };
+    */
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpHeader.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpHeader.java
new file mode 100644
index 0000000000..8021d49719
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpHeader.java
@@ -0,0 +1,53 @@
+
+package com.amazonaws.http;
+
+/**
+ * Http header class.
+ */
+public final class HttpHeader {
+
+    /** HTTP header for Accept. */
+    public static final String ACCEPT = "Accept";
+
+    /** HTTP header for Authorization. */
+    public static final String AUTHORIZATION = "Authorization";
+
+    /** HTTP header for Content-Length. */
+    public static final String CONTENT_LENGTH = "Content-Length";
+
+    /** HTTP header for Content-Type. */
+    public static final String CONTENT_TYPE = "Content-Type";
+
+    /** HTTP header for Date. */
+    public static final String DATE = "Date";
+
+    /** HTTP header for Expect. */
+    public static final String EXPECT = "Expect";
+
+    /** HTTP header for Host. */
+    public static final String HOST = "Host";
+
+    /** HTTP header for Location. */
+    public static final String LOCATION = "Location";
+
+    /** HTTP header for User-Agent. */
+    public static final String USER_AGENT = "User-Agent";
+
+    /** Amazon header for X-Amz-Date. */
+    public static final String X_AMZ_CONTENT_SHA256 = "X-Amz-Date";
+    /*
+     * Amazon headers
+     */
+
+    /** Amazon header for X-Amz-Date. */
+    public static final String X_AMZ_DATE = "X-Amz-Date";
+
+    /** Amazon header for x-amz-nonce. */
+    public static final String X_AMZ_NONCE = "x-amz-nonce";
+
+    /** Amazon header for x-amz-security-token. */
+    public static final String X_AMZ_SECURITY_TOKEN = "X-Amz-Date";
+
+    /** Amazon header for X-Amzn-Authorization. */
+    public static final String X_AMZN_AUTHORIZATION = "X-Amz-Date";
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodName.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodName.java
new file mode 100644
index 0000000000..aae4794d8a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodName.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+/** Enums for HTTP method. */
+public enum HttpMethodName {
+
+    /** Http method for GET. */
+    GET,
+
+    /** Http method for POST. */
+    POST,
+
+    /** Http method for PUT. */
+    PUT,
+
+    /** Http method for DELETE. */
+    DELETE,
+
+    /** Http method for HEAD. */
+    HEAD,
+
+    /** Http method for PATCH. */
+    PATCH;
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodReleaseInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodReleaseInputStream.java
new file mode 100644
index 0000000000..4d207faa1b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpMethodReleaseInputStream.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.HttpMethod;
+import com.amazonaws.internal.SdkInputStream;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpEntityEnclosingRequest;
+import org.apache.http.client.methods.AbortableHttpRequest;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Utility class to wrap InputStreams obtained from an HttpClient library's
+ * HttpMethod object, and ensure the stream and HTTP connection are properly
+ * released.
+ * <p>
+ * This input stream wrapper is used to ensure that input streams obtained
+ * through HttpClient connections are cleaned up correctly once the caller has
+ * read all the contents of the connection's input stream, or closed the input
+ * stream. Additionally, this class attempts to release the connection and close
+ * the stream in this object's finalizer method, as a last resort to avoid
+ * leaking resources.
+ * <p>
+ * <b>Important!</b> This input stream must be completely consumed or closed to
+ * ensure the necessary cleanup operations can be performed.
+ */
+public class HttpMethodReleaseInputStream extends SdkInputStream {
+    private static final Log log = LogFactory.getLog(HttpMethodReleaseInputStream.class);
+
+    private InputStream in;
+    private HttpEntityEnclosingRequest httpRequest;
+    private boolean alreadyReleased;
+    private boolean underlyingStreamConsumed;
+
+    /**
+     * Constructs an input stream based on an {@link HttpMethod} object
+     * representing an HTTP connection. If a connection input stream is
+     * available, this constructor wraps the underlying input stream and makes
+     * that stream available. If no underlying connection is available, an empty
+     * {@link ByteArrayInputStream} is made available.
+     *
+     * @param httpMethod The HTTP method being executed, whose response content
+     *            is to be wrapped.
+     */
+    @SuppressWarnings("checkstyle:emptyblock")
+    public HttpMethodReleaseInputStream(HttpEntityEnclosingRequest httpMethod) {
+        this.httpRequest = httpMethod;
+
+        try {
+            this.in = httpMethod.getEntity().getContent();
+        } catch (IOException e) {
+            if (log.isWarnEnabled()) {
+                log.warn("Unable to obtain HttpMethod's response data stream", e);
+            }
+            try {
+                httpMethod.getEntity().getContent().close();
+            } catch (Exception ex) {
+            }
+            this.in = new ByteArrayInputStream(new byte[0]); // Empty input
+                                                             // stream;
+        }
+    }
+
+    /**
+     * Returns the underlying HttpMethod object that contains/manages the actual
+     * HTTP connection.
+     *
+     * @return the HTTPMethod object that provides the data input stream.
+     */
+    public HttpEntityEnclosingRequest getHttpRequest() {
+        return httpRequest;
+    }
+
+    /**
+     * Forces the release of an HttpMethod's connection in a way that will
+     * perform all the necessary cleanup through the correct use of HttpClient
+     * methods.
+     *
+     * @throws IOException
+     */
+    protected void releaseConnection() throws IOException {
+        if (!alreadyReleased) {
+            if (!underlyingStreamConsumed) {
+                // Underlying input stream has not been consumed, abort method
+                // to force connection to be closed and cleaned-up.
+                if (httpRequest instanceof AbortableHttpRequest) {
+                    AbortableHttpRequest abortableHttpRequest = (AbortableHttpRequest) httpRequest;
+                    abortableHttpRequest.abort();
+                }
+            }
+            in.close();
+            alreadyReleased = true;
+        }
+    }
+
+    /**
+     * Standard input stream read method, except it calls
+     * {@link #releaseConnection} when the underlying input stream is consumed.
+     *
+     * @see java.io.InputStream#read()
+     */
+    @Override
+    public int read() throws IOException {
+        try {
+            int read = in.read();
+            if (read == -1) {
+                underlyingStreamConsumed = true;
+                if (!alreadyReleased) {
+                    releaseConnection();
+                    if (log.isDebugEnabled()) {
+                        log.debug("Released HttpMethod as its response data stream is fully consumed");
+                    }
+                }
+            }
+            return read;
+        } catch (IOException e) {
+            releaseConnection();
+            if (log.isDebugEnabled()) {
+                log.debug("Released HttpMethod as its response data stream threw an exception", e);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Standard input stream read method, except it calls
+     * {@link #releaseConnection} when the underlying input stream is consumed.
+     *
+     * @see java.io.InputStream#read(byte[], int, int)
+     */
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        try {
+            int read = in.read(b, off, len);
+            if (read == -1) {
+                underlyingStreamConsumed = true;
+                if (!alreadyReleased) {
+                    releaseConnection();
+                    if (log.isDebugEnabled()) {
+                        log.debug("Released HttpMethod as its response data stream is fully consumed");
+                    }
+                }
+            }
+            return read;
+        } catch (IOException e) {
+            releaseConnection();
+            if (log.isDebugEnabled()) {
+                log.debug("Released HttpMethod as its response data stream threw an exception", e);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Standard input stream available method, except it ensures that
+     * {@link #releaseConnection()} is called if any errors are encountered from
+     * the wrapped stream.
+     *
+     * @see java.io.InputStream#available()
+     */
+    @Override
+    public int available() throws IOException {
+        try {
+            return in.available();
+        } catch (IOException e) {
+            releaseConnection();
+            if (log.isDebugEnabled()) {
+                log.debug("Released HttpMethod as its response data stream threw an exception", e);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Standard input stream close method, except it ensures that
+     * {@link #releaseConnection()} is called before the input stream is closed.
+     *
+     * @see java.io.InputStream#close()
+     */
+    @Override
+    public void close() throws IOException {
+        if (!alreadyReleased) {
+            releaseConnection();
+            if (log.isDebugEnabled()) {
+                log.debug("Released HttpMethod as its response data stream is closed");
+            }
+        }
+        in.close();
+    }
+
+    /**
+     * Tries to ensure a connection is always cleaned-up correctly by calling
+     * {@link #releaseConnection()} on class destruction if the cleanup hasn't
+     * already been done.
+     * <p>
+     * This desperate cleanup act will only be necessary if the user of this
+     * class does not completely consume or close this input stream prior to
+     * object destruction. This method will log Warning messages if a forced
+     * cleanup is required, hopefully reminding the user to close their streams
+     * properly.
+     */
+    @Override
+    protected void finalize() throws Throwable {
+        if (!alreadyReleased) {
+            if (log.isWarnEnabled()) {
+                log.warn("Attempting to release HttpMethod in finalize() as its response data stream has gone out of scope. "
+                        + "This attempt will not always succeed and cannot be relied upon! Please ensure S3 response data streams are "
+                        + "always fully consumed or closed to avoid HTTP connection starvation.");
+            }
+            releaseConnection();
+            if (log.isWarnEnabled()) {
+                log.warn("Successfully released HttpMethod in finalize(). You were lucky this time... "
+                        + "Please ensure S3 response data streams are always fully consumed or closed.");
+            }
+        }
+        super.finalize();
+    }
+
+    @Override
+    protected InputStream getWrappedInputStream() {
+        return in;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequest.java
new file mode 100644
index 0000000000..762f750a38
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.util.StringUtils;
+
+import java.io.InputStream;
+import java.net.URI;
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A HTTP request class. Any {@link AmazonWebServiceRequest} will be translated
+ * to this class before being sent out by {@link HttpClient}.
+ */
+public class HttpRequest {
+
+    private final String method;
+    private URI uri;
+    private final Map<String, String> headers;
+    private final InputStream content;
+    private boolean isStreaming;
+
+    /**
+     * Constructs a HttpRequest with given method and uri. It uses no header and
+     * has no content. It's handy for HEAD/GET/DELETE where content is absent.
+     *
+     * @param method HTTP method
+     * @param uri uri of the request.
+     */
+    public HttpRequest(String method, URI uri) {
+        this(method, uri, null, null);
+    }
+
+    /**
+     * Constructs a HttpRequest with given method and uri.
+     *
+     * @param method HTTP method
+     * @param uri uri of the request.
+     * @param headers HTTP headers key-value map
+     * @param content content of the request. Can be null if no content.
+     */
+    @SuppressWarnings("unchecked")
+    public HttpRequest(String method, URI uri, Map<String, String> headers, InputStream content) {
+        this.method = StringUtils.upperCase(method);
+        this.uri = uri;
+        this.headers = headers == null ? Collections.EMPTY_MAP
+                : Collections.unmodifiableMap(headers);
+        this.content = content;
+    }
+
+    /**
+     * Gets the HTTP method, one of GET, POST, PUT, HEAD, DELETE.
+     *
+     * @return the HTTP method
+     */
+    public String getMethod() {
+        return method;
+    }
+
+    /**
+     * Gets the {@link URI} of this request.
+     *
+     * @return uri of this request
+     */
+    public URI getUri() {
+        return uri;
+    }
+
+    /**
+     * Updates the uri of this request. It's used to handle redirect.
+     *
+     * @param uri a new uri for this request
+     */
+    void setUri(URI uri) {
+        this.uri = uri;
+    }
+
+    /**
+     * Gets an unmodifiable headers map. Possible headers are: user-agent, date,
+     * content-length, x-amz-.
+     *
+     * @return an unmodifiable headers map
+     */
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    /**
+     * Gets the input stream, null if no content.
+     *
+     * @return the input stream, null if no content.
+     */
+    public InputStream getContent() {
+        return content;
+    }
+
+    /**
+     * Gets the length of the content which is set in the header, 0 if no
+     * content.
+     *
+     * @return the length of the content, 0 if no content
+     */
+    public long getContentLength() {
+        if (headers == null) {
+            return 0;
+        }
+        final String len = headers.get(HttpHeader.CONTENT_LENGTH);
+        if (len == null || len.isEmpty()) {
+            return 0;
+        }
+        return Long.valueOf(len);
+    }
+
+    public boolean isStreaming() {
+        return isStreaming;
+    }
+
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void setStreaming(boolean isStreaming) {
+        this.isStreaming = isStreaming;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequestFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequestFactory.java
new file mode 100644
index 0000000000..69a2d21367
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpRequestFactory.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.Request;
+import com.amazonaws.util.HttpUtils;
+import com.amazonaws.util.StringUtils;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * Responsible for converting AWS {@link Request}s to {@link HttpRequest}s.
+ */
+public class HttpRequestFactory {
+
+    private static final String DEFAULT_ENCODING = "UTF-8";
+
+    /**
+     * Creates an {@link HttpClient} request object based on the specified AWS
+     * request and populates any parameters, headers, etc. from the original
+     * request.
+     *
+     * @param request The request to convert to an HttpClient request object.
+     * @param clientConfiguration The client configuration.
+     * @param context The execution context of the HTTP request to be executed
+     * @return The converted HttpClient request object with any parameters,
+     *         headers, etc. from the original request set.
+     */
+    public HttpRequest createHttpRequest(Request<?> request,
+            ClientConfiguration clientConfiguration, ExecutionContext context) {
+        final URI endpoint = request.getEndpoint();
+
+        /*
+         * HttpClient cannot handle url in pattern of "http://host//path", so we
+         * have to escape the double-slash between endpoint and resource-path
+         * into "/%2F"
+         */
+        String uri = HttpUtils.appendUri(endpoint.toString(), request.getResourcePath(), true);
+        final String encodedParams = HttpUtils.encodeParameters(request);
+        HttpMethodName method = request.getHttpMethod();
+
+        /*
+         * For all non-POST requests, and any POST requests that already have a
+         * payload, we put the encoded params directly in the URI, otherwise,
+         * we'll put them in the POST request's payload.
+         */
+        final boolean requestHasNoPayload = request.getContent() != null;
+        final boolean requestIsPost = method == HttpMethodName.POST;
+        final boolean putParamsInUri = !requestIsPost || requestHasNoPayload;
+        if (encodedParams != null && putParamsInUri) {
+            uri += "?" + encodedParams;
+        }
+
+        // Configure headers from request. Additional headers will be added
+        // later if necessary.
+        final Map<String, String> headers = new HashMap<String, String>();
+        configureHeaders(headers, request, context, clientConfiguration);
+
+        InputStream is = request.getContent();
+
+        // Some HTTP client, e.g. HttpURLConnection, doesn't support PATCH.
+        // Tunnel it through another method by setting the intended method in
+        // the X-HTTP-Method-Override header.
+        if (method == HttpMethodName.PATCH) {
+            method = HttpMethodName.POST;
+            headers.put("X-HTTP-Method-Override", HttpMethodName.PATCH.toString());
+        }
+        if (method == HttpMethodName.POST) {
+            /*
+             * If there isn't any payload content to include in this request,
+             * then try to include the POST parameters in the query body,
+             * otherwise, just use the query string. For all AWS Query services,
+             * the best behavior is putting the params in the request body for
+             * POST requests, but we can't do that for S3.
+             */
+            if (request.getContent() == null && encodedParams != null) {
+                final byte[] contentBytes = encodedParams.getBytes(StringUtils.UTF8);
+                is = new ByteArrayInputStream(contentBytes);
+                headers.put("Content-Length", String.valueOf(contentBytes.length));
+            }
+        }
+        /*
+         * if (method == HttpMethodName.POST || method == HttpMethodName.PUT) {
+         * final String len = headers.get("Content-Length"); if (len == null ||
+         * len.isEmpty()) { // streaming mode if (is != null) { throw new
+         * AmazonClientException( "Unknown content-length"); } else {
+         * headers.put("Content-Length", "0"); } } }
+         */
+
+        // Enables gzip compression. Also signals the implementation of
+        // HttpClient to disable transparent gzip.
+        if (clientConfiguration.isEnableGzip()
+                && headers.get("Accept-Encoding") == null) {
+            headers.put("Accept-Encoding", "gzip");
+        } else {
+            headers.put("Accept-Encoding", "identity");
+        }
+
+        final HttpRequest httpRequest = new HttpRequest(method.toString(), URI.create(uri), headers,
+                is);
+        httpRequest.setStreaming(request.isStreaming());
+
+        return httpRequest;
+    }
+
+    /** Configures the headers in the specified Apache HTTP request. */
+    private void configureHeaders(Map<String, String> headers, Request<?> request,
+            ExecutionContext context, ClientConfiguration clientConfiguration) {
+        /*
+         * Apache HttpClient omits the port number in the Host header (even if
+         * we explicitly specify it) if it's the default port for the protocol
+         * in use. To ensure that we use the same Host header in the request and
+         * in the calculated string to sign (even if Apache HttpClient changed
+         * and started honoring our explicit host with endpoint), we follow this
+         * same behavior here and in the QueryString signer.
+         */
+        final URI endpoint = request.getEndpoint();
+        String hostHeader = endpoint.getHost();
+        if (HttpUtils.isUsingNonDefaultPort(endpoint)) {
+            hostHeader += ":" + endpoint.getPort();
+        }
+        headers.put("Host", hostHeader);
+
+        // Copy over any other headers already in our request
+        for (final Entry<String, String> entry : request.getHeaders().entrySet()) {
+            headers.put(entry.getKey(), entry.getValue());
+        }
+
+        /* Set content type and encoding */
+        if (headers.get("Content-Type") == null || headers.get("Content-Type").isEmpty()) {
+            headers.put("Content-Type",
+                    "application/x-www-form-urlencoded; " +
+                            "charset=" + StringUtils.lowerCase(DEFAULT_ENCODING));
+        }
+
+        // Override the user agent string specified in the client params if the
+        // context requires it
+        if (context != null && context.getContextUserAgent() != null) {
+            headers.put("User-Agent",
+                    createUserAgentString(clientConfiguration, context.getContextUserAgent()));
+        }
+    }
+
+    /**
+     * Appends the given user-agent string to the client's existing one and
+     * returns it.
+     */
+    private String createUserAgentString(ClientConfiguration clientConfiguration,
+            String contextUserAgent) {
+        if (clientConfiguration.getUserAgent().contains(contextUserAgent)) {
+            return clientConfiguration.getUserAgent();
+        } else {
+            return clientConfiguration.getUserAgent() + " " + contextUserAgent;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponse.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponse.java
new file mode 100644
index 0000000000..f316f0fcab
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponse.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.GZIPInputStream;
+
+/**
+ * Represents an HTTP response returned by an AWS service in response to a
+ * service request.
+ */
+@SuppressWarnings("checkstyle:finalclass")
+public class HttpResponse {
+
+    private final String statusText;
+    private final int statusCode;
+    // Raw content input stream without decoding
+    private final InputStream rawContent;
+    private final Map<String, String> headers;
+    private InputStream content;
+
+    private HttpResponse(String statusText, int statusCode, Map<String, String> headers,
+            InputStream rawContent) {
+        this.statusText = statusText;
+        this.statusCode = statusCode;
+        this.headers = headers;
+        this.rawContent = rawContent;
+    }
+
+    /**
+     * Returns the HTTP headers returned with this response.
+     *
+     * @return The set of HTTP headers returned with this HTTP response.
+     */
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    /**
+     * Returns the input stream containing the response content.
+     *
+     * @return The input stream containing the response content.
+     * @throws IOException if an I/O error has occurred
+     */
+    public InputStream getContent() throws IOException {
+        if (content == null) {
+            // Avoid decoding the content multiple times
+            synchronized (this) {
+                if (rawContent != null && "gzip".equals(headers.get("Content-Encoding"))) {
+                    content = new GZIPInputStream(rawContent);
+                } else {
+                    content = rawContent;
+                }
+            }
+        }
+        return content;
+    }
+
+    /**
+     * Get the raw content without considering Content-Encoding. This is useful
+     * if you want full control of the content.
+     *
+     * @return the raw content input stream.
+     * @throws IOException if an I/O error has occurred
+     */
+    public InputStream getRawContent() throws IOException {
+        return rawContent;
+    }
+
+    /**
+     * Returns the HTTP status text associated with this response.
+     *
+     * @return The HTTP status text associated with this response.
+     */
+    public String getStatusText() {
+        return statusText;
+    }
+
+    /**
+     * Returns the HTTP status code (ex: 200, 404, etc) associated with this
+     * response.
+     *
+     * @return The HTTP status code associated with this response.
+     */
+    public int getStatusCode() {
+        return statusCode;
+    }
+
+    /**
+     * Creates a builder for {@link HttpResponse}.
+     *
+     * @return a builder
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * A builder class for {@link HttpResponse} to create an immutable instance.
+     */
+    public static class Builder {
+        private String statusText;
+        private int statusCode;
+        private InputStream content;
+        private final Map<String, String> headers = new HashMap<String, String>();
+
+        /**
+         * Sets the status text.
+         *
+         * @param statusText status text
+         * @return builder itself
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public Builder statusText(String statusText) {
+            this.statusText = statusText;
+            return this;
+        }
+
+        /**
+         * Sets the status code, such as 200, 204, 400, 500, etc
+         *
+         * @param statusCode status code
+         * @return builder itself
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public Builder statusCode(int statusCode) {
+            this.statusCode = statusCode;
+            return this;
+        }
+
+        /**
+         * Sets the content input stream. Default is null, aka no content.
+         *
+         * @param content input stream
+         * @return builder itself
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public Builder content(InputStream content) {
+            this.content = content;
+            return this;
+        }
+
+        /**
+         * Adds a key-value header to the request.
+         *
+         * @param key header key
+         * @param value header value
+         * @return builder itself
+         */
+        public Builder header(String key, String value) {
+            headers.put(key, value);
+            return this;
+        }
+
+        /**
+         * Builds an instance of {@link HttpResponse}
+         *
+         * @return a new instance of {@link HttpResponse}
+         */
+        public HttpResponse build() {
+            return new HttpResponse(statusText, statusCode,
+                    Collections.unmodifiableMap(headers), content);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponseHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponseHandler.java
new file mode 100644
index 0000000000..95ee767036
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/HttpResponseHandler.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+/**
+ * Responsible for handling an HTTP response and returning an object of type T.
+ * For example, a typical response handler might accept a response, and
+ * translate it into a concrete typed object.
+ *
+ * @param <T> The output of this response handler.
+ */
+public interface HttpResponseHandler<T> {
+
+    /**
+     * Accepts an HTTP response object, and returns an object of type T.
+     * Individual implementations may choose to handle the response however they
+     * need to, and return any type that they need to.
+     *
+     * @param response The HTTP response to handle, as received from an AWS
+     *            service.
+     * @return An object of type T, as defined by individual implementations.
+     * @throws Exception If any problems are encountered handling the response.
+     */
+    public T handle(HttpResponse response) throws Exception;
+
+    /**
+     * Indicates if this response handler requires that the underlying HTTP
+     * connection <b>not</b> be closed automatically after the response is
+     * handled.
+     * <p>
+     * For example, if the object returned by this response handler manually
+     * manages the stream of data from the HTTP connection, and doesn't read all
+     * the data from the connection in the {@link #handle(HttpResponse)} method,
+     * this method can be used to prevent the underlying connection from being
+     * prematurely closed.
+     * <p>
+     * Response handlers should use this option very carefully, since it means
+     * that resource cleanup is no longer handled automatically, and if
+     * neglected, can result in the client runtime running out of resources for
+     * new HTTP connections.
+     *
+     * @return True if this response handler requires that the underlying HTTP
+     *         connection be left open, and not automatically closed, otherwise
+     *         false.
+     */
+    public boolean needsConnectionLeftOpen();
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/IdleConnectionReaper.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/IdleConnectionReaper.java
new file mode 100644
index 0000000000..6b4a27994b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/IdleConnectionReaper.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.conn.ClientConnectionManager;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Daemon thread to periodically check connection pools for idle connections.
+ * <p>
+ * Connections sitting around idle in the HTTP connection pool for too long will
+ * eventually be terminated by the AWS end of the connection, and will go into
+ * CLOSE_WAIT. If this happens, sockets will sit around in CLOSE_WAIT, still
+ * using resources on the client side to manage that socket. Many sockets stuck
+ * in CLOSE_WAIT can prevent the OS from creating new connections.
+ * <p>
+ * This class closes idle connections before they can move into the CLOSE_WAIT
+ * state.
+ * <p>
+ * This thread is important because by default, we disable Apache HttpClient's
+ * stale connection checking, so without this thread running in the background,
+ * cleaning up old/inactive HTTP connections, we'd see more IO exceptions when
+ * stale connections (i.e. closed on the AWS side) are left in the connection
+ * pool, and requests grab one of them to begin executing a request.
+ */
+public final class IdleConnectionReaper extends Thread {
+
+    /** The period between invocations of the idle connection reaper. */
+    private static final int PERIOD_MILLISECONDS = 1000 * 60 * 1;
+    private static final int MINUTE_IN_SECONDS = 60;
+
+    /**
+     * The list of registered connection managers, whose connections will be
+     * periodically checked and idle connections closed.
+     */
+    private static final ArrayList<ClientConnectionManager> CONNECTION_MANAGERS = new ArrayList<ClientConnectionManager>();
+    /**
+     * Set to true when shutting down the reaper; Once set to true, this flag is
+     * never set back to false.
+     */
+    private volatile boolean shuttingDown;
+
+    /** Singleton instance of the connection reaper. */
+    private static IdleConnectionReaper instance;
+
+    /** Shared log for any errors during connection reaping. */
+    static final Log log = LogFactory.getLog(IdleConnectionReaper.class);
+
+    /** Private constructor - singleton pattern. */
+    private IdleConnectionReaper() {
+        super("java-sdk-http-connection-reaper");
+        setDaemon(true);
+    }
+
+    /**
+     * Registers the given connection manager with this reaper;
+     * @param connectionManager the connection manager.
+     * @return true if the connection manager has been successfully registered;
+     *         false otherwise.
+     */
+    public static synchronized boolean registerConnectionManager(
+            ClientConnectionManager connectionManager) {
+        if (instance == null) {
+            instance = new IdleConnectionReaper();
+            instance.start();
+        }
+        return CONNECTION_MANAGERS.add(connectionManager);
+    }
+
+    /**
+     * Removes the given connection manager from this reaper, and shutting down
+     * the reaper if there is zero connection manager left.
+     * @param connectionManager the connection manager.
+     * @return true if the connection manager has been successfully removed;
+     *         false otherwise.
+     */
+    public static synchronized boolean removeConnectionManager(
+            ClientConnectionManager connectionManager) {
+        boolean b = CONNECTION_MANAGERS.remove(connectionManager);
+        if (CONNECTION_MANAGERS.isEmpty())
+            shutdown();
+        return b;
+    }
+
+    private void markShuttingDown() {
+        shuttingDown = true;
+    }
+
+    @SuppressWarnings({"unchecked", "checkstyle:hiddenfield"})
+    @Override
+    public void run() {
+        while (true) {
+            if (shuttingDown) {
+                log.debug("Shutting down reaper thread.");
+                return;
+            }
+            try {
+                Thread.sleep(PERIOD_MILLISECONDS);
+
+                // Copy the list of managed ConnectionManagers to avoid possible
+                // ConcurrentModificationExceptions if registerConnectionManager
+                // or
+                // removeConnectionManager are called while we're iterating
+                // (rather
+                // than block/lock while this loop executes).
+                List<ClientConnectionManager> connectionManagers = null;
+                synchronized (IdleConnectionReaper.class) {
+                    connectionManagers = (List<ClientConnectionManager>) IdleConnectionReaper.CONNECTION_MANAGERS
+                            .clone();
+                }
+                for (ClientConnectionManager connectionManager : connectionManagers) {
+                    // When we release connections, the connection manager
+                    // leaves them
+                    // open so they can be reused. We want to close out any idle
+                    // connections so that they don't sit around in CLOSE_WAIT.
+                    try {
+                        connectionManager.closeIdleConnections(MINUTE_IN_SECONDS, TimeUnit.SECONDS);
+                    } catch (Exception t) {
+                        log.warn("Unable to close idle connections", t);
+                    }
+                }
+            } catch (Throwable t) {
+                log.debug("Reaper thread: ", t);
+            }
+        }
+    }
+
+    /**
+     * Shuts down the thread, allowing the class and instance to be collected.
+     * <p>
+     * Since this is a daemon thread, its running will not prevent JVM shutdown.
+     * It will, however, prevent this class from being unloaded or garbage
+     * collected, in the context of a long-running application, until it is
+     * interrupted. This method will stop the thread's execution and clear its
+     * state. Any use of a service client will cause the thread to be restarted.
+     *
+     * @return true if an actual shutdown has been made; false otherwise.
+     */
+    public static synchronized boolean shutdown() {
+        if (instance != null) {
+            instance.markShuttingDown();
+            instance.interrupt();
+            CONNECTION_MANAGERS.clear();
+            instance = null;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * For testing purposes. Returns the number of connection managers currently
+     * monitored by this reaper.
+     */
+    static synchronized int size() {
+        return CONNECTION_MANAGERS.size();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonErrorResponseHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonErrorResponseHandler.java
new file mode 100644
index 0000000000..44b88aa227
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonErrorResponseHandler.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.json.JsonUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * The JSON error response handler class.
+ */
+public class JsonErrorResponseHandler implements HttpResponseHandler<AmazonServiceException> {
+
+    /**
+     * Services using AWS JSON 1.1 protocol with HTTP binding send the error
+     * type information in the response headers, instead of the content.
+     */
+    private static final String X_AMZN_ERROR_TYPE = "x-amzn-ErrorType";
+    private static final int HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;
+
+    /**
+     * The list of error response unmarshallers to try to apply to error
+     * responses.
+     */
+    private final List<? extends JsonErrorUnmarshaller> unmarshallerList;
+
+    /**
+     * Constructor.
+     * @param exceptionUnmarshallers the list of exception unmarshallers.
+     */
+    public JsonErrorResponseHandler(List<? extends JsonErrorUnmarshaller> exceptionUnmarshallers) {
+        this.unmarshallerList = exceptionUnmarshallers;
+    }
+
+    @Override
+    public AmazonServiceException handle(HttpResponse response) throws Exception {
+        JsonErrorResponse error;
+        try {
+            error = JsonErrorResponse.fromResponse(response);
+        } catch (IOException e) {
+            throw new AmazonClientException("Unable to parse error response", e);
+        }
+
+        AmazonServiceException ase = runErrorUnmarshallers(error);
+        if (ase == null)
+            return null;
+
+        ase.setStatusCode(response.getStatusCode());
+        if (response.getStatusCode() < HTTP_STATUS_INTERNAL_SERVER_ERROR) {
+            ase.setErrorType(ErrorType.Client);
+        } else {
+            ase.setErrorType(ErrorType.Service);
+        }
+        ase.setErrorCode(error.getErrorCode());
+
+        for (Entry<String, String> headerEntry : response.getHeaders().entrySet()) {
+            if ("X-Amzn-RequestId".equalsIgnoreCase(headerEntry.getKey())) {
+                ase.setRequestId(headerEntry.getValue());
+            }
+        }
+
+        return ase;
+    }
+
+    private AmazonServiceException runErrorUnmarshallers(JsonErrorResponse error) throws Exception {
+        /*
+         * We need to select which exception unmarshaller is the correct one to
+         * use from all the possible exceptions this operation can throw.
+         * Currently we rely on JsonErrorUnmarshaller.match(...) method which
+         * checks for the error type parsed either from response headers or the
+         * content.
+         */
+        for (JsonErrorUnmarshaller unmarshaller : unmarshallerList) {
+            if (unmarshaller.match(error)) {
+                return unmarshaller.unmarshall(error);
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean needsConnectionLeftOpen() {
+        return false;
+    }
+
+    /**
+     * A class that represents the error object returned from JSON service.
+     */
+    public static final class JsonErrorResponse {
+
+        private final int statusCode;
+        private final String message;
+        private final String errorCode;
+        private final Map<String, String> map;
+
+        private JsonErrorResponse(int statusCode, String errorCode, Map<String, String> map) {
+            this.statusCode = statusCode;
+            this.errorCode = errorCode;
+            this.map = map;
+            this.message = get("message");
+        }
+
+        /**
+         * Gets the status code of the response header
+         *
+         * @return status code
+         */
+        public int getStatusCode() {
+            return statusCode;
+        }
+
+        /**
+         * Gets the error code
+         *
+         * @return error code
+         */
+        public String getErrorCode() {
+            return errorCode;
+        }
+
+        /**
+         * Gets the error message
+         *
+         * @return error message
+         */
+        public String getMessage() {
+            return message;
+        }
+
+        /**
+         * Gets value from the error body map.
+         *
+         * @param key key of map
+         * @return null if key is null; "" if not exists
+         */
+        public String get(String key) {
+            if (key == null || key.length() == 0) {
+                return null;
+            }
+
+            String firstLetterUppercaseKey;
+            String firstLetterLowercaseKey;
+
+            firstLetterLowercaseKey = StringUtils.lowerCase(key.substring(0, 1))
+                    + key.substring(1);
+
+            firstLetterUppercaseKey = StringUtils.upperCase(key.substring(0, 1))
+                    + key.substring(1);
+
+            String value = "";
+            if (map.containsKey(firstLetterUppercaseKey)) {
+                value = map.get(firstLetterUppercaseKey);
+            } else if (map.containsKey(firstLetterLowercaseKey)) {
+                value = map.get(firstLetterLowercaseKey);
+            }
+
+            return value;
+        }
+
+        /**
+         * @param response The HTTP response.
+         * @return the JSONErrorResponse object.
+         * @throws IOException
+         */
+        public static JsonErrorResponse fromResponse(HttpResponse response) throws IOException {
+            int statusCode = response.getStatusCode();
+
+            // parse error body
+            Map<String, String> map = JsonUtils.jsonToMap(new BufferedReader(new InputStreamReader(
+                    response.getContent(), StringUtils.UTF8)));
+
+            /*
+             * Services using AWS JSON 1.1 protocol with HTTP binding send the
+             * error type information in the response headers, instead of the
+             * content.
+             */
+            String errorCode = response.getHeaders().get(X_AMZN_ERROR_TYPE);
+            if (errorCode != null) {
+                int separator = errorCode.indexOf(':');
+                if (separator != -1) {
+                    errorCode = errorCode.substring(0, separator);
+                }
+            } else if (map.containsKey("__type")) {
+                // check body otherwise
+                String type = map.get("__type");
+                int separator = type.lastIndexOf("#");
+                errorCode = type.substring(separator + 1);
+            }
+
+            return new JsonErrorResponse(statusCode, errorCode, map);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonResponseHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonResponseHandler.java
new file mode 100644
index 0000000000..41f6252f82
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/JsonResponseHandler.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.ResponseMetadata;
+import com.amazonaws.internal.CRC32MismatchException;
+import com.amazonaws.transform.JsonUnmarshallerContext;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.VoidJsonUnmarshaller;
+import com.amazonaws.util.CRC32ChecksumCalculatingInputStream;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.JsonUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.GZIPInputStream;
+
+/**
+ * Default implementation of HttpResponseHandler that handles a successful
+ * response from an AWS service and unmarshalls the result using a JSON
+ * unmarshaller.
+ *
+ * @param <T> Indicates the type being unmarshalled by this response handler.
+ */
+public class JsonResponseHandler<T> implements HttpResponseHandler<AmazonWebServiceResponse<T>> {
+
+    /** The JSON unmarshaller to use when handling the response */
+    private Unmarshaller<T, JsonUnmarshallerContext> responseUnmarshaller;
+
+    /** Shared logger for profiling information */
+    private static final Log log = LogFactory.getLog("com.amazonaws.request");
+
+    /** Boolean to indicate if connect needs to be left open. */
+    @SuppressWarnings({"checkstyle:constantname", "checkstyle:visibilitymodifier"})
+    public boolean needsConnectionLeftOpen = false;
+
+    /**
+     * Constructs a new response handler that will use the specified JSON
+     * unmarshaller to unmarshall the service response and uses the specified
+     * response element path to find the root of the business data in the
+     * service's response.
+     *
+     * @param responseUnmarshaller The JSON unmarshaller to use on the response.
+     */
+    public JsonResponseHandler(Unmarshaller<T, JsonUnmarshallerContext> responseUnmarshaller) {
+        this.responseUnmarshaller = responseUnmarshaller;
+
+        /*
+         * Even if the invoked operation just returns null, we still need an
+         * unmarshaller to run so we can pull out response metadata. We might
+         * want to pass this in through the client class so that we don't have
+         * to do this check here.
+         */
+        if (this.responseUnmarshaller == null) {
+            this.responseUnmarshaller = new VoidJsonUnmarshaller<T>();
+        }
+    }
+
+    /**
+     * @see com.amazonaws.http.HttpResponseHandler#handle(com.amazonaws.http.HttpResponse)
+     */
+    @Override
+    public AmazonWebServiceResponse<T> handle(HttpResponse response) throws Exception {
+        log.trace("Parsing service response JSON");
+
+        final String crc32Checksum = response.getHeaders().get("x-amz-crc32");
+        CRC32ChecksumCalculatingInputStream crc32ChecksumInputStream = null;
+
+        // Get the raw content input stream to calculate the crc32 checksum on
+        // gzipped data.
+        InputStream content = response.getRawContent();
+        if (content == null) {
+            // An empty input stream to avoid NPE
+            content = new ByteArrayInputStream("{}".getBytes(StringUtils.UTF8));
+        }
+
+        log.debug("CRC32Checksum = " + crc32Checksum);
+        log.debug("content encoding = " + response.getHeaders().get("Content-Encoding"));
+
+        if (crc32Checksum != null) {
+            crc32ChecksumInputStream = new CRC32ChecksumCalculatingInputStream(content);
+            if ("gzip".equals(response.getHeaders().get("Content-Encoding"))) {
+                content = new GZIPInputStream(crc32ChecksumInputStream);
+            } else {
+                content = crc32ChecksumInputStream;
+            }
+        }
+
+        final AwsJsonReader jsonReader = JsonUtils.getJsonReader(new InputStreamReader(content,
+                StringUtils.UTF8));
+
+        try {
+            final AmazonWebServiceResponse<T> awsResponse = new AmazonWebServiceResponse<T>();
+            final JsonUnmarshallerContext unmarshallerContext = new JsonUnmarshallerContext(jsonReader,
+                    response);
+
+            final T result = responseUnmarshaller.unmarshall(unmarshallerContext);
+
+            if (crc32Checksum != null) {
+                final long serverSideCRC = Long.parseLong(crc32Checksum);
+                final long clientSideCRC = crc32ChecksumInputStream.getCRC32Checksum();
+                if (clientSideCRC != serverSideCRC) {
+                    throw new CRC32MismatchException(
+                            "Client calculated crc32 checksum didn't match that calculated by server side");
+                }
+            }
+
+            awsResponse.setResult(result);
+
+            final Map<String, String> metadata = new HashMap<String, String>();
+            metadata.put(ResponseMetadata.AWS_REQUEST_ID,
+                    response.getHeaders().get("x-amzn-RequestId"));
+            awsResponse.setResponseMetadata(new ResponseMetadata(metadata));
+
+            log.trace("Done parsing service response");
+            return awsResponse;
+        } finally {
+            if (!needsConnectionLeftOpen) {
+                try {
+                    jsonReader.close();
+                } catch (final IOException e) {
+                    log.warn("Error closing json parser", e);
+                }
+            }
+        }
+    }
+
+    /**
+     * Hook for subclasses to override in order to collect additional metadata
+     * from service responses.
+     *
+     * @param unmarshallerContext The unmarshaller context used to process a
+     *            service's response data.
+     */
+    @Deprecated
+    protected void registerAdditionalMetadataExpressions(JsonUnmarshallerContext unmarshallerContext) {
+    }
+
+    /**
+     * Since this response handler completely consumes all the data from the
+     * underlying HTTP connection during the handle method, we don't need to
+     * keep the HTTP connection open.
+     *
+     * @see com.amazonaws.http.HttpResponseHandler#needsConnectionLeftOpen()
+     */
+    @Override
+    public boolean needsConnectionLeftOpen() {
+        return needsConnectionLeftOpen;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/RepeatableInputStreamRequestEntity.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/RepeatableInputStreamRequestEntity.java
new file mode 100644
index 0000000000..379247c0b6
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/RepeatableInputStreamRequestEntity.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.Request;
+import com.amazonaws.metrics.MetricInputStreamEntity;
+import com.amazonaws.metrics.ServiceMetricType;
+import com.amazonaws.metrics.ThroughputMetricType;
+import com.amazonaws.metrics.internal.ServiceMetricTypeGuesser;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.entity.InputStreamEntity;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Custom implementation of {@link RequestEntity} that delegates to an
+ * {@link InputStreamRequestEntity}, with the one notable difference, that if
+ * the underlying InputStream supports being reset, this RequestEntity will
+ * report that it is repeatable and will reset the stream on all subsequent
+ * attempts to write out the request.
+ */
+class RepeatableInputStreamRequestEntity extends BasicHttpEntity {
+
+    /** True if the request entity hasn't been written out yet */
+    private boolean firstAttempt = true;
+
+    /** The underlying InputStreamEntity being delegated to */
+    private InputStreamEntity inputStreamRequestEntity;
+
+    /** The InputStream containing the content to write out */
+    private InputStream content;
+
+    /** Shared logger for more debugging information */
+    private static final Log log = LogFactory.getLog(AmazonHttpClient.class);
+
+    /**
+     * Record the original exception if we do attempt a retry, so that if the
+     * retry fails, we can report the original exception. Otherwise, we're most
+     * likely masking the real exception with an error about not being able to
+     * reset far enough back in the input stream.
+     */
+    private IOException originalException;
+
+    /**
+     * Creates a new RepeatableInputStreamRequestEntity using the information
+     * from the specified request. If the input stream containing the request's
+     * contents is repeatable, then this RequestEntity will report as being
+     * repeatable.
+     *
+     * @param request The details of the request being written out (content
+     *            type, content length, and content).
+     */
+    RepeatableInputStreamRequestEntity(final Request<?> request) {
+        setChunked(false);
+
+        /*
+         * If we don't specify a content length when we instantiate our
+         * InputStreamRequestEntity, then HttpClient will attempt to buffer the
+         * entire stream contents into memory to determine the content length.
+         * TODO: It'd be nice to have easier access to content length and
+         * content type from the request, instead of having to look directly
+         * into the headers.
+         */
+        long contentLength = -1;
+        try {
+            String contentLengthString = request.getHeaders().get("Content-Length");
+            if (contentLengthString != null) {
+                contentLength = Long.parseLong(contentLengthString);
+            }
+        } catch (NumberFormatException nfe) {
+            log.warn("Unable to parse content length from request.  " +
+                    "Buffering contents in memory.");
+        }
+
+        String contentType = request.getHeaders().get("Content-Type");
+        ThroughputMetricType type = ServiceMetricTypeGuesser
+                .guessThroughputMetricType(request,
+                        ServiceMetricType.UPLOAD_THROUGHPUT_NAME_SUFFIX,
+                        ServiceMetricType.UPLOAD_BYTE_COUNT_NAME_SUFFIX);
+        if (type == null) {
+            inputStreamRequestEntity =
+                    new InputStreamEntity(request.getContent(), contentLength);
+        } else {
+            inputStreamRequestEntity =
+                    new MetricInputStreamEntity(type, request.getContent(), contentLength);
+        }
+        inputStreamRequestEntity.setContentType(contentType);
+        content = request.getContent();
+
+        setContent(content);
+        setContentType(contentType);
+        setContentLength(contentLength);
+    }
+
+    @Override
+    public boolean isChunked() {
+        return false;
+    }
+
+    /**
+     * Returns true if the underlying InputStream supports marking/reseting or
+     * if the underlying InputStreamRequestEntity is repeatable (i.e. its
+     * content length has been set to
+     * {@link InputStreamRequestEntity#CONTENT_LENGTH_AUTO} and therefore its
+     * entire contents will be buffered in memory and can be repeated).
+     *
+     * @see org.apache.commons.httpclient.methods.RequestEntity#isRepeatable()
+     */
+    @Override
+    public boolean isRepeatable() {
+        return content.markSupported() || inputStreamRequestEntity.isRepeatable();
+    }
+
+    /**
+     * Resets the underlying InputStream if this isn't the first attempt to
+     * write out the request, otherwise simply delegates to
+     * InputStreamRequestEntity to write out the data.
+     * <p>
+     * If an error is encountered the first time we try to write the request
+     * entity, we remember the original exception, and report that as the root
+     * cause if we continue to encounter errors, rather than masking the
+     * original error.
+     *
+     * @see org.apache.commons.httpclient.methods.RequestEntity#writeRequest(java.io.OutputStream)
+     */
+    @Override
+    public void writeTo(OutputStream output) throws IOException {
+        try {
+            if (!firstAttempt && isRepeatable())
+                content.reset();
+
+            firstAttempt = false;
+            inputStreamRequestEntity.writeTo(output);
+        } catch (IOException ioe) {
+            if (originalException == null)
+                originalException = ioe;
+            throw originalException;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/StaxResponseHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/StaxResponseHandler.java
new file mode 100644
index 0000000000..8ee2c5d1eb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/StaxResponseHandler.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.ResponseMetadata;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.VoidStaxUnmarshaller;
+import com.amazonaws.util.StringUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * Default implementation of HttpResponseHandler that handles a successful
+ * response from an AWS service and unmarshalls the result using a StAX
+ * unmarshaller.
+ *
+ * @param <T> Indicates the type being unmarshalled by this response handler.
+ */
+public class StaxResponseHandler<T> implements HttpResponseHandler<AmazonWebServiceResponse<T>> {
+
+    /** The StAX unmarshaller to use when handling the response */
+    private Unmarshaller<T, StaxUnmarshallerContext> responseUnmarshaller;
+
+    /** Shared logger for profiling information */
+    private static final Log log = LogFactory.getLog("com.amazonaws.request");
+
+    /** Shared factory for creating XML event readers */
+    private static final XmlPullParserFactory XML_PULL_PARSER_FACTORY;
+    static {
+        try {
+            XML_PULL_PARSER_FACTORY = XmlPullParserFactory.newInstance();
+        } catch (XmlPullParserException xppe) {
+            throw new AmazonClientException("Couldn't initialize XmlPullParserFactory", xppe);
+        }
+    }
+
+    /**
+     * Constructs a new response handler that will use the specified StAX
+     * unmarshaller to unmarshall the service response and uses the specified
+     * response element path to find the root of the business data in the
+     * service's response.
+     *
+     * @param responseUnmarshaller The StAX unmarshaller to use on the response.
+     */
+    public StaxResponseHandler(Unmarshaller<T, StaxUnmarshallerContext> responseUnmarshaller) {
+        this.responseUnmarshaller = responseUnmarshaller;
+
+        /*
+         * Even if the invoked operation just returns null, we still need an
+         * unmarshaller to run so we can pull out response metadata. We might
+         * want to pass this in through the client class so that we don't have
+         * to do this check here.
+         */
+        if (this.responseUnmarshaller == null) {
+            this.responseUnmarshaller = new VoidStaxUnmarshaller<T>();
+        }
+    }
+
+    /**
+     * @see com.amazonaws.http.HttpResponseHandler#handle(com.amazonaws.http.HttpResponse)
+     */
+    @Override
+    public AmazonWebServiceResponse<T> handle(HttpResponse response) throws Exception {
+        log.trace("Parsing service response XML");
+        InputStream content = response.getContent();
+        if (content == null)
+            content = new ByteArrayInputStream("<eof/>".getBytes(StringUtils.UTF8));
+
+        XmlPullParser xpp = XML_PULL_PARSER_FACTORY.newPullParser();
+        xpp.setInput(content, null);
+
+        AmazonWebServiceResponse<T> awsResponse = new AmazonWebServiceResponse<T>();
+        StaxUnmarshallerContext unmarshallerContext = new StaxUnmarshallerContext(xpp,
+                response.getHeaders());
+        unmarshallerContext.registerMetadataExpression("ResponseMetadata/RequestId", 2,
+                ResponseMetadata.AWS_REQUEST_ID);
+        unmarshallerContext.registerMetadataExpression("requestId", 2,
+                ResponseMetadata.AWS_REQUEST_ID);
+        registerAdditionalMetadataExpressions(unmarshallerContext);
+
+        T result = responseUnmarshaller.unmarshall(unmarshallerContext);
+        awsResponse.setResult(result);
+
+        Map<String, String> metadata = unmarshallerContext.getMetadata();
+        Map<String, String> responseHeaders = response.getHeaders();
+        if (responseHeaders != null) {
+            if (responseHeaders.get("x-amzn-RequestId") != null) {
+                metadata.put(ResponseMetadata.AWS_REQUEST_ID,
+                        responseHeaders.get("x-amzn-RequestId"));
+            }
+        }
+        awsResponse.setResponseMetadata(new ResponseMetadata(metadata));
+
+        log.trace("Done parsing service response");
+        return awsResponse;
+    }
+
+    /**
+     * Hook for subclasses to override in order to collect additional metadata
+     * from service responses.
+     *
+     * @param unmarshallerContext The unmarshaller context used to process a
+     *            service's response data.
+     */
+    protected void registerAdditionalMetadataExpressions(StaxUnmarshallerContext unmarshallerContext) {
+    }
+
+    /**
+     * Since this response handler completely consumes all the data from the
+     * underlying HTTP connection during the handle method, we don't need to
+     * keep the HTTP connection open.
+     *
+     * @see com.amazonaws.http.HttpResponseHandler#needsConnectionLeftOpen()
+     */
+    @Override
+    public boolean needsConnectionLeftOpen() {
+        return false;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/UrlHttpClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/UrlHttpClient.java
new file mode 100644
index 0000000000..4bd81a78e1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/UrlHttpClient.java
@@ -0,0 +1,483 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import com.amazonaws.ClientConfiguration;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.nio.BufferOverflowException;
+import java.nio.ByteBuffer;
+import java.security.GeneralSecurityException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+
+/**
+ * An implementation of {@link HttpClient} by {@link HttpURLConnection}. This is
+ * the recommended HTTP client in Android. Compared to {@link ApacheHttpClient},
+ * it has one limitation. When handling 'Expected 100-continue' header, it only
+ * accepts either 100 continue or 417 reject, and throws
+ * {@link ProtocolException} on other status code. Such limitation will cause
+ * some issue when talking to S3 service. See <a
+ * href="http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUT.html">S3's
+ * Put Object API</a> for the requirement of handling 100-continue.
+ */
+public class UrlHttpClient implements HttpClient {
+
+    private static final String TAG = "amazonaws";
+    private static final Log log = LogFactory.getLog(UrlHttpClient.class);
+    private static final int DEFAULT_BUFFER_SIZE = 1024;
+    private static final int BUFFER_SIZE_MULTIPLIER = 8;
+    private final ClientConfiguration config;
+
+    /**
+     * Constructor.
+     * @param config the client config.
+     */
+    public UrlHttpClient(ClientConfiguration config) {
+        this.config = config;
+    }
+
+    @Override
+    public HttpResponse execute(final HttpRequest request) throws IOException {
+        final URL url = request.getUri().toURL();
+        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        final CurlBuilder curlBuilder = config.isCurlLogging()
+                ? new CurlBuilder(request.getUri().toURL()) : null;
+
+        configureConnection(request, connection);
+        applyHeadersAndMethod(request, connection, curlBuilder);
+        writeContentToConnection(request, connection, curlBuilder);
+
+        if (curlBuilder != null) {
+            if (curlBuilder.isValid()) {
+                printToLog(curlBuilder.build());
+            } else {
+                printToLog("Failed to create curl, content too long");
+            }
+        }
+
+        return createHttpResponse(request, connection);
+    }
+
+    @SuppressWarnings("checkstyle:emptyblock")
+    HttpResponse createHttpResponse(final HttpRequest request, final HttpURLConnection connection)
+            throws IOException {
+        // connection.setDoOutput(true);
+        final String statusText = connection.getResponseMessage();
+        final int statusCode = connection.getResponseCode();
+        InputStream content = connection.getErrorStream();
+        if (content == null) {
+            // HEAD method doesn't have a body
+            if (!"HEAD".equals(request.getMethod())) {
+                try {
+                    content = connection.getInputStream();
+                } catch (final IOException ioe) {
+                    // getInputStream() can throw an exception when there is no
+                    // input stream.
+                }
+            }
+        }
+
+        final HttpResponse.Builder builder = HttpResponse.builder()
+                .statusCode(statusCode)
+                .statusText(statusText)
+                .content(content);
+        for (final Map.Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {
+            // skip null field that stores connection status
+            if (header.getKey() == null) {
+                continue;
+            }
+            // No AWS service return a list of header values, so it's safe to
+            // take the first one.
+            builder.header(header.getKey(), header.getValue().get(0));
+        }
+
+        return builder.build();
+    }
+
+    /**
+     * This is no op.
+     */
+    @Override
+    public void shutdown() {
+        // No op
+    }
+
+    /**
+     * Needed to pass UrlHttpClientTest.
+     *
+     * @see #writeContentToConnection(HttpRequest, HttpURLConnection,
+     *      CurlBuilder)
+     */
+    void writeContentToConnection(HttpRequest request, HttpURLConnection connection)
+            throws IOException {
+        writeContentToConnection(request, connection, null /* curlBuilder */);
+    }
+
+    /**
+     * Writes the content (if any) of the request to the passed connection
+     *
+     * @param request
+     * @param connection
+     * @param curlBuilder
+     * @throws IOException
+     */
+    void writeContentToConnection(final HttpRequest request, final HttpURLConnection connection,
+            final CurlBuilder curlBuilder) throws IOException {
+        // Note: if DoOutput is set to true and method is GET, HttpUrlConnection
+        // will silently change the method to POST.
+        if (request.getContent() != null && request.getContentLength() >= 0) {
+            connection.setDoOutput(true);
+            // This is for backward compatibility, because
+            // setFixedLengthStreamingMode(long) is available in API level 19.
+            if (!request.isStreaming()) {
+                connection.setFixedLengthStreamingMode((int) request.getContentLength());
+            }
+            final OutputStream os = connection.getOutputStream();
+            ByteBuffer curlBuffer = null;
+            if (curlBuilder != null) {
+                if (request.getContentLength() < Integer.MAX_VALUE) {
+                    curlBuffer = ByteBuffer.allocate((int) request.getContentLength());
+                } else {
+                    curlBuilder.setContentOverflow(true);
+                }
+            }
+            write(request.getContent(), os, curlBuilder, curlBuffer);
+            if (curlBuilder != null && curlBuffer != null && curlBuffer.position() != 0) {
+                // has content
+                curlBuilder.setContent(new String(curlBuffer.array(), "UTF-8"));
+            }
+            os.flush();
+            os.close();
+        }
+    }
+
+    /**
+     * Needed to pass UrlHttpClientTest.
+     *
+     * @see #applyHeadersAndMethod(HttpRequest, HttpURLConnection, CurlBuilder)
+     */
+    HttpURLConnection applyHeadersAndMethod(final HttpRequest request,
+            final HttpURLConnection connection) throws ProtocolException {
+        return applyHeadersAndMethod(request, connection, null /* curlBuilder */);
+    }
+
+    @SuppressWarnings("checkstyle:emptyblock")
+    HttpURLConnection applyHeadersAndMethod(final HttpRequest request,
+            final HttpURLConnection connection, final CurlBuilder curlBuilder)
+            throws ProtocolException {
+        // add headers
+        if (request.getHeaders() != null && !request.getHeaders().isEmpty()) {
+            if (curlBuilder != null) {
+                curlBuilder.setHeaders(request.getHeaders());
+            }
+            for (final Map.Entry<String, String> header : request.getHeaders().entrySet()) {
+                final String key = header.getKey();
+                // Skip reserved headers for HttpURLConnection
+                if (key.equals(HttpHeader.CONTENT_LENGTH) || key.equals(HttpHeader.HOST)) {
+                    continue;
+                }
+                /*
+                 * Amazon S3 suggests set 100-continue header prior to sending
+                 * the request body in order to improve efficiency. S3 may
+                 * return '100 Continue' or 417 (Expectation failed). It may
+                 * also respond with 307 to redirect the request to the correct
+                 * regional location, in which case HttpURLConection will throw
+                 * ProtocolException because it only expects either a 100 or a
+                 * 417 response. As a result, this feature is explicitly
+                 * disabled. To prevent sending the request body twice due to
+                 * redirect, please choose the correct endpoint.
+                 */
+                if (key.equals(HttpHeader.EXPECT)) {
+                    // continue;
+                }
+                connection.setRequestProperty(key, header.getValue());
+            }
+        }
+
+        final String method = request.getMethod();
+        connection.setRequestMethod(method);
+        if (curlBuilder != null) {
+            curlBuilder.setMethod(method);
+        }
+        return connection;
+    }
+
+    protected void printToLog(String message) {
+        log.debug(message);
+    }
+
+    protected HttpURLConnection getUrlConnection(URL url) throws IOException {
+        return (HttpURLConnection) url.openConnection();
+    }
+
+    private void write(InputStream is, OutputStream os, CurlBuilder curlBuilder,
+            ByteBuffer curlBuffer) throws IOException {
+        final byte[] buf = new byte[DEFAULT_BUFFER_SIZE * BUFFER_SIZE_MULTIPLIER];
+        int len;
+        while ((len = is.read(buf)) != -1) {
+            try {
+                if (curlBuffer != null) {
+                    curlBuffer.put(buf, 0 /* offset */, len);
+                }
+            } catch (final BufferOverflowException e) {
+                curlBuilder.setContentOverflow(true);
+            }
+            os.write(buf, 0, len);
+        }
+    }
+
+    void configureConnection(HttpRequest request, HttpURLConnection connection) {
+        // configure the connection
+        connection.setConnectTimeout(config.getConnectionTimeout());
+        connection.setReadTimeout(config.getSocketTimeout());
+        // disable redirect and cache
+        connection.setInstanceFollowRedirects(false);
+        connection.setUseCaches(false);
+        // is streaming
+        if (request.isStreaming()) {
+            connection.setChunkedStreamingMode(0);
+        }
+
+        // configure https connection
+        if (connection instanceof HttpsURLConnection) {
+            final HttpsURLConnection https = (HttpsURLConnection) connection;
+
+            // disable cert check
+            /*
+             * Commented as per https://support.google.com/faqs/answer/6346016. Uncomment for testing.
+            if (System.getProperty(DISABLE_CERT_CHECKING_SYSTEM_PROPERTY) != null) {
+                disableCertificateValidation(https);
+            }
+            */
+
+            if (config.getTrustManager() != null) {
+                enableCustomTrustManager(https);
+            }
+        }
+    }
+
+    private SSLContext sc = null;
+
+    private void enableCustomTrustManager(HttpsURLConnection connection) {
+        if (sc == null) {
+            final TrustManager[] customTrustManagers = new TrustManager[] {
+                    config.getTrustManager()
+            };
+            try {
+                sc = SSLContext.getInstance("TLS");
+                sc.init(null, customTrustManagers, null);
+            } catch (final GeneralSecurityException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        connection.setSSLSocketFactory(sc.getSocketFactory());
+    }
+
+    /*
+    private void disableCertificateValidation(HttpsURLConnection connection) {
+        if (sc == null) {
+            TrustManager[] trustAllCerts = new TrustManager[] {
+                    new TrustAllManager()
+            };
+            try {
+                // Install the all-trusting trust manager
+                sc = SSLContext.getInstance("TLS");
+                sc.init(null, trustAllCerts, null);
+            } catch (GeneralSecurityException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        connection.setSSLSocketFactory(sc.getSocketFactory());
+        connection.setHostnameVerifier(new AllowAllHostnameVerifier());
+    }
+    */
+    /**
+     * An allow all hostname verifier, only used internally for testing purpose.
+     */
+    /*
+    static class AllowAllHostnameVerifier implements HostnameVerifier {
+        @Override
+        public boolean verify(String hostname, SSLSession session) {
+            // Always return true to bypass host name verification
+            return true;
+        }
+    }
+    */
+    /**
+     * A trust all policy manager, only used internally for testing purpose.
+     */
+    /*
+    static class TrustAllManager implements X509TrustManager {
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return null;
+        }
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] certs, String authType) {
+            // No-op, to trust all certs
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] certs, String authType) {
+            // No-op, to trust all certs
+        }
+    }
+    */
+
+    /**
+     * Helper class to build a curl message.
+     */
+    protected final class CurlBuilder {
+
+        /** The {@link URL} of the operation. */
+        private final URL url;
+        /** The method to execute on the given url. */
+        private String method = null;
+        /**
+         * A map of headers and their values to be sent with the curl request.
+         */
+        private final HashMap<String, String> headers = new HashMap<String, String>();
+        /** The content to send with the curl request. */
+        private String content = null;
+        /** Whether or not the content cannot be written to the curl command. */
+        private boolean contentOverflow = false;
+
+        /**
+         * Builds a new curl command for the given {@link URL}.
+         *
+         * @param url The {@link URL} for the operation, must not be
+         *            {@code null}.
+         */
+        public CurlBuilder(URL url) {
+            if (url == null) {
+                throw new IllegalArgumentException("Must have a valid url");
+            }
+            this.url = url;
+        }
+
+        /**
+         * Set the method to call for the given curl command. This method will
+         * override the previous value.
+         *
+         * @param method The method to use for the request.
+         * @return This object for chaining.
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public CurlBuilder setMethod(String method) {
+            this.method = method;
+            return this;
+        }
+
+        /**
+         * Set the headers used for the given curl command. This method will
+         * override the previous values.
+         *
+         * @param headers The headers to use for the request.
+         * @return This object for chaining.
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public CurlBuilder setHeaders(Map<String, String> headers) {
+            this.headers.clear();
+            this.headers.putAll(headers);
+            return this;
+        }
+
+        /**
+         * Set the content used for the given curl command. This method will
+         * override the previous value.
+         *
+         * @param content The content to use for the request.
+         * @return This object for chaining.
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public CurlBuilder setContent(String content) {
+            this.content = content;
+            return this;
+        }
+
+        /**
+         * Sets whether or not the content is too large for the curl command.
+         * Content of length greater than {@link Integer#MAX_VALUE} are
+         * considered too long. If set, the curl should not be logged as it will
+         * be invalid.
+         *
+         * @param contentOverflow Whether or not the content is too long to
+         *            print.
+         * @return This object for chaining.
+         */
+        @SuppressWarnings("checkstyle:hiddenfield")
+        public CurlBuilder setContentOverflow(boolean contentOverflow) {
+            this.contentOverflow = contentOverflow;
+            return this;
+        }
+
+        /**
+         * @return Whether or not this object is valid for printing.
+         */
+        public boolean isValid() {
+            return !contentOverflow;
+        }
+
+        /**
+         * Creates a curl command that can be replayed from command line.
+         *
+         * @return The curl command.
+         * @throws IllegalStateException If {@link #isValid()} returns false.
+         */
+        public String build() {
+            if (!isValid()) {
+                throw new IllegalStateException("Invalid state, cannot create curl command");
+            }
+            final StringBuilder stringBuilder = new StringBuilder("curl");
+            if (method != null) {
+                stringBuilder.append(" -X ")
+                        .append(method);
+            }
+            for (final Map.Entry<String, String> entry : headers.entrySet()) {
+                stringBuilder.append(" -H \"")
+                        .append(entry.getKey())
+                        .append(":")
+                        .append(entry.getValue())
+                        .append("\"");
+            }
+            if (content != null) {
+                stringBuilder.append(" -d '")
+                        .append(content)
+                        .append("'");
+            }
+            return stringBuilder.append(" ")
+                    .append(url.toString())
+                    .toString();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionManagerFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionManagerFactory.java
new file mode 100644
index 0000000000..6c95dd9647
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionManagerFactory.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.conn;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.ClientConnectionRequest;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+/**
+ * The client connection manager factory class.
+ */
+public class ClientConnectionManagerFactory {
+    private static final Log log = LogFactory.getLog(ClientConnectionManagerFactory.class);
+
+    /**
+     * @return a wrapped instance of {@link ClientConnectionManager} to capture
+     * the necessary performance metrics.
+     *
+     * @param orig the target instance to be wrapped
+     */
+    public static ClientConnectionManager wrap(ClientConnectionManager orig) {
+        if (orig instanceof Wrapped)
+            throw new IllegalArgumentException();
+        final Class<?>[] interfaces = new Class<?>[] {
+            ClientConnectionManager.class,
+            Wrapped.class
+        };
+        return (ClientConnectionManager) Proxy.newProxyInstance(
+                // https://github.com/aws/aws-sdk-java/pull/48#issuecomment-29454423
+                ClientConnectionManagerFactory.class.getClassLoader(),
+                interfaces,
+                new Handler(orig));
+    }
+
+    /**
+     * The handler behind the dynamic proxy for {@link ClientConnectionManager}
+     * so that the any returned instance of {@link ClientConnectionRequest} can
+     * further wrapped for capturing performance metrics.
+     */
+    private static class Handler implements InvocationHandler {
+        private final ClientConnectionManager orig;
+
+        Handler(ClientConnectionManager real) {
+            this.orig = real;
+        }
+
+        @Override
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            try {
+                Object ret = method.invoke(orig, args);
+                return ret instanceof ClientConnectionRequest
+                        ? ClientConnectionRequestFactory.wrap((ClientConnectionRequest) ret)
+                        : ret;
+            } catch (InvocationTargetException e) {
+                log.debug("", e);
+                throw e.getCause();
+            }
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionRequestFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionRequestFactory.java
new file mode 100644
index 0000000000..4baf5c1d45
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/ClientConnectionRequestFactory.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.conn;
+
+import com.amazonaws.metrics.AwsSdkMetrics;
+import com.amazonaws.metrics.ServiceLatencyProvider;
+import com.amazonaws.util.AWSServiceMetrics;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.conn.ClientConnectionRequest;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+class ClientConnectionRequestFactory {
+    private static final Log log = LogFactory.getLog(ClientConnectionRequestFactory.class);
+    private static final Class<?>[] INTERFACES = {
+        ClientConnectionRequest.class,
+        Wrapped.class
+    };
+
+    /**
+     * Returns a wrapped instance of {@link ClientConnectionRequest} to capture
+     * the necessary performance metrics.
+     *
+     * @param orig the target instance to be wrapped
+     */
+    static ClientConnectionRequest wrap(ClientConnectionRequest orig) {
+        if (orig instanceof Wrapped)
+            throw new IllegalArgumentException();
+        return (ClientConnectionRequest) Proxy.newProxyInstance(
+                // https://github.com/aws/aws-sdk-java/pull/48#issuecomment-29454423
+                ClientConnectionRequestFactory.class.getClassLoader(),
+                INTERFACES,
+                new Handler(orig));
+    }
+
+    /**
+     * The handler behind the dynamic proxy for {@link ClientConnectionRequest}
+     * so that the latency of the
+     * {@link ClientConnectionRequest#getConnection(long, java.util.concurrent.TimeUnit)}
+     * can be captured.
+     */
+    private static class Handler implements InvocationHandler {
+        private final ClientConnectionRequest orig;
+
+        Handler(ClientConnectionRequest orig) {
+            this.orig = orig;
+        }
+
+        @Override
+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+            try {
+                if ("getConnection".equals(method.getName())) {
+                    ServiceLatencyProvider latencyProvider = new ServiceLatencyProvider(
+                            AWSServiceMetrics.HttpClientGetConnectionTime);
+                    try {
+                        return method.invoke(orig, args);
+                    } finally {
+                        AwsSdkMetrics.getServiceMetricCollector()
+                                .collectLatency(latencyProvider.endTiming());
+                    }
+                }
+                return method.invoke(orig, args);
+            } catch (InvocationTargetException e) {
+                log.debug("", e);
+                throw e.getCause();
+            }
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/Wrapped.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/Wrapped.java
new file mode 100644
index 0000000000..d76fe482cb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/conn/Wrapped.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.conn;
+
+/**
+ * An internal marker interface to defend against accidental recursive
+ * wrappings.
+ */
+interface Wrapped {
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/HttpRequestNoRetryHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/HttpRequestNoRetryHandler.java
new file mode 100644
index 0000000000..95f549dbee
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/HttpRequestNoRetryHandler.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.impl.client;
+
+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+/**
+ * The HttpRequestNoRetryHandler class.
+ */
+public final class HttpRequestNoRetryHandler extends DefaultHttpRequestRetryHandler {
+
+    /** Singleton. */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final HttpRequestNoRetryHandler Singleton = new HttpRequestNoRetryHandler();
+
+    private HttpRequestNoRetryHandler() {
+    }
+
+    @Override
+    public boolean retryRequest(
+            final IOException exception,
+            int executionCount,
+            final HttpContext context) {
+        return false;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpClient.java
new file mode 100644
index 0000000000..b577869434
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpClient.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.impl.client;
+
+import com.amazonaws.http.conn.ClientConnectionManagerFactory;
+import com.amazonaws.http.protocol.SdkHttpRequestExecutor;
+
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HttpRequestExecutor;
+
+/**
+ * SDK HTTP client class.
+ */
+public class SdkHttpClient extends DefaultHttpClient {
+
+    /**
+     * Constructor.
+     * @param conman the client connection manager.
+     * @param params the HTTP parameters.
+     */
+    public SdkHttpClient(
+            final ClientConnectionManager conman,
+            final HttpParams params) {
+        super(ClientConnectionManagerFactory.wrap(conman), params);
+    }
+
+    @Override
+    protected HttpRequestExecutor createRequestExecutor() {
+        return new SdkHttpRequestExecutor();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpRequestRetryHandler.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpRequestRetryHandler.java
new file mode 100644
index 0000000000..f011f14709
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/impl/client/SdkHttpRequestRetryHandler.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.impl.client;
+
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+
+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
+import org.apache.http.protocol.HttpContext;
+
+import java.io.IOException;
+
+/** The SdkHttpRequestRetryHandler class. */
+public final class SdkHttpRequestRetryHandler extends DefaultHttpRequestRetryHandler {
+
+    /** Singleton. */
+    @SuppressWarnings("checkstyle:constantname")
+    public static final SdkHttpRequestRetryHandler Singleton = new SdkHttpRequestRetryHandler();
+
+    private SdkHttpRequestRetryHandler() {
+    }
+
+    @Override
+    public boolean retryRequest(
+            final IOException exception,
+            int executionCount,
+            final HttpContext context) {
+        boolean retry = super.retryRequest(exception, executionCount, context);
+        if (retry) {
+            AWSRequestMetrics awsRequestMetrics = (AWSRequestMetrics) context
+                    .getAttribute(AWSRequestMetrics.class.getSimpleName());
+            if (awsRequestMetrics != null) {
+                awsRequestMetrics.incrementCounter(Field.HttpClientRetryCount);
+            }
+        }
+        return retry;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/http/protocol/SdkHttpRequestExecutor.java b/aws-java-sdk-core/src/main/java/com/amazonaws/http/protocol/SdkHttpRequestExecutor.java
new file mode 100644
index 0000000000..bb4372fb8d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/http/protocol/SdkHttpRequestExecutor.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.http.protocol;
+
+import com.amazonaws.util.AWSRequestMetrics;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+
+import org.apache.http.HttpClientConnection;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.protocol.HttpContext;
+import org.apache.http.protocol.HttpRequestExecutor;
+
+import java.io.IOException;
+
+/**
+ * Used to capture the http send-request and receive-response latency metrics of
+ * the http client library, with no retries involved.
+ */
+public class SdkHttpRequestExecutor extends HttpRequestExecutor {
+    @Override
+    protected HttpResponse doSendRequest(
+            final HttpRequest request,
+            final HttpClientConnection conn,
+            final HttpContext context)
+            throws IOException, HttpException {
+        AWSRequestMetrics awsRequestMetrics = (AWSRequestMetrics) context
+                .getAttribute(AWSRequestMetrics.class.getSimpleName());
+        if (awsRequestMetrics == null) {
+            return super.doSendRequest(request, conn, context);
+        }
+        awsRequestMetrics.startEvent(Field.HttpClientSendRequestTime);
+        try {
+            return super.doSendRequest(request, conn, context);
+        } finally {
+            awsRequestMetrics.endEvent(Field.HttpClientSendRequestTime);
+        }
+    }
+
+    @Override
+    protected HttpResponse doReceiveResponse(
+            final HttpRequest request,
+            final HttpClientConnection conn,
+            final HttpContext context)
+            throws HttpException, IOException {
+        AWSRequestMetrics awsRequestMetrics = (AWSRequestMetrics) context
+                .getAttribute(AWSRequestMetrics.class.getSimpleName());
+        if (awsRequestMetrics == null) {
+            return super.doReceiveResponse(request, conn, context);
+        }
+        awsRequestMetrics.startEvent(Field.HttpClientReceiveResponseTime);
+        try {
+            return super.doReceiveResponse(request, conn, context);
+        } finally {
+            awsRequestMetrics.endEvent(Field.HttpClientReceiveResponseTime);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CRC32MismatchException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CRC32MismatchException.java
new file mode 100644
index 0000000000..21139fe867
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CRC32MismatchException.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import java.io.IOException;
+
+/**
+ * The exception will be thrown when client side CRC32 checksum does not match
+ * the one from server side.
+ */
+public class CRC32MismatchException extends IOException {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Creates a new CRC32MismatchException with the specified message, and root
+     * cause.
+     *
+     * @param message An error message describing why this exception was thrown.
+     * @param t The underlying cause of this exception.
+     */
+    public CRC32MismatchException(String message, Throwable t) {
+        super(message, t);
+    }
+
+    /**
+     * Creates a new CRC32MismatchException with the specified message.
+     *
+     * @param message An error message describing why this exception was thrown.
+     */
+    public CRC32MismatchException(String message) {
+        super(message);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CustomBackoffStrategy.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CustomBackoffStrategy.java
new file mode 100644
index 0000000000..24e990f974
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/CustomBackoffStrategy.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+public abstract class CustomBackoffStrategy {
+    public abstract int getBackoffPeriod(int retryAttempts);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/DynamoDBBackoffStrategy.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/DynamoDBBackoffStrategy.java
new file mode 100644
index 0000000000..124a87a0f7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/DynamoDBBackoffStrategy.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+public class DynamoDBBackoffStrategy extends CustomBackoffStrategy {
+    @Override
+    public int getBackoffPeriod(int retries) {
+
+        if (retries <= 0) {
+            return 0;
+        } else {
+
+            int delay = 50 * (int) Math.pow(2, retries - 1);
+
+            if (delay < 0) {
+                delay = Integer.MAX_VALUE;
+            }
+
+            return delay;
+        }
+
+    }
+
+    public static final CustomBackoffStrategy DEFAULT = new DynamoDBBackoffStrategy();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ListWithAutoConstructFlag.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ListWithAutoConstructFlag.java
new file mode 100644
index 0000000000..b60dde01a7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ListWithAutoConstructFlag.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * List with auto construct flag to indicate whether it is auto constructed by
+ * Java SDK.
+ */
+public class ListWithAutoConstructFlag<T> extends ArrayList<T> {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Auto construct flag to indicate whether the list is auto constructed by
+     * Java SDK.
+     */
+    private boolean autoConstruct;
+
+    public ListWithAutoConstructFlag() {
+        super();
+    }
+
+    public ListWithAutoConstructFlag(Collection<? extends T> c) {
+        super(c);
+    }
+
+    public ListWithAutoConstructFlag(int initialCapacity) {
+        super(initialCapacity);
+    }
+
+    public void setAutoConstruct(boolean autoConstruct) {
+        this.autoConstruct = autoConstruct;
+    }
+
+    /**
+     * Return true if the list is auto constructed by Java SDK
+     */
+    public boolean isAutoConstruct() {
+        return autoConstruct;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/MetricAware.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/MetricAware.java
new file mode 100644
index 0000000000..91c174d704
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/MetricAware.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+/**
+ * Used to check if any metrics gathering activity is already turned on in one
+ * of the underlying wrapped objects.
+ */
+@Deprecated
+public interface MetricAware {
+    /**
+     * Returns true if this object or one of it's inner wrapped objects has
+     * metrics gathering activity turned on; false otherwise.
+     */
+    public boolean isMetricActivated();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/Releasable.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/Releasable.java
new file mode 100644
index 0000000000..23920cde95
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/Releasable.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2014-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.internal;
+
+import java.io.Closeable;
+
+/**
+ * Used for releasing a resource.
+ * <p>
+ * For example, the creation of a <code>ResettableInputStream</code> would entail
+ * physically opening a file. If the opened file is meant to be closed only (in
+ * a finally block) by the very same code block that created it, then it is
+ * necessary that the release method must not be called while the execution is
+ * made in other stack frames.
+ * 
+ * In such case, as other stack frames may inadvertently or indirectly call the
+ * close method of the stream, the creator of the stream would need to
+ * explicitly disable the accidental closing via
+ * <code>ResettableInputStream#disableClose()</code>, so that the release method
+ * becomes the only way to truly close the opened file.
+ */
+public interface Releasable {
+    /**
+     * Releases the allocated resource. This method should not be called except
+     * by the caller who allocated the resource at the very top of the call
+     * stack. This allows, typically, a {@link Closeable} resource to be not
+     * unintentionally released owing to the calling of the
+     * {@link Closeable#close()} methods by implementation deep down in the call
+     * stack.
+     * <p>
+     * For example, the creation of a <code>ResettableInputStream</code> would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames.
+     * 
+     * In such case, as other stack frames may inadvertently or indirectly call
+     * the close method of the stream, the creator of the stream would need to
+     * explicitly disable the accidental closing via
+     * <code>ResettableInputStream#disableClose()</code>, so that the release method
+     * becomes the only way to truly close the opened file.
+     */
+    public void release();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ReleasableInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ReleasableInputStream.java
new file mode 100644
index 0000000000..206d471ff8
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ReleasableInputStream.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2014-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.internal;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.FileInputStream;
+import java.io.InputStream;
+
+/**
+ * An input stream that can have the close operation disabled (to avoid
+ * accidentally being closed). This is necessary, for example, when an input
+ * stream needs to be marked-and-reset multiple times but only as long as the
+ * input stream has not been closed. To survive not being accidentally closed,
+ * the close method can be disabled via {@link #disableClose()}.
+ * <p>
+ * The creator of this input stream should therefore always call
+ * {@link #release()} in a finally block to truly release the underlying
+ * resources.
+ *
+ * @see Releasable
+ * @see ResettableInputStream
+ */
+public class ReleasableInputStream extends SdkFilterInputStream implements Releasable {
+    private static final Log log = LogFactory
+            .getLog(ReleasableInputStream.class);
+    /**
+     * True if the close method is disabled; false otherwise. Default is false.
+     * In case the close method is disabled, caller would be responsible to
+     * release resources via {@link #release()}.
+     */
+    private boolean closeDisabled;
+
+    /**
+     * This constructor is not meant to be used directly. Use
+     * {@link #wrap(InputStream)} instead.
+     */
+    protected ReleasableInputStream(InputStream is) {
+        super(is);
+    }
+
+    /**
+     * If {@link #closeDisabled} is false, closes this input stream and releases
+     * any system resources associated with the stream. Otherwise, this method
+     * does nothing.
+     */
+    @Override
+    public final void close() {
+        if (!closeDisabled) {
+            doRelease();
+        }
+    }
+
+    /**
+     * Closes the underlying stream file and releases any system resources associated.
+     */
+    @Override
+    public final void release() {
+        doRelease();
+    }
+
+    /**
+     * Used to truly release the underlying resources.
+     */
+    private void doRelease() {
+        try {
+            in.close();
+        } catch (final Exception ex) {
+            if (log.isDebugEnabled()) {
+                log.debug("FYI", ex);
+            }
+        }
+        if (in instanceof Releasable) {
+            // This allows any underlying stream that has the close operation
+            // disabled to be truly released
+            final Releasable r = (Releasable)in;
+            r.release();
+        }
+        abortIfNeeded();
+    }
+
+    /**
+     * Returns true if the close method has been disabled; false otherwise. Once
+     * the close method is disabled, caller would be responsible to release
+     * resources via {@link #release()}.
+     */
+    public final boolean isCloseDisabled() {
+        return closeDisabled;
+    }
+
+    /**
+     * Used to disable the close method. Once the close method is disabled,
+     * caller would be responsible to release resources via {@link #release()}.
+     */
+    public final <T extends ReleasableInputStream> T disableClose() {
+        this.closeDisabled = true;
+        @SuppressWarnings("unchecked")
+        final
+        T t = (T)this;
+        return t;
+    }
+
+    /**
+     * Wraps the given input stream into a {@link ReleasableInputStream} if
+     * necessary. Note if the given input stream is a {@link FileInputStream}, a
+     * {@link ResettableInputStream} which is a specific subclass of
+     * {@link ReleasableInputStream} will be returned.
+     */
+    public static ReleasableInputStream wrap(InputStream is) {
+        if (is instanceof ReleasableInputStream)
+         {
+            return (ReleasableInputStream)is;   // already wrapped
+        }
+        if (is instanceof FileInputStream) {
+            return ResettableInputStream.newResettableInputStream((FileInputStream)is);
+        }
+        return new ReleasableInputStream(is);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ResettableInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ResettableInputStream.java
new file mode 100644
index 0000000000..928da48254
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/ResettableInputStream.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2014-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.internal;
+
+import com.amazonaws.AmazonClientException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.channels.FileChannel;
+
+/**
+ * A mark-and-resettable input stream that can be used on files or file input
+ * streams.
+ *
+ * In particular, a {@link ResettableInputStream} allows the close operation to
+ * be disabled via {@link #disableClose()} (to avoid accidentally being closed).
+ * This is necessary when such input stream needs to be marked-and-reset
+ * multiple times but only as long as the stream has not been closed.
+ * <p>
+ * The creator of this input stream should therefore always call
+ * {@link #release()} in a finally block to truly release the underlying
+ * resources.
+ *
+ * @see Releasable
+ */
+public class ResettableInputStream extends ReleasableInputStream {
+    private static final Log log = LogFactory
+            .getLog(ResettableInputStream.class);
+    private final File file; // null if the file is not known
+    private final FileInputStream fis; // never null
+    private final FileChannel fileChannel; // never null
+    /**
+     * Marked position of the file; default to zero.
+     */
+    private long markPos;
+
+    /**
+     * @param file
+     *            must not be null. Upon successful construction the the file
+     *            will be opened with an input stream automatically marked at
+     *            the starting position of the given file.
+     *            <p>
+     *            Note the creation of a {@link ResettableInputStream} would
+     *            entail physically opening a file. If the opened file is meant
+     *            to be closed only (in a finally block) by the very same code
+     *            block that created it, then it is necessary that the release
+     *            method must not be called while the execution is made in other
+     *            stack frames.
+     *
+     *            In such case, as other stack frames may inadvertently or
+     *            indirectly call the close method of the stream, the creator of
+     *            the stream would need to explicitly disable the accidental
+     *            closing via {@link ResettableInputStream#disableClose()}, so
+     *            that the release method becomes the only way to truly close
+     *            the opened file.
+     */
+    public ResettableInputStream(File file) throws IOException {
+        this(new FileInputStream(file), file);
+    }
+
+    /**
+     * @param fis
+     *            file input stream; must not be null. Upon successful
+     *            construction the input stream will be automatically marked at
+     *            the current position of the given file input stream.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames.
+     *
+     * In such case, as other stack frames may inadvertently or indirectly call
+     * the close method of the stream, the creator of the stream would need to
+     * explicitly disable the accidental closing via
+     * {@link ResettableInputStream#disableClose()}, so that the release method
+     * becomes the only way to truly close the opened file.
+     */
+    public ResettableInputStream(FileInputStream fis) throws IOException {
+        this(fis, null);
+    }
+
+    /**
+     * @param file
+     *            can be null if not known
+     */
+    private ResettableInputStream(FileInputStream fis, File file) throws IOException {
+        super(fis);
+        this.file = file;
+        this.fis = fis;
+        this.fileChannel = fis.getChannel();
+        this.markPos = fileChannel.position();
+    }
+
+    @Override
+    public final boolean markSupported() {
+        return true;
+    }
+
+    /**
+     * Marks the current position in this input stream. A subsequent call to
+     * the <code>reset</code> method repositions this stream at the last marked
+     * position so that subsequent reads re-read the same bytes.
+     * This method works as long as the underlying file has not been closed.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames.
+     *
+     * In such case, as other stack frames may inadvertently or indirectly call
+     * the close method of the stream, the creator of the stream would need to
+     * explicitly disable the accidental closing via
+     * {@link ResettableInputStream#disableClose()}, so that the release method
+     * becomes the only way to truly close the opened file.
+     *
+     * @param _
+     *            ignored
+     */
+    @Override
+    public void mark(int _) {
+        abortIfNeeded();
+        try {
+            markPos = fileChannel.position();
+        } catch (final IOException e) {
+            throw new AmazonClientException("Failed to mark the file position", e);
+        }
+        if (log.isTraceEnabled()) {
+            log.trace("File input stream marked at position " + markPos);
+        }
+    }
+
+    /**
+     * Repositions this stream to the position at the time the
+     * <code>mark</code> method was last called on this input stream.
+     * This method works as long as the underlying file has not been closed.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames.
+     *
+     * In such case, as other stack frames may inadvertently or indirectly call
+     * the close method of the stream, the creator of the stream would need to
+     * explicitly disable the accidental closing via
+     * {@link ResettableInputStream#disableClose()}, so that the release method
+     * becomes the only way to truly close the opened file.
+     */
+    @Override
+    public void reset() throws IOException {
+        abortIfNeeded();
+        fileChannel.position(markPos);
+        if (log.isTraceEnabled()) {
+            log.trace("Reset to position " + markPos);
+        }
+    }
+
+    @Override
+    public int available() throws IOException {
+        abortIfNeeded();
+        return fis.available();
+    }
+
+    @Override
+    public int read() throws IOException {
+        abortIfNeeded();
+        return fis.read();
+    }
+
+    @Override
+    public long skip(long n) throws IOException {
+        abortIfNeeded();
+        return fis.skip(n);
+    }
+
+    @Override
+    public int read(byte[] arg0, int arg1, int arg2) throws IOException {
+        abortIfNeeded();
+        return fis.read(arg0, arg1, arg2);
+    }
+
+    /**
+     * Returns the underlying file, if known; or null if not;
+     */
+    public File getFile() {
+        return file;
+    }
+
+    /**
+     * Convenient factory method to construct a new resettable input stream for
+     * the given file, converting any IOException into AmazonClientException.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames. In such case, as other stack
+     * frames may inadvertently or indirectly call the close method of the
+     * stream, the creator of the stream would need to explicitly disable the
+     * accidental closing via {@link ResettableInputStream#disableClose()}, so
+     * that the release method becomes the only way to truly close the opened
+     * file.
+     */
+    public static ResettableInputStream newResettableInputStream(File file) {
+        return newResettableInputStream(file, null);
+    }
+
+    /**
+     * Convenient factory method to construct a new resettable input stream for
+     * the given file, converting any IOException into AmazonClientException
+     * with the given error message.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames. In such case, as other stack
+     * frames may inadvertently or indirectly call the close method of the
+     * stream, the creator of the stream would need to explicitly disable the
+     * accidental closing via {@link ResettableInputStream#disableClose()}, so
+     * that the release method becomes the only way to truly close the opened
+     * file.
+     */
+    public static ResettableInputStream newResettableInputStream(File file,
+            String errmsg) {
+        try {
+            return new ResettableInputStream(file);
+        } catch (final IOException e) {
+            throw errmsg == null
+                    ? new AmazonClientException(e)
+                    : new AmazonClientException(errmsg, e);
+        }
+    }
+
+    /**
+     * Convenient factory method to construct a new resettable input stream for
+     * the given file input stream, converting any IOException into
+     * AmazonClientException.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames. In such case, as other stack
+     * frames may inadvertently or indirectly call the close method of the
+     * stream, the creator of the stream would need to explicitly disable the
+     * accidental closing via {@link ResettableInputStream#disableClose()}, so
+     * that the release method becomes the only way to truly close the opened
+     * file.
+     */
+    public static ResettableInputStream newResettableInputStream(
+            FileInputStream fis) {
+        return newResettableInputStream(fis, null);
+    }
+
+    /**
+     * Convenient factory method to construct a new resettable input stream for
+     * the given file input stream, converting any IOException into
+     * AmazonClientException with the given error message.
+     * <p>
+     * Note the creation of a {@link ResettableInputStream} would entail
+     * physically opening a file. If the opened file is meant to be closed only
+     * (in a finally block) by the very same code block that created it, then it
+     * is necessary that the release method must not be called while the
+     * execution is made in other stack frames. In such case, as other stack
+     * frames may inadvertently or indirectly call the close method of the
+     * stream, the creator of the stream would need to explicitly disable the
+     * accidental closing via {@link ResettableInputStream#disableClose()}, so
+     * that the release method becomes the only way to truly close the opened
+     * file.
+     */
+    public static ResettableInputStream newResettableInputStream(
+            FileInputStream fis, String errmsg) {
+        try {
+            return new ResettableInputStream(fis);
+        } catch (final IOException e) {
+            throw new AmazonClientException(errmsg, e);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkDigestInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkDigestInputStream.java
new file mode 100644
index 0000000000..6f416baebc
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkDigestInputStream.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+
+/**
+ * Base class for AWS Android SDK specific {@link DigestInputStream}.
+ */
+public class SdkDigestInputStream extends DigestInputStream implements MetricAware {
+    private static final int SKIP_BUF_SIZE = 2 * 1024;
+
+    public SdkDigestInputStream(InputStream stream, MessageDigest digest) {
+        super(stream, digest);
+    }
+
+    @Override
+    @Deprecated
+    public final boolean isMetricActivated() {
+        if (in instanceof MetricAware) {
+            MetricAware metricAware = (MetricAware) in;
+            return metricAware.isMetricActivated();
+        }
+        return false;
+    }
+
+    // https://github.com/aws/aws-sdk-java/issues/232
+    /**
+     * Skips over and discards <code>n</code> bytes of data from this input
+     * stream, while taking the skipped bytes into account for digest
+     * calculation. The <code>skip</code> method may, for a variety of reasons,
+     * end up skipping over some smaller number of bytes, possibly
+     * <code>0</code>. This may result from any of a number of conditions;
+     * reaching end of file before <code>n</code> bytes have been skipped is
+     * only one possibility. The actual number of bytes skipped is returned. If
+     * <code>n</code> is negative, no bytes are skipped.
+     * <p>
+     * The <code>skip</code> method of this class creates a byte array and then
+     * repeatedly reads into it until <code>n</code> bytes have been read or the
+     * end of the stream has been reached. Subclasses are encouraged to provide
+     * a more efficient implementation of this method. For instance, the
+     * implementation may depend on the ability to seek.
+     *
+     * @param n the number of bytes to be skipped.
+     * @return the actual number of bytes skipped.
+     * @exception IOException if the stream does not support seek, or if some
+     *                other I/O error occurs.
+     */
+    @Override
+    public final long skip(final long n) throws IOException {
+        if (n <= 0)
+            return n;
+        byte[] b = new byte[(int) Math.min(SKIP_BUF_SIZE, n)];
+        long m = n; // remaining number of bytes to read
+        while (m > 0) {
+            int len = read(b, 0, (int) Math.min(m, b.length));
+            if (len == -1)
+                return (m == n) ? -1 : (n - m);
+            m -= len;
+        }
+        assert (m == 0);
+        return n;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterInputStream.java
new file mode 100644
index 0000000000..f4525f4a81
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterInputStream.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import com.amazonaws.AbortedException;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Base class for AWS Java SDK specific {@link FilterInputStream}.
+ */
+public class SdkFilterInputStream extends FilterInputStream implements MetricAware {
+    protected SdkFilterInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    @Deprecated
+    public boolean isMetricActivated() {
+        if (in instanceof MetricAware) {
+            MetricAware metricAware = (MetricAware) in;
+            return metricAware.isMetricActivated();
+        }
+        return false;
+    }
+
+    /**
+     * Aborts with subclass specific abortion logic executed if needed. Note the
+     * interrupted status of the thread is cleared by this method.
+     *
+     * @throws AbortedException if found necessary.
+     */
+    protected final void abortIfNeeded() {
+        if (Thread.interrupted()) {
+            abort(); // execute subclass specific abortion logic
+            throw new AbortedException();
+        }
+    }
+
+    /**
+     * Can be used to provide abortion logic prior to throwing the
+     * AbortedException. No-op by default.
+     */
+    protected void abort() {
+        // no-op by default, but subclass such as S3ObjectInputStream may
+        // override
+    }
+
+    @Override
+    public int read() throws IOException {
+        abortIfNeeded();
+        return in.read();
+    }
+
+    @Override
+    public int read(byte b[], int off, int len) throws IOException {
+        abortIfNeeded();
+        return in.read(b, off, len);
+    }
+
+    @Override
+    public long skip(long n) throws IOException {
+        abortIfNeeded();
+        return in.skip(n);
+    }
+
+    @Override
+    public int available() throws IOException {
+        abortIfNeeded();
+        return in.available();
+    }
+
+    @Override
+    public void close() throws IOException {
+        in.close();
+        abortIfNeeded();
+    }
+
+    @Override
+    public synchronized void mark(int readlimit) {
+        abortIfNeeded();
+        in.mark(readlimit);
+    }
+
+    @Override
+    public synchronized void reset() throws IOException {
+        abortIfNeeded();
+        in.reset();
+    }
+
+    @Override
+    public boolean markSupported() {
+        abortIfNeeded();
+        return in.markSupported();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterOutputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterOutputStream.java
new file mode 100644
index 0000000000..fbecbfe22b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkFilterOutputStream.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import java.io.FilterOutputStream;
+import java.io.OutputStream;
+
+/**
+ * Base class for AWS Java SDK specific {@link FilterOutputStream}.
+ * 
+ * @deprecated class only adds metrics, which is deprecated
+ */
+@Deprecated
+public class SdkFilterOutputStream extends FilterOutputStream implements MetricAware {
+    public SdkFilterOutputStream(OutputStream out) {
+        super(out);
+    }
+
+    @Override
+    public boolean isMetricActivated() {
+        if (out instanceof MetricAware) {
+            MetricAware metricAware = (MetricAware) out;
+            return metricAware.isMetricActivated();
+        }
+        return false;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkInputStream.java
new file mode 100644
index 0000000000..62665c5809
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/SdkInputStream.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2014-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import com.amazonaws.AbortedException;
+
+import org.apache.commons.logging.LogFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Base class for AWS Java SDK specific {@link InputStream}.
+ */
+public abstract class SdkInputStream extends InputStream implements MetricAware {
+    /**
+     * Returns the underlying input stream, if any, from the subclass; or null
+     * if there is no underlying input stream.
+     */
+    abstract protected InputStream getWrappedInputStream();
+
+    @Override
+    @Deprecated
+    public final boolean isMetricActivated() {
+        InputStream in = getWrappedInputStream();
+        if (in instanceof MetricAware) {
+            MetricAware metricAware = (MetricAware) in;
+            return metricAware.isMetricActivated();
+        }
+        return false;
+    }
+
+    /**
+     * Aborts with subclass specific abortion logic executed if needed. Note the
+     * interrupted status of the thread is cleared by this method.
+     *
+     * @throws AbortedException if found necessary.
+     */
+    protected final void abortIfNeeded() {
+        if (Thread.interrupted()) {
+            try {
+                abort(); // execute subclass specific abortion logic
+            } catch (IOException e) {
+                LogFactory.getLog(getClass()).debug("FYI", e);
+            }
+            throw new AbortedException();
+        }
+    }
+
+    /**
+     * Can be used to provide abortion logic prior to throwing the
+     * AbortedException. No-op by default.
+     */
+    protected void abort() throws IOException {
+        // no-op by default, but subclass such as S3ObjectInputStream may
+        // override
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/StaticCredentialsProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/StaticCredentialsProvider.java
new file mode 100644
index 0000000000..ed48a1ddbc
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/StaticCredentialsProvider.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.AWSCredentialsProvider;
+
+/**
+ * Simple implementation of AWSCredentialsProvider that just wraps static
+ * AWSCredentials.
+ */
+public class StaticCredentialsProvider implements AWSCredentialsProvider {
+
+    private final AWSCredentials credentials;
+
+    public StaticCredentialsProvider(AWSCredentials credentials) {
+        this.credentials = credentials;
+    }
+
+    @Override
+    public AWSCredentials getCredentials() {
+        return credentials;
+    }
+
+    @Override
+    public void refresh() {
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HostRegexToRegionMapping.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HostRegexToRegionMapping.java
new file mode 100644
index 0000000000..a2142034df
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HostRegexToRegionMapping.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal.config;
+
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+public class HostRegexToRegionMapping {
+    private final String hostNameRegex;
+    private final String regionName;
+
+    public HostRegexToRegionMapping(
+            String hostNameRegex, String regionName) {
+        if (hostNameRegex == null || hostNameRegex.isEmpty()) {
+            throw new IllegalArgumentException(
+                    "Invalid HostRegexToRegionMapping configuration: " +
+                            "hostNameRegex must be non-empty");
+        }
+        try {
+            Pattern.compile(hostNameRegex);
+        } catch (PatternSyntaxException e) {
+            throw new IllegalArgumentException(
+                    "Invalid HostRegexToRegionMapping configuration: " +
+                            "hostNameRegex is not a valid regex",
+                    e);
+        }
+        if (regionName == null || regionName.isEmpty()) {
+            throw new IllegalArgumentException(
+                    "Invalid HostRegexToRegionMapping configuration: " +
+                            "regionName must be non-empty");
+        }
+        this.hostNameRegex = hostNameRegex;
+        this.regionName = regionName;
+    }
+
+    public String getHostNameRegex() {
+        return hostNameRegex;
+    }
+
+    public String getRegionName() {
+        return regionName;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HttpClientConfig.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HttpClientConfig.java
new file mode 100644
index 0000000000..2cbd07a3a0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/HttpClientConfig.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal.config;
+
+/**
+ * AWS HttpClient configuration.
+ */
+public class HttpClientConfig {
+    // This class is not strictly necessary for the existing use cases,
+    // but allows future expansion of additional configurations to be made
+    // with ease.
+    private final String serviceName;
+
+    HttpClientConfig(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    @Override
+    public String toString() {
+        return "serviceName: " + serviceName;
+    }
+
+    public String getServiceName() {
+        return serviceName;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/InternalConfig.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/InternalConfig.java
new file mode 100644
index 0000000000..6d7f080800
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/InternalConfig.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal.config;
+
+import com.amazonaws.regions.Regions;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Internal configuration for the AWS Android SDK.
+ */
+public class InternalConfig {
+    private static final Log log = LogFactory.getLog(InternalConfig.class);
+    private static final String SERVICE_REGION_DELIMITOR = "/";
+
+    private final SignerConfig defaultSignerConfig;
+    private final Map<String, SignerConfig> serviceRegionSigners;
+    private final Map<String, SignerConfig> regionSigners;
+    private final Map<String, SignerConfig> serviceSigners;
+    private final Map<String, HttpClientConfig> httpClients;
+    private final List<HostRegexToRegionMapping> hostRegexToRegionMappings;
+
+    InternalConfig() {
+        defaultSignerConfig = getDefaultSigner();
+        regionSigners = getDefaultRegionSigners();
+        serviceSigners = getDefaultServiceSigners();
+        serviceRegionSigners = getDefaultServiceRegionSigners();
+        httpClients = getDefaultHttpClients();
+        hostRegexToRegionMappings = getDefaultHostRegexToRegionMappings();
+    }
+
+    /**
+     * Returns the signer configuration for the specified service, not specific
+     * to any region.
+     */
+    public SignerConfig getSignerConfig(String serviceName) {
+        return getSignerConfig(serviceName, null);
+    }
+
+    /**
+     * Returns the http client configuration for the http client name.
+     */
+    public HttpClientConfig getHttpClientConfig(String httpClientName) {
+        return httpClients.get(httpClientName);
+    }
+
+    /**
+     * Returns the signer configuration for the specified service name and an
+     * optional region name.
+     *
+     * @param serviceName must not be null
+     * @param regionName similar to the region name in {@link Regions}; can be
+     *            null.
+     * @return the signer
+     */
+    public SignerConfig getSignerConfig(String serviceName, String regionName) {
+        if (serviceName == null) {
+            throw new IllegalArgumentException();
+        }
+        SignerConfig signerConfig = null;
+        if (regionName != null) {
+            // Service+Region signer config has the highest precedence
+            final String key = serviceName + SERVICE_REGION_DELIMITOR + regionName;
+            signerConfig = serviceRegionSigners.get(key);
+            if (signerConfig != null) {
+                return signerConfig;
+            }
+            // Region signer config has the 2nd highest precedence
+            signerConfig = regionSigners.get(regionName);
+            if (signerConfig != null) {
+                return signerConfig;
+            }
+        }
+        // Service signer config has the 3rd highest precedence
+        signerConfig = serviceSigners.get(serviceName);
+        // Fall back to the default
+        return signerConfig == null ? defaultSignerConfig : signerConfig;
+    }
+
+    /**
+     * @return all the host-name-regex to region-name mappings.
+     */
+    public List<HostRegexToRegionMapping> getHostRegexToRegionMappings() {
+        return Collections.unmodifiableList(hostRegexToRegionMappings);
+    }
+
+    private static Map<String, HttpClientConfig> getDefaultHttpClients() {
+        // map from service client name to sigv4 service name
+        final Map<String, HttpClientConfig> ret = new HashMap<String, HttpClientConfig>();
+        ret.put("AmazonCloudWatchClient", new HttpClientConfig("monitoring"));
+        ret.put("AmazonCloudWatchLogsClient", new HttpClientConfig("logs"));
+        ret.put("AmazonSimpleDBClient", new HttpClientConfig("sdb"));
+        ret.put("AmazonSimpleEmailServiceClient", new HttpClientConfig("email"));
+        ret.put("AWSSecurityTokenServiceClient", new HttpClientConfig("sts"));
+        ret.put("AmazonCognitoIdentityClient", new HttpClientConfig("cognito-identity"));
+        ret.put("AmazonCognitoIdentityProviderClient", new HttpClientConfig("cognito-idp"));
+        ret.put("AmazonCognitoSyncClient", new HttpClientConfig("cognito-sync"));
+        ret.put("AmazonKinesisFirehoseClient", new HttpClientConfig("firehose"));
+        ret.put("AWSIotClient", new HttpClientConfig("execute-api"));
+        ret.put("AmazonLexRuntimeClient", new HttpClientConfig("runtime.lex"));
+        ret.put("AmazonPinpointClient", new HttpClientConfig("mobiletargeting"));
+        ret.put("AmazonPinpointAnalyticsClient", new HttpClientConfig("mobileanalytics"));
+        ret.put("AmazonTranscribeClient", new HttpClientConfig("transcribe"));
+        return ret;
+    }
+
+    private static Map<String, SignerConfig> getDefaultRegionSigners() {
+        // map from region name to signer type
+        final Map<String, SignerConfig> ret = new HashMap<String, SignerConfig>();
+        ret.put("eu-central-1", new SignerConfig("AWS4SignerType"));
+        ret.put("cn-north-1", new SignerConfig("AWS4SignerType"));
+        return ret;
+    }
+
+    private static Map<String, SignerConfig> getDefaultServiceRegionSigners() {
+        // map from "<service>/<region>" to signer type
+        final Map<String, SignerConfig> ret = new HashMap<String, SignerConfig>();
+        ret.put("s3/eu-central-1", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/cn-north-1", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/us-east-2", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/ca-central-1", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/ap-south-1", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/ap-northeast-2", new SignerConfig("AWSS3V4SignerType"));
+        ret.put("s3/eu-west-2", new SignerConfig("AWSS3V4SignerType"));
+        return ret;
+    }
+
+    private static Map<String, SignerConfig> getDefaultServiceSigners() {
+        // map from abbreviated service name to signer type
+        final Map<String, SignerConfig> ret = new HashMap<String, SignerConfig>();
+        ret.put("ec2", new SignerConfig("QueryStringSignerType"));
+        ret.put("email", new SignerConfig("AWS3SignerType"));
+        ret.put("s3", new SignerConfig("S3SignerType"));
+        ret.put("sdb", new SignerConfig("QueryStringSignerType"));
+        ret.put("runtime.lex", new SignerConfig("AmazonLexV4Signer"));
+        ret.put("polly", new SignerConfig("AmazonPollyCustomPresigner"));
+        return ret;
+    }
+
+    private static SignerConfig getDefaultSigner() {
+        return new SignerConfig("AWS4SignerType");
+    }
+
+    private static List<HostRegexToRegionMapping> getDefaultHostRegexToRegionMappings() {
+        final List<HostRegexToRegionMapping> ret = new ArrayList<HostRegexToRegionMapping>();
+        ret.add(new HostRegexToRegionMapping("(.+\\.)?s3\\.amazonaws\\.com", "us-east-1"));
+        ret.add(new HostRegexToRegionMapping("(.+\\.)?s3-external-1\\.amazonaws\\.com", "us-east-1"));
+        ret.add(new HostRegexToRegionMapping("(.+\\.)?s3-fips-us-gov-west-1\\.amazonaws\\.com",
+                "us-gov-west-1"));
+        return ret;
+    }
+
+    // For debugging purposes
+    void dump() {
+        final StringBuilder sb = new StringBuilder().append("defaultSignerConfig: ")
+                .append(defaultSignerConfig).append("\n")
+                .append("serviceRegionSigners: ").append(serviceRegionSigners)
+                .append("\n").append("regionSigners: ").append(regionSigners)
+                .append("\n").append("serviceSigners: ").append(serviceSigners)
+                .append("\n").append("hostRegexToRegionMappings: ")
+                .append(hostRegexToRegionMappings);
+        log.debug(sb.toString());
+    }
+
+    public static class Factory {
+        private static final InternalConfig SINGELTON;
+        static {
+            InternalConfig config = null;
+            try {
+                config = new InternalConfig();
+            } catch (final RuntimeException ex) {
+                throw ex;
+            } catch (final Exception ex) {
+                throw new IllegalStateException(
+                        "Fatal: Failed to load the internal config for AWS Android SDK",
+                        ex);
+            }
+            SINGELTON = config;
+        }
+
+        /**
+         * Returns a non-null and immutable instance of the AWS SDK internal
+         * configuration.
+         */
+        public static InternalConfig getInternalConfig() {
+            return SINGELTON;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/SignerConfig.java b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/SignerConfig.java
new file mode 100644
index 0000000000..2bf102ef6a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/internal/config/SignerConfig.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.internal.config;
+
+/**
+ * Signer configuration.
+ */
+public class SignerConfig {
+
+    private final String signerType;
+
+    SignerConfig(String signerType) {
+        this.signerType = signerType;
+    }
+
+    SignerConfig(SignerConfig from) {
+        this.signerType = from.getSignerType();
+    }
+
+    public String getSignerType() {
+        return signerType;
+    }
+
+    @Override
+    public String toString() {
+        return signerType;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/AwsSdkMetrics.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/AwsSdkMetrics.java
new file mode 100644
index 0000000000..156bbf80ed
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/AwsSdkMetrics.java
@@ -0,0 +1,826 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import static com.amazonaws.SDKGlobalConfiguration.DEFAULT_METRICS_SYSTEM_PROPERTY;
+
+import com.amazonaws.SDKGlobalConfiguration;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.AWSCredentialsProvider;
+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;
+import com.amazonaws.auth.PropertiesCredentials;
+import com.amazonaws.regions.Regions;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+import com.amazonaws.util.AWSServiceMetrics;
+
+import org.apache.commons.logging.LogFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Used to control the default AWS SDK metric collection system.
+ * <p>
+ * The default metric collection of the Java AWS SDK is disabled by default. To
+ * enable it, simply specify the system property
+ * <b>"com.amazonaws.sdk.enableDefaultMetrics"</b> when starting up the JVM.
+ * When the system property is specified, a default metric collector will be
+ * started at the AWS SDK level. The default implementation uploads the
+ * request/response metrics captured to Amazon CloudWatch using AWS credentials
+ * obtained via the {@link DefaultAWSCredentialsProviderChain}.
+ * <p>
+ * For additional optional attributes that can be specified for the system
+ * property, please read the javadoc of the individual fields of this class for
+ * more details.
+ * <p>
+ * Instead of via system properties, the default AWS SDK metric collection can
+ * also be enabled programmatically via {@link #enableDefaultMetrics()}.
+ * Similarly, metric collection at the AWS SDK level can be disabled via
+ * {@link #disableMetrics()}.
+ * <p>
+ * Clients who needs to fully customize the metric collection can implement the
+ * SPI {@link MetricCollector}, and then replace the default AWS SDK
+ * implementation of the collector via
+ * {@link #setMetricCollector(MetricCollector)}.
+ * <p>
+ * Alternatively, for limited customization of the internal collector
+ * implementation provided by the AWS SDK, one can extend the internal Amazon
+ * CloudWatch metric collector. See the javadoc at
+ * com.amazonaws.metrics.internal.cloudwatch.CloudWatchMetricConfig for more
+ * details.
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum AwsSdkMetrics {
+    ;
+
+    /** Constant for default metric namespace. */
+    public static final String DEFAULT_METRIC_NAMESPACE = "AWSSDK/Java";
+
+    private static final int QUEUE_POLL_TIMEOUT_MILLI_MINUMUM = 1000;
+
+    private static final String MBEAN_OBJECT_NAME =
+            "com.amazonaws.management:type=" + AwsSdkMetrics.class.getSimpleName();
+    /**
+     * Used to enable the use of a single metric namespace for all levels of SDK
+     * generated CloudWatch metrics such as JVM level, host level, etc.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=useSingleMetricNamespace
+     * </pre>
+     */
+    public static final String USE_SINGLE_METRIC_NAMESPACE = "useSingleMetricNamespace";
+    /**
+     * Used to exclude the generation of JVM metrics when the AWS SDK default
+     * metrics is enabled. By default, jvm metrics is included.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=excludeJvmMetrics
+     * </pre>
+     */
+    public static final String EXCLUDE_MACHINE_METRICS = "excludeMachineMetrics";
+
+    /**
+     * Used to generate per host level metrics when the AWS SDK default metrics
+     * is enabled. By default, per-host level metrics is excluded.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=includePerHostMetrics
+     * </pre>
+     */
+    public static final String INCLUDE_PER_HOST_METRICS = "includePerHostMetrics";
+
+    /**
+     * Used to specify an AWS credential property file. By default, the
+     * {@link DefaultAWSCredentialsProviderChain} is used.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=credentialFile=/path/aws.properties
+     * </pre>
+     */
+    public static final String AWS_CREDENTAIL_PROPERTIES_FILE = "credentialFile";
+
+    /**
+     * Used to specify the Amazon CloudWatch region for metrics uploading
+     * purposes. By default, metrics are uploaded to us-east-1.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=cloudwatchRegion=us-west-2
+     * </pre>
+     */
+    public static final String CLOUDWATCH_REGION = "cloudwatchRegion";
+
+    /**
+     * Used to specify the internal in-memory queue size for queuing metrics
+     * data points. The default size is 1,000.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=metricQueueSize=1000
+     * </pre>
+     */
+    public static final String METRIC_QUEUE_SIZE = "metricQueueSize";
+
+    /**
+     * Used to specify the internal queue polling timeout in millisecond. The
+     * default timeout is 1 minute, which is optimal for the default CloudWatch
+     * implementation.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=getQueuePollTimeoutMilli=60000
+     * </pre>
+     */
+    public static final String QUEUE_POLL_TIMEOUT_MILLI = "getQueuePollTimeoutMilli";
+
+    /**
+     * Used to specify a custom metric name space. The default name space is
+     * {@link #DEFAULT_METRIC_NAMESPACE}.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=metricNameSpace=MyNameSpace
+     * </pre>
+     */
+    public static final String METRIC_NAME_SPACE = "metricNameSpace";
+
+    /**
+     * Used to generate per JVM level metrics when the AWS SDK default metrics
+     * is enabled. By default, JVM level metrics are not generated.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=jvmMetricName=Tomcat1
+     * </pre>
+     */
+    public static final String JVM_METRIC_NAME = "jvmMetricName";
+
+    /**
+     * Used to explicitly specify the host name for metric purposes, instead of
+     * detecting the host name via {@link InetAddress} when the AWS SDK default
+     * metrics is enabled. Specifying the host name also has the side effecting
+     * of enabling per host level metrics.
+     *
+     * <pre>
+     * Example:
+     *  -Dcom.amazonaws.sdk.enableDefaultMetrics=hostMetricName=MyHost
+     * </pre>
+     */
+    public static final String HOST_METRIC_NAME = "hostMetricName";
+
+    private static final String DEFAULT_METRIC_COLLECTOR_FACTORY =
+            "com.amazonaws.metrics.internal.cloudwatch.DefaultMetricCollectorFactory";
+    /**
+     * True iff the system property {@link #DEFAULT_METRICS_SYSTEM_PROPERTY} has
+     * been set; false otherwise.
+     */
+    private static final boolean DEFAULT_METRICS_ENABLED;
+    private static volatile AWSCredentialsProvider credentialProvider;
+    /**
+     * True if machine metrics is to be excluded; false otherwise.
+     */
+    private static volatile boolean machineMetricsExcluded;
+    /**
+     * True if per-host metrics is to be included; false if per-host metrics is
+     * to be excluded when {@link #hostMetricName} is not specified. In the
+     * absence of {@link #hostMetricName}, the host name will be automatically
+     * detected via {@link InetAddress}.
+     */
+    private static volatile boolean perHostMetricsIncluded;
+    private static volatile Regions region;
+    private static volatile Integer metricQueueSize;
+    private static volatile Long queuePollTimeoutMilli;
+    private static volatile String metricNameSpace = DEFAULT_METRIC_NAMESPACE;
+    private static volatile String credentialFile;
+
+    /**
+     * No JVM level metrics is generated if this field is set to null or blank.
+     * Otherwise, the value in this field is used to compose the metric name
+     * space. Example:
+     * <ol>
+     * <li>If jvmMetricName="Tomcat1" and host-level metrics is disabled, the
+     * metric name space will be something like: "AWSSDK/Java/Tomcat1".</li>
+     * <li>If jvmMetricName="Tomcat1" and host-level metrics is enabled, the
+     * metric name space will be something like:
+     * "AWSSDK/Java/myhost.mycompany.com/Tomcat1".</li>
+     * <li>If jvmMetricName="Tomcat1" and host-level metrics is enabled and the
+     * metricNameSpace="MyNameSpace", the metric name space will be something
+     * like: "MyNameSpace/myhost.mycompany.com/Tomcat1".</li>
+     * </ol>
+     */
+    private static volatile String jvmMetricName;
+    private static volatile String hostMetricName;
+    /**
+     * True if the same metric namespace is to be used for all levels (such as
+     * JVM level, host-level, etc.) of AWS Cloudwatch Metrics for the Java SDK;
+     * false otherwise.
+     */
+    private static volatile boolean singleMetricNamespace;
+
+    static {
+        String defaultMetrics = System.getProperty(DEFAULT_METRICS_SYSTEM_PROPERTY);
+        DEFAULT_METRICS_ENABLED = defaultMetrics != null;
+        if (DEFAULT_METRICS_ENABLED) {
+            String[] values = defaultMetrics.split(",");
+            boolean excludeMachineMetrics = false;
+            boolean includePerHostMetrics = false;
+            boolean useSingleMetricNamespace = false;
+            for (String s : values) {
+                String part = s.trim();
+                if (!excludeMachineMetrics && EXCLUDE_MACHINE_METRICS.equals(part)) {
+                    excludeMachineMetrics = true;
+                } else if (!includePerHostMetrics && INCLUDE_PER_HOST_METRICS.equals(part)) {
+                    includePerHostMetrics = true;
+                } else if (!useSingleMetricNamespace && USE_SINGLE_METRIC_NAMESPACE.equals(part)) {
+                    useSingleMetricNamespace = true;
+                } else {
+                    String[] pair = part.split("=");
+                    if (pair.length == 2) {
+                        String key = pair[0].trim();
+                        String value = pair[1].trim();
+                        try {
+                            if (AWS_CREDENTAIL_PROPERTIES_FILE.equals(key)) {
+                                setCredentialFile0(value);
+                            } else if (CLOUDWATCH_REGION.equals(key)) {
+                                region = Regions.fromName(value);
+                            } else if (METRIC_QUEUE_SIZE.equals(key)) {
+                                Integer i = new Integer(value);
+                                if (i.intValue() < 1)
+                                    throw new IllegalArgumentException(METRIC_QUEUE_SIZE
+                                            + " must be at least 1");
+                                metricQueueSize = i;
+                            } else if (QUEUE_POLL_TIMEOUT_MILLI.equals(key)) {
+                                Long i = new Long(value);
+                                if (i.intValue() < QUEUE_POLL_TIMEOUT_MILLI_MINUMUM)
+                                    throw new IllegalArgumentException(QUEUE_POLL_TIMEOUT_MILLI
+                                            + " must be at least 1000");
+                                queuePollTimeoutMilli = i;
+                            } else if (METRIC_NAME_SPACE.equals(key)) {
+                                metricNameSpace = value;
+                            } else if (JVM_METRIC_NAME.equals(key)) {
+                                jvmMetricName = value;
+                            } else if (HOST_METRIC_NAME.equals(key)) {
+                                hostMetricName = value;
+                            } else {
+                                LogFactory.getLog(AwsSdkMetrics.class).debug(
+                                        "Ignoring unrecognized parameter: " + part);
+                            }
+                        } catch (Exception e) {
+                            LogFactory.getLog(AwsSdkMetrics.class).debug("Ignoring failure", e);
+                        }
+                    }
+                }
+            }
+            machineMetricsExcluded = excludeMachineMetrics;
+            perHostMetricsIncluded = includePerHostMetrics;
+            singleMetricNamespace = useSingleMetricNamespace;
+        }
+    }
+
+    private static final MetricRegistry REGISTRY = new MetricRegistry();
+    private static volatile MetricCollector mc;
+    /**
+     * Used to disallow re-entrancy in enabling the default metric collection
+     * system.
+     */
+    private static boolean dirtyEnabling;
+
+    /**
+     * @param <T> RequestMetricCollector type.
+     * @return a non-null request metric collector for the SDK. If no custom
+     * request metric collector has previously been specified via
+     * {@link #setMetricCollector(MetricCollector)} and the
+     * {@link SDKGlobalConfiguration#DEFAULT_METRICS_SYSTEM_PROPERTY} has been
+     * set, then this method will initialize and return the default metric
+     * collector provided by the AWS SDK on a best-attempt basis.
+     */
+    public static <T extends RequestMetricCollector> T getRequestMetricCollector() {
+        if (mc == null) {
+            if (isDefaultMetricsEnabled())
+                enableDefaultMetrics();
+        }
+        @SuppressWarnings("unchecked")
+        T t = (T) (mc == null ? RequestMetricCollector.NONE : mc.getRequestMetricCollector());
+        return t;
+    }
+
+    /**
+     * @param <T> Tje ServiceMetricCollector type.
+     * @return a non-null service metric collector for the SDK.
+     */
+    public static <T extends ServiceMetricCollector> T getServiceMetricCollector() {
+        if (mc == null) {
+            if (isDefaultMetricsEnabled())
+                enableDefaultMetrics();
+        }
+        @SuppressWarnings("unchecked")
+        T t = (T) (mc == null ? ServiceMetricCollector.NONE : mc.getServiceMetricCollector());
+        return t;
+    }
+
+    /**
+     * This method should never be called by anyone except the JMX MBean used
+     * for administrative purposes only.
+     */
+    static MetricCollector getInternalMetricCollector() {
+        return mc;
+    }
+
+    /**
+     * @param <T> The MetricCollector type.
+     * @return a non-null metric collector for the SDK.
+     */
+    public static <T extends MetricCollector> T getMetricCollector() {
+        if (mc == null) {
+            if (isDefaultMetricsEnabled())
+                enableDefaultMetrics();
+        }
+        @SuppressWarnings("unchecked")
+        T t = (T) (mc == null ? MetricCollector.NONE : mc);
+        return t;
+    }
+
+    /**
+     * Sets the metric collector to be used by the AWS SDK, and stop the
+     * previously running collector used by the AWS SDK, if any. Note, however,
+     * a request metric collector specified at the web service client level or
+     * request level, if any, always takes precedence over the one specified at
+     * the AWS SDK level.
+     * <p>
+     * Caller of this method is responsible for starting the new metric
+     * collector specified as the input parameter.
+     *
+     * @param mc the metric collector to be used by the AWS SDK; or null if no
+     *            metric collection is to be performed at the AWS SDK level.
+     * @see RequestMetricCollector
+     * @see RequestMetricCollector#NONE
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public static synchronized void setMetricCollector(MetricCollector mc) {
+        MetricCollector old = AwsSdkMetrics.mc;
+        AwsSdkMetrics.mc = mc;
+        if (old != null) {
+            old.stop();
+        }
+    }
+
+    /**
+     * Used to set whether the machine metrics is to be excluded.
+     *
+     * @param excludeMachineMetrics true if machine metrics is to be excluded;
+     *            false otherwise.
+     */
+    public static void setMachineMetricsExcluded(boolean excludeMachineMetrics) {
+        AwsSdkMetrics.machineMetricsExcluded = excludeMachineMetrics;
+    }
+
+    /**
+     * Used to set whether the per-host metrics is to be included.
+     *
+     * @param includePerHostMetrics true if per-host metrics is to be included;
+     *            false otherwise.
+     */
+    public static void setPerHostMetricsIncluded(boolean includePerHostMetrics) {
+        AwsSdkMetrics.perHostMetricsIncluded = includePerHostMetrics;
+    }
+
+    /**
+     * @return true if the system property
+     * {@link SDKGlobalConfiguration#DEFAULT_METRICS_SYSTEM_PROPERTY} has been
+     * set; false otherwise.
+     */
+    public static boolean isDefaultMetricsEnabled() {
+        return DEFAULT_METRICS_ENABLED;
+    }
+
+    /**
+     * @return true if a single metric name space is to be used for all levels
+     * of SDK generated CloudWatch metrics, including JVM level, host level,
+     * etc.; false otherwise.
+     */
+    public static boolean isSingleMetricNamespace() {
+        return singleMetricNamespace;
+    }
+
+    /**
+     * Used to set whether a single metric name space is to be used for all
+     * levels of SDK generated CloudWatch metrics, including JVM level, host
+     * level, etc.
+     *
+     * @param singleMetricNamespace true if single metric name is to be used;
+     *            false otherwise.
+     */
+    public static void setSingleMetricNamespace(boolean singleMetricNamespace) {
+        AwsSdkMetrics.singleMetricNamespace = singleMetricNamespace;
+    }
+
+    /**
+     * @return true if metrics at the AWS SDK level is enabled; false if
+     * disabled.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public static boolean isMetricsEnabled() {
+        MetricCollector mc = AwsSdkMetrics.mc;
+        return mc != null && mc.isEnabled();
+    }
+
+    /**
+     * @return true if machine metrics is to be excluded.
+     */
+    public static boolean isMachineMetricExcluded() {
+        return machineMetricsExcluded;
+    }
+
+    /**
+     * @return true if the per-host metrics flag has been set; false otherwise.
+     */
+    public static boolean isPerHostMetricIncluded() {
+        return perHostMetricsIncluded;
+    }
+
+    /**
+     * @return true if per-host metrics is enabled; false otherwise.
+     */
+    public static boolean isPerHostMetricEnabled() {
+        if (perHostMetricsIncluded)
+            return true;
+        String host = hostMetricName;
+        host = host == null ? "" : host.trim();
+        return host.length() > 0;
+    }
+
+    /**
+     * Starts the default AWS SDK metric collector, but only if no metric
+     * collector is currently in use at the AWS SDK level.
+     *
+     * @return true if the default AWS SDK metric collector has been
+     *         successfully started by this call; false otherwise.
+     */
+    public static synchronized boolean enableDefaultMetrics() {
+        if (mc == null || !mc.isEnabled()) {
+            if (dirtyEnabling) {
+                throw new IllegalStateException("Reentrancy is not allowed");
+            }
+            dirtyEnabling = true;
+            try {
+                Class<?> c = Class.forName(DEFAULT_METRIC_COLLECTOR_FACTORY);
+                MetricCollector.Factory f = (MetricCollector.Factory) c.newInstance();
+                MetricCollector instance = f.getInstance();
+                if (instance != null) {
+                    setMetricCollector(instance);
+                    return true;
+                }
+            } catch (Exception e) {
+                LogFactory.getLog(AwsSdkMetrics.class)
+                        .warn("Failed to enable the default metrics", e);
+            } finally {
+                dirtyEnabling = false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Convenient method to disable the metric collector at the AWS SDK level.
+     */
+    public static void disableMetrics() {
+        setMetricCollector(MetricCollector.NONE);
+    }
+
+    /**
+     * Adds the given metric type to the REGISTRY of predefined metrics to be
+     * captured at the AWS SDK level.
+     * @param type the metric type.
+     * @return true if the set of predefined metric types gets changed as a
+     *         result of the call
+     */
+    public static boolean add(MetricType type) {
+        return type == null ? false : REGISTRY.addMetricType(type);
+    }
+
+    /**
+     * Adds the given metric types to the REGISTRY of predefined metrics to be
+     * captured at the AWS SDK level.
+     * @param types the collection of metric types.
+     * @param <T> the MetricType type.
+     * @return true if the set of predefined metric types gets changed as a
+     *         result of the call
+     */
+    public static <T extends MetricType> boolean addAll(Collection<T> types) {
+        return types == null || types.size() == 0
+                ? false
+                : REGISTRY.addMetricTypes(types);
+    }
+
+    /**
+     * Sets the given metric types to replace the REGISTRY of predefined metrics
+     * to be captured at the AWS SDK level.
+     * @param types the collection of metric types.
+     * @param <T> the MetricType type.
+     */
+    public static <T extends MetricType> void set(Collection<T> types) {
+        REGISTRY.setMetricTypes(types);
+    }
+
+    /**
+     * Removes the given metric type from the REGISTRY of predefined metrics to
+     * be captured at the AWS SDK level.
+     * @param type the collection of metric types.
+     * @return true if the set of predefined metric types gets changed as a
+     *         result of the call
+     */
+    public static boolean remove(MetricType type) {
+        return type == null ? false : REGISTRY.removeMetricType(type);
+    }
+
+    /**
+     * @return an unmodifiable set of the current predefined metrics.
+     */
+    public static Set<MetricType> getPredefinedMetrics() {
+        return REGISTRY.predefinedMetrics();
+    }
+
+    /**
+     * @return the credential provider for the default AWS SDK metric
+     * implementation. This method is restricted to calls from the default AWS
+     * SDK metric implementation.
+     *
+     * @throws SecurityException if called outside the default AWS SDK metric
+     *             implementation.
+     */
+    public static AWSCredentialsProvider getCredentialProvider() {
+        StackTraceElement[] e = Thread.currentThread().getStackTrace();
+        for (int i = 0; i < e.length; i++) {
+            if (e[i].getClassName().equals(DEFAULT_METRIC_COLLECTOR_FACTORY)) {
+                return credentialProvider;
+            }
+        }
+        SecurityException ex = new SecurityException();
+        LogFactory.getLog(AwsSdkMetrics.class).warn(
+                "Illegal attempt to access the credential provider", ex);
+        throw ex;
+    }
+
+    /**
+     * Sets the credential provider for the default AWS SDK metric
+     * implementation; or null if the default is to be used. Calling this method
+     * may result in the credential provider being different from the credential
+     * file property.
+     * @param provider the AWSCredentialsProvider.
+     */
+    public static synchronized void setCredentialProvider(
+            AWSCredentialsProvider provider) {
+        credentialProvider = provider;
+    }
+
+    /**
+     * @return the region configured for the default AWS SDK metric collector;
+     * or null if the default is to be used.
+     */
+    public static Regions getRegion() {
+        return region;
+    }
+
+    /**
+     * Sets the region to be used for the default AWS SDK metric collector; or
+     * null if the default is to be used.
+     * @param region the region.
+     */
+    public static void setRegion(Regions region) {
+        AwsSdkMetrics.region = region;
+    }
+
+    /**
+     * @return the last set AWS credential file, or null if there is none.
+     */
+    public static String getCredentailFile() {
+        return credentialFile;
+    }
+
+    /**
+     * Sets the AWS credential file to be used for accessing Amazon CloudWatch.
+     * Successfully calling this method would result in the AWS credential
+     * provider to make use of the given credential file.
+     * @param filepath the credential filepath.
+     */
+    public static void setCredentialFile(String filepath)
+            throws IOException {
+        setCredentialFile0(filepath);
+    }
+
+    /**
+     * Internal method to implement the {@link #setCredentialFile(String)}.
+     */
+    private static void setCredentialFile0(String filepath)
+            throws IOException {
+        final PropertiesCredentials cred =
+                new PropertiesCredentials(new File(filepath));
+        synchronized (AwsSdkMetrics.class) {
+            credentialProvider = new AWSCredentialsProvider() {
+                @Override
+                public void refresh() {
+                }
+
+                @Override
+                public AWSCredentials getCredentials() {
+                    return cred;
+                }
+            };
+            AwsSdkMetrics.credentialFile = filepath;
+        }
+    }
+
+    /**
+     * @return the internal metric queue size to be used for the default AWS SDK
+     * metric collector; or null if the default is to be used.
+     */
+    public static Integer getMetricQueueSize() {
+        return metricQueueSize;
+    }
+
+    /**
+     * Sets the metric queue size to be used for the default AWS SDK metric
+     * collector; or null if the default is to be used.
+     * @param size the size of the metric queue.
+     */
+    public static void setMetricQueueSize(Integer size) {
+        metricQueueSize = size;
+    }
+
+    /**
+     * @return the internal metric queue timeout in millisecond to be used for
+     * the default AWS SDK metric collector; or null if the default is to be
+     * used.
+     */
+    public static Long getQueuePollTimeoutMilli() {
+        return queuePollTimeoutMilli;
+    }
+
+    /**
+     * Sets the queue poll time in millisecond to be used for the default AWS
+     * SDK metric collector; or null if the default is to be used.
+     * @param timeoutMilli the timeout in milliseconds.
+     */
+    public static void setQueuePollTimeoutMilli(Long timeoutMilli) {
+        queuePollTimeoutMilli = timeoutMilli;
+    }
+
+    /**
+     * @return the metric name space, which is never null or blank.
+     */
+    public static String getMetricNameSpace() {
+        return metricNameSpace;
+    }
+
+    /**
+     * Sets the metric name space.
+     *
+     * @param metricNameSpace metric name space which must neither be null or
+     *            blank.
+     * @throws IllegalArgumentException if the specified metric name space is
+     *             either null or blank.
+     */
+    public static void setMetricNameSpace(String metricNameSpace) {
+        if (metricNameSpace == null || metricNameSpace.trim().length() == 0)
+            throw new IllegalArgumentException();
+        AwsSdkMetrics.metricNameSpace = metricNameSpace;
+    }
+
+    /**
+     * @return the name of the JVM for generating per-JVM level metrics; or null
+     * or blank if per-JVM level metrics are disabled.
+     */
+    public static String getJvmMetricName() {
+        return jvmMetricName;
+    }
+
+    /**
+     * Sets the name of the JVM for generating per-JVM level metrics.
+     *
+     * @param jvmMetricName name of the JVM for generating per-JVM level
+     *            metrics; or null or blank if per-JVM level metrics are to be
+     *            disabled.
+     */
+    public static void setJvmMetricName(String jvmMetricName) {
+        AwsSdkMetrics.jvmMetricName = jvmMetricName;
+    }
+
+    /**
+     * @return the host name for generating per-host level metrics; or null or
+     * blank if the host is to be automatically detected via {@link InetAddress}
+     * .
+     */
+    public static String getHostMetricName() {
+        return hostMetricName;
+    }
+
+    /**
+     * Sets the host name for generating per-host level metrics.
+     *
+     * @param hostMetricName host name for generating per-host level metrics; or
+     *            null or blank if the host is to be automatically detected via
+     *            {@link InetAddress}.
+     */
+    public static void setHostMetricName(String hostMetricName) {
+        AwsSdkMetrics.hostMetricName = hostMetricName;
+    }
+
+    /**
+     * Used as a REGISTRY for the predefined metrics to be captured by the
+     * metric collector at the AWS SDK level.
+     */
+    private static class MetricRegistry {
+        private final Set<MetricType> metricTypes = new HashSet<MetricType>();
+        private volatile Set<MetricType> readOnly;
+
+        MetricRegistry() {
+            metricTypes.add(Field.ClientExecuteTime);
+            metricTypes.add(Field.Exception);
+            metricTypes.add(Field.HttpClientRetryCount);
+            metricTypes.add(Field.HttpRequestTime);
+            metricTypes.add(Field.RequestCount);
+            // metricTypes.add(Field.RequestSigningTime);
+            // metricTypes.add(Field.ResponseProcessingTime);
+            metricTypes.add(Field.RetryCount);
+            metricTypes.add(Field.HttpClientSendRequestTime);
+            metricTypes.add(Field.HttpClientReceiveResponseTime);
+            metricTypes.add(Field.HttpClientPoolAvailableCount);
+            metricTypes.add(Field.HttpClientPoolLeasedCount);
+            metricTypes.add(Field.HttpClientPoolPendingCount);
+            metricTypes.add(AWSServiceMetrics.HttpClientGetConnectionTime);
+            syncReadOnly();
+        }
+
+        private void syncReadOnly() {
+            readOnly = Collections.unmodifiableSet(new HashSet<MetricType>(metricTypes));
+        }
+
+        public boolean addMetricType(MetricType type) {
+            synchronized (metricTypes) {
+                boolean added = metricTypes.add(type);
+                if (added)
+                    syncReadOnly();
+                return added;
+            }
+        }
+
+        public <T extends MetricType> boolean addMetricTypes(Collection<T> types) {
+            synchronized (metricTypes) {
+                boolean added = metricTypes.addAll(types);
+                if (added)
+                    syncReadOnly();
+                return added;
+            }
+        }
+
+        public <T extends MetricType> void setMetricTypes(Collection<T> types) {
+            synchronized (metricTypes) {
+                if (types == null || types.size() == 0) {
+                    if (metricTypes.size() == 0)
+                        return;
+                    if (types == null)
+                        types = Collections.emptyList();
+                }
+                metricTypes.clear();
+                if (!addMetricTypes(types)) {
+                    syncReadOnly(); // avoid missing sync
+                }
+            }
+        }
+
+        public boolean removeMetricType(MetricType type) {
+            synchronized (metricTypes) {
+                boolean removed = metricTypes.remove(type);
+                if (removed)
+                    syncReadOnly();
+                return removed;
+            }
+        }
+
+        public Set<MetricType> predefinedMetrics() {
+            return readOnly;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputHelper.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputHelper.java
new file mode 100644
index 0000000000..27adc37115
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputHelper.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Helper class to capture the byte throughput.
+ * <p>
+ * Note this class is only relevant when metric is enabled. Otherwise it should
+ * not even be involved in the call stack to minimize runtime overhead.
+ */
+class ByteThroughputHelper extends ByteThroughputProvider {
+    private static final int REPORT_INTERVAL_SECS = 10;
+
+    ByteThroughputHelper(ThroughputMetricType type) {
+        super(type);
+    }
+
+    long startTiming() {
+        if (TimeUnit.NANOSECONDS.toSeconds(getDurationNano()) > REPORT_INTERVAL_SECS) {
+            reportMetrics();
+        }
+        return System.nanoTime();
+    }
+
+    void reportMetrics() {
+        if (getByteCount() > 0) {
+            ServiceMetricCollector col = AwsSdkMetrics.getServiceMetricCollector();
+            col.collectByteThroughput(this);
+            reset();
+        }
+    }
+
+    @Override
+    public void increment(int bytesDelta, long startTimeNano) {
+        super.increment(bytesDelta, startTimeNano);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputProvider.java
new file mode 100644
index 0000000000..ed3d81217f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ByteThroughputProvider.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * Byte throughput metric information provider.
+ */
+public abstract class ByteThroughputProvider {
+    private long duration;
+    private int byteCount;
+    private final ThroughputMetricType throughputType;
+
+    protected ByteThroughputProvider(ThroughputMetricType type) {
+        this.throughputType = type;
+    }
+
+    public ThroughputMetricType getThroughputMetricType() {
+        return throughputType;
+    }
+
+    public int getByteCount() {
+        return byteCount;
+    }
+
+    public long getDurationNano() {
+        return duration;
+    }
+
+    /**
+     * @return a provider id that can be used to compute the number of active
+     * byte throughput provider of a specific metric type being active in a
+     * given time interval.
+     */
+    public String getProviderId() {
+        return super.toString();
+    }
+
+    /**
+     * @param bytesDelta the number of bytes to increment
+     * @param startTimeNano the start time in nano seconds
+     */
+    protected void increment(int bytesDelta, long startTimeNano) {
+        this.byteCount += bytesDelta;
+        this.duration += System.nanoTime() - startTimeNano;
+    }
+
+    protected void reset() {
+        this.byteCount = 0;
+        this.duration = 0;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(
+                "providerId=%s, throughputType=%s, byteCount=%d, duration=%d",
+                getProviderId(), throughputType, byteCount, duration);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricCollector.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricCollector.java
new file mode 100644
index 0000000000..ba28751738
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricCollector.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * Metric Collector SPI. This is a class instead of interface so in case of
+ * adding new methods in the future we can do that safetly without breaking any
+ * existing clients that implements this SPI.
+ */
+public abstract class MetricCollector {
+    /**
+     * Can be used to serve as a factory for the request metric collector.
+     */
+    public static interface Factory {
+
+        /**
+         * @return an instance of the collector; or null if if failed to create
+         * one.
+         */
+        public MetricCollector getInstance();
+    }
+
+    /**
+     * Starts the request metric collector.
+     *
+     * @return true if the collector is successfully started; false otherwise.
+     */
+    public abstract boolean start();
+
+    /**
+     * Stops the request metric collector.
+     *
+     * @return true if the collector is successfully stopped; false if the
+     *         collector is not running and therefore the call has no effect.
+     */
+    public abstract boolean stop();
+
+    /** @return true if this collector is enabled; false otherwise. */
+    public abstract boolean isEnabled();
+
+    /** @return the request metric collector. */
+    public abstract RequestMetricCollector getRequestMetricCollector();
+
+    /** @return the service metric collector. */
+    public abstract ServiceMetricCollector getServiceMetricCollector();
+
+    /** A convenient instance of a no-op request metric collector. */
+    public static final MetricCollector NONE = new MetricCollector() {
+        @Override
+        public boolean start() {
+            return true;
+        }
+
+        @Override
+        public boolean stop() {
+            return true;
+        }
+
+        /** Always returns false. */
+        @Override
+        public boolean isEnabled() {
+            return false;
+        }
+
+        @Override
+        public RequestMetricCollector getRequestMetricCollector() {
+            return RequestMetricCollector.NONE;
+        }
+
+        @Override
+        public ServiceMetricCollector getServiceMetricCollector() {
+            return ServiceMetricCollector.NONE;
+        }
+    };
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricFilterInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricFilterInputStream.java
new file mode 100644
index 0000000000..f73ff468cf
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricFilterInputStream.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Used to capture the input stream throughput metrics, but excluding the
+ * {@link #read()} API.
+ * <p>
+ * Note this class is only relevant when metric is enabled. Otherwise it should
+ * not even be involved in the call stack to minimize runtime overhead.
+ */
+public class MetricFilterInputStream extends SdkFilterInputStream {
+    private final ByteThroughputHelper helper;
+
+    /**
+     * Constructor.
+     * @param type the throughput metric type.
+     * @param in the input stream.
+     */
+    public MetricFilterInputStream(ThroughputMetricType type, InputStream in) {
+        super(in);
+        helper = new ByteThroughputHelper(type);
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        abortIfNeeded();
+        long startNano = helper.startTiming();
+        int bytesRead = in.read(b, off, len);
+        if (bytesRead > 0) {
+            helper.increment(bytesRead, startNano);
+        }
+        return bytesRead;
+    }
+
+    @Override
+    public void close() throws IOException {
+        helper.reportMetrics();
+        in.close();
+        abortIfNeeded();
+    }
+
+    @Override
+    public final boolean isMetricActivated() {
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricInputStreamEntity.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricInputStreamEntity.java
new file mode 100644
index 0000000000..a0df721550
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricInputStreamEntity.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import com.amazonaws.internal.MetricAware;
+
+import org.apache.http.entity.InputStreamEntity;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Used to help capture the throughput metrics.
+ * <p>
+ * Note this class is only relevant when metric is enabled. Otherwise it should
+ * not even be involved in the call stack to minimize runtime overhead.
+ */
+public class MetricInputStreamEntity extends InputStreamEntity {
+    private static final int BUFFER_SIZE = 2048;
+    private final ByteThroughputHelper helper;
+
+    /**
+     * Constructor.
+     * @param metricType the throughput metric type.
+     * @param instream the input stream.
+     * @param length the length.
+     */
+    public MetricInputStreamEntity(ThroughputMetricType metricType,
+            InputStream instream, long length) {
+        super(instream, length);
+        helper = new ByteThroughputHelper(metricType);
+    }
+
+    @Override
+    public void writeTo(final OutputStream outstream) throws IOException {
+        if (outstream instanceof MetricAware) {
+            // hchar: There is currently no implementation of output stream that
+            // has metric gathering capability but there could be!
+            // So the code here is for future proof purposes.
+            MetricAware aware = (MetricAware) outstream;
+            if (aware.isMetricActivated()) {
+                // let the underlying output stream takes care of byte counting
+                super.writeTo(outstream);
+                return;
+            }
+        }
+        writeToWithMetrics(outstream);
+    }
+
+    /**
+     * Copied from {{@link InputStreamEntity#writeTo(OutputStream)} but modified
+     * to capture metrics for the output stream.
+     */
+    private void writeToWithMetrics(final OutputStream outstream) throws IOException {
+        if (outstream == null) {
+            throw new IllegalArgumentException("Output stream may not be null");
+        }
+        final InputStream content = getContent();
+        final long length = getContentLength();
+        InputStream instream = content;
+        try {
+            byte[] buffer = new byte[BUFFER_SIZE];
+            int l;
+            if (length < 0) {
+                // consume until EOF
+                while ((l = instream.read(buffer)) != -1) {
+                    long startNano = helper.startTiming();
+                    outstream.write(buffer, 0, l);
+                    helper.increment(l, startNano);
+                }
+            } else {
+                // consume no more than length
+                long remaining = length;
+                while (remaining > 0) {
+                    l = instream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, remaining));
+                    if (l == -1) {
+                        break;
+                    }
+                    long startNano = helper.startTiming();
+                    outstream.write(buffer, 0, l);
+                    helper.increment(l, startNano);
+                    remaining -= l;
+                }
+            }
+        } finally {
+            helper.reportMetrics();
+            instream.close();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricType.java
new file mode 100644
index 0000000000..72f52dfd30
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/MetricType.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * Metric type.
+ */
+public interface MetricType {
+    /**
+     * Non-null name of the metric type. Used to uniquely identify the metric
+     * type. Therefore, the name returned must be globally unique across all
+     * metric types that implement this interface.
+     * @return the non-null name of the metric type.
+     */
+    public String name();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricCollector.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricCollector.java
new file mode 100644
index 0000000000..af6bc25eb7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricCollector.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import com.amazonaws.Request;
+import com.amazonaws.Response;
+
+/**
+ * A service provider interface that can be used to implement an AWS SDK
+ * request/response metric collector.
+ *
+ * @see AwsSdkMetrics
+ */
+public abstract class RequestMetricCollector {
+    /**
+     * Can be used to serve as a factory for the request metric collector.
+     */
+    public static interface Factory {
+        /**
+         * @return an instance of the collector; or null if if failed to create
+         * one.
+         */
+        public RequestMetricCollector getRequestMetricCollector();
+    }
+
+    /**
+     * Used to collect the metric at the end of a request/response cycle.
+     * @param request the request.
+     * @param response the response.
+     * @see Request#getAWSRequestMetrics()
+     */
+    public abstract void collectMetrics(Request<?> request, Response<?> response);
+
+    /**
+     * @return true if this is enabled.
+     */
+    public boolean isEnabled() {
+        return true;
+    }
+
+    /** A convenient instance of a no-op request metric collector. */
+    public static final RequestMetricCollector NONE = new RequestMetricCollector() {
+        @Override
+        public void collectMetrics(Request<?> request, Response<?> response) {
+        }
+
+        @Override
+        public boolean isEnabled() {
+            return false;
+        }
+    };
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricType.java
new file mode 100644
index 0000000000..bdbd7d3f20
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/RequestMetricType.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * <a href=
+ * "http://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/metrics/package-summary.html"
+ * >Request metric type</a>.
+ */
+public interface RequestMetricType extends MetricType {
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceLatencyProvider.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceLatencyProvider.java
new file mode 100644
index 0000000000..764bee2782
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceLatencyProvider.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import com.amazonaws.util.TimingInfo;
+
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * Latency metric information provider.
+ */
+public class ServiceLatencyProvider {
+    private final long startNano = System.nanoTime();
+    private long endNano = startNano;
+    private final ServiceMetricType serviceMetricType;
+
+    /**
+     * Constructor.
+     * @param type the service metric type.
+     */
+    public ServiceLatencyProvider(ServiceMetricType type) {
+        this.serviceMetricType = type;
+    }
+
+    /**
+     * Constructor.
+     * @return the service metric type.
+     */
+    public ServiceMetricType getServiceMetricType() {
+        return serviceMetricType;
+    }
+
+    /**
+     * Ends the timing. Must not be called more than once.
+     * @return the service latency provider.
+     */
+    public ServiceLatencyProvider endTiming() {
+        if (endNano != startNano) {
+            throw new IllegalStateException();
+        }
+        endNano = System.nanoTime();
+        return this;
+    }
+
+    /**
+     * @return the duration in milliseconds.
+     */
+    public double getDurationMilli() {
+        if (endNano == startNano) {
+            LogFactory.getLog(getClass()).debug(
+                    "Likely to be a missing invocation of endTiming().");
+        }
+        return TimingInfo.durationMilliOf(startNano, endNano);
+    }
+
+    /**
+     * @return the provider id.
+     */
+    public String getProviderId() {
+        return super.toString();
+    }
+
+    @Override
+    public String toString() {
+        return String.format(
+                "providerId=%s, serviceMetricType=%s, startNano=%d, endNano=%d",
+                getProviderId(), serviceMetricType, startNano, endNano);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricCollector.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricCollector.java
new file mode 100644
index 0000000000..7190cf418b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricCollector.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * A service provider interface that can be used to implement an AWS SDK general
+ * purpose metric collector.
+ */
+public abstract class ServiceMetricCollector {
+
+    /** Interface for Factory. */
+    public static interface Factory {
+        /**
+         * @return an instance of the collector; or null if if failed to create
+         * one.
+         */
+        public ServiceMetricCollector getServiceMetricCollector();
+    }
+
+    /**
+     * Collects metrics on the number of bytes written or read and the
+     * respective duration.
+     * @param provider the byte throughput provider.
+     */
+    public abstract void collectByteThroughput(ByteThroughputProvider provider);
+
+    /**
+     * Collects metrics for non-request specific latencies.
+     * @param provider the service latency provider.
+     */
+    public abstract void collectLatency(ServiceLatencyProvider provider);
+
+    /**
+     * @return true if this is enabled.
+     */
+    public boolean isEnabled() {
+        return true;
+    }
+
+    /** A convenient instance of a no-op service metric collector. */
+    public static final ServiceMetricCollector NONE = new ServiceMetricCollector() {
+        @Override
+        public void collectByteThroughput(ByteThroughputProvider provider) {
+        }
+
+        @Override
+        public void collectLatency(ServiceLatencyProvider provider) {
+        }
+
+        @Override
+        public boolean isEnabled() {
+            return false;
+        }
+    };
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricType.java
new file mode 100644
index 0000000000..67c0519173
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ServiceMetricType.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * <a href=
+ * "http://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/metrics/package-summary.html"
+ * >Service specific Metric type</a> (eg S3, DynamoDB, etc.)
+ */
+public interface ServiceMetricType extends MetricType {
+
+    /**
+     * @return the service name.
+     */
+    public String getServiceName();
+
+    /** Upload throughput name suffix. */
+    public static final String UPLOAD_THROUGHPUT_NAME_SUFFIX = "UploadThroughput";
+
+    /** Upload byte count name suffic. */
+    public static final String UPLOAD_BYTE_COUNT_NAME_SUFFIX = "UploadByteCount";
+
+    /** Download throughput name suffix. */
+    public static final String DOWNLOAD_THROUGHPUT_NAME_SUFFIX = "DownloadThroughput";
+
+    /** Download byte count name suffix. */
+    public static final String DOWNLOAD_BYTE_COUNT_NAME_SUFFIX = "DownloadByteCount";
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleMetricType.java
new file mode 100644
index 0000000000..0a521b4b4a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleMetricType.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * The simple metric type class.
+ */
+public abstract class SimpleMetricType implements MetricType {
+    @Override
+    public abstract String name();
+
+    @Override
+    public final int hashCode() {
+        return name().hashCode();
+    }
+
+    @Override
+    public final boolean equals(Object o) {
+        if (!(o instanceof MetricType))
+            return false;
+        MetricType that = (MetricType) o;
+        return this.name().equals(that.name());
+    }
+
+    @Override
+    public final String toString() {
+        return name();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleServiceMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleServiceMetricType.java
new file mode 100644
index 0000000000..4d60906143
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleServiceMetricType.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * Simple service metric type class.
+ */
+public class SimpleServiceMetricType extends SimpleMetricType implements ServiceMetricType {
+    private final String name;
+    private final String serviceName;
+
+    /**
+     * Constructor.
+     * @param name the name of the service metric type.
+     * @param serviceName the service name.
+     */
+    public SimpleServiceMetricType(String name, String serviceName) {
+        this.name = name;
+        this.serviceName = serviceName;
+    }
+
+    @Override
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public String getServiceName() {
+        return serviceName;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleThroughputMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleThroughputMetricType.java
new file mode 100644
index 0000000000..5910d8a757
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/SimpleThroughputMetricType.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * Simple throughput metric type.
+ */
+public class SimpleThroughputMetricType extends SimpleServiceMetricType implements
+        ThroughputMetricType {
+    private final ServiceMetricType byteCountMetricType;
+
+    /**
+     * Constructor.
+     * @param name the name of the simple throughput metric type.
+     * @param serviceName the service name.
+     * @param byteCountMetricName the byte count metric name.
+     */
+    public SimpleThroughputMetricType(String name, String serviceName, String byteCountMetricName) {
+        super(name, serviceName);
+        this.byteCountMetricType = new SimpleServiceMetricType(byteCountMetricName, serviceName);
+    }
+
+    @Override
+    public ServiceMetricType getByteCountMetricType() {
+        return byteCountMetricType;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ThroughputMetricType.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ThroughputMetricType.java
new file mode 100644
index 0000000000..eac9ee5464
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/ThroughputMetricType.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+/**
+ * The throughput metric type class.
+ */
+public interface ThroughputMetricType extends ServiceMetricType {
+
+    /**
+     * @return the byte count metric type.
+     */
+    public ServiceMetricType getByteCountMetricType();
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/internal/ServiceMetricTypeGuesser.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/internal/ServiceMetricTypeGuesser.java
new file mode 100644
index 0000000000..7de6a6b70a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/internal/ServiceMetricTypeGuesser.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.metrics.internal;
+
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.Request;
+import com.amazonaws.metrics.AwsSdkMetrics;
+import com.amazonaws.metrics.ServiceMetricType;
+import com.amazonaws.metrics.SimpleThroughputMetricType;
+import com.amazonaws.metrics.ThroughputMetricType;
+
+/**
+ * An internal helper factory for generating service specific
+ * {@link ServiceMetricType} without causing compile time dependency on the
+ * service specific artifacts. There exists a S3ServiceMetricTest.java unit test
+ * in the S3 client library that ensures this class behaves consistently with
+ * the service metric enum defined in the S3 client library.
+ */
+public enum ServiceMetricTypeGuesser {
+    ;
+    /**
+     * Returned the best-guessed throughput metric type for the given request,
+     * or null if there is none or if metric is disabled.
+     */
+    public static ThroughputMetricType guessThroughputMetricType(
+            final Request<?> req,
+            final String metricNameSuffix,
+            final String byteCountMetricNameSuffix)
+    {
+        if (!AwsSdkMetrics.isMetricsEnabled())
+            return null; // metric disabled
+        AmazonWebServiceRequest orig = req.getOriginalRequest();
+        if (orig.getClass().getName().startsWith("com.amazonaws.services.s3")) {
+            return new SimpleThroughputMetricType(
+                    "S3" + metricNameSuffix,
+                    req.getServiceName(),
+                    "S3" + byteCountMetricNameSuffix);
+        }
+        return null;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/package-info.java
new file mode 100644
index 0000000000..58e62a8ce1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/metrics/package-info.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * Classes used to support the AWS SDK metrics API.
+ *
+ * When the default metric collection system is enabled,
+ * the default AWS SDK implementation
+ * captures a set of predefined core metrics that are grouped under three major
+ * categories:  AWS Request Metrics, AWS Service Metrics, and Machine Metrics.
+ * <h3>Nomenclature</h3>
+ * <ul>
+ * <li>Physical Http Request - an http request initiated by the http client library used by AWS Java SDK . No retry is involved, or at least not initiated from the JVM.</li>
+ * <li>Logical Http Request - an http request initiated from the AWS Java SDK by executing the underlying http client library. A logical request may involve multiple physical requests due to retries.</li>
+ * <li>Service Client type - the specific subtype of AmazonWebServiceClient, such as AmazonS3Client, AmazonDynamoDBClient, etc.</li>
+ * <li>Request type - the specific subtype of AmazonWebServiceRequest, such as PutItemRequest, PutObjectRequest, etc.</li>
+ * <li>Http Client Library - the <a href="http://hc.apache.org/httpcomponents-client-4.2.x/index.html">Apache HttpComponents client</a> library</li>
+ * </ul>
+ *
+ * <h3>AWS Request Metrics</h3>
+ * <ol>
+ * <li>ClientExecuteTime - Total number of milliseconds taken for a
+ * request/response including the time taken to execute the request handlers,
+ * round trip to AWS, and the time taken to execute the response handlers.
+ * Captured on a per request type level.</li>
+ * <li>Exception - Number of logical request failure. Captured both on a per service
+ * client type level and a per request type level.</li>
+ * <li>HttpClientPoolAvailableCount - Number of idle persistent connections of
+ * the underlying httpclient.
+ * This metric is collected from the respective <a
+ * href="https://hc.apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache/http/pool/PoolStats.html"
+ * >PoolStats</a> before the connection of a request is obtained.</li>
+ * <li>HttpClientPoolLeasedCount - Number of persistent connections tracked by
+ * the underlying httpclient connection manager currently being used to execute
+ * requests.
+ * This metric is collected from the respective <a
+ * href="https://hc.apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache/http/pool/PoolStats.html"
+ * >PoolStats</a> before the connection of a request is obtained.</li>
+ * <li>HttpClientPoolPendingCount - Number of connection requests being blocked
+ * awaiting a free connection of the underlying httpclient.
+ * This metric is collected from the respective <a
+ * href="https://hc.apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache/http/pool/PoolStats.html"
+ * >PoolStats</a>. before the connection of a request is obtained</li>
+ * <li>HttpRequestTime - Number of milliseconds taken for a logical request/response
+ * round trip to AWS. Captured on a per request type level.< /li>
+ * <li>HttpClientSendRequestTime - Number of milliseconds taken for a physical request
+ * to get sent to AWS. Captured on a per request type level.< /li>
+ * <li>HttpClientReceiveResponseTime - Number of milliseconds taken for a physical response
+ * to get received from AWS. Captured on a per request type level.< /li>
+ * <li>HttpClientRetryCount - Number of retries per physical request. Captured on a per service
+ * client type level. </li>
+ * <li>RequestCount - Number of logical requests. Captured on a per service
+ * client type level. </li>
+ * <li>RetryCount - Number of retries per logical request. Captured on a per service
+ * client type level. </li>
+ * <li>DynamoDBConsumedCapacity - Number of Amazon DynamoDB capacity units consumed.
+ * Captured on a per request type level, and is only available if the request
+ * has been specified with the necessary "ReturnConsumedCapacity" parameter.
+ * </li>
+ * </ol>
+ * <h3>AWS Service Metrics</h3>
+ * <ol>
+ * <li>HttpClientGetConnectionTime - Total number of milliseconds taken for the
+ * underlying http client library to get a connection.
+ * <li>S3DownloadThroughput - Number of bytes downloaded from S3 per second.</li>
+ * <li>S3DownloadByteCount - Number of bytes downloaded from S3.</li>
+ * <li>S3UploadThroughput - Number of bytes uploaded to S3 per second.</li>
+ * <li>S3UploadByteCount - Number of bytes uploaded to S3.</li>
+ * </ol>
+ * <h3>Machine Metrics</h3>
+ * <h4>Memory</h4>
+ * <ol>
+ * <li>TotalMemory - Total amount of memory currently available to the JVM for
+ * current and future objects, measured in bytes. This value may vary over
+ * time, depending on the host environment.</li>
+ * <li>FreeMemory - An approximation to the total amount of memory currently
+ * available to the JVM for future allocated objects, measured in bytes.</li>
+ * <li>UsedMemory - TotalMemory minus FreeMemory.</li>
+ * <li>SpareMemory - The maximum amount of memory that the JVM will attempt to
+ * use, measured in bytes, minus UsedMemory. </li>
+ * </ol>
+ * <h4>Threads</h4>
+ * <ol>
+ * <li>ThreadCount - The current number of live threads including both daemon
+ * and non-daemon threads.</li>
+ * <li>DeadLockThreadCount - The number of threads that are deadlocked waiting
+ * for object monitors or ownable synchronizers, if any. Threads are deadlocked
+ *  in a cycle waiting for a lock of these two types if each thread owns one
+ *  lock while trying to acquire another lock already held by another thread in
+ *   the cycle. No metrics is generated when the value is zero.</li>
+ * <li>DaemonThreadCount - The current number of live daemon threads. No metrics
+ *  is generated when the value is zero.</li>
+ * <li>PeakThreadCount - The peak live thread count since the JVM started or
+ * since the peak was reset.</li>
+ * <li>TotalStartedThreadCount - The total number of threads created and also
+ * started since the JVM started.</li>
+ * </ol>
+ * <h4>File Descriptors</h4>
+ * <ol>
+ * <li>OpenFileDescriptorCount - Number of opened file descriptors of the
+ * operating system.</li>
+ * <li>SpareFileDescriptorCount - Maximum number of file descriptors of the
+ * operating system minus OpenFileDescriptorCount.</li>
+ * </ol>
+ * 
+ * @Deprecated The metrics package is deprecated
+ */
+
+@Deprecated
+package com.amazonaws.metrics;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfigurable.java b/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfigurable.java
new file mode 100644
index 0000000000..ddb0d915a3
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfigurable.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.mobile.config;
+
+import android.content.Context;
+
+import com.amazonaws.ClientConfiguration;
+
+/**
+ * The {@code AWSConfigurable} interface defines the methods
+ * in the lifecycle of any SDK Client object that uses 
+ * {@link com.amazonaws.mobile.config.AWSConfiguration}.
+ * 
+ * <p>
+ * Any SDK client that need to be configurable will
+ * implement this interface by overriding these methods.
+ * 
+ * {@link com.amazonaws.mobile.client.AWSMobileClient} will
+ * use these methods to control the creation and initialization of a SDK client.
+ * </p>
+ */
+public interface AWSConfigurable {
+
+    /**
+     * Initialize the SDK Client. This method will construct the instance
+     * of the client and perform basic initialization. The 
+     * {@link com.amazonaws.mobile.config.AWSConfiguration} will be
+     * constructed based on awsconfiguration.json file.
+     * 
+     * @param context               Reference to the application context.
+     * @return the client instance that conforms to AWSConfigurable
+     */
+    public AWSConfigurable initialize(Context context) throws Exception;
+
+    /**
+     * Initialize the SDK Client. This method will construct the instance
+     * of the client and perform basic initialization.
+     * 
+     * @param context               Reference to the application context.
+     * @param configuration         Instance of {@link AWSConfiguration}
+     * @return the client instance that conforms to AWSConfigurable
+     */
+    public AWSConfigurable initialize(Context context,
+                                      AWSConfiguration configuration) throws Exception;
+
+    /**
+     * Initialize the SDK Client. This method will construct the instance
+     * of the client and perform basic initialization.
+     * 
+     * @param context               Reference to the application context.
+     * @param configuration         Instance of {@link AWSConfiguration}
+     * @param clientConfiguration   Instance of {@link com.amazonaws.ClientConfiguration}
+     * @return the client instance that conforms to AWSConfigurable
+     */
+    public AWSConfigurable initialize(Context context,
+                                      AWSConfiguration configuration,
+                                      ClientConfiguration clientConfiguration) throws Exception;
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfiguration.java b/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfiguration.java
new file mode 100644
index 0000000000..18afc37d90
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/mobile/config/AWSConfiguration.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.mobile.config;
+
+import android.content.Context;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.InputStream;
+import java.util.Scanner;
+
+/**
+ * A container for the JSONObject representation of SDK configuration. Reads the
+ * res/raw/awsconfiguration.json file in your project by default. This can be
+ * specified in the constructor through the resource id, if you wish to read a
+ * different resource as your configuration source.
+ */
+public class AWSConfiguration {
+    private static final String DEFAULT = "Default";
+    private static final String DEFAULT_IDENTIFIER = "awsconfiguration";
+
+    private JSONObject mJSONObject;
+    private String configName; // "Default" or something else like "Backup"
+
+    /**
+     * Constructs an AWSConfiguration object
+     * 
+     * @param context application context, used to retrieve
+     *            awsconfiguration.json from resources
+     */
+    public AWSConfiguration(Context context) {
+        this(context, getConfigResourceId(context));
+    }
+    
+    private static int getConfigResourceId(Context context) {
+        try {
+            return context.getResources().getIdentifier(DEFAULT_IDENTIFIER,
+                    "raw", context.getPackageName());
+        } catch (Exception e) {
+            throw new RuntimeException(
+                    "Failed to read awsconfiguration.json"
+                    + " please check that it is correctly formed.",
+                    e);
+        }
+    }
+
+    /**
+     * Constructs an AWSConfiguration object
+     * 
+     * @param context application context, used to retrieve the resource
+     *            specified by configResourceId
+     * @param configResourceId resource id of the json file to be read
+     */
+    public AWSConfiguration(Context context, int configResourceId) {
+        this(context, configResourceId, DEFAULT);
+    }
+
+    /**
+     * Construct an AWSConfiguration object
+     * 
+     * @param context application context, used to retrieve the resource
+     *            specified by configResourceId
+     * @param configResourceId resource id of the json file to be read
+     * @param configName instructs the reader of this configuration to pick the
+     *            specified configName
+     */
+    public AWSConfiguration(Context context, int configResourceId,
+            String configName) {
+        this.configName = configName;
+        readInputJson(context, configResourceId);
+    }
+
+    private void readInputJson(Context context, int resourceId) {
+        try {
+            final InputStream inputStream = context.getResources().openRawResource(
+                    resourceId);
+            final Scanner in = new Scanner(inputStream);
+            final StringBuilder sb = new StringBuilder();
+            while (in.hasNextLine()) {
+                sb.append(in.nextLine());
+            }
+            in.close();
+
+            this.mJSONObject = new JSONObject(sb.toString());
+        } catch (Exception je) {
+            throw new RuntimeException(
+                    "Failed to read awsconfiguration.json please check that it is correctly formed.",
+                    je);
+        }
+    }
+
+    /**
+     * This method will search for the name provided in the json and unwrap the
+     * configuration specified by {@link #setConfiguration(String)}.
+     * 
+     * Example:
+     * {
+     *     "S3TransferUtility": {
+     *         "Default": {
+     *             "Bucket": "waterBucket",
+     *             "Region": "us-west-2"
+     *         }
+     *     }
+     * }
+     * 
+     * When name is "S3TransferUtility" and setConfiguration is "Default",
+     * The value return is:
+     * {
+     *     "Bucket": "waterBucket",
+     *     "Region": "us-west-2"
+     * }
+     * 
+     * Certain keys do not have a configuration (i.e. "Default") and 
+     * when this happens the value for the key is directly returned.
+     * 
+     * @param key used to search for in JSON map
+     * @return an immutable copy of the value mapped by {@code name} if it
+     *         exists and is a {@code JSONObject}, or null otherwise.
+     */
+    public JSONObject optJsonObject(String key) {
+        try {
+            JSONObject value = this.mJSONObject.getJSONObject(key);
+            
+            if (value.has(this.configName)) {
+                value = value.getJSONObject(this.configName);
+            }
+            
+            return new JSONObject(value.toString());
+        } catch (JSONException je) {
+            return null;
+        }
+    }
+    
+    /**
+     * @return The user agent specified in the configuration file.
+     */
+    public String getUserAgent() {
+        try {
+            return this.mJSONObject.getString("UserAgent");
+        } catch (JSONException je) {
+            return "";
+        }
+    }
+
+    /**
+     * Change the settings that are being read in. This is "Default" by default.
+     * 
+     * @param configurationName the key used to differentiate between configuration settings
+     */
+    public void setConfiguration(String configurationName) {
+        this.configName = configurationName;
+    }
+
+    /**
+     * 
+     * @return the configuration This is "Default" by default.
+     */
+    public String getConfiguration() {
+        return this.configName;
+    }
+
+    @Override
+    public String toString() {
+        return mJSONObject.toString();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/mobileconnectors/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/mobileconnectors/package-info.java
new file mode 100644
index 0000000000..9b3ab5b1ee
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/mobileconnectors/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * The mobileconnectors package includes higher level classes that make accessing AWS services from a mobile device more convenient.
+ */
+
+package com.amazonaws.mobileconnectors;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/package-info.java
new file mode 100644
index 0000000000..f1485c70b4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * The amazonaws package includes classes commonly used to support the AWS SDK for Android.
+ */
+package com.amazonaws;
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Region.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Region.java
new file mode 100644
index 0000000000..aeae867723
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Region.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import com.amazonaws.AmazonWebServiceClient;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.auth.AWSCredentialsProvider;
+
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Metadata for an AWS region, including its name and what services are
+ * available in it.
+ */
+public final class Region {
+
+    private static final String DEFAULT_DOMAIN = "amazonaws.com";
+
+    private final String name;
+    private final String domain;
+
+    private final Map<String, String> serviceEndpoints =
+            new HashMap<String, String>();
+
+    private final Map<String, Boolean> httpSupport =
+            new HashMap<String, Boolean>();
+
+    private final Map<String, Boolean> httpsSupport =
+            new HashMap<String, Boolean>();
+
+    Region(final String name, final String domain) {
+        this.name = name;
+
+        if (domain == null || domain.isEmpty()) {
+            this.domain = DEFAULT_DOMAIN;
+        } else {
+            this.domain = domain;
+        }
+    }
+
+    /**
+     * @param region the region.
+     * @return the region with the id given, or null if it cannot be found in
+     * the current regions.xml file.
+     */
+    public static Region getRegion(Regions region) {
+        return RegionUtils.getRegion(region.getName());
+    }
+
+    /**
+     * @param regionString the region represented as a string. i.e. us-east-1
+     * @return the region with the id given, or null if it cannot be found in
+     * the current regions.xml file.
+     */
+    public static Region getRegion(String regionString) {
+        return RegionUtils.getRegion(regionString);
+    }
+
+    /**
+     * The unique system ID for this region; ex: &quot;us-east-1&quot;.
+     *
+     * @return The unique system ID for this region.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns the domain for this region; ex: &quot;amazonaws.com&quot;.
+     *
+     * @return The domain for this region.
+     */
+    public String getDomain() {
+        return domain;
+    }
+
+    /**
+     * @return a map of the available services in this region and their
+     * endpoints. The keys of the map are service abbreviations, as defined in
+     * {@link ServiceAbbreviations}, and the values are the endpoint URLs.
+     *
+     * @return A map of the available services in this region.
+     */
+    Map<String, String> getServiceEndpoints() {
+        return serviceEndpoints;
+    }
+
+    Map<String, Boolean> getHttpSupport() {
+        return httpSupport;
+    }
+
+    Map<String, Boolean> getHttpsSupport() {
+        return httpsSupport;
+    }
+
+    /**
+     * @param serviceName the service name.
+     * @return the endpoint for the service given.
+     *
+     * @see ServiceAbbreviations
+     */
+    public String getServiceEndpoint(String serviceName) {
+        return serviceEndpoints.get(serviceName);
+    }
+
+    /**
+     * @param serviceName the service name.
+     * @return whether the given service is supported in this region.
+     *
+     * @see ServiceAbbreviations
+     */
+    public boolean isServiceSupported(String serviceName) {
+        return serviceEndpoints.containsKey(serviceName);
+    }
+
+    /**
+     * @param serviceName the service name.
+     * @return whether the given service support the https protocol in this
+     * region.
+     *
+     * @see ServiceAbbreviations
+     */
+    public boolean hasHttpsEndpoint(String serviceName) {
+        return httpsSupport.containsKey(serviceName) && httpsSupport.get(serviceName);
+    }
+
+    /**
+     * @param serviceName the service name.
+     * @return whether the given service support the http protocol in this
+     * region.
+     *
+     * @see ServiceAbbreviations
+     */
+    public boolean hasHttpEndpoint(String serviceName) {
+        return httpSupport.containsKey(serviceName) && httpSupport.get(serviceName);
+    }
+
+    /**
+     * Creates a new service client of the class given and configures it. If
+     * credentials or config are null, defaults will be used.
+     *
+     * @param serviceClass The service client class to instantiate, e.g.
+     *            AmazonS3Client.class
+     * @param credentials The credentials provider to use, or null for the
+     *            default credentials provider
+     * @param config The configuration to use, or null for the default
+     *            configuration
+     * @param <T> the AmazonWebServiceClient type.
+     * @return the AmazonWebServiceClient.
+     * @see ServiceAbbreviations
+     */
+    public <T extends AmazonWebServiceClient> T createClient(Class<T> serviceClass,
+            AWSCredentialsProvider credentials,
+            ClientConfiguration config) {
+        Constructor<T> constructor;
+        T client;
+        try {
+            if (credentials == null && config == null) {
+                constructor = serviceClass.getConstructor();
+                client = constructor.newInstance();
+            } else if (credentials == null) {
+                constructor = serviceClass.getConstructor(ClientConfiguration.class);
+                client = constructor.newInstance(config);
+            } else if (config == null) {
+                constructor = serviceClass.getConstructor(AWSCredentialsProvider.class);
+                client = constructor.newInstance(credentials);
+            } else {
+                constructor = serviceClass.getConstructor(AWSCredentialsProvider.class,
+                        ClientConfiguration.class);
+                client = constructor.newInstance(credentials, config);
+            }
+
+            client.setRegion(this);
+            return client;
+        } catch (Exception e) {
+            throw new RuntimeException("Couldn't instantiate instance of " + serviceClass, e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof Region))
+            return false;
+
+        Region region = (Region) obj;
+        return this.getName().equals(region.getName());
+    }
+
+    @Override
+    public int hashCode() {
+        return getName().hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return getName();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionDefaults.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionDefaults.java
new file mode 100644
index 0000000000..20f095349a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionDefaults.java
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2010-2018- Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+class RegionDefaults {
+    public static List<Region> getRegions() {
+
+        final List<Region> ret = new ArrayList<Region>();
+        Region region;
+
+        region = new Region("ap-northeast-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.ap-northeast-1.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.ap-northeast-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "data.iot", "data.iot.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ap-northeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("ap-northeast-2", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.ap-northeast-2.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.ap-northeast-2.amazonaws.com", false,
+                true);
+        updateRegion(region, "data.iot", "data.iot.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ap-northeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.ap-northeast-2.amazonaws.com", false, true);
+
+        region = new Region("ap-south-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.ap-south-1.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ap-south-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("ap-southeast-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.ap-southeast-1.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.ap-southeast-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "data.iot", "data.iot.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ap-southeast-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("ap-southeast-2", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.ap-southeast-2.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.ap-southeast-2.amazonaws.com", false,
+                true);
+        updateRegion(region, "data.iot", "data.iot.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ap-southeast-2.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("ca-central-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.ca-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("eu-central-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.eu-central-1.amazonaws.com",
+                false, true);
+        updateRegion(region, "cognito-idp", "cognito-idp.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "data.iot", "data.iot.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.eu-central-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("eu-west-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.eu-west-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "cognito-idp", "cognito-idp.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "data.iot", "data.iot.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "email", "email.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "machinelearning", "machinelearning.eu-west-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "polly", "polly.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "rekognition", "rekognition.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.eu-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("eu-west-2", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.eu-west-2.amazonaws.com", false,
+                true);
+        updateRegion(region, "cognito-idp", "cognito-idp.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.eu-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("eu-west-3", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.eu-west-3.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("sa-east-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.sa-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("us-east-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.us-east-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "cognito-idp", "cognito-idp.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "data.iot", "data.iot.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "email", "email.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "machinelearning", "machinelearning.us-east-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "mobileanalytics", "mobileanalytics.us-east-1.amazonaws.com", false,
+                true);
+        updateRegion(region, "pinpoint", "pinpoint.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "rekognition", "rekognition.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.us-east-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("us-east-2", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.us-east-2.amazonaws.com", false,
+                true);
+        updateRegion(region, "cognito-idp", "cognito-idp.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.us-east-2.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("us-west-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.us-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("us-west-2", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.us-west-2.amazonaws.com", false,
+                true);
+        updateRegion(region, "cognito-idp", "cognito-idp.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "cognito-sync", "cognito-sync.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "data.iot", "data.iot.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "email", "email.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "firehose", "firehose.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "iot", "iot.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "polly", "polly.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "rekognition", "rekognition.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sdb", "sdb.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.us-west-2.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+
+        region = new Region("cn-north-1", "amazonaws.com.cn");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "cognito-identity", "cognito-identity.cn-north-1.amazonaws.com.cn",
+                false, true);
+        updateRegion(region, "dynamodb", "dynamodb.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "ec2", "ec2.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "iot", "iot.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "kinesis", "kinesis.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "lambda", "lambda.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "logs", "logs.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "s3", "s3.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sns", "sns.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sqs", "sqs.cn-north-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sts", "sts.cn-north-1.amazonaws.com.cn", false, true);
+
+        region = new Region("cn-northwest-1", "amazonaws.com.cn");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.cn-northwest-1.amazonaws.com.cn", false,
+                true);
+        updateRegion(region, "dynamodb", "dynamodb.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "ec2", "ec2.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "kinesis", "kinesis.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "logs", "logs.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "s3", "s3.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sns", "sns.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sqs", "sqs.cn-northwest-1.amazonaws.com.cn", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com.cn", false, true);
+
+        region = new Region("us-gov-west-1", "amazonaws.com");
+        ret.add(region);
+        updateRegion(region, "autoscaling", "autoscaling.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "dynamodb", "dynamodb.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "ec2", "ec2.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "elasticloadbalancing",
+                "elasticloadbalancing.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kinesis", "kinesis.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "kms", "kms.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "lambda", "lambda.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "logs", "logs.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "rekognition", "rekognition.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "s3", "s3.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sns", "sns.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sqs", "sqs.us-gov-west-1.amazonaws.com", false, true);
+        updateRegion(region, "sts", "sts.amazonaws.com", false, true);
+        return ret;
+    }
+
+    private static void updateRegion(Region region, String service, String host,
+            boolean http, boolean https) {
+
+        final Map<String, String> serviceEndpoints = region.getServiceEndpoints();
+        final Map<String, Boolean> httpSupport = region.getHttpSupport();
+        final Map<String, Boolean> httpsSupport = region.getHttpsSupport();
+
+        serviceEndpoints.put(service, host);
+        httpSupport.put(service, http);
+        httpsSupport.put(service, https);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadata.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadata.java
new file mode 100644
index 0000000000..dfe0a2ce70
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadata.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A collection of metadata about a set of regions and the services they
+ * contain.
+ *
+ * @see RegionUtils
+ */
+public class RegionMetadata {
+
+    private final List<Region> regions;
+
+    /**
+     * Creates a new RegionMetadata object from the given list of regions.
+     *
+     * @param regions the list of regions
+     */
+    public RegionMetadata(final List<Region> regions) {
+        if (regions == null) {
+            throw new IllegalArgumentException("regions cannot be null");
+        }
+
+        this.regions =
+                Collections.unmodifiableList(new ArrayList<Region>(regions));
+    }
+
+    /**
+     * Returns an immutable list of all regions known to this region metadata
+     * object, in no particular order.
+     *
+     * @return an immutable list of all regions
+     */
+    public List<Region> getRegions() {
+        return regions;
+    }
+
+    /**
+     * Returns the region with the name given, if it exists. Otherwise, returns
+     * null.
+     *
+     * @param name the name of the region to search for
+     * @return the corresponding region, if it exists
+     */
+    public Region getRegion(final String name) {
+        for (Region region : regions) {
+            if (region.getName().equals(name)) {
+                return region;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns a list of the regions that support the service given.
+     *
+     * @param service the service abbreviation to search for
+     * @return the list of regions with support for the given service
+     * @see ServiceAbbreviations
+     */
+    public List<Region> getRegionsForService(final String service) {
+        List<Region> results = new LinkedList<Region>();
+
+        for (Region region : regions) {
+            if (region.isServiceSupported(service)) {
+                results.add(region);
+            }
+        }
+
+        return results;
+    }
+
+    /**
+     * Searches through all known regions to find one with any service at the
+     * specified endpoint. If no region is found with a service at that
+     * endpoint, an exception is thrown.
+     *
+     * @param endpoint The endpoint for any service residing in the desired
+     *            region.
+     * @return The region containing any service running at the specified
+     *         endpoint, otherwise an exception is thrown if no region is found
+     *         with a service at the specified endpoint.
+     * @throws IllegalArgumentException If the given URL is malformed, or if the
+     *             one of the service URLs on record is malformed.
+     */
+    public Region getRegionByEndpoint(final String endpoint) {
+        String host = getHost(endpoint);
+
+        for (Region region : regions) {
+            for (String serviceEndpoint : region.getServiceEndpoints().values()) {
+
+                if (host.equals(getHost(serviceEndpoint))) {
+                    return region;
+                }
+            }
+        }
+
+        throw new IllegalArgumentException(
+                "No region found with any service for endpoint " + endpoint);
+    }
+
+    /**
+     * Parse the host portion out of an endpoint (which may or may not contain a
+     * scheme).
+     *
+     * @param endpoint the endpoint to parse
+     * @return the host portion of the endpoint
+     */
+    private static String getHost(final String endpoint) {
+        String host = URI.create(endpoint).getHost();
+        if (host == null) {
+            host = URI.create("http://" + endpoint).getHost();
+        }
+        return host;
+    }
+
+    @Override
+    public String toString() {
+        return regions.toString();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadataParser.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadataParser.java
new file mode 100644
index 0000000000..021ac4616e
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionMetadataParser.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+/**
+ * Parses a region metadata file to pull out information about the available
+ * regions, names, IDs, and what service endpoints are available in each region.
+ *
+ * @deprecated The SDK no longer supports a regions.xml override
+ */
+@Deprecated
+public class RegionMetadataParser {
+
+    private static final String REGION_TAG = "Region";
+    private static final String REGION_ID_TAG = "Name";
+    private static final String DOMAIN_TAG = "Domain";
+    private static final String ENDPOINT_TAG = "Endpoint";
+    private static final String SERVICE_TAG = "ServiceName";
+    private static final String HTTP_TAG = "Http";
+    private static final String HTTPS_TAG = "Https";
+    private static final String HOSTNAME_TAG = "Hostname";
+
+    /**
+     * Parses the specified input stream and returns a {@code RegionMetadata}
+     * object.
+     *
+     * @param input the input stream to parse
+     * @return the parsed region metadata
+     * @throws IOException on error
+     */
+    public static RegionMetadata parse(final InputStream input)
+            throws IOException {
+
+        return new RegionMetadata(internalParse(input, false));
+    }
+
+    /**
+     * @deprecated since this object is stateless
+     */
+    @Deprecated
+    public RegionMetadataParser() {
+    }
+
+    /**
+     * Parses the specified input stream and returns a list of the regions
+     * declared in it. By default, verification on the region endpoints is
+     * disabled.
+     *
+     * @param input The stream containing the region metadata to parse.
+     * @return The list of parsed regions.
+     * @deprecated in favor of {@link #parse(InputStream)}
+     */
+    @Deprecated
+    public List<Region> parseRegionMetadata(InputStream input)
+            throws IOException {
+
+        return internalParse(input, false);
+    }
+
+    /**
+     * Parses the specified input stream and optionally verifies that all of the
+     * endpoints end in ".amazonaws.com". This method is deprecated, since not
+     * all valid AWS endpoints end in ".amazonaws.com" any more.
+     *
+     * @param input The stream containing the region metadata to parse.
+     * @param endpointVerification Whether to verify each region endpoint
+     * @return The list of parsed regions.
+     * @deprecated in favor of {@link #parse(InputStream)}
+     */
+    @Deprecated
+    public List<Region> parseRegionMetadata(final InputStream input,
+            final boolean endpointVerification)
+            throws IOException {
+
+        return internalParse(input, endpointVerification);
+    }
+
+    @SuppressWarnings("checkstyle:emptyblock")
+    private static List<Region> internalParse(
+            final InputStream input,
+            final boolean endpointVerification) throws IOException {
+
+        Document document;
+        try {
+
+            DocumentBuilderFactory factory =
+                    DocumentBuilderFactory.newInstance();
+
+            DocumentBuilder documentBuilder = factory.newDocumentBuilder();
+            document = documentBuilder.parse(input);
+
+        } catch (IOException exception) {
+            throw exception;
+        } catch (Exception exception) {
+            throw new IOException("Unable to parse region metadata file: "
+                    + exception.getMessage(),
+                    exception);
+        } finally {
+            try {
+                input.close();
+            } catch (IOException exception) {
+            }
+        }
+
+        NodeList regionNodes = document.getElementsByTagName(REGION_TAG);
+        List<Region> regions = new ArrayList<Region>();
+        for (int i = 0; i < regionNodes.getLength(); i++) {
+            Node node = regionNodes.item(i);
+            if (node.getNodeType() == Node.ELEMENT_NODE) {
+                Element element = (Element) node;
+                regions.add(parseRegionElement(element, endpointVerification));
+            }
+        }
+
+        return regions;
+    }
+
+    private static Region parseRegionElement(
+            final Element regionElement,
+            final boolean endpointVerification) {
+
+        String name = getChildElementValue(REGION_ID_TAG, regionElement);
+        String domain = getChildElementValue(DOMAIN_TAG, regionElement);
+
+        Region region = new Region(name, domain);
+
+        NodeList endpointNodes =
+                regionElement.getElementsByTagName(ENDPOINT_TAG);
+
+        for (int i = 0; i < endpointNodes.getLength(); i++) {
+            addRegionEndpoint(region,
+                    (Element) endpointNodes.item(i),
+                    endpointVerification);
+        }
+
+        return region;
+    }
+
+    private static void addRegionEndpoint(
+            final Region region,
+            final Element endpointElement,
+            final boolean endpointVerification) {
+
+        String serviceName = getChildElementValue(SERVICE_TAG, endpointElement);
+        String hostname = getChildElementValue(HOSTNAME_TAG, endpointElement);
+        String http = getChildElementValue(HTTP_TAG, endpointElement);
+        String https = getChildElementValue(HTTPS_TAG, endpointElement);
+
+        if (endpointVerification && !verifyLegacyEndpoint(hostname)) {
+            throw new IllegalStateException("Invalid service endpoint ("
+                    + hostname + ") is detected.");
+        }
+
+        region.getServiceEndpoints().put(serviceName, hostname);
+        region.getHttpSupport().put(serviceName, "true".equals(http));
+        region.getHttpsSupport().put(serviceName, "true".equals(https));
+    }
+
+    private static String getChildElementValue(
+            final String tagName,
+            final Element element) {
+
+        Node tagNode = element.getElementsByTagName(tagName).item(0);
+        if (tagNode == null)
+            return null;
+        NodeList nodes = tagNode.getChildNodes();
+        Node node = nodes.item(0);
+
+        return node.getNodeValue();
+    }
+
+    /**
+     * Returns whether the provided endpoint is a "valid" AWS service endpoint
+     * ending in ".amazonaws.com".
+     */
+    private static boolean verifyLegacyEndpoint(String endpoint) {
+        return endpoint.endsWith(".amazonaws.com");
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionUtils.java
new file mode 100644
index 0000000000..8a4b4e463a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/RegionUtils.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import static com.amazonaws.SDKGlobalConfiguration.REGIONS_FILE_OVERRIDE_SYSTEM_PROPERTY;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Utilities for working with regions.
+ */
+public class RegionUtils {
+
+    private static List<Region> regions;
+
+    // Use the same logger as the http client
+    private static final Log log = LogFactory.getLog("com.amazonaws.request");
+
+    /**
+     * @return a list of the available AWS regions.
+     */
+    public static synchronized List<Region> getRegions() {
+        if (regions == null) {
+            init();
+        }
+
+        return regions;
+    }
+
+    /**
+     * @param serviceAbbreviation the service abbreviation.
+     * @return a list of the regions that support the service given.
+     *
+     * @see ServiceAbbreviations
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public static synchronized List<Region> getRegionsForService(String serviceAbbreviation) {
+        List<Region> regions = new LinkedList<Region>();
+        for (Region r : getRegions()) {
+            if (r.isServiceSupported(serviceAbbreviation)) {
+                regions.add(r);
+            }
+        }
+        return regions;
+    }
+
+    /**
+     * @param regionName the region name.
+     * @return the region with the id given, if it exists. Otherwise, returns
+     * null.
+     */
+    public static Region getRegion(String regionName) {
+        for (Region r : getRegions()) {
+            if (r.getName().equals(regionName)) {
+                return r;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Searches through all known regions to find one with any service at the
+     * specified endpoint. If no region is found with a service at that
+     * endpoint, an exception is thrown.
+     *
+     * @param endpoint The endpoint for any service residing in the desired
+     *            region.
+     * @return The region containing any service running at the specified
+     *         endpoint, otherwise an exception is thrown if no region is found
+     *         with a service at the specified endpoint.
+     * @throws MalformedURLException If the given URL is malformed, or if the
+     *             one of the service URLs on record is malformed.
+     */
+    public static Region getRegionByEndpoint(String endpoint) {
+        URI targetEndpointUri = getUriByEndpoint(endpoint);
+        String targetHost = targetEndpointUri.getHost();
+
+        for (Region region : getRegions()) {
+            for (String serviceEndpoint : region.getServiceEndpoints().values()) {
+                URI serviceEndpointUrl = getUriByEndpoint(serviceEndpoint);
+
+                if (serviceEndpointUrl.getHost().equals(targetHost))
+                    return region;
+            }
+        }
+
+        throw new IllegalArgumentException("No region found with any service for endpoint "
+                + endpoint);
+    }
+
+    /**
+     * There is no need to call this method, it is public only for
+     * Compatibility. Every regions method makes sure this method has already
+     * been called. This method will load the regions (specified by the
+     * developer if the system property
+     * SDKGlobalConfiguraiton.REGIONS_FILE_OVERRIDE_SYSTEM_PROPERTY is set, or
+     * the defaults shipped with the SDK) into memory.
+     */
+    public static synchronized void init() {
+        if (System.getProperty(REGIONS_FILE_OVERRIDE_SYSTEM_PROPERTY) != null) {
+            try {
+                loadRegionsFromOverrideFile();
+            } catch (FileNotFoundException e) {
+                throw new RuntimeException("Couldn't find regions override file specified", e);
+            }
+        }
+
+        // Fall back onto the version we ship with the SDK
+        if (regions == null) {
+            initSDKRegions();
+        }
+        // Throw out RuntimeException explicitly
+        if (regions == null) {
+            throw new RuntimeException("Failed to initialize the regions.");
+        }
+    }
+
+    private static void loadRegionsFromOverrideFile() throws FileNotFoundException {
+        String overrideFilePath = System.getProperty(REGIONS_FILE_OVERRIDE_SYSTEM_PROPERTY);
+        if (log.isDebugEnabled()) {
+            log.debug("Using local override of the regions file ("
+                    + overrideFilePath
+                    + ") to initiate regions data...");
+        }
+        File regionsFile = new File(overrideFilePath);
+        FileInputStream override = new FileInputStream(regionsFile);
+        initRegions(override);
+    }
+
+    /**
+     * Tries to initialize the regions list from the stream given.
+     *
+     * @param regionsFile The input stream pointing to the retrieved region
+     *            file.
+     */
+    private static void initRegions(InputStream regionsFile) {
+        try {
+            RegionMetadataParser parser = new RegionMetadataParser();
+            regions = parser.parseRegionMetadata(regionsFile);
+        } catch (Exception e) {
+            log.warn("Failed to parse regional endpoints", e);
+        }
+    }
+
+    /**
+     * Failsafe method to initialize the regions list from the list bundled with
+     * the SDK, in case it cannot be fetched from the remote source.
+     */
+    private static void initSDKRegions() {
+        if (log.isDebugEnabled()) {
+            log.debug("Initializing the regions with default regions");
+        }
+        regions = RegionDefaults.getRegions();
+    }
+
+    /**
+     * Get the URI object for the given endpoint. URI class cannot correctly
+     * parse the endpoint if it doesn't include protocol. This method will add
+     * the protocol if this happens.
+     */
+    private static URI getUriByEndpoint(String endpoint) {
+        URI targetEndpointUri = null;
+        try {
+            targetEndpointUri = new URI(endpoint);
+            if (targetEndpointUri.getHost() == null) {
+                targetEndpointUri = new URI("http://" + endpoint);
+            }
+        } catch (URISyntaxException e) {
+            throw new RuntimeException("Unable to parse service endpoint: " + e.getMessage());
+        }
+        return targetEndpointUri;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Regions.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Regions.java
new file mode 100644
index 0000000000..bb0f6e4bb7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/Regions.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+/**
+ * Enumeration of region names
+ */
+public enum Regions {
+
+    /** us-gov-west-1. */
+    GovCloud("us-gov-west-1"),
+
+    /** us-east-1. */
+    US_EAST_1("us-east-1"),
+
+    /** us-east-2. */
+    US_EAST_2("us-east-2"),
+
+    /** us-west-1. */
+    US_WEST_1("us-west-1"),
+
+    /** us-west-2. */
+    US_WEST_2("us-west-2"),
+
+    /** eu-west-1/ */
+    EU_WEST_1("eu-west-1"),
+
+    /** eu-west-2. */
+    EU_WEST_2("eu-west-2"),
+
+    /** eu-west-3. */
+    EU_WEST_3("eu-west-3"),
+
+    /** eu-central-1. */
+    EU_CENTRAL_1("eu-central-1"),
+
+    /** ap-south-1. */
+    AP_SOUTH_1("ap-south-1"),
+
+    /** ap-southeast-1. */
+    AP_SOUTHEAST_1("ap-southeast-1"),
+
+    /** ap-southeast-2. */
+    AP_SOUTHEAST_2("ap-southeast-2"),
+
+    /** ap-northeast-1. */
+    AP_NORTHEAST_1("ap-northeast-1"),
+
+    /** ap-northeast-2. */
+    AP_NORTHEAST_2("ap-northeast-2"),
+
+    /** sa-east-1. */
+    SA_EAST_1("sa-east-1"),
+
+    /** ca-central-1. */
+    CA_CENTRAL_1("ca-central-1"),
+
+    /** cn-north-1. */
+    CN_NORTH_1("cn-north-1"),
+    
+    /** cn-northwest-1. */
+    CN_NORTHWEST_1("cn-northwest-1");
+
+    /**
+     * The default region that new customers in the US are encouraged to use
+     * when using AWS services for the first time.
+     */
+    public static final Regions DEFAULT_REGION = US_WEST_2;
+
+    private final String name;
+
+    private Regions(String name) {
+        this.name = name;
+    }
+
+    /**
+     * @return the name of this region, used in the regions.xml file to identify it.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns a region enum corresponding to the given region name.
+     *
+     * @param regionName The name of the region. Ex.: eu-west-1
+     * @return Region enum representing the given region name.
+     */
+    public static Regions fromName(String regionName) {
+        for (final Regions region : Regions.values()) {
+            if (regionName.equals(region.getName())) {
+                return region;
+            }
+        }
+        throw new IllegalArgumentException("Cannot create enum from " + regionName + " value!");
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/regions/ServiceAbbreviations.java b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/ServiceAbbreviations.java
new file mode 100644
index 0000000000..3b0c771794
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/regions/ServiceAbbreviations.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2013-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+/**
+ * Abbreviations for looking up information about a specific service. Used in
+ * {@link Region#getServiceEndpoint(String)} and related methods.
+ */
+@SuppressWarnings("checkstyle:constantname")
+public final class ServiceAbbreviations {
+
+    /** cloudformation. */
+    public static final String CloudFormation = "cloudformation";
+
+    /** cloudfront. */
+    public static final String CloudFront = "cloudfront";
+
+    /** cloudsearch. */
+    public static final String CloudSearch = "cloudsearch";
+
+    /** cloudwatch. */
+    public static final String CloudWatch = "monitoring";
+
+    /** dynamodb. */
+    public static final String Dynamodb = "dynamodb";
+
+    /** ec2. */
+    public static final String EC2 = "ec2";
+
+    /** elastic map reduce. */
+    public static final String ElasticMapReduce = "elasticmapreduce";
+
+    /** elasticache. */
+    public static final String Elasticache = "elasticache";
+
+    /** rds. */
+    public static final String RDS = "rds";
+
+    /** route53. */
+    public static final String Route53 = "route53";
+
+    /** email. */
+    public static final String Email = "email";
+
+    /** simple db. */
+    public static final String SimpleDB = "sdb";
+
+    /** sns. */
+    public static final String SNS = "sns";
+
+    /** sqs. */
+    public static final String SQS = "sqs";
+
+    /** s3. */
+    public static final String S3 = "s3";
+
+    /** autosclaing. */
+    public static final String Autoscaling = "autoscaling";
+
+    /** elastic bean stalk. */
+    public static final String ElasticBeanstalk = "elasticbeanstalk";
+
+    /** iam. */
+    public static final String IAM = "iam";
+
+    /** import export. */
+    public static final String ImportExport = "importexport";
+
+    /** sts. */
+    public static final String STS = "sts";
+
+    /** storage gateway. */
+    public static final String StorageGateway = "storagegateway";
+
+    /** elastic load balancing. */
+    public static final String ElasticLoadbalancing = "elasticloadbalancing";
+
+    /** simple workflow. */
+    public static final String SimpleWorkflow = "swf";
+
+    /** glacier. */
+    public static final String Glacier = "glacier";
+
+    /** direct connect. */
+    public static final String DirectConnect = "directconnect";
+
+    /** data pipeline. */
+    public static final String DataPipeline = "datapipeline";
+
+    /** redshift. */
+    public static final String RedShift = "redshift";
+
+    /** opsworks. */
+    public static final String Opsworks = "opsworks";
+
+    /** elastic transcoder. */
+    public static final String ElasticTranscoder = "elastictranscoder";
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/retry/PredefinedRetryPolicies.java b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/PredefinedRetryPolicies.java
new file mode 100644
index 0000000000..f3349848b3
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/PredefinedRetryPolicies.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+
+import org.apache.http.HttpStatus;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+
+/**
+ * This class includes a set of pre-defined retry policies, including default
+ * policies used by SDK.
+ */
+public class PredefinedRetryPolicies {
+
+    /** No retry policy **/
+    public static final RetryPolicy NO_RETRY_POLICY = new RetryPolicy(
+            RetryPolicy.RetryCondition.NO_RETRY_CONDITION,
+            RetryPolicy.BackoffStrategy.NO_DELAY,
+            0,      // maxErrorRetry
+            false); // honorMaxErrorRetryInClientConfig
+
+
+    /* SDK default */
+    /** Base sleep time (milliseconds) for throttling exceptions. **/
+    private static final int BASE_DELAY_IN_MILLISECONDS = 100;
+
+    /** Maximum exponential back-off time before retrying a request */
+    private static final int MAX_BACKOFF_IN_MILLISECONDS = 20 * 1000;
+
+    /** SDK default max retry count **/
+    public static final int DEFAULT_MAX_ERROR_RETRY = 3;
+
+    /** SDK default retry policy **/
+    public static final RetryPolicy DEFAULT;
+
+    /* Default for DynamoDB client */
+
+    /** Default max retry count for DynamoDB client **/
+    public static final int DYNAMODB_DEFAULT_MAX_ERROR_RETRY = 10;
+
+    /** Default policy for DynamoDB client **/
+    public static final RetryPolicy DYNAMODB_DEFAULT;
+
+    /* Reusable retry policy components */
+
+    /**
+     * The SDK default retry condition, which checks for various conditions in
+     * the following order:
+     * <ul>
+     * <li>Never retry on requests with non-repeatable content;
+     * <li>Retry on client exceptions caused by IOException;
+     * <li>Retry on service exceptions that are either 500 internal server
+     * errors, 503 service unavailable errors, service throttling errors or
+     * clock skew errors.
+     * </ul>
+     */
+    public static final RetryPolicy.RetryCondition DEFAULT_RETRY_CONDITION = new SDKDefaultRetryCondition();
+
+    /**
+     * The SDK default back-off strategy, which increases exponentially up to a
+     * max amount of delay. It also applies a larger scale factor upon service
+     * throttling exception.
+     */
+    public static final RetryPolicy.BackoffStrategy DEFAULT_BACKOFF_STRATEGY = new SDKDefaultBackoffStrategy(
+            BASE_DELAY_IN_MILLISECONDS, MAX_BACKOFF_IN_MILLISECONDS);
+
+    static {
+        DEFAULT = getDefaultRetryPolicy();
+        DYNAMODB_DEFAULT = getDynamoDBDefaultRetryPolicy();
+    }
+
+    /**
+     * @return the SDK default retry policy. This policy will honor the
+     * maxErrorRetry set in ClientConfiguration.
+     *
+     * @see ClientConfiguration#setMaxErrorRetry(int)
+     */
+    public static RetryPolicy getDefaultRetryPolicy() {
+        return new RetryPolicy(DEFAULT_RETRY_CONDITION,
+                DEFAULT_BACKOFF_STRATEGY,
+                DEFAULT_MAX_ERROR_RETRY,
+                true);
+    }
+
+    /**
+     * @return the default retry policy for DynamoDB client. This policy will
+     * honor the maxErrorRetry set in ClientConfiguration.
+     *
+     * @see ClientConfiguration#setMaxErrorRetry(int)
+     */
+    public static RetryPolicy getDynamoDBDefaultRetryPolicy() {
+        return new RetryPolicy(DEFAULT_RETRY_CONDITION,
+                DEFAULT_BACKOFF_STRATEGY,
+                DYNAMODB_DEFAULT_MAX_ERROR_RETRY,
+                true);
+    }
+
+    /**
+     * @param maxErrorRetry the max error retry count.
+     * @return the SDK default retry policy with the specified max retry count.
+     */
+    public static RetryPolicy getDefaultRetryPolicyWithCustomMaxRetries(int maxErrorRetry) {
+        return new RetryPolicy(DEFAULT_RETRY_CONDITION,
+                DEFAULT_BACKOFF_STRATEGY,
+                maxErrorRetry,
+                false);
+    }
+
+    /**
+     * @param maxErrorRetry the max error retry count.
+     * @return the default retry policy for DynamoDB client with the specified
+     * max retry count.
+     */
+    public static RetryPolicy getDynamoDBDefaultRetryPolicyWithCustomMaxRetries(int maxErrorRetry) {
+        return new RetryPolicy(DEFAULT_RETRY_CONDITION,
+                DEFAULT_BACKOFF_STRATEGY,
+                maxErrorRetry,
+                false);
+    }
+
+    /**
+     * The default implementation of RetryCondition used by the SDK. User could
+     * extend this class to provide additional custom conditions. The default
+     * implementation checks for various conditions in the following order:
+     * <ul>
+     * <li>Retry on client exceptions caused by IOException;
+     * <li>Retry on service exceptions that are either 500 internal server
+     * errors, 503 service unavailable errors, service throttling errors or
+     * clock skew errors.
+     * </ul>
+     */
+    public static class SDKDefaultRetryCondition implements RetryPolicy.RetryCondition {
+
+        @Override
+        public boolean shouldRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retriesAttempted) {
+
+            // Always retry on client exceptions caused by IOException, unless
+            // it's caused by a thread interruption
+            if ((exception.getCause() instanceof IOException)
+                    && !(exception.getCause() instanceof InterruptedIOException))
+                return true;
+
+            // Only retry on a subset of service exceptions
+            if (exception instanceof AmazonServiceException) {
+                AmazonServiceException ase = (AmazonServiceException) exception;
+
+                /*
+                 * For 500 internal server errors and 503 service unavailable
+                 * errors, we want to retry, but we need to use an exponential
+                 * back-off strategy so that we don't overload a server with a
+                 * flood of retries.
+                 */
+                int statusCode = ase.getStatusCode();
+                if (statusCode == HttpStatus.SC_INTERNAL_SERVER_ERROR
+                        || statusCode == HttpStatus.SC_SERVICE_UNAVAILABLE
+                        || statusCode == HttpStatus.SC_BAD_GATEWAY
+                        || statusCode == HttpStatus.SC_GATEWAY_TIMEOUT) {
+                    return true;
+                }
+
+                /*
+                 * Throttling is reported as a 400 error from newer services. To
+                 * try and smooth out an occasional throttling error, we'll
+                 * pause and retry, hoping that the pause is long enough for the
+                 * request to get through the next time.
+                 */
+                if (RetryUtils.isThrottlingException(ase))
+                    return true;
+
+                /*
+                 * Clock skew exception. If it is then we will get the time
+                 * offset between the device time and the server time to set the
+                 * clock skew and then retry the request.
+                 */
+                if (RetryUtils.isClockSkewError(ase))
+                    return true;
+            }
+
+            return false;
+        }
+
+    }
+
+    /** A private class that implements the default back-off strategy. **/
+    private static final class SDKDefaultBackoffStrategy implements RetryPolicy.BackoffStrategy {
+
+        /** For generating a random scale factor **/
+        private final Random random = new Random();
+
+        private final int baseDelayMs;
+        private final int maxDelayMs;
+
+        private SDKDefaultBackoffStrategy(int baseDelayMs, int maxDelayMs) {
+            this.baseDelayMs = baseDelayMs;
+            this.maxDelayMs = maxDelayMs;
+        }
+
+        /** {@inheritDoc} */
+        @Override
+        public final long delayBeforeNextRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retries) {
+            if (retries <= 0)
+                return 0;
+
+            // Full jitter
+            // https://www.awsarchitectureblog.com/2015/03/backoff.html
+            return random.nextInt(Math.min(maxDelayMs, (1 << retries) * baseDelayMs));
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryPolicy.java b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryPolicy.java
new file mode 100644
index 0000000000..46e1fe141b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryPolicy.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+
+/**
+ * Retry policy that can be configured on a specific service client using
+ * {@link ClientConfiguration}. This class is immutable, therefore safe to be
+ * shared by multiple clients.
+ *
+ * @see ClientConfiguration
+ * @see PredefinedRetryPolicies
+ */
+public final class RetryPolicy {
+
+    /**
+     * Condition on whether a request should be retried. This field should not
+     * be null.
+     */
+    private final RetryCondition retryCondition;
+
+    /**
+     * Back-off strategy to control the sleep time between retry attempts. This
+     * field should not be null.
+     */
+    private final BackoffStrategy backoffStrategy;
+
+    /**
+     * Non-negative integer indicating the max retry count.
+     */
+    private final int maxErrorRetry;
+
+    /**
+     * Whether this retry policy should honor the max error retry set in
+     * ClientConfiguration.
+     *
+     * @see ClientConfiguration#setMaxErrorRetry(int)
+     */
+    private final boolean honorMaxErrorRetryInClientConfig;
+
+    /**
+     * Constructs a new retry policy. See {@link PredefinedRetryPolicies} for
+     * some pre-defined policy components, and also the default policies used by
+     * SDK.
+     *
+     * @param retryCondition Retry condition on whether a specific request and
+     *            exception should be retried. If null value is specified, the
+     *            SDK' default retry condition is used.
+     * @param backoffStrategy Back-off strategy for controlling how long the
+     *            next retry should wait. If null value is specified, the SDK'
+     *            default exponential back-off strategy is used.
+     * @param maxErrorRetry Maximum number of retry attempts for failed
+     *            requests.
+     * @param honorMaxErrorRetryInClientConfig Whether this retry policy should
+     *            honor the max error retry set by
+     *            {@link ClientConfiguration#setMaxErrorRetry(int)}
+     * @see ClientConfiguration
+     * @see PredefinedRetryPolicies
+     */
+    public RetryPolicy(RetryCondition retryCondition,
+            BackoffStrategy backoffStrategy,
+            int maxErrorRetry,
+            boolean honorMaxErrorRetryInClientConfig) {
+        if (retryCondition == null) {
+            retryCondition = PredefinedRetryPolicies.DEFAULT_RETRY_CONDITION;
+        }
+        if (backoffStrategy == null) {
+            backoffStrategy = PredefinedRetryPolicies.DEFAULT_BACKOFF_STRATEGY;
+        }
+        if (maxErrorRetry < 0) {
+            throw new IllegalArgumentException(
+                    "Please provide a non-negative value for maxErrorRetry.");
+        }
+
+        this.retryCondition = retryCondition;
+        this.backoffStrategy = backoffStrategy;
+        this.maxErrorRetry = maxErrorRetry;
+        this.honorMaxErrorRetryInClientConfig = honorMaxErrorRetryInClientConfig;
+    };
+
+    /**
+     * Returns the retry condition included in this retry policy.
+     *
+     * @return The retry condition included in this retry policy.
+     */
+    public RetryCondition getRetryCondition() {
+        return retryCondition;
+    }
+
+    /**
+     * Returns the back-off strategy included in this retry policy.
+     *
+     * @return The back-off strategy included in this retry policy.
+     */
+    public BackoffStrategy getBackoffStrategy() {
+        return backoffStrategy;
+    }
+
+    /**
+     * Returns the maximum number of retry attempts.
+     *
+     * @return The maximum number of retry attempts.
+     */
+    public int getMaxErrorRetry() {
+        return maxErrorRetry;
+    }
+
+    /**
+     * Returns whether this retry policy should honor the max error retry set in
+     * ClientConfiguration.
+     *
+     * @return Whether this retry policy should honor the max error retry set in
+     *         ClientConfiguration
+     * @see ClientConfiguration#setMaxErrorRetry(int)
+     */
+    public boolean isMaxErrorRetryInClientConfigHonored() {
+        return honorMaxErrorRetryInClientConfig;
+    }
+
+    /**
+     * The hook for providing custom condition on whether a failed request
+     * should be retried.
+     */
+    public static interface RetryCondition {
+
+        /**
+         * Condition for no retry.
+         */
+        RetryCondition NO_RETRY_CONDITION = new RetryCondition() {
+            @Override
+            public boolean shouldRetry(AmazonWebServiceRequest originalRequest,
+                                       AmazonClientException exception,
+                                       int retriesAttempted) {
+                return false;
+            }
+        };
+
+        /**
+         * Returns whether a failed request should be retried according to the
+         * given request context. In the following circumstances, the request
+         * will fail directly without consulting this method:
+         * <ul>
+         * <li>if it has already reached the max retry limit,
+         * <li>if the request contains non-repeatable content,
+         * <li>if any RuntimeException or Error is thrown when executing the
+         * request.
+         * </ul>
+         *
+         * @param originalRequest The original request object being executed.
+         *            For performance reason, this object is not a defensive
+         *            copy, and caller should not attempt to modify its data.
+         * @param exception The exception from the failed request, represented
+         *            as an AmazonClientException object. There are two types of
+         *            exception that will be passed to this method:
+         *            <ul>
+         *            <li>AmazonServiceException (sub-class of
+         *            AmazonClientException) indicating a service error
+         *            <li>AmazonClientException caused by an IOException when
+         *            executing the HTTP request.
+         *            </ul>
+         *            Any other exceptions are regarded as unexpected failures
+         *            and are thrown immediately without any retry. For
+         *            performance reason, this object is not a defensive copy,
+         *            and caller should not attempt to modify its data.
+         * @param retriesAttempted The number of times the current request has
+         *            been attempted.
+         * @return True if the failed request should be retried.
+         */
+        public boolean shouldRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retriesAttempted);
+
+    }
+
+    /**
+     * The hook for providing custom back-off strategy to control the sleep time
+     * between retries.
+     */
+    public static interface BackoffStrategy {
+
+        /**
+         * Backoff strategy.
+         */
+        RetryPolicy.BackoffStrategy NO_DELAY = new BackoffStrategy() {
+            @Override
+            public long delayBeforeNextRetry(AmazonWebServiceRequest originalRequest,
+                    AmazonClientException exception,
+                    int retriesAttempted) {
+                return 0;
+            }
+        };
+
+        /**
+         * Returns the delay (in milliseconds) before next retry attempt.
+         *
+         * @param originalRequest The original request object being executed.
+         *            For performance reason, this object is not a defensive
+         *            copy, and caller should not attempt to modify its data.
+         * @param exception The exception from the failed request, represented
+         *            as an AmazonClientException object. There are two types of
+         *            exception that will be passed to this method:
+         *            <ul>
+         *            <li>AmazonServiceException (sub-class of
+         *            AmazonClientException) indicating a service error
+         *            <li>AmazonClientException caused by an IOException when
+         *            executing the HTTP request.
+         *            </ul>
+         *            Any other exceptions are regarded as unexpected failures
+         *            and are thrown immediately without any retry. For
+         *            performance reason, this object is not a defensive copy,
+         *            and caller should not attempt to modify its data.
+         * @param retriesAttempted The number of times the current request has
+         *            been attempted (not including the next attempt after the
+         *            delay).
+         * @return The delay (in milliseconds) before next retry attempt.
+         */
+        public long delayBeforeNextRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retriesAttempted);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryUtils.java
new file mode 100644
index 0000000000..4b32131628
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/retry/RetryUtils.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AbortedException;
+import com.amazonaws.AmazonServiceException;
+
+import java.io.InterruptedIOException;
+import java.net.SocketTimeoutException;
+
+/** RetryUtils class. */
+public class RetryUtils {
+
+    /**
+     * Returns true if the specified exception is a throttling error.
+     *
+     * @param ase The exception to test.
+     * @return True if the exception resulted from a throttling error message
+     *         from a service, otherwise false.
+     */
+    public static boolean isThrottlingException(AmazonServiceException ase) {
+        if (ase == null)
+            return false;
+
+        String errorCode = ase.getErrorCode();
+        return "Throttling".equals(errorCode)
+                || "ThrottlingException".equals(errorCode)
+                || "ProvisionedThroughputExceededException".equals(errorCode);
+    }
+
+    /**
+     * Returns true if the specified exception is a request entity too large
+     * error.
+     *
+     * @param ase The exception to test.
+     * @return True if the exception resulted from a request entity too large
+     *         error message from a service, otherwise false.
+     */
+    public static boolean isRequestEntityTooLargeException(AmazonServiceException ase) {
+        if (ase == null)
+            return false;
+        return "Request entity too large".equals(ase.getErrorCode());
+    }
+
+    /**
+     * Returns true if the specified exception is a clock skew error.
+     *
+     * @param ase The exception to test.
+     * @return True if the exception resulted from a clock skews error message
+     *         from a service, otherwise false.
+     */
+    public static boolean isClockSkewError(AmazonServiceException ase) {
+        if (ase == null)
+            return false;
+
+        String errorCode = ase.getErrorCode();
+        return "RequestTimeTooSkewed".equals(errorCode)
+                || "RequestExpired".equals(errorCode)
+                || "InvalidSignatureException".equals(errorCode)
+                || "SignatureDoesNotMatch".equals(errorCode);
+    }
+
+    /**
+     * Return true if the error is caused by interruption.
+     *
+     * @param error throwable
+     * @return true if the exception is caused by interruption.
+     */
+    public static boolean isInterrupted(Throwable error) {
+        if (error instanceof AbortedException) {
+            return true;
+        }
+        if (error.getCause() != null) {
+            Throwable cause = error.getCause();
+            /*
+             * InterruptedIOException is thrown by OkHttp when connection is
+             * interrupted. SocketTimeoutException is a subclass of
+             * InterruptedIOException. It's caused by timeout and should be
+             * excluded.
+             */
+            if (cause instanceof InterruptedException
+                    || cause instanceof InterruptedIOException
+                    && !(cause instanceof SocketTimeoutException)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentity.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentity.java
new file mode 100644
index 0000000000..d08d54a0ca
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentity.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity;
+
+import com.amazonaws.*;
+import com.amazonaws.regions.*;
+import com.amazonaws.services.cognitoidentity.model.*;
+
+/**
+ * Interface for accessing Amazon Cognito Identity <fullname>Amazon
+ * Cognito</fullname>
+ * <p>
+ * Amazon Cognito is a web service that delivers scoped temporary credentials to
+ * mobile devices and other untrusted environments. Amazon Cognito uniquely
+ * identifies a device and supplies the user with a consistent identity over the
+ * lifetime of an application.
+ * </p>
+ * <p>
+ * Using Amazon Cognito, you can enable authentication with one or more
+ * third-party identity providers (Facebook, Google, or Login with Amazon), and
+ * you can also choose to support unauthenticated access from your app. Cognito
+ * delivers a unique identifier for each user and acts as an OpenID token
+ * provider trusted by AWS Security Token Service (STS) to access temporary,
+ * limited-privilege AWS credentials.
+ * </p>
+ * <p>
+ * To provide end-user credentials, first make an unsigned call to <a>GetId</a>.
+ * If the end user is authenticated with one of the supported identity
+ * providers, set the <code>Logins</code> map with the identity provider token.
+ * <code>GetId</code> returns a unique identifier for the user.
+ * </p>
+ * <p>
+ * Next, make an unsigned call to <a>GetCredentialsForIdentity</a>. This call
+ * expects the same <code>Logins</code> map as the <code>GetId</code> call, as
+ * well as the <code>IdentityID</code> originally returned by <code>GetId</code>
+ * . Assuming your identity pool has been configured via the
+ * <a>SetIdentityPoolRoles</a> operation, <code>GetCredentialsForIdentity</code>
+ * will return AWS credentials for your use. If your pool has not been
+ * configured with <code>SetIdentityPoolRoles</code>, or if you want to follow
+ * legacy flow, make an unsigned call to <a>GetOpenIdToken</a>, which returns
+ * the OpenID token necessary to call STS and retrieve AWS credentials. This
+ * call expects the same <code>Logins</code> map as the <code>GetId</code> call,
+ * as well as the <code>IdentityID</code> originally returned by
+ * <code>GetId</code>. The token returned by <code>GetOpenIdToken</code> can be
+ * passed to the STS operation <a href=
+ * "http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html"
+ * >AssumeRoleWithWebIdentity</a> to retrieve AWS credentials.
+ * </p>
+ * <p>
+ * If you want to use Amazon Cognito in an Android, iOS, or Unity application,
+ * you will probably want to make API calls via the AWS Mobile SDK. To learn
+ * more, see the <a href="http://docs.aws.amazon.com/mobile/index.html">AWS
+ * Mobile SDK Developer Guide</a>.
+ * </p>
+ **/
+public interface AmazonCognitoIdentity {
+
+    /**
+     * Overrides the default endpoint for this client
+     * ("https://cognito-identity.us-east-1.amazonaws.com"). Callers can use
+     * this method to control which AWS region they want to work with.
+     * <p>
+     * Callers can pass in just the endpoint (ex:
+     * "cognito-identity.us-east-1.amazonaws.com") or a full URL, including the
+     * protocol (ex: "https://cognito-identity.us-east-1.amazonaws.com"). If the
+     * protocol is not specified here, the default protocol from this client's
+     * {@link ClientConfiguration} will be used, which by default is HTTPS.
+     * <p>
+     * For more information on using AWS regions with the AWS SDK for Java, and
+     * a complete list of all available endpoints for all AWS services, see: <a
+     * href=
+     * "http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912"
+     * > http://developer.amazonwebservices.com/connect/entry.jspa?externalID=
+     * 3912</a>
+     * <p>
+     * <b>This method is not threadsafe. An endpoint should be configured when
+     * the client is created and before any service requests are made. Changing
+     * it afterwards creates inevitable race conditions for any service requests
+     * in transit or retrying.</b>
+     *
+     * @param endpoint The endpoint (ex:
+     *            "cognito-identity.us-east-1.amazonaws.com") or a full URL,
+     *            including the protocol (ex:
+     *            "https://cognito-identity.us-east-1.amazonaws.com") of the
+     *            region specific AWS endpoint this client will communicate
+     *            with.
+     * @throws IllegalArgumentException If any problems are detected with the
+     *             specified endpoint.
+     */
+    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;
+
+    /**
+     * An alternative to {@link AmazonCognitoIdentity#setEndpoint(String)}, sets
+     * the regional endpoint for this client's service calls. Callers can use
+     * this method to control which AWS region they want to work with.
+     * <p>
+     * By default, all service endpoints in all regions use the https protocol.
+     * To use http instead, specify it in the {@link ClientConfiguration}
+     * supplied at construction.
+     * <p>
+     * <b>This method is not threadsafe. A region should be configured when the
+     * client is created and before any service requests are made. Changing it
+     * afterwards creates inevitable race conditions for any service requests in
+     * transit or retrying.</b>
+     *
+     * @param region The region this client will communicate with. See
+     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
+     *            accessing a given region.
+     * @throws java.lang.IllegalArgumentException If the given region is null,
+     *             or if this service isn't available in the given region. See
+     *             {@link Region#isServiceSupported(String)}
+     * @see Region#getRegion(com.amazonaws.regions.Regions)
+     * @see Region#createClient(Class,
+     *      com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
+     */
+    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
+
+    /**
+     * <p>
+     * Returns credentials for the provided identity ID. Any provided logins
+     * will be validated against supported login providers. If the token is for
+     * cognito-identity.amazonaws.com, it will be passed through to AWS Security
+     * Token Service with the appropriate role for the token.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getCredentialsForIdentityRequest <p>
+     *            Input to the <code>GetCredentialsForIdentity</code> action.
+     *            </p>
+     * @return getCredentialsForIdentityResult The response from the
+     *         GetCredentialsForIdentity service method, as returned by Amazon
+     *         Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InvalidIdentityPoolConfigurationException
+     * @throws InternalErrorException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    GetCredentialsForIdentityResult getCredentialsForIdentity(
+            GetCredentialsForIdentityRequest getCredentialsForIdentityRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Generates (or retrieves) a Cognito ID. Supplying multiple logins will
+     * create an implicit linked account.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getIdRequest Input to the GetId action.
+     * @return getIdResult The response from the GetId service method, as
+     *         returned by Amazon Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InternalErrorException
+     * @throws LimitExceededException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    GetIdResult getId(GetIdRequest getIdRequest) throws AmazonClientException,
+            AmazonServiceException;
+
+    /**
+     * <p>
+     * Gets an OpenID token, using a known Cognito ID. This known Cognito ID is
+     * returned by <a>GetId</a>. You can optionally add additional logins for
+     * the identity. Supplying multiple logins creates an implicit link.
+     * </p>
+     * <p>
+     * The OpenId token is valid for 15 minutes.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getOpenIdTokenRequest Input to the GetOpenIdToken action.
+     * @return getOpenIdTokenResult The response from the GetOpenIdToken service
+     *         method, as returned by Amazon Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InternalErrorException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    GetOpenIdTokenResult getOpenIdToken(GetOpenIdTokenRequest getOpenIdTokenRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * Shuts down this client object, releasing any resources that might be held
+     * open. This is an optional method, and callers are not expected to call
+     * it, but can if they want to explicitly release any open resources. Once a
+     * client has been shutdown, it should not be used to make any more
+     * requests.
+     */
+    public void shutdown();
+
+    /**
+     * Returns additional metadata for a previously executed successful request,
+     * typically used for debugging issues where a service isn't acting as
+     * expected. This data isn't considered part of the result data returned by
+     * an operation, so it's available through this separate, diagnostic
+     * interface.
+     * <p>
+     * Response metadata is only cached for a limited period of time, so if you
+     * need to access this extra diagnostic information for an executed request,
+     * you should use this method to retrieve it as soon as possible after
+     * executing a request.
+     *
+     * @param request The originally executed request.
+     * @return The response metadata for the specified request, or null if none
+     *         is available.
+     */
+    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
new file mode 100644
index 0000000000..e391cc8033
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
@@ -0,0 +1,563 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity;
+
+import java.util.*;
+
+import com.amazonaws.*;
+import com.amazonaws.auth.*;
+import com.amazonaws.handlers.*;
+import com.amazonaws.http.*;
+import com.amazonaws.internal.*;
+import com.amazonaws.metrics.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.*;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.services.cognitoidentity.model.transform.*;
+
+/**
+ * Client for accessing Amazon Cognito Identity. All service calls made using
+ * this client are blocking, and will not return until the service call
+ * completes.
+ * <p>
+ * <fullname>Amazon Cognito</fullname>
+ * <p>
+ * Amazon Cognito is a web service that delivers scoped temporary credentials to
+ * mobile devices and other untrusted environments. Amazon Cognito uniquely
+ * identifies a device and supplies the user with a consistent identity over the
+ * lifetime of an application.
+ * </p>
+ * <p>
+ * Using Amazon Cognito, you can enable authentication with one or more
+ * third-party identity providers (Facebook, Google, or Login with Amazon), and
+ * you can also choose to support unauthenticated access from your app. Cognito
+ * delivers a unique identifier for each user and acts as an OpenID token
+ * provider trusted by AWS Security Token Service (STS) to access temporary,
+ * limited-privilege AWS credentials.
+ * </p>
+ * <p>
+ * To provide end-user credentials, first make an unsigned call to <a>GetId</a>.
+ * If the end user is authenticated with one of the supported identity
+ * providers, set the <code>Logins</code> map with the identity provider token.
+ * <code>GetId</code> returns a unique identifier for the user.
+ * </p>
+ * <p>
+ * Next, make an unsigned call to <a>GetCredentialsForIdentity</a>. This call
+ * expects the same <code>Logins</code> map as the <code>GetId</code> call, as
+ * well as the <code>IdentityID</code> originally returned by <code>GetId</code>
+ * . Assuming your identity pool has been configured via the
+ * <a>SetIdentityPoolRoles</a> operation, <code>GetCredentialsForIdentity</code>
+ * will return AWS credentials for your use. If your pool has not been
+ * configured with <code>SetIdentityPoolRoles</code>, or if you want to follow
+ * legacy flow, make an unsigned call to <a>GetOpenIdToken</a>, which returns
+ * the OpenID token necessary to call STS and retrieve AWS credentials. This
+ * call expects the same <code>Logins</code> map as the <code>GetId</code> call,
+ * as well as the <code>IdentityID</code> originally returned by
+ * <code>GetId</code>. The token returned by <code>GetOpenIdToken</code> can be
+ * passed to the STS operation <a href=
+ * "http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html"
+ * >AssumeRoleWithWebIdentity</a> to retrieve AWS credentials.
+ * </p>
+ * <p>
+ * If you want to use Amazon Cognito in an Android, iOS, or Unity application,
+ * you will probably want to make API calls via the AWS Mobile SDK. To learn
+ * more, see the <a href="http://docs.aws.amazon.com/mobile/index.html">AWS
+ * Mobile SDK Developer Guide</a>.
+ * </p>
+ */
+public class AmazonCognitoIdentityClient extends AmazonWebServiceClient implements
+        AmazonCognitoIdentity {
+    /** Provider for AWS credentials. */
+    private AWSCredentialsProvider awsCredentialsProvider;
+
+    /**
+     * List of exception unmarshallers for all Amazon Cognito Identity
+     * exceptions.
+     */
+    protected List<JsonErrorUnmarshaller> jsonErrorUnmarshallers;
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity. A credentials provider chain will be used that
+     * searches for credentials in this order:
+     * <ul>
+     * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>
+     * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>
+     * <li>Instance profile credentials delivered through the Amazon EC2
+     * metadata service</li>
+     * </ul>
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @see DefaultAWSCredentialsProviderChain
+     */
+    @Deprecated
+    public AmazonCognitoIdentityClient() {
+        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity. A credentials provider chain will be used that
+     * searches for credentials in this order:
+     * <ul>
+     * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>
+     * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>
+     * <li>Instance profile credentials delivered through the Amazon EC2
+     * metadata service</li>
+     * </ul>
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AmazonCognitoIdentity (ex: proxy
+     *            settings, retry counts, etc.).
+     * @see DefaultAWSCredentialsProviderChain
+     */
+    @Deprecated
+    public AmazonCognitoIdentityClient(ClientConfiguration clientConfiguration) {
+        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentials The AWS credentials (access key ID and secret key)
+     *            to use when authenticating with AWS services.
+     */
+    public AmazonCognitoIdentityClient(AWSCredentials awsCredentials) {
+        this(awsCredentials, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials and
+     * client configuration options.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentials The AWS credentials (access key ID and secret key)
+     *            to use when authenticating with AWS services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AmazonCognitoIdentity (ex: proxy
+     *            settings, retry counts, etc.).
+     */
+    public AmazonCognitoIdentityClient(AWSCredentials awsCredentials,
+            ClientConfiguration clientConfiguration) {
+        this(new StaticCredentialsProvider(awsCredentials), clientConfiguration);
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials
+     * provider.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     */
+    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider) {
+        this(awsCredentialsProvider, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials
+     * provider and client configuration options.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AmazonCognitoIdentity (ex: proxy
+     *            settings, retry counts, etc.).
+     */
+    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration) {
+        this(awsCredentialsProvider, clientConfiguration, new UrlHttpClient(clientConfiguration));
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials
+     * provider, client configuration options and request metric collector.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AmazonCognitoIdentity (ex: proxy
+     *            settings, retry counts, etc.).
+     * @param requestMetricCollector optional request metric collector
+     */
+    @Deprecated
+    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration,
+            RequestMetricCollector requestMetricCollector) {
+        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
+
+        this.awsCredentialsProvider = awsCredentialsProvider;
+
+        init();
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AmazonCognitoIdentity using the specified AWS account credentials
+     * provider, client configuration options and request metric collector.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AmazonCognitoIdentity (ex: proxy
+     *            settings, retry counts, etc.).
+     * @param httpClient A http client
+     */
+    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration, HttpClient httpClient) {
+        super(adjustClientConfiguration(clientConfiguration), httpClient);
+
+        this.awsCredentialsProvider = awsCredentialsProvider;
+
+        init();
+    }
+
+    private void init() {
+        jsonErrorUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
+        jsonErrorUnmarshallers.add(new ExternalServiceExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new InternalErrorExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new InvalidIdentityPoolConfigurationExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new InvalidParameterExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new LimitExceededExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new NotAuthorizedExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new ResourceConflictExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new ResourceNotFoundExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new TooManyRequestsExceptionUnmarshaller());
+        jsonErrorUnmarshallers.add(new JsonErrorUnmarshaller());
+
+        // calling this.setEndPoint(...) will also modify the signer accordingly
+        this.setEndpoint("cognito-identity.us-east-1.amazonaws.com");
+        this.endpointPrefix = "cognito-identity";
+
+        HandlerChainFactory chainFactory = new HandlerChainFactory();
+        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
+                "/com/amazonaws/services/cognitoidentity/request.handlers"));
+        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
+                "/com/amazonaws/services/cognitoidentity/request.handler2s"));
+    }
+
+    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
+        ClientConfiguration config = orig;
+
+        return config;
+    }
+
+    /**
+     * <p>
+     * Returns credentials for the provided identity ID. Any provided logins
+     * will be validated against supported login providers. If the token is for
+     * cognito-identity.amazonaws.com, it will be passed through to AWS Security
+     * Token Service with the appropriate role for the token.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getCredentialsForIdentityRequest <p>
+     *            Input to the <code>GetCredentialsForIdentity</code> action.
+     *            </p>
+     * @return getCredentialsForIdentityResult The response from the
+     *         GetCredentialsForIdentity service method, as returned by Amazon
+     *         Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InvalidIdentityPoolConfigurationException
+     * @throws InternalErrorException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    public GetCredentialsForIdentityResult getCredentialsForIdentity(
+            GetCredentialsForIdentityRequest getCredentialsForIdentityRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getCredentialsForIdentityRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetCredentialsForIdentityRequest> request = null;
+        Response<GetCredentialsForIdentityResult> response = null;
+        try {
+            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
+            try {
+                request = new GetCredentialsForIdentityRequestMarshaller()
+                        .marshall(getCredentialsForIdentityRequest);
+                // Binds the request metrics to the current request.
+                request.setAWSRequestMetrics(awsRequestMetrics);
+            } finally {
+                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
+            }
+            Unmarshaller<GetCredentialsForIdentityResult, JsonUnmarshallerContext> unmarshaller = new GetCredentialsForIdentityResultJsonUnmarshaller();
+            JsonResponseHandler<GetCredentialsForIdentityResult> responseHandler = new JsonResponseHandler<GetCredentialsForIdentityResult>(
+                    unmarshaller);
+
+            response = invoke(request, responseHandler, executionContext);
+
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
+        }
+    }
+
+    /**
+     * <p>
+     * Generates (or retrieves) a Cognito ID. Supplying multiple logins will
+     * create an implicit linked account.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getIdRequest Input to the GetId action.
+     * @return getIdResult The response from the GetId service method, as
+     *         returned by Amazon Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InternalErrorException
+     * @throws LimitExceededException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    public GetIdResult getId(GetIdRequest getIdRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getIdRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetIdRequest> request = null;
+        Response<GetIdResult> response = null;
+        try {
+            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
+            try {
+                request = new GetIdRequestMarshaller().marshall(getIdRequest);
+                // Binds the request metrics to the current request.
+                request.setAWSRequestMetrics(awsRequestMetrics);
+            } finally {
+                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
+            }
+            Unmarshaller<GetIdResult, JsonUnmarshallerContext> unmarshaller = new GetIdResultJsonUnmarshaller();
+            JsonResponseHandler<GetIdResult> responseHandler = new JsonResponseHandler<GetIdResult>(
+                    unmarshaller);
+
+            response = invoke(request, responseHandler, executionContext);
+
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
+        }
+    }
+
+    /**
+     * <p>
+     * Gets an OpenID token, using a known Cognito ID. This known Cognito ID is
+     * returned by <a>GetId</a>. You can optionally add additional logins for
+     * the identity. Supplying multiple logins creates an implicit link.
+     * </p>
+     * <p>
+     * The OpenId token is valid for 15 minutes.
+     * </p>
+     * <p>
+     * This is a public API. You do not need any credentials to call this API.
+     * </p>
+     * 
+     * @param getOpenIdTokenRequest Input to the GetOpenIdToken action.
+     * @return getOpenIdTokenResult The response from the GetOpenIdToken service
+     *         method, as returned by Amazon Cognito Identity.
+     * @throws InvalidParameterException
+     * @throws ResourceNotFoundException
+     * @throws NotAuthorizedException
+     * @throws ResourceConflictException
+     * @throws TooManyRequestsException
+     * @throws InternalErrorException
+     * @throws ExternalServiceException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by Amazon
+     *             Cognito Identity indicating either a problem with the data in
+     *             the request, or a server side issue.
+     */
+    public GetOpenIdTokenResult getOpenIdToken(GetOpenIdTokenRequest getOpenIdTokenRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getOpenIdTokenRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetOpenIdTokenRequest> request = null;
+        Response<GetOpenIdTokenResult> response = null;
+        try {
+            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
+            try {
+                request = new GetOpenIdTokenRequestMarshaller().marshall(getOpenIdTokenRequest);
+                // Binds the request metrics to the current request.
+                request.setAWSRequestMetrics(awsRequestMetrics);
+            } finally {
+                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
+            }
+            Unmarshaller<GetOpenIdTokenResult, JsonUnmarshallerContext> unmarshaller = new GetOpenIdTokenResultJsonUnmarshaller();
+            JsonResponseHandler<GetOpenIdTokenResult> responseHandler = new JsonResponseHandler<GetOpenIdTokenResult>(
+                    unmarshaller);
+
+            response = invoke(request, responseHandler, executionContext);
+
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
+        }
+    }
+
+    /**
+     * Returns additional metadata for a previously executed successful,
+     * request, typically used for debugging issues where a service isn't acting
+     * as expected. This data isn't considered part of the result data returned
+     * by an operation, so it's available through this separate, diagnostic
+     * interface.
+     * <p>
+     * Response metadata is only cached for a limited period of time, so if you
+     * need to access this extra diagnostic information for an executed request,
+     * you should use this method to retrieve it as soon as possible after
+     * executing the request.
+     *
+     * @param request The originally executed request
+     * @return The response metadata for the specified request, or null if none
+     *         is available.
+     * @deprecated ResponseMetadata cache can hold up to 50 requests and
+     *             responses in memory and will cause memory issue. This method
+     *             now always returns null.
+     */
+    @Deprecated
+    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
+        return client.getResponseMetadataForRequest(request);
+    }
+
+    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
+            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
+            ExecutionContext executionContext) {
+        request.setEndpoint(endpoint);
+        request.setTimeOffset(timeOffset);
+
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        AWSCredentials credentials;
+        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
+        try {
+            credentials = awsCredentialsProvider.getCredentials();
+        } finally {
+            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
+        }
+
+        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
+        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
+            credentials = originalRequest.getRequestCredentials();
+        }
+
+        executionContext.setCredentials(credentials);
+        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(
+                jsonErrorUnmarshallers);
+        Response<X> result = client.execute(request, responseHandler,
+                errorResponseHandler, executionContext);
+        return result;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/Credentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/Credentials.java
new file mode 100644
index 0000000000..860cc9c8b0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/Credentials.java
@@ -0,0 +1,304 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Credentials for the provided identity ID.
+ * </p>
+ */
+public class Credentials implements Serializable {
+    /**
+     * <p>
+     * The Access Key portion of the credentials.
+     * </p>
+     */
+    private String accessKeyId;
+
+    /**
+     * <p>
+     * The Secret Access Key portion of the credentials
+     * </p>
+     */
+    private String secretKey;
+
+    /**
+     * <p>
+     * The Session Token portion of the credentials
+     * </p>
+     */
+    private String sessionToken;
+
+    /**
+     * <p>
+     * The date at which these credentials will expire.
+     * </p>
+     */
+    private java.util.Date expiration;
+
+    /**
+     * <p>
+     * The Access Key portion of the credentials.
+     * </p>
+     *
+     * @return <p>
+     *         The Access Key portion of the credentials.
+     *         </p>
+     */
+    public String getAccessKeyId() {
+        return accessKeyId;
+    }
+
+    /**
+     * <p>
+     * The Access Key portion of the credentials.
+     * </p>
+     *
+     * @param accessKeyId <p>
+     *            The Access Key portion of the credentials.
+     *            </p>
+     */
+    public void setAccessKeyId(String accessKeyId) {
+        this.accessKeyId = accessKeyId;
+    }
+
+    /**
+     * <p>
+     * The Access Key portion of the credentials.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param accessKeyId <p>
+     *            The Access Key portion of the credentials.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withAccessKeyId(String accessKeyId) {
+        this.accessKeyId = accessKeyId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The Secret Access Key portion of the credentials
+     * </p>
+     *
+     * @return <p>
+     *         The Secret Access Key portion of the credentials
+     *         </p>
+     */
+    public String getSecretKey() {
+        return secretKey;
+    }
+
+    /**
+     * <p>
+     * The Secret Access Key portion of the credentials
+     * </p>
+     *
+     * @param secretKey <p>
+     *            The Secret Access Key portion of the credentials
+     *            </p>
+     */
+    public void setSecretKey(String secretKey) {
+        this.secretKey = secretKey;
+    }
+
+    /**
+     * <p>
+     * The Secret Access Key portion of the credentials
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param secretKey <p>
+     *            The Secret Access Key portion of the credentials
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withSecretKey(String secretKey) {
+        this.secretKey = secretKey;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The Session Token portion of the credentials
+     * </p>
+     *
+     * @return <p>
+     *         The Session Token portion of the credentials
+     *         </p>
+     */
+    public String getSessionToken() {
+        return sessionToken;
+    }
+
+    /**
+     * <p>
+     * The Session Token portion of the credentials
+     * </p>
+     *
+     * @param sessionToken <p>
+     *            The Session Token portion of the credentials
+     *            </p>
+     */
+    public void setSessionToken(String sessionToken) {
+        this.sessionToken = sessionToken;
+    }
+
+    /**
+     * <p>
+     * The Session Token portion of the credentials
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param sessionToken <p>
+     *            The Session Token portion of the credentials
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withSessionToken(String sessionToken) {
+        this.sessionToken = sessionToken;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The date at which these credentials will expire.
+     * </p>
+     *
+     * @return <p>
+     *         The date at which these credentials will expire.
+     *         </p>
+     */
+    public java.util.Date getExpiration() {
+        return expiration;
+    }
+
+    /**
+     * <p>
+     * The date at which these credentials will expire.
+     * </p>
+     *
+     * @param expiration <p>
+     *            The date at which these credentials will expire.
+     *            </p>
+     */
+    public void setExpiration(java.util.Date expiration) {
+        this.expiration = expiration;
+    }
+
+    /**
+     * <p>
+     * The date at which these credentials will expire.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param expiration <p>
+     *            The date at which these credentials will expire.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withExpiration(java.util.Date expiration) {
+        this.expiration = expiration;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getAccessKeyId() != null)
+            sb.append("AccessKeyId: " + getAccessKeyId() + ",");
+        if (getSecretKey() != null)
+            sb.append("SecretKey: " + getSecretKey() + ",");
+        if (getSessionToken() != null)
+            sb.append("SessionToken: " + getSessionToken() + ",");
+        if (getExpiration() != null)
+            sb.append("Expiration: " + getExpiration());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getAccessKeyId() == null) ? 0 : getAccessKeyId().hashCode());
+        hashCode = prime * hashCode + ((getSecretKey() == null) ? 0 : getSecretKey().hashCode());
+        hashCode = prime * hashCode
+                + ((getSessionToken() == null) ? 0 : getSessionToken().hashCode());
+        hashCode = prime * hashCode + ((getExpiration() == null) ? 0 : getExpiration().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof Credentials == false)
+            return false;
+        Credentials other = (Credentials) obj;
+
+        if (other.getAccessKeyId() == null ^ this.getAccessKeyId() == null)
+            return false;
+        if (other.getAccessKeyId() != null
+                && other.getAccessKeyId().equals(this.getAccessKeyId()) == false)
+            return false;
+        if (other.getSecretKey() == null ^ this.getSecretKey() == null)
+            return false;
+        if (other.getSecretKey() != null
+                && other.getSecretKey().equals(this.getSecretKey()) == false)
+            return false;
+        if (other.getSessionToken() == null ^ this.getSessionToken() == null)
+            return false;
+        if (other.getSessionToken() != null
+                && other.getSessionToken().equals(this.getSessionToken()) == false)
+            return false;
+        if (other.getExpiration() == null ^ this.getExpiration() == null)
+            return false;
+        if (other.getExpiration() != null
+                && other.getExpiration().equals(this.getExpiration()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ExternalServiceException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ExternalServiceException.java
new file mode 100644
index 0000000000..f3f30fd3e4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ExternalServiceException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * An exception thrown when a dependent service such as Facebook or Twitter is
+ * not responding
+ * </p>
+ */
+public class ExternalServiceException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new ExternalServiceException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public ExternalServiceException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityRequest.java
new file mode 100644
index 0000000000..80a7e076fa
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityRequest.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns credentials for the provided identity ID. Any provided logins will be
+ * validated against supported login providers. If the token is for
+ * cognito-identity.amazonaws.com, it will be passed through to AWS Security
+ * Token Service with the appropriate role for the token.
+ * </p>
+ * <p>
+ * This is a public API. You do not need any credentials to call this API.
+ * </p>
+ */
+public class GetCredentialsForIdentityRequest extends AmazonWebServiceRequest implements
+        Serializable {
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityId;
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     */
+    private java.util.Map<String, String> logins;
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to be assumed when multiple
+     * roles were received in the token from the identity provider. For example,
+     * a SAML-based identity provider. This parameter is optional for identity
+     * providers that do not support role customization.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     */
+    private String customRoleArn;
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return <p>
+     *         A unique identifier in the format REGION:GUID.
+     *         </p>
+     */
+    public String getIdentityId() {
+        return identityId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId <p>
+     *            A unique identifier in the format REGION:GUID.
+     *            </p>
+     */
+    public void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId <p>
+     *            A unique identifier in the format REGION:GUID.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityRequest withIdentityId(String identityId) {
+        this.identityId = identityId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     *
+     * @return <p>
+     *         A set of optional name-value pairs that map provider names to
+     *         provider tokens.
+     *         </p>
+     */
+    public java.util.Map<String, String> getLogins() {
+        return logins;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     *
+     * @param logins <p>
+     *            A set of optional name-value pairs that map provider names to
+     *            provider tokens.
+     *            </p>
+     */
+    public void setLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param logins <p>
+     *            A set of optional name-value pairs that map provider names to
+     *            provider tokens.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityRequest withLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The method adds a new key-value pair into Logins parameter, and returns a
+     * reference to this object so that method calls can be chained together.
+     *
+     * @param key The key of the entry to be added into Logins.
+     * @param value The corresponding value of the entry to be added into
+     *            Logins.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityRequest addLoginsEntry(String key, String value) {
+        if (null == this.logins) {
+            this.logins = new java.util.HashMap<String, String>();
+        }
+        if (this.logins.containsKey(key))
+            throw new IllegalArgumentException("Duplicated keys (" + key.toString()
+                    + ") are provided.");
+        this.logins.put(key, value);
+        return this;
+    }
+
+    /**
+     * Removes all the entries added into Logins.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     */
+    public GetCredentialsForIdentityRequest clearLoginsEntries() {
+        this.logins = null;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to be assumed when multiple
+     * roles were received in the token from the identity provider. For example,
+     * a SAML-based identity provider. This parameter is optional for identity
+     * providers that do not support role customization.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     *
+     * @return <p>
+     *         The Amazon Resource Name (ARN) of the role to be assumed when
+     *         multiple roles were received in the token from the identity
+     *         provider. For example, a SAML-based identity provider. This
+     *         parameter is optional for identity providers that do not support
+     *         role customization.
+     *         </p>
+     */
+    public String getCustomRoleArn() {
+        return customRoleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to be assumed when multiple
+     * roles were received in the token from the identity provider. For example,
+     * a SAML-based identity provider. This parameter is optional for identity
+     * providers that do not support role customization.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     *
+     * @param customRoleArn <p>
+     *            The Amazon Resource Name (ARN) of the role to be assumed when
+     *            multiple roles were received in the token from the identity
+     *            provider. For example, a SAML-based identity provider. This
+     *            parameter is optional for identity providers that do not
+     *            support role customization.
+     *            </p>
+     */
+    public void setCustomRoleArn(String customRoleArn) {
+        this.customRoleArn = customRoleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to be assumed when multiple
+     * roles were received in the token from the identity provider. For example,
+     * a SAML-based identity provider. This parameter is optional for identity
+     * providers that do not support role customization.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     *
+     * @param customRoleArn <p>
+     *            The Amazon Resource Name (ARN) of the role to be assumed when
+     *            multiple roles were received in the token from the identity
+     *            provider. For example, a SAML-based identity provider. This
+     *            parameter is optional for identity providers that do not
+     *            support role customization.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityRequest withCustomRoleArn(String customRoleArn) {
+        this.customRoleArn = customRoleArn;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getIdentityId() != null)
+            sb.append("IdentityId: " + getIdentityId() + ",");
+        if (getLogins() != null)
+            sb.append("Logins: " + getLogins() + ",");
+        if (getCustomRoleArn() != null)
+            sb.append("CustomRoleArn: " + getCustomRoleArn());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode());
+        hashCode = prime * hashCode + ((getLogins() == null) ? 0 : getLogins().hashCode());
+        hashCode = prime * hashCode
+                + ((getCustomRoleArn() == null) ? 0 : getCustomRoleArn().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetCredentialsForIdentityRequest == false)
+            return false;
+        GetCredentialsForIdentityRequest other = (GetCredentialsForIdentityRequest) obj;
+
+        if (other.getIdentityId() == null ^ this.getIdentityId() == null)
+            return false;
+        if (other.getIdentityId() != null
+                && other.getIdentityId().equals(this.getIdentityId()) == false)
+            return false;
+        if (other.getLogins() == null ^ this.getLogins() == null)
+            return false;
+        if (other.getLogins() != null && other.getLogins().equals(this.getLogins()) == false)
+            return false;
+        if (other.getCustomRoleArn() == null ^ this.getCustomRoleArn() == null)
+            return false;
+        if (other.getCustomRoleArn() != null
+                && other.getCustomRoleArn().equals(this.getCustomRoleArn()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityResult.java
new file mode 100644
index 0000000000..f83bd8d259
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetCredentialsForIdentityResult.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Returned in response to a successful <code>GetCredentialsForIdentity</code>
+ * operation.
+ * </p>
+ */
+public class GetCredentialsForIdentityResult implements Serializable {
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityId;
+
+    /**
+     * <p>
+     * Credentials for the provided identity ID.
+     * </p>
+     */
+    private Credentials credentials;
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return <p>
+     *         A unique identifier in the format REGION:GUID.
+     *         </p>
+     */
+    public String getIdentityId() {
+        return identityId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId <p>
+     *            A unique identifier in the format REGION:GUID.
+     *            </p>
+     */
+    public void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier in the format REGION:GUID.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId <p>
+     *            A unique identifier in the format REGION:GUID.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityResult withIdentityId(String identityId) {
+        this.identityId = identityId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * Credentials for the provided identity ID.
+     * </p>
+     *
+     * @return <p>
+     *         Credentials for the provided identity ID.
+     *         </p>
+     */
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * <p>
+     * Credentials for the provided identity ID.
+     * </p>
+     *
+     * @param credentials <p>
+     *            Credentials for the provided identity ID.
+     *            </p>
+     */
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * <p>
+     * Credentials for the provided identity ID.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param credentials <p>
+     *            Credentials for the provided identity ID.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCredentialsForIdentityResult withCredentials(Credentials credentials) {
+        this.credentials = credentials;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getIdentityId() != null)
+            sb.append("IdentityId: " + getIdentityId() + ",");
+        if (getCredentials() != null)
+            sb.append("Credentials: " + getCredentials());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode());
+        hashCode = prime * hashCode
+                + ((getCredentials() == null) ? 0 : getCredentials().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetCredentialsForIdentityResult == false)
+            return false;
+        GetCredentialsForIdentityResult other = (GetCredentialsForIdentityResult) obj;
+
+        if (other.getIdentityId() == null ^ this.getIdentityId() == null)
+            return false;
+        if (other.getIdentityId() != null
+                && other.getIdentityId().equals(this.getIdentityId()) == false)
+            return false;
+        if (other.getCredentials() == null ^ this.getCredentials() == null)
+            return false;
+        if (other.getCredentials() != null
+                && other.getCredentials().equals(this.getCredentials()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdRequest.java
new file mode 100644
index 0000000000..59540a0b19
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdRequest.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Generates (or retrieves) a Cognito ID. Supplying multiple logins will create
+ * an implicit linked account.
+ * </p>
+ * <p>
+ * This is a public API. You do not need any credentials to call this API.
+ * </p>
+ */
+public class GetIdRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * A standard AWS account ID (9+ digits).
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 15<br/>
+     * <b>Pattern: </b>\d+<br/>
+     */
+    private String accountId;
+
+    /**
+     * An identity pool ID in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityPoolId;
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The available provider names for <code>Logins</code> are as follows:
+     * <ul>
+     * <li>Facebook: <code>graph.facebook.com</code></li>
+     * <li>Google: <code>accounts.google.com</code></li>
+     * <li>Amazon: <code>www.amazon.com</code></li>
+     * <li>Twitter: <code>api.twitter.com</code></li>
+     * <li>Digits: <code>www.digits.com</code></li>
+     * </ul>
+     * </p>
+     */
+    private java.util.Map<String, String> logins;
+
+    /**
+     * A standard AWS account ID (9+ digits).
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 15<br/>
+     * <b>Pattern: </b>\d+<br/>
+     *
+     * @return A standard AWS account ID (9+ digits).
+     */
+    public String getAccountId() {
+        return accountId;
+    }
+
+    /**
+     * A standard AWS account ID (9+ digits).
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 15<br/>
+     * <b>Pattern: </b>\d+<br/>
+     *
+     * @param accountId A standard AWS account ID (9+ digits).
+     */
+    public void setAccountId(String accountId) {
+        this.accountId = accountId;
+    }
+
+    /**
+     * A standard AWS account ID (9+ digits).
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 15<br/>
+     * <b>Pattern: </b>\d+<br/>
+     *
+     * @param accountId A standard AWS account ID (9+ digits).
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetIdRequest withAccountId(String accountId) {
+        this.accountId = accountId;
+        return this;
+    }
+
+    /**
+     * An identity pool ID in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return An identity pool ID in the format REGION:GUID.
+     */
+    public String getIdentityPoolId() {
+        return identityPoolId;
+    }
+
+    /**
+     * An identity pool ID in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityPoolId An identity pool ID in the format REGION:GUID.
+     */
+    public void setIdentityPoolId(String identityPoolId) {
+        this.identityPoolId = identityPoolId;
+    }
+
+    /**
+     * An identity pool ID in the format REGION:GUID.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityPoolId An identity pool ID in the format REGION:GUID.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetIdRequest withIdentityPoolId(String identityPoolId) {
+        this.identityPoolId = identityPoolId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The available provider names for <code>Logins</code> are as follows:
+     * <ul>
+     * <li>Facebook: <code>graph.facebook.com</code></li>
+     * <li>Google: <code>accounts.google.com</code></li>
+     * <li>Amazon: <code>www.amazon.com</code></li>
+     * <li>Twitter: <code>api.twitter.com</code></li>
+     * <li>Digits: <code>www.digits.com</code></li>
+     * </ul>
+     * </p>
+     *
+     * @return <p>
+     *         A set of optional name-value pairs that map provider names to
+     *         provider tokens.
+     *         </p>
+     *         <p>
+     *         The available provider names for <code>Logins</code> are as
+     *         follows:
+     *         <ul>
+     *         <li>Facebook: <code>graph.facebook.com</code></li>
+     *         <li>Google: <code>accounts.google.com</code></li>
+     *         <li>Amazon: <code>www.amazon.com</code></li>
+     *         <li>Twitter: <code>api.twitter.com</code></li>
+     *         <li>Digits: <code>www.digits.com</code></li>
+     *         </ul>
+     *         </p>
+     */
+    public java.util.Map<String, String> getLogins() {
+        return logins;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The available provider names for <code>Logins</code> are as follows:
+     * <ul>
+     * <li>Facebook: <code>graph.facebook.com</code></li>
+     * <li>Google: <code>accounts.google.com</code></li>
+     * <li>Amazon: <code>www.amazon.com</code></li>
+     * <li>Twitter: <code>api.twitter.com</code></li>
+     * <li>Digits: <code>www.digits.com</code></li>
+     * </ul>
+     * </p>
+     *
+     * @param logins <p>
+     *            A set of optional name-value pairs that map provider names to
+     *            provider tokens.
+     *            </p>
+     *            <p>
+     *            The available provider names for <code>Logins</code> are as
+     *            follows:
+     *            <ul>
+     *            <li>Facebook: <code>graph.facebook.com</code></li>
+     *            <li>Google: <code>accounts.google.com</code></li>
+     *            <li>Amazon: <code>www.amazon.com</code></li>
+     *            <li>Twitter: <code>api.twitter.com</code></li>
+     *            <li>Digits: <code>www.digits.com</code></li>
+     *            </ul>
+     *            </p>
+     */
+    public void setLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The available provider names for <code>Logins</code> are as follows:
+     * <ul>
+     * <li>Facebook: <code>graph.facebook.com</code></li>
+     * <li>Google: <code>accounts.google.com</code></li>
+     * <li>Amazon: <code>www.amazon.com</code></li>
+     * <li>Twitter: <code>api.twitter.com</code></li>
+     * <li>Digits: <code>www.digits.com</code></li>
+     * </ul>
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param logins <p>
+     *            A set of optional name-value pairs that map provider names to
+     *            provider tokens.
+     *            </p>
+     *            <p>
+     *            The available provider names for <code>Logins</code> are as
+     *            follows:
+     *            <ul>
+     *            <li>Facebook: <code>graph.facebook.com</code></li>
+     *            <li>Google: <code>accounts.google.com</code></li>
+     *            <li>Amazon: <code>www.amazon.com</code></li>
+     *            <li>Twitter: <code>api.twitter.com</code></li>
+     *            <li>Digits: <code>www.digits.com</code></li>
+     *            </ul>
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetIdRequest withLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens.
+     * </p>
+     * <p>
+     * The available provider names for <code>Logins</code> are as follows:
+     * <ul>
+     * <li>Facebook: <code>graph.facebook.com</code></li>
+     * <li>Google: <code>accounts.google.com</code></li>
+     * <li>Amazon: <code>www.amazon.com</code></li>
+     * <li>Twitter: <code>api.twitter.com</code></li>
+     * <li>Digits: <code>www.digits.com</code></li>
+     * </ul>
+     * </p>
+     * <p>
+     * The method adds a new key-value pair into Logins parameter, and returns a
+     * reference to this object so that method calls can be chained together.
+     *
+     * @param key The key of the entry to be added into Logins.
+     * @param value The corresponding value of the entry to be added into
+     *            Logins.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetIdRequest addLoginsEntry(String key, String value) {
+        if (null == this.logins) {
+            this.logins = new java.util.HashMap<String, String>();
+        }
+        if (this.logins.containsKey(key))
+            throw new IllegalArgumentException("Duplicated keys (" + key.toString()
+                    + ") are provided.");
+        this.logins.put(key, value);
+        return this;
+    }
+
+    /**
+     * Removes all the entries added into Logins.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     */
+    public GetIdRequest clearLoginsEntries() {
+        this.logins = null;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getAccountId() != null)
+            sb.append("AccountId: " + getAccountId() + ",");
+        if (getIdentityPoolId() != null)
+            sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
+        if (getLogins() != null)
+            sb.append("Logins: " + getLogins());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getAccountId() == null) ? 0 : getAccountId().hashCode());
+        hashCode = prime * hashCode
+                + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode());
+        hashCode = prime * hashCode + ((getLogins() == null) ? 0 : getLogins().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetIdRequest == false)
+            return false;
+        GetIdRequest other = (GetIdRequest) obj;
+
+        if (other.getAccountId() == null ^ this.getAccountId() == null)
+            return false;
+        if (other.getAccountId() != null
+                && other.getAccountId().equals(this.getAccountId()) == false)
+            return false;
+        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null)
+            return false;
+        if (other.getIdentityPoolId() != null
+                && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false)
+            return false;
+        if (other.getLogins() == null ^ this.getLogins() == null)
+            return false;
+        if (other.getLogins() != null && other.getLogins().equals(this.getLogins()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdResult.java
new file mode 100644
index 0000000000..3436fab5d9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetIdResult.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+/**
+ * Returned in response to a GetId request.
+ */
+public class GetIdResult implements Serializable {
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityId;
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return A unique identifier in the format REGION:GUID.
+     */
+    public String getIdentityId() {
+        return identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID.
+     */
+    public void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetIdResult withIdentityId(String identityId) {
+        this.identityId = identityId;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getIdentityId() != null)
+            sb.append("IdentityId: " + getIdentityId());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetIdResult == false)
+            return false;
+        GetIdResult other = (GetIdResult) obj;
+
+        if (other.getIdentityId() == null ^ this.getIdentityId() == null)
+            return false;
+        if (other.getIdentityId() != null
+                && other.getIdentityId().equals(this.getIdentityId()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenRequest.java
new file mode 100644
index 0000000000..94eea1ab55
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenRequest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Gets an OpenID token, using a known Cognito ID. This known Cognito ID is
+ * returned by <a>GetId</a>. You can optionally add additional logins for the
+ * identity. Supplying multiple logins creates an implicit link.
+ * </p>
+ * <p>
+ * The OpenId token is valid for 15 minutes.
+ * </p>
+ * <p>
+ * This is a public API. You do not need any credentials to call this API.
+ * </p>
+ */
+public class GetOpenIdTokenRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityId;
+
+    /**
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens. When using graph.facebook.com and www.amazon.com, supply the
+     * access_token returned from the provider's authflow. For
+     * accounts.google.com or any other OpenId Connect provider, always include
+     * the id_token.
+     */
+    private java.util.Map<String, String> logins;
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return A unique identifier in the format REGION:GUID.
+     */
+    public String getIdentityId() {
+        return identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID.
+     */
+    public void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetOpenIdTokenRequest withIdentityId(String identityId) {
+        this.identityId = identityId;
+        return this;
+    }
+
+    /**
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens. When using graph.facebook.com and www.amazon.com, supply the
+     * access_token returned from the provider's authflow. For
+     * accounts.google.com or any other OpenId Connect provider, always include
+     * the id_token.
+     *
+     * @return A set of optional name-value pairs that map provider names to
+     *         provider tokens. When using graph.facebook.com and
+     *         www.amazon.com, supply the access_token returned from the
+     *         provider's authflow. For accounts.google.com or any other OpenId
+     *         Connect provider, always include the id_token.
+     */
+    public java.util.Map<String, String> getLogins() {
+        return logins;
+    }
+
+    /**
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens. When using graph.facebook.com and www.amazon.com, supply the
+     * access_token returned from the provider's authflow. For
+     * accounts.google.com or any other OpenId Connect provider, always include
+     * the id_token.
+     *
+     * @param logins A set of optional name-value pairs that map provider names
+     *            to provider tokens. When using graph.facebook.com and
+     *            www.amazon.com, supply the access_token returned from the
+     *            provider's authflow. For accounts.google.com or any other
+     *            OpenId Connect provider, always include the id_token.
+     */
+    public void setLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+    }
+
+    /**
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens. When using graph.facebook.com and www.amazon.com, supply the
+     * access_token returned from the provider's authflow. For
+     * accounts.google.com or any other OpenId Connect provider, always include
+     * the id_token.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param logins A set of optional name-value pairs that map provider names
+     *            to provider tokens. When using graph.facebook.com and
+     *            www.amazon.com, supply the access_token returned from the
+     *            provider's authflow. For accounts.google.com or any other
+     *            OpenId Connect provider, always include the id_token.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetOpenIdTokenRequest withLogins(java.util.Map<String, String> logins) {
+        this.logins = logins;
+        return this;
+    }
+
+    /**
+     * A set of optional name-value pairs that map provider names to provider
+     * tokens. When using graph.facebook.com and www.amazon.com, supply the
+     * access_token returned from the provider's authflow. For
+     * accounts.google.com or any other OpenId Connect provider, always include
+     * the id_token.
+     * <p>
+     * The method adds a new key-value pair into Logins parameter, and returns a
+     * reference to this object so that method calls can be chained together.
+     *
+     * @param key The key of the entry to be added into Logins.
+     * @param value The corresponding value of the entry to be added into
+     *            Logins.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetOpenIdTokenRequest addLoginsEntry(String key, String value) {
+        if (null == this.logins) {
+            this.logins = new java.util.HashMap<String, String>();
+        }
+        if (this.logins.containsKey(key))
+            throw new IllegalArgumentException("Duplicated keys (" + key.toString()
+                    + ") are provided.");
+        this.logins.put(key, value);
+        return this;
+    }
+
+    /**
+     * Removes all the entries added into Logins.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     */
+    public GetOpenIdTokenRequest clearLoginsEntries() {
+        this.logins = null;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getIdentityId() != null)
+            sb.append("IdentityId: " + getIdentityId() + ",");
+        if (getLogins() != null)
+            sb.append("Logins: " + getLogins());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode());
+        hashCode = prime * hashCode + ((getLogins() == null) ? 0 : getLogins().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetOpenIdTokenRequest == false)
+            return false;
+        GetOpenIdTokenRequest other = (GetOpenIdTokenRequest) obj;
+
+        if (other.getIdentityId() == null ^ this.getIdentityId() == null)
+            return false;
+        if (other.getIdentityId() != null
+                && other.getIdentityId().equals(this.getIdentityId()) == false)
+            return false;
+        if (other.getLogins() == null ^ this.getLogins() == null)
+            return false;
+        if (other.getLogins() != null && other.getLogins().equals(this.getLogins()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenResult.java
new file mode 100644
index 0000000000..17b9549266
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/GetOpenIdTokenResult.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import java.io.Serializable;
+
+/**
+ * Returned in response to a successful GetOpenIdToken request.
+ */
+public class GetOpenIdTokenResult implements Serializable {
+    /**
+     * A unique identifier in the format REGION:GUID. Note that the IdentityId
+     * returned may not match the one passed on input.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     */
+    private String identityId;
+
+    /**
+     * An OpenID token, valid for 15 minutes.
+     */
+    private String token;
+
+    /**
+     * A unique identifier in the format REGION:GUID. Note that the IdentityId
+     * returned may not match the one passed on input.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @return A unique identifier in the format REGION:GUID. Note that the
+     *         IdentityId returned may not match the one passed on input.
+     */
+    public String getIdentityId() {
+        return identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID. Note that the IdentityId
+     * returned may not match the one passed on input.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID. Note
+     *            that the IdentityId returned may not match the one passed on
+     *            input.
+     */
+    public void setIdentityId(String identityId) {
+        this.identityId = identityId;
+    }
+
+    /**
+     * A unique identifier in the format REGION:GUID. Note that the IdentityId
+     * returned may not match the one passed on input.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 55<br/>
+     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
+     *
+     * @param identityId A unique identifier in the format REGION:GUID. Note
+     *            that the IdentityId returned may not match the one passed on
+     *            input.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetOpenIdTokenResult withIdentityId(String identityId) {
+        this.identityId = identityId;
+        return this;
+    }
+
+    /**
+     * An OpenID token, valid for 15 minutes.
+     *
+     * @return An OpenID token, valid for 15 minutes.
+     */
+    public String getToken() {
+        return token;
+    }
+
+    /**
+     * An OpenID token, valid for 15 minutes.
+     *
+     * @param token An OpenID token, valid for 15 minutes.
+     */
+    public void setToken(String token) {
+        this.token = token;
+    }
+
+    /**
+     * An OpenID token, valid for 15 minutes.
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param token An OpenID token, valid for 15 minutes.
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetOpenIdTokenResult withToken(String token) {
+        this.token = token;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getIdentityId() != null)
+            sb.append("IdentityId: " + getIdentityId() + ",");
+        if (getToken() != null)
+            sb.append("Token: " + getToken());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode());
+        hashCode = prime * hashCode + ((getToken() == null) ? 0 : getToken().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetOpenIdTokenResult == false)
+            return false;
+        GetOpenIdTokenResult other = (GetOpenIdTokenResult) obj;
+
+        if (other.getIdentityId() == null ^ this.getIdentityId() == null)
+            return false;
+        if (other.getIdentityId() != null
+                && other.getIdentityId().equals(this.getIdentityId()) == false)
+            return false;
+        if (other.getToken() == null ^ this.getToken() == null)
+            return false;
+        if (other.getToken() != null && other.getToken().equals(this.getToken()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InternalErrorException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InternalErrorException.java
new file mode 100644
index 0000000000..2706a283f2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InternalErrorException.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when the service encounters an error during processing the request.
+ */
+public class InternalErrorException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new InternalErrorException with the specified error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public InternalErrorException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidIdentityPoolConfigurationException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidIdentityPoolConfigurationException.java
new file mode 100644
index 0000000000..1daaa36830
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidIdentityPoolConfigurationException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * Thrown if the identity pool has no role associated for the given auth type
+ * (auth/unauth) or if the AssumeRole fails.
+ * </p>
+ */
+public class InvalidIdentityPoolConfigurationException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new InvalidIdentityPoolConfigurationException with the
+     * specified error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public InvalidIdentityPoolConfigurationException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidParameterException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidParameterException.java
new file mode 100644
index 0000000000..649beaf9d0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/InvalidParameterException.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown for missing or bad input parameter(s).
+ */
+public class InvalidParameterException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new InvalidParameterException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public InvalidParameterException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/LimitExceededException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/LimitExceededException.java
new file mode 100644
index 0000000000..da74ae121f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/LimitExceededException.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when the total number of user pools has exceeded a preset limit.
+ */
+public class LimitExceededException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new LimitExceededException with the specified error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public LimitExceededException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/NotAuthorizedException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/NotAuthorizedException.java
new file mode 100644
index 0000000000..1160fa7c98
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/NotAuthorizedException.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when a user is not authorized to access the requested resource.
+ */
+public class NotAuthorizedException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new NotAuthorizedException with the specified error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public NotAuthorizedException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceConflictException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceConflictException.java
new file mode 100644
index 0000000000..7a79836fac
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceConflictException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when a user tries to use a login which is already linked to another
+ * account.
+ */
+public class ResourceConflictException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new ResourceConflictException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public ResourceConflictException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceNotFoundException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceNotFoundException.java
new file mode 100644
index 0000000000..28dddae570
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/ResourceNotFoundException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when the requested resource (for example, a dataset or record) does
+ * not exist.
+ */
+public class ResourceNotFoundException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new ResourceNotFoundException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public ResourceNotFoundException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/TooManyRequestsException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/TooManyRequestsException.java
new file mode 100644
index 0000000000..09d656fcc6
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/TooManyRequestsException.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * Thrown when a request is throttled.
+ */
+public class TooManyRequestsException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new TooManyRequestsException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public TooManyRequestsException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/package-info.java
new file mode 100644
index 0000000000..1e3df02676
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * Classes modeling the various types represented by AmazonCognitoIdentity
+ */
+
+package com.amazonaws.services.cognitoidentity.model;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonMarshaller.java
new file mode 100644
index 0000000000..815f0d4fdd
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonMarshaller.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.util.json.AwsJsonWriter;
+
+/**
+ * JSON marshaller for POJO Credentials
+ */
+class CredentialsJsonMarshaller {
+
+    public void marshall(Credentials credentials, AwsJsonWriter jsonWriter) throws Exception {
+        jsonWriter.beginObject();
+        if (credentials.getAccessKeyId() != null) {
+            String accessKeyId = credentials.getAccessKeyId();
+            jsonWriter.name("AccessKeyId");
+            jsonWriter.value(accessKeyId);
+        }
+        if (credentials.getSecretKey() != null) {
+            String secretKey = credentials.getSecretKey();
+            jsonWriter.name("SecretKey");
+            jsonWriter.value(secretKey);
+        }
+        if (credentials.getSessionToken() != null) {
+            String sessionToken = credentials.getSessionToken();
+            jsonWriter.name("SessionToken");
+            jsonWriter.value(sessionToken);
+        }
+        if (credentials.getExpiration() != null) {
+            java.util.Date expiration = credentials.getExpiration();
+            jsonWriter.name("Expiration");
+            jsonWriter.value(expiration);
+        }
+        jsonWriter.endObject();
+    }
+
+    private static CredentialsJsonMarshaller instance;
+
+    public static CredentialsJsonMarshaller getInstance() {
+        if (instance == null)
+            instance = new CredentialsJsonMarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonUnmarshaller.java
new file mode 100644
index 0000000000..4e30e98468
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/CredentialsJsonUnmarshaller.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.json.AwsJsonReader;
+
+/**
+ * JSON unmarshaller for POJO Credentials
+ */
+class CredentialsJsonUnmarshaller implements Unmarshaller<Credentials, JsonUnmarshallerContext> {
+
+    public Credentials unmarshall(JsonUnmarshallerContext context) throws Exception {
+        AwsJsonReader reader = context.getReader();
+        if (!reader.isContainer()) {
+            reader.skipValue();
+            return null;
+        }
+        Credentials credentials = new Credentials();
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("AccessKeyId")) {
+                credentials.setAccessKeyId(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else if (name.equals("SecretKey")) {
+                credentials.setSecretKey(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else if (name.equals("SessionToken")) {
+                credentials.setSessionToken(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else if (name.equals("Expiration")) {
+                credentials.setExpiration(DateJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return credentials;
+    }
+
+    private static CredentialsJsonUnmarshaller instance;
+
+    public static CredentialsJsonUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new CredentialsJsonUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ExternalServiceExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ExternalServiceExceptionUnmarshaller.java
new file mode 100644
index 0000000000..824282a32b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ExternalServiceExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.ExternalServiceException;
+
+public class ExternalServiceExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public ExternalServiceExceptionUnmarshaller() {
+        super(ExternalServiceException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("ExternalServiceException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        ExternalServiceException e = (ExternalServiceException) super.unmarshall(error);
+        e.setErrorCode("ExternalServiceException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityRequestMarshaller.java
new file mode 100644
index 0000000000..6826792624
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityRequestMarshaller.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.http.HttpMethodName;
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.BinaryUtils;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.StringInputStream;
+import com.amazonaws.util.json.AwsJsonWriter;
+import com.amazonaws.util.json.JsonUtils;
+
+/**
+ * JSON request marshaller for GetCredentialsForIdentityRequest
+ */
+public class GetCredentialsForIdentityRequestMarshaller implements
+        Marshaller<Request<GetCredentialsForIdentityRequest>, GetCredentialsForIdentityRequest> {
+
+    public Request<GetCredentialsForIdentityRequest> marshall(
+            GetCredentialsForIdentityRequest getCredentialsForIdentityRequest) {
+        if (getCredentialsForIdentityRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(GetCredentialsForIdentityRequest)");
+        }
+
+        Request<GetCredentialsForIdentityRequest> request = new DefaultRequest<GetCredentialsForIdentityRequest>(
+                getCredentialsForIdentityRequest, "AmazonCognitoIdentity");
+        String target = "AWSCognitoIdentityService.GetCredentialsForIdentity";
+        request.addHeader("X-Amz-Target", target);
+        request.setHttpMethod(HttpMethodName.POST);
+
+        String uriResourcePath = "/";
+        request.setResourcePath(uriResourcePath);
+        try {
+            StringWriter stringWriter = new StringWriter();
+            AwsJsonWriter jsonWriter = JsonUtils.getJsonWriter(stringWriter);
+            jsonWriter.beginObject();
+
+            if (getCredentialsForIdentityRequest.getIdentityId() != null) {
+                String identityId = getCredentialsForIdentityRequest.getIdentityId();
+                jsonWriter.name("IdentityId");
+                jsonWriter.value(identityId);
+            }
+            if (getCredentialsForIdentityRequest.getLogins() != null) {
+                java.util.Map<String, String> logins = getCredentialsForIdentityRequest.getLogins();
+                jsonWriter.name("Logins");
+                jsonWriter.beginObject();
+                for (java.util.Map.Entry<String, String> loginsEntry : logins.entrySet()) {
+                    String loginsValue = loginsEntry.getValue();
+                    if (loginsValue != null) {
+                        jsonWriter.name(loginsEntry.getKey());
+                        jsonWriter.value(loginsValue);
+                    }
+                }
+                jsonWriter.endObject();
+            }
+            if (getCredentialsForIdentityRequest.getCustomRoleArn() != null) {
+                String customRoleArn = getCredentialsForIdentityRequest.getCustomRoleArn();
+                jsonWriter.name("CustomRoleArn");
+                jsonWriter.value(customRoleArn);
+            }
+
+            jsonWriter.endObject();
+            jsonWriter.close();
+            String snippet = stringWriter.toString();
+            byte[] content = snippet.getBytes(UTF8);
+            request.setContent(new StringInputStream(snippet));
+            request.addHeader("Content-Length", Integer.toString(content.length));
+        } catch (Throwable t) {
+            throw new AmazonClientException(
+                    "Unable to marshall request to JSON: " + t.getMessage(), t);
+        }
+        if (!request.getHeaders().containsKey("Content-Type")) {
+            request.addHeader("Content-Type", "application/x-amz-json-1.1");
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityResultJsonUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityResultJsonUnmarshaller.java
new file mode 100644
index 0000000000..84fbeb19b2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetCredentialsForIdentityResultJsonUnmarshaller.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.json.AwsJsonReader;
+
+/**
+ * JSON unmarshaller for response GetCredentialsForIdentityResult
+ */
+public class GetCredentialsForIdentityResultJsonUnmarshaller implements
+        Unmarshaller<GetCredentialsForIdentityResult, JsonUnmarshallerContext> {
+
+    public GetCredentialsForIdentityResult unmarshall(JsonUnmarshallerContext context)
+            throws Exception {
+        GetCredentialsForIdentityResult getCredentialsForIdentityResult = new GetCredentialsForIdentityResult();
+
+        AwsJsonReader reader = context.getReader();
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("IdentityId")) {
+                getCredentialsForIdentityResult.setIdentityId(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else if (name.equals("Credentials")) {
+                getCredentialsForIdentityResult.setCredentials(CredentialsJsonUnmarshaller
+                        .getInstance()
+                        .unmarshall(context));
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+
+        return getCredentialsForIdentityResult;
+    }
+
+    private static GetCredentialsForIdentityResultJsonUnmarshaller instance;
+
+    public static GetCredentialsForIdentityResultJsonUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetCredentialsForIdentityResultJsonUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdRequestMarshaller.java
new file mode 100644
index 0000000000..ac5c7c7d3f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdRequestMarshaller.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.http.HttpMethodName;
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.BinaryUtils;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.StringInputStream;
+import com.amazonaws.util.json.AwsJsonWriter;
+import com.amazonaws.util.json.JsonUtils;
+
+/**
+ * JSON request marshaller for GetIdRequest
+ */
+public class GetIdRequestMarshaller implements Marshaller<Request<GetIdRequest>, GetIdRequest> {
+
+    public Request<GetIdRequest> marshall(GetIdRequest getIdRequest) {
+        if (getIdRequest == null) {
+            throw new AmazonClientException("Invalid argument passed to marshall(GetIdRequest)");
+        }
+
+        Request<GetIdRequest> request = new DefaultRequest<GetIdRequest>(getIdRequest,
+                "AmazonCognitoIdentity");
+        String target = "AWSCognitoIdentityService.GetId";
+        request.addHeader("X-Amz-Target", target);
+        request.setHttpMethod(HttpMethodName.POST);
+
+        String uriResourcePath = "/";
+        request.setResourcePath(uriResourcePath);
+        try {
+            StringWriter stringWriter = new StringWriter();
+            AwsJsonWriter jsonWriter = JsonUtils.getJsonWriter(stringWriter);
+            jsonWriter.beginObject();
+
+            if (getIdRequest.getAccountId() != null) {
+                String accountId = getIdRequest.getAccountId();
+                jsonWriter.name("AccountId");
+                jsonWriter.value(accountId);
+            }
+            if (getIdRequest.getIdentityPoolId() != null) {
+                String identityPoolId = getIdRequest.getIdentityPoolId();
+                jsonWriter.name("IdentityPoolId");
+                jsonWriter.value(identityPoolId);
+            }
+            if (getIdRequest.getLogins() != null) {
+                java.util.Map<String, String> logins = getIdRequest.getLogins();
+                jsonWriter.name("Logins");
+                jsonWriter.beginObject();
+                for (java.util.Map.Entry<String, String> loginsEntry : logins.entrySet()) {
+                    String loginsValue = loginsEntry.getValue();
+                    if (loginsValue != null) {
+                        jsonWriter.name(loginsEntry.getKey());
+                        jsonWriter.value(loginsValue);
+                    }
+                }
+                jsonWriter.endObject();
+            }
+
+            jsonWriter.endObject();
+            jsonWriter.close();
+            String snippet = stringWriter.toString();
+            byte[] content = snippet.getBytes(UTF8);
+            request.setContent(new StringInputStream(snippet));
+            request.addHeader("Content-Length", Integer.toString(content.length));
+        } catch (Throwable t) {
+            throw new AmazonClientException(
+                    "Unable to marshall request to JSON: " + t.getMessage(), t);
+        }
+        if (!request.getHeaders().containsKey("Content-Type")) {
+            request.addHeader("Content-Type", "application/x-amz-json-1.1");
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdResultJsonUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdResultJsonUnmarshaller.java
new file mode 100644
index 0000000000..4374ff9fdb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetIdResultJsonUnmarshaller.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.json.AwsJsonReader;
+
+/**
+ * JSON unmarshaller for response GetIdResult
+ */
+public class GetIdResultJsonUnmarshaller implements
+        Unmarshaller<GetIdResult, JsonUnmarshallerContext> {
+
+    public GetIdResult unmarshall(JsonUnmarshallerContext context) throws Exception {
+        GetIdResult getIdResult = new GetIdResult();
+
+        AwsJsonReader reader = context.getReader();
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("IdentityId")) {
+                getIdResult.setIdentityId(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+
+        return getIdResult;
+    }
+
+    private static GetIdResultJsonUnmarshaller instance;
+
+    public static GetIdResultJsonUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetIdResultJsonUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenRequestMarshaller.java
new file mode 100644
index 0000000000..ef69f2d1bb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenRequestMarshaller.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.http.HttpMethodName;
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.BinaryUtils;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.StringInputStream;
+import com.amazonaws.util.json.AwsJsonWriter;
+import com.amazonaws.util.json.JsonUtils;
+
+/**
+ * JSON request marshaller for GetOpenIdTokenRequest
+ */
+public class GetOpenIdTokenRequestMarshaller implements
+        Marshaller<Request<GetOpenIdTokenRequest>, GetOpenIdTokenRequest> {
+
+    public Request<GetOpenIdTokenRequest> marshall(GetOpenIdTokenRequest getOpenIdTokenRequest) {
+        if (getOpenIdTokenRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(GetOpenIdTokenRequest)");
+        }
+
+        Request<GetOpenIdTokenRequest> request = new DefaultRequest<GetOpenIdTokenRequest>(
+                getOpenIdTokenRequest, "AmazonCognitoIdentity");
+        String target = "AWSCognitoIdentityService.GetOpenIdToken";
+        request.addHeader("X-Amz-Target", target);
+        request.setHttpMethod(HttpMethodName.POST);
+
+        String uriResourcePath = "/";
+        request.setResourcePath(uriResourcePath);
+        try {
+            StringWriter stringWriter = new StringWriter();
+            AwsJsonWriter jsonWriter = JsonUtils.getJsonWriter(stringWriter);
+            jsonWriter.beginObject();
+
+            if (getOpenIdTokenRequest.getIdentityId() != null) {
+                String identityId = getOpenIdTokenRequest.getIdentityId();
+                jsonWriter.name("IdentityId");
+                jsonWriter.value(identityId);
+            }
+            if (getOpenIdTokenRequest.getLogins() != null) {
+                java.util.Map<String, String> logins = getOpenIdTokenRequest.getLogins();
+                jsonWriter.name("Logins");
+                jsonWriter.beginObject();
+                for (java.util.Map.Entry<String, String> loginsEntry : logins.entrySet()) {
+                    String loginsValue = loginsEntry.getValue();
+                    if (loginsValue != null) {
+                        jsonWriter.name(loginsEntry.getKey());
+                        jsonWriter.value(loginsValue);
+                    }
+                }
+                jsonWriter.endObject();
+            }
+
+            jsonWriter.endObject();
+            jsonWriter.close();
+            String snippet = stringWriter.toString();
+            byte[] content = snippet.getBytes(UTF8);
+            request.setContent(new StringInputStream(snippet));
+            request.addHeader("Content-Length", Integer.toString(content.length));
+        } catch (Throwable t) {
+            throw new AmazonClientException(
+                    "Unable to marshall request to JSON: " + t.getMessage(), t);
+        }
+        if (!request.getHeaders().containsKey("Content-Type")) {
+            request.addHeader("Content-Type", "application/x-amz-json-1.1");
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenResultJsonUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenResultJsonUnmarshaller.java
new file mode 100644
index 0000000000..27f9c7aae1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/GetOpenIdTokenResultJsonUnmarshaller.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.services.cognitoidentity.model.*;
+import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.json.AwsJsonReader;
+
+/**
+ * JSON unmarshaller for response GetOpenIdTokenResult
+ */
+public class GetOpenIdTokenResultJsonUnmarshaller implements
+        Unmarshaller<GetOpenIdTokenResult, JsonUnmarshallerContext> {
+
+    public GetOpenIdTokenResult unmarshall(JsonUnmarshallerContext context) throws Exception {
+        GetOpenIdTokenResult getOpenIdTokenResult = new GetOpenIdTokenResult();
+
+        AwsJsonReader reader = context.getReader();
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("IdentityId")) {
+                getOpenIdTokenResult.setIdentityId(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else if (name.equals("Token")) {
+                getOpenIdTokenResult.setToken(StringJsonUnmarshaller.getInstance()
+                        .unmarshall(context));
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+
+        return getOpenIdTokenResult;
+    }
+
+    private static GetOpenIdTokenResultJsonUnmarshaller instance;
+
+    public static GetOpenIdTokenResultJsonUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetOpenIdTokenResultJsonUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InternalErrorExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InternalErrorExceptionUnmarshaller.java
new file mode 100644
index 0000000000..b65d3c7699
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InternalErrorExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.InternalErrorException;
+
+public class InternalErrorExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public InternalErrorExceptionUnmarshaller() {
+        super(InternalErrorException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("InternalErrorException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        InternalErrorException e = (InternalErrorException) super.unmarshall(error);
+        e.setErrorCode("InternalErrorException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidIdentityPoolConfigurationExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidIdentityPoolConfigurationExceptionUnmarshaller.java
new file mode 100644
index 0000000000..566ef88409
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidIdentityPoolConfigurationExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.InvalidIdentityPoolConfigurationException;
+
+public class InvalidIdentityPoolConfigurationExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public InvalidIdentityPoolConfigurationExceptionUnmarshaller() {
+        super(InvalidIdentityPoolConfigurationException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("InvalidIdentityPoolConfigurationException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        InvalidIdentityPoolConfigurationException e = (InvalidIdentityPoolConfigurationException) super
+                .unmarshall(error);
+        e.setErrorCode("InvalidIdentityPoolConfigurationException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidParameterExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidParameterExceptionUnmarshaller.java
new file mode 100644
index 0000000000..5dc0cf338c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/InvalidParameterExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.InvalidParameterException;
+
+public class InvalidParameterExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public InvalidParameterExceptionUnmarshaller() {
+        super(InvalidParameterException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("InvalidParameterException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        InvalidParameterException e = (InvalidParameterException) super.unmarshall(error);
+        e.setErrorCode("InvalidParameterException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/LimitExceededExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/LimitExceededExceptionUnmarshaller.java
new file mode 100644
index 0000000000..dbd1dac13b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/LimitExceededExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.LimitExceededException;
+
+public class LimitExceededExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public LimitExceededExceptionUnmarshaller() {
+        super(LimitExceededException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("LimitExceededException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        LimitExceededException e = (LimitExceededException) super.unmarshall(error);
+        e.setErrorCode("LimitExceededException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/NotAuthorizedExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/NotAuthorizedExceptionUnmarshaller.java
new file mode 100644
index 0000000000..a233ab5ea0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/NotAuthorizedExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.NotAuthorizedException;
+
+public class NotAuthorizedExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public NotAuthorizedExceptionUnmarshaller() {
+        super(NotAuthorizedException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("NotAuthorizedException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        NotAuthorizedException e = (NotAuthorizedException) super.unmarshall(error);
+        e.setErrorCode("NotAuthorizedException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceConflictExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceConflictExceptionUnmarshaller.java
new file mode 100644
index 0000000000..901adae591
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceConflictExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.ResourceConflictException;
+
+public class ResourceConflictExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public ResourceConflictExceptionUnmarshaller() {
+        super(ResourceConflictException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("ResourceConflictException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        ResourceConflictException e = (ResourceConflictException) super.unmarshall(error);
+        e.setErrorCode("ResourceConflictException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceNotFoundExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceNotFoundExceptionUnmarshaller.java
new file mode 100644
index 0000000000..210826bd84
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/ResourceNotFoundExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.ResourceNotFoundException;
+
+public class ResourceNotFoundExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public ResourceNotFoundExceptionUnmarshaller() {
+        super(ResourceNotFoundException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("ResourceNotFoundException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        ResourceNotFoundException e = (ResourceNotFoundException) super.unmarshall(error);
+        e.setErrorCode("ResourceNotFoundException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/TooManyRequestsExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/TooManyRequestsExceptionUnmarshaller.java
new file mode 100644
index 0000000000..e6f616de87
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/TooManyRequestsExceptionUnmarshaller.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.services.cognitoidentity.model.TooManyRequestsException;
+
+public class TooManyRequestsExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+    public TooManyRequestsExceptionUnmarshaller() {
+        super(TooManyRequestsException.class);
+    }
+
+    @Override
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return error.getErrorCode().equals("TooManyRequestsException");
+    }
+
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+
+        TooManyRequestsException e = (TooManyRequestsException) super.unmarshall(error);
+        e.setErrorCode("TooManyRequestsException");
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/package-info.java
new file mode 100644
index 0000000000..3281c98086
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/model/transform/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * Marhsalling for the various types represented byAmazonCognitoIdentity
+ */
+
+package com.amazonaws.services.cognitoidentity.model.transform;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/package-info.java
new file mode 100644
index 0000000000..9b6f695be4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * <fullname>Amazon Cognito</fullname> <p>Amazon Cognito is a web service that delivers scoped temporary credentials to mobile devices and other untrusted environments. Amazon Cognito uniquely identifies a device and supplies the user with a consistent identity over the lifetime of an application.</p> <p>Using Amazon Cognito, you can enable authentication with one or more third-party identity providers (Facebook, Google, or Login with Amazon), and you can also choose to support unauthenticated access from your app. Cognito delivers a unique identifier for each user and acts as an OpenID token provider trusted by AWS Security Token Service (STS) to access temporary, limited-privilege AWS credentials.</p> <p>To provide end-user credentials, first make an unsigned call to <a>GetId</a>. If the end user is authenticated with one of the supported identity providers, set the <code>Logins</code> map with the identity provider token. <code>GetId</code> returns a unique identifier for the user.</p> <p>Next, make an unsigned call to <a>GetCredentialsForIdentity</a>. This call expects the same <code>Logins</code> map as the <code>GetId</code> call, as well as the <code>IdentityID</code> originally returned by <code>GetId</code>. Assuming your identity pool has been configured via the <a>SetIdentityPoolRoles</a> operation, <code>GetCredentialsForIdentity</code> will return AWS credentials for your use. If your pool has not been configured with <code>SetIdentityPoolRoles</code>, or if you want to follow legacy flow, make an unsigned call to <a>GetOpenIdToken</a>, which returns the OpenID token necessary to call STS and retrieve AWS credentials. This call expects the same <code>Logins</code> map as the <code>GetId</code> call, as well as the <code>IdentityID</code> originally returned by <code>GetId</code>. The token returned by <code>GetOpenIdToken</code> can be passed to the STS operation <a href="http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html">AssumeRoleWithWebIdentity</a> to retrieve AWS credentials.</p> <p>If you want to use Amazon Cognito in an Android, iOS, or Unity application, you will probably want to make API calls via the AWS Mobile SDK. To learn more, see the <a href="http://docs.aws.amazon.com/mobile/index.html">AWS Mobile SDK Developer Guide</a>.</p>
+ */
+
+package com.amazonaws.services.cognitoidentity;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenService.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenService.java
new file mode 100644
index 0000000000..c9682c131f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenService.java
@@ -0,0 +1,840 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken;
+
+import com.amazonaws.*;
+import com.amazonaws.regions.*;
+import com.amazonaws.services.securitytoken.model.*;
+
+/**
+ * Interface for accessing AWS Security Token Service <fullname>AWS Security
+ * Token Service</fullname>
+ * <p>
+ * The AWS Security Token Service (STS) is a web service that enables you to
+ * request temporary, limited-privilege credentials for AWS Identity and Access
+ * Management (IAM) users or for users that you authenticate (federated users).
+ * This guide provides descriptions of the STS API. For more detailed
+ * information about using this service, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html"
+ * >Temporary Security Credentials</a>.
+ * </p>
+ * <note>
+ * <p>
+ * As an alternative to using the API, you can use one of the AWS SDKs, which
+ * consist of libraries and sample code for various programming languages and
+ * platforms (Java, Ruby, .NET, iOS, Android, etc.). The SDKs provide a
+ * convenient way to create programmatic access to STS. For example, the SDKs
+ * take care of cryptographically signing requests, managing errors, and
+ * retrying requests automatically. For information about the AWS SDKs,
+ * including how to download and install them, see the <a
+ * href="http://aws.amazon.com/tools/">Tools for Amazon Web Services page</a>.
+ * </p>
+ * </note>
+ * <p>
+ * For information about setting up signatures and authorization through the
+ * API, go to <a href=
+ * "http://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html"
+ * >Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For
+ * general information about the Query API, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html"
+ * >Making Query Requests</a> in <i>Using IAM</i>. For information about using
+ * security tokens with other AWS products, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html"
+ * >AWS Services That Work with IAM</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * If you're new to AWS and need additional technical information about a
+ * specific AWS product, you can find the product's technical documentation at
+ * <a href="http://aws.amazon.com/documentation/">http://aws.amazon.com/
+ * documentation/</a>.
+ * </p>
+ * <p>
+ * <b>Endpoints</b>
+ * </p>
+ * <p>
+ * The AWS Security Token Service (STS) has a default endpoint of
+ * https://sts.amazonaws.com that maps to the US East (N. Virginia) region.
+ * Additional regions are available and are activated by default. For more
+ * information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html"
+ * >Activating and Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
+ * Guide</i>.
+ * </p>
+ * <p>
+ * For information about STS endpoints, see <a
+ * href="http://docs.aws.amazon.com/general/latest/gr/rande.html#sts_region"
+ * >Regions and Endpoints</a> in the <i>AWS General Reference</i>.
+ * </p>
+ * <p>
+ * <b>Recording API requests</b>
+ * </p>
+ * <p>
+ * STS supports AWS CloudTrail, which is a service that records AWS calls for
+ * your AWS account and delivers log files to an Amazon S3 bucket. By using
+ * information collected by CloudTrail, you can determine what requests were
+ * successfully made to STS, who made the request, when it was made, and so on.
+ * To learn more about CloudTrail, including how to turn it on and find your log
+ * files, see the <a href=
+ * "http://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html"
+ * >AWS CloudTrail User Guide</a>.
+ * </p>
+ **/
+public interface AWSSecurityTokenService {
+
+    /**
+     * Overrides the default endpoint for this client
+     * ("https://sts.amazonaws.com"). Callers can use this method to control
+     * which AWS region they want to work with.
+     * <p>
+     * Callers can pass in just the endpoint (ex: "sts.amazonaws.com") or a full
+     * URL, including the protocol (ex: "https://sts.amazonaws.com"). If the
+     * protocol is not specified here, the default protocol from this client's
+     * {@link ClientConfiguration} will be used, which by default is HTTPS.
+     * <p>
+     * For more information on using AWS regions with the AWS SDK for Java, and
+     * a complete list of all available endpoints for all AWS services, see: <a
+     * href=
+     * "http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912"
+     * > http://developer.amazonwebservices.com/connect/entry.jspa?externalID=
+     * 3912</a>
+     * <p>
+     * <b>This method is not threadsafe. An endpoint should be configured when
+     * the client is created and before any service requests are made. Changing
+     * it afterwards creates inevitable race conditions for any service requests
+     * in transit or retrying.</b>
+     *
+     * @param endpoint The endpoint (ex: "sts.amazonaws.com") or a full URL,
+     *            including the protocol (ex: "https://sts.amazonaws.com") of
+     *            the region specific AWS endpoint this client will communicate
+     *            with.
+     * @throws IllegalArgumentException If any problems are detected with the
+     *             specified endpoint.
+     */
+    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;
+
+    /**
+     * An alternative to {@link AWSSecurityTokenService#setEndpoint(String)},
+     * sets the regional endpoint for this client's service calls. Callers can
+     * use this method to control which AWS region they want to work with.
+     * <p>
+     * By default, all service endpoints in all regions use the https protocol.
+     * To use http instead, specify it in the {@link ClientConfiguration}
+     * supplied at construction.
+     * <p>
+     * <b>This method is not threadsafe. A region should be configured when the
+     * client is created and before any service requests are made. Changing it
+     * afterwards creates inevitable race conditions for any service requests in
+     * transit or retrying.</b>
+     *
+     * @param region The region this client will communicate with. See
+     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
+     *            accessing a given region.
+     * @throws java.lang.IllegalArgumentException If the given region is null,
+     *             or if this service isn't available in the given region. See
+     *             {@link Region#isServiceSupported(String)}
+     * @see Region#getRegion(com.amazonaws.regions.Regions)
+     * @see Region#createClient(Class,
+     *      com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
+     */
+    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials (consisting of an access
+     * key ID, a secret access key, and a security token) that you can use to
+     * access AWS resources that you might not normally have access to.
+     * Typically, you use <code>AssumeRole</code> for cross-account access or
+     * federation. For a comparison of <code>AssumeRole</code> with the other
+     * APIs that produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * <b>Important:</b> You cannot call <code>AssumeRole</code> by using AWS
+     * root account credentials; access is denied. You must use credentials for
+     * an IAM user or an IAM role to call <code>AssumeRole</code>.
+     * </p>
+     * <p>
+     * For cross-account access, imagine that you own multiple accounts and need
+     * to access resources in each account. You could create long-term
+     * credentials in each account to access those resources. However, managing
+     * all those credentials and remembering which one can access which account
+     * can be time consuming. Instead, you can create one set of long-term
+     * credentials in one account and then use temporary security credentials to
+     * access all the other accounts by assuming roles in those accounts. For
+     * more information about roles, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html">IAM
+     * Roles (Delegation and Federation)</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * For federation, you can, for example, grant single sign-on access to the
+     * AWS Management Console. If you already have an identity and
+     * authentication system in your corporate network, you don't have to
+     * recreate user identities in AWS in order to grant those user identities
+     * access to AWS. Instead, after a user has been authenticated, you call
+     * <code>AssumeRole</code> (and specify the role with the appropriate
+     * permissions) to get temporary security credentials for that user. With
+     * those temporary security credentials, you construct a sign-in URL that
+     * users can use to access the console. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html#sts-introduction"
+     * >Common Scenarios for Temporary Credentials</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials are valid for the duration that you
+     * specified when calling <code>AssumeRole</code>, which can be from 900
+     * seconds (15 minutes) to a maximum of 3600 seconds (1 hour). The default
+     * is 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by <code>AssumeRole</code> can
+     * be used to make API calls to any AWS service with the following
+     * exception: you cannot call the STS service's
+     * <code>GetFederationToken</code> or <code>GetSessionToken</code> APIs.
+     * </p>
+     * <p>
+     * Optionally, you can pass an IAM access policy to this operation. If you
+     * choose not to pass a policy, the temporary security credentials that are
+     * returned by the operation have the permissions that are defined in the
+     * access policy of the role that is being assumed. If you pass a policy to
+     * this operation, the temporary security credentials that are returned by
+     * the operation have the permissions that are allowed by both the access
+     * policy of the role that is being assumed, <i> <b>and</b> </i> the policy
+     * that you pass. This gives you a way to further restrict the permissions
+     * for the resulting temporary security credentials. You cannot use the
+     * passed policy to grant permissions that are in excess of those allowed by
+     * the access policy of the role that is being assumed. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * To assume a role, your AWS account must be trusted by the role. The trust
+     * relationship is defined in the role's trust policy when the role is
+     * created. That trust policy states which accounts are allowed to delegate
+     * access to this account's role.
+     * </p>
+     * <p>
+     * The user who wants to access the role must also have permissions
+     * delegated from the role's administrator. If the user is in a different
+     * account than the role, then the user's administrator must attach a policy
+     * that allows the user to call AssumeRole on the ARN of the role in the
+     * other account. If the user is in the same account as the role, then you
+     * can either attach a policy to the user (identical to the previous
+     * different account user), or you can add the user as a principal directly
+     * in the role's trust policy
+     * </p>
+     * <p>
+     * <b>Using MFA with AssumeRole</b>
+     * </p>
+     * <p>
+     * You can optionally include multi-factor authentication (MFA) information
+     * when you call <code>AssumeRole</code>. This is useful for cross-account
+     * scenarios in which you want to make sure that the user who is assuming
+     * the role has been authenticated using an AWS MFA device. In that
+     * scenario, the trust policy of the role being assumed includes a condition
+     * that tests for MFA authentication; if the caller does not include valid
+     * MFA information, the request to assume the role is denied. The condition
+     * in a trust policy that tests for MFA authentication might look like the
+     * following example.
+     * </p>
+     * <p>
+     * <code>"Condition": {"Bool": {"aws:MultiFactorAuthPresent": true}}</code>
+     * </p>
+     * <p>
+     * For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/MFAProtectedAPI.html"
+     * >Configuring MFA-Protected API Access</a> in the <i>IAM User Guide</i>
+     * guide.
+     * </p>
+     * <p>
+     * To use MFA with <code>AssumeRole</code>, you pass values for the
+     * <code>SerialNumber</code> and <code>TokenCode</code> parameters. The
+     * <code>SerialNumber</code> value identifies the user's hardware or virtual
+     * MFA device. The <code>TokenCode</code> is the time-based one-time
+     * password (TOTP) that the MFA devices produces.
+     * </p>
+     * 
+     * @param assumeRoleRequest
+     * @return assumeRoleResult The response from the AssumeRole service method,
+     *         as returned by AWS Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    AssumeRoleResult assumeRole(AssumeRoleRequest assumeRoleRequest) throws AmazonClientException,
+            AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials for users who have been
+     * authenticated in a mobile or web application with a web identity
+     * provider, such as Amazon Cognito, Login with Amazon, Facebook, Google, or
+     * any OpenID Connect-compatible identity provider.
+     * </p>
+     * <note>
+     * <p>
+     * For mobile applications, we recommend that you use Amazon Cognito. You
+     * can use Amazon Cognito with the <a
+     * href="http://aws.amazon.com/sdkforios/">AWS SDK for iOS</a> and the <a
+     * href="http://aws.amazon.com/sdkforandroid/">AWS SDK for Android</a> to
+     * uniquely identify a user and supply the user with a consistent identity
+     * throughout the lifetime of an application.
+     * </p>
+     * <p>
+     * To learn more about Amazon Cognito, see <a href=
+     * "http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-auth.html#d0e840"
+     * >Amazon Cognito Overview</a> in the <i>AWS SDK for Android Developer
+     * Guide</i> guide and <a href=
+     * "http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-auth.html#d0e664"
+     * >Amazon Cognito Overview</a> in the <i>AWS SDK for iOS Developer
+     * Guide</i>.
+     * </p>
+     * </note>
+     * <p>
+     * Calling <code>AssumeRoleWithWebIdentity</code> does not require the use
+     * of AWS security credentials. Therefore, you can distribute an application
+     * (for example, on mobile devices) that requests temporary security
+     * credentials without including long-term AWS credentials in the
+     * application, and without deploying server-based proxy services that use
+     * long-term AWS credentials. Instead, the identity of the caller is
+     * validated by using a token from the web identity provider. For a
+     * comparison of <code>AssumeRoleWithWebIdentity</code> with the other APIs
+     * that produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials returned by this API consist of an
+     * access key ID, a secret access key, and a security token. Applications
+     * can use these temporary security credentials to sign calls to AWS service
+     * APIs.
+     * </p>
+     * <p>
+     * The credentials are valid for the duration that you specified when
+     * calling <code>AssumeRoleWithWebIdentity</code>, which can be from 900
+     * seconds (15 minutes) to a maximum of 3600 seconds (1 hour). The default
+     * is 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>AssumeRoleWithWebIdentity</code> can be used to make API calls to
+     * any AWS service with the following exception: you cannot call the STS
+     * service's <code>GetFederationToken</code> or <code>GetSessionToken</code>
+     * APIs.
+     * </p>
+     * <p>
+     * Optionally, you can pass an IAM access policy to this operation. If you
+     * choose not to pass a policy, the temporary security credentials that are
+     * returned by the operation have the permissions that are defined in the
+     * access policy of the role that is being assumed. If you pass a policy to
+     * this operation, the temporary security credentials that are returned by
+     * the operation have the permissions that are allowed by both the access
+     * policy of the role that is being assumed, <i> <b>and</b> </i> the policy
+     * that you pass. This gives you a way to further restrict the permissions
+     * for the resulting temporary security credentials. You cannot use the
+     * passed policy to grant permissions that are in excess of those allowed by
+     * the access policy of the role that is being assumed. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * Before your application can call <code>AssumeRoleWithWebIdentity</code>,
+     * you must have an identity token from a supported identity provider and
+     * create a role that the application can assume. The role that your
+     * application assumes must trust the identity provider that is associated
+     * with the identity token. In other words, the identity provider must be
+     * specified in the role's trust policy.
+     * </p>
+     * <important>
+     * <p>
+     * Calling <code>AssumeRoleWithWebIdentity</code> can result in an entry in
+     * your AWS CloudTrail logs. The entry includes the <a
+     * href="http://openid.net/specs/openid-connect-core-1_0.html#Claims"
+     * >Subject</a> of the provided Web Identity Token. We recommend that you
+     * avoid using any personally identifiable information (PII) in this field.
+     * For example, you could instead use a GUID or a pairwise identifier, as <a
+     * href
+     * ="http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes"
+     * >suggested in the OIDC specification</a>.
+     * </p>
+     * </important>
+     * <p>
+     * For more information about how to use web identity federation and the
+     * <code>AssumeRoleWithWebIdentity</code> API, see the following resources:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_manual"
+     * >Using Web Identity Federation APIs for Mobile Apps</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+     * >Federation Through a Web-based Identity Provider</a>.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href=
+     * "https://web-identity-federation-playground.s3.amazonaws.com/index.html">
+     * Web Identity Federation Playground</a>. This interactive website lets you
+     * walk through the process of authenticating via Login with Amazon,
+     * Facebook, or Google, getting temporary security credentials, and then
+     * using those credentials to make a request to AWS.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href="http://aws.amazon.com/sdkforios/">AWS SDK for iOS</a> and <a
+     * href="http://aws.amazon.com/sdkforandroid/">AWS SDK for Android</a>.
+     * These toolkits contain sample apps that show how to invoke the identity
+     * providers, and then how to use the information from these providers to
+     * get and use temporary security credentials.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href="http://aws.amazon.com/articles/4617974389850313">Web Identity
+     * Federation with Mobile Applications</a>. This article discusses web
+     * identity federation and shows an example of how to use web identity
+     * federation to get access to content in Amazon S3.
+     * </p>
+     * </li>
+     * </ul>
+     * 
+     * @param assumeRoleWithWebIdentityRequest
+     * @return assumeRoleWithWebIdentityResult The response from the
+     *         AssumeRoleWithWebIdentity service method, as returned by AWS
+     *         Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws IDPRejectedClaimException
+     * @throws IDPCommunicationErrorException
+     * @throws InvalidIdentityTokenException
+     * @throws ExpiredTokenException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    AssumeRoleWithWebIdentityResult assumeRoleWithWebIdentity(
+            AssumeRoleWithWebIdentityRequest assumeRoleWithWebIdentityRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns details about the IAM identity whose credentials are used to call
+     * the API.
+     * </p>
+     * 
+     * @param getCallerIdentityRequest
+     * @return getCallerIdentityResult The response from the GetCallerIdentity
+     *         service method, as returned by AWS Security Token Service.
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    GetCallerIdentityResult getCallerIdentity(GetCallerIdentityRequest getCallerIdentityRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials (consisting of an access
+     * key ID, a secret access key, and a security token) for a federated user.
+     * A typical use is in a proxy application that gets temporary security
+     * credentials on behalf of distributed applications inside a corporate
+     * network. Because you must call the <code>GetFederationToken</code> action
+     * using the long-term security credentials of an IAM user, this call is
+     * appropriate in contexts where those credentials can be safely stored,
+     * usually in a server-based application. For a comparison of
+     * <code>GetFederationToken</code> with the other APIs that produce
+     * temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <note>
+     * <p>
+     * If you are creating a mobile-based or browser-based app that can
+     * authenticate users using a web identity provider like Login with Amazon,
+     * Facebook, Google, or an OpenID Connect-compatible identity provider, we
+     * recommend that you use <a href="http://aws.amazon.com/cognito/">Amazon
+     * Cognito</a> or <code>AssumeRoleWithWebIdentity</code>. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+     * >Federation Through a Web-based Identity Provider</a>.
+     * </p>
+     * </note>
+     * <p>
+     * The <code>GetFederationToken</code> action must be called by using the
+     * long-term AWS security credentials of an IAM user. You can also call
+     * <code>GetFederationToken</code> using the security credentials of an AWS
+     * root account, but we do not recommended it. Instead, we recommend that
+     * you create an IAM user for the purpose of the proxy application and then
+     * attach a policy to the IAM user that limits federated users to only the
+     * actions and resources that they need access to. For more information, see
+     * <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">IAM
+     * Best Practices</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials that are obtained by using the
+     * long-term credentials of an IAM user are valid for the specified
+     * duration, from 900 seconds (15 minutes) up to a maximium of 129600
+     * seconds (36 hours). The default is 43200 seconds (12 hours). Temporary
+     * credentials that are obtained by using AWS root account credentials have
+     * a maximum duration of 3600 seconds (1 hour).
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetFederationToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot use these credentials to call any IAM APIs.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS APIs.
+     * </p>
+     * </li>
+     * </ul>
+     * <p>
+     * <b>Permissions</b>
+     * </p>
+     * <p>
+     * The permissions for the temporary security credentials returned by
+     * <code>GetFederationToken</code> are determined by a combination of the
+     * following:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * The policy or policies that are attached to the IAM user whose
+     * credentials are used to call <code>GetFederationToken</code>.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * The policy that is passed as a parameter in the call.
+     * </p>
+     * </li>
+     * </ul>
+     * <p>
+     * The passed policy is attached to the temporary security credentials that
+     * result from the <code>GetFederationToken</code> API call--that is, to the
+     * <i>federated user</i>. When the federated user makes an AWS request, AWS
+     * evaluates the policy attached to the federated user in combination with
+     * the policy or policies attached to the IAM user whose credentials were
+     * used to call <code>GetFederationToken</code>. AWS allows the federated
+     * user's request only when both the federated user <i> <b>and</b> </i> the
+     * IAM user are explicitly allowed to perform the requested action. The
+     * passed policy cannot grant more permissions than those that are defined
+     * in the IAM user policy.
+     * </p>
+     * <p>
+     * A typical use case is that the permissions of the IAM user whose
+     * credentials are used to call <code>GetFederationToken</code> are designed
+     * to allow access to all the actions and resources that any federated user
+     * will need. Then, for individual users, you pass a policy to the operation
+     * that scopes down the permissions to a level that's appropriate to that
+     * individual user, using a policy that allows only a subset of permissions
+     * that are granted to the IAM user.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>. For information about using
+     * <code>GetFederationToken</code> to create temporary security credentials,
+     * see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getfederationtoken"
+     * >GetFederationTokenFederation Through a Custom Identity Broker</a>.
+     * </p>
+     * 
+     * @param getFederationTokenRequest
+     * @return getFederationTokenResult The response from the GetFederationToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    GetFederationTokenResult getFederationToken(GetFederationTokenRequest getFederationTokenRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns a set of temporary credentials for an AWS account or IAM user.
+     * The credentials consist of an access key ID, a secret access key, and a
+     * security token. Typically, you use <code>GetSessionToken</code> if you
+     * want to use MFA to protect programmatic calls to specific AWS APIs like
+     * Amazon EC2 <code>StopInstances</code>. MFA-enabled IAM users would need
+     * to call <code>GetSessionToken</code> and submit an MFA code that is
+     * associated with their MFA device. Using the temporary security
+     * credentials that are returned from the call, IAM users can then make
+     * programmatic calls to APIs that require MFA authentication. If you do not
+     * supply a correct MFA code, then the API returns an access denied error.
+     * For a comparison of <code>GetSessionToken</code> with the other APIs that
+     * produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The <code>GetSessionToken</code> action must be called by using the
+     * long-term AWS security credentials of the AWS account or an IAM user.
+     * Credentials that are created by IAM users are valid for the duration that
+     * you specify, from 900 seconds (15 minutes) up to a maximum of 129600
+     * seconds (36 hours), with a default of 43200 seconds (12 hours);
+     * credentials that are created by using account credentials can range from
+     * 900 seconds (15 minutes) up to a maximum of 3600 seconds (1 hour), with a
+     * default of 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetSessionToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot call any IAM APIs unless MFA authentication information is
+     * included in the request.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS API <i>except</i> <code>AssumeRole</code>.
+     * </p>
+     * </li>
+     * </ul>
+     * <note>
+     * <p>
+     * We recommend that you do not call <code>GetSessionToken</code> with root
+     * account credentials. Instead, follow our <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users"
+     * >best practices</a> by creating one or more IAM users, giving them the
+     * necessary permissions, and using IAM users for everyday interaction with
+     * AWS.
+     * </p>
+     * </note>
+     * <p>
+     * The permissions associated with the temporary security credentials
+     * returned by <code>GetSessionToken</code> are based on the permissions
+     * associated with account or IAM user whose credentials are used to call
+     * the action. If <code>GetSessionToken</code> is called using root account
+     * credentials, the temporary credentials have root account permissions.
+     * Similarly, if <code>GetSessionToken</code> is called using the
+     * credentials of an IAM user, the temporary credentials have the same
+     * permissions as the IAM user.
+     * </p>
+     * <p>
+     * For more information about using <code>GetSessionToken</code> to create
+     * temporary credentials, go to <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getsessiontoken"
+     * >Temporary Credentials for Users in Untrusted Environments</a> in the
+     * <i>IAM User Guide</i>.
+     * </p>
+     * 
+     * @param getSessionTokenRequest
+     * @return getSessionTokenResult The response from the GetSessionToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    GetSessionTokenResult getSessionToken(GetSessionTokenRequest getSessionTokenRequest)
+            throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns a set of temporary credentials for an AWS account or IAM user.
+     * The credentials consist of an access key ID, a secret access key, and a
+     * security token. Typically, you use <code>GetSessionToken</code> if you
+     * want to use MFA to protect programmatic calls to specific AWS APIs like
+     * Amazon EC2 <code>StopInstances</code>. MFA-enabled IAM users would need
+     * to call <code>GetSessionToken</code> and submit an MFA code that is
+     * associated with their MFA device. Using the temporary security
+     * credentials that are returned from the call, IAM users can then make
+     * programmatic calls to APIs that require MFA authentication. If you do not
+     * supply a correct MFA code, then the API returns an access denied error.
+     * For a comparison of <code>GetSessionToken</code> with the other APIs that
+     * produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The <code>GetSessionToken</code> action must be called by using the
+     * long-term AWS security credentials of the AWS account or an IAM user.
+     * Credentials that are created by IAM users are valid for the duration that
+     * you specify, from 900 seconds (15 minutes) up to a maximum of 129600
+     * seconds (36 hours), with a default of 43200 seconds (12 hours);
+     * credentials that are created by using account credentials can range from
+     * 900 seconds (15 minutes) up to a maximum of 3600 seconds (1 hour), with a
+     * default of 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetSessionToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot call any IAM APIs unless MFA authentication information is
+     * included in the request.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS API <i>except</i> <code>AssumeRole</code>.
+     * </p>
+     * </li>
+     * </ul>
+     * <note>
+     * <p>
+     * We recommend that you do not call <code>GetSessionToken</code> with root
+     * account credentials. Instead, follow our <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users"
+     * >best practices</a> by creating one or more IAM users, giving them the
+     * necessary permissions, and using IAM users for everyday interaction with
+     * AWS.
+     * </p>
+     * </note>
+     * <p>
+     * The permissions associated with the temporary security credentials
+     * returned by <code>GetSessionToken</code> are based on the permissions
+     * associated with account or IAM user whose credentials are used to call
+     * the action. If <code>GetSessionToken</code> is called using root account
+     * credentials, the temporary credentials have root account permissions.
+     * Similarly, if <code>GetSessionToken</code> is called using the
+     * credentials of an IAM user, the temporary credentials have the same
+     * permissions as the IAM user.
+     * </p>
+     * <p>
+     * For more information about using <code>GetSessionToken</code> to create
+     * temporary credentials, go to <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getsessiontoken"
+     * >Temporary Credentials for Users in Untrusted Environments</a> in the
+     * <i>IAM User Guide</i>.
+     * </p>
+     * 
+     * @return getSessionTokenResult The response from the GetSessionToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    GetSessionTokenResult getSessionToken() throws AmazonClientException, AmazonServiceException;
+
+    /**
+     * <p>
+     * Returns details about the IAM identity whose credentials are used to call
+     * the API.
+     * </p>
+     * 
+     * @return getCallerIdentityResult The response from the GetCallerIdentity
+     *         service method, as returned by AWS Security Token Service.
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    GetCallerIdentityResult getCallerIdentity() throws AmazonClientException,
+            AmazonServiceException;
+
+    /**
+     * Shuts down this client object, releasing any resources that might be held
+     * open. This is an optional method, and callers are not expected to call
+     * it, but can if they want to explicitly release any open resources. Once a
+     * client has been shutdown, it should not be used to make any more
+     * requests.
+     */
+    public void shutdown();
+
+    /**
+     * Returns additional metadata for a previously executed successful request,
+     * typically used for debugging issues where a service isn't acting as
+     * expected. This data isn't considered part of the result data returned by
+     * an operation, so it's available through this separate, diagnostic
+     * interface.
+     * <p>
+     * Response metadata is only cached for a limited period of time, so if you
+     * need to access this extra diagnostic information for an executed request,
+     * you should use this method to retrieve it as soon as possible after
+     * executing a request.
+     *
+     * @param request The originally executed request.
+     * @return The response metadata for the specified request, or null if none
+     *         is available.
+     */
+    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java
new file mode 100644
index 0000000000..56acd749bb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java
@@ -0,0 +1,1151 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken;
+
+import org.w3c.dom.*;
+
+import java.util.*;
+
+import com.amazonaws.*;
+import com.amazonaws.auth.*;
+import com.amazonaws.handlers.*;
+import com.amazonaws.http.*;
+import com.amazonaws.internal.*;
+import com.amazonaws.metrics.*;
+import com.amazonaws.transform.*;
+import com.amazonaws.util.*;
+import com.amazonaws.util.AWSRequestMetrics.Field;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.services.securitytoken.model.transform.*;
+
+/**
+ * Client for accessing AWS Security Token Service. All service calls made using
+ * this client are blocking, and will not return until the service call
+ * completes.
+ * <p>
+ * <fullname>AWS Security Token Service</fullname>
+ * <p>
+ * The AWS Security Token Service (STS) is a web service that enables you to
+ * request temporary, limited-privilege credentials for AWS Identity and Access
+ * Management (IAM) users or for users that you authenticate (federated users).
+ * This guide provides descriptions of the STS API. For more detailed
+ * information about using this service, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html"
+ * >Temporary Security Credentials</a>.
+ * </p>
+ * <note>
+ * <p>
+ * As an alternative to using the API, you can use one of the AWS SDKs, which
+ * consist of libraries and sample code for various programming languages and
+ * platforms (Java, Ruby, .NET, iOS, Android, etc.). The SDKs provide a
+ * convenient way to create programmatic access to STS. For example, the SDKs
+ * take care of cryptographically signing requests, managing errors, and
+ * retrying requests automatically. For information about the AWS SDKs,
+ * including how to download and install them, see the <a
+ * href="http://aws.amazon.com/tools/">Tools for Amazon Web Services page</a>.
+ * </p>
+ * </note>
+ * <p>
+ * For information about setting up signatures and authorization through the
+ * API, go to <a href=
+ * "http://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html"
+ * >Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For
+ * general information about the Query API, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html"
+ * >Making Query Requests</a> in <i>Using IAM</i>. For information about using
+ * security tokens with other AWS products, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html"
+ * >AWS Services That Work with IAM</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * If you're new to AWS and need additional technical information about a
+ * specific AWS product, you can find the product's technical documentation at
+ * <a href="http://aws.amazon.com/documentation/">http://aws.amazon.com/
+ * documentation/</a>.
+ * </p>
+ * <p>
+ * <b>Endpoints</b>
+ * </p>
+ * <p>
+ * The AWS Security Token Service (STS) has a default endpoint of
+ * https://sts.amazonaws.com that maps to the US East (N. Virginia) region.
+ * Additional regions are available and are activated by default. For more
+ * information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html"
+ * >Activating and Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
+ * Guide</i>.
+ * </p>
+ * <p>
+ * For information about STS endpoints, see <a
+ * href="http://docs.aws.amazon.com/general/latest/gr/rande.html#sts_region"
+ * >Regions and Endpoints</a> in the <i>AWS General Reference</i>.
+ * </p>
+ * <p>
+ * <b>Recording API requests</b>
+ * </p>
+ * <p>
+ * STS supports AWS CloudTrail, which is a service that records AWS calls for
+ * your AWS account and delivers log files to an Amazon S3 bucket. By using
+ * information collected by CloudTrail, you can determine what requests were
+ * successfully made to STS, who made the request, when it was made, and so on.
+ * To learn more about CloudTrail, including how to turn it on and find your log
+ * files, see the <a href=
+ * "http://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html"
+ * >AWS CloudTrail User Guide</a>.
+ * </p>
+ */
+public class AWSSecurityTokenServiceClient extends AmazonWebServiceClient implements
+        AWSSecurityTokenService {
+    /** Provider for AWS credentials. */
+    private AWSCredentialsProvider awsCredentialsProvider;
+
+    /**
+     * List of exception unmarshallers for all AWS Security Token Service
+     * exceptions.
+     */
+    protected final List<Unmarshaller<AmazonServiceException, Node>> exceptionUnmarshallers = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService. A credentials provider chain will be used that
+     * searches for credentials in this order:
+     * <ul>
+     * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>
+     * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>
+     * <li>Instance profile credentials delivered through the Amazon EC2
+     * metadata service</li>
+     * </ul>
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @see DefaultAWSCredentialsProviderChain
+     */
+    @Deprecated
+    public AWSSecurityTokenServiceClient() {
+        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService. A credentials provider chain will be used that
+     * searches for credentials in this order:
+     * <ul>
+     * <li>Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY</li>
+     * <li>Java System Properties - aws.accessKeyId and aws.secretKey</li>
+     * <li>Instance profile credentials delivered through the Amazon EC2
+     * metadata service</li>
+     * </ul>
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AWSSecurityTokenService (ex: proxy
+     *            settings, retry counts, etc.).
+     * @see DefaultAWSCredentialsProviderChain
+     */
+    @Deprecated
+    public AWSSecurityTokenServiceClient(ClientConfiguration clientConfiguration) {
+        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentials The AWS credentials (access key ID and secret key)
+     *            to use when authenticating with AWS services.
+     */
+    public AWSSecurityTokenServiceClient(AWSCredentials awsCredentials) {
+        this(awsCredentials, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials and
+     * client configuration options.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentials The AWS credentials (access key ID and secret key)
+     *            to use when authenticating with AWS services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AWSSecurityTokenService (ex: proxy
+     *            settings, retry counts, etc.).
+     */
+    public AWSSecurityTokenServiceClient(AWSCredentials awsCredentials,
+            ClientConfiguration clientConfiguration) {
+        this(new StaticCredentialsProvider(awsCredentials), clientConfiguration);
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials
+     * provider.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     */
+    public AWSSecurityTokenServiceClient(AWSCredentialsProvider awsCredentialsProvider) {
+        this(awsCredentialsProvider, new ClientConfiguration());
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials
+     * provider and client configuration options.
+     * <p>
+     * If AWS session credentials are passed in, then those credentials will be
+     * used to authenticate requests. Otherwise, if AWS long-term credentials
+     * are passed in, then session management will be handled automatically by
+     * the SDK. Callers are encouraged to use long-term credentials and let the
+     * SDK handle starting and renewing sessions.
+     * <p>
+     * Automatically managed sessions will be shared among all clients that use
+     * the same credentials and service endpoint. To opt out of this behavior,
+     * explicitly provide an instance of {@link AWSCredentialsProvider} that
+     * returns {@link AWSSessionCredentials}.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AWSSecurityTokenService (ex: proxy
+     *            settings, retry counts, etc.).
+     */
+    public AWSSecurityTokenServiceClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration) {
+        this(awsCredentialsProvider, clientConfiguration, new UrlHttpClient(clientConfiguration));
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials
+     * provider, client configuration options and request metric collector.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AWSSecurityTokenService (ex: proxy
+     *            settings, retry counts, etc.).
+     * @param requestMetricCollector optional request metric collector
+     */
+    @Deprecated
+    public AWSSecurityTokenServiceClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration,
+            RequestMetricCollector requestMetricCollector) {
+        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
+
+        this.awsCredentialsProvider = awsCredentialsProvider;
+
+        init();
+    }
+
+    /**
+     * Constructs a new client to invoke service methods on
+     * AWSSecurityTokenService using the specified AWS account credentials
+     * provider, client configuration options and request metric collector.
+     * <p>
+     * All service calls made using this new client object are blocking, and
+     * will not return until the service call completes.
+     *
+     * @param awsCredentialsProvider The AWS credentials provider which will
+     *            provide credentials to authenticate requests with AWS
+     *            services.
+     * @param clientConfiguration The client configuration options controlling
+     *            how this client connects to AWSSecurityTokenService (ex: proxy
+     *            settings, retry counts, etc.).
+     * @param httpClient A http client
+     */
+    public AWSSecurityTokenServiceClient(AWSCredentialsProvider awsCredentialsProvider,
+            ClientConfiguration clientConfiguration, HttpClient httpClient) {
+        super(adjustClientConfiguration(clientConfiguration), httpClient);
+
+        this.awsCredentialsProvider = awsCredentialsProvider;
+
+        init();
+    }
+
+    private void init() {
+        exceptionUnmarshallers.add(new ExpiredTokenExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new IDPCommunicationErrorExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new IDPRejectedClaimExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new InvalidIdentityTokenExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new MalformedPolicyDocumentExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new PackedPolicyTooLargeExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new RegionDisabledExceptionUnmarshaller());
+        exceptionUnmarshallers.add(new StandardErrorUnmarshaller());
+
+        // calling this.setEndPoint(...) will also modify the signer accordingly
+        this.setEndpoint("sts.amazonaws.com");
+        this.endpointPrefix = "sts";
+
+        HandlerChainFactory chainFactory = new HandlerChainFactory();
+        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
+                "/com/amazonaws/services/securitytoken/request.handlers"));
+        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
+                "/com/amazonaws/services/securitytoken/request.handler2s"));
+    }
+
+    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
+        ClientConfiguration config = orig;
+
+        return config;
+    }
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials (consisting of an access
+     * key ID, a secret access key, and a security token) that you can use to
+     * access AWS resources that you might not normally have access to.
+     * Typically, you use <code>AssumeRole</code> for cross-account access or
+     * federation. For a comparison of <code>AssumeRole</code> with the other
+     * APIs that produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * <b>Important:</b> You cannot call <code>AssumeRole</code> by using AWS
+     * root account credentials; access is denied. You must use credentials for
+     * an IAM user or an IAM role to call <code>AssumeRole</code>.
+     * </p>
+     * <p>
+     * For cross-account access, imagine that you own multiple accounts and need
+     * to access resources in each account. You could create long-term
+     * credentials in each account to access those resources. However, managing
+     * all those credentials and remembering which one can access which account
+     * can be time consuming. Instead, you can create one set of long-term
+     * credentials in one account and then use temporary security credentials to
+     * access all the other accounts by assuming roles in those accounts. For
+     * more information about roles, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html">IAM
+     * Roles (Delegation and Federation)</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * For federation, you can, for example, grant single sign-on access to the
+     * AWS Management Console. If you already have an identity and
+     * authentication system in your corporate network, you don't have to
+     * recreate user identities in AWS in order to grant those user identities
+     * access to AWS. Instead, after a user has been authenticated, you call
+     * <code>AssumeRole</code> (and specify the role with the appropriate
+     * permissions) to get temporary security credentials for that user. With
+     * those temporary security credentials, you construct a sign-in URL that
+     * users can use to access the console. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html#sts-introduction"
+     * >Common Scenarios for Temporary Credentials</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials are valid for the duration that you
+     * specified when calling <code>AssumeRole</code>, which can be from 900
+     * seconds (15 minutes) to a maximum of 3600 seconds (1 hour). The default
+     * is 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by <code>AssumeRole</code> can
+     * be used to make API calls to any AWS service with the following
+     * exception: you cannot call the STS service's
+     * <code>GetFederationToken</code> or <code>GetSessionToken</code> APIs.
+     * </p>
+     * <p>
+     * Optionally, you can pass an IAM access policy to this operation. If you
+     * choose not to pass a policy, the temporary security credentials that are
+     * returned by the operation have the permissions that are defined in the
+     * access policy of the role that is being assumed. If you pass a policy to
+     * this operation, the temporary security credentials that are returned by
+     * the operation have the permissions that are allowed by both the access
+     * policy of the role that is being assumed, <i> <b>and</b> </i> the policy
+     * that you pass. This gives you a way to further restrict the permissions
+     * for the resulting temporary security credentials. You cannot use the
+     * passed policy to grant permissions that are in excess of those allowed by
+     * the access policy of the role that is being assumed. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * To assume a role, your AWS account must be trusted by the role. The trust
+     * relationship is defined in the role's trust policy when the role is
+     * created. That trust policy states which accounts are allowed to delegate
+     * access to this account's role.
+     * </p>
+     * <p>
+     * The user who wants to access the role must also have permissions
+     * delegated from the role's administrator. If the user is in a different
+     * account than the role, then the user's administrator must attach a policy
+     * that allows the user to call AssumeRole on the ARN of the role in the
+     * other account. If the user is in the same account as the role, then you
+     * can either attach a policy to the user (identical to the previous
+     * different account user), or you can add the user as a principal directly
+     * in the role's trust policy
+     * </p>
+     * <p>
+     * <b>Using MFA with AssumeRole</b>
+     * </p>
+     * <p>
+     * You can optionally include multi-factor authentication (MFA) information
+     * when you call <code>AssumeRole</code>. This is useful for cross-account
+     * scenarios in which you want to make sure that the user who is assuming
+     * the role has been authenticated using an AWS MFA device. In that
+     * scenario, the trust policy of the role being assumed includes a condition
+     * that tests for MFA authentication; if the caller does not include valid
+     * MFA information, the request to assume the role is denied. The condition
+     * in a trust policy that tests for MFA authentication might look like the
+     * following example.
+     * </p>
+     * <p>
+     * <code>"Condition": {"Bool": {"aws:MultiFactorAuthPresent": true}}</code>
+     * </p>
+     * <p>
+     * For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/MFAProtectedAPI.html"
+     * >Configuring MFA-Protected API Access</a> in the <i>IAM User Guide</i>
+     * guide.
+     * </p>
+     * <p>
+     * To use MFA with <code>AssumeRole</code>, you pass values for the
+     * <code>SerialNumber</code> and <code>TokenCode</code> parameters. The
+     * <code>SerialNumber</code> value identifies the user's hardware or virtual
+     * MFA device. The <code>TokenCode</code> is the time-based one-time
+     * password (TOTP) that the MFA devices produces.
+     * </p>
+     * 
+     * @param assumeRoleRequest
+     * @return assumeRoleResult The response from the AssumeRole service method,
+     *         as returned by AWS Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public AssumeRoleResult assumeRole(AssumeRoleRequest assumeRoleRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(assumeRoleRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<AssumeRoleRequest> request = null;
+        Response<AssumeRoleResult> response = null;
+        try {
+            request = new AssumeRoleRequestMarshaller().marshall(assumeRoleRequest);
+            // Binds the request metrics to the current request.
+            request.setAWSRequestMetrics(awsRequestMetrics);
+            response = invoke(request, new AssumeRoleResultStaxUnmarshaller(), executionContext);
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response);
+        }
+    }
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials for users who have been
+     * authenticated in a mobile or web application with a web identity
+     * provider, such as Amazon Cognito, Login with Amazon, Facebook, Google, or
+     * any OpenID Connect-compatible identity provider.
+     * </p>
+     * <note>
+     * <p>
+     * For mobile applications, we recommend that you use Amazon Cognito. You
+     * can use Amazon Cognito with the <a
+     * href="http://aws.amazon.com/sdkforios/">AWS SDK for iOS</a> and the <a
+     * href="http://aws.amazon.com/sdkforandroid/">AWS SDK for Android</a> to
+     * uniquely identify a user and supply the user with a consistent identity
+     * throughout the lifetime of an application.
+     * </p>
+     * <p>
+     * To learn more about Amazon Cognito, see <a href=
+     * "http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-auth.html#d0e840"
+     * >Amazon Cognito Overview</a> in the <i>AWS SDK for Android Developer
+     * Guide</i> guide and <a href=
+     * "http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-auth.html#d0e664"
+     * >Amazon Cognito Overview</a> in the <i>AWS SDK for iOS Developer
+     * Guide</i>.
+     * </p>
+     * </note>
+     * <p>
+     * Calling <code>AssumeRoleWithWebIdentity</code> does not require the use
+     * of AWS security credentials. Therefore, you can distribute an application
+     * (for example, on mobile devices) that requests temporary security
+     * credentials without including long-term AWS credentials in the
+     * application, and without deploying server-based proxy services that use
+     * long-term AWS credentials. Instead, the identity of the caller is
+     * validated by using a token from the web identity provider. For a
+     * comparison of <code>AssumeRoleWithWebIdentity</code> with the other APIs
+     * that produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials returned by this API consist of an
+     * access key ID, a secret access key, and a security token. Applications
+     * can use these temporary security credentials to sign calls to AWS service
+     * APIs.
+     * </p>
+     * <p>
+     * The credentials are valid for the duration that you specified when
+     * calling <code>AssumeRoleWithWebIdentity</code>, which can be from 900
+     * seconds (15 minutes) to a maximum of 3600 seconds (1 hour). The default
+     * is 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>AssumeRoleWithWebIdentity</code> can be used to make API calls to
+     * any AWS service with the following exception: you cannot call the STS
+     * service's <code>GetFederationToken</code> or <code>GetSessionToken</code>
+     * APIs.
+     * </p>
+     * <p>
+     * Optionally, you can pass an IAM access policy to this operation. If you
+     * choose not to pass a policy, the temporary security credentials that are
+     * returned by the operation have the permissions that are defined in the
+     * access policy of the role that is being assumed. If you pass a policy to
+     * this operation, the temporary security credentials that are returned by
+     * the operation have the permissions that are allowed by both the access
+     * policy of the role that is being assumed, <i> <b>and</b> </i> the policy
+     * that you pass. This gives you a way to further restrict the permissions
+     * for the resulting temporary security credentials. You cannot use the
+     * passed policy to grant permissions that are in excess of those allowed by
+     * the access policy of the role that is being assumed. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * Before your application can call <code>AssumeRoleWithWebIdentity</code>,
+     * you must have an identity token from a supported identity provider and
+     * create a role that the application can assume. The role that your
+     * application assumes must trust the identity provider that is associated
+     * with the identity token. In other words, the identity provider must be
+     * specified in the role's trust policy.
+     * </p>
+     * <important>
+     * <p>
+     * Calling <code>AssumeRoleWithWebIdentity</code> can result in an entry in
+     * your AWS CloudTrail logs. The entry includes the <a
+     * href="http://openid.net/specs/openid-connect-core-1_0.html#Claims"
+     * >Subject</a> of the provided Web Identity Token. We recommend that you
+     * avoid using any personally identifiable information (PII) in this field.
+     * For example, you could instead use a GUID or a pairwise identifier, as <a
+     * href
+     * ="http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes"
+     * >suggested in the OIDC specification</a>.
+     * </p>
+     * </important>
+     * <p>
+     * For more information about how to use web identity federation and the
+     * <code>AssumeRoleWithWebIdentity</code> API, see the following resources:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_manual"
+     * >Using Web Identity Federation APIs for Mobile Apps</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+     * >Federation Through a Web-based Identity Provider</a>.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href=
+     * "https://web-identity-federation-playground.s3.amazonaws.com/index.html">
+     * Web Identity Federation Playground</a>. This interactive website lets you
+     * walk through the process of authenticating via Login with Amazon,
+     * Facebook, or Google, getting temporary security credentials, and then
+     * using those credentials to make a request to AWS.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href="http://aws.amazon.com/sdkforios/">AWS SDK for iOS</a> and <a
+     * href="http://aws.amazon.com/sdkforandroid/">AWS SDK for Android</a>.
+     * These toolkits contain sample apps that show how to invoke the identity
+     * providers, and then how to use the information from these providers to
+     * get and use temporary security credentials.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * <a href="http://aws.amazon.com/articles/4617974389850313">Web Identity
+     * Federation with Mobile Applications</a>. This article discusses web
+     * identity federation and shows an example of how to use web identity
+     * federation to get access to content in Amazon S3.
+     * </p>
+     * </li>
+     * </ul>
+     * 
+     * @param assumeRoleWithWebIdentityRequest
+     * @return assumeRoleWithWebIdentityResult The response from the
+     *         AssumeRoleWithWebIdentity service method, as returned by AWS
+     *         Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws IDPRejectedClaimException
+     * @throws IDPCommunicationErrorException
+     * @throws InvalidIdentityTokenException
+     * @throws ExpiredTokenException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public AssumeRoleWithWebIdentityResult assumeRoleWithWebIdentity(
+            AssumeRoleWithWebIdentityRequest assumeRoleWithWebIdentityRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(assumeRoleWithWebIdentityRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<AssumeRoleWithWebIdentityRequest> request = null;
+        Response<AssumeRoleWithWebIdentityResult> response = null;
+        try {
+            request = new AssumeRoleWithWebIdentityRequestMarshaller()
+                    .marshall(assumeRoleWithWebIdentityRequest);
+            // Binds the request metrics to the current request.
+            request.setAWSRequestMetrics(awsRequestMetrics);
+            response = invoke(request, new AssumeRoleWithWebIdentityResultStaxUnmarshaller(),
+                    executionContext);
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response);
+        }
+    }
+
+    /**
+     * <p>
+     * Returns details about the IAM identity whose credentials are used to call
+     * the API.
+     * </p>
+     * 
+     * @param getCallerIdentityRequest
+     * @return getCallerIdentityResult The response from the GetCallerIdentity
+     *         service method, as returned by AWS Security Token Service.
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public GetCallerIdentityResult getCallerIdentity(
+            GetCallerIdentityRequest getCallerIdentityRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getCallerIdentityRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetCallerIdentityRequest> request = null;
+        Response<GetCallerIdentityResult> response = null;
+        try {
+            request = new GetCallerIdentityRequestMarshaller().marshall(getCallerIdentityRequest);
+            // Binds the request metrics to the current request.
+            request.setAWSRequestMetrics(awsRequestMetrics);
+            response = invoke(request, new GetCallerIdentityResultStaxUnmarshaller(),
+                    executionContext);
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response);
+        }
+    }
+
+    /**
+     * <p>
+     * Returns a set of temporary security credentials (consisting of an access
+     * key ID, a secret access key, and a security token) for a federated user.
+     * A typical use is in a proxy application that gets temporary security
+     * credentials on behalf of distributed applications inside a corporate
+     * network. Because you must call the <code>GetFederationToken</code> action
+     * using the long-term security credentials of an IAM user, this call is
+     * appropriate in contexts where those credentials can be safely stored,
+     * usually in a server-based application. For a comparison of
+     * <code>GetFederationToken</code> with the other APIs that produce
+     * temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <note>
+     * <p>
+     * If you are creating a mobile-based or browser-based app that can
+     * authenticate users using a web identity provider like Login with Amazon,
+     * Facebook, Google, or an OpenID Connect-compatible identity provider, we
+     * recommend that you use <a href="http://aws.amazon.com/cognito/">Amazon
+     * Cognito</a> or <code>AssumeRoleWithWebIdentity</code>. For more
+     * information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+     * >Federation Through a Web-based Identity Provider</a>.
+     * </p>
+     * </note>
+     * <p>
+     * The <code>GetFederationToken</code> action must be called by using the
+     * long-term AWS security credentials of an IAM user. You can also call
+     * <code>GetFederationToken</code> using the security credentials of an AWS
+     * root account, but we do not recommended it. Instead, we recommend that
+     * you create an IAM user for the purpose of the proxy application and then
+     * attach a policy to the IAM user that limits federated users to only the
+     * actions and resources that they need access to. For more information, see
+     * <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">IAM
+     * Best Practices</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The temporary security credentials that are obtained by using the
+     * long-term credentials of an IAM user are valid for the specified
+     * duration, from 900 seconds (15 minutes) up to a maximium of 129600
+     * seconds (36 hours). The default is 43200 seconds (12 hours). Temporary
+     * credentials that are obtained by using AWS root account credentials have
+     * a maximum duration of 3600 seconds (1 hour).
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetFederationToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot use these credentials to call any IAM APIs.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS APIs.
+     * </p>
+     * </li>
+     * </ul>
+     * <p>
+     * <b>Permissions</b>
+     * </p>
+     * <p>
+     * The permissions for the temporary security credentials returned by
+     * <code>GetFederationToken</code> are determined by a combination of the
+     * following:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * The policy or policies that are attached to the IAM user whose
+     * credentials are used to call <code>GetFederationToken</code>.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * The policy that is passed as a parameter in the call.
+     * </p>
+     * </li>
+     * </ul>
+     * <p>
+     * The passed policy is attached to the temporary security credentials that
+     * result from the <code>GetFederationToken</code> API call--that is, to the
+     * <i>federated user</i>. When the federated user makes an AWS request, AWS
+     * evaluates the policy attached to the federated user in combination with
+     * the policy or policies attached to the IAM user whose credentials were
+     * used to call <code>GetFederationToken</code>. AWS allows the federated
+     * user's request only when both the federated user <i> <b>and</b> </i> the
+     * IAM user are explicitly allowed to perform the requested action. The
+     * passed policy cannot grant more permissions than those that are defined
+     * in the IAM user policy.
+     * </p>
+     * <p>
+     * A typical use case is that the permissions of the IAM user whose
+     * credentials are used to call <code>GetFederationToken</code> are designed
+     * to allow access to all the actions and resources that any federated user
+     * will need. Then, for individual users, you pass a policy to the operation
+     * that scopes down the permissions to a level that's appropriate to that
+     * individual user, using a policy that allows only a subset of permissions
+     * that are granted to the IAM user.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>. For information about using
+     * <code>GetFederationToken</code> to create temporary security credentials,
+     * see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getfederationtoken"
+     * >GetFederationTokenFederation Through a Custom Identity Broker</a>.
+     * </p>
+     * 
+     * @param getFederationTokenRequest
+     * @return getFederationTokenResult The response from the GetFederationToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws MalformedPolicyDocumentException
+     * @throws PackedPolicyTooLargeException
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public GetFederationTokenResult getFederationToken(
+            GetFederationTokenRequest getFederationTokenRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getFederationTokenRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetFederationTokenRequest> request = null;
+        Response<GetFederationTokenResult> response = null;
+        try {
+            request = new GetFederationTokenRequestMarshaller().marshall(getFederationTokenRequest);
+            // Binds the request metrics to the current request.
+            request.setAWSRequestMetrics(awsRequestMetrics);
+            response = invoke(request, new GetFederationTokenResultStaxUnmarshaller(),
+                    executionContext);
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response);
+        }
+    }
+
+    /**
+     * <p>
+     * Returns a set of temporary credentials for an AWS account or IAM user.
+     * The credentials consist of an access key ID, a secret access key, and a
+     * security token. Typically, you use <code>GetSessionToken</code> if you
+     * want to use MFA to protect programmatic calls to specific AWS APIs like
+     * Amazon EC2 <code>StopInstances</code>. MFA-enabled IAM users would need
+     * to call <code>GetSessionToken</code> and submit an MFA code that is
+     * associated with their MFA device. Using the temporary security
+     * credentials that are returned from the call, IAM users can then make
+     * programmatic calls to APIs that require MFA authentication. If you do not
+     * supply a correct MFA code, then the API returns an access denied error.
+     * For a comparison of <code>GetSessionToken</code> with the other APIs that
+     * produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The <code>GetSessionToken</code> action must be called by using the
+     * long-term AWS security credentials of the AWS account or an IAM user.
+     * Credentials that are created by IAM users are valid for the duration that
+     * you specify, from 900 seconds (15 minutes) up to a maximum of 129600
+     * seconds (36 hours), with a default of 43200 seconds (12 hours);
+     * credentials that are created by using account credentials can range from
+     * 900 seconds (15 minutes) up to a maximum of 3600 seconds (1 hour), with a
+     * default of 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetSessionToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot call any IAM APIs unless MFA authentication information is
+     * included in the request.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS API <i>except</i> <code>AssumeRole</code>.
+     * </p>
+     * </li>
+     * </ul>
+     * <note>
+     * <p>
+     * We recommend that you do not call <code>GetSessionToken</code> with root
+     * account credentials. Instead, follow our <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users"
+     * >best practices</a> by creating one or more IAM users, giving them the
+     * necessary permissions, and using IAM users for everyday interaction with
+     * AWS.
+     * </p>
+     * </note>
+     * <p>
+     * The permissions associated with the temporary security credentials
+     * returned by <code>GetSessionToken</code> are based on the permissions
+     * associated with account or IAM user whose credentials are used to call
+     * the action. If <code>GetSessionToken</code> is called using root account
+     * credentials, the temporary credentials have root account permissions.
+     * Similarly, if <code>GetSessionToken</code> is called using the
+     * credentials of an IAM user, the temporary credentials have the same
+     * permissions as the IAM user.
+     * </p>
+     * <p>
+     * For more information about using <code>GetSessionToken</code> to create
+     * temporary credentials, go to <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getsessiontoken"
+     * >Temporary Credentials for Users in Untrusted Environments</a> in the
+     * <i>IAM User Guide</i>.
+     * </p>
+     * 
+     * @param getSessionTokenRequest
+     * @return getSessionTokenResult The response from the GetSessionToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public GetSessionTokenResult getSessionToken(GetSessionTokenRequest getSessionTokenRequest)
+            throws AmazonServiceException, AmazonClientException {
+        ExecutionContext executionContext = createExecutionContext(getSessionTokenRequest);
+        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
+        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
+        Request<GetSessionTokenRequest> request = null;
+        Response<GetSessionTokenResult> response = null;
+        try {
+            request = new GetSessionTokenRequestMarshaller().marshall(getSessionTokenRequest);
+            // Binds the request metrics to the current request.
+            request.setAWSRequestMetrics(awsRequestMetrics);
+            response = invoke(request, new GetSessionTokenResultStaxUnmarshaller(),
+                    executionContext);
+            return response.getAwsResponse();
+        } finally {
+            endClientExecution(awsRequestMetrics, request, response);
+        }
+    }
+
+    /**
+     * <p>
+     * Returns a set of temporary credentials for an AWS account or IAM user.
+     * The credentials consist of an access key ID, a secret access key, and a
+     * security token. Typically, you use <code>GetSessionToken</code> if you
+     * want to use MFA to protect programmatic calls to specific AWS APIs like
+     * Amazon EC2 <code>StopInstances</code>. MFA-enabled IAM users would need
+     * to call <code>GetSessionToken</code> and submit an MFA code that is
+     * associated with their MFA device. Using the temporary security
+     * credentials that are returned from the call, IAM users can then make
+     * programmatic calls to APIs that require MFA authentication. If you do not
+     * supply a correct MFA code, then the API returns an access denied error.
+     * For a comparison of <code>GetSessionToken</code> with the other APIs that
+     * produce temporary credentials, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+     * >Requesting Temporary Security Credentials</a> and <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+     * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The <code>GetSessionToken</code> action must be called by using the
+     * long-term AWS security credentials of the AWS account or an IAM user.
+     * Credentials that are created by IAM users are valid for the duration that
+     * you specify, from 900 seconds (15 minutes) up to a maximum of 129600
+     * seconds (36 hours), with a default of 43200 seconds (12 hours);
+     * credentials that are created by using account credentials can range from
+     * 900 seconds (15 minutes) up to a maximum of 3600 seconds (1 hour), with a
+     * default of 1 hour.
+     * </p>
+     * <p>
+     * The temporary security credentials created by
+     * <code>GetSessionToken</code> can be used to make API calls to any AWS
+     * service with the following exceptions:
+     * </p>
+     * <ul>
+     * <li>
+     * <p>
+     * You cannot call any IAM APIs unless MFA authentication information is
+     * included in the request.
+     * </p>
+     * </li>
+     * <li>
+     * <p>
+     * You cannot call any STS API <i>except</i> <code>AssumeRole</code>.
+     * </p>
+     * </li>
+     * </ul>
+     * <note>
+     * <p>
+     * We recommend that you do not call <code>GetSessionToken</code> with root
+     * account credentials. Instead, follow our <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users"
+     * >best practices</a> by creating one or more IAM users, giving them the
+     * necessary permissions, and using IAM users for everyday interaction with
+     * AWS.
+     * </p>
+     * </note>
+     * <p>
+     * The permissions associated with the temporary security credentials
+     * returned by <code>GetSessionToken</code> are based on the permissions
+     * associated with account or IAM user whose credentials are used to call
+     * the action. If <code>GetSessionToken</code> is called using root account
+     * credentials, the temporary credentials have root account permissions.
+     * Similarly, if <code>GetSessionToken</code> is called using the
+     * credentials of an IAM user, the temporary credentials have the same
+     * permissions as the IAM user.
+     * </p>
+     * <p>
+     * For more information about using <code>GetSessionToken</code> to create
+     * temporary credentials, go to <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getsessiontoken"
+     * >Temporary Credentials for Users in Untrusted Environments</a> in the
+     * <i>IAM User Guide</i>.
+     * </p>
+     * 
+     * @return getSessionTokenResult The response from the GetSessionToken
+     *         service method, as returned by AWS Security Token Service.
+     * @throws RegionDisabledException
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public GetSessionTokenResult getSessionToken()
+            throws AmazonServiceException, AmazonClientException {
+        GetSessionTokenRequest getSessionTokenRequest = new GetSessionTokenRequest();
+        return getSessionToken(getSessionTokenRequest);
+    }
+
+    /**
+     * <p>
+     * Returns details about the IAM identity whose credentials are used to call
+     * the API.
+     * </p>
+     * 
+     * @return getCallerIdentityResult The response from the GetCallerIdentity
+     *         service method, as returned by AWS Security Token Service.
+     * @throws AmazonClientException If any internal errors are encountered
+     *             inside the client while attempting to make the request or
+     *             handle the response. For example if a network connection is
+     *             not available.
+     * @throws AmazonServiceException If an error response is returned by AWS
+     *             Security Token Service indicating either a problem with the
+     *             data in the request, or a server side issue.
+     */
+    public GetCallerIdentityResult getCallerIdentity()
+            throws AmazonServiceException, AmazonClientException {
+        GetCallerIdentityRequest getCallerIdentityRequest = new GetCallerIdentityRequest();
+        return getCallerIdentity(getCallerIdentityRequest);
+    }
+
+    /**
+     * Returns additional metadata for a previously executed successful,
+     * request, typically used for debugging issues where a service isn't acting
+     * as expected. This data isn't considered part of the result data returned
+     * by an operation, so it's available through this separate, diagnostic
+     * interface.
+     * <p>
+     * Response metadata is only cached for a limited period of time, so if you
+     * need to access this extra diagnostic information for an executed request,
+     * you should use this method to retrieve it as soon as possible after
+     * executing the request.
+     *
+     * @param request The originally executed request
+     * @return The response metadata for the specified request, or null if none
+     *         is available.
+     * @deprecated ResponseMetadata cache can hold up to 50 requests and
+     *             responses in memory and will cause memory issue. This method
+     *             now always returns null.
+     */
+    @Deprecated
+    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
+        return client.getResponseMetadataForRequest(request);
+    }
+
+    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
+            Unmarshaller<X, StaxUnmarshallerContext> unmarshaller,
+            ExecutionContext executionContext) {
+        request.setEndpoint(endpoint);
+        request.setTimeOffset(timeOffset);
+        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
+
+        AWSCredentials credentials = awsCredentialsProvider.getCredentials();
+        if (originalRequest.getRequestCredentials() != null) {
+            credentials = originalRequest.getRequestCredentials();
+        }
+
+        executionContext.setCredentials(credentials);
+
+        StaxResponseHandler<X> responseHandler = new StaxResponseHandler<X>(unmarshaller);
+        DefaultErrorResponseHandler errorResponseHandler = new DefaultErrorResponseHandler(
+                exceptionUnmarshallers);
+        return client.execute(request, responseHandler, errorResponseHandler, executionContext);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleRequest.java
new file mode 100644
index 0000000000..bcceadf56b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleRequest.java
@@ -0,0 +1,1308 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns a set of temporary security credentials (consisting of an access key
+ * ID, a secret access key, and a security token) that you can use to access AWS
+ * resources that you might not normally have access to. Typically, you use
+ * <code>AssumeRole</code> for cross-account access or federation. For a
+ * comparison of <code>AssumeRole</code> with the other APIs that produce
+ * temporary credentials, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+ * >Requesting Temporary Security Credentials</a> and <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+ * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * <b>Important:</b> You cannot call <code>AssumeRole</code> by using AWS root
+ * account credentials; access is denied. You must use credentials for an IAM
+ * user or an IAM role to call <code>AssumeRole</code>.
+ * </p>
+ * <p>
+ * For cross-account access, imagine that you own multiple accounts and need to
+ * access resources in each account. You could create long-term credentials in
+ * each account to access those resources. However, managing all those
+ * credentials and remembering which one can access which account can be time
+ * consuming. Instead, you can create one set of long-term credentials in one
+ * account and then use temporary security credentials to access all the other
+ * accounts by assuming roles in those accounts. For more information about
+ * roles, see <a
+ * href="http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html"
+ * >IAM Roles (Delegation and Federation)</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * For federation, you can, for example, grant single sign-on access to the AWS
+ * Management Console. If you already have an identity and authentication system
+ * in your corporate network, you don't have to recreate user identities in AWS
+ * in order to grant those user identities access to AWS. Instead, after a user
+ * has been authenticated, you call <code>AssumeRole</code> (and specify the
+ * role with the appropriate permissions) to get temporary security credentials
+ * for that user. With those temporary security credentials, you construct a
+ * sign-in URL that users can use to access the console. For more information,
+ * see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html#sts-introduction"
+ * >Common Scenarios for Temporary Credentials</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * The temporary security credentials are valid for the duration that you
+ * specified when calling <code>AssumeRole</code>, which can be from 900 seconds
+ * (15 minutes) to a maximum of 3600 seconds (1 hour). The default is 1 hour.
+ * </p>
+ * <p>
+ * The temporary security credentials created by <code>AssumeRole</code> can be
+ * used to make API calls to any AWS service with the following exception: you
+ * cannot call the STS service's <code>GetFederationToken</code> or
+ * <code>GetSessionToken</code> APIs.
+ * </p>
+ * <p>
+ * Optionally, you can pass an IAM access policy to this operation. If you
+ * choose not to pass a policy, the temporary security credentials that are
+ * returned by the operation have the permissions that are defined in the access
+ * policy of the role that is being assumed. If you pass a policy to this
+ * operation, the temporary security credentials that are returned by the
+ * operation have the permissions that are allowed by both the access policy of
+ * the role that is being assumed, <i> <b>and</b> </i> the policy that you pass.
+ * This gives you a way to further restrict the permissions for the resulting
+ * temporary security credentials. You cannot use the passed policy to grant
+ * permissions that are in excess of those allowed by the access policy of the
+ * role that is being assumed. For more information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+ * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+ * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * To assume a role, your AWS account must be trusted by the role. The trust
+ * relationship is defined in the role's trust policy when the role is created.
+ * That trust policy states which accounts are allowed to delegate access to
+ * this account's role.
+ * </p>
+ * <p>
+ * The user who wants to access the role must also have permissions delegated
+ * from the role's administrator. If the user is in a different account than the
+ * role, then the user's administrator must attach a policy that allows the user
+ * to call AssumeRole on the ARN of the role in the other account. If the user
+ * is in the same account as the role, then you can either attach a policy to
+ * the user (identical to the previous different account user), or you can add
+ * the user as a principal directly in the role's trust policy
+ * </p>
+ * <p>
+ * <b>Using MFA with AssumeRole</b>
+ * </p>
+ * <p>
+ * You can optionally include multi-factor authentication (MFA) information when
+ * you call <code>AssumeRole</code>. This is useful for cross-account scenarios
+ * in which you want to make sure that the user who is assuming the role has
+ * been authenticated using an AWS MFA device. In that scenario, the trust
+ * policy of the role being assumed includes a condition that tests for MFA
+ * authentication; if the caller does not include valid MFA information, the
+ * request to assume the role is denied. The condition in a trust policy that
+ * tests for MFA authentication might look like the following example.
+ * </p>
+ * <p>
+ * <code>"Condition": {"Bool": {"aws:MultiFactorAuthPresent": true}}</code>
+ * </p>
+ * <p>
+ * For more information, see <a
+ * href="http://docs.aws.amazon.com/IAM/latest/UserGuide/MFAProtectedAPI.html"
+ * >Configuring MFA-Protected API Access</a> in the <i>IAM User Guide</i> guide.
+ * </p>
+ * <p>
+ * To use MFA with <code>AssumeRole</code>, you pass values for the
+ * <code>SerialNumber</code> and <code>TokenCode</code> parameters. The
+ * <code>SerialNumber</code> value identifies the user's hardware or virtual MFA
+ * device. The <code>TokenCode</code> is the time-based one-time password (TOTP)
+ * that the MFA devices produces.
+ * </p>
+ */
+public class AssumeRoleRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to assume.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     */
+    private String roleArn;
+
+    /**
+     * <p>
+     * An identifier for the assumed role session.
+     * </p>
+     * <p>
+     * Use the role session name to uniquely identify a session when the same
+     * role is assumed by different principals or for different reasons. In
+     * cross-account scenarios, the role session name is visible to, and can be
+     * logged by the account that owns the role. The role session name is also
+     * used in the ARN of the assumed role principal. This means that subsequent
+     * cross-account API requests using the temporary security credentials will
+     * expose the role session name to the external account in their CloudTrail
+     * logs.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     */
+    private String roleSessionName;
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * This parameter is optional. If you pass a policy, the temporary security
+     * credentials that are returned by the operation have the permissions that
+     * are allowed by both (the intersection of) the access policy of the role
+     * that is being assumed, <i>and</i> the policy that you pass. This gives
+     * you a way to further restrict the permissions for the resulting temporary
+     * security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     */
+    private String policy;
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     */
+    private Integer durationSeconds;
+
+    /**
+     * <p>
+     * A unique identifier that is used by third parties when assuming roles in
+     * their customers' accounts. For each role that the third party can assume,
+     * they should instruct their customers to ensure the role's trust policy
+     * checks for the external ID that the third party generated. Each time the
+     * third party assumes the role, they should pass the customer's external
+     * ID. The external ID is useful in order to help third parties bind a role
+     * to the customer who created it. For more information about the external
+     * ID, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     * >How to Use an External ID When Granting Access to Your AWS Resources to
+     * a Third Party</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@:\/-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 1224<br/>
+     * <b>Pattern: </b>[\w+=,.@:\/-]*<br/>
+     */
+    private String externalId;
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * user who is making the <code>AssumeRole</code> call. Specify this value
+     * if the trust policy of the role being assumed includes a condition that
+     * requires MFA authentication. The value is either the serial number for a
+     * hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource
+     * Name (ARN) for a virtual device (such as
+     * <code>arn:aws:iam::123456789012:mfa/user</code>).
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     */
+    private String serialNumber;
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if the trust policy of the role
+     * being assumed requires MFA (that is, if the policy includes a condition
+     * that tests for MFA). If the role being assumed requires MFA and if the
+     * <code>TokenCode</code> value is missing or expired, the
+     * <code>AssumeRole</code> call returns an "access denied" error.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     */
+    private String tokenCode;
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to assume.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @return <p>
+     *         The Amazon Resource Name (ARN) of the role to assume.
+     *         </p>
+     */
+    public String getRoleArn() {
+        return roleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to assume.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param roleArn <p>
+     *            The Amazon Resource Name (ARN) of the role to assume.
+     *            </p>
+     */
+    public void setRoleArn(String roleArn) {
+        this.roleArn = roleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role to assume.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param roleArn <p>
+     *            The Amazon Resource Name (ARN) of the role to assume.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withRoleArn(String roleArn) {
+        this.roleArn = roleArn;
+        return this;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session.
+     * </p>
+     * <p>
+     * Use the role session name to uniquely identify a session when the same
+     * role is assumed by different principals or for different reasons. In
+     * cross-account scenarios, the role session name is visible to, and can be
+     * logged by the account that owns the role. The role session name is also
+     * used in the ARN of the assumed role principal. This means that subsequent
+     * cross-account API requests using the temporary security credentials will
+     * expose the role session name to the external account in their CloudTrail
+     * logs.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @return <p>
+     *         An identifier for the assumed role session.
+     *         </p>
+     *         <p>
+     *         Use the role session name to uniquely identify a session when the
+     *         same role is assumed by different principals or for different
+     *         reasons. In cross-account scenarios, the role session name is
+     *         visible to, and can be logged by the account that owns the role.
+     *         The role session name is also used in the ARN of the assumed role
+     *         principal. This means that subsequent cross-account API requests
+     *         using the temporary security credentials will expose the role
+     *         session name to the external account in their CloudTrail logs.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@-
+     *         </p>
+     */
+    public String getRoleSessionName() {
+        return roleSessionName;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session.
+     * </p>
+     * <p>
+     * Use the role session name to uniquely identify a session when the same
+     * role is assumed by different principals or for different reasons. In
+     * cross-account scenarios, the role session name is visible to, and can be
+     * logged by the account that owns the role. The role session name is also
+     * used in the ARN of the assumed role principal. This means that subsequent
+     * cross-account API requests using the temporary security credentials will
+     * expose the role session name to the external account in their CloudTrail
+     * logs.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param roleSessionName <p>
+     *            An identifier for the assumed role session.
+     *            </p>
+     *            <p>
+     *            Use the role session name to uniquely identify a session when
+     *            the same role is assumed by different principals or for
+     *            different reasons. In cross-account scenarios, the role
+     *            session name is visible to, and can be logged by the account
+     *            that owns the role. The role session name is also used in the
+     *            ARN of the assumed role principal. This means that subsequent
+     *            cross-account API requests using the temporary security
+     *            credentials will expose the role session name to the external
+     *            account in their CloudTrail logs.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public void setRoleSessionName(String roleSessionName) {
+        this.roleSessionName = roleSessionName;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session.
+     * </p>
+     * <p>
+     * Use the role session name to uniquely identify a session when the same
+     * role is assumed by different principals or for different reasons. In
+     * cross-account scenarios, the role session name is visible to, and can be
+     * logged by the account that owns the role. The role session name is also
+     * used in the ARN of the assumed role principal. This means that subsequent
+     * cross-account API requests using the temporary security credentials will
+     * expose the role session name to the external account in their CloudTrail
+     * logs.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param roleSessionName <p>
+     *            An identifier for the assumed role session.
+     *            </p>
+     *            <p>
+     *            Use the role session name to uniquely identify a session when
+     *            the same role is assumed by different principals or for
+     *            different reasons. In cross-account scenarios, the role
+     *            session name is visible to, and can be logged by the account
+     *            that owns the role. The role session name is also used in the
+     *            ARN of the assumed role principal. This means that subsequent
+     *            cross-account API requests using the temporary security
+     *            credentials will expose the role session name to the external
+     *            account in their CloudTrail logs.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withRoleSessionName(String roleSessionName) {
+        this.roleSessionName = roleSessionName;
+        return this;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * This parameter is optional. If you pass a policy, the temporary security
+     * credentials that are returned by the operation have the permissions that
+     * are allowed by both (the intersection of) the access policy of the role
+     * that is being assumed, <i>and</i> the policy that you pass. This gives
+     * you a way to further restrict the permissions for the resulting temporary
+     * security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @return <p>
+     *         An IAM policy in JSON format.
+     *         </p>
+     *         <p>
+     *         This parameter is optional. If you pass a policy, the temporary
+     *         security credentials that are returned by the operation have the
+     *         permissions that are allowed by both (the intersection of) the
+     *         access policy of the role that is being assumed, <i>and</i> the
+     *         policy that you pass. This gives you a way to further restrict
+     *         the permissions for the resulting temporary security credentials.
+     *         You cannot use the passed policy to grant permissions that are in
+     *         excess of those allowed by the access policy of the role that is
+     *         being assumed. For more information, see <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *         >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     *         AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters up to 2048 characters in length. The
+     *         characters can be any ASCII character from the space character to
+     *         the end of the valid character list ( -\u00FF). It can also
+     *         include the tab ( ), linefeed ( ), and carriage return ( )
+     *         characters.
+     *         </p>
+     *         <note>
+     *         <p>
+     *         The policy plain text must be 2048 bytes or shorter. However, an
+     *         internal conversion compresses it into a packed binary format
+     *         with a separate limit. The PackedPolicySize response element
+     *         indicates by percentage how close to the upper size limit the
+     *         policy is, with 100% equaling the maximum allowed size.
+     *         </p>
+     *         </note>
+     */
+    public String getPolicy() {
+        return policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * This parameter is optional. If you pass a policy, the temporary security
+     * credentials that are returned by the operation have the permissions that
+     * are allowed by both (the intersection of) the access policy of the role
+     * that is being assumed, <i>and</i> the policy that you pass. This gives
+     * you a way to further restrict the permissions for the resulting temporary
+     * security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format.
+     *            </p>
+     *            <p>
+     *            This parameter is optional. If you pass a policy, the
+     *            temporary security credentials that are returned by the
+     *            operation have the permissions that are allowed by both (the
+     *            intersection of) the access policy of the role that is being
+     *            assumed, <i>and</i> the policy that you pass. This gives you a
+     *            way to further restrict the permissions for the resulting
+     *            temporary security credentials. You cannot use the passed
+     *            policy to grant permissions that are in excess of those
+     *            allowed by the access policy of the role that is being
+     *            assumed. For more information, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *            >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     *            AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     */
+    public void setPolicy(String policy) {
+        this.policy = policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * This parameter is optional. If you pass a policy, the temporary security
+     * credentials that are returned by the operation have the permissions that
+     * are allowed by both (the intersection of) the access policy of the role
+     * that is being assumed, <i>and</i> the policy that you pass. This gives
+     * you a way to further restrict the permissions for the resulting temporary
+     * security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format.
+     *            </p>
+     *            <p>
+     *            This parameter is optional. If you pass a policy, the
+     *            temporary security credentials that are returned by the
+     *            operation have the permissions that are allowed by both (the
+     *            intersection of) the access policy of the role that is being
+     *            assumed, <i>and</i> the policy that you pass. This gives you a
+     *            way to further restrict the permissions for the resulting
+     *            temporary security credentials. You cannot use the passed
+     *            policy to grant permissions that are in excess of those
+     *            allowed by the access policy of the role that is being
+     *            assumed. For more information, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *            >Permissions for AssumeRole, AssumeRoleWithSAML, and
+     *            AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withPolicy(String policy) {
+        this.policy = policy;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @return <p>
+     *         The duration, in seconds, of the role session. The value can
+     *         range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By
+     *         default, the value is set to 3600 seconds.
+     *         </p>
+     */
+    public Integer getDurationSeconds() {
+        return durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, of the role session. The value can
+     *            range from 900 seconds (15 minutes) to 3600 seconds (1 hour).
+     *            By default, the value is set to 3600 seconds.
+     *            </p>
+     */
+    public void setDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, of the role session. The value can
+     *            range from 900 seconds (15 minutes) to 3600 seconds (1 hour).
+     *            By default, the value is set to 3600 seconds.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A unique identifier that is used by third parties when assuming roles in
+     * their customers' accounts. For each role that the third party can assume,
+     * they should instruct their customers to ensure the role's trust policy
+     * checks for the external ID that the third party generated. Each time the
+     * third party assumes the role, they should pass the customer's external
+     * ID. The external ID is useful in order to help third parties bind a role
+     * to the customer who created it. For more information about the external
+     * ID, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     * >How to Use an External ID When Granting Access to Your AWS Resources to
+     * a Third Party</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@:\/-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 1224<br/>
+     * <b>Pattern: </b>[\w+=,.@:\/-]*<br/>
+     *
+     * @return <p>
+     *         A unique identifier that is used by third parties when assuming
+     *         roles in their customers' accounts. For each role that the third
+     *         party can assume, they should instruct their customers to ensure
+     *         the role's trust policy checks for the external ID that the third
+     *         party generated. Each time the third party assumes the role, they
+     *         should pass the customer's external ID. The external ID is useful
+     *         in order to help third parties bind a role to the customer who
+     *         created it. For more information about the external ID, see <a
+     *         href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     *         >How to Use an External ID When Granting Access to Your AWS
+     *         Resources to a Third Party</a> in the <i>IAM User Guide</i>.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@:\/-
+     *         </p>
+     */
+    public String getExternalId() {
+        return externalId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier that is used by third parties when assuming roles in
+     * their customers' accounts. For each role that the third party can assume,
+     * they should instruct their customers to ensure the role's trust policy
+     * checks for the external ID that the third party generated. Each time the
+     * third party assumes the role, they should pass the customer's external
+     * ID. The external ID is useful in order to help third parties bind a role
+     * to the customer who created it. For more information about the external
+     * ID, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     * >How to Use an External ID When Granting Access to Your AWS Resources to
+     * a Third Party</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@:\/-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 1224<br/>
+     * <b>Pattern: </b>[\w+=,.@:\/-]*<br/>
+     *
+     * @param externalId <p>
+     *            A unique identifier that is used by third parties when
+     *            assuming roles in their customers' accounts. For each role
+     *            that the third party can assume, they should instruct their
+     *            customers to ensure the role's trust policy checks for the
+     *            external ID that the third party generated. Each time the
+     *            third party assumes the role, they should pass the customer's
+     *            external ID. The external ID is useful in order to help third
+     *            parties bind a role to the customer who created it. For more
+     *            information about the external ID, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     *            >How to Use an External ID When Granting Access to Your AWS
+     *            Resources to a Third Party</a> in the <i>IAM User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@:\/-
+     *            </p>
+     */
+    public void setExternalId(String externalId) {
+        this.externalId = externalId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier that is used by third parties when assuming roles in
+     * their customers' accounts. For each role that the third party can assume,
+     * they should instruct their customers to ensure the role's trust policy
+     * checks for the external ID that the third party generated. Each time the
+     * third party assumes the role, they should pass the customer's external
+     * ID. The external ID is useful in order to help third parties bind a role
+     * to the customer who created it. For more information about the external
+     * ID, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     * >How to Use an External ID When Granting Access to Your AWS Resources to
+     * a Third Party</a> in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@:\/-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 1224<br/>
+     * <b>Pattern: </b>[\w+=,.@:\/-]*<br/>
+     *
+     * @param externalId <p>
+     *            A unique identifier that is used by third parties when
+     *            assuming roles in their customers' accounts. For each role
+     *            that the third party can assume, they should instruct their
+     *            customers to ensure the role's trust policy checks for the
+     *            external ID that the third party generated. Each time the
+     *            third party assumes the role, they should pass the customer's
+     *            external ID. The external ID is useful in order to help third
+     *            parties bind a role to the customer who created it. For more
+     *            information about the external ID, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html"
+     *            >How to Use an External ID When Granting Access to Your AWS
+     *            Resources to a Third Party</a> in the <i>IAM User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@:\/-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withExternalId(String externalId) {
+        this.externalId = externalId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * user who is making the <code>AssumeRole</code> call. Specify this value
+     * if the trust policy of the role being assumed includes a condition that
+     * requires MFA authentication. The value is either the serial number for a
+     * hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource
+     * Name (ARN) for a virtual device (such as
+     * <code>arn:aws:iam::123456789012:mfa/user</code>).
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @return <p>
+     *         The identification number of the MFA device that is associated
+     *         with the user who is making the <code>AssumeRole</code> call.
+     *         Specify this value if the trust policy of the role being assumed
+     *         includes a condition that requires MFA authentication. The value
+     *         is either the serial number for a hardware device (such as
+     *         <code>GAHT12345678</code>) or an Amazon Resource Name (ARN) for a
+     *         virtual device (such as
+     *         <code>arn:aws:iam::123456789012:mfa/user</code>).
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@-
+     *         </p>
+     */
+    public String getSerialNumber() {
+        return serialNumber;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * user who is making the <code>AssumeRole</code> call. Specify this value
+     * if the trust policy of the role being assumed includes a condition that
+     * requires MFA authentication. The value is either the serial number for a
+     * hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource
+     * Name (ARN) for a virtual device (such as
+     * <code>arn:aws:iam::123456789012:mfa/user</code>).
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @param serialNumber <p>
+     *            The identification number of the MFA device that is associated
+     *            with the user who is making the <code>AssumeRole</code> call.
+     *            Specify this value if the trust policy of the role being
+     *            assumed includes a condition that requires MFA authentication.
+     *            The value is either the serial number for a hardware device
+     *            (such as <code>GAHT12345678</code>) or an Amazon Resource Name
+     *            (ARN) for a virtual device (such as
+     *            <code>arn:aws:iam::123456789012:mfa/user</code>).
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public void setSerialNumber(String serialNumber) {
+        this.serialNumber = serialNumber;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * user who is making the <code>AssumeRole</code> call. Specify this value
+     * if the trust policy of the role being assumed includes a condition that
+     * requires MFA authentication. The value is either the serial number for a
+     * hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource
+     * Name (ARN) for a virtual device (such as
+     * <code>arn:aws:iam::123456789012:mfa/user</code>).
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @param serialNumber <p>
+     *            The identification number of the MFA device that is associated
+     *            with the user who is making the <code>AssumeRole</code> call.
+     *            Specify this value if the trust policy of the role being
+     *            assumed includes a condition that requires MFA authentication.
+     *            The value is either the serial number for a hardware device
+     *            (such as <code>GAHT12345678</code>) or an Amazon Resource Name
+     *            (ARN) for a virtual device (such as
+     *            <code>arn:aws:iam::123456789012:mfa/user</code>).
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withSerialNumber(String serialNumber) {
+        this.serialNumber = serialNumber;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if the trust policy of the role
+     * being assumed requires MFA (that is, if the policy includes a condition
+     * that tests for MFA). If the role being assumed requires MFA and if the
+     * <code>TokenCode</code> value is missing or expired, the
+     * <code>AssumeRole</code> call returns an "access denied" error.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @return <p>
+     *         The value provided by the MFA device, if the trust policy of the
+     *         role being assumed requires MFA (that is, if the policy includes
+     *         a condition that tests for MFA). If the role being assumed
+     *         requires MFA and if the <code>TokenCode</code> value is missing
+     *         or expired, the <code>AssumeRole</code> call returns an
+     *         "access denied" error.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a sequence of six numeric digits.
+     *         </p>
+     */
+    public String getTokenCode() {
+        return tokenCode;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if the trust policy of the role
+     * being assumed requires MFA (that is, if the policy includes a condition
+     * that tests for MFA). If the role being assumed requires MFA and if the
+     * <code>TokenCode</code> value is missing or expired, the
+     * <code>AssumeRole</code> call returns an "access denied" error.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @param tokenCode <p>
+     *            The value provided by the MFA device, if the trust policy of
+     *            the role being assumed requires MFA (that is, if the policy
+     *            includes a condition that tests for MFA). If the role being
+     *            assumed requires MFA and if the <code>TokenCode</code> value
+     *            is missing or expired, the <code>AssumeRole</code> call
+     *            returns an "access denied" error.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a sequence of six numeric digits.
+     *            </p>
+     */
+    public void setTokenCode(String tokenCode) {
+        this.tokenCode = tokenCode;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if the trust policy of the role
+     * being assumed requires MFA (that is, if the policy includes a condition
+     * that tests for MFA). If the role being assumed requires MFA and if the
+     * <code>TokenCode</code> value is missing or expired, the
+     * <code>AssumeRole</code> call returns an "access denied" error.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @param tokenCode <p>
+     *            The value provided by the MFA device, if the trust policy of
+     *            the role being assumed requires MFA (that is, if the policy
+     *            includes a condition that tests for MFA). If the role being
+     *            assumed requires MFA and if the <code>TokenCode</code> value
+     *            is missing or expired, the <code>AssumeRole</code> call
+     *            returns an "access denied" error.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a sequence of six numeric digits.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleRequest withTokenCode(String tokenCode) {
+        this.tokenCode = tokenCode;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getRoleArn() != null)
+            sb.append("RoleArn: " + getRoleArn() + ",");
+        if (getRoleSessionName() != null)
+            sb.append("RoleSessionName: " + getRoleSessionName() + ",");
+        if (getPolicy() != null)
+            sb.append("Policy: " + getPolicy() + ",");
+        if (getDurationSeconds() != null)
+            sb.append("DurationSeconds: " + getDurationSeconds() + ",");
+        if (getExternalId() != null)
+            sb.append("ExternalId: " + getExternalId() + ",");
+        if (getSerialNumber() != null)
+            sb.append("SerialNumber: " + getSerialNumber() + ",");
+        if (getTokenCode() != null)
+            sb.append("TokenCode: " + getTokenCode());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getRoleArn() == null) ? 0 : getRoleArn().hashCode());
+        hashCode = prime * hashCode
+                + ((getRoleSessionName() == null) ? 0 : getRoleSessionName().hashCode());
+        hashCode = prime * hashCode + ((getPolicy() == null) ? 0 : getPolicy().hashCode());
+        hashCode = prime * hashCode
+                + ((getDurationSeconds() == null) ? 0 : getDurationSeconds().hashCode());
+        hashCode = prime * hashCode + ((getExternalId() == null) ? 0 : getExternalId().hashCode());
+        hashCode = prime * hashCode
+                + ((getSerialNumber() == null) ? 0 : getSerialNumber().hashCode());
+        hashCode = prime * hashCode + ((getTokenCode() == null) ? 0 : getTokenCode().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof AssumeRoleRequest == false)
+            return false;
+        AssumeRoleRequest other = (AssumeRoleRequest) obj;
+
+        if (other.getRoleArn() == null ^ this.getRoleArn() == null)
+            return false;
+        if (other.getRoleArn() != null && other.getRoleArn().equals(this.getRoleArn()) == false)
+            return false;
+        if (other.getRoleSessionName() == null ^ this.getRoleSessionName() == null)
+            return false;
+        if (other.getRoleSessionName() != null
+                && other.getRoleSessionName().equals(this.getRoleSessionName()) == false)
+            return false;
+        if (other.getPolicy() == null ^ this.getPolicy() == null)
+            return false;
+        if (other.getPolicy() != null && other.getPolicy().equals(this.getPolicy()) == false)
+            return false;
+        if (other.getDurationSeconds() == null ^ this.getDurationSeconds() == null)
+            return false;
+        if (other.getDurationSeconds() != null
+                && other.getDurationSeconds().equals(this.getDurationSeconds()) == false)
+            return false;
+        if (other.getExternalId() == null ^ this.getExternalId() == null)
+            return false;
+        if (other.getExternalId() != null
+                && other.getExternalId().equals(this.getExternalId()) == false)
+            return false;
+        if (other.getSerialNumber() == null ^ this.getSerialNumber() == null)
+            return false;
+        if (other.getSerialNumber() != null
+                && other.getSerialNumber().equals(this.getSerialNumber()) == false)
+            return false;
+        if (other.getTokenCode() == null ^ this.getTokenCode() == null)
+            return false;
+        if (other.getTokenCode() != null
+                && other.getTokenCode().equals(this.getTokenCode()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleResult.java
new file mode 100644
index 0000000000..9f124f5a63
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleResult.java
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Contains the response to a successful <a>AssumeRole</a> request, including
+ * temporary AWS credentials that can be used to make AWS requests.
+ * </p>
+ */
+public class AssumeRoleResult implements Serializable {
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     */
+    private Credentials credentials;
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     */
+    private AssumedRoleUser assumedRoleUser;
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     */
+    private Integer packedPolicySize;
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @return <p>
+     *         The temporary security credentials, which include an access key
+     *         ID, a secret access key, and a security (or session) token.
+     *         </p>
+     *         <p>
+     *         <b>Note:</b> The size of the security token that STS APIs return
+     *         is not fixed. We strongly recommend that you make no assumptions
+     *         about the maximum size. As of this writing, the typical size is
+     *         less than 4096 bytes, but that can vary. Also, future updates to
+     *         AWS might require larger sizes.
+     *         </p>
+     */
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     */
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleResult withCredentials(Credentials credentials) {
+        this.credentials = credentials;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     *
+     * @return <p>
+     *         The Amazon Resource Name (ARN) and the assumed role ID, which are
+     *         identifiers that you can use to refer to the resulting temporary
+     *         security credentials. For example, you can reference these
+     *         credentials as a principal in a resource-based policy by using
+     *         the ARN or assumed role ID. The ARN and ID include the
+     *         <code>RoleSessionName</code> that you specified when you called
+     *         <code>AssumeRole</code>.
+     *         </p>
+     */
+    public AssumedRoleUser getAssumedRoleUser() {
+        return assumedRoleUser;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     *
+     * @param assumedRoleUser <p>
+     *            The Amazon Resource Name (ARN) and the assumed role ID, which
+     *            are identifiers that you can use to refer to the resulting
+     *            temporary security credentials. For example, you can reference
+     *            these credentials as a principal in a resource-based policy by
+     *            using the ARN or assumed role ID. The ARN and ID include the
+     *            <code>RoleSessionName</code> that you specified when you
+     *            called <code>AssumeRole</code>.
+     *            </p>
+     */
+    public void setAssumedRoleUser(AssumedRoleUser assumedRoleUser) {
+        this.assumedRoleUser = assumedRoleUser;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param assumedRoleUser <p>
+     *            The Amazon Resource Name (ARN) and the assumed role ID, which
+     *            are identifiers that you can use to refer to the resulting
+     *            temporary security credentials. For example, you can reference
+     *            these credentials as a principal in a resource-based policy by
+     *            using the ARN or assumed role ID. The ARN and ID include the
+     *            <code>RoleSessionName</code> that you specified when you
+     *            called <code>AssumeRole</code>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleResult withAssumedRoleUser(AssumedRoleUser assumedRoleUser) {
+        this.assumedRoleUser = assumedRoleUser;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @return <p>
+     *         A percentage value that indicates the size of the policy in
+     *         packed form. The service rejects any policy with a packed size
+     *         greater than 100 percent, which means the policy exceeded the
+     *         allowed space.
+     *         </p>
+     */
+    public Integer getPackedPolicySize() {
+        return packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value that indicates the size of the policy in
+     *            packed form. The service rejects any policy with a packed size
+     *            greater than 100 percent, which means the policy exceeded the
+     *            allowed space.
+     *            </p>
+     */
+    public void setPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value that indicates the size of the policy in
+     *            packed form. The service rejects any policy with a packed size
+     *            greater than 100 percent, which means the policy exceeded the
+     *            allowed space.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleResult withPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getCredentials() != null)
+            sb.append("Credentials: " + getCredentials() + ",");
+        if (getAssumedRoleUser() != null)
+            sb.append("AssumedRoleUser: " + getAssumedRoleUser() + ",");
+        if (getPackedPolicySize() != null)
+            sb.append("PackedPolicySize: " + getPackedPolicySize());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getCredentials() == null) ? 0 : getCredentials().hashCode());
+        hashCode = prime * hashCode
+                + ((getAssumedRoleUser() == null) ? 0 : getAssumedRoleUser().hashCode());
+        hashCode = prime * hashCode
+                + ((getPackedPolicySize() == null) ? 0 : getPackedPolicySize().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof AssumeRoleResult == false)
+            return false;
+        AssumeRoleResult other = (AssumeRoleResult) obj;
+
+        if (other.getCredentials() == null ^ this.getCredentials() == null)
+            return false;
+        if (other.getCredentials() != null
+                && other.getCredentials().equals(this.getCredentials()) == false)
+            return false;
+        if (other.getAssumedRoleUser() == null ^ this.getAssumedRoleUser() == null)
+            return false;
+        if (other.getAssumedRoleUser() != null
+                && other.getAssumedRoleUser().equals(this.getAssumedRoleUser()) == false)
+            return false;
+        if (other.getPackedPolicySize() == null ^ this.getPackedPolicySize() == null)
+            return false;
+        if (other.getPackedPolicySize() != null
+                && other.getPackedPolicySize().equals(this.getPackedPolicySize()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityRequest.java
new file mode 100644
index 0000000000..adce9b2a6e
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityRequest.java
@@ -0,0 +1,1055 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns a set of temporary security credentials for users who have been
+ * authenticated in a mobile or web application with a web identity provider,
+ * such as Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID
+ * Connect-compatible identity provider.
+ * </p>
+ * <note>
+ * <p>
+ * For mobile applications, we recommend that you use Amazon Cognito. You can
+ * use Amazon Cognito with the <a href="http://aws.amazon.com/sdkforios/">AWS
+ * SDK for iOS</a> and the <a href="http://aws.amazon.com/sdkforandroid/">AWS
+ * SDK for Android</a> to uniquely identify a user and supply the user with a
+ * consistent identity throughout the lifetime of an application.
+ * </p>
+ * <p>
+ * To learn more about Amazon Cognito, see <a href=
+ * "http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-auth.html#d0e840"
+ * >Amazon Cognito Overview</a> in the <i>AWS SDK for Android Developer
+ * Guide</i> guide and <a href=
+ * "http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-auth.html#d0e664"
+ * >Amazon Cognito Overview</a> in the <i>AWS SDK for iOS Developer Guide</i>.
+ * </p>
+ * </note>
+ * <p>
+ * Calling <code>AssumeRoleWithWebIdentity</code> does not require the use of
+ * AWS security credentials. Therefore, you can distribute an application (for
+ * example, on mobile devices) that requests temporary security credentials
+ * without including long-term AWS credentials in the application, and without
+ * deploying server-based proxy services that use long-term AWS credentials.
+ * Instead, the identity of the caller is validated by using a token from the
+ * web identity provider. For a comparison of
+ * <code>AssumeRoleWithWebIdentity</code> with the other APIs that produce
+ * temporary credentials, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+ * >Requesting Temporary Security Credentials</a> and <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+ * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * The temporary security credentials returned by this API consist of an access
+ * key ID, a secret access key, and a security token. Applications can use these
+ * temporary security credentials to sign calls to AWS service APIs.
+ * </p>
+ * <p>
+ * The credentials are valid for the duration that you specified when calling
+ * <code>AssumeRoleWithWebIdentity</code>, which can be from 900 seconds (15
+ * minutes) to a maximum of 3600 seconds (1 hour). The default is 1 hour.
+ * </p>
+ * <p>
+ * The temporary security credentials created by
+ * <code>AssumeRoleWithWebIdentity</code> can be used to make API calls to any
+ * AWS service with the following exception: you cannot call the STS service's
+ * <code>GetFederationToken</code> or <code>GetSessionToken</code> APIs.
+ * </p>
+ * <p>
+ * Optionally, you can pass an IAM access policy to this operation. If you
+ * choose not to pass a policy, the temporary security credentials that are
+ * returned by the operation have the permissions that are defined in the access
+ * policy of the role that is being assumed. If you pass a policy to this
+ * operation, the temporary security credentials that are returned by the
+ * operation have the permissions that are allowed by both the access policy of
+ * the role that is being assumed, <i> <b>and</b> </i> the policy that you pass.
+ * This gives you a way to further restrict the permissions for the resulting
+ * temporary security credentials. You cannot use the passed policy to grant
+ * permissions that are in excess of those allowed by the access policy of the
+ * role that is being assumed. For more information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+ * >Permissions for AssumeRole, AssumeRoleWithSAML, and
+ * AssumeRoleWithWebIdentity</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * Before your application can call <code>AssumeRoleWithWebIdentity</code>, you
+ * must have an identity token from a supported identity provider and create a
+ * role that the application can assume. The role that your application assumes
+ * must trust the identity provider that is associated with the identity token.
+ * In other words, the identity provider must be specified in the role's trust
+ * policy.
+ * </p>
+ * <important>
+ * <p>
+ * Calling <code>AssumeRoleWithWebIdentity</code> can result in an entry in your
+ * AWS CloudTrail logs. The entry includes the <a
+ * href="http://openid.net/specs/openid-connect-core-1_0.html#Claims"
+ * >Subject</a> of the provided Web Identity Token. We recommend that you avoid
+ * using any personally identifiable information (PII) in this field. For
+ * example, you could instead use a GUID or a pairwise identifier, as <a
+ * href="http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes"
+ * >suggested in the OIDC specification</a>.
+ * </p>
+ * </important>
+ * <p>
+ * For more information about how to use web identity federation and the
+ * <code>AssumeRoleWithWebIdentity</code> API, see the following resources:
+ * </p>
+ * <ul>
+ * <li>
+ * <p>
+ * <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_manual"
+ * >Using Web Identity Federation APIs for Mobile Apps</a> and <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+ * >Federation Through a Web-based Identity Provider</a>.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * <a href=
+ * "https://web-identity-federation-playground.s3.amazonaws.com/index.html"> Web
+ * Identity Federation Playground</a>. This interactive website lets you walk
+ * through the process of authenticating via Login with Amazon, Facebook, or
+ * Google, getting temporary security credentials, and then using those
+ * credentials to make a request to AWS.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * <a href="http://aws.amazon.com/sdkforios/">AWS SDK for iOS</a> and <a
+ * href="http://aws.amazon.com/sdkforandroid/">AWS SDK for Android</a>. These
+ * toolkits contain sample apps that show how to invoke the identity providers,
+ * and then how to use the information from these providers to get and use
+ * temporary security credentials.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * <a href="http://aws.amazon.com/articles/4617974389850313">Web Identity
+ * Federation with Mobile Applications</a>. This article discusses web identity
+ * federation and shows an example of how to use web identity federation to get
+ * access to content in Amazon S3.
+ * </p>
+ * </li>
+ * </ul>
+ */
+public class AssumeRoleWithWebIdentityRequest extends AmazonWebServiceRequest implements
+        Serializable {
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role that the caller is assuming.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     */
+    private String roleArn;
+
+    /**
+     * <p>
+     * An identifier for the assumed role session. Typically, you pass the name
+     * or identifier that is associated with the user who is using your
+     * application. That way, the temporary security credentials that your
+     * application will use are associated with that user. This session name is
+     * included as part of the ARN and assumed role ID in the
+     * <code>AssumedRoleUser</code> response element.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     */
+    private String roleSessionName;
+
+    /**
+     * <p>
+     * The OAuth 2.0 access token or OpenID Connect ID token that is provided by
+     * the identity provider. Your application must get this token by
+     * authenticating the user who is using your application with a web identity
+     * provider before the application makes an
+     * <code>AssumeRoleWithWebIdentity</code> call.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     */
+    private String webIdentityToken;
+
+    /**
+     * <p>
+     * The fully qualified host component of the domain name of the identity
+     * provider.
+     * </p>
+     * <p>
+     * Specify this value only for OAuth 2.0 access tokens. Currently
+     * <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the
+     * only supported identity providers for OAuth 2.0 access tokens. Do not
+     * include URL schemes and port numbers.
+     * </p>
+     * <p>
+     * Do not specify this value for OpenID Connect ID tokens.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     */
+    private String providerId;
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * The policy parameter is optional. If you pass a policy, the temporary
+     * security credentials that are returned by the operation have the
+     * permissions that are allowed by both the access policy of the role that
+     * is being assumed, <i> <b>and</b> </i> the policy that you pass. This
+     * gives you a way to further restrict the permissions for the resulting
+     * temporary security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     */
+    private String policy;
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     */
+    private Integer durationSeconds;
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role that the caller is assuming.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @return <p>
+     *         The Amazon Resource Name (ARN) of the role that the caller is
+     *         assuming.
+     *         </p>
+     */
+    public String getRoleArn() {
+        return roleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role that the caller is assuming.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param roleArn <p>
+     *            The Amazon Resource Name (ARN) of the role that the caller is
+     *            assuming.
+     *            </p>
+     */
+    public void setRoleArn(String roleArn) {
+        this.roleArn = roleArn;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) of the role that the caller is assuming.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param roleArn <p>
+     *            The Amazon Resource Name (ARN) of the role that the caller is
+     *            assuming.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withRoleArn(String roleArn) {
+        this.roleArn = roleArn;
+        return this;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session. Typically, you pass the name
+     * or identifier that is associated with the user who is using your
+     * application. That way, the temporary security credentials that your
+     * application will use are associated with that user. This session name is
+     * included as part of the ARN and assumed role ID in the
+     * <code>AssumedRoleUser</code> response element.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @return <p>
+     *         An identifier for the assumed role session. Typically, you pass
+     *         the name or identifier that is associated with the user who is
+     *         using your application. That way, the temporary security
+     *         credentials that your application will use are associated with
+     *         that user. This session name is included as part of the ARN and
+     *         assumed role ID in the <code>AssumedRoleUser</code> response
+     *         element.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@-
+     *         </p>
+     */
+    public String getRoleSessionName() {
+        return roleSessionName;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session. Typically, you pass the name
+     * or identifier that is associated with the user who is using your
+     * application. That way, the temporary security credentials that your
+     * application will use are associated with that user. This session name is
+     * included as part of the ARN and assumed role ID in the
+     * <code>AssumedRoleUser</code> response element.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param roleSessionName <p>
+     *            An identifier for the assumed role session. Typically, you
+     *            pass the name or identifier that is associated with the user
+     *            who is using your application. That way, the temporary
+     *            security credentials that your application will use are
+     *            associated with that user. This session name is included as
+     *            part of the ARN and assumed role ID in the
+     *            <code>AssumedRoleUser</code> response element.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public void setRoleSessionName(String roleSessionName) {
+        this.roleSessionName = roleSessionName;
+    }
+
+    /**
+     * <p>
+     * An identifier for the assumed role session. Typically, you pass the name
+     * or identifier that is associated with the user who is using your
+     * application. That way, the temporary security credentials that your
+     * application will use are associated with that user. This session name is
+     * included as part of the ARN and assumed role ID in the
+     * <code>AssumedRoleUser</code> response element.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 64<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param roleSessionName <p>
+     *            An identifier for the assumed role session. Typically, you
+     *            pass the name or identifier that is associated with the user
+     *            who is using your application. That way, the temporary
+     *            security credentials that your application will use are
+     *            associated with that user. This session name is included as
+     *            part of the ARN and assumed role ID in the
+     *            <code>AssumedRoleUser</code> response element.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withRoleSessionName(String roleSessionName) {
+        this.roleSessionName = roleSessionName;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The OAuth 2.0 access token or OpenID Connect ID token that is provided by
+     * the identity provider. Your application must get this token by
+     * authenticating the user who is using your application with a web identity
+     * provider before the application makes an
+     * <code>AssumeRoleWithWebIdentity</code> call.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @return <p>
+     *         The OAuth 2.0 access token or OpenID Connect ID token that is
+     *         provided by the identity provider. Your application must get this
+     *         token by authenticating the user who is using your application
+     *         with a web identity provider before the application makes an
+     *         <code>AssumeRoleWithWebIdentity</code> call.
+     *         </p>
+     */
+    public String getWebIdentityToken() {
+        return webIdentityToken;
+    }
+
+    /**
+     * <p>
+     * The OAuth 2.0 access token or OpenID Connect ID token that is provided by
+     * the identity provider. Your application must get this token by
+     * authenticating the user who is using your application with a web identity
+     * provider before the application makes an
+     * <code>AssumeRoleWithWebIdentity</code> call.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @param webIdentityToken <p>
+     *            The OAuth 2.0 access token or OpenID Connect ID token that is
+     *            provided by the identity provider. Your application must get
+     *            this token by authenticating the user who is using your
+     *            application with a web identity provider before the
+     *            application makes an <code>AssumeRoleWithWebIdentity</code>
+     *            call.
+     *            </p>
+     */
+    public void setWebIdentityToken(String webIdentityToken) {
+        this.webIdentityToken = webIdentityToken;
+    }
+
+    /**
+     * <p>
+     * The OAuth 2.0 access token or OpenID Connect ID token that is provided by
+     * the identity provider. Your application must get this token by
+     * authenticating the user who is using your application with a web identity
+     * provider before the application makes an
+     * <code>AssumeRoleWithWebIdentity</code> call.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @param webIdentityToken <p>
+     *            The OAuth 2.0 access token or OpenID Connect ID token that is
+     *            provided by the identity provider. Your application must get
+     *            this token by authenticating the user who is using your
+     *            application with a web identity provider before the
+     *            application makes an <code>AssumeRoleWithWebIdentity</code>
+     *            call.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withWebIdentityToken(String webIdentityToken) {
+        this.webIdentityToken = webIdentityToken;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The fully qualified host component of the domain name of the identity
+     * provider.
+     * </p>
+     * <p>
+     * Specify this value only for OAuth 2.0 access tokens. Currently
+     * <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the
+     * only supported identity providers for OAuth 2.0 access tokens. Do not
+     * include URL schemes and port numbers.
+     * </p>
+     * <p>
+     * Do not specify this value for OpenID Connect ID tokens.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @return <p>
+     *         The fully qualified host component of the domain name of the
+     *         identity provider.
+     *         </p>
+     *         <p>
+     *         Specify this value only for OAuth 2.0 access tokens. Currently
+     *         <code>www.amazon.com</code> and <code>graph.facebook.com</code>
+     *         are the only supported identity providers for OAuth 2.0 access
+     *         tokens. Do not include URL schemes and port numbers.
+     *         </p>
+     *         <p>
+     *         Do not specify this value for OpenID Connect ID tokens.
+     *         </p>
+     */
+    public String getProviderId() {
+        return providerId;
+    }
+
+    /**
+     * <p>
+     * The fully qualified host component of the domain name of the identity
+     * provider.
+     * </p>
+     * <p>
+     * Specify this value only for OAuth 2.0 access tokens. Currently
+     * <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the
+     * only supported identity providers for OAuth 2.0 access tokens. Do not
+     * include URL schemes and port numbers.
+     * </p>
+     * <p>
+     * Do not specify this value for OpenID Connect ID tokens.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @param providerId <p>
+     *            The fully qualified host component of the domain name of the
+     *            identity provider.
+     *            </p>
+     *            <p>
+     *            Specify this value only for OAuth 2.0 access tokens. Currently
+     *            <code>www.amazon.com</code> and
+     *            <code>graph.facebook.com</code> are the only supported
+     *            identity providers for OAuth 2.0 access tokens. Do not include
+     *            URL schemes and port numbers.
+     *            </p>
+     *            <p>
+     *            Do not specify this value for OpenID Connect ID tokens.
+     *            </p>
+     */
+    public void setProviderId(String providerId) {
+        this.providerId = providerId;
+    }
+
+    /**
+     * <p>
+     * The fully qualified host component of the domain name of the identity
+     * provider.
+     * </p>
+     * <p>
+     * Specify this value only for OAuth 2.0 access tokens. Currently
+     * <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the
+     * only supported identity providers for OAuth 2.0 access tokens. Do not
+     * include URL schemes and port numbers.
+     * </p>
+     * <p>
+     * Do not specify this value for OpenID Connect ID tokens.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>4 - 2048<br/>
+     *
+     * @param providerId <p>
+     *            The fully qualified host component of the domain name of the
+     *            identity provider.
+     *            </p>
+     *            <p>
+     *            Specify this value only for OAuth 2.0 access tokens. Currently
+     *            <code>www.amazon.com</code> and
+     *            <code>graph.facebook.com</code> are the only supported
+     *            identity providers for OAuth 2.0 access tokens. Do not include
+     *            URL schemes and port numbers.
+     *            </p>
+     *            <p>
+     *            Do not specify this value for OpenID Connect ID tokens.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withProviderId(String providerId) {
+        this.providerId = providerId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * The policy parameter is optional. If you pass a policy, the temporary
+     * security credentials that are returned by the operation have the
+     * permissions that are allowed by both the access policy of the role that
+     * is being assumed, <i> <b>and</b> </i> the policy that you pass. This
+     * gives you a way to further restrict the permissions for the resulting
+     * temporary security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @return <p>
+     *         An IAM policy in JSON format.
+     *         </p>
+     *         <p>
+     *         The policy parameter is optional. If you pass a policy, the
+     *         temporary security credentials that are returned by the operation
+     *         have the permissions that are allowed by both the access policy
+     *         of the role that is being assumed, <i> <b>and</b> </i> the policy
+     *         that you pass. This gives you a way to further restrict the
+     *         permissions for the resulting temporary security credentials. You
+     *         cannot use the passed policy to grant permissions that are in
+     *         excess of those allowed by the access policy of the role that is
+     *         being assumed. For more information, see <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *         >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM User
+     *         Guide</i>.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters up to 2048 characters in length. The
+     *         characters can be any ASCII character from the space character to
+     *         the end of the valid character list ( -\u00FF). It can also
+     *         include the tab ( ), linefeed ( ), and carriage return ( )
+     *         characters.
+     *         </p>
+     *         <note>
+     *         <p>
+     *         The policy plain text must be 2048 bytes or shorter. However, an
+     *         internal conversion compresses it into a packed binary format
+     *         with a separate limit. The PackedPolicySize response element
+     *         indicates by percentage how close to the upper size limit the
+     *         policy is, with 100% equaling the maximum allowed size.
+     *         </p>
+     *         </note>
+     */
+    public String getPolicy() {
+        return policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * The policy parameter is optional. If you pass a policy, the temporary
+     * security credentials that are returned by the operation have the
+     * permissions that are allowed by both the access policy of the role that
+     * is being assumed, <i> <b>and</b> </i> the policy that you pass. This
+     * gives you a way to further restrict the permissions for the resulting
+     * temporary security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format.
+     *            </p>
+     *            <p>
+     *            The policy parameter is optional. If you pass a policy, the
+     *            temporary security credentials that are returned by the
+     *            operation have the permissions that are allowed by both the
+     *            access policy of the role that is being assumed, <i>
+     *            <b>and</b> </i> the policy that you pass. This gives you a way
+     *            to further restrict the permissions for the resulting
+     *            temporary security credentials. You cannot use the passed
+     *            policy to grant permissions that are in excess of those
+     *            allowed by the access policy of the role that is being
+     *            assumed. For more information, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *            >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM
+     *            User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     */
+    public void setPolicy(String policy) {
+        this.policy = policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format.
+     * </p>
+     * <p>
+     * The policy parameter is optional. If you pass a policy, the temporary
+     * security credentials that are returned by the operation have the
+     * permissions that are allowed by both the access policy of the role that
+     * is being assumed, <i> <b>and</b> </i> the policy that you pass. This
+     * gives you a way to further restrict the permissions for the resulting
+     * temporary security credentials. You cannot use the passed policy to grant
+     * permissions that are in excess of those allowed by the access policy of
+     * the role that is being assumed. For more information, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     * >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM User
+     * Guide</i>.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format.
+     *            </p>
+     *            <p>
+     *            The policy parameter is optional. If you pass a policy, the
+     *            temporary security credentials that are returned by the
+     *            operation have the permissions that are allowed by both the
+     *            access policy of the role that is being assumed, <i>
+     *            <b>and</b> </i> the policy that you pass. This gives you a way
+     *            to further restrict the permissions for the resulting
+     *            temporary security credentials. You cannot use the passed
+     *            policy to grant permissions that are in excess of those
+     *            allowed by the access policy of the role that is being
+     *            assumed. For more information, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_assumerole.html"
+     *            >Permissions for AssumeRoleWithWebIdentity</a> in the <i>IAM
+     *            User Guide</i>.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withPolicy(String policy) {
+        this.policy = policy;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @return <p>
+     *         The duration, in seconds, of the role session. The value can
+     *         range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By
+     *         default, the value is set to 3600 seconds.
+     *         </p>
+     */
+    public Integer getDurationSeconds() {
+        return durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, of the role session. The value can
+     *            range from 900 seconds (15 minutes) to 3600 seconds (1 hour).
+     *            By default, the value is set to 3600 seconds.
+     *            </p>
+     */
+    public void setDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, of the role session. The value can range from
+     * 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value
+     * is set to 3600 seconds.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 3600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, of the role session. The value can
+     *            range from 900 seconds (15 minutes) to 3600 seconds (1 hour).
+     *            By default, the value is set to 3600 seconds.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityRequest withDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getRoleArn() != null)
+            sb.append("RoleArn: " + getRoleArn() + ",");
+        if (getRoleSessionName() != null)
+            sb.append("RoleSessionName: " + getRoleSessionName() + ",");
+        if (getWebIdentityToken() != null)
+            sb.append("WebIdentityToken: " + getWebIdentityToken() + ",");
+        if (getProviderId() != null)
+            sb.append("ProviderId: " + getProviderId() + ",");
+        if (getPolicy() != null)
+            sb.append("Policy: " + getPolicy() + ",");
+        if (getDurationSeconds() != null)
+            sb.append("DurationSeconds: " + getDurationSeconds());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getRoleArn() == null) ? 0 : getRoleArn().hashCode());
+        hashCode = prime * hashCode
+                + ((getRoleSessionName() == null) ? 0 : getRoleSessionName().hashCode());
+        hashCode = prime * hashCode
+                + ((getWebIdentityToken() == null) ? 0 : getWebIdentityToken().hashCode());
+        hashCode = prime * hashCode + ((getProviderId() == null) ? 0 : getProviderId().hashCode());
+        hashCode = prime * hashCode + ((getPolicy() == null) ? 0 : getPolicy().hashCode());
+        hashCode = prime * hashCode
+                + ((getDurationSeconds() == null) ? 0 : getDurationSeconds().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof AssumeRoleWithWebIdentityRequest == false)
+            return false;
+        AssumeRoleWithWebIdentityRequest other = (AssumeRoleWithWebIdentityRequest) obj;
+
+        if (other.getRoleArn() == null ^ this.getRoleArn() == null)
+            return false;
+        if (other.getRoleArn() != null && other.getRoleArn().equals(this.getRoleArn()) == false)
+            return false;
+        if (other.getRoleSessionName() == null ^ this.getRoleSessionName() == null)
+            return false;
+        if (other.getRoleSessionName() != null
+                && other.getRoleSessionName().equals(this.getRoleSessionName()) == false)
+            return false;
+        if (other.getWebIdentityToken() == null ^ this.getWebIdentityToken() == null)
+            return false;
+        if (other.getWebIdentityToken() != null
+                && other.getWebIdentityToken().equals(this.getWebIdentityToken()) == false)
+            return false;
+        if (other.getProviderId() == null ^ this.getProviderId() == null)
+            return false;
+        if (other.getProviderId() != null
+                && other.getProviderId().equals(this.getProviderId()) == false)
+            return false;
+        if (other.getPolicy() == null ^ this.getPolicy() == null)
+            return false;
+        if (other.getPolicy() != null && other.getPolicy().equals(this.getPolicy()) == false)
+            return false;
+        if (other.getDurationSeconds() == null ^ this.getDurationSeconds() == null)
+            return false;
+        if (other.getDurationSeconds() != null
+                && other.getDurationSeconds().equals(this.getDurationSeconds()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityResult.java
new file mode 100644
index 0000000000..d2d57ba9f2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumeRoleWithWebIdentityResult.java
@@ -0,0 +1,660 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Contains the response to a successful <a>AssumeRoleWithWebIdentity</a>
+ * request, including temporary AWS credentials that can be used to make AWS
+ * requests.
+ * </p>
+ */
+public class AssumeRoleWithWebIdentityResult implements Serializable {
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     */
+    private Credentials credentials;
+
+    /**
+     * <p>
+     * The unique user identifier that is returned by the identity provider.
+     * This identifier is associated with the <code>WebIdentityToken</code> that
+     * was submitted with the <code>AssumeRoleWithWebIdentity</code> call. The
+     * identifier is typically unique to the user and the application that
+     * acquired the <code>WebIdentityToken</code> (pairwise identifier). For
+     * OpenID Connect ID tokens, this field contains the value returned by the
+     * identity provider as the token's <code>sub</code> (Subject) claim.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 255<br/>
+     */
+    private String subjectFromWebIdentityToken;
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     */
+    private AssumedRoleUser assumedRoleUser;
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     */
+    private Integer packedPolicySize;
+
+    /**
+     * <p>
+     * The issuing authority of the web identity token presented. For OpenID
+     * Connect ID Tokens this contains the value of the <code>iss</code> field.
+     * For OAuth 2.0 access tokens, this contains the value of the
+     * <code>ProviderId</code> parameter that was passed in the
+     * <code>AssumeRoleWithWebIdentity</code> request.
+     * </p>
+     */
+    private String provider;
+
+    /**
+     * <p>
+     * The intended audience (also known as client ID) of the web identity
+     * token. This is traditionally the client identifier issued to the
+     * application that requested the web identity token.
+     * </p>
+     */
+    private String audience;
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @return <p>
+     *         The temporary security credentials, which include an access key
+     *         ID, a secret access key, and a security token.
+     *         </p>
+     *         <p>
+     *         <b>Note:</b> The size of the security token that STS APIs return
+     *         is not fixed. We strongly recommend that you make no assumptions
+     *         about the maximum size. As of this writing, the typical size is
+     *         less than 4096 bytes, but that can vary. Also, future updates to
+     *         AWS might require larger sizes.
+     *         </p>
+     */
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     */
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withCredentials(Credentials credentials) {
+        this.credentials = credentials;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The unique user identifier that is returned by the identity provider.
+     * This identifier is associated with the <code>WebIdentityToken</code> that
+     * was submitted with the <code>AssumeRoleWithWebIdentity</code> call. The
+     * identifier is typically unique to the user and the application that
+     * acquired the <code>WebIdentityToken</code> (pairwise identifier). For
+     * OpenID Connect ID tokens, this field contains the value returned by the
+     * identity provider as the token's <code>sub</code> (Subject) claim.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 255<br/>
+     *
+     * @return <p>
+     *         The unique user identifier that is returned by the identity
+     *         provider. This identifier is associated with the
+     *         <code>WebIdentityToken</code> that was submitted with the
+     *         <code>AssumeRoleWithWebIdentity</code> call. The identifier is
+     *         typically unique to the user and the application that acquired
+     *         the <code>WebIdentityToken</code> (pairwise identifier). For
+     *         OpenID Connect ID tokens, this field contains the value returned
+     *         by the identity provider as the token's <code>sub</code>
+     *         (Subject) claim.
+     *         </p>
+     */
+    public String getSubjectFromWebIdentityToken() {
+        return subjectFromWebIdentityToken;
+    }
+
+    /**
+     * <p>
+     * The unique user identifier that is returned by the identity provider.
+     * This identifier is associated with the <code>WebIdentityToken</code> that
+     * was submitted with the <code>AssumeRoleWithWebIdentity</code> call. The
+     * identifier is typically unique to the user and the application that
+     * acquired the <code>WebIdentityToken</code> (pairwise identifier). For
+     * OpenID Connect ID tokens, this field contains the value returned by the
+     * identity provider as the token's <code>sub</code> (Subject) claim.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 255<br/>
+     *
+     * @param subjectFromWebIdentityToken <p>
+     *            The unique user identifier that is returned by the identity
+     *            provider. This identifier is associated with the
+     *            <code>WebIdentityToken</code> that was submitted with the
+     *            <code>AssumeRoleWithWebIdentity</code> call. The identifier is
+     *            typically unique to the user and the application that acquired
+     *            the <code>WebIdentityToken</code> (pairwise identifier). For
+     *            OpenID Connect ID tokens, this field contains the value
+     *            returned by the identity provider as the token's
+     *            <code>sub</code> (Subject) claim.
+     *            </p>
+     */
+    public void setSubjectFromWebIdentityToken(String subjectFromWebIdentityToken) {
+        this.subjectFromWebIdentityToken = subjectFromWebIdentityToken;
+    }
+
+    /**
+     * <p>
+     * The unique user identifier that is returned by the identity provider.
+     * This identifier is associated with the <code>WebIdentityToken</code> that
+     * was submitted with the <code>AssumeRoleWithWebIdentity</code> call. The
+     * identifier is typically unique to the user and the application that
+     * acquired the <code>WebIdentityToken</code> (pairwise identifier). For
+     * OpenID Connect ID tokens, this field contains the value returned by the
+     * identity provider as the token's <code>sub</code> (Subject) claim.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 255<br/>
+     *
+     * @param subjectFromWebIdentityToken <p>
+     *            The unique user identifier that is returned by the identity
+     *            provider. This identifier is associated with the
+     *            <code>WebIdentityToken</code> that was submitted with the
+     *            <code>AssumeRoleWithWebIdentity</code> call. The identifier is
+     *            typically unique to the user and the application that acquired
+     *            the <code>WebIdentityToken</code> (pairwise identifier). For
+     *            OpenID Connect ID tokens, this field contains the value
+     *            returned by the identity provider as the token's
+     *            <code>sub</code> (Subject) claim.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withSubjectFromWebIdentityToken(
+            String subjectFromWebIdentityToken) {
+        this.subjectFromWebIdentityToken = subjectFromWebIdentityToken;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     *
+     * @return <p>
+     *         The Amazon Resource Name (ARN) and the assumed role ID, which are
+     *         identifiers that you can use to refer to the resulting temporary
+     *         security credentials. For example, you can reference these
+     *         credentials as a principal in a resource-based policy by using
+     *         the ARN or assumed role ID. The ARN and ID include the
+     *         <code>RoleSessionName</code> that you specified when you called
+     *         <code>AssumeRole</code>.
+     *         </p>
+     */
+    public AssumedRoleUser getAssumedRoleUser() {
+        return assumedRoleUser;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     *
+     * @param assumedRoleUser <p>
+     *            The Amazon Resource Name (ARN) and the assumed role ID, which
+     *            are identifiers that you can use to refer to the resulting
+     *            temporary security credentials. For example, you can reference
+     *            these credentials as a principal in a resource-based policy by
+     *            using the ARN or assumed role ID. The ARN and ID include the
+     *            <code>RoleSessionName</code> that you specified when you
+     *            called <code>AssumeRole</code>.
+     *            </p>
+     */
+    public void setAssumedRoleUser(AssumedRoleUser assumedRoleUser) {
+        this.assumedRoleUser = assumedRoleUser;
+    }
+
+    /**
+     * <p>
+     * The Amazon Resource Name (ARN) and the assumed role ID, which are
+     * identifiers that you can use to refer to the resulting temporary security
+     * credentials. For example, you can reference these credentials as a
+     * principal in a resource-based policy by using the ARN or assumed role ID.
+     * The ARN and ID include the <code>RoleSessionName</code> that you
+     * specified when you called <code>AssumeRole</code>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param assumedRoleUser <p>
+     *            The Amazon Resource Name (ARN) and the assumed role ID, which
+     *            are identifiers that you can use to refer to the resulting
+     *            temporary security credentials. For example, you can reference
+     *            these credentials as a principal in a resource-based policy by
+     *            using the ARN or assumed role ID. The ARN and ID include the
+     *            <code>RoleSessionName</code> that you specified when you
+     *            called <code>AssumeRole</code>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withAssumedRoleUser(AssumedRoleUser assumedRoleUser) {
+        this.assumedRoleUser = assumedRoleUser;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @return <p>
+     *         A percentage value that indicates the size of the policy in
+     *         packed form. The service rejects any policy with a packed size
+     *         greater than 100 percent, which means the policy exceeded the
+     *         allowed space.
+     *         </p>
+     */
+    public Integer getPackedPolicySize() {
+        return packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value that indicates the size of the policy in
+     *            packed form. The service rejects any policy with a packed size
+     *            greater than 100 percent, which means the policy exceeded the
+     *            allowed space.
+     *            </p>
+     */
+    public void setPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value that indicates the size of the policy in packed form.
+     * The service rejects any policy with a packed size greater than 100
+     * percent, which means the policy exceeded the allowed space.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value that indicates the size of the policy in
+     *            packed form. The service rejects any policy with a packed size
+     *            greater than 100 percent, which means the policy exceeded the
+     *            allowed space.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The issuing authority of the web identity token presented. For OpenID
+     * Connect ID Tokens this contains the value of the <code>iss</code> field.
+     * For OAuth 2.0 access tokens, this contains the value of the
+     * <code>ProviderId</code> parameter that was passed in the
+     * <code>AssumeRoleWithWebIdentity</code> request.
+     * </p>
+     *
+     * @return <p>
+     *         The issuing authority of the web identity token presented. For
+     *         OpenID Connect ID Tokens this contains the value of the
+     *         <code>iss</code> field. For OAuth 2.0 access tokens, this
+     *         contains the value of the <code>ProviderId</code> parameter that
+     *         was passed in the <code>AssumeRoleWithWebIdentity</code> request.
+     *         </p>
+     */
+    public String getProvider() {
+        return provider;
+    }
+
+    /**
+     * <p>
+     * The issuing authority of the web identity token presented. For OpenID
+     * Connect ID Tokens this contains the value of the <code>iss</code> field.
+     * For OAuth 2.0 access tokens, this contains the value of the
+     * <code>ProviderId</code> parameter that was passed in the
+     * <code>AssumeRoleWithWebIdentity</code> request.
+     * </p>
+     *
+     * @param provider <p>
+     *            The issuing authority of the web identity token presented. For
+     *            OpenID Connect ID Tokens this contains the value of the
+     *            <code>iss</code> field. For OAuth 2.0 access tokens, this
+     *            contains the value of the <code>ProviderId</code> parameter
+     *            that was passed in the <code>AssumeRoleWithWebIdentity</code>
+     *            request.
+     *            </p>
+     */
+    public void setProvider(String provider) {
+        this.provider = provider;
+    }
+
+    /**
+     * <p>
+     * The issuing authority of the web identity token presented. For OpenID
+     * Connect ID Tokens this contains the value of the <code>iss</code> field.
+     * For OAuth 2.0 access tokens, this contains the value of the
+     * <code>ProviderId</code> parameter that was passed in the
+     * <code>AssumeRoleWithWebIdentity</code> request.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param provider <p>
+     *            The issuing authority of the web identity token presented. For
+     *            OpenID Connect ID Tokens this contains the value of the
+     *            <code>iss</code> field. For OAuth 2.0 access tokens, this
+     *            contains the value of the <code>ProviderId</code> parameter
+     *            that was passed in the <code>AssumeRoleWithWebIdentity</code>
+     *            request.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withProvider(String provider) {
+        this.provider = provider;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The intended audience (also known as client ID) of the web identity
+     * token. This is traditionally the client identifier issued to the
+     * application that requested the web identity token.
+     * </p>
+     *
+     * @return <p>
+     *         The intended audience (also known as client ID) of the web
+     *         identity token. This is traditionally the client identifier
+     *         issued to the application that requested the web identity token.
+     *         </p>
+     */
+    public String getAudience() {
+        return audience;
+    }
+
+    /**
+     * <p>
+     * The intended audience (also known as client ID) of the web identity
+     * token. This is traditionally the client identifier issued to the
+     * application that requested the web identity token.
+     * </p>
+     *
+     * @param audience <p>
+     *            The intended audience (also known as client ID) of the web
+     *            identity token. This is traditionally the client identifier
+     *            issued to the application that requested the web identity
+     *            token.
+     *            </p>
+     */
+    public void setAudience(String audience) {
+        this.audience = audience;
+    }
+
+    /**
+     * <p>
+     * The intended audience (also known as client ID) of the web identity
+     * token. This is traditionally the client identifier issued to the
+     * application that requested the web identity token.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param audience <p>
+     *            The intended audience (also known as client ID) of the web
+     *            identity token. This is traditionally the client identifier
+     *            issued to the application that requested the web identity
+     *            token.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumeRoleWithWebIdentityResult withAudience(String audience) {
+        this.audience = audience;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getCredentials() != null)
+            sb.append("Credentials: " + getCredentials() + ",");
+        if (getSubjectFromWebIdentityToken() != null)
+            sb.append("SubjectFromWebIdentityToken: " + getSubjectFromWebIdentityToken() + ",");
+        if (getAssumedRoleUser() != null)
+            sb.append("AssumedRoleUser: " + getAssumedRoleUser() + ",");
+        if (getPackedPolicySize() != null)
+            sb.append("PackedPolicySize: " + getPackedPolicySize() + ",");
+        if (getProvider() != null)
+            sb.append("Provider: " + getProvider() + ",");
+        if (getAudience() != null)
+            sb.append("Audience: " + getAudience());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getCredentials() == null) ? 0 : getCredentials().hashCode());
+        hashCode = prime
+                * hashCode
+                + ((getSubjectFromWebIdentityToken() == null) ? 0
+                        : getSubjectFromWebIdentityToken().hashCode());
+        hashCode = prime * hashCode
+                + ((getAssumedRoleUser() == null) ? 0 : getAssumedRoleUser().hashCode());
+        hashCode = prime * hashCode
+                + ((getPackedPolicySize() == null) ? 0 : getPackedPolicySize().hashCode());
+        hashCode = prime * hashCode + ((getProvider() == null) ? 0 : getProvider().hashCode());
+        hashCode = prime * hashCode + ((getAudience() == null) ? 0 : getAudience().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof AssumeRoleWithWebIdentityResult == false)
+            return false;
+        AssumeRoleWithWebIdentityResult other = (AssumeRoleWithWebIdentityResult) obj;
+
+        if (other.getCredentials() == null ^ this.getCredentials() == null)
+            return false;
+        if (other.getCredentials() != null
+                && other.getCredentials().equals(this.getCredentials()) == false)
+            return false;
+        if (other.getSubjectFromWebIdentityToken() == null
+                ^ this.getSubjectFromWebIdentityToken() == null)
+            return false;
+        if (other.getSubjectFromWebIdentityToken() != null
+                && other.getSubjectFromWebIdentityToken().equals(
+                        this.getSubjectFromWebIdentityToken()) == false)
+            return false;
+        if (other.getAssumedRoleUser() == null ^ this.getAssumedRoleUser() == null)
+            return false;
+        if (other.getAssumedRoleUser() != null
+                && other.getAssumedRoleUser().equals(this.getAssumedRoleUser()) == false)
+            return false;
+        if (other.getPackedPolicySize() == null ^ this.getPackedPolicySize() == null)
+            return false;
+        if (other.getPackedPolicySize() != null
+                && other.getPackedPolicySize().equals(this.getPackedPolicySize()) == false)
+            return false;
+        if (other.getProvider() == null ^ this.getProvider() == null)
+            return false;
+        if (other.getProvider() != null && other.getProvider().equals(this.getProvider()) == false)
+            return false;
+        if (other.getAudience() == null ^ this.getAudience() == null)
+            return false;
+        if (other.getAudience() != null && other.getAudience().equals(this.getAudience()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumedRoleUser.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumedRoleUser.java
new file mode 100644
index 0000000000..25211e9248
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/AssumedRoleUser.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * The identifiers for the temporary security credentials that the operation
+ * returns.
+ * </p>
+ */
+public class AssumedRoleUser implements Serializable {
+    /**
+     * <p>
+     * A unique identifier that contains the role ID and the role session name
+     * of the role that is being assumed. The role ID is generated by AWS when
+     * the role is created.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@:-]*<br/>
+     */
+    private String assumedRoleId;
+
+    /**
+     * <p>
+     * The ARN of the temporary security credentials that are returned from the
+     * <a>AssumeRole</a> action. For more information about ARNs and how to use
+     * them in policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     */
+    private String arn;
+
+    /**
+     * <p>
+     * A unique identifier that contains the role ID and the role session name
+     * of the role that is being assumed. The role ID is generated by AWS when
+     * the role is created.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@:-]*<br/>
+     *
+     * @return <p>
+     *         A unique identifier that contains the role ID and the role
+     *         session name of the role that is being assumed. The role ID is
+     *         generated by AWS when the role is created.
+     *         </p>
+     */
+    public String getAssumedRoleId() {
+        return assumedRoleId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier that contains the role ID and the role session name
+     * of the role that is being assumed. The role ID is generated by AWS when
+     * the role is created.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@:-]*<br/>
+     *
+     * @param assumedRoleId <p>
+     *            A unique identifier that contains the role ID and the role
+     *            session name of the role that is being assumed. The role ID is
+     *            generated by AWS when the role is created.
+     *            </p>
+     */
+    public void setAssumedRoleId(String assumedRoleId) {
+        this.assumedRoleId = assumedRoleId;
+    }
+
+    /**
+     * <p>
+     * A unique identifier that contains the role ID and the role session name
+     * of the role that is being assumed. The role ID is generated by AWS when
+     * the role is created.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@:-]*<br/>
+     *
+     * @param assumedRoleId <p>
+     *            A unique identifier that contains the role ID and the role
+     *            session name of the role that is being assumed. The role ID is
+     *            generated by AWS when the role is created.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumedRoleUser withAssumedRoleId(String assumedRoleId) {
+        this.assumedRoleId = assumedRoleId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The ARN of the temporary security credentials that are returned from the
+     * <a>AssumeRole</a> action. For more information about ARNs and how to use
+     * them in policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @return <p>
+     *         The ARN of the temporary security credentials that are returned
+     *         from the <a>AssumeRole</a> action. For more information about
+     *         ARNs and how to use them in policies, see <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *         >IAM Identifiers</a> in <i>Using IAM</i>.
+     *         </p>
+     */
+    public String getArn() {
+        return arn;
+    }
+
+    /**
+     * <p>
+     * The ARN of the temporary security credentials that are returned from the
+     * <a>AssumeRole</a> action. For more information about ARNs and how to use
+     * them in policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The ARN of the temporary security credentials that are
+     *            returned from the <a>AssumeRole</a> action. For more
+     *            information about ARNs and how to use them in policies, see <a
+     *            href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *            >IAM Identifiers</a> in <i>Using IAM</i>.
+     *            </p>
+     */
+    public void setArn(String arn) {
+        this.arn = arn;
+    }
+
+    /**
+     * <p>
+     * The ARN of the temporary security credentials that are returned from the
+     * <a>AssumeRole</a> action. For more information about ARNs and how to use
+     * them in policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The ARN of the temporary security credentials that are
+     *            returned from the <a>AssumeRole</a> action. For more
+     *            information about ARNs and how to use them in policies, see <a
+     *            href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *            >IAM Identifiers</a> in <i>Using IAM</i>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public AssumedRoleUser withArn(String arn) {
+        this.arn = arn;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getAssumedRoleId() != null)
+            sb.append("AssumedRoleId: " + getAssumedRoleId() + ",");
+        if (getArn() != null)
+            sb.append("Arn: " + getArn());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getAssumedRoleId() == null) ? 0 : getAssumedRoleId().hashCode());
+        hashCode = prime * hashCode + ((getArn() == null) ? 0 : getArn().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof AssumedRoleUser == false)
+            return false;
+        AssumedRoleUser other = (AssumedRoleUser) obj;
+
+        if (other.getAssumedRoleId() == null ^ this.getAssumedRoleId() == null)
+            return false;
+        if (other.getAssumedRoleId() != null
+                && other.getAssumedRoleId().equals(this.getAssumedRoleId()) == false)
+            return false;
+        if (other.getArn() == null ^ this.getArn() == null)
+            return false;
+        if (other.getArn() != null && other.getArn().equals(this.getArn()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/Credentials.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/Credentials.java
new file mode 100644
index 0000000000..328f4484ca
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/Credentials.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * AWS credentials for API authentication.
+ * </p>
+ */
+public class Credentials implements Serializable {
+    /**
+     * <p>
+     * The access key ID that identifies the temporary security credentials.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>16 - 32<br/>
+     * <b>Pattern: </b>[\w]*<br/>
+     */
+    private String accessKeyId;
+
+    /**
+     * <p>
+     * The secret access key that can be used to sign requests.
+     * </p>
+     */
+    private String secretAccessKey;
+
+    /**
+     * <p>
+     * The token that users must pass to the service API to use the temporary
+     * credentials.
+     * </p>
+     */
+    private String sessionToken;
+
+    /**
+     * <p>
+     * The date on which the current credentials expire.
+     * </p>
+     */
+    private java.util.Date expiration;
+
+    /**
+     * Default constructor for Credentials object. Callers should use the setter
+     * or fluent setter (with...) methods to initialize any additional object
+     * members.
+     */
+    public Credentials() {
+    }
+
+    /**
+     * Constructs a new Credentials object. Callers should use the setter or
+     * fluent setter (with...) methods to initialize any additional object
+     * members.
+     * 
+     * @param accessKeyId <p>
+     *            The access key ID that identifies the temporary security
+     *            credentials.
+     *            </p>
+     * @param secretAccessKey <p>
+     *            The secret access key that can be used to sign requests.
+     *            </p>
+     * @param sessionToken <p>
+     *            The token that users must pass to the service API to use the
+     *            temporary credentials.
+     *            </p>
+     * @param expiration <p>
+     *            The date on which the current credentials expire.
+     *            </p>
+     */
+    public Credentials(String accessKeyId, String secretAccessKey, String sessionToken,
+            java.util.Date expiration) {
+        setAccessKeyId(accessKeyId);
+        setSecretAccessKey(secretAccessKey);
+        setSessionToken(sessionToken);
+        setExpiration(expiration);
+    }
+
+    /**
+     * <p>
+     * The access key ID that identifies the temporary security credentials.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>16 - 32<br/>
+     * <b>Pattern: </b>[\w]*<br/>
+     *
+     * @return <p>
+     *         The access key ID that identifies the temporary security
+     *         credentials.
+     *         </p>
+     */
+    public String getAccessKeyId() {
+        return accessKeyId;
+    }
+
+    /**
+     * <p>
+     * The access key ID that identifies the temporary security credentials.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>16 - 32<br/>
+     * <b>Pattern: </b>[\w]*<br/>
+     *
+     * @param accessKeyId <p>
+     *            The access key ID that identifies the temporary security
+     *            credentials.
+     *            </p>
+     */
+    public void setAccessKeyId(String accessKeyId) {
+        this.accessKeyId = accessKeyId;
+    }
+
+    /**
+     * <p>
+     * The access key ID that identifies the temporary security credentials.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>16 - 32<br/>
+     * <b>Pattern: </b>[\w]*<br/>
+     *
+     * @param accessKeyId <p>
+     *            The access key ID that identifies the temporary security
+     *            credentials.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withAccessKeyId(String accessKeyId) {
+        this.accessKeyId = accessKeyId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The secret access key that can be used to sign requests.
+     * </p>
+     *
+     * @return <p>
+     *         The secret access key that can be used to sign requests.
+     *         </p>
+     */
+    public String getSecretAccessKey() {
+        return secretAccessKey;
+    }
+
+    /**
+     * <p>
+     * The secret access key that can be used to sign requests.
+     * </p>
+     *
+     * @param secretAccessKey <p>
+     *            The secret access key that can be used to sign requests.
+     *            </p>
+     */
+    public void setSecretAccessKey(String secretAccessKey) {
+        this.secretAccessKey = secretAccessKey;
+    }
+
+    /**
+     * <p>
+     * The secret access key that can be used to sign requests.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param secretAccessKey <p>
+     *            The secret access key that can be used to sign requests.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withSecretAccessKey(String secretAccessKey) {
+        this.secretAccessKey = secretAccessKey;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The token that users must pass to the service API to use the temporary
+     * credentials.
+     * </p>
+     *
+     * @return <p>
+     *         The token that users must pass to the service API to use the
+     *         temporary credentials.
+     *         </p>
+     */
+    public String getSessionToken() {
+        return sessionToken;
+    }
+
+    /**
+     * <p>
+     * The token that users must pass to the service API to use the temporary
+     * credentials.
+     * </p>
+     *
+     * @param sessionToken <p>
+     *            The token that users must pass to the service API to use the
+     *            temporary credentials.
+     *            </p>
+     */
+    public void setSessionToken(String sessionToken) {
+        this.sessionToken = sessionToken;
+    }
+
+    /**
+     * <p>
+     * The token that users must pass to the service API to use the temporary
+     * credentials.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param sessionToken <p>
+     *            The token that users must pass to the service API to use the
+     *            temporary credentials.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withSessionToken(String sessionToken) {
+        this.sessionToken = sessionToken;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The date on which the current credentials expire.
+     * </p>
+     *
+     * @return <p>
+     *         The date on which the current credentials expire.
+     *         </p>
+     */
+    public java.util.Date getExpiration() {
+        return expiration;
+    }
+
+    /**
+     * <p>
+     * The date on which the current credentials expire.
+     * </p>
+     *
+     * @param expiration <p>
+     *            The date on which the current credentials expire.
+     *            </p>
+     */
+    public void setExpiration(java.util.Date expiration) {
+        this.expiration = expiration;
+    }
+
+    /**
+     * <p>
+     * The date on which the current credentials expire.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param expiration <p>
+     *            The date on which the current credentials expire.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public Credentials withExpiration(java.util.Date expiration) {
+        this.expiration = expiration;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getAccessKeyId() != null)
+            sb.append("AccessKeyId: " + getAccessKeyId() + ",");
+        if (getSecretAccessKey() != null)
+            sb.append("SecretAccessKey: " + getSecretAccessKey() + ",");
+        if (getSessionToken() != null)
+            sb.append("SessionToken: " + getSessionToken() + ",");
+        if (getExpiration() != null)
+            sb.append("Expiration: " + getExpiration());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getAccessKeyId() == null) ? 0 : getAccessKeyId().hashCode());
+        hashCode = prime * hashCode
+                + ((getSecretAccessKey() == null) ? 0 : getSecretAccessKey().hashCode());
+        hashCode = prime * hashCode
+                + ((getSessionToken() == null) ? 0 : getSessionToken().hashCode());
+        hashCode = prime * hashCode + ((getExpiration() == null) ? 0 : getExpiration().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof Credentials == false)
+            return false;
+        Credentials other = (Credentials) obj;
+
+        if (other.getAccessKeyId() == null ^ this.getAccessKeyId() == null)
+            return false;
+        if (other.getAccessKeyId() != null
+                && other.getAccessKeyId().equals(this.getAccessKeyId()) == false)
+            return false;
+        if (other.getSecretAccessKey() == null ^ this.getSecretAccessKey() == null)
+            return false;
+        if (other.getSecretAccessKey() != null
+                && other.getSecretAccessKey().equals(this.getSecretAccessKey()) == false)
+            return false;
+        if (other.getSessionToken() == null ^ this.getSessionToken() == null)
+            return false;
+        if (other.getSessionToken() != null
+                && other.getSessionToken().equals(this.getSessionToken()) == false)
+            return false;
+        if (other.getExpiration() == null ^ this.getExpiration() == null)
+            return false;
+        if (other.getExpiration() != null
+                && other.getExpiration().equals(this.getExpiration()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/ExpiredTokenException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/ExpiredTokenException.java
new file mode 100644
index 0000000000..82178602b9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/ExpiredTokenException.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The web identity token that was passed is expired or is not valid. Get a new
+ * identity token from the identity provider and then retry the request.
+ * </p>
+ */
+public class ExpiredTokenException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new ExpiredTokenException with the specified error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public ExpiredTokenException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/FederatedUser.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/FederatedUser.java
new file mode 100644
index 0000000000..5ebe674a96
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/FederatedUser.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Identifiers for the federated user that is associated with the credentials.
+ * </p>
+ */
+public class FederatedUser implements Serializable {
+    /**
+     * <p>
+     * The string that identifies the federated user associated with the
+     * credentials, similar to the unique ID of an IAM user.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@\:-]*<br/>
+     */
+    private String federatedUserId;
+
+    /**
+     * <p>
+     * The ARN that specifies the federated user that is associated with the
+     * credentials. For more information about ARNs and how to use them in
+     * policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     */
+    private String arn;
+
+    /**
+     * Default constructor for FederatedUser object. Callers should use the
+     * setter or fluent setter (with...) methods to initialize any additional
+     * object members.
+     */
+    public FederatedUser() {
+    }
+
+    /**
+     * Constructs a new FederatedUser object. Callers should use the setter or
+     * fluent setter (with...) methods to initialize any additional object
+     * members.
+     * 
+     * @param federatedUserId <p>
+     *            The string that identifies the federated user associated with
+     *            the credentials, similar to the unique ID of an IAM user.
+     *            </p>
+     * @param arn <p>
+     *            The ARN that specifies the federated user that is associated
+     *            with the credentials. For more information about ARNs and how
+     *            to use them in policies, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *            >IAM Identifiers</a> in <i>Using IAM</i>.
+     *            </p>
+     */
+    public FederatedUser(String federatedUserId, String arn) {
+        setFederatedUserId(federatedUserId);
+        setArn(arn);
+    }
+
+    /**
+     * <p>
+     * The string that identifies the federated user associated with the
+     * credentials, similar to the unique ID of an IAM user.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@\:-]*<br/>
+     *
+     * @return <p>
+     *         The string that identifies the federated user associated with the
+     *         credentials, similar to the unique ID of an IAM user.
+     *         </p>
+     */
+    public String getFederatedUserId() {
+        return federatedUserId;
+    }
+
+    /**
+     * <p>
+     * The string that identifies the federated user associated with the
+     * credentials, similar to the unique ID of an IAM user.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@\:-]*<br/>
+     *
+     * @param federatedUserId <p>
+     *            The string that identifies the federated user associated with
+     *            the credentials, similar to the unique ID of an IAM user.
+     *            </p>
+     */
+    public void setFederatedUserId(String federatedUserId) {
+        this.federatedUserId = federatedUserId;
+    }
+
+    /**
+     * <p>
+     * The string that identifies the federated user associated with the
+     * credentials, similar to the unique ID of an IAM user.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 96<br/>
+     * <b>Pattern: </b>[\w+=,.@\:-]*<br/>
+     *
+     * @param federatedUserId <p>
+     *            The string that identifies the federated user associated with
+     *            the credentials, similar to the unique ID of an IAM user.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public FederatedUser withFederatedUserId(String federatedUserId) {
+        this.federatedUserId = federatedUserId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The ARN that specifies the federated user that is associated with the
+     * credentials. For more information about ARNs and how to use them in
+     * policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @return <p>
+     *         The ARN that specifies the federated user that is associated with
+     *         the credentials. For more information about ARNs and how to use
+     *         them in policies, see <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *         >IAM Identifiers</a> in <i>Using IAM</i>.
+     *         </p>
+     */
+    public String getArn() {
+        return arn;
+    }
+
+    /**
+     * <p>
+     * The ARN that specifies the federated user that is associated with the
+     * credentials. For more information about ARNs and how to use them in
+     * policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The ARN that specifies the federated user that is associated
+     *            with the credentials. For more information about ARNs and how
+     *            to use them in policies, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *            >IAM Identifiers</a> in <i>Using IAM</i>.
+     *            </p>
+     */
+    public void setArn(String arn) {
+        this.arn = arn;
+    }
+
+    /**
+     * <p>
+     * The ARN that specifies the federated user that is associated with the
+     * credentials. For more information about ARNs and how to use them in
+     * policies, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     * >IAM Identifiers</a> in <i>Using IAM</i>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The ARN that specifies the federated user that is associated
+     *            with the credentials. For more information about ARNs and how
+     *            to use them in policies, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html"
+     *            >IAM Identifiers</a> in <i>Using IAM</i>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public FederatedUser withArn(String arn) {
+        this.arn = arn;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getFederatedUserId() != null)
+            sb.append("FederatedUserId: " + getFederatedUserId() + ",");
+        if (getArn() != null)
+            sb.append("Arn: " + getArn());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getFederatedUserId() == null) ? 0 : getFederatedUserId().hashCode());
+        hashCode = prime * hashCode + ((getArn() == null) ? 0 : getArn().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof FederatedUser == false)
+            return false;
+        FederatedUser other = (FederatedUser) obj;
+
+        if (other.getFederatedUserId() == null ^ this.getFederatedUserId() == null)
+            return false;
+        if (other.getFederatedUserId() != null
+                && other.getFederatedUserId().equals(this.getFederatedUserId()) == false)
+            return false;
+        if (other.getArn() == null ^ this.getArn() == null)
+            return false;
+        if (other.getArn() != null && other.getArn().equals(this.getArn()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityRequest.java
new file mode 100644
index 0000000000..f8104eff0a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityRequest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns details about the IAM identity whose credentials are used to call the
+ * API.
+ * </p>
+ */
+public class GetCallerIdentityRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetCallerIdentityRequest == false)
+            return false;
+        GetCallerIdentityRequest other = (GetCallerIdentityRequest) obj;
+
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityResult.java
new file mode 100644
index 0000000000..302b82bd51
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetCallerIdentityResult.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Contains the response to a successful <a>GetCallerIdentity</a> request,
+ * including information about the entity making the request.
+ * </p>
+ */
+public class GetCallerIdentityResult implements Serializable {
+    /**
+     * <p>
+     * The unique identifier of the calling entity. The exact value depends on
+     * the type of entity making the call. The values returned are those listed
+     * in the <b>aws:userid</b> column in the <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     * >Principal table</a> found on the <b>Policy Variables</b> reference page
+     * in the <i>IAM User Guide</i>.
+     * </p>
+     */
+    private String userId;
+
+    /**
+     * <p>
+     * The AWS account ID number of the account that owns or contains the
+     * calling entity.
+     * </p>
+     */
+    private String account;
+
+    /**
+     * <p>
+     * The AWS ARN associated with the calling entity.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     */
+    private String arn;
+
+    /**
+     * <p>
+     * The unique identifier of the calling entity. The exact value depends on
+     * the type of entity making the call. The values returned are those listed
+     * in the <b>aws:userid</b> column in the <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     * >Principal table</a> found on the <b>Policy Variables</b> reference page
+     * in the <i>IAM User Guide</i>.
+     * </p>
+     *
+     * @return <p>
+     *         The unique identifier of the calling entity. The exact value
+     *         depends on the type of entity making the call. The values
+     *         returned are those listed in the <b>aws:userid</b> column in the
+     *         <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     *         >Principal table</a> found on the <b>Policy Variables</b>
+     *         reference page in the <i>IAM User Guide</i>.
+     *         </p>
+     */
+    public String getUserId() {
+        return userId;
+    }
+
+    /**
+     * <p>
+     * The unique identifier of the calling entity. The exact value depends on
+     * the type of entity making the call. The values returned are those listed
+     * in the <b>aws:userid</b> column in the <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     * >Principal table</a> found on the <b>Policy Variables</b> reference page
+     * in the <i>IAM User Guide</i>.
+     * </p>
+     *
+     * @param userId <p>
+     *            The unique identifier of the calling entity. The exact value
+     *            depends on the type of entity making the call. The values
+     *            returned are those listed in the <b>aws:userid</b> column in
+     *            the <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     *            >Principal table</a> found on the <b>Policy Variables</b>
+     *            reference page in the <i>IAM User Guide</i>.
+     *            </p>
+     */
+    public void setUserId(String userId) {
+        this.userId = userId;
+    }
+
+    /**
+     * <p>
+     * The unique identifier of the calling entity. The exact value depends on
+     * the type of entity making the call. The values returned are those listed
+     * in the <b>aws:userid</b> column in the <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     * >Principal table</a> found on the <b>Policy Variables</b> reference page
+     * in the <i>IAM User Guide</i>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param userId <p>
+     *            The unique identifier of the calling entity. The exact value
+     *            depends on the type of entity making the call. The values
+     *            returned are those listed in the <b>aws:userid</b> column in
+     *            the <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable"
+     *            >Principal table</a> found on the <b>Policy Variables</b>
+     *            reference page in the <i>IAM User Guide</i>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCallerIdentityResult withUserId(String userId) {
+        this.userId = userId;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The AWS account ID number of the account that owns or contains the
+     * calling entity.
+     * </p>
+     *
+     * @return <p>
+     *         The AWS account ID number of the account that owns or contains
+     *         the calling entity.
+     *         </p>
+     */
+    public String getAccount() {
+        return account;
+    }
+
+    /**
+     * <p>
+     * The AWS account ID number of the account that owns or contains the
+     * calling entity.
+     * </p>
+     *
+     * @param account <p>
+     *            The AWS account ID number of the account that owns or contains
+     *            the calling entity.
+     *            </p>
+     */
+    public void setAccount(String account) {
+        this.account = account;
+    }
+
+    /**
+     * <p>
+     * The AWS account ID number of the account that owns or contains the
+     * calling entity.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param account <p>
+     *            The AWS account ID number of the account that owns or contains
+     *            the calling entity.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCallerIdentityResult withAccount(String account) {
+        this.account = account;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The AWS ARN associated with the calling entity.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @return <p>
+     *         The AWS ARN associated with the calling entity.
+     *         </p>
+     */
+    public String getArn() {
+        return arn;
+    }
+
+    /**
+     * <p>
+     * The AWS ARN associated with the calling entity.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The AWS ARN associated with the calling entity.
+     *            </p>
+     */
+    public void setArn(String arn) {
+        this.arn = arn;
+    }
+
+    /**
+     * <p>
+     * The AWS ARN associated with the calling entity.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>20 - 2048<br/>
+     * <b>Pattern: </b>[
+     * -\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]+<br/>
+     *
+     * @param arn <p>
+     *            The AWS ARN associated with the calling entity.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetCallerIdentityResult withArn(String arn) {
+        this.arn = arn;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getUserId() != null)
+            sb.append("UserId: " + getUserId() + ",");
+        if (getAccount() != null)
+            sb.append("Account: " + getAccount() + ",");
+        if (getArn() != null)
+            sb.append("Arn: " + getArn());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getUserId() == null) ? 0 : getUserId().hashCode());
+        hashCode = prime * hashCode + ((getAccount() == null) ? 0 : getAccount().hashCode());
+        hashCode = prime * hashCode + ((getArn() == null) ? 0 : getArn().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetCallerIdentityResult == false)
+            return false;
+        GetCallerIdentityResult other = (GetCallerIdentityResult) obj;
+
+        if (other.getUserId() == null ^ this.getUserId() == null)
+            return false;
+        if (other.getUserId() != null && other.getUserId().equals(this.getUserId()) == false)
+            return false;
+        if (other.getAccount() == null ^ this.getAccount() == null)
+            return false;
+        if (other.getAccount() != null && other.getAccount().equals(this.getAccount()) == false)
+            return false;
+        if (other.getArn() == null ^ this.getArn() == null)
+            return false;
+        if (other.getArn() != null && other.getArn().equals(this.getArn()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenRequest.java
new file mode 100644
index 0000000000..5e43ccf600
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenRequest.java
@@ -0,0 +1,810 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns a set of temporary security credentials (consisting of an access key
+ * ID, a secret access key, and a security token) for a federated user. A
+ * typical use is in a proxy application that gets temporary security
+ * credentials on behalf of distributed applications inside a corporate network.
+ * Because you must call the <code>GetFederationToken</code> action using the
+ * long-term security credentials of an IAM user, this call is appropriate in
+ * contexts where those credentials can be safely stored, usually in a
+ * server-based application. For a comparison of <code>GetFederationToken</code>
+ * with the other APIs that produce temporary credentials, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+ * >Requesting Temporary Security Credentials</a> and <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+ * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <note>
+ * <p>
+ * If you are creating a mobile-based or browser-based app that can authenticate
+ * users using a web identity provider like Login with Amazon, Facebook, Google,
+ * or an OpenID Connect-compatible identity provider, we recommend that you use
+ * <a href="http://aws.amazon.com/cognito/">Amazon Cognito</a> or
+ * <code>AssumeRoleWithWebIdentity</code>. For more information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity"
+ * >Federation Through a Web-based Identity Provider</a>.
+ * </p>
+ * </note>
+ * <p>
+ * The <code>GetFederationToken</code> action must be called by using the
+ * long-term AWS security credentials of an IAM user. You can also call
+ * <code>GetFederationToken</code> using the security credentials of an AWS root
+ * account, but we do not recommended it. Instead, we recommend that you create
+ * an IAM user for the purpose of the proxy application and then attach a policy
+ * to the IAM user that limits federated users to only the actions and resources
+ * that they need access to. For more information, see <a
+ * href="http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html"
+ * >IAM Best Practices</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * The temporary security credentials that are obtained by using the long-term
+ * credentials of an IAM user are valid for the specified duration, from 900
+ * seconds (15 minutes) up to a maximium of 129600 seconds (36 hours). The
+ * default is 43200 seconds (12 hours). Temporary credentials that are obtained
+ * by using AWS root account credentials have a maximum duration of 3600 seconds
+ * (1 hour).
+ * </p>
+ * <p>
+ * The temporary security credentials created by <code>GetFederationToken</code>
+ * can be used to make API calls to any AWS service with the following
+ * exceptions:
+ * </p>
+ * <ul>
+ * <li>
+ * <p>
+ * You cannot use these credentials to call any IAM APIs.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * You cannot call any STS APIs.
+ * </p>
+ * </li>
+ * </ul>
+ * <p>
+ * <b>Permissions</b>
+ * </p>
+ * <p>
+ * The permissions for the temporary security credentials returned by
+ * <code>GetFederationToken</code> are determined by a combination of the
+ * following:
+ * </p>
+ * <ul>
+ * <li>
+ * <p>
+ * The policy or policies that are attached to the IAM user whose credentials
+ * are used to call <code>GetFederationToken</code>.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * The policy that is passed as a parameter in the call.
+ * </p>
+ * </li>
+ * </ul>
+ * <p>
+ * The passed policy is attached to the temporary security credentials that
+ * result from the <code>GetFederationToken</code> API call--that is, to the
+ * <i>federated user</i>. When the federated user makes an AWS request, AWS
+ * evaluates the policy attached to the federated user in combination with the
+ * policy or policies attached to the IAM user whose credentials were used to
+ * call <code>GetFederationToken</code>. AWS allows the federated user's request
+ * only when both the federated user <i> <b>and</b> </i> the IAM user are
+ * explicitly allowed to perform the requested action. The passed policy cannot
+ * grant more permissions than those that are defined in the IAM user policy.
+ * </p>
+ * <p>
+ * A typical use case is that the permissions of the IAM user whose credentials
+ * are used to call <code>GetFederationToken</code> are designed to allow access
+ * to all the actions and resources that any federated user will need. Then, for
+ * individual users, you pass a policy to the operation that scopes down the
+ * permissions to a level that's appropriate to that individual user, using a
+ * policy that allows only a subset of permissions that are granted to the IAM
+ * user.
+ * </p>
+ * <p>
+ * If you do not pass a policy, the resulting temporary security credentials
+ * have no effective permissions. The only exception is when the temporary
+ * security credentials are used to access a resource that has a resource-based
+ * policy that specifically allows the federated user to access the resource.
+ * </p>
+ * <p>
+ * For more information about how permissions work, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+ * >Permissions for GetFederationToken</a>. For information about using
+ * <code>GetFederationToken</code> to create temporary security credentials, see
+ * <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getfederationtoken"
+ * >GetFederationTokenFederation Through a Custom Identity Broker</a>.
+ * </p>
+ */
+public class GetFederationTokenRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * <p>
+     * The name of the federated user. The name is used as an identifier for the
+     * temporary security credentials (such as <code>Bob</code>). For example,
+     * you can reference the federated user name in a resource-based policy,
+     * such as in an Amazon S3 bucket policy.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 32<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     */
+    private String name;
+
+    /**
+     * <p>
+     * An IAM policy in JSON format that is passed with the
+     * <code>GetFederationToken</code> call and evaluated along with the policy
+     * or policies that are attached to the IAM user whose credentials are used
+     * to call <code>GetFederationToken</code>. The passed policy is used to
+     * scope down the permissions that are available to the IAM user, by
+     * allowing only a subset of the permissions that are granted to the IAM
+     * user. The passed policy cannot grant more permissions than those granted
+     * to the IAM user. The final permissions for the federated user are the
+     * most restrictive set based on the intersection of the passed policy and
+     * the IAM user policy.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     */
+    private String policy;
+
+    /**
+     * <p>
+     * The duration, in seconds, that the session should last. Acceptable
+     * durations for federation sessions range from 900 seconds (15 minutes) to
+     * 129600 seconds (36 hours), with 43200 seconds (12 hours) as the default.
+     * Sessions obtained using AWS account (root) credentials are restricted to
+     * a maximum of 3600 seconds (one hour). If the specified duration is longer
+     * than one hour, the session obtained by using AWS account (root)
+     * credentials defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     */
+    private Integer durationSeconds;
+
+    /**
+     * Default constructor for GetFederationTokenRequest object. Callers should
+     * use the setter or fluent setter (with...) methods to initialize any
+     * additional object members.
+     */
+    public GetFederationTokenRequest() {
+    }
+
+    /**
+     * Constructs a new GetFederationTokenRequest object. Callers should use the
+     * setter or fluent setter (with...) methods to initialize any additional
+     * object members.
+     * 
+     * @param name <p>
+     *            The name of the federated user. The name is used as an
+     *            identifier for the temporary security credentials (such as
+     *            <code>Bob</code>). For example, you can reference the
+     *            federated user name in a resource-based policy, such as in an
+     *            Amazon S3 bucket policy.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public GetFederationTokenRequest(String name) {
+        setName(name);
+    }
+
+    /**
+     * <p>
+     * The name of the federated user. The name is used as an identifier for the
+     * temporary security credentials (such as <code>Bob</code>). For example,
+     * you can reference the federated user name in a resource-based policy,
+     * such as in an Amazon S3 bucket policy.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 32<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @return <p>
+     *         The name of the federated user. The name is used as an identifier
+     *         for the temporary security credentials (such as <code>Bob</code>
+     *         ). For example, you can reference the federated user name in a
+     *         resource-based policy, such as in an Amazon S3 bucket policy.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@-
+     *         </p>
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * <p>
+     * The name of the federated user. The name is used as an identifier for the
+     * temporary security credentials (such as <code>Bob</code>). For example,
+     * you can reference the federated user name in a resource-based policy,
+     * such as in an Amazon S3 bucket policy.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 32<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param name <p>
+     *            The name of the federated user. The name is used as an
+     *            identifier for the temporary security credentials (such as
+     *            <code>Bob</code>). For example, you can reference the
+     *            federated user name in a resource-based policy, such as in an
+     *            Amazon S3 bucket policy.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * <p>
+     * The name of the federated user. The name is used as an identifier for the
+     * temporary security credentials (such as <code>Bob</code>). For example,
+     * you can reference the federated user name in a resource-based policy,
+     * such as in an Amazon S3 bucket policy.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>2 - 32<br/>
+     * <b>Pattern: </b>[\w+=,.@-]*<br/>
+     *
+     * @param name <p>
+     *            The name of the federated user. The name is used as an
+     *            identifier for the temporary security credentials (such as
+     *            <code>Bob</code>). For example, you can reference the
+     *            federated user name in a resource-based policy, such as in an
+     *            Amazon S3 bucket policy.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenRequest withName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format that is passed with the
+     * <code>GetFederationToken</code> call and evaluated along with the policy
+     * or policies that are attached to the IAM user whose credentials are used
+     * to call <code>GetFederationToken</code>. The passed policy is used to
+     * scope down the permissions that are available to the IAM user, by
+     * allowing only a subset of the permissions that are granted to the IAM
+     * user. The passed policy cannot grant more permissions than those granted
+     * to the IAM user. The final permissions for the federated user are the
+     * most restrictive set based on the intersection of the passed policy and
+     * the IAM user policy.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @return <p>
+     *         An IAM policy in JSON format that is passed with the
+     *         <code>GetFederationToken</code> call and evaluated along with the
+     *         policy or policies that are attached to the IAM user whose
+     *         credentials are used to call <code>GetFederationToken</code>. The
+     *         passed policy is used to scope down the permissions that are
+     *         available to the IAM user, by allowing only a subset of the
+     *         permissions that are granted to the IAM user. The passed policy
+     *         cannot grant more permissions than those granted to the IAM user.
+     *         The final permissions for the federated user are the most
+     *         restrictive set based on the intersection of the passed policy
+     *         and the IAM user policy.
+     *         </p>
+     *         <p>
+     *         If you do not pass a policy, the resulting temporary security
+     *         credentials have no effective permissions. The only exception is
+     *         when the temporary security credentials are used to access a
+     *         resource that has a resource-based policy that specifically
+     *         allows the federated user to access the resource.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters up to 2048 characters in length. The
+     *         characters can be any ASCII character from the space character to
+     *         the end of the valid character list ( -\u00FF). It can also
+     *         include the tab ( ), linefeed ( ), and carriage return ( )
+     *         characters.
+     *         </p>
+     *         <note>
+     *         <p>
+     *         The policy plain text must be 2048 bytes or shorter. However, an
+     *         internal conversion compresses it into a packed binary format
+     *         with a separate limit. The PackedPolicySize response element
+     *         indicates by percentage how close to the upper size limit the
+     *         policy is, with 100% equaling the maximum allowed size.
+     *         </p>
+     *         </note>
+     *         <p>
+     *         For more information about how permissions work, see <a href=
+     *         "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     *         >Permissions for GetFederationToken</a>.
+     *         </p>
+     */
+    public String getPolicy() {
+        return policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format that is passed with the
+     * <code>GetFederationToken</code> call and evaluated along with the policy
+     * or policies that are attached to the IAM user whose credentials are used
+     * to call <code>GetFederationToken</code>. The passed policy is used to
+     * scope down the permissions that are available to the IAM user, by
+     * allowing only a subset of the permissions that are granted to the IAM
+     * user. The passed policy cannot grant more permissions than those granted
+     * to the IAM user. The final permissions for the federated user are the
+     * most restrictive set based on the intersection of the passed policy and
+     * the IAM user policy.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format that is passed with the
+     *            <code>GetFederationToken</code> call and evaluated along with
+     *            the policy or policies that are attached to the IAM user whose
+     *            credentials are used to call <code>GetFederationToken</code>.
+     *            The passed policy is used to scope down the permissions that
+     *            are available to the IAM user, by allowing only a subset of
+     *            the permissions that are granted to the IAM user. The passed
+     *            policy cannot grant more permissions than those granted to the
+     *            IAM user. The final permissions for the federated user are the
+     *            most restrictive set based on the intersection of the passed
+     *            policy and the IAM user policy.
+     *            </p>
+     *            <p>
+     *            If you do not pass a policy, the resulting temporary security
+     *            credentials have no effective permissions. The only exception
+     *            is when the temporary security credentials are used to access
+     *            a resource that has a resource-based policy that specifically
+     *            allows the federated user to access the resource.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     *            <p>
+     *            For more information about how permissions work, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     *            >Permissions for GetFederationToken</a>.
+     *            </p>
+     */
+    public void setPolicy(String policy) {
+        this.policy = policy;
+    }
+
+    /**
+     * <p>
+     * An IAM policy in JSON format that is passed with the
+     * <code>GetFederationToken</code> call and evaluated along with the policy
+     * or policies that are attached to the IAM user whose credentials are used
+     * to call <code>GetFederationToken</code>. The passed policy is used to
+     * scope down the permissions that are available to the IAM user, by
+     * allowing only a subset of the permissions that are granted to the IAM
+     * user. The passed policy cannot grant more permissions than those granted
+     * to the IAM user. The final permissions for the federated user are the
+     * most restrictive set based on the intersection of the passed policy and
+     * the IAM user policy.
+     * </p>
+     * <p>
+     * If you do not pass a policy, the resulting temporary security credentials
+     * have no effective permissions. The only exception is when the temporary
+     * security credentials are used to access a resource that has a
+     * resource-based policy that specifically allows the federated user to
+     * access the resource.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters up to 2048 characters in length. The characters can
+     * be any ASCII character from the space character to the end of the valid
+     * character list ( -\u00FF). It can also include the tab ( ), linefeed ( ),
+     * and carriage return ( ) characters.
+     * </p>
+     * <note>
+     * <p>
+     * The policy plain text must be 2048 bytes or shorter. However, an internal
+     * conversion compresses it into a packed binary format with a separate
+     * limit. The PackedPolicySize response element indicates by percentage how
+     * close to the upper size limit the policy is, with 100% equaling the
+     * maximum allowed size.
+     * </p>
+     * </note>
+     * <p>
+     * For more information about how permissions work, see <a href=
+     * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     * >Permissions for GetFederationToken</a>.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>1 - 2048<br/>
+     * <b>Pattern: </b>[ -\u00FF]+<br/>
+     *
+     * @param policy <p>
+     *            An IAM policy in JSON format that is passed with the
+     *            <code>GetFederationToken</code> call and evaluated along with
+     *            the policy or policies that are attached to the IAM user whose
+     *            credentials are used to call <code>GetFederationToken</code>.
+     *            The passed policy is used to scope down the permissions that
+     *            are available to the IAM user, by allowing only a subset of
+     *            the permissions that are granted to the IAM user. The passed
+     *            policy cannot grant more permissions than those granted to the
+     *            IAM user. The final permissions for the federated user are the
+     *            most restrictive set based on the intersection of the passed
+     *            policy and the IAM user policy.
+     *            </p>
+     *            <p>
+     *            If you do not pass a policy, the resulting temporary security
+     *            credentials have no effective permissions. The only exception
+     *            is when the temporary security credentials are used to access
+     *            a resource that has a resource-based policy that specifically
+     *            allows the federated user to access the resource.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters up to 2048 characters in
+     *            length. The characters can be any ASCII character from the
+     *            space character to the end of the valid character list (
+     *            -\u00FF). It can also include the tab ( ), linefeed ( ), and
+     *            carriage return ( ) characters.
+     *            </p>
+     *            <note>
+     *            <p>
+     *            The policy plain text must be 2048 bytes or shorter. However,
+     *            an internal conversion compresses it into a packed binary
+     *            format with a separate limit. The PackedPolicySize response
+     *            element indicates by percentage how close to the upper size
+     *            limit the policy is, with 100% equaling the maximum allowed
+     *            size.
+     *            </p>
+     *            </note>
+     *            <p>
+     *            For more information about how permissions work, see <a href=
+     *            "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_getfederationtoken.html"
+     *            >Permissions for GetFederationToken</a>.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenRequest withPolicy(String policy) {
+        this.policy = policy;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, that the session should last. Acceptable
+     * durations for federation sessions range from 900 seconds (15 minutes) to
+     * 129600 seconds (36 hours), with 43200 seconds (12 hours) as the default.
+     * Sessions obtained using AWS account (root) credentials are restricted to
+     * a maximum of 3600 seconds (one hour). If the specified duration is longer
+     * than one hour, the session obtained by using AWS account (root)
+     * credentials defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @return <p>
+     *         The duration, in seconds, that the session should last.
+     *         Acceptable durations for federation sessions range from 900
+     *         seconds (15 minutes) to 129600 seconds (36 hours), with 43200
+     *         seconds (12 hours) as the default. Sessions obtained using AWS
+     *         account (root) credentials are restricted to a maximum of 3600
+     *         seconds (one hour). If the specified duration is longer than one
+     *         hour, the session obtained by using AWS account (root)
+     *         credentials defaults to one hour.
+     *         </p>
+     */
+    public Integer getDurationSeconds() {
+        return durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, that the session should last. Acceptable
+     * durations for federation sessions range from 900 seconds (15 minutes) to
+     * 129600 seconds (36 hours), with 43200 seconds (12 hours) as the default.
+     * Sessions obtained using AWS account (root) credentials are restricted to
+     * a maximum of 3600 seconds (one hour). If the specified duration is longer
+     * than one hour, the session obtained by using AWS account (root)
+     * credentials defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, that the session should last.
+     *            Acceptable durations for federation sessions range from 900
+     *            seconds (15 minutes) to 129600 seconds (36 hours), with 43200
+     *            seconds (12 hours) as the default. Sessions obtained using AWS
+     *            account (root) credentials are restricted to a maximum of 3600
+     *            seconds (one hour). If the specified duration is longer than
+     *            one hour, the session obtained by using AWS account (root)
+     *            credentials defaults to one hour.
+     *            </p>
+     */
+    public void setDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, that the session should last. Acceptable
+     * durations for federation sessions range from 900 seconds (15 minutes) to
+     * 129600 seconds (36 hours), with 43200 seconds (12 hours) as the default.
+     * Sessions obtained using AWS account (root) credentials are restricted to
+     * a maximum of 3600 seconds (one hour). If the specified duration is longer
+     * than one hour, the session obtained by using AWS account (root)
+     * credentials defaults to one hour.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, that the session should last.
+     *            Acceptable durations for federation sessions range from 900
+     *            seconds (15 minutes) to 129600 seconds (36 hours), with 43200
+     *            seconds (12 hours) as the default. Sessions obtained using AWS
+     *            account (root) credentials are restricted to a maximum of 3600
+     *            seconds (one hour). If the specified duration is longer than
+     *            one hour, the session obtained by using AWS account (root)
+     *            credentials defaults to one hour.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenRequest withDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getName() != null)
+            sb.append("Name: " + getName() + ",");
+        if (getPolicy() != null)
+            sb.append("Policy: " + getPolicy() + ",");
+        if (getDurationSeconds() != null)
+            sb.append("DurationSeconds: " + getDurationSeconds());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode());
+        hashCode = prime * hashCode + ((getPolicy() == null) ? 0 : getPolicy().hashCode());
+        hashCode = prime * hashCode
+                + ((getDurationSeconds() == null) ? 0 : getDurationSeconds().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetFederationTokenRequest == false)
+            return false;
+        GetFederationTokenRequest other = (GetFederationTokenRequest) obj;
+
+        if (other.getName() == null ^ this.getName() == null)
+            return false;
+        if (other.getName() != null && other.getName().equals(this.getName()) == false)
+            return false;
+        if (other.getPolicy() == null ^ this.getPolicy() == null)
+            return false;
+        if (other.getPolicy() != null && other.getPolicy().equals(this.getPolicy()) == false)
+            return false;
+        if (other.getDurationSeconds() == null ^ this.getDurationSeconds() == null)
+            return false;
+        if (other.getDurationSeconds() != null
+                && other.getDurationSeconds().equals(this.getDurationSeconds()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenResult.java
new file mode 100644
index 0000000000..93ef613b22
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetFederationTokenResult.java
@@ -0,0 +1,357 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Contains the response to a successful <a>GetFederationToken</a> request,
+ * including temporary AWS credentials that can be used to make AWS requests.
+ * </p>
+ */
+public class GetFederationTokenResult implements Serializable {
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     */
+    private Credentials credentials;
+
+    /**
+     * <p>
+     * Identifiers for the federated user associated with the credentials (such
+     * as <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     * <code>123456789012:Bob</code>). You can use the federated user's ARN in
+     * your resource-based policies, such as an Amazon S3 bucket policy.
+     * </p>
+     */
+    private FederatedUser federatedUser;
+
+    /**
+     * <p>
+     * A percentage value indicating the size of the policy in packed form. The
+     * service rejects policies for which the packed size is greater than 100
+     * percent of the allowed value.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     */
+    private Integer packedPolicySize;
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @return <p>
+     *         The temporary security credentials, which include an access key
+     *         ID, a secret access key, and a security (or session) token.
+     *         </p>
+     *         <p>
+     *         <b>Note:</b> The size of the security token that STS APIs return
+     *         is not fixed. We strongly recommend that you make no assumptions
+     *         about the maximum size. As of this writing, the typical size is
+     *         less than 4096 bytes, but that can vary. Also, future updates to
+     *         AWS might require larger sizes.
+     *         </p>
+     */
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     */
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenResult withCredentials(Credentials credentials) {
+        this.credentials = credentials;
+        return this;
+    }
+
+    /**
+     * <p>
+     * Identifiers for the federated user associated with the credentials (such
+     * as <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     * <code>123456789012:Bob</code>). You can use the federated user's ARN in
+     * your resource-based policies, such as an Amazon S3 bucket policy.
+     * </p>
+     *
+     * @return <p>
+     *         Identifiers for the federated user associated with the
+     *         credentials (such as
+     *         <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     *         <code>123456789012:Bob</code>). You can use the federated user's
+     *         ARN in your resource-based policies, such as an Amazon S3 bucket
+     *         policy.
+     *         </p>
+     */
+    public FederatedUser getFederatedUser() {
+        return federatedUser;
+    }
+
+    /**
+     * <p>
+     * Identifiers for the federated user associated with the credentials (such
+     * as <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     * <code>123456789012:Bob</code>). You can use the federated user's ARN in
+     * your resource-based policies, such as an Amazon S3 bucket policy.
+     * </p>
+     *
+     * @param federatedUser <p>
+     *            Identifiers for the federated user associated with the
+     *            credentials (such as
+     *            <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     *            <code>123456789012:Bob</code>). You can use the federated
+     *            user's ARN in your resource-based policies, such as an Amazon
+     *            S3 bucket policy.
+     *            </p>
+     */
+    public void setFederatedUser(FederatedUser federatedUser) {
+        this.federatedUser = federatedUser;
+    }
+
+    /**
+     * <p>
+     * Identifiers for the federated user associated with the credentials (such
+     * as <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     * <code>123456789012:Bob</code>). You can use the federated user's ARN in
+     * your resource-based policies, such as an Amazon S3 bucket policy.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param federatedUser <p>
+     *            Identifiers for the federated user associated with the
+     *            credentials (such as
+     *            <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
+     *            <code>123456789012:Bob</code>). You can use the federated
+     *            user's ARN in your resource-based policies, such as an Amazon
+     *            S3 bucket policy.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenResult withFederatedUser(FederatedUser federatedUser) {
+        this.federatedUser = federatedUser;
+        return this;
+    }
+
+    /**
+     * <p>
+     * A percentage value indicating the size of the policy in packed form. The
+     * service rejects policies for which the packed size is greater than 100
+     * percent of the allowed value.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @return <p>
+     *         A percentage value indicating the size of the policy in packed
+     *         form. The service rejects policies for which the packed size is
+     *         greater than 100 percent of the allowed value.
+     *         </p>
+     */
+    public Integer getPackedPolicySize() {
+        return packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value indicating the size of the policy in packed form. The
+     * service rejects policies for which the packed size is greater than 100
+     * percent of the allowed value.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value indicating the size of the policy in packed
+     *            form. The service rejects policies for which the packed size
+     *            is greater than 100 percent of the allowed value.
+     *            </p>
+     */
+    public void setPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+    }
+
+    /**
+     * <p>
+     * A percentage value indicating the size of the policy in packed form. The
+     * service rejects policies for which the packed size is greater than 100
+     * percent of the allowed value.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>0 - <br/>
+     *
+     * @param packedPolicySize <p>
+     *            A percentage value indicating the size of the policy in packed
+     *            form. The service rejects policies for which the packed size
+     *            is greater than 100 percent of the allowed value.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetFederationTokenResult withPackedPolicySize(Integer packedPolicySize) {
+        this.packedPolicySize = packedPolicySize;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getCredentials() != null)
+            sb.append("Credentials: " + getCredentials() + ",");
+        if (getFederatedUser() != null)
+            sb.append("FederatedUser: " + getFederatedUser() + ",");
+        if (getPackedPolicySize() != null)
+            sb.append("PackedPolicySize: " + getPackedPolicySize());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getCredentials() == null) ? 0 : getCredentials().hashCode());
+        hashCode = prime * hashCode
+                + ((getFederatedUser() == null) ? 0 : getFederatedUser().hashCode());
+        hashCode = prime * hashCode
+                + ((getPackedPolicySize() == null) ? 0 : getPackedPolicySize().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetFederationTokenResult == false)
+            return false;
+        GetFederationTokenResult other = (GetFederationTokenResult) obj;
+
+        if (other.getCredentials() == null ^ this.getCredentials() == null)
+            return false;
+        if (other.getCredentials() != null
+                && other.getCredentials().equals(this.getCredentials()) == false)
+            return false;
+        if (other.getFederatedUser() == null ^ this.getFederatedUser() == null)
+            return false;
+        if (other.getFederatedUser() != null
+                && other.getFederatedUser().equals(this.getFederatedUser()) == false)
+            return false;
+        if (other.getPackedPolicySize() == null ^ this.getPackedPolicySize() == null)
+            return false;
+        if (other.getPackedPolicySize() != null
+                && other.getPackedPolicySize().equals(this.getPackedPolicySize()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenRequest.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenRequest.java
new file mode 100644
index 0000000000..c3099cb023
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenRequest.java
@@ -0,0 +1,556 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+import com.amazonaws.AmazonWebServiceRequest;
+
+/**
+ * <p>
+ * Returns a set of temporary credentials for an AWS account or IAM user. The
+ * credentials consist of an access key ID, a secret access key, and a security
+ * token. Typically, you use <code>GetSessionToken</code> if you want to use MFA
+ * to protect programmatic calls to specific AWS APIs like Amazon EC2
+ * <code>StopInstances</code>. MFA-enabled IAM users would need to call
+ * <code>GetSessionToken</code> and submit an MFA code that is associated with
+ * their MFA device. Using the temporary security credentials that are returned
+ * from the call, IAM users can then make programmatic calls to APIs that
+ * require MFA authentication. If you do not supply a correct MFA code, then the
+ * API returns an access denied error. For a comparison of
+ * <code>GetSessionToken</code> with the other APIs that produce temporary
+ * credentials, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html"
+ * >Requesting Temporary Security Credentials</a> and <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#stsapi_comparison"
+ * >Comparing the AWS STS APIs</a> in the <i>IAM User Guide</i>.
+ * </p>
+ * <p>
+ * The <code>GetSessionToken</code> action must be called by using the long-term
+ * AWS security credentials of the AWS account or an IAM user. Credentials that
+ * are created by IAM users are valid for the duration that you specify, from
+ * 900 seconds (15 minutes) up to a maximum of 129600 seconds (36 hours), with a
+ * default of 43200 seconds (12 hours); credentials that are created by using
+ * account credentials can range from 900 seconds (15 minutes) up to a maximum
+ * of 3600 seconds (1 hour), with a default of 1 hour.
+ * </p>
+ * <p>
+ * The temporary security credentials created by <code>GetSessionToken</code>
+ * can be used to make API calls to any AWS service with the following
+ * exceptions:
+ * </p>
+ * <ul>
+ * <li>
+ * <p>
+ * You cannot call any IAM APIs unless MFA authentication information is
+ * included in the request.
+ * </p>
+ * </li>
+ * <li>
+ * <p>
+ * You cannot call any STS API <i>except</i> <code>AssumeRole</code>.
+ * </p>
+ * </li>
+ * </ul>
+ * <note>
+ * <p>
+ * We recommend that you do not call <code>GetSessionToken</code> with root
+ * account credentials. Instead, follow our <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users"
+ * >best practices</a> by creating one or more IAM users, giving them the
+ * necessary permissions, and using IAM users for everyday interaction with AWS.
+ * </p>
+ * </note>
+ * <p>
+ * The permissions associated with the temporary security credentials returned
+ * by <code>GetSessionToken</code> are based on the permissions associated with
+ * account or IAM user whose credentials are used to call the action. If
+ * <code>GetSessionToken</code> is called using root account credentials, the
+ * temporary credentials have root account permissions. Similarly, if
+ * <code>GetSessionToken</code> is called using the credentials of an IAM user,
+ * the temporary credentials have the same permissions as the IAM user.
+ * </p>
+ * <p>
+ * For more information about using <code>GetSessionToken</code> to create
+ * temporary credentials, go to <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_getsessiontoken"
+ * >Temporary Credentials for Users in Untrusted Environments</a> in the <i>IAM
+ * User Guide</i>.
+ * </p>
+ */
+public class GetSessionTokenRequest extends AmazonWebServiceRequest implements Serializable {
+    /**
+     * <p>
+     * The duration, in seconds, that the credentials should remain valid.
+     * Acceptable durations for IAM user sessions range from 900 seconds (15
+     * minutes) to 129600 seconds (36 hours), with 43200 seconds (12 hours) as
+     * the default. Sessions for AWS account owners are restricted to a maximum
+     * of 3600 seconds (one hour). If the duration is longer than one hour, the
+     * session for AWS account owners defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     */
+    private Integer durationSeconds;
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * IAM user who is making the <code>GetSessionToken</code> call. Specify
+     * this value if the IAM user has a policy that requires MFA authentication.
+     * The value is either the serial number for a hardware device (such as
+     * <code>GAHT12345678</code>) or an Amazon Resource Name (ARN) for a virtual
+     * device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
+     * find the device for an IAM user by going to the AWS Management Console
+     * and viewing the user's security credentials.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     */
+    private String serialNumber;
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if MFA is required. If any policy
+     * requires the IAM user to submit an MFA code, specify this value. If MFA
+     * authentication is required, and the user does not provide a code when
+     * requesting a set of temporary security credentials, the user will receive
+     * an "access denied" response when requesting resources that require MFA
+     * authentication.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     */
+    private String tokenCode;
+
+    /**
+     * <p>
+     * The duration, in seconds, that the credentials should remain valid.
+     * Acceptable durations for IAM user sessions range from 900 seconds (15
+     * minutes) to 129600 seconds (36 hours), with 43200 seconds (12 hours) as
+     * the default. Sessions for AWS account owners are restricted to a maximum
+     * of 3600 seconds (one hour). If the duration is longer than one hour, the
+     * session for AWS account owners defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @return <p>
+     *         The duration, in seconds, that the credentials should remain
+     *         valid. Acceptable durations for IAM user sessions range from 900
+     *         seconds (15 minutes) to 129600 seconds (36 hours), with 43200
+     *         seconds (12 hours) as the default. Sessions for AWS account
+     *         owners are restricted to a maximum of 3600 seconds (one hour). If
+     *         the duration is longer than one hour, the session for AWS account
+     *         owners defaults to one hour.
+     *         </p>
+     */
+    public Integer getDurationSeconds() {
+        return durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, that the credentials should remain valid.
+     * Acceptable durations for IAM user sessions range from 900 seconds (15
+     * minutes) to 129600 seconds (36 hours), with 43200 seconds (12 hours) as
+     * the default. Sessions for AWS account owners are restricted to a maximum
+     * of 3600 seconds (one hour). If the duration is longer than one hour, the
+     * session for AWS account owners defaults to one hour.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, that the credentials should remain
+     *            valid. Acceptable durations for IAM user sessions range from
+     *            900 seconds (15 minutes) to 129600 seconds (36 hours), with
+     *            43200 seconds (12 hours) as the default. Sessions for AWS
+     *            account owners are restricted to a maximum of 3600 seconds
+     *            (one hour). If the duration is longer than one hour, the
+     *            session for AWS account owners defaults to one hour.
+     *            </p>
+     */
+    public void setDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+    }
+
+    /**
+     * <p>
+     * The duration, in seconds, that the credentials should remain valid.
+     * Acceptable durations for IAM user sessions range from 900 seconds (15
+     * minutes) to 129600 seconds (36 hours), with 43200 seconds (12 hours) as
+     * the default. Sessions for AWS account owners are restricted to a maximum
+     * of 3600 seconds (one hour). If the duration is longer than one hour, the
+     * session for AWS account owners defaults to one hour.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Range: </b>900 - 129600<br/>
+     *
+     * @param durationSeconds <p>
+     *            The duration, in seconds, that the credentials should remain
+     *            valid. Acceptable durations for IAM user sessions range from
+     *            900 seconds (15 minutes) to 129600 seconds (36 hours), with
+     *            43200 seconds (12 hours) as the default. Sessions for AWS
+     *            account owners are restricted to a maximum of 3600 seconds
+     *            (one hour). If the duration is longer than one hour, the
+     *            session for AWS account owners defaults to one hour.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetSessionTokenRequest withDurationSeconds(Integer durationSeconds) {
+        this.durationSeconds = durationSeconds;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * IAM user who is making the <code>GetSessionToken</code> call. Specify
+     * this value if the IAM user has a policy that requires MFA authentication.
+     * The value is either the serial number for a hardware device (such as
+     * <code>GAHT12345678</code>) or an Amazon Resource Name (ARN) for a virtual
+     * device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
+     * find the device for an IAM user by going to the AWS Management Console
+     * and viewing the user's security credentials.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @return <p>
+     *         The identification number of the MFA device that is associated
+     *         with the IAM user who is making the <code>GetSessionToken</code>
+     *         call. Specify this value if the IAM user has a policy that
+     *         requires MFA authentication. The value is either the serial
+     *         number for a hardware device (such as <code>GAHT12345678</code>)
+     *         or an Amazon Resource Name (ARN) for a virtual device (such as
+     *         <code>arn:aws:iam::123456789012:mfa/user</code>). You can find
+     *         the device for an IAM user by going to the AWS Management Console
+     *         and viewing the user's security credentials.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a string of characters consisting of upper- and lower-case
+     *         alphanumeric characters with no spaces. You can also include any
+     *         of the following characters: =,.@-
+     *         </p>
+     */
+    public String getSerialNumber() {
+        return serialNumber;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * IAM user who is making the <code>GetSessionToken</code> call. Specify
+     * this value if the IAM user has a policy that requires MFA authentication.
+     * The value is either the serial number for a hardware device (such as
+     * <code>GAHT12345678</code>) or an Amazon Resource Name (ARN) for a virtual
+     * device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
+     * find the device for an IAM user by going to the AWS Management Console
+     * and viewing the user's security credentials.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @param serialNumber <p>
+     *            The identification number of the MFA device that is associated
+     *            with the IAM user who is making the
+     *            <code>GetSessionToken</code> call. Specify this value if the
+     *            IAM user has a policy that requires MFA authentication. The
+     *            value is either the serial number for a hardware device (such
+     *            as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
+     *            for a virtual device (such as
+     *            <code>arn:aws:iam::123456789012:mfa/user</code>). You can find
+     *            the device for an IAM user by going to the AWS Management
+     *            Console and viewing the user's security credentials.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     */
+    public void setSerialNumber(String serialNumber) {
+        this.serialNumber = serialNumber;
+    }
+
+    /**
+     * <p>
+     * The identification number of the MFA device that is associated with the
+     * IAM user who is making the <code>GetSessionToken</code> call. Specify
+     * this value if the IAM user has a policy that requires MFA authentication.
+     * The value is either the serial number for a hardware device (such as
+     * <code>GAHT12345678</code>) or an Amazon Resource Name (ARN) for a virtual
+     * device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
+     * find the device for an IAM user by going to the AWS Management Console
+     * and viewing the user's security credentials.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * string of characters consisting of upper- and lower-case alphanumeric
+     * characters with no spaces. You can also include any of the following
+     * characters: =,.@-
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>9 - 256<br/>
+     * <b>Pattern: </b>[\w+=/:,.@-]*<br/>
+     *
+     * @param serialNumber <p>
+     *            The identification number of the MFA device that is associated
+     *            with the IAM user who is making the
+     *            <code>GetSessionToken</code> call. Specify this value if the
+     *            IAM user has a policy that requires MFA authentication. The
+     *            value is either the serial number for a hardware device (such
+     *            as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
+     *            for a virtual device (such as
+     *            <code>arn:aws:iam::123456789012:mfa/user</code>). You can find
+     *            the device for an IAM user by going to the AWS Management
+     *            Console and viewing the user's security credentials.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a string of characters consisting of upper- and
+     *            lower-case alphanumeric characters with no spaces. You can
+     *            also include any of the following characters: =,.@-
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetSessionTokenRequest withSerialNumber(String serialNumber) {
+        this.serialNumber = serialNumber;
+        return this;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if MFA is required. If any policy
+     * requires the IAM user to submit an MFA code, specify this value. If MFA
+     * authentication is required, and the user does not provide a code when
+     * requesting a set of temporary security credentials, the user will receive
+     * an "access denied" response when requesting resources that require MFA
+     * authentication.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @return <p>
+     *         The value provided by the MFA device, if MFA is required. If any
+     *         policy requires the IAM user to submit an MFA code, specify this
+     *         value. If MFA authentication is required, and the user does not
+     *         provide a code when requesting a set of temporary security
+     *         credentials, the user will receive an "access denied" response
+     *         when requesting resources that require MFA authentication.
+     *         </p>
+     *         <p>
+     *         The format for this parameter, as described by its regex pattern,
+     *         is a sequence of six numeric digits.
+     *         </p>
+     */
+    public String getTokenCode() {
+        return tokenCode;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if MFA is required. If any policy
+     * requires the IAM user to submit an MFA code, specify this value. If MFA
+     * authentication is required, and the user does not provide a code when
+     * requesting a set of temporary security credentials, the user will receive
+     * an "access denied" response when requesting resources that require MFA
+     * authentication.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @param tokenCode <p>
+     *            The value provided by the MFA device, if MFA is required. If
+     *            any policy requires the IAM user to submit an MFA code,
+     *            specify this value. If MFA authentication is required, and the
+     *            user does not provide a code when requesting a set of
+     *            temporary security credentials, the user will receive an
+     *            "access denied" response when requesting resources that
+     *            require MFA authentication.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a sequence of six numeric digits.
+     *            </p>
+     */
+    public void setTokenCode(String tokenCode) {
+        this.tokenCode = tokenCode;
+    }
+
+    /**
+     * <p>
+     * The value provided by the MFA device, if MFA is required. If any policy
+     * requires the IAM user to submit an MFA code, specify this value. If MFA
+     * authentication is required, and the user does not provide a code when
+     * requesting a set of temporary security credentials, the user will receive
+     * an "access denied" response when requesting resources that require MFA
+     * authentication.
+     * </p>
+     * <p>
+     * The format for this parameter, as described by its regex pattern, is a
+     * sequence of six numeric digits.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     * <p>
+     * <b>Constraints:</b><br/>
+     * <b>Length: </b>6 - 6<br/>
+     * <b>Pattern: </b>[\d]*<br/>
+     *
+     * @param tokenCode <p>
+     *            The value provided by the MFA device, if MFA is required. If
+     *            any policy requires the IAM user to submit an MFA code,
+     *            specify this value. If MFA authentication is required, and the
+     *            user does not provide a code when requesting a set of
+     *            temporary security credentials, the user will receive an
+     *            "access denied" response when requesting resources that
+     *            require MFA authentication.
+     *            </p>
+     *            <p>
+     *            The format for this parameter, as described by its regex
+     *            pattern, is a sequence of six numeric digits.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetSessionTokenRequest withTokenCode(String tokenCode) {
+        this.tokenCode = tokenCode;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getDurationSeconds() != null)
+            sb.append("DurationSeconds: " + getDurationSeconds() + ",");
+        if (getSerialNumber() != null)
+            sb.append("SerialNumber: " + getSerialNumber() + ",");
+        if (getTokenCode() != null)
+            sb.append("TokenCode: " + getTokenCode());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getDurationSeconds() == null) ? 0 : getDurationSeconds().hashCode());
+        hashCode = prime * hashCode
+                + ((getSerialNumber() == null) ? 0 : getSerialNumber().hashCode());
+        hashCode = prime * hashCode + ((getTokenCode() == null) ? 0 : getTokenCode().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetSessionTokenRequest == false)
+            return false;
+        GetSessionTokenRequest other = (GetSessionTokenRequest) obj;
+
+        if (other.getDurationSeconds() == null ^ this.getDurationSeconds() == null)
+            return false;
+        if (other.getDurationSeconds() != null
+                && other.getDurationSeconds().equals(this.getDurationSeconds()) == false)
+            return false;
+        if (other.getSerialNumber() == null ^ this.getSerialNumber() == null)
+            return false;
+        if (other.getSerialNumber() != null
+                && other.getSerialNumber().equals(this.getSerialNumber()) == false)
+            return false;
+        if (other.getTokenCode() == null ^ this.getTokenCode() == null)
+            return false;
+        if (other.getTokenCode() != null
+                && other.getTokenCode().equals(this.getTokenCode()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenResult.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenResult.java
new file mode 100644
index 0000000000..31a9d97e71
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/GetSessionTokenResult.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import java.io.Serializable;
+
+/**
+ * <p>
+ * Contains the response to a successful <a>GetSessionToken</a> request,
+ * including temporary AWS credentials that can be used to make AWS requests.
+ * </p>
+ */
+public class GetSessionTokenResult implements Serializable {
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     */
+    private Credentials credentials;
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @return <p>
+     *         The temporary security credentials, which include an access key
+     *         ID, a secret access key, and a security (or session) token.
+     *         </p>
+     *         <p>
+     *         <b>Note:</b> The size of the security token that STS APIs return
+     *         is not fixed. We strongly recommend that you make no assumptions
+     *         about the maximum size. As of this writing, the typical size is
+     *         less than 4096 bytes, but that can vary. Also, future updates to
+     *         AWS might require larger sizes.
+     *         </p>
+     */
+    public Credentials getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     */
+    public void setCredentials(Credentials credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * <p>
+     * The temporary security credentials, which include an access key ID, a
+     * secret access key, and a security (or session) token.
+     * </p>
+     * <p>
+     * <b>Note:</b> The size of the security token that STS APIs return is not
+     * fixed. We strongly recommend that you make no assumptions about the
+     * maximum size. As of this writing, the typical size is less than 4096
+     * bytes, but that can vary. Also, future updates to AWS might require
+     * larger sizes.
+     * </p>
+     * <p>
+     * Returns a reference to this object so that method calls can be chained
+     * together.
+     *
+     * @param credentials <p>
+     *            The temporary security credentials, which include an access
+     *            key ID, a secret access key, and a security (or session)
+     *            token.
+     *            </p>
+     *            <p>
+     *            <b>Note:</b> The size of the security token that STS APIs
+     *            return is not fixed. We strongly recommend that you make no
+     *            assumptions about the maximum size. As of this writing, the
+     *            typical size is less than 4096 bytes, but that can vary. Also,
+     *            future updates to AWS might require larger sizes.
+     *            </p>
+     * @return A reference to this updated object so that method calls can be
+     *         chained together.
+     */
+    public GetSessionTokenResult withCredentials(Credentials credentials) {
+        this.credentials = credentials;
+        return this;
+    }
+
+    /**
+     * Returns a string representation of this object; useful for testing and
+     * debugging.
+     *
+     * @return A string representation of this object.
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("{");
+        if (getCredentials() != null)
+            sb.append("Credentials: " + getCredentials());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int hashCode = 1;
+
+        hashCode = prime * hashCode
+                + ((getCredentials() == null) ? 0 : getCredentials().hashCode());
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+
+        if (obj instanceof GetSessionTokenResult == false)
+            return false;
+        GetSessionTokenResult other = (GetSessionTokenResult) obj;
+
+        if (other.getCredentials() == null ^ this.getCredentials() == null)
+            return false;
+        if (other.getCredentials() != null
+                && other.getCredentials().equals(this.getCredentials()) == false)
+            return false;
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPCommunicationErrorException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPCommunicationErrorException.java
new file mode 100644
index 0000000000..a4b808aa79
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPCommunicationErrorException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The request could not be fulfilled because the non-AWS identity provider
+ * (IDP) that was asked to verify the incoming identity token could not be
+ * reached. This is often a transient error caused by network conditions. Retry
+ * the request a limited number of times so that you don't exceed the request
+ * rate. If the error persists, the non-AWS identity provider might be down or
+ * not responding.
+ * </p>
+ */
+public class IDPCommunicationErrorException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new IDPCommunicationErrorException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public IDPCommunicationErrorException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPRejectedClaimException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPRejectedClaimException.java
new file mode 100644
index 0000000000..1c24a9deec
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/IDPRejectedClaimException.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The identity provider (IdP) reported that authentication failed. This might
+ * be because the claim is invalid.
+ * </p>
+ * <p>
+ * If this error is returned for the <code>AssumeRoleWithWebIdentity</code>
+ * operation, it can also mean that the claim has expired or has been explicitly
+ * revoked.
+ * </p>
+ */
+public class IDPRejectedClaimException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new IDPRejectedClaimException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public IDPRejectedClaimException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/InvalidIdentityTokenException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/InvalidIdentityTokenException.java
new file mode 100644
index 0000000000..52b10c8895
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/InvalidIdentityTokenException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The web identity token that was passed could not be validated by AWS. Get a
+ * new identity token from the identity provider and then retry the request.
+ * </p>
+ */
+public class InvalidIdentityTokenException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new InvalidIdentityTokenException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public InvalidIdentityTokenException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/MalformedPolicyDocumentException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/MalformedPolicyDocumentException.java
new file mode 100644
index 0000000000..68924b98d9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/MalformedPolicyDocumentException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The request was rejected because the policy document was malformed. The error
+ * message describes the specific error.
+ * </p>
+ */
+public class MalformedPolicyDocumentException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new MalformedPolicyDocumentException with the specified
+     * error message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public MalformedPolicyDocumentException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/PackedPolicyTooLargeException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/PackedPolicyTooLargeException.java
new file mode 100644
index 0000000000..80bf8ad420
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/PackedPolicyTooLargeException.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * The request was rejected because the policy document was too large. The error
+ * message describes how big the policy document is, in packed form, as a
+ * percentage of what the API allows.
+ * </p>
+ */
+public class PackedPolicyTooLargeException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new PackedPolicyTooLargeException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public PackedPolicyTooLargeException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/RegionDisabledException.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/RegionDisabledException.java
new file mode 100644
index 0000000000..35bf008bf7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/RegionDisabledException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
+import com.amazonaws.AmazonServiceException;
+
+/**
+ * <p>
+ * STS is not activated in the requested region for the account that is being
+ * asked to generate credentials. The account administrator must use the IAM
+ * console to activate STS in that region. For more information, see <a href=
+ * "http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html"
+ * >Activating and Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
+ * Guide</i>.
+ * </p>
+ */
+public class RegionDisabledException extends AmazonServiceException {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new RegionDisabledException with the specified error
+     * message.
+     *
+     * @param message Describes the error encountered.
+     */
+    public RegionDisabledException(String message) {
+        super(message);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/package-info.java
new file mode 100644
index 0000000000..39a7b72709
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * Classes modeling the various types represented by AWSSecurityTokenService
+ */
+
+package com.amazonaws.services.securitytoken.model;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleRequestMarshaller.java
new file mode 100644
index 0000000000..1f40b99684
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleRequestMarshaller.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX request marshaller for AssumeRoleRequest
+ */
+public class AssumeRoleRequestMarshaller implements
+        Marshaller<Request<AssumeRoleRequest>, AssumeRoleRequest> {
+
+    public Request<AssumeRoleRequest> marshall(AssumeRoleRequest assumeRoleRequest) {
+        if (assumeRoleRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(AssumeRoleRequest)");
+        }
+
+        Request<AssumeRoleRequest> request = new DefaultRequest<AssumeRoleRequest>(
+                assumeRoleRequest, "AWSSecurityTokenService");
+        request.addParameter("Action", "AssumeRole");
+        request.addParameter("Version", "2011-06-15");
+
+        String prefix;
+        if (assumeRoleRequest.getRoleArn() != null) {
+            prefix = "RoleArn";
+            String roleArn = assumeRoleRequest.getRoleArn();
+            request.addParameter(prefix, StringUtils.fromString(roleArn));
+        }
+        if (assumeRoleRequest.getRoleSessionName() != null) {
+            prefix = "RoleSessionName";
+            String roleSessionName = assumeRoleRequest.getRoleSessionName();
+            request.addParameter(prefix, StringUtils.fromString(roleSessionName));
+        }
+        if (assumeRoleRequest.getPolicy() != null) {
+            prefix = "Policy";
+            String policy = assumeRoleRequest.getPolicy();
+            request.addParameter(prefix, StringUtils.fromString(policy));
+        }
+        if (assumeRoleRequest.getDurationSeconds() != null) {
+            prefix = "DurationSeconds";
+            Integer durationSeconds = assumeRoleRequest.getDurationSeconds();
+            request.addParameter(prefix, StringUtils.fromInteger(durationSeconds));
+        }
+        if (assumeRoleRequest.getExternalId() != null) {
+            prefix = "ExternalId";
+            String externalId = assumeRoleRequest.getExternalId();
+            request.addParameter(prefix, StringUtils.fromString(externalId));
+        }
+        if (assumeRoleRequest.getSerialNumber() != null) {
+            prefix = "SerialNumber";
+            String serialNumber = assumeRoleRequest.getSerialNumber();
+            request.addParameter(prefix, StringUtils.fromString(serialNumber));
+        }
+        if (assumeRoleRequest.getTokenCode() != null) {
+            prefix = "TokenCode";
+            String tokenCode = assumeRoleRequest.getTokenCode();
+            request.addParameter(prefix, StringUtils.fromString(tokenCode));
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleResultStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleResultStaxUnmarshaller.java
new file mode 100644
index 0000000000..40e76d407d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleResultStaxUnmarshaller.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for response AssumeRoleResult
+ */
+public class AssumeRoleResultStaxUnmarshaller implements
+        Unmarshaller<AssumeRoleResult, StaxUnmarshallerContext> {
+
+    public AssumeRoleResult unmarshall(StaxUnmarshallerContext context) throws Exception {
+        AssumeRoleResult assumeRoleResult = new AssumeRoleResult();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("Credentials", targetDepth)) {
+                    assumeRoleResult.setCredentials(CredentialsStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("AssumedRoleUser", targetDepth)) {
+                    assumeRoleResult.setAssumedRoleUser(AssumedRoleUserStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("PackedPolicySize", targetDepth)) {
+                    assumeRoleResult.setPackedPolicySize(IntegerStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return assumeRoleResult;
+    }
+
+    private static AssumeRoleResultStaxUnmarshaller instance;
+
+    public static AssumeRoleResultStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new AssumeRoleResultStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityRequestMarshaller.java
new file mode 100644
index 0000000000..f374333841
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityRequestMarshaller.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX request marshaller for AssumeRoleWithWebIdentityRequest
+ */
+public class AssumeRoleWithWebIdentityRequestMarshaller implements
+        Marshaller<Request<AssumeRoleWithWebIdentityRequest>, AssumeRoleWithWebIdentityRequest> {
+
+    public Request<AssumeRoleWithWebIdentityRequest> marshall(
+            AssumeRoleWithWebIdentityRequest assumeRoleWithWebIdentityRequest) {
+        if (assumeRoleWithWebIdentityRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(AssumeRoleWithWebIdentityRequest)");
+        }
+
+        Request<AssumeRoleWithWebIdentityRequest> request = new DefaultRequest<AssumeRoleWithWebIdentityRequest>(
+                assumeRoleWithWebIdentityRequest, "AWSSecurityTokenService");
+        request.addParameter("Action", "AssumeRoleWithWebIdentity");
+        request.addParameter("Version", "2011-06-15");
+
+        String prefix;
+        if (assumeRoleWithWebIdentityRequest.getRoleArn() != null) {
+            prefix = "RoleArn";
+            String roleArn = assumeRoleWithWebIdentityRequest.getRoleArn();
+            request.addParameter(prefix, StringUtils.fromString(roleArn));
+        }
+        if (assumeRoleWithWebIdentityRequest.getRoleSessionName() != null) {
+            prefix = "RoleSessionName";
+            String roleSessionName = assumeRoleWithWebIdentityRequest.getRoleSessionName();
+            request.addParameter(prefix, StringUtils.fromString(roleSessionName));
+        }
+        if (assumeRoleWithWebIdentityRequest.getWebIdentityToken() != null) {
+            prefix = "WebIdentityToken";
+            String webIdentityToken = assumeRoleWithWebIdentityRequest.getWebIdentityToken();
+            request.addParameter(prefix, StringUtils.fromString(webIdentityToken));
+        }
+        if (assumeRoleWithWebIdentityRequest.getProviderId() != null) {
+            prefix = "ProviderId";
+            String providerId = assumeRoleWithWebIdentityRequest.getProviderId();
+            request.addParameter(prefix, StringUtils.fromString(providerId));
+        }
+        if (assumeRoleWithWebIdentityRequest.getPolicy() != null) {
+            prefix = "Policy";
+            String policy = assumeRoleWithWebIdentityRequest.getPolicy();
+            request.addParameter(prefix, StringUtils.fromString(policy));
+        }
+        if (assumeRoleWithWebIdentityRequest.getDurationSeconds() != null) {
+            prefix = "DurationSeconds";
+            Integer durationSeconds = assumeRoleWithWebIdentityRequest.getDurationSeconds();
+            request.addParameter(prefix, StringUtils.fromInteger(durationSeconds));
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityResultStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityResultStaxUnmarshaller.java
new file mode 100644
index 0000000000..31a8883948
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumeRoleWithWebIdentityResultStaxUnmarshaller.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for response AssumeRoleWithWebIdentityResult
+ */
+public class AssumeRoleWithWebIdentityResultStaxUnmarshaller implements
+        Unmarshaller<AssumeRoleWithWebIdentityResult, StaxUnmarshallerContext> {
+
+    public AssumeRoleWithWebIdentityResult unmarshall(StaxUnmarshallerContext context)
+            throws Exception {
+        AssumeRoleWithWebIdentityResult assumeRoleWithWebIdentityResult = new AssumeRoleWithWebIdentityResult();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("Credentials", targetDepth)) {
+                    assumeRoleWithWebIdentityResult.setCredentials(CredentialsStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("SubjectFromWebIdentityToken", targetDepth)) {
+                    assumeRoleWithWebIdentityResult
+                            .setSubjectFromWebIdentityToken(StringStaxUnmarshaller.getInstance()
+                                    .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("AssumedRoleUser", targetDepth)) {
+                    assumeRoleWithWebIdentityResult
+                            .setAssumedRoleUser(AssumedRoleUserStaxUnmarshaller.getInstance()
+                                    .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("PackedPolicySize", targetDepth)) {
+                    assumeRoleWithWebIdentityResult.setPackedPolicySize(IntegerStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Provider", targetDepth)) {
+                    assumeRoleWithWebIdentityResult.setProvider(StringStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Audience", targetDepth)) {
+                    assumeRoleWithWebIdentityResult.setAudience(StringStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return assumeRoleWithWebIdentityResult;
+    }
+
+    private static AssumeRoleWithWebIdentityResultStaxUnmarshaller instance;
+
+    public static AssumeRoleWithWebIdentityResultStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new AssumeRoleWithWebIdentityResultStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxMarshaller.java
new file mode 100644
index 0000000000..fda6f8c004
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxMarshaller.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.Request;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX marshaller for POJO AssumedRoleUser
+ */
+class AssumedRoleUserStaxMarshaller {
+
+    public void marshall(AssumedRoleUser _assumedRoleUser, Request<?> request, String _prefix) {
+        String prefix;
+        if (_assumedRoleUser.getAssumedRoleId() != null) {
+            prefix = _prefix + "AssumedRoleId";
+            String assumedRoleId = _assumedRoleUser.getAssumedRoleId();
+            request.addParameter(prefix, StringUtils.fromString(assumedRoleId));
+        }
+        if (_assumedRoleUser.getArn() != null) {
+            prefix = _prefix + "Arn";
+            String arn = _assumedRoleUser.getArn();
+            request.addParameter(prefix, StringUtils.fromString(arn));
+        }
+    }
+
+    private static AssumedRoleUserStaxMarshaller instance;
+
+    public static AssumedRoleUserStaxMarshaller getInstance() {
+        if (instance == null)
+            instance = new AssumedRoleUserStaxMarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxUnmarshaller.java
new file mode 100644
index 0000000000..5a92892817
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/AssumedRoleUserStaxUnmarshaller.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for model AssumedRoleUser
+ */
+class AssumedRoleUserStaxUnmarshaller implements
+        Unmarshaller<AssumedRoleUser, StaxUnmarshallerContext> {
+
+    public AssumedRoleUser unmarshall(StaxUnmarshallerContext context) throws Exception {
+        AssumedRoleUser assumedRoleUser = new AssumedRoleUser();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("AssumedRoleId", targetDepth)) {
+                    assumedRoleUser.setAssumedRoleId(StringStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Arn", targetDepth)) {
+                    assumedRoleUser
+                            .setArn(StringStaxUnmarshaller.getInstance().unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return assumedRoleUser;
+    }
+
+    private static AssumedRoleUserStaxUnmarshaller instance;
+
+    public static AssumedRoleUserStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new AssumedRoleUserStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxMarshaller.java
new file mode 100644
index 0000000000..7be8c5af39
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxMarshaller.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.Request;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX marshaller for POJO Credentials
+ */
+class CredentialsStaxMarshaller {
+
+    public void marshall(Credentials _credentials, Request<?> request, String _prefix) {
+        String prefix;
+        if (_credentials.getAccessKeyId() != null) {
+            prefix = _prefix + "AccessKeyId";
+            String accessKeyId = _credentials.getAccessKeyId();
+            request.addParameter(prefix, StringUtils.fromString(accessKeyId));
+        }
+        if (_credentials.getSecretAccessKey() != null) {
+            prefix = _prefix + "SecretAccessKey";
+            String secretAccessKey = _credentials.getSecretAccessKey();
+            request.addParameter(prefix, StringUtils.fromString(secretAccessKey));
+        }
+        if (_credentials.getSessionToken() != null) {
+            prefix = _prefix + "SessionToken";
+            String sessionToken = _credentials.getSessionToken();
+            request.addParameter(prefix, StringUtils.fromString(sessionToken));
+        }
+        if (_credentials.getExpiration() != null) {
+            prefix = _prefix + "Expiration";
+            java.util.Date expiration = _credentials.getExpiration();
+            request.addParameter(prefix, StringUtils.fromDate(expiration));
+        }
+    }
+
+    private static CredentialsStaxMarshaller instance;
+
+    public static CredentialsStaxMarshaller getInstance() {
+        if (instance == null)
+            instance = new CredentialsStaxMarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxUnmarshaller.java
new file mode 100644
index 0000000000..d041f7ee3c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/CredentialsStaxUnmarshaller.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for model Credentials
+ */
+class CredentialsStaxUnmarshaller implements Unmarshaller<Credentials, StaxUnmarshallerContext> {
+
+    public Credentials unmarshall(StaxUnmarshallerContext context) throws Exception {
+        Credentials credentials = new Credentials();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("AccessKeyId", targetDepth)) {
+                    credentials.setAccessKeyId(StringStaxUnmarshaller.getInstance().unmarshall(
+                            context));
+                    continue;
+                }
+                if (context.testExpression("SecretAccessKey", targetDepth)) {
+                    credentials.setSecretAccessKey(StringStaxUnmarshaller.getInstance().unmarshall(
+                            context));
+                    continue;
+                }
+                if (context.testExpression("SessionToken", targetDepth)) {
+                    credentials.setSessionToken(StringStaxUnmarshaller.getInstance().unmarshall(
+                            context));
+                    continue;
+                }
+                if (context.testExpression("Expiration", targetDepth)) {
+                    credentials.setExpiration(DateStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return credentials;
+    }
+
+    private static CredentialsStaxUnmarshaller instance;
+
+    public static CredentialsStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new CredentialsStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/ExpiredTokenExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/ExpiredTokenExceptionUnmarshaller.java
new file mode 100644
index 0000000000..093c2d8eb9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/ExpiredTokenExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.ExpiredTokenException;
+
+public class ExpiredTokenExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public ExpiredTokenExceptionUnmarshaller() {
+        super(ExpiredTokenException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("ExpiredTokenException"))
+            return null;
+
+        ExpiredTokenException e = (ExpiredTokenException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxMarshaller.java
new file mode 100644
index 0000000000..b1b7099b3f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxMarshaller.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.Request;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX marshaller for POJO FederatedUser
+ */
+class FederatedUserStaxMarshaller {
+
+    public void marshall(FederatedUser _federatedUser, Request<?> request, String _prefix) {
+        String prefix;
+        if (_federatedUser.getFederatedUserId() != null) {
+            prefix = _prefix + "FederatedUserId";
+            String federatedUserId = _federatedUser.getFederatedUserId();
+            request.addParameter(prefix, StringUtils.fromString(federatedUserId));
+        }
+        if (_federatedUser.getArn() != null) {
+            prefix = _prefix + "Arn";
+            String arn = _federatedUser.getArn();
+            request.addParameter(prefix, StringUtils.fromString(arn));
+        }
+    }
+
+    private static FederatedUserStaxMarshaller instance;
+
+    public static FederatedUserStaxMarshaller getInstance() {
+        if (instance == null)
+            instance = new FederatedUserStaxMarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxUnmarshaller.java
new file mode 100644
index 0000000000..c35db9ba19
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/FederatedUserStaxUnmarshaller.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for model FederatedUser
+ */
+class FederatedUserStaxUnmarshaller implements Unmarshaller<FederatedUser, StaxUnmarshallerContext> {
+
+    public FederatedUser unmarshall(StaxUnmarshallerContext context) throws Exception {
+        FederatedUser federatedUser = new FederatedUser();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("FederatedUserId", targetDepth)) {
+                    federatedUser.setFederatedUserId(StringStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Arn", targetDepth)) {
+                    federatedUser.setArn(StringStaxUnmarshaller.getInstance().unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return federatedUser;
+    }
+
+    private static FederatedUserStaxUnmarshaller instance;
+
+    public static FederatedUserStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new FederatedUserStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityRequestMarshaller.java
new file mode 100644
index 0000000000..68c27772d4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityRequestMarshaller.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX request marshaller for GetCallerIdentityRequest
+ */
+public class GetCallerIdentityRequestMarshaller implements
+        Marshaller<Request<GetCallerIdentityRequest>, GetCallerIdentityRequest> {
+
+    public Request<GetCallerIdentityRequest> marshall(
+            GetCallerIdentityRequest getCallerIdentityRequest) {
+        if (getCallerIdentityRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(GetCallerIdentityRequest)");
+        }
+
+        Request<GetCallerIdentityRequest> request = new DefaultRequest<GetCallerIdentityRequest>(
+                getCallerIdentityRequest, "AWSSecurityTokenService");
+        request.addParameter("Action", "GetCallerIdentity");
+        request.addParameter("Version", "2011-06-15");
+
+        String prefix;
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityResultStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityResultStaxUnmarshaller.java
new file mode 100644
index 0000000000..cd6f86f0ee
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetCallerIdentityResultStaxUnmarshaller.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for response GetCallerIdentityResult
+ */
+public class GetCallerIdentityResultStaxUnmarshaller implements
+        Unmarshaller<GetCallerIdentityResult, StaxUnmarshallerContext> {
+
+    public GetCallerIdentityResult unmarshall(StaxUnmarshallerContext context) throws Exception {
+        GetCallerIdentityResult getCallerIdentityResult = new GetCallerIdentityResult();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("UserId", targetDepth)) {
+                    getCallerIdentityResult.setUserId(StringStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Account", targetDepth)) {
+                    getCallerIdentityResult.setAccount(StringStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("Arn", targetDepth)) {
+                    getCallerIdentityResult.setArn(StringStaxUnmarshaller.getInstance().unmarshall(
+                            context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return getCallerIdentityResult;
+    }
+
+    private static GetCallerIdentityResultStaxUnmarshaller instance;
+
+    public static GetCallerIdentityResultStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetCallerIdentityResultStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenRequestMarshaller.java
new file mode 100644
index 0000000000..5d7062da98
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenRequestMarshaller.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX request marshaller for GetFederationTokenRequest
+ */
+public class GetFederationTokenRequestMarshaller implements
+        Marshaller<Request<GetFederationTokenRequest>, GetFederationTokenRequest> {
+
+    public Request<GetFederationTokenRequest> marshall(
+            GetFederationTokenRequest getFederationTokenRequest) {
+        if (getFederationTokenRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(GetFederationTokenRequest)");
+        }
+
+        Request<GetFederationTokenRequest> request = new DefaultRequest<GetFederationTokenRequest>(
+                getFederationTokenRequest, "AWSSecurityTokenService");
+        request.addParameter("Action", "GetFederationToken");
+        request.addParameter("Version", "2011-06-15");
+
+        String prefix;
+        if (getFederationTokenRequest.getName() != null) {
+            prefix = "Name";
+            String name = getFederationTokenRequest.getName();
+            request.addParameter(prefix, StringUtils.fromString(name));
+        }
+        if (getFederationTokenRequest.getPolicy() != null) {
+            prefix = "Policy";
+            String policy = getFederationTokenRequest.getPolicy();
+            request.addParameter(prefix, StringUtils.fromString(policy));
+        }
+        if (getFederationTokenRequest.getDurationSeconds() != null) {
+            prefix = "DurationSeconds";
+            Integer durationSeconds = getFederationTokenRequest.getDurationSeconds();
+            request.addParameter(prefix, StringUtils.fromInteger(durationSeconds));
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenResultStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenResultStaxUnmarshaller.java
new file mode 100644
index 0000000000..34fabd5a0c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetFederationTokenResultStaxUnmarshaller.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for response GetFederationTokenResult
+ */
+public class GetFederationTokenResultStaxUnmarshaller implements
+        Unmarshaller<GetFederationTokenResult, StaxUnmarshallerContext> {
+
+    public GetFederationTokenResult unmarshall(StaxUnmarshallerContext context) throws Exception {
+        GetFederationTokenResult getFederationTokenResult = new GetFederationTokenResult();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("Credentials", targetDepth)) {
+                    getFederationTokenResult.setCredentials(CredentialsStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("FederatedUser", targetDepth)) {
+                    getFederationTokenResult.setFederatedUser(FederatedUserStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+                if (context.testExpression("PackedPolicySize", targetDepth)) {
+                    getFederationTokenResult.setPackedPolicySize(IntegerStaxUnmarshaller
+                            .getInstance().unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return getFederationTokenResult;
+    }
+
+    private static GetFederationTokenResultStaxUnmarshaller instance;
+
+    public static GetFederationTokenResultStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetFederationTokenResultStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenRequestMarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenRequestMarshaller.java
new file mode 100644
index 0000000000..071d3576db
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenRequestMarshaller.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.Request;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Marshaller;
+import com.amazonaws.util.StringUtils;
+
+/**
+ * StAX request marshaller for GetSessionTokenRequest
+ */
+public class GetSessionTokenRequestMarshaller implements
+        Marshaller<Request<GetSessionTokenRequest>, GetSessionTokenRequest> {
+
+    public Request<GetSessionTokenRequest> marshall(GetSessionTokenRequest getSessionTokenRequest) {
+        if (getSessionTokenRequest == null) {
+            throw new AmazonClientException(
+                    "Invalid argument passed to marshall(GetSessionTokenRequest)");
+        }
+
+        Request<GetSessionTokenRequest> request = new DefaultRequest<GetSessionTokenRequest>(
+                getSessionTokenRequest, "AWSSecurityTokenService");
+        request.addParameter("Action", "GetSessionToken");
+        request.addParameter("Version", "2011-06-15");
+
+        String prefix;
+        if (getSessionTokenRequest.getDurationSeconds() != null) {
+            prefix = "DurationSeconds";
+            Integer durationSeconds = getSessionTokenRequest.getDurationSeconds();
+            request.addParameter(prefix, StringUtils.fromInteger(durationSeconds));
+        }
+        if (getSessionTokenRequest.getSerialNumber() != null) {
+            prefix = "SerialNumber";
+            String serialNumber = getSessionTokenRequest.getSerialNumber();
+            request.addParameter(prefix, StringUtils.fromString(serialNumber));
+        }
+        if (getSessionTokenRequest.getTokenCode() != null) {
+            prefix = "TokenCode";
+            String tokenCode = getSessionTokenRequest.getTokenCode();
+            request.addParameter(prefix, StringUtils.fromString(tokenCode));
+        }
+
+        return request;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenResultStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenResultStaxUnmarshaller.java
new file mode 100644
index 0000000000..b181566480
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/GetSessionTokenResultStaxUnmarshaller.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import com.amazonaws.services.securitytoken.model.*;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.transform.MapEntry;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;
+
+/**
+ * StAX unmarshaller for response GetSessionTokenResult
+ */
+public class GetSessionTokenResultStaxUnmarshaller implements
+        Unmarshaller<GetSessionTokenResult, StaxUnmarshallerContext> {
+
+    public GetSessionTokenResult unmarshall(StaxUnmarshallerContext context) throws Exception {
+        GetSessionTokenResult getSessionTokenResult = new GetSessionTokenResult();
+
+        int originalDepth = context.getCurrentDepth();
+        int targetDepth = originalDepth + 1;
+
+        if (context.isStartOfDocument())
+            targetDepth += 2;
+
+        while (true) {
+            int xmlEvent = context.nextEvent();
+            if (xmlEvent == XmlPullParser.END_DOCUMENT)
+                break;
+
+            if (xmlEvent == XmlPullParser.START_TAG) {
+                if (context.testExpression("Credentials", targetDepth)) {
+                    getSessionTokenResult.setCredentials(CredentialsStaxUnmarshaller.getInstance()
+                            .unmarshall(context));
+                    continue;
+                }
+            } else if (xmlEvent == XmlPullParser.END_TAG) {
+                if (context.getCurrentDepth() < originalDepth) {
+                    break;
+                }
+            }
+        }
+        return getSessionTokenResult;
+    }
+
+    private static GetSessionTokenResultStaxUnmarshaller instance;
+
+    public static GetSessionTokenResultStaxUnmarshaller getInstance() {
+        if (instance == null)
+            instance = new GetSessionTokenResultStaxUnmarshaller();
+        return instance;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPCommunicationErrorExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPCommunicationErrorExceptionUnmarshaller.java
new file mode 100644
index 0000000000..667e5ae206
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPCommunicationErrorExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.IDPCommunicationErrorException;
+
+public class IDPCommunicationErrorExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public IDPCommunicationErrorExceptionUnmarshaller() {
+        super(IDPCommunicationErrorException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("IDPCommunicationError"))
+            return null;
+
+        IDPCommunicationErrorException e = (IDPCommunicationErrorException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPRejectedClaimExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPRejectedClaimExceptionUnmarshaller.java
new file mode 100644
index 0000000000..3e91dc150d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/IDPRejectedClaimExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.IDPRejectedClaimException;
+
+public class IDPRejectedClaimExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public IDPRejectedClaimExceptionUnmarshaller() {
+        super(IDPRejectedClaimException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("IDPRejectedClaim"))
+            return null;
+
+        IDPRejectedClaimException e = (IDPRejectedClaimException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/InvalidIdentityTokenExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/InvalidIdentityTokenExceptionUnmarshaller.java
new file mode 100644
index 0000000000..dac4b371ec
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/InvalidIdentityTokenExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.InvalidIdentityTokenException;
+
+public class InvalidIdentityTokenExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public InvalidIdentityTokenExceptionUnmarshaller() {
+        super(InvalidIdentityTokenException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("InvalidIdentityToken"))
+            return null;
+
+        InvalidIdentityTokenException e = (InvalidIdentityTokenException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/MalformedPolicyDocumentExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/MalformedPolicyDocumentExceptionUnmarshaller.java
new file mode 100644
index 0000000000..0592792ce9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/MalformedPolicyDocumentExceptionUnmarshaller.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.MalformedPolicyDocumentException;
+
+public class MalformedPolicyDocumentExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public MalformedPolicyDocumentExceptionUnmarshaller() {
+        super(MalformedPolicyDocumentException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("MalformedPolicyDocument"))
+            return null;
+
+        MalformedPolicyDocumentException e = (MalformedPolicyDocumentException) super
+                .unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/PackedPolicyTooLargeExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/PackedPolicyTooLargeExceptionUnmarshaller.java
new file mode 100644
index 0000000000..5fce3a8e26
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/PackedPolicyTooLargeExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.PackedPolicyTooLargeException;
+
+public class PackedPolicyTooLargeExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public PackedPolicyTooLargeExceptionUnmarshaller() {
+        super(PackedPolicyTooLargeException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("PackedPolicyTooLarge"))
+            return null;
+
+        PackedPolicyTooLargeException e = (PackedPolicyTooLargeException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/RegionDisabledExceptionUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/RegionDisabledExceptionUnmarshaller.java
new file mode 100644
index 0000000000..2bdf217c29
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/RegionDisabledExceptionUnmarshaller.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
+import org.w3c.dom.Node;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.util.XpathUtils;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+
+import com.amazonaws.services.securitytoken.model.RegionDisabledException;
+
+public class RegionDisabledExceptionUnmarshaller extends StandardErrorUnmarshaller {
+
+    public RegionDisabledExceptionUnmarshaller() {
+        super(RegionDisabledException.class);
+    }
+
+    public AmazonServiceException unmarshall(Node node) throws Exception {
+        // Bail out if this isn't the right error code that this
+        // marshaller understands.
+        String errorCode = parseErrorCode(node);
+        if (errorCode == null || !errorCode.equals("RegionDisabledException"))
+            return null;
+
+        RegionDisabledException e = (RegionDisabledException) super.unmarshall(node);
+
+        return e;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/package-info.java
new file mode 100644
index 0000000000..594fa97f0d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/model/transform/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * Marhsalling for the various types represented byAWSSecurityTokenService
+ */
+
+package com.amazonaws.services.securitytoken.model.transform;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/package-info.java b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/package-info.java
new file mode 100644
index 0000000000..98aa5737a5
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/services/securitytoken/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * <fullname>AWS Security Token Service</fullname> <p>The AWS Security Token Service (STS) is a web service that enables you to request temporary, limited-privilege credentials for AWS Identity and Access Management (IAM) users or for users that you authenticate (federated users). This guide provides descriptions of the STS API. For more detailed information about using this service, go to <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Temporary Security Credentials</a>. </p> <note> <p> As an alternative to using the API, you can use one of the AWS SDKs, which consist of libraries and sample code for various programming languages and platforms (Java, Ruby, .NET, iOS, Android, etc.). The SDKs provide a convenient way to create programmatic access to STS. For example, the SDKs take care of cryptographically signing requests, managing errors, and retrying requests automatically. For information about the AWS SDKs, including how to download and install them, see the <a href="http://aws.amazon.com/tools/">Tools for Amazon Web Services page</a>. </p> </note> <p>For information about setting up signatures and authorization through the API, go to <a href="http://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html">Signing AWS API Requests</a> in the <i>AWS General Reference</i>. For general information about the Query API, go to <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/IAM_UsingQueryAPI.html">Making Query Requests</a> in <i>Using IAM</i>. For information about using security tokens with other AWS products, go to <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">AWS Services That Work with IAM</a> in the <i>IAM User Guide</i>. </p> <p>If you're new to AWS and need additional technical information about a specific AWS product, you can find the product's technical documentation at <a href="http://aws.amazon.com/documentation/">http://aws.amazon.com/documentation/</a>. </p> <p> <b>Endpoints</b> </p> <p>The AWS Security Token Service (STS) has a default endpoint of https://sts.amazonaws.com that maps to the US East (N. Virginia) region. Additional regions are available and are activated by default. For more information, see <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and Deactivating AWS STS in an AWS Region</a> in the <i>IAM User Guide</i>.</p> <p>For information about STS endpoints, see <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#sts_region">Regions and Endpoints</a> in the <i>AWS General Reference</i>.</p> <p> <b>Recording API requests</b> </p> <p>STS supports AWS CloudTrail, which is a service that records AWS calls for your AWS account and delivers log files to an Amazon S3 bucket. By using information collected by CloudTrail, you can determine what requests were successfully made to STS, who made the request, when it was made, and so on. To learn more about CloudTrail, including how to turn it on and find your log files, see the <a href="http://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">AWS CloudTrail User Guide</a>.</p>
+ */
+
+package com.amazonaws.services.securitytoken;
+
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/AbstractErrorUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/AbstractErrorUnmarshaller.java
new file mode 100644
index 0000000000..4f781b81ba
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/AbstractErrorUnmarshaller.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.AmazonServiceException;
+
+import java.lang.reflect.Constructor;
+
+/** Abstract class for error unmarshaller.
+ * @param <T> the AbstractErrorUnmarshaller type.
+ */
+public abstract class AbstractErrorUnmarshaller<T> implements
+        Unmarshaller<AmazonServiceException, T> {
+
+    /**
+     * The type of AmazonServiceException that will be instantiated. Subclasses
+     * specialized for a specific type of exception can control this through the
+     * protected constructor.
+     */
+    protected final Class<? extends AmazonServiceException> exceptionClass;
+
+    /**
+     * Constructs a new error unmarshaller that will unmarshall error responses
+     * into AmazonServiceException objects.
+     */
+    public AbstractErrorUnmarshaller() {
+        this(AmazonServiceException.class);
+    }
+
+    /**
+     * Constructs a new error unmarshaller that will unmarshall error responses
+     * into objects of the specified class, extending AmazonServiceException.
+     *
+     * @param exceptionClass The subclass of AmazonServiceException which will
+     *            be instantiated and populated by this class.
+     */
+    public AbstractErrorUnmarshaller(Class<? extends AmazonServiceException> exceptionClass) {
+        this.exceptionClass = exceptionClass;
+    }
+
+    /**
+     * Constructs a new exception object of the type specified in this class's
+     * constructor and sets the specified error message.
+     *
+     * @param message The error message to set in the new exception object.
+     * @return A new exception object of the type specified in this class's
+     *         constructor and sets the specified error message.
+     * @throws Exception If there are any problems using reflection to invoke the
+     *             exception class's constructor.
+     */
+    protected AmazonServiceException newException(String message) throws Exception {
+        Constructor<? extends AmazonServiceException> constructor = exceptionClass
+                .getConstructor(String.class);
+        return constructor.newInstance(message);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonErrorUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonErrorUnmarshaller.java
new file mode 100644
index 0000000000..177535bccd
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonErrorUnmarshaller.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+
+/**
+ * Unmarshaller for JSON error responses from AWS services.
+ */
+public class JsonErrorUnmarshaller extends AbstractErrorUnmarshaller<JsonErrorResponse> {
+
+    /** Constructor. */
+    public JsonErrorUnmarshaller() {
+    }
+
+    protected JsonErrorUnmarshaller(Class<? extends AmazonServiceException> exceptionClass) {
+        super(exceptionClass);
+    }
+
+    /**
+     * Subclass should override the match(String, JSONObject) method to indicate
+     * whether it represents the given error type, and unmarshall(JSONObject)
+     * should never return null.
+     */
+    @Override
+    public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+        String message = error.getMessage();
+        String errorCode = error.getErrorCode();
+
+        if ((null == message || message.isEmpty()) && (null == errorCode || errorCode.isEmpty())) {
+            /**
+             * Trigger the catch block in AmazonHttpClient.handleErrorResponse
+             * to handle 413 and 503 errors
+             */
+            throw new AmazonClientException(
+                    "Neither error message nor error code is found in the error response payload.");
+        } else {
+            AmazonServiceException ase = newException(message);
+            ase.setErrorCode(errorCode);
+            return ase;
+        }
+    }
+
+    /**
+     * Any subclass that is specific to a error type should only return true
+     * when the response matches, either by matching the error type parsed from
+     * header or from the JSON content.
+     *
+     * @param error The JSON content of the response. Subclass should check for
+     *            the error type information from this JSONObject if
+     *            errorTypeFromHeader is null.
+     * @return true.
+     */
+    public boolean match(JsonErrorResponse error) throws Exception {
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonUnmarshallerContext.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonUnmarshallerContext.java
new file mode 100644
index 0000000000..209f06ee66
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/JsonUnmarshallerContext.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.http.HttpResponse;
+import com.amazonaws.util.json.AwsJsonReader;
+
+/** JsonUnmarshallerContext class. */
+public class JsonUnmarshallerContext {
+
+    private final AwsJsonReader reader;
+    private final HttpResponse httpResponse;
+
+    /**
+     * Constructor.
+     * @param reader the AwsJsonReader.
+     */
+    public JsonUnmarshallerContext(AwsJsonReader reader) {
+        this(reader, null);
+    }
+
+    /**
+     * Constructor.
+     * @param reader the AwsJsonReader.
+     * @param httpResponse the HTTP response.
+     */
+    public JsonUnmarshallerContext(AwsJsonReader reader, HttpResponse httpResponse) {
+        this.reader = reader;
+        this.httpResponse = httpResponse;
+    }
+
+    /**
+     * @return the AwsJsonReader.
+     */
+    public AwsJsonReader getReader() {
+        return reader;
+    }
+
+    /**
+     * Returns the value of the header with the specified name from the
+     * response, or null if not present.
+     *
+     * @param header The name of the header to lookup.
+     * @return The value of the header with the specified name from the response,
+     *         or null if not present.
+     */
+    public String getHeader(String header) {
+        if (httpResponse == null)
+            return null;
+
+        return httpResponse.getHeaders().get(header);
+    }
+
+    /**
+     * @return the HTTP response.
+     */
+    public HttpResponse getHttpResponse() {
+        return httpResponse;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/LegacyErrorUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/LegacyErrorUnmarshaller.java
new file mode 100644
index 0000000000..29fbac3891
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/LegacyErrorUnmarshaller.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.util.XpathUtils;
+
+import org.w3c.dom.Node;
+
+import java.lang.reflect.Constructor;
+
+/**
+ * Unmarshalls an AWS error response into an AmazonServiceException, or
+ * optionally, a subclass of AmazonServiceException if this class is extended.
+ */
+public class LegacyErrorUnmarshaller implements Unmarshaller<AmazonServiceException, Node> {
+    /**
+     * The type of AmazonServiceException that will be instantiated. Subclasses
+     * specialized for a specific type of exception can control this through the
+     * protected constructor.
+     */
+    private final Class<? extends AmazonServiceException> exceptionClass;
+
+    /**
+     * Constructs a new unmarshaller that will unmarshall AWS error responses as
+     * a generic AmazonServiceException object.
+     */
+    public LegacyErrorUnmarshaller() {
+        this(AmazonServiceException.class);
+    }
+
+    /**
+     * Constructor allowing subclasses to specify a specific type of
+     * AmazonServiceException to instantiating when populating the exception
+     * object with data from the AWS error response.
+     *
+     * @param exceptionClass The class of AmazonServiceException to create and
+     *            populate when unmarshalling the AWS error response.
+     */
+    protected LegacyErrorUnmarshaller(Class<? extends AmazonServiceException> exceptionClass) {
+        this.exceptionClass = exceptionClass;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.amazonaws.transform.Unmarshaller#unmarshall(java.lang.Object)
+     */
+    @Override
+    public AmazonServiceException unmarshall(Node in) throws Exception {
+        String errorCode = parseErrorCode(in);
+        String message = XpathUtils.asString("Response/Errors/Error/Message", in);
+        String requestId = XpathUtils.asString("Response/RequestID", in);
+        String errorType = XpathUtils.asString("Response/Errors/Error/Type", in);
+
+        Constructor<? extends AmazonServiceException> constructor = exceptionClass
+                .getConstructor(String.class);
+        AmazonServiceException ase = constructor.newInstance(message);
+        ase.setErrorCode(errorCode);
+        ase.setRequestId(requestId);
+
+        if (errorType == null) {
+            ase.setErrorType(ErrorType.Unknown);
+        } else if ("server".equalsIgnoreCase(errorType)) {
+            ase.setErrorType(ErrorType.Service);
+        } else if ("client".equalsIgnoreCase(errorType)) {
+            ase.setErrorType(ErrorType.Client);
+        }
+
+        return ase;
+    }
+
+    /**
+     * Returns the AWS error code for the specified error response.
+     *
+     * @param in The DOM tree node containing the error response.
+     * @return The AWS error code contained in the specified error response.
+     * @throws Exception If any problems were encountered pulling out the AWS
+     *             error code.
+     */
+    public String parseErrorCode(Node in) throws Exception {
+        return XpathUtils.asString("Response/Errors/Error/Code", in);
+    }
+
+    /**
+     * Returns the path to the specified property within an error response.
+     *
+     * @param property The name of the desired property.
+     * @return The path to the specified property within an error message.
+     */
+    public String getErrorPropertyPath(String property) {
+        return "Response/Errors/Error/" + property;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/ListUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/ListUnmarshaller.java
new file mode 100644
index 0000000000..f9dfcc3833
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/ListUnmarshaller.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.AwsJsonToken;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/***
+ * The ListUnmarshaller class.
+ * @param <T> the class type.
+ */
+public class ListUnmarshaller<T>
+        implements Unmarshaller<List<T>, JsonUnmarshallerContext> {
+
+    private final Unmarshaller<T, JsonUnmarshallerContext> itemUnmarshaller;
+
+    /**
+     * Constructor.
+     * @param itemUnmarshaller the item unmarshaller.
+     */
+    public ListUnmarshaller(
+            Unmarshaller<T, JsonUnmarshallerContext> itemUnmarshaller) {
+        this.itemUnmarshaller = itemUnmarshaller;
+    }
+
+    @Override
+    public List<T> unmarshall(JsonUnmarshallerContext context)
+            throws Exception {
+
+        AwsJsonReader reader = context.getReader();
+        if (reader.peek() == AwsJsonToken.VALUE_NULL) {
+            reader.skipValue();
+            return null;
+        }
+
+        List<T> list = new ArrayList<T>();
+
+        reader.beginArray();
+        while (reader.hasNext()) {
+            list.add(itemUnmarshaller.unmarshall(context));
+        }
+        reader.endArray();
+
+        return list;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapEntry.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapEntry.java
new file mode 100644
index 0000000000..e082650f99
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapEntry.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import java.util.Map;
+
+/**
+ * Simple implementation of the Map.Entry interface.
+ *
+ * @param <K> The type of the key held in this map entry.
+ * @param <V> The type of the value held in this map entry.
+ */
+public class MapEntry<K, V> implements Map.Entry<K, V> {
+    private K key;
+    private V value;
+
+    /*
+     * (non-Javadoc)
+     * @see java.util.Map.Entry#getKey()
+     */
+    @Override
+    public K getKey() {
+        return key;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.util.Map.Entry#getValue()
+     */
+    @Override
+    public V getValue() {
+        return value;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.util.Map.Entry#setValue(java.lang.Object)
+     */
+    @Override
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public V setValue(V value) {
+        this.value = value;
+        return this.value;
+    }
+
+    /**
+     * @param key the key.
+     * @return key object.
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public K setKey(K key) {
+        this.key = key;
+        return this.key;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapUnmarshaller.java
new file mode 100644
index 0000000000..b7d393c3fb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/MapUnmarshaller.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.AwsJsonToken;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * MapUnmarshaller class.
+ * @param <V> value type.
+ */
+public class MapUnmarshaller<V> implements Unmarshaller<Map<String, V>, JsonUnmarshallerContext> {
+
+    private final Unmarshaller<V, JsonUnmarshallerContext> valueUnmarshaller;
+
+    /**
+     * Constructor.
+     * @param valueUnmarshaller the value unmarshaller.
+     */
+    public MapUnmarshaller(Unmarshaller<V, JsonUnmarshallerContext> valueUnmarshaller) {
+        this.valueUnmarshaller = valueUnmarshaller;
+    }
+
+    @Override
+    public Map<String, V> unmarshall(JsonUnmarshallerContext context) throws Exception {
+        AwsJsonReader reader = context.getReader();
+        if (reader.peek() == AwsJsonToken.VALUE_NULL) {
+            reader.skipValue();
+            return null;
+        }
+
+        Map<String, V> map = new HashMap<String, V>();
+
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String key = reader.nextName();
+            V v = valueUnmarshaller.unmarshall(context);
+            map.put(key, v);
+        }
+        reader.endObject();
+
+        return map;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Marshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Marshaller.java
new file mode 100644
index 0000000000..7d3a9a67d9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Marshaller.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+/**
+ * Marshaller class.
+ * @param <T> type.
+ * @param <R> type.
+ */
+public interface Marshaller<T, R> {
+
+    /**
+     * @param in input to marshall.
+     * @return marshalled result.
+     * @throws Exception
+     */
+    public T marshall(R in) throws Exception;
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallers.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallers.java
new file mode 100644
index 0000000000..f99d76e705
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallers.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.util.Base64;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * SimpleTypeJsonUnmarshallers class.
+ */
+public class SimpleTypeJsonUnmarshallers {
+    /**
+     * Unmarshaller for String values.
+     */
+    public static class StringJsonUnmarshaller implements
+            Unmarshaller<String, JsonUnmarshallerContext> {
+        @Override
+        public String unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            return unmarshallerContext.getReader().nextString();
+        }
+
+        private static StringJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static StringJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new StringJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Double values.
+     */
+    public static class DoubleJsonUnmarshaller implements
+            Unmarshaller<Double, JsonUnmarshallerContext> {
+        @Override
+        public Double unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String doubleString = unmarshallerContext.getReader().nextString();
+            return (doubleString == null) ? null : Double.parseDouble(doubleString);
+        }
+
+        private static DoubleJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static DoubleJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new DoubleJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Integer values.
+     */
+    public static class IntegerJsonUnmarshaller implements
+            Unmarshaller<Integer, JsonUnmarshallerContext> {
+        @Override
+        public Integer unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String intString = unmarshallerContext.getReader().nextString();
+            return (intString == null) ? null : Integer.parseInt(intString);
+        }
+
+        private static IntegerJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static IntegerJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new IntegerJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Big Integer values.
+     */
+    public static class BigIntegerJsonUnmarshaller implements
+            Unmarshaller<BigInteger, JsonUnmarshallerContext> {
+        @Override
+        public BigInteger unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String intString = unmarshallerContext.getReader().nextString();
+            return (intString == null) ? null : new BigInteger(intString);
+        }
+
+        private static BigIntegerJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BigIntegerJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BigIntegerJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Big Decimal values.
+     */
+    public static class BigDecimalJsonUnmarshaller implements
+            Unmarshaller<BigDecimal, JsonUnmarshallerContext> {
+        @Override
+        public BigDecimal unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String s = unmarshallerContext.getReader().nextString();
+            return (s == null) ? null : new BigDecimal(s);
+        }
+
+        private static BigDecimalJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BigDecimalJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BigDecimalJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Boolean values.
+     */
+    public static class BooleanJsonUnmarshaller implements
+            Unmarshaller<Boolean, JsonUnmarshallerContext> {
+        @Override
+        public Boolean unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String booleanString = unmarshallerContext.getReader().nextString();
+            return (booleanString == null) ? null : Boolean.parseBoolean(booleanString);
+        }
+
+        private static BooleanJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BooleanJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BooleanJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Float values.
+     */
+    public static class FloatJsonUnmarshaller implements
+            Unmarshaller<Float, JsonUnmarshallerContext> {
+        @Override
+        public Float unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String floatString = unmarshallerContext.getReader().nextString();
+            return (floatString == null) ? null : Float.valueOf(floatString);
+        }
+
+        private static FloatJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static FloatJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new FloatJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Long values.
+     */
+    public static class LongJsonUnmarshaller implements Unmarshaller<Long, JsonUnmarshallerContext> {
+        @Override
+        public Long unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String longString = unmarshallerContext.getReader().nextString();
+            return (longString == null) ? null : Long.parseLong(longString);
+        }
+
+        private static LongJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static LongJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new LongJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Byte values.
+     */
+    public static class ByteJsonUnmarshaller implements Unmarshaller<Byte, JsonUnmarshallerContext> {
+        @Override
+        public Byte unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String byteString = unmarshallerContext.getReader().nextString();
+            return (byteString == null) ? null : Byte.valueOf(byteString);
+        }
+
+        private static ByteJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static ByteJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new ByteJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Date values - JSON dates come in as epoch seconds.
+     */
+    public static class DateJsonUnmarshaller implements Unmarshaller<Date, JsonUnmarshallerContext> {
+
+        private static final int DATE_MULTIPLIER = 1000;
+        @Override
+        public Date unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String dateString = unmarshallerContext.getReader().nextString();
+            if (dateString == null)
+                return null;
+
+            try {
+                Number number = NumberFormat.getInstance(new Locale("en")).parse(dateString);
+                return new Date(number.longValue() * DATE_MULTIPLIER);
+            } catch (ParseException e) {
+                String errorMessage = "Unable to parse date '" + dateString + "':  "
+                        + e.getMessage();
+                throw new AmazonClientException(errorMessage, e);
+            }
+        }
+
+        private static DateJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static DateJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new DateJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for ByteBuffer values.
+     */
+    public static class ByteBufferJsonUnmarshaller implements
+            Unmarshaller<ByteBuffer, JsonUnmarshallerContext> {
+        @Override
+        public ByteBuffer unmarshall(JsonUnmarshallerContext unmarshallerContext) throws Exception {
+            String base64EncodedString = unmarshallerContext.getReader().nextString();
+            byte[] decodedBytes = Base64.decode(base64EncodedString);
+            return ByteBuffer.wrap(decodedBytes);
+
+        }
+
+        private static ByteBufferJsonUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static ByteBufferJsonUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new ByteBufferJsonUnmarshaller();
+            return instance;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallers.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallers.java
new file mode 100644
index 0000000000..42a30806e9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallers.java
@@ -0,0 +1,309 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.util.Base64;
+import com.amazonaws.util.DateUtils;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+/**
+ * Collection of StAX unmarshallers for simple data types.
+ */
+public class SimpleTypeStaxUnmarshallers {
+    /** Shared logger */
+    private static Log log = LogFactory.getLog(SimpleTypeStaxUnmarshallers.class);
+
+    /**
+     * Unmarshaller for String values.
+     */
+    public static class StringStaxUnmarshaller implements
+            Unmarshaller<String, StaxUnmarshallerContext> {
+        @Override
+        public String unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            return unmarshallerContext.readText();
+        }
+
+        private static StringStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static StringStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new StringStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+
+    /**
+     * Unmarshaller for Big Decimal values.
+     */
+    public static class BigDecimalStaxUnmarshaller implements
+            Unmarshaller<BigDecimal, StaxUnmarshallerContext> {
+        @Override
+        public BigDecimal unmarshall(StaxUnmarshallerContext unmarshallerContext)
+                throws Exception {
+            String s = unmarshallerContext.readText();
+            return (s == null) ? null : new BigDecimal(s);
+        }
+
+        private static BigDecimalStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BigDecimalStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BigDecimalStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Big Integer values.
+     */
+    public static class BigIntegerStaxUnmarshaller implements
+            Unmarshaller<BigInteger, StaxUnmarshallerContext> {
+        @Override
+        public BigInteger unmarshall(StaxUnmarshallerContext unmarshallerContext)
+                throws Exception {
+            String s = unmarshallerContext.readText();
+            return (s == null) ? null : new BigInteger(s);
+        }
+
+        private static BigIntegerStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BigIntegerStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BigIntegerStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Double values.
+     */
+    public static class DoubleStaxUnmarshaller implements
+            Unmarshaller<Double, StaxUnmarshallerContext> {
+        @Override
+        public Double unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String doubleString = unmarshallerContext.readText();
+            return (doubleString == null) ? null : Double.parseDouble(doubleString);
+        }
+
+        private static DoubleStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static DoubleStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new DoubleStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Integer values.
+     */
+    public static class IntegerStaxUnmarshaller implements
+            Unmarshaller<Integer, StaxUnmarshallerContext> {
+        @Override
+        public Integer unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String intString = unmarshallerContext.readText();
+            return (intString == null) ? null : Integer.parseInt(intString);
+        }
+
+        private static IntegerStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static IntegerStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new IntegerStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Boolean values.
+     */
+    public static class BooleanStaxUnmarshaller implements
+            Unmarshaller<Boolean, StaxUnmarshallerContext> {
+        @Override
+        public Boolean unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String booleanString = unmarshallerContext.readText();
+            return (booleanString == null) ? null : Boolean.parseBoolean(booleanString);
+        }
+
+        private static BooleanStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static BooleanStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new BooleanStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Float values.
+     */
+    public static class FloatStaxUnmarshaller implements
+            Unmarshaller<Float, StaxUnmarshallerContext> {
+        @Override
+        public Float unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String floatString = unmarshallerContext.readText();
+            return (floatString == null) ? null : Float.valueOf(floatString);
+        }
+
+        private static FloatStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static FloatStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new FloatStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Long values.
+     */
+    public static class LongStaxUnmarshaller implements Unmarshaller<Long, StaxUnmarshallerContext> {
+        @Override
+        public Long unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String longString = unmarshallerContext.readText();
+            return (longString == null) ? null : Long.parseLong(longString);
+        }
+
+        private static LongStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static LongStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new LongStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Byte values.
+     */
+    public static class ByteStaxUnmarshaller implements Unmarshaller<Byte, StaxUnmarshallerContext> {
+        @Override
+        public Byte unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String byteString = unmarshallerContext.readText();
+            return (byteString == null) ? null : Byte.valueOf(byteString);
+        }
+
+        private static ByteStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static ByteStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new ByteStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for Date values.
+     */
+    public static class DateStaxUnmarshaller implements Unmarshaller<Date, StaxUnmarshallerContext> {
+        @Override
+        public Date unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String dateString = unmarshallerContext.readText();
+            if (dateString == null)
+                return null;
+
+            try {
+                return DateUtils.parseISO8601Date(dateString);
+            } catch (Exception e) {
+                log.warn("Unable to parse date '" + dateString + "':  " + e.getMessage(), e);
+                return null;
+            }
+        }
+
+        private static DateStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static DateStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new DateStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+    /**
+     * Unmarshaller for ByteBuffer values.
+     */
+    public static class ByteBufferStaxUnmarshaller implements
+            Unmarshaller<ByteBuffer, StaxUnmarshallerContext> {
+        @Override
+        public ByteBuffer unmarshall(StaxUnmarshallerContext unmarshallerContext) throws Exception {
+            String base64EncodedString = unmarshallerContext.readText();
+            byte[] decodedBytes = Base64.decode(base64EncodedString);
+            return ByteBuffer.wrap(decodedBytes);
+
+        }
+
+        private static ByteBufferStaxUnmarshaller instance;
+
+        /**
+         * Constructor.
+         * @return the instance.
+         */
+        public static ByteBufferStaxUnmarshaller getInstance() {
+            if (instance == null)
+                instance = new ByteBufferStaxUnmarshaller();
+            return instance;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StandardErrorUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StandardErrorUnmarshaller.java
new file mode 100644
index 0000000000..2e1bfd0d8c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StandardErrorUnmarshaller.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.util.XpathUtils;
+
+import org.w3c.dom.Node;
+
+/**
+ * Error unmarshaller that knows how to interpret a standard AWS error message
+ * (i.e. where to find the AWS error code, the error message, etc.) and turn it
+ * into an AmazonServiceException.
+ *
+ * @see LegacyErrorUnmarshaller
+ */
+public class StandardErrorUnmarshaller extends AbstractErrorUnmarshaller<Node> {
+
+    /**
+     * Constructs a new unmarshaller that will unmarshall a standard AWS error
+     * message as a generic AmazonServiceException object.
+     */
+    public StandardErrorUnmarshaller() {
+    }
+
+    /**
+     * Constructor allowing subclasses to specify a specific type of
+     * AmazonServiceException to instantiating when populating the exception
+     * object with data from the error message.
+     *
+     * @param exceptionClass The class of AmazonServiceException to create and
+     *            populate when unmarshalling the error message.
+     */
+    protected StandardErrorUnmarshaller(Class<? extends AmazonServiceException> exceptionClass) {
+        super(exceptionClass);
+    }
+
+    /**
+     * @see com.amazonaws.transform.Unmarshaller#unmarshall(java.lang.Object)
+     */
+    @Override
+    public AmazonServiceException unmarshall(Node in) throws Exception {
+        String errorCode = parseErrorCode(in);
+        String errorType = XpathUtils.asString("ErrorResponse/Error/Type", in);
+        String requestId = XpathUtils.asString("ErrorResponse/RequestId", in);
+        String message = XpathUtils.asString("ErrorResponse/Error/Message", in);
+
+        AmazonServiceException ase = newException(message);
+        ase.setErrorCode(errorCode);
+        ase.setRequestId(requestId);
+
+        if (errorType == null) {
+            ase.setErrorType(ErrorType.Unknown);
+        } else if ("Receiver".equalsIgnoreCase(errorType)) {
+            ase.setErrorType(ErrorType.Service);
+        } else if ("Sender".equalsIgnoreCase(errorType)) {
+            ase.setErrorType(ErrorType.Client);
+        }
+
+        return ase;
+    }
+
+    /**
+     * Returns the AWS error code for the specified error response.
+     *
+     * @param in The DOM tree node containing the error response.
+     * @return The AWS error code contained in the specified error response.
+     * @throws Exception If any problems were encountered pulling out the AWS
+     *             error code.
+     */
+    public String parseErrorCode(Node in) throws Exception {
+        return XpathUtils.asString("ErrorResponse/Error/Code", in);
+    }
+
+    /**
+     * Returns the path to the specified property within an error response.
+     *
+     * @param property The name of the desired property.
+     * @return The path to the specified property within an error message.
+     */
+    public String getErrorPropertyPath(String property) {
+        return "ErrorResponse/Error/" + property;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StaxUnmarshallerContext.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StaxUnmarshallerContext.java
new file mode 100644
index 0000000000..020124f57e
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/StaxUnmarshallerContext.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Contains the unmarshalling state for the parsing of an XML response. The
+ * unmarshallers are stateless so that they can be reused, so this class holds
+ * the state while different unmarshallers work together to parse an XML
+ * response. It also tracks the current position and element depth of the
+ * document being parsed and provides utilties for accessing the next XML event
+ * from the parser, reading element text, handling attribute XML events, etc.
+ */
+public class StaxUnmarshallerContext {
+
+    private int currentEventType;
+    private final XmlPullParser xpp;
+
+    /** The deque stack. */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    public final Deque<String> stack = new LinkedList<String>();
+    private String stackString = "";
+
+    private Map<String, String> metadata = new HashMap<String, String>();
+    private List<MetadataExpression> metadataExpressions = new ArrayList<MetadataExpression>();
+
+    private final Map<String, String> headers;
+
+    /**
+     * Constructs a new unmarshaller context using the specified source of XML
+     * events.
+     *
+     * @param xpp The source of XML events for this unmarshalling context.
+     */
+    public StaxUnmarshallerContext(XmlPullParser xpp) {
+        this(xpp, null);
+    }
+
+    /**
+     * Constructs a new unmarshaller context using the specified source of XML
+     * events, and a set of response headers.
+     *
+     * @param xpp The source of XML events for this unmarshalling context.
+     * @param headers The set of response headers associated with this
+     *            unmarshaller context.
+     */
+    public StaxUnmarshallerContext(XmlPullParser xpp, Map<String, String> headers) {
+        this.xpp = xpp;
+        this.headers = headers;
+    }
+
+    /**
+     * Returns the value of the header with the specified name from the
+     * response, or null if not present.
+     *
+     * @param header The name of the header to lookup.
+     * @return The value of the header with the specified name from the response,
+     *         or null if not present.
+     */
+    public String getHeader(String header) {
+        if (headers == null)
+            return null;
+
+        return headers.get(header);
+    }
+
+    /**
+     * Returns the text contents of the current element being parsed.
+     *
+     * @return The text contents of the current element being parsed.
+     * @throws IOException
+     * @throws XmlPullParserException
+     */
+    public String readText() throws XmlPullParserException, IOException {
+        String s = xpp.nextText();
+        // Warning: Prior to API level 14, the pull parser returned by
+        // android.util.Xml did not always advance to the END_TAG event when
+        // this method was called. Work around by using manually advancing after
+        // calls to nextText():
+        if (xpp.getEventType() != XmlPullParser.END_TAG) {
+            xpp.next();
+        }
+        currentEventType = xpp.getEventType();
+        updateContext();
+        return s;
+    }
+
+    /**
+     * Returns the element depth of the parser's current position in the XML
+     * document being parsed.
+     *
+     * @return The element depth of the parser's current position in the XML
+     *         document being parsed.
+     */
+    public int getCurrentDepth() {
+        return stack.size();
+    }
+
+    /**
+     * Tests the specified expression against the current position in the XML
+     * document being parsed.
+     *
+     * @param expression The psuedo-xpath expression to test.
+     * @return True if the expression matches the current document position,
+     *         otherwise false.
+     */
+    public boolean testExpression(String expression) {
+        return testExpression(expression, getCurrentDepth());
+    }
+
+    /**
+     * Tests the specified expression against the current position in the XML
+     * document being parsed, and restricts the expression to matching at the
+     * specified stack depth.
+     *
+     * @param expression The psuedo-xpath expression to test.
+     * @param startingStackDepth The depth in the stack representing where the
+     *            expression must start matching in order for this method to
+     *            return true.
+     * @return True if the specified expression matches the current position in
+     *         the XML document, starting from the specified depth.
+     */
+    public boolean testExpression(String expression, int startingStackDepth) {
+        if (".".equals(expression))
+            return true;
+
+        int index = -1;
+        while ((index = expression.indexOf("/", index + 1)) > -1) {
+            // Don't consider attributes a new depth level
+            if (expression.charAt(index + 1) != '@') {
+                startingStackDepth++;
+            }
+        }
+
+        return (getCurrentDepth() == startingStackDepth
+                && stackString.endsWith("/" + expression));
+    }
+
+    /**
+     * Returns true if this unmarshaller context is at the very beginning of a
+     * source document (i.e. no data has been parsed from the document yet).
+     *
+     * @return true if this unmarshaller context is at the very beginning of a
+     *         source document (i.e. no data has been parsed from the document
+     *         yet).
+     */
+    public boolean isStartOfDocument() {
+        return currentEventType == XmlPullParser.START_DOCUMENT;
+    }
+
+    /**
+     * Returns the next XML event for the document being parsed. It's one of
+     * XmlPullParser.START_DOCUMENT,XmlPullParser.END_DOCUMENT,
+     * XmlPullParser.START_TAG, XmlPullParser.END_TAG.
+     *
+     * @return The next XML event for the document being parsed.
+     * @throws IOException
+     * @throws XmlPullParserException
+     */
+    public int nextEvent() throws XmlPullParserException, IOException {
+        currentEventType = xpp.next();
+        // skip text node
+        if (currentEventType == XmlPullParser.TEXT) {
+            currentEventType = xpp.next();
+        }
+
+        updateContext();
+
+        // look for meta data
+        if (currentEventType == XmlPullParser.START_TAG) {
+            for (MetadataExpression metadataExpression : metadataExpressions) {
+                if (testExpression(metadataExpression.expression,
+                        metadataExpression.targetDepth)) {
+                    metadata.put(metadataExpression.key, readText());
+                    break;
+                }
+            }
+        }
+
+        return currentEventType;
+    }
+
+    /**
+     * Returns any metadata collected through metadata expressions while this
+     * context was reading the XML events from the XML document.
+     *
+     * @return A map of any metadata collected through metadata expressions
+     *         while this context was reading the XML document.
+     */
+    public Map<String, String> getMetadata() {
+        return metadata;
+    }
+
+    /**
+     * Registers an expression, which if matched, will cause the data for the
+     * matching element to be stored in the metadata map under the specified
+     * key.
+     *
+     * @param expression The expression an element must match in order for it's
+     *            data to be pulled out and stored in the metadata map.
+     * @param targetDepth The depth in the XML document where the expression
+     *            match must start.
+     * @param storageKey The key under which to store the matching element's
+     *            data.
+     */
+    public void registerMetadataExpression(String expression, int targetDepth, String storageKey) {
+        metadataExpressions.add(new MetadataExpression(expression, targetDepth, storageKey));
+    }
+
+    /*
+     * Private Interface
+     */
+
+    /**
+     * Simple container for the details of a metadata expression this
+     * unmarshaller context is looking for.
+     */
+    @SuppressWarnings("checkstyle:visibilitymodifier")
+    private static class MetadataExpression {
+
+        public String expression;
+        public int targetDepth;
+        public String key;
+
+        public MetadataExpression(String expression, int targetDepth, String key) {
+            this.expression = expression;
+            this.targetDepth = targetDepth;
+            this.key = key;
+        }
+    }
+
+    private void updateContext() {
+        if (currentEventType == XmlPullParser.START_TAG) {
+            stackString += "/" + xpp.getName();
+            stack.push(stackString);
+        } else if (currentEventType == XmlPullParser.END_TAG) {
+            stack.pop();
+            stackString = stack.isEmpty() ? "" : stack.peek();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Unmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Unmarshaller.java
new file mode 100644
index 0000000000..9e10409abd
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/Unmarshaller.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+/**
+ * Interface for Unmarshaller.
+ * @param <T> the type.
+ * @param <R> the type.
+ */
+public interface Unmarshaller<T, R> {
+
+    /**
+     * @param in to unmarshall.
+     * @return unmarshalled result.
+     * @throws Exception
+     */
+    public T unmarshall(R in) throws Exception;
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidJsonUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidJsonUnmarshaller.java
new file mode 100644
index 0000000000..8329c80caa
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidJsonUnmarshaller.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+/**
+ * Simple unmarshaller that iterates through the JSON events but always returns
+ * null.
+ * @param <T> the VoidJsonUnmarshaller type.
+ */
+public class VoidJsonUnmarshaller<T> implements Unmarshaller<T, JsonUnmarshallerContext> {
+    @Override
+    public T unmarshall(JsonUnmarshallerContext context) throws Exception {
+        return null;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidStaxUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidStaxUnmarshaller.java
new file mode 100644
index 0000000000..f35746dad0
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidStaxUnmarshaller.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import org.xmlpull.v1.XmlPullParser;
+
+/**
+ * Simple StAX unmarshaller that iterates through the XML events but always
+ * returns null.
+ * @param <T> the VoidStaxUnmarshaller type.
+ */
+public class VoidStaxUnmarshaller<T> implements Unmarshaller<T, StaxUnmarshallerContext> {
+    @Override
+    @SuppressWarnings("checkstyle:emptystatement")
+    public T unmarshall(StaxUnmarshallerContext context) throws Exception {
+        while (context.nextEvent() != XmlPullParser.END_DOCUMENT)
+            ;
+        return null;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidUnmarshaller.java b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidUnmarshaller.java
new file mode 100644
index 0000000000..f9e1ec0cab
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/transform/VoidUnmarshaller.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import org.w3c.dom.Node;
+
+/**
+ * Simple Unmarshaller implementation that always returns null.
+ */
+public class VoidUnmarshaller implements Unmarshaller<Void, Node> {
+    /**
+     * @see com.amazonaws.transform.Unmarshaller#unmarshall(java.lang.Object)
+     */
+    @Override
+    public Void unmarshall(Node in) throws Exception {
+        return null;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetrics.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetrics.java
new file mode 100644
index 0000000000..2fca981ccf
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetrics.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.metrics.MetricType;
+import com.amazonaws.metrics.RequestMetricType;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Used as both a base class and a minimal support of AWS SDK request metrics.
+ * The base class of supporting AWS SDK request metrics.
+ * <p>
+ * In contrast to {@link AWSRequestMetricsFullSupport}, which is intended to be
+ * a full support of AWS SDK request metrics, this class only provides access to
+ * a {@link TimingInfo} instance that only has minimal support for start and end
+ * time (ie with no-ops for sub-event measurements) for backward compatibility
+ * reason. The other methods related to properties and counters in this class
+ * are effectively no-ops.
+ * <p>
+ * This class is instantiated instead of {@link AWSRequestMetricsFullSupport}
+ * when request metric collection is not required during a particular service
+ * request/response cycle.
+ *
+ * @deprecated metrics is deprecated
+ */
+@Deprecated
+public class AWSRequestMetrics {
+    /**
+     * Predefined AWS SDK metric types general across all AWS clients. Client
+     * specific predefined metrics like S3 or DynamoDB are defined in the client
+     * specific packages.
+     */
+    public static enum Field implements RequestMetricType {
+
+        /** AWSErrorCode. */
+        AWSErrorCode,
+
+        /** AWSRequestID. */
+        AWSRequestID,
+
+        /** BytesProcessed. */
+        BytesProcessed,
+
+        /**
+         * Total number of milliseconds taken for a request/response including
+         * the time taken to execute the request handlers, round trip to AWS,
+         * and the time taken to execute the response handlers.
+         */
+        ClientExecuteTime,
+
+        /** CredentialsRequestTime. */
+        CredentialsRequestTime,
+
+        /** Exception. */
+        Exception,
+        /**
+         * Number of milliseconds taken for a request/response round trip to
+         * AWS.
+         */
+        HttpRequestTime,
+
+        /** RedirectLocation. */
+        RedirectLocation,
+
+        /** RequestMarshallTime. */
+        RequestMarshallTime,
+        /**
+         * Number of milliseconds taken to sign a request.
+         */
+        RequestSigningTime,
+        /**
+         * Number of milliseconds taken to execute the response handler for a
+         * response from AWS.
+         */
+        ResponseProcessingTime,
+        /**
+         * Number of requests to AWS.
+         */
+        RequestCount,
+        /**
+         * Number of retries of AWS SDK sending a request to AWS.
+         */
+        RetryCount, // captured via the RequestCount since (RetryCount =
+                    // RequestCount - 1)
+        /**
+         * Number of retries of the underlying http client library in sending a
+         * request to AWS.
+         */
+        HttpClientRetryCount,
+        /**
+         * Time taken to send a request to AWS by the http client library,
+         * excluding any retry.
+         */
+        HttpClientSendRequestTime,
+        /**
+         * Time taken to receive a response from AWS by the http client library,
+         * excluding any retry.
+         */
+        HttpClientReceiveResponseTime,
+
+        /**
+         * The number of idle persistent connections.
+         * <p>
+         * Reference: https://hc.apache
+         * .org/httpcomponents-core-ga/httpcore/apidocs/org/apache
+         * /http/pool/PoolStats.html
+         */
+        HttpClientPoolAvailableCount,
+        /**
+         * The number of persistent connections tracked by the connection
+         * manager currently being used to execute requests.
+         * <p>
+         * Reference: https://hc
+         * .apache.org/httpcomponents-core-ga/httpcore/apidocs/org/apache
+         * /http/pool/PoolStats.html
+         */
+        HttpClientPoolLeasedCount,
+        /**
+         * The number of connection requests being blocked awaiting a free
+         * connection.
+         * <p>
+         * Reference: https://hc.apache.org/httpcomponents-core-ga/httpcore
+         * /apidocs/org/apache/http/pool/PoolStats.html
+         */
+        HttpClientPoolPendingCount,
+
+        /** RetryPauseTime. */
+        RetryPauseTime,
+        // S3DownloadThroughput, // migrated to S3RequestMetric in the S3 clint
+        // library
+        // S3UploadThroughput, // migrated to S3RequestMetric in the S3 clint
+        // library
+        /** ServiceEndpoint. */
+        ServiceEndpoint,
+
+        /** ServiceName. */
+        ServiceName,
+
+        /** StatusCode. */
+        StatusCode; // The http status code
+    }
+
+    protected final TimingInfo timingInfo;
+
+    /**
+     * This constructor should be used only in the case when AWS SDK metrics
+     * collector is disabled, when minimal timing info is supported for backward
+     * compatibility reasons.
+     *
+     * @see AWSRequestMetricsFullSupport
+     */
+    public AWSRequestMetrics() {
+        this.timingInfo = TimingInfo.startTiming();
+    }
+
+    protected AWSRequestMetrics(TimingInfo timingInfo) {
+        this.timingInfo = timingInfo;
+    }
+
+    public final TimingInfo getTimingInfo() {
+        return timingInfo;
+    }
+
+    /**
+     * @return true if this metrics is enabled; false otherwise. Returns false
+     * by default.
+     */
+    public boolean isEnabled() {
+        return false;
+    }
+
+    /**
+     * @param eventName the event name to start.
+     */
+    public void startEvent(String eventName) {
+    }
+
+    /**
+     * @param f the metric type.
+     */
+    public void startEvent(MetricType f) {
+    }
+
+    /**
+     * @param eventName the event name.
+     */
+    public void endEvent(String eventName) {
+    }
+
+    /**
+     * @param f the metric type.
+     */
+    public void endEvent(MetricType f) {
+    }
+
+    /**
+     * @param event the event.
+     */
+    public void incrementCounter(String event) {
+    }
+
+    /**
+     * @param f the metric type.
+     */
+    public void incrementCounter(MetricType f) {
+    }
+
+    /**
+     * @param counterName the counter name.
+     * @param count the count.
+     */
+    public void setCounter(String counterName, long count) {
+    }
+
+    /**
+     * @param f the metric type.
+     * @param count the count.
+     */
+    public void setCounter(MetricType f, long count) {
+    }
+
+    /**
+     * @param propertyName the property name.
+     * @param value the value.
+     */
+    public void addProperty(String propertyName, Object value) {
+    }
+
+    /**
+     * @param f the metric type.
+     * @param value the value.
+     */
+    public void addProperty(MetricType f, Object value) {
+    }
+
+    /**
+     * log.
+     */
+    public void log() {
+    }
+
+    /**
+     * @param propertyName the property name.
+     * @return list of property objects.
+     */
+    public List<Object> getProperty(String propertyName) {
+        return Collections.emptyList();
+    }
+
+    /**
+     * @param f the metric type.
+     * @return the list of property objects.
+     */
+    public List<Object> getProperty(MetricType f) {
+        return Collections.emptyList();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetricsFullSupport.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetricsFullSupport.java
new file mode 100644
index 0000000000..0555a5153b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSRequestMetricsFullSupport.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.metrics.AwsSdkMetrics;
+import com.amazonaws.metrics.MetricType;
+import com.amazonaws.metrics.RequestMetricCollector;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * In contrast to {@link AWSRequestMetrics}, which is intended to be a minimal
+ * support of AWS SDK request metrics, this class is the full support of AWS SDK
+ * request metrics including features such as properties and sub-events.
+ * <p>
+ * This class is instantiated instead of {@link AWSRequestMetrics} when request
+ * metric collection is required during a particular service request/response
+ * cycle.
+ *
+ * @deprecated metrics is deprecated
+ */
+@Deprecated
+public class AWSRequestMetricsFullSupport extends AWSRequestMetrics {
+    /* Stores some key value pairs. */
+    private final Map<String, List<Object>> properties = new HashMap<String, List<Object>>();
+
+    /* A map to store events that are being profiled. */
+    private final Map<String, TimingInfo> eventsBeingProfiled = new HashMap<String, TimingInfo>();
+    /* Latency Logger */
+    private static final Log LATENCY_LOGGER = LogFactory.getLog("com.amazonaws.latency");
+    private static final Object KEY_VALUE_SEPARATOR = "=";
+    private static final Object COMMA_SEPARATOR = ", ";
+
+    /**
+     * This constructor should be used in the case when AWS SDK metrics
+     * collector is enabled.
+     *
+     * @see AWSRequestMetricsFullSupport
+     */
+    public AWSRequestMetricsFullSupport() {
+        super(TimingInfo.startTimingFullSupport());
+    }
+
+    /**
+     * Start an event which will be timed. The startTime and endTime are added
+     * to timingInfo only after endEvent is called. For every startEvent there
+     * should be a corresponding endEvent. If you start the same event without
+     * ending it, this will overwrite the old event. i.e. There is no support
+     * for recursive events yet. Having said that, if you start and end an event
+     * in that sequence multiple times, all events are logged in timingInfo in
+     * that order. This feature is enabled if the system property
+     * "com.amazonaws.sdk.enableRuntimeProfiling" is set, or if a
+     * {@link RequestMetricCollector} is in use either at the request, web
+     * service client, or AWS SDK level.
+     *
+     * @param eventName - The name of the event to start
+     * @see AwsSdkMetrics
+     */
+    @Override
+    public void startEvent(String eventName) {
+        /* This will overwrite past events */
+        // ignoring the wall clock time
+        eventsBeingProfiled.put(eventName, TimingInfo.startTimingFullSupport(System.nanoTime()));
+    }
+
+    @Override
+    public void startEvent(MetricType f) {
+        startEvent(f.name());
+    }
+
+    /**
+     * End an event which was previously started. Once ended, log how much time
+     * the event took. It is illegal to end an Event that was not started. It is
+     * good practice to endEvent in a finally block. See Also startEvent.
+     *
+     * @param eventName - The name of the event to start
+     */
+    @Override
+    public void endEvent(String eventName) {
+        TimingInfo event = eventsBeingProfiled.get(eventName);
+        /* Somebody tried to end an event that was not started. */
+        if (event == null) {
+            LogFactory.getLog(getClass()).warn("Trying to end an event which was never started: " + eventName);
+            return;
+        }
+        event.endTiming();
+        this.timingInfo.addSubMeasurement(
+                eventName,
+                TimingInfo.unmodifiableTimingInfo(
+                        event.getStartTimeNano(),
+                        event.getEndTimeNano()));
+    }
+
+    @Override
+    public void endEvent(MetricType f) {
+        endEvent(f.name());
+    }
+
+    /**
+     * Add 1 to an existing count for a given event. If the count for that event
+     * does not exist, then it creates one and initializes it to 1. This feature
+     * is enabled if the system property
+     * "com.amazonaws.sdk.enableRuntimeProfiling" is set, or if a
+     * {@link RequestMetricCollector} is in use either at the request, web
+     * service client, or AWS SDK level.
+     *
+     * @param event - The name of the event to count
+     */
+    @Override
+    public void incrementCounter(String event) {
+        timingInfo.incrementCounter(event);
+    }
+
+    @Override
+    public void incrementCounter(MetricType f) {
+        incrementCounter(f.name());
+    }
+
+    @Override
+    public void setCounter(String counterName, long count) {
+        timingInfo.setCounter(counterName, count);
+    }
+
+    @Override
+    public void setCounter(MetricType f, long count) {
+        setCounter(f.name(), count);
+    }
+
+    /**
+     * Add a property. If you add the same property more than once, it stores
+     * all values a list. This feature is enabled if the system property
+     * "com.amazonaws.sdk.enableRuntimeProfiling" is set, or if a
+     * {@link RequestMetricCollector} is in use either at the request, web
+     * service client, or AWS SDK level.
+     *
+     * @param propertyName The name of the property
+     * @param value The property value
+     */
+    @Override
+    public void addProperty(String propertyName, Object value) {
+        List<Object> propertyList = properties.get(propertyName);
+        if (propertyList == null) {
+            propertyList = new ArrayList<Object>();
+            properties.put(propertyName, propertyList);
+        }
+
+        propertyList.add(value);
+    }
+
+    @Override
+    public void addProperty(MetricType f, Object value) {
+        addProperty(f.name(), value);
+    }
+
+    @Override
+    public void log() {
+        if (LATENCY_LOGGER.isInfoEnabled()) {
+            StringBuilder builder = new StringBuilder();
+
+            for (Entry<String, List<Object>> entry : properties.entrySet()) {
+                keyValueFormat(entry.getKey(), entry.getValue(), builder);
+            }
+
+            for (Entry<String, Number> entry : timingInfo.getAllCounters()
+                    .entrySet()) {
+                keyValueFormat(entry.getKey(), entry.getValue(), builder);
+            }
+            for (Entry<String, List<TimingInfo>> entry : timingInfo
+                    .getSubMeasurementsByName().entrySet()) {
+                keyValueFormat(entry.getKey(), entry.getValue(), builder);
+            }
+            LATENCY_LOGGER.info(builder.toString());
+        }
+    }
+
+    private void keyValueFormat(Object key, Object value, StringBuilder builder) {
+        builder.append(key).append(KEY_VALUE_SEPARATOR).append(value).append(COMMA_SEPARATOR);
+    }
+
+    @Override
+    public List<Object> getProperty(String propertyName) {
+        return properties.get(propertyName);
+    }
+
+    @Override
+    public List<Object> getProperty(MetricType f) {
+        return getProperty(f.name());
+    }
+
+    /** Always returns true. */
+    @Override
+    public final boolean isEnabled() {
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSServiceMetrics.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSServiceMetrics.java
new file mode 100644
index 0000000000..8531fe7758
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AWSServiceMetrics.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.metrics.ServiceMetricType;
+
+/**
+ * Predefined AWS SDK non-request specific metric types general across all AWS
+ * clients. Client specific predefined metrics like S3 or DynamoDB are defined
+ * in the client specific packages.
+ *
+ * @deprecated Metrics is deprecated
+ */
+@Deprecated
+public enum AWSServiceMetrics implements ServiceMetricType {
+    /**
+     * Time taken to get a connection by the http client library.
+     */
+    HttpClientGetConnectionTime("HttpClient");
+
+    private final String serviceName;
+
+    private AWSServiceMetrics(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    @Override
+    public String getServiceName() {
+        return serviceName;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/AbstractBase32Codec.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AbstractBase32Codec.java
new file mode 100644
index 0000000000..6b6db2ec44
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AbstractBase32Codec.java
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.CodecUtils.sanityCheckLastPos;
+
+/**
+ * Common base class for Base 32 like codec implementation.
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings("checkstyle:innerassignment")
+abstract class AbstractBase32Codec implements Codec {
+
+    private static final int BITS_3 = 3;
+    private static final int BITS_4 = 4;
+    private static final int BITS_5 = 5;
+    private static final int BIT_MULTIPLIER = 8;
+
+    private static final int MASK_2BITS = (1 << 2) - 1;
+    private static final int MASK_3BITS = (1 << BITS_3) - 1;
+    private static final int MASK_4BITS = (1 << BITS_4) - 1;
+    private static final int MASK_5BITS = (1 << BITS_5) - 1;
+    // Base 32 alphabet as defined at http://www.ietf.org/rfc/rfc4648.txt
+    private static final byte PAD = '=';
+
+    private final byte[] alpahbets;
+
+    protected AbstractBase32Codec(byte[] alphabets) {
+        alpahbets = alphabets;
+    }
+
+    @Override
+    public final byte[] encode(byte[] src) {
+        final int num5bytes = src.length / BITS_5;
+        final int remainder = src.length % BITS_5;
+
+        if (remainder == 0) {
+            byte[] dest = new byte[num5bytes * BIT_MULTIPLIER];
+
+            for (int s = 0, d = 0; s < src.length; s += BITS_5, d += BIT_MULTIPLIER)
+                encode5bytes(src, s, dest, d);
+            return dest;
+        }
+
+        byte[] dest = new byte[(num5bytes + 1) * BIT_MULTIPLIER];
+        int s = 0, d = 0;
+
+        for (; s < src.length - remainder; s += BITS_5, d += BIT_MULTIPLIER)
+            encode5bytes(src, s, dest, d);
+
+        switch (remainder) {
+            case 1:
+                encode1byte(src, s, dest, d);
+                break;
+            case 2:
+                encode2bytes(src, s, dest, d);
+                break;
+            case BITS_3:
+                encode3bytes(src, s, dest, d);
+                break;
+            case BITS_4:
+                encode4bytes(src, s, dest, d);
+                break;
+            default:
+                break;
+        }
+        return dest;
+    }
+
+    private final void encode5bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> BITS_3 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_3BITS) << 2 | (p = src[s++]) >>> (BITS_5 + 1) & MASK_2BITS]; // 3
+                                                                                          // 2
+        dest[d++] = alpahbets[p >>> 1 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & 1) << BITS_4 | (p = src[s++]) >>> BITS_4 & MASK_4BITS]; // 1
+                                                                                 // 4
+        dest[d++] = alpahbets[(p & MASK_4BITS) << 1 | (p = src[s++]) >>> (BITS_5 + 2) & 1]; // 4
+                                                                                 // 1
+        dest[d++] = alpahbets[p >>> 2 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_2BITS) << BITS_3 | (p = src[s]) >>> BITS_5 & MASK_3BITS]; // 2
+                                                                                        // 3
+        dest[d] = alpahbets[p & MASK_5BITS]; // 5
+        return;
+    }
+
+    private final void encode4bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> BITS_3 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_3BITS) << 2 | (p = src[s++]) >>> (BITS_5 + 1) & MASK_2BITS]; // 3
+                                                                                          // 2
+        dest[d++] = alpahbets[p >>> 1 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & 1) << BITS_4 | (p = src[s++]) >>> BITS_4 & MASK_4BITS]; // 1
+                                                                                 // 4
+        dest[d++] = alpahbets[(p & MASK_4BITS) << 1 | (p = src[s]) >>> (BITS_5 + 2) & 1]; // 4
+                                                                               // 1
+        dest[d++] = alpahbets[p >>> 2 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_2BITS) << BITS_3]; // 2
+        dest[d] = PAD;
+        return;
+    }
+
+    private final void encode3bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> BITS_3 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_3BITS) << 2 | (p = src[s++]) >>> (BITS_5 + 1) & MASK_2BITS]; // 3
+                                                                                          // 2
+        dest[d++] = alpahbets[p >>> 1 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & 1) << BITS_4 | (p = src[s]) >>> (BITS_4) & MASK_4BITS]; // 1
+                                                                               // 4
+        dest[d++] = alpahbets[(p & MASK_4BITS) << 1]; // 4
+
+        for (int i = 0; i < BITS_3; i++)
+            dest[d++] = PAD;
+        return;
+    }
+
+    private final void encode2bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> BITS_3 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_3BITS) << 2 | (p = src[s]) >>> (BITS_5 + 1) & MASK_2BITS]; // 3
+                                                                                        // 2
+        dest[d++] = alpahbets[p >>> 1 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & 1) << BITS_4]; // 1
+
+        for (int i = 0; i < BITS_4; i++)
+            dest[d++] = PAD;
+        return;
+    }
+
+    private final void encode1byte(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s]) >>> BITS_3 & MASK_5BITS]; // 5
+        dest[d++] = alpahbets[(p & MASK_3BITS) << 2]; // 3
+
+        for (int i = 0; i < (BITS_5 + 1); i++)
+            dest[d++] = PAD;
+        return;
+    }
+
+    private final void decode5bytes(byte[] src, int s, byte[] dest, int d) {
+        int p = 0;
+        // operator precedence in descending order: >>> or <<, &, |
+        dest[d++] = (byte)
+                (
+                pos(src[s++]) << BITS_3
+                | (p = pos(src[s++])) >>> 2 & MASK_3BITS
+                ); // 5 3
+        dest[d++] = (byte)
+                (
+                (p & MASK_2BITS) << (BITS_5 + 1)
+                        | pos(src[s++]) << 1
+                        | (p = pos(src[s++])) >>> BITS_4 & 1
+                ); // 2 5 1
+        dest[d++] = (byte)
+                (
+                (p & MASK_4BITS) << BITS_4
+                | (p = pos(src[s++])) >>> 1 & MASK_4BITS
+                ); // 4 4
+        dest[d++] = (byte)
+                (
+                (p & 1) << (BITS_5 + 2)
+                        | pos(src[s++]) << 2
+                        | (p = pos(src[s++])) >>> BITS_3 & MASK_2BITS
+                ); // 1 5 2
+        dest[d] = (byte)
+                (
+                (p & MASK_3BITS) << BITS_5
+                | pos(src[s])
+                ); // 3 5
+        return;
+    }
+
+    /**
+     * @param n the number of final quantum in bytes to decode into. Ranges from
+     *            1 to 4, inclusive.
+     */
+    private final void decode1to4bytes(int n, byte[] src, int s, byte[] dest, int d) {
+        int p = 0;
+        // operator precedence in descending order: >>> or <<, &, |
+        dest[d++] = (byte)
+                (
+                pos(src[s++]) << BITS_3
+                | (p = pos(src[s++])) >>> 2 & MASK_3BITS
+                ); // 5 3
+        if (n == 1) {
+            sanityCheckLastPos(p, MASK_2BITS);
+            return;
+        }
+
+        dest[d++] = (byte)
+                (
+                (p & MASK_2BITS) << (BITS_5 + 1)
+                        | (pos(src[s++])) << 1
+                        | (p = pos(src[s++])) >>> BITS_4 & 1
+                ); // 2 5 1
+        if (n == 2) {
+            sanityCheckLastPos(p, MASK_4BITS);
+            return;
+        }
+
+        dest[d++] = (byte)
+                (
+                (p & MASK_4BITS) << BITS_4
+                | (p = pos(src[s++])) >>> 1 & MASK_4BITS
+                ); // 4 4
+        if (n == BITS_3) {
+            sanityCheckLastPos(p, 1);
+            return;
+        }
+
+        dest[d] = (byte)
+                (
+                (p & 1) << (BITS_5 + 2)
+                        | pos(src[s++]) << 2
+                        | (p = pos(src[s])) >>> BITS_3 & MASK_2BITS
+                ); // 1 5 2
+        sanityCheckLastPos(p, MASK_3BITS);
+        return;
+    }
+
+    @Override
+    public final byte[] decode(byte[] src, final int length) {
+        if (length % (BITS_5 + BITS_3) != 0)
+            throw new IllegalArgumentException(
+                    "Input is expected to be encoded in multiple of 8 bytes but found: " + length);
+
+        int pads = 0;
+        int last = length - 1;
+
+        // max possible padding in b32 encoding is 6
+        for (; pads < (BITS_5 + 1) && last > -1; last--, pads++) {
+            if (src[last] != PAD)
+                break;
+        }
+
+        final int fq; // final quantum in unit of bytes
+
+        switch (pads) {
+            case 0:
+                fq = BITS_5;
+                break; // final quantum of encoding input is an integral
+                       // multiple of 40 bits
+            case 1:
+                fq = BITS_4;
+                break; // final quantum of encoding input is exactly 32 bits
+            case BITS_3:
+                fq = BITS_3;
+                break; // final quantum of encoding input is exactly 24 bits
+            case BITS_4:
+                fq = 2;
+                break; // final quantum of encoding input is exactly 16 bits
+            case (BITS_5 + 1):
+                fq = 1;
+                break; // final quantum of encoding input is exactly 8 bits
+            default:
+                throw new IllegalArgumentException("Invalid number of paddings " + pads);
+        }
+        final byte[] dest = new byte[length / (BITS_5 + BITS_3) * BITS_5 - (BITS_5 - fq)];
+        int s = 0, d = 0;
+
+        // % has a higher precedence than - than <
+        for (; d < dest.length - fq % BITS_5; s += (BITS_5 + BITS_3), d += BITS_5)
+            decode5bytes(src, s, dest, d);
+
+        if (fq < BITS_5)
+            decode1to4bytes(fq, src, s, dest, d);
+        return dest;
+    }
+
+    protected abstract int pos(byte in);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/AwsHostNameUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AwsHostNameUtils.java
new file mode 100644
index 0000000000..2080939bb3
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/AwsHostNameUtils.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.internal.config.HostRegexToRegionMapping;
+import com.amazonaws.internal.config.InternalConfig;
+
+import org.apache.commons.logging.LogFactory;
+
+import java.net.InetAddress;
+import java.net.URI;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * AWS host name utils class.
+ */
+public class AwsHostNameUtils {
+
+    private static final Pattern S3_ENDPOINT_PATTERN =
+            Pattern.compile("^(?:.+\\.)?s3[.-]([a-z0-9-]+)$");
+
+    /**
+     * @deprecated in favor of {@link #parseRegionName(String, String)}.
+     * @param endpoint the URI endpoint.
+     * @return the region name.
+     */
+    @Deprecated
+    public static String parseRegionName(URI endpoint) {
+        return parseRegionName(endpoint.getHost(), null);
+    }
+
+    /**
+     * Attempts to parse the region name from an endpoint based on conventions
+     * about the endpoint format.
+     *
+     * @param host the hostname to parse
+     * @param serviceHint an optional hint about the service for the endpoint
+     * @return the region parsed from the hostname, or &quot;us-east-1&quot; if
+     *         no region information could be found
+     */
+    public static String parseRegionName(final String host,
+            final String serviceHint) {
+
+        if (host == null) {
+            throw new IllegalArgumentException("hostname cannot be null");
+        }
+        String regionNameInInternalConfig = parseRegionNameByInternalConfig(host);
+        if (regionNameInInternalConfig != null) {
+            return regionNameInInternalConfig;
+        }
+
+        if (host.endsWith(".amazonaws.com")) {
+            int index = host.length() - ".amazonaws.com".length();
+            return parseStandardRegionName(host.substring(0, index));
+        }
+
+        if (host.endsWith(".amazonaws.com.cn")) {
+            int index = host.length() - ".amazonaws.com.cn".length();
+            return parseStandardRegionName(host.substring(0, index));
+        }
+
+        if (serviceHint != null) {
+            // If we have a service hint, look for 'service.[region]' or
+            // 'service-[region]' in the endpoint's hostname.
+            Pattern pattern = Pattern.compile(
+                    "^(?:.+\\.)?"
+                            + Pattern.quote(serviceHint)
+                            + "[.-]([a-z0-9-]+)\\."
+                    );
+
+            Matcher matcher = pattern.matcher(host);
+            if (matcher.find()) {
+                return matcher.group(1);
+            }
+        }
+
+        // Endpoint is totally non-standard; guess us-east-1 for lack of a
+        // better option.
+
+        return "us-east-1";
+    }
+
+    /**
+     * Parses the region name from a standard (*.amazonaws.com) endpoint.
+     *
+     * @param fragment the portion of the endpoint excluding
+     *            &quot;.amazonaws.com&quot;
+     * @return the parsed region name (or &quot;us-east-1&quot; as a best guess
+     *         if we can't tell for sure)
+     */
+    private static String parseStandardRegionName(final String fragment) {
+
+        Matcher matcher = S3_ENDPOINT_PATTERN.matcher(fragment);
+        if (matcher.matches()) {
+            // host was 'bucket.s3-[region].amazonaws.com'.
+            return matcher.group(1);
+        }
+
+        int index = fragment.lastIndexOf('.');
+        if (index == -1) {
+            // host was 'service.amazonaws.com', guess us-east-1
+            // for lack of a better option.
+            return "us-east-1";
+        }
+
+        // host was 'service.[region].amazonaws.com'.
+        String region = fragment.substring(index + 1);
+
+        // Special case for iam.us-gov.amazonaws.com, which is actually
+        // us-gov-west-1.
+        if ("us-gov".equals(region)) {
+            region = "us-gov-west-1";
+        }
+
+        return region;
+    }
+
+    /**
+     * @return the configured region name if the given host name matches any of
+     *         the host-to-region mappings in the internal config; otherwise
+     *         return null.
+     */
+    private static String parseRegionNameByInternalConfig(String host) {
+        InternalConfig internConfig = InternalConfig.Factory.getInternalConfig();
+
+        for (HostRegexToRegionMapping mapping : internConfig.getHostRegexToRegionMappings()) {
+            String hostNameRegex = mapping.getHostNameRegex();
+            if (host.matches(hostNameRegex)) {
+                return mapping.getRegionName();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Parses the service name from an endpoint. Can only handle endpoints of
+     * the form 'service.[region.]amazonaws.com'.
+     * @param endpoint the URI endpoint.
+     * @return the parsed service name.
+     * @deprecated because it's no longer needed by the SDK, and therefore not
+     *             maintained.
+     */
+    @Deprecated
+    public static String parseServiceName(URI endpoint) {
+        String host = endpoint.getHost();
+
+        // If we don't recognize the domain, throw an exception.
+        if (!host.endsWith(".amazonaws.com")) {
+            throw new IllegalArgumentException(
+                    "Cannot parse a service name from an unrecognized endpoint ("
+                            + host
+                            + ").");
+        }
+
+        String serviceAndRegion =
+                host.substring(0, host.indexOf(".amazonaws.com"));
+
+        // Special cases for S3 endpoints with bucket names embedded.
+        if (serviceAndRegion.endsWith(".s3")
+                || S3_ENDPOINT_PATTERN.matcher(serviceAndRegion).matches()) {
+            return "s3";
+        }
+
+        char separator = '.';
+
+        // If we don't detect a separator between service name and region, then
+        // assume that the region is not included in the hostname, and it's only
+        // the service name (ex: "http://iam.amazonaws.com").
+        if (serviceAndRegion.indexOf(separator) == -1) {
+            return serviceAndRegion;
+        }
+
+        String service =
+                serviceAndRegion.substring(0, serviceAndRegion.indexOf(separator));
+
+        return service;
+    }
+
+    /**
+     * @return the host name for the local host. If the operation is not allowed
+     * by the security check, the textual representation of the IP address of
+     * the local host is returned instead. If the ip address of the local host
+     * cannot be resolved or if there is any other failure, "localhost" is
+     * returned as a fallback.
+     */
+    public static String localHostName() {
+        try {
+            InetAddress localhost = InetAddress.getLocalHost();
+            return localhost.getHostName();
+        } catch (Exception e) {
+            LogFactory
+                    .getLog(AwsHostNameUtils.class)
+                    .debug("Failed to determine the local hostname; fall back to "
+                            + "use \"localhost\".", e);
+            return "localhost";
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16.java
new file mode 100644
index 0000000000..56d00df0b2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A Base 16 CODEC API. See http://www.ietf.org/rfc/rfc4648.txt
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum Base16 {
+    ;
+    private static final Base16Codec CODEC = new Base16Codec();
+
+    /**
+     * @param bytes the bytes.
+     * @return a base 16 encoded string of the given bytes.
+     */
+    public static String encodeAsString(byte... bytes) {
+        if (bytes == null)
+            return null;
+        return bytes.length == 0 ? "" : CodecUtils.toStringDirect(CODEC.encode(bytes));
+    }
+
+    /**
+     * @param bytes the bytes.
+     * @return a 16 encoded byte array of the given bytes.
+     */
+    public static byte[] encode(byte[] bytes) {
+        return bytes == null || bytes.length == 0 ? bytes : CODEC.encode(bytes);
+    }
+
+    /**
+     * Decodes the given base 16 encoded string, skipping carriage returns, line
+     * feeds and spaces as needed.
+     * @param b16 the string to decode.
+     * @return the decoded string in bytes.
+     */
+    public static byte[] decode(String b16) {
+        if (b16 == null)
+            return null;
+        if (b16.length() == 0)
+            return new byte[0];
+        byte[] buf = new byte[b16.length()];
+        int len = CodecUtils.sanitize(b16, buf);
+        return CODEC.decode(buf, len);
+    }
+
+    /**
+     * Decodes the given base 16 encoded bytes.
+     * @param b16 the byte[] to decode.
+     * @return the decoded result.
+     */
+    public static byte[] decode(byte[] b16) {
+        return b16 == null || b16.length == 0 ? b16 : CODEC.decode(b16, b16.length);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16Codec.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16Codec.java
new file mode 100644
index 0000000000..2c6102b7c7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base16Codec.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A Base 16 codec implementation.
+ *
+ * @author Hanson Char
+ */
+class Base16Codec implements Codec {
+    private static final int OFFSET_VALUE = 10;
+    private static final int BITS_4 = 4;
+
+    @SuppressWarnings("checkstyle:constantname")
+    private static final int OFFSET_OF_a = 'a' - OFFSET_VALUE;
+    private static final int OFFSET_OF_A = 'A' - OFFSET_VALUE;
+    private static final int MASK_4BITS = (1 << BITS_4) - 1;
+
+    private static class LazyHolder {
+        private static final byte[] DECODED = decodeTable();
+
+        private static byte[] decodeTable() {
+            final byte[] dest = new byte['f' + 1];
+
+            for (int i = 0; i <= 'f'; i++) {
+                if (i >= '0' && i <= '9')
+                    dest[i] = (byte) (i - '0');
+                else if (i >= 'A' && i <= 'F')
+                    dest[i] = (byte) (i - OFFSET_OF_A);
+                else if (i >= 'a' && i <= 'f')
+                    dest[i] = (byte) (i - OFFSET_OF_a);
+                else
+                    dest[i] = -1;
+            }
+            return dest;
+        }
+    }
+
+    private final byte[] alpahbets = CodecUtils.toBytesDirect("0123456789ABCDEF");
+
+    @Override
+    @SuppressWarnings("checkstyle:innerassignment")
+    public byte[] encode(byte[] src) {
+        byte[] dest = new byte[src.length * 2];
+        byte p;
+
+        for (int i = 0, j = 0; i < src.length; i++) {
+            dest[j++] = alpahbets[(p = src[i]) >>> BITS_4 & MASK_4BITS];
+            dest[j++] = alpahbets[p & MASK_4BITS];
+        }
+        return dest;
+    }
+
+    @Override
+    public byte[] decode(byte[] src, final int length) {
+        if (length % 2 != 0) {
+            throw new IllegalArgumentException(
+                    "Input is expected to be encoded in multiple of 2 bytes but found: "
+                            + length);
+        }
+        final byte[] dest = new byte[length / 2];
+
+        for (int i = 0, j = 0; j < dest.length; j++) {
+            dest[j] = (byte)
+                    (
+                    pos(src[i++]) << BITS_4 | pos(src[i++])
+                    );
+
+        }
+        return dest;
+    }
+
+    protected int pos(byte in) {
+        int pos = LazyHolder.DECODED[in];
+
+        if (pos > -1) {
+            return pos;
+        }
+        throw new IllegalArgumentException("Invalid base 16 character: \'" + (char) in + "\'");
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32.java
new file mode 100644
index 0000000000..d855ef14e7
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A Base 32 CODEC API. See http://www.ietf.org/rfc/rfc4648.txt
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum Base32 {
+    ;
+    private static final Base32Codec CODEC = new Base32Codec();
+
+    /**
+     * @param bytes the bytes.
+     * @return a base 32 encoded string of the given bytes.
+     */
+    public static String encodeAsString(byte... bytes) {
+        if (bytes == null) {
+            return null;
+        }
+        return bytes.length == 0 ? "" : CodecUtils.toStringDirect(CODEC.encode(bytes));
+    }
+
+    /**
+     * @param bytes the bytes.
+     * @return a 32 encoded byte array of the given bytes. hchar: compared to
+     * Base32.encode(byte[]) of JakartaCommons-1.5, this routine is > 20x faster
+     * on my MacAir.
+     */
+    public static byte[] encode(byte[] bytes) {
+        return bytes == null || bytes.length == 0 ? bytes : CODEC.encode(bytes);
+    }
+
+    /**
+     * Decodes the given base 32 encoded string, skipping carriage returns, line
+     * feeds and spaces as needed. hchar: compared to Base32.decode(String) of
+     * JakartaCommons-1.5, this routine is > 11x faster on my MacAir.
+     * @param b32 the base 32 encoded string.
+     * @return the decoded result.
+     */
+    public static byte[] decode(String b32) {
+        if (b32 == null) {
+            return null;
+        }
+        if (b32.length() == 0) {
+            return new byte[0];
+        }
+        byte[] buf = new byte[b32.length()];
+        int len = CodecUtils.sanitize(b32, buf);
+        return CODEC.decode(buf, len);
+    }
+
+    /**
+     * Decodes the given base 32 encoded bytes.
+     * @param b32 the base 32 encoded bytes.
+     * @return the decoded result.
+     */
+    public static byte[] decode(byte[] b32) {
+        return b32 == null || b32.length == 0 ? b32 : CODEC.decode(b32, b32.length);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32Codec.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32Codec.java
new file mode 100644
index 0000000000..6ac9594723
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base32Codec.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A Base 32 codec implementation.
+ *
+ * @author Hanson Char
+ */
+class Base32Codec extends AbstractBase32Codec {
+    private static final int OFFSET = 26;
+    private static final int OFFSET_OF_2 = '2' - OFFSET;
+
+    private static class LazyHolder {
+        private static final byte[] DECODED = decodeTable();
+
+        private static byte[] decodeTable() {
+            final byte[] dest = new byte['z' + 1];
+
+            for (int i = 0; i <= 'z'; i++) {
+                if (i >= 'A' && i <= 'Z')
+                    dest[i] = (byte) (i - 'A');
+                else if (i >= '2' && i <= '7')
+                    dest[i] = (byte) (i - OFFSET_OF_2);
+                else if (i >= 'a' && i <= 'z')
+                    dest[i] = (byte) (i - 'a');
+                else
+                    dest[i] = -1;
+            }
+            return dest;
+        }
+    }
+
+    private static byte[] alphabets() {
+        // Base 32 alphabet as defined at http://www.ietf.org/rfc/rfc4648.txt
+        return CodecUtils.toBytesDirect("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
+    }
+
+    Base32Codec() {
+        super(alphabets());
+    }
+
+    @Override
+    protected int pos(byte in) {
+        int pos = LazyHolder.DECODED[in];
+
+        if (pos > -1)
+            return pos;
+        throw new IllegalArgumentException("Invalid base 32 character: \'" + (char) in + "\'");
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64.java
new file mode 100644
index 0000000000..ed884a0fac
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A Base 64 CODEC API. See http://www.ietf.org/rfc/rfc4648.txt
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum Base64 {
+    ;
+    private static final Base64Codec CODEC = new Base64Codec();
+
+    /**
+     * @param bytes the bytes.
+     * @return a base 64 encoded string of the given bytes.
+     */
+    public static String encodeAsString(byte... bytes) {
+        if (bytes == null)
+            return null;
+        return bytes.length == 0 ? "" : CodecUtils.toStringDirect(CODEC.encode(bytes));
+    }
+
+    /**
+     * @param bytes the bytes.
+     * @return a 64 encoded byte array of the given bytes.
+     */
+    public static byte[] encode(byte[] bytes) {
+        return bytes == null || bytes.length == 0 ? bytes : CODEC.encode(bytes);
+    }
+
+    /**
+     * Decodes the given base 64 encoded string, skipping carriage returns, line
+     * feeds and spaces as needed.
+     * @param b64 the base 64 encoded string.
+     * @return the decoded result.
+     */
+    public static byte[] decode(String b64) {
+        if (b64 == null) {
+            return null;
+        }
+        if (b64.length() == 0) {
+            return new byte[0];
+        }
+        byte[] buf = new byte[b64.length()];
+        int len = CodecUtils.sanitize(b64, buf);
+        return CODEC.decode(buf, len);
+    }
+
+    /**
+     * Decodes the given base 64 encoded bytes.
+     * @param b64 the base 64 encoded bytes.
+     * @return the decoded result.
+     */
+    public static byte[] decode(byte[] b64) {
+        return b64 == null || b64.length == 0 ? b64 : CODEC.decode(b64, b64.length);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64Codec.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64Codec.java
new file mode 100644
index 0000000000..bca46a4a86
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Base64Codec.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.CodecUtils.sanityCheckLastPos;
+
+/**
+ * A Base 64 codec implementation.
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings({"checkstyle:constantname", "checkstyle:innerassignment"})
+class Base64Codec implements Codec {
+
+    private static final int OFFSET_a_VALUE = 26;
+    private static final int OFFSET_0_VALUE = 52;
+    private static final int OFFSET_PLUS_VALUE = 62;
+    private static final int OFFSET_SLASH_VALUE = 63;
+
+    private static final int OFFSET_OF_a = 'a' - OFFSET_a_VALUE;
+    private static final int OFFSET_OF_0 = '0' - OFFSET_0_VALUE;
+    private static final int OFFSET_OF_PLUS = '+' - OFFSET_PLUS_VALUE;
+    private static final int OFFSET_OF_SLASH = '/' - OFFSET_SLASH_VALUE;
+
+    private static final int BITS_3 = 3;
+    private static final int BITS_4 = 4;
+    private static final int BITS_6 = 6;
+
+    private static final int MASK_2BITS = (1 << 2) - 1;
+    private static final int MASK_4BITS = (1 << BITS_4) - 1;
+    private static final int MASK_6BITS = (1 << BITS_6) - 1;
+    // Alphabet as defined at http://www.ietf.org/rfc/rfc4648.txt
+    private static final byte PAD = '=';
+
+    private static class LazyHolder {
+        private static final byte[] DECODED = decodeTable();
+
+        private static byte[] decodeTable() {
+            final byte[] dest = new byte['z' + 1];
+
+            for (int i = 0; i <= 'z'; i++) {
+                if (i >= 'A' && i <= 'Z')
+                    dest[i] = (byte) (i - 'A');
+                else if (i >= '0' && i <= '9')
+                    dest[i] = (byte) (i - OFFSET_OF_0);
+                else if (i == '+')
+                    dest[i] = (byte) (i - OFFSET_OF_PLUS);
+                else if (i == '/')
+                    dest[i] = (byte) (i - OFFSET_OF_SLASH);
+                else if (i >= 'a' && i <= 'z')
+                    dest[i] = (byte) (i - OFFSET_OF_a);
+                else
+                    dest[i] = -1;
+            }
+            return dest;
+        }
+    }
+
+    private final byte[] alpahbets;
+
+    Base64Codec() {
+        alpahbets = CodecUtils
+                .toBytesDirect("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
+    }
+
+    protected Base64Codec(byte[] alphabets) {
+        alpahbets = alphabets;
+    }
+
+    @Override
+    public byte[] encode(byte[] src) {
+        final int num3bytes = src.length / BITS_3;
+        final int remainder = src.length % BITS_3;
+
+        if (remainder == 0) {
+            byte[] dest = new byte[num3bytes * BITS_4];
+
+            for (int s = 0, d = 0; s < src.length; s += BITS_3, d += BITS_4)
+                encode3bytes(src, s, dest, d);
+            return dest;
+        }
+
+        byte[] dest = new byte[(num3bytes + 1) * BITS_4];
+        int s = 0, d = 0;
+
+        for (; s < src.length - remainder; s += BITS_3, d += BITS_4)
+            encode3bytes(src, s, dest, d);
+
+        switch (remainder) {
+            case 1:
+                encode1byte(src, s, dest, d);
+                break;
+            case 2:
+                encode2bytes(src, s, dest, d);
+                break;
+            default:
+                break;
+        }
+        return dest;
+    }
+
+    void encode3bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> 2 & MASK_6BITS]; // 6
+        dest[d++] = alpahbets[(p & MASK_2BITS) << BITS_4 | (p = src[s++]) >>> BITS_4 & MASK_4BITS]; // 2
+                                                                                          // 4
+        dest[d++] = alpahbets[(p & MASK_4BITS) << 2 | (p = src[s]) >>> BITS_6 & MASK_2BITS]; // 4
+                                                                                        // 2
+        dest[d] = alpahbets[p & MASK_6BITS]; // 6
+        return;
+    }
+
+    void encode2bytes(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s++]) >>> 2 & MASK_6BITS]; // 6
+        dest[d++] = alpahbets[(p & MASK_2BITS) << BITS_4 | (p = src[s]) >>> BITS_4 & MASK_4BITS]; // 2
+                                                                                        // 4
+        dest[d++] = alpahbets[(p & MASK_4BITS) << 2]; // 4
+        dest[d] = PAD;
+        return;
+    }
+
+    void encode1byte(byte[] src, int s, byte[] dest, int d) {
+        // operator precedence in descending order: >>> or <<, &, |
+        byte p;
+        dest[d++] = alpahbets[(p = src[s]) >>> 2 & MASK_6BITS]; // 6
+        dest[d++] = alpahbets[(p & MASK_2BITS) << BITS_4]; // 2
+        dest[d++] = PAD;
+        dest[d] = PAD;
+        return;
+    }
+
+    void decode4bytes(byte[] src, int s, byte[] dest, int d) {
+        int p = 0;
+        // operator precedence in descending order: >>> or <<, &, |
+        dest[d++] = (byte)
+                (
+                pos(src[s++]) << 2
+                | (p = pos(src[s++])) >>> BITS_4 & MASK_2BITS
+                ); // 6 2
+        dest[d++] = (byte)
+                (
+                (p & MASK_4BITS) << BITS_4
+                | (p = pos(src[s++])) >>> 2 & MASK_4BITS
+                ); // 4 4
+        dest[d] = (byte)
+                (
+                (p & MASK_2BITS) << BITS_6
+                | pos(src[s])
+                ); // 2 6
+        return;
+    }
+
+    /**
+     * @param n the number of final quantum in bytes to decode into. Ranges from
+     *            1 to 3, inclusive.
+     */
+    void decode1to3bytes(int n, byte[] src, int s, byte[] dest, int d) {
+        int p = 0;
+        // operator precedence in descending order: >>> or <<, &, |
+        dest[d++] = (byte)
+                (
+                pos(src[s++]) << 2
+                | (p = pos(src[s++])) >>> BITS_4 & MASK_2BITS
+                ); // 6 2
+        if (n == 1) {
+            sanityCheckLastPos(p, MASK_4BITS);
+            return;
+        }
+
+        dest[d++] = (byte)
+                (
+                (p & MASK_4BITS) << BITS_4
+                | (p = pos(src[s++])) >>> 2 & MASK_4BITS
+                ); // 4 4
+        if (n == 2) {
+            sanityCheckLastPos(p, MASK_2BITS);
+            return;
+        }
+
+        dest[d] = (byte)
+                (
+                (p & MASK_2BITS) << BITS_6
+                | pos(src[s])
+                ); // 2 6
+        return;
+    }
+
+    @Override
+    public byte[] decode(byte[] src, final int length) {
+        if (length % BITS_4 != 0)
+            throw new IllegalArgumentException(
+                    "Input is expected to be encoded in multiple of 4 bytes but found: " + length);
+
+        int pads = 0;
+        int last = length - 1;
+
+        // max possible padding in b64 encoding is 2
+        for (; pads < 2 && last > -1; last--, pads++) {
+            if (src[last] != PAD)
+                break;
+        }
+
+        final int fq; // final quantum in unit of bytes
+
+        switch (pads) {
+            case 0:
+                fq = BITS_3;
+                break; // final quantum of encoding input is an integral
+                       // multiple of 24 bits
+            case 1:
+                fq = 2;
+                break; // final quantum of encoding input is exactly 16 bits
+            case 2:
+                fq = 1;
+                break; // final quantum of encoding input is exactly 8 bits
+            default:
+                throw new Error("Impossible");
+        }
+        final byte[] dest = new byte[length / BITS_4 * BITS_3 - (BITS_3 - fq)];
+        int s = 0, d = 0;
+
+        // % has a higher precedence than - than <
+        for (; d < dest.length - fq % BITS_3; s += BITS_4, d += BITS_3) {
+            decode4bytes(src, s, dest, d);
+        }
+
+        if (fq < BITS_3) {
+            decode1to3bytes(fq, src, s, dest, d);
+        }
+        return dest;
+    }
+
+    protected int pos(byte in) {
+        int pos = LazyHolder.DECODED[in];
+
+        if (pos > -1)
+            return pos;
+        throw new IllegalArgumentException("Invalid base 64 character: \'" + (char) in + "\'");
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/BinaryUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/BinaryUtils.java
new file mode 100644
index 0000000000..c56e1e710c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/BinaryUtils.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Utilities for encoding and decoding binary data to and from different forms.
+ */
+public class BinaryUtils {
+
+    private static final int HEX_LENGTH_8 = 8;
+    private static final int HEX_PARSE_16 = 16;
+    private static final int FF_LOCATION = 6;
+
+    /**
+     * Converts byte data to a Hex-encoded string.
+     *
+     * @param data data to hex encode.
+     * @return hex-encoded string.
+     */
+    public static String toHex(byte[] data) {
+        final StringBuilder sb = new StringBuilder(data.length * 2);
+        for (int i = 0; i < data.length; i++) {
+            String hex = Integer.toHexString(data[i]);
+            if (hex.length() == 1) {
+                // Append leading zero.
+                sb.append("0");
+            } else if (hex.length() == HEX_LENGTH_8) {
+                // Remove ff prefix from negative numbers.
+                hex = hex.substring(FF_LOCATION);
+            }
+            sb.append(hex);
+        }
+        return StringUtils.lowerCase(sb.toString());
+    }
+
+    /**
+     * Converts a Hex-encoded data string to the original byte data.
+     *
+     * @param hexData hex-encoded data to decode.
+     * @return decoded data from the hex string.
+     */
+    public static byte[] fromHex(String hexData) {
+        final byte[] result = new byte[(hexData.length() + 1) / 2];
+        String hexNumber = null;
+        int stringOffset = 0;
+        int byteOffset = 0;
+        while (stringOffset < hexData.length()) {
+            hexNumber = hexData.substring(stringOffset, stringOffset + 2);
+            stringOffset += 2;
+            result[byteOffset++] = (byte) Integer.parseInt(hexNumber, HEX_PARSE_16);
+        }
+        return result;
+    }
+
+    /**
+     * Converts byte data to a Base64-encoded string.
+     *
+     * @param data data to Base64 encode.
+     * @return encoded Base64 string.
+     */
+    public static String toBase64(byte[] data) {
+        return Base64.encodeAsString(data);
+    }
+
+    /**
+     * Converts a Base64-encoded string to the original byte data.
+     *
+     * @param b64Data a Base64-encoded string to decode.
+     * @return bytes decoded from a Base64 string.
+     */
+    public static byte[] fromBase64(String b64Data) {
+        return b64Data == null ? null : Base64.decode(b64Data);
+    }
+
+    /**
+     * Wraps a ByteBuffer in an InputStream.
+     *
+     * @param byteBuffer The ByteBuffer to wrap.
+     * @return An InputStream wrapping the ByteBuffer content.
+     */
+    public static InputStream toStream(ByteBuffer byteBuffer) {
+        final byte[] bytes = new byte[byteBuffer.remaining()];
+        byteBuffer.get(bytes);
+        return new ByteArrayInputStream(bytes);
+    }
+
+    /**
+     * @param bb the byte buffer.
+     * @return a copy of all the bytes from the given <code>ByteBuffer</code>,
+     * from the beginning to the buffer's limit; or null if the input is null.
+     * <p>
+     * The internal states of the given byte buffer will be restored when this
+     * method completes execution.
+     * <p>
+     * When handling <code>ByteBuffer</code> from user's input, it's typical to
+     * call the {@link #copyBytesFrom(ByteBuffer)} instead of
+     * {@link #copyAllBytesFrom(ByteBuffer)} so as to account for the position
+     * of the input <code>ByteBuffer</code>. The opposite is typically true,
+     * however, when handling <code>ByteBuffer</code> from within the
+     * unmarshallers of the low-level clients.
+     */
+    public static byte[] copyAllBytesFrom(ByteBuffer bb) {
+        if (bb == null) {
+            return null;
+        }
+
+        if (bb.hasArray()) {
+            return Arrays.copyOfRange(
+                    bb.array(),
+                    bb.arrayOffset(),
+                    bb.arrayOffset() + bb.limit());
+        }
+
+        final ByteBuffer copy = bb.asReadOnlyBuffer();
+        copy.rewind();
+
+        final byte[] dst = new byte[copy.remaining()];
+        copy.get(dst);
+        return dst;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/CRC32ChecksumCalculatingInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CRC32ChecksumCalculatingInputStream.java
new file mode 100644
index 0000000000..472169ec0a
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CRC32ChecksumCalculatingInputStream.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.CRC32;
+
+/**
+ * Simple InputStream wrapper that examines the wrapped stream's contents as
+ * they are read and calculates and CRC32 checksum.
+ */
+public class CRC32ChecksumCalculatingInputStream extends SdkFilterInputStream {
+
+    /** The CRC32 being calculated by this input stream */
+    private CRC32 crc32;
+
+    /**
+     * Constructor.
+     * @param in the input stream.
+     */
+    public CRC32ChecksumCalculatingInputStream(InputStream in) {
+        super(in);
+        crc32 = new CRC32();
+    }
+
+    public long getCRC32Checksum() {
+        return crc32.getValue();
+    }
+
+    /**
+     * Resets the wrapped input stream and the CRC32 computation.
+     *
+     * @see java.io.InputStream#reset()
+     */
+    @Override
+    public synchronized void reset() throws IOException {
+        abortIfNeeded();
+        crc32.reset();
+        in.reset();
+    }
+
+    /**
+     * @see java.io.InputStream#read()
+     */
+    @Override
+    public int read() throws IOException {
+        abortIfNeeded();
+        int ch = in.read();
+        if (ch != -1) {
+            crc32.update(ch);
+        }
+        return ch;
+    }
+
+    /**
+     * @see java.io.InputStream#read(byte[], int, int)
+     */
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        abortIfNeeded();
+        int result = in.read(b, off, len);
+        if (result != -1) {
+            crc32.update(b, off, result);
+        }
+        return result;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/ClassLoaderHelper.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ClassLoaderHelper.java
new file mode 100644
index 0000000000..39ed85e9a9
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ClassLoaderHelper.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2011-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+
+/**
+ * The class loader helper class.
+ */
+@SuppressWarnings({"checkstyle:nowhitespacebefore", "checkstyle:emptyblock"})
+public enum ClassLoaderHelper {
+    ;
+    /**
+     * Retrieves the resource via the context class loader of the current
+     * thread, and if not found, via the class loaders of the optionally
+     * specified classes in the order of their specification, and if not found,
+     * from the class loader of {@link ClassLoaderHelper} as the last resort.
+     *
+     * @param resource resource to be loaded
+     * @param classes class loader providers
+     * @return the resource loaded as an URL or null if not found.
+     */
+    public static URL getResource(String resource, Class<?>... classes) {
+        return getResource(resource, false, classes);
+    }
+
+    /**
+     * If classesFirst is false, retrieves the resource via the context class
+     * loader of the current thread, and if not found, via the class loaders of
+     * the optionally specified classes in the order of their specification, and
+     * if not found, from the class loader of {@link ClassLoaderHelper} as the
+     * last resort.
+     * <p>
+     * If classesFirst is true, retrieves the resource via the optionally
+     * specified classes in the order of their specification, and if not found,
+     * via the context class loader of the current thread, and if not found,
+     * from the class loader of {@link ClassLoaderHelper} as the last resort.
+     *
+     * @param resource resource to be loaded
+     * @param classesFirst true if the class loaders of the optionally specified
+     *            classes take precedence over the context class loader of the
+     *            current thread; false if the opposite is true.
+     * @param classes class loader providers
+     * @return the resource loaded as an URL or null if not found.
+     */
+    public static URL getResource(String resource, boolean classesFirst,
+            Class<?>... classes) {
+        URL url;
+        if (classesFirst) {
+            url = getResourceViaClasses(resource, classes);
+            if (url == null) {
+                url = getResourceViaContext(resource);
+            }
+        } else {
+            url = getResourceViaContext(resource);
+            if (url == null) {
+                url = getResourceViaClasses(resource, classes);
+            }
+        }
+        return url == null ? ClassLoaderHelper.class.getResource(resource) : url;
+    }
+
+    private static URL getResourceViaClasses(String resource, Class<?>[] classes) {
+        if (classes != null) {
+            for (Class<?> c : classes) {
+                URL url = c.getResource(resource);
+                if (url != null)
+                    return url;
+            }
+        }
+        return null;
+    }
+
+    private static URL getResourceViaContext(String resource) {
+        ClassLoader loader = Thread.currentThread().getContextClassLoader();
+        return loader == null ? null : loader.getResource(resource);
+    }
+
+    private static Class<?> loadClassViaClasses(String fqcn, Class<?>[] classes) {
+        if (classes != null) {
+            for (Class<?> c : classes) {
+                ClassLoader loader = c.getClassLoader();
+                if (loader != null) {
+                    try {
+                        return loader.loadClass(fqcn);
+                    } catch (ClassNotFoundException e) {
+                        // move on to try the next class loader
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private static Class<?> loadClassViaContext(String fqcn) {
+        ClassLoader loader = Thread.currentThread().getContextClassLoader();
+        try {
+            return loader == null ? null : loader.loadClass(fqcn);
+        } catch (ClassNotFoundException e) {
+        }
+        return null;
+    }
+
+    /**
+     * Loads the class via the optionally specified classes in the order of
+     * their specification, and if not found, via the context class loader of
+     * the current thread, and if not found, from the caller class loader as the
+     * last resort.
+     *
+     * @param fqcn fully qualified class name of the target class to be loaded
+     * @param classes class loader providers
+     * @return the class loaded; never null
+     * @throws ClassNotFoundException if failed to load the class
+     */
+    public static Class<?> loadClass(String fqcn, Class<?>... classes)
+            throws ClassNotFoundException {
+        return loadClass(fqcn, true, classes);
+    }
+
+    /**
+     * If classesFirst is false, loads the class via the context class loader of
+     * the current thread, and if not found, via the class loaders of the
+     * optionally specified classes in the order of their specification, and if
+     * not found, from the caller class loader as the last resort.
+     * <p>
+     * If classesFirst is true, loads the class via the optionally specified
+     * classes in the order of their specification, and if not found, via the
+     * context class loader of the current thread, and if not found, from the
+     * caller class loader as the last resort.
+     *
+     * @param fqcn fully qualified class name of the target class to be loaded
+     * @param classesFirst true if the class loaders of the optionally specified
+     *            classes take precedence over the context class loader of the
+     *            current thread; false if the opposite is true.
+     * @param classes class loader providers
+     * @return the class loaded; never null
+     * @throws ClassNotFoundException if failed to load the class
+     */
+    public static Class<?> loadClass(String fqcn, boolean classesFirst,
+            Class<?>... classes) throws ClassNotFoundException {
+        Class<?> target = null;
+        if (classesFirst) {
+            target = loadClassViaClasses(fqcn, classes);
+            if (target == null) {
+                target = loadClassViaContext(fqcn);
+            }
+        } else {
+            target = loadClassViaContext(fqcn);
+            if (target == null) {
+                target = loadClassViaClasses(fqcn, classes);
+            }
+        }
+        return target == null ? Class.forName(fqcn) : target;
+    }
+
+    /**
+     * Retrieves the resource as an input stream via the context class loader of
+     * the current thread, and if not found, via the class loaders of the
+     * optionally specified classes in the order of their specification, and if
+     * not found, from the class loader of {@link ClassLoaderHelper} as the last
+     * resort.
+     *
+     * @param resource resource to be loaded
+     * @param classes class loader providers
+     * @return the resource loaded as an input stream or null if not found.
+     */
+    public static InputStream getResourceAsStream(String resource,
+            Class<?>... classes) {
+        return getResourceAsStream(resource, false, classes);
+    }
+
+    /**
+     * If classesFirst is false, retrieves the resource as an input stream via
+     * the context class loader of the current thread, and if not found, via the
+     * class loaders of the optionally specified classes in the order of their
+     * specification, and if not found, from the class loader of
+     * {@link ClassLoaderHelper} as the last resort.
+     * <p>
+     * If classesFirst is true, retrieves the resource as an input stream via
+     * the optionally specified classes in the order of their specification, and
+     * if not found, via the context class loader of the current thread, and if
+     * not found, from the class loader of {@link ClassLoaderHelper} as the last
+     * resort.
+     *
+     * @param resource resource to be loaded
+     * @param classesFirst true if the class loaders of the optionally specified
+     *            classes take precedence over the context class loader of the
+     *            current thread; false if the opposite is true.
+     * @param classes class loader providers
+     * @return the resource loaded as an input stream or null if not found.
+     */
+    public static InputStream getResourceAsStream(String resource,
+            boolean classesFirst, Class<?>... classes) {
+        URL url = getResource(resource, classesFirst, classes);
+        try {
+            return url != null ? url.openStream() : null;
+        } catch (IOException e) {
+            return null;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Classes.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Classes.java
new file mode 100644
index 0000000000..b3c34a743f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Classes.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.jar.JarFile;
+
+/**
+ * Classes related utilities.
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum Classes {
+    ;
+    /**
+     * @return the class of the immediate subclass of the given parent class for
+     * the given object instance; or null if such immediate subclass cannot be
+     * uniquely identified for the given object instance.
+     *
+     * @param parentClass the parent class. The child class is {@link Object} if
+     *            and only if the parent class is null.
+     * @param instance the given object instance
+     */
+    public static Class<?> childClassOf(Class<?> parentClass,
+            Object instance) {
+        if (instance == null || instance == Object.class)
+            return null;
+        if (parentClass != null) {
+            if (parentClass.isInterface()) {
+                // child of an interface class is not injective (ie one-to-one)
+                return null;
+            }
+        }
+        Class<?> childClass = instance.getClass();
+        while (true) {
+            Class<?> parent = childClass.getSuperclass();
+            if (parent == parentClass)
+                return childClass;
+            if (parent == null)
+                return null;
+            childClass = parent;
+        }
+    }
+
+    /**
+     * @param klass class.
+     * @return the jar file from which the given class is loaded; or null if no
+     * such jar file can be located.
+     */
+    public static JarFile jarFileOf(Class<?> klass) {
+        URL url = klass.getResource(
+                "/" + klass.getName().replace('.', '/') + ".class");
+        if (url == null)
+            return null;
+        String s = url.getFile();
+        int beginIndex = s.indexOf("file:") + "file:".length();
+        int endIndex = s.indexOf(".jar!");
+        if (endIndex == -1)
+            return null;
+        endIndex += ".jar".length();
+        String f = s.substring(beginIndex, endIndex);
+        File file = new File(f);
+        try {
+            return file.exists() ? new JarFile(file) : null;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Codec.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Codec.java
new file mode 100644
index 0000000000..d45c19635d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Codec.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * Codec SPI
+ *
+ * @author Hanson Char
+ */
+interface Codec {
+    public byte[] encode(byte[] src);
+
+    public byte[] decode(byte[] src, final int length);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/CodecUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CodecUtils.java
new file mode 100644
index 0000000000..51a178eddc
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CodecUtils.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * Codec internal utilities
+ *
+ * @author Hanson Char
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum CodecUtils {
+    ;
+    /**
+     * Transforms the given string into the given destination byte array
+     * truncating each character into a byte and skipping carriage returns and
+     * line feeds if any.
+     * <p>
+     * dmurray: "It so happens that we're currently only calling this method
+     * with src.length == dest.length, in which case it works, but we could
+     * theoretically get away with passing a smaller dest if we knew ahead of
+     * time that src contained some number of spaces. In that case it looks like
+     * this implementation would truncate the result."
+     * <p>
+     * hchar: "Yes, but the truncation is the intentional behavior of this
+     * internal routine in that case."
+     *
+     * @param singleOctets non-null string containing only single octet
+     *            characters
+     * @param dest destination byte array
+     * @return the actual length of the destination byte array holding data
+     * @throws IllegalArgumentException if the input string contains any
+     *             multi-octet character
+     */
+    static int sanitize(final String singleOctets, byte[] dest) {
+        final int capacity = dest.length;
+        final char[] src = singleOctets.toCharArray();
+        int limit = 0;
+
+        for (int i = 0; i < capacity; i++) {
+            final char c = src[i];
+
+            if (c == '\r' || c == '\n' || c == ' ')
+                continue;
+            if (c > Byte.MAX_VALUE)
+                throw new IllegalArgumentException("Invalid character found at position " + i
+                        + " for " + singleOctets);
+            dest[limit++] = (byte) c;
+        }
+        return limit;
+    }
+
+    /**
+     * @param singleOctets the string of single octet.
+     * @return a byte array representing the given string, truncating each
+     * character into a byte directly.
+     *
+     * @throws IllegalArgumentException if the input string contains any
+     *             multi-octet character
+     */
+    public static byte[] toBytesDirect(final String singleOctets) {
+        final char[] src = singleOctets.toCharArray();
+        final byte[] dest = new byte[src.length];
+
+        for (int i = 0; i < dest.length; i++) {
+            final char c = src[i];
+
+            if (c > Byte.MAX_VALUE)
+                throw new IllegalArgumentException("Invalid character found at position " + i
+                        + " for " + singleOctets);
+            dest[i] = (byte) c;
+        }
+        return dest;
+    }
+
+    /**
+     * @param bytes the bytes.
+     * @return a string representing the given byte array, treating each byte as
+     * a single octet character.
+     */
+    public static String toStringDirect(final byte[] bytes) {
+        final char[] dest = new char[bytes.length];
+        int i = 0;
+
+        for (byte b : bytes)
+            dest[i++] = (char) b;
+
+        return new String(dest);
+    }
+
+    /**
+     * Sanity check the last decoded position is a possible value.
+     *
+     * @param pos the position.
+     * @param mask the mask int.
+     * @throws IllegalArgumentException if the given decoded position is not a
+     *             possible value produced via the respective encoding
+     */
+    static void sanityCheckLastPos(int pos, int mask) {
+        if ((pos & mask) != 0) {
+            throw new IllegalArgumentException("Invalid last non-pad character detected");
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/CountingInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CountingInputStream.java
new file mode 100644
index 0000000000..4d30c15953
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/CountingInputStream.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Simple input stream wrapper utility to count the bytes read from a stream.
+ *
+ * @deprecated This class is no longer used and will be removed in the future
+ */
+@Deprecated
+public class CountingInputStream extends SdkFilterInputStream {
+    private long byteCount = 0;
+
+    /**
+     * Constructor.
+     * @param in the input stream.
+     */
+    public CountingInputStream(InputStream in) {
+        super(in);
+    }
+
+    /**
+     * Returns the number of bytes read from this stream so far.
+     *
+     * @return the number of bytes read from this stream so far.
+     */
+    public long getByteCount() {
+        return byteCount;
+    }
+
+    @Override
+    public int read() throws IOException {
+        int tmp = super.read();
+        byteCount += tmp >= 0 ? 1 : 0;
+        return tmp;
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        int tmp = super.read(b, off, len);
+        byteCount += tmp >= 0 ? tmp : 0;
+        return tmp;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/DateUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/DateUtils.java
new file mode 100644
index 0000000000..26599bcfb8
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/DateUtils.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Utilities for parsing and formatting dates.
+ */
+public class DateUtils {
+    /**
+     * ISO 8601 format
+     */
+    public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'";
+    /**
+     * Alternate ISO 8601 format without fractional seconds
+     */
+    public static final String ALTERNATE_ISO8601_DATE_PATTERN = "yyyy-MM-dd'T'HH:mm:ss'Z'";
+    /**
+     * RFC 822 format
+     */
+    public static final String RFC822_DATE_PATTERN = "EEE, dd MMM yyyy HH:mm:ss z";
+    /**
+     * This is another ISO 8601 format that's used in clock skew error response
+     */
+    public static final String COMPRESSED_DATE_PATTERN = "yyyyMMdd'T'HHmmss'Z'";
+
+    private static final TimeZone GMT_TIMEZONE = TimeZone.getTimeZone("GMT");
+
+    /**
+     * A map to cache date pattern string to SimpleDateFormat object
+     */
+    private static final Map<String, ThreadLocal<SimpleDateFormat>> SDF_MAP = new HashMap<String, ThreadLocal<SimpleDateFormat>>();
+
+    /**
+     * A helper function to retrieve a SimpleDateFormat object for the given
+     * date pattern
+     *
+     * @param pattern date pattern
+     * @return SimpleDateFormat object
+     */
+    private static ThreadLocal<SimpleDateFormat> getSimpleDateFormat(final String pattern) {
+        ThreadLocal<SimpleDateFormat> sdf = SDF_MAP.get(pattern);
+        if (sdf == null) {
+            synchronized (SDF_MAP) {
+                sdf = SDF_MAP.get(pattern);
+                if (sdf == null) {
+                    sdf = new ThreadLocal<SimpleDateFormat>() {
+                        @Override
+                        protected SimpleDateFormat initialValue() {
+                            final SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.US);
+                            sdf.setTimeZone(GMT_TIMEZONE);
+                            sdf.setLenient(false);
+                            return sdf;
+                        }
+                    };
+                    SDF_MAP.put(pattern, sdf);
+                }
+            }
+        }
+        return sdf;
+    }
+
+    /**
+     * Parses the specified date string with the given date pattern and returns
+     * the Date object.
+     *
+     * @param pattern date pattern
+     * @param dateString The date string to parse.
+     * @return The parsed Date object.
+     */
+    public static Date parse(String pattern, String dateString) {
+        try {
+            return getSimpleDateFormat(pattern).get().parse(dateString);
+        } catch (final ParseException pe) {
+            throw new IllegalArgumentException(pe);
+        }
+    }
+
+    /**
+     * Formats the specific date into the given pattern
+     *
+     * @param pattern date pattern
+     * @param date date to be formatted
+     * @return formated string representing the give date
+     */
+    public static String format(String pattern, Date date) {
+        return getSimpleDateFormat(pattern).get().format(date);
+    }
+
+    /**
+     * Parses the specified date string as an ISO 8601 date and returns the Date
+     * object.
+     *
+     * @param dateString The date string to parse.
+     * @return The parsed Date object.
+     */
+    public static Date parseISO8601Date(String dateString) {
+        try {
+            return parse(ISO8601_DATE_PATTERN, dateString);
+        } catch (final IllegalArgumentException e) {
+            // If the first ISO 8601 parser didn't work, try the alternate
+            // version which doesn't include fractional seconds
+            return parse(ALTERNATE_ISO8601_DATE_PATTERN, dateString);
+        }
+    }
+
+    /**
+     * Formats the specified date as an ISO 8601 string.
+     *
+     * @param date The date to format.
+     * @return The ISO 8601 string representing the specified date.
+     */
+    public static String formatISO8601Date(Date date) {
+        return format(ISO8601_DATE_PATTERN, date);
+    }
+
+    /**
+     * Parses the specified date string as an RFC 822 date and returns the Date
+     * object.
+     *
+     * @param dateString The date string to parse.
+     * @return The parsed Date object.
+     */
+    public static Date parseRFC822Date(String dateString) {
+        return parse(RFC822_DATE_PATTERN, dateString);
+    }
+
+    /**
+     * Formats the specified date as an RFC 822 string.
+     *
+     * @param date The date to format.
+     * @return The RFC 822 string representing the specified date.
+     */
+    public static String formatRFC822Date(Date date) {
+        return format(RFC822_DATE_PATTERN, date);
+    }
+
+    /**
+     * Parses the specified date string as a compressedIso8601DateFormat
+     * ("yyyyMMdd'T'HHmmss'Z'") and returns the Date object.
+     *
+     * @param dateString The date string to parse.
+     * @return The parsed Date object.
+     */
+    public static Date parseCompressedISO8601Date(String dateString) {
+        return parse(COMPRESSED_DATE_PATTERN, dateString);
+    }
+
+    /**
+     * Clone date.
+     *
+     * @param date the date to clone.
+     * @return the cloned Date.
+     */
+    public static Date cloneDate(Date date) {
+        return date == null ? null : new Date(date.getTime());
+    }
+
+    /**
+     * @return the number of days since epoch with respect to the given number
+     * of milliseconds since epoch.
+     *
+     * @param milliSinceEpoch milliseconds since epoch.
+     */
+    public static long numberOfDaysSinceEpoch(long milliSinceEpoch) {
+        return TimeUnit.MILLISECONDS.toDays(milliSinceEpoch);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingScheme.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingScheme.java
new file mode 100644
index 0000000000..5e0be6461f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingScheme.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * Encoding scheme.
+ *
+ * @author Hanson Char
+ */
+public interface EncodingScheme {
+
+    /**
+     * @param bytes bytes to encode.
+     * @return the string result.
+     */
+    public String encodeAsString(byte[] bytes);
+
+    /**
+     * @param encoded string to decode.
+     * @return the decoded result.
+     */
+    public byte[] decode(String encoded);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingSchemeEnum.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingSchemeEnum.java
new file mode 100644
index 0000000000..81c7e7f6dc
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/EncodingSchemeEnum.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * Currently provided encoding schemes "out of the box".
+ *
+ * @author Hanson Char See http://www.ietf.org/rfc/rfc4648.txt
+ */
+public enum EncodingSchemeEnum implements EncodingScheme {
+
+    /** Base 16. */
+    BASE16 {
+        @Override
+        public String encodeAsString(byte[] bytes) {
+            return Base16.encodeAsString(bytes);
+        }
+
+        @Override
+        public byte[] decode(String encoded) {
+            return Base16.decode(encoded);
+        }
+    },
+
+    /** Base 32. */
+    BASE32 {
+        @Override
+        public String encodeAsString(byte[] bytes) {
+            return Base32.encodeAsString(bytes);
+        }
+
+        @Override
+        public byte[] decode(String encoded) {
+            return Base32.decode(encoded);
+        }
+    },
+
+    /** Base 64. */
+    BASE64 {
+        @Override
+        public String encodeAsString(byte[] bytes) {
+            return Base64.encodeAsString(bytes);
+        }
+
+        @Override
+        public byte[] decode(String encoded) {
+            return Base64.decode(encoded);
+        }
+    };
+
+    @Override
+    public abstract String encodeAsString(byte[] bytes);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpClientWrappingInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpClientWrappingInputStream.java
new file mode 100644
index 0000000000..1ee0374848
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpClientWrappingInputStream.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import org.apache.http.client.HttpClient;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * An {@code InputStream} that closes the associated {@code HttpClient} when the
+ * stream is closed.
+ */
+class HttpClientWrappingInputStream extends SdkFilterInputStream {
+
+    private final HttpClient client;
+
+    /**
+     * @param client the {@code HttpClient} to wrap
+     * @param stream the {@code InputStream} to wrap
+     */
+    public HttpClientWrappingInputStream(
+            final HttpClient client,
+            final InputStream stream) {
+
+        super(stream);
+        this.client = client;
+    }
+
+    @Override
+    public void close() throws IOException {
+        try {
+            super.close();
+        } finally {
+            client.getConnectionManager().shutdown();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpUtils.java
new file mode 100644
index 0000000000..571d8a4ab1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/HttpUtils.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.Request;
+import com.amazonaws.http.HttpMethodName;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.util.Map.Entry;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * HTTP utils class.
+ */
+public class HttpUtils {
+
+    private static final String DEFAULT_ENCODING = "UTF-8";
+    private static final int PORT_HTTP = 80;
+    private static final int PORT_HTTPS = 443;
+    private static final int HTTP_STATUS_OK = 200;
+
+    /**
+     * Regex which matches any of the sequences that we need to fix up after
+     * URLEncoder.encode().
+     */
+    private static final Pattern ENCODED_CHARACTERS_PATTERN;
+    static {
+        final StringBuilder pattern = new StringBuilder();
+
+        pattern
+                .append(Pattern.quote("+"))
+                .append("|")
+                .append(Pattern.quote("*"))
+                .append("|")
+                .append(Pattern.quote("%7E"))
+                .append("|")
+                .append(Pattern.quote("%2F"));
+
+        ENCODED_CHARACTERS_PATTERN = Pattern.compile(pattern.toString());
+    }
+
+    private static final Pattern DECODED_CHARACTERS_PATTERN;
+    static {
+        final StringBuilder decodePattern = new StringBuilder();
+
+        decodePattern.append(Pattern.quote("%2A"))
+                .append("|")
+                .append(Pattern.quote("%2B"))
+                .append("|");
+
+        DECODED_CHARACTERS_PATTERN = Pattern.compile(decodePattern.toString());
+
+    }
+
+    /**
+     * Encode a string for use in the path of a URL; uses URLEncoder.encode,
+     * (which encodes a string for use in the query portion of a URL), then
+     * applies some postfilters to fix things up per the RFC. Can optionally
+     * handle strings which are meant to encode a path (ie include '/'es which
+     * should NOT be escaped).
+     *
+     * @param value the value to encode
+     * @param path true if the value is intended to represent a path
+     * @return the encoded value
+     */
+    public static String urlEncode(final String value, final boolean path) {
+        if (value == null) {
+            return "";
+        }
+
+        try {
+            final String encoded = URLEncoder.encode(value, DEFAULT_ENCODING);
+
+            final Matcher matcher = ENCODED_CHARACTERS_PATTERN.matcher(encoded);
+            final StringBuffer buffer = new StringBuffer(encoded.length());
+
+            while (matcher.find()) {
+                String replacement = matcher.group(0);
+
+                if ("+".equals(replacement)) {
+                    replacement = "%20";
+                } else if ("*".equals(replacement)) {
+                    replacement = "%2A";
+                } else if ("%7E".equals(replacement)) {
+                    replacement = "~";
+                } else if (path && "%2F".equals(replacement)) {
+                    replacement = "/";
+                }
+                matcher.appendReplacement(buffer, replacement);
+            }
+
+            matcher.appendTail(buffer);
+            return buffer.toString();
+
+        } catch (final UnsupportedEncodingException ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    /**
+     * Decode a string for use in the path of a URL; uses URLDecoder.decode,
+     * which decodes a string for use in the query portion of a URL.
+     *
+     * @param value The value to decode
+     * @return The decoded value if parameter is not null, otherwise, null is
+     *         returned.
+     */
+    public static String urlDecode(final String value) {
+        if (value == null) {
+            return null;
+        }
+
+        try {
+            return URLDecoder.decode(value, DEFAULT_ENCODING);
+        } catch (final UnsupportedEncodingException ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    /**
+     * Returns true if the specified URI is using a non-standard port (i.e. any
+     * port other than 80 for HTTP URIs or any port other than 443 for HTTPS
+     * URIs).
+     *
+     * @param uri the URI.
+     * @return True if the specified URI is using a non-standard port, otherwise
+     *         false.
+     */
+    public static boolean isUsingNonDefaultPort(URI uri) {
+        final String scheme = StringUtils.lowerCase(uri.getScheme());
+        final int port = uri.getPort();
+
+        if (port <= 0) {
+            return false;
+        }
+        if ("http".equals(scheme) && port == PORT_HTTP) {
+            return false;
+        }
+        if ("https".equals(scheme) && port == PORT_HTTPS) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * @param request the request.
+     * @return true if request is post and request has no payload.
+     */
+    public static boolean usePayloadForQueryParameters(Request<?> request) {
+        final boolean requestIsPOST = HttpMethodName.POST.equals(request.getHttpMethod());
+        final boolean requestHasNoPayload = (request.getContent() == null);
+
+        return requestIsPOST && requestHasNoPayload;
+    }
+
+    /**
+     * Creates an encoded query string from all the parameters in the specified
+     * request.
+     *
+     * @param request The request containing the parameters to encode.
+     * @return Null if no parameters were present, otherwise the encoded query
+     *         string for the parameters present in the specified request.
+     */
+    public static String encodeParameters(Request<?> request) {
+        if (request.getParameters().isEmpty()) {
+            return null;
+        }
+        final StringBuilder sb = new StringBuilder();
+        boolean first = true;
+        try {
+            for (final Entry<String, String> entry : request.getParameters().entrySet()) {
+                final String encodedName = URLEncoder.encode(entry.getKey(), DEFAULT_ENCODING);
+                final String value = entry.getValue();
+                final String encodedValue = value == null ? "" : URLEncoder.encode(value,
+                        DEFAULT_ENCODING);
+                if (!first) {
+                    sb.append("&");
+                } else {
+                    first = false;
+                }
+                sb.append(encodedName).append("=").append(encodedValue);
+            }
+        } catch (final UnsupportedEncodingException e) {
+            throw new IllegalArgumentException(e);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Append the given path to the given baseUri. By default, all slash
+     * characters in path will not be url-encoded.
+     * @param baseUri the base URI.
+     * @param path the path.
+     * @return the appended URI.
+     */
+    public static String appendUri(String baseUri, String path) {
+        return appendUri(baseUri, path, false);
+    }
+
+    /**
+     * Append the given path to the given baseUri.
+     * <p>
+     * This method will encode the given path but not the given baseUri.
+     * </p>
+     *
+     * @param baseUri The URI to append to (required, may be relative)
+     * @param path The path to append (may be null or empty)
+     * @param escapeDoubleSlash Whether double-slash in the path should be
+     *            escaped to "/%2F"
+     * @return The baseUri with the (encoded) path appended
+     */
+    public static String appendUri(final String baseUri, String path,
+            final boolean escapeDoubleSlash) {
+        String resultUri = baseUri;
+        if (path != null && path.length() > 0) {
+            if (path.startsWith("/")) {
+                // trim the trailing slash in baseUri, since the path already
+                // starts with a slash
+                if (resultUri.endsWith("/")) {
+                    resultUri = resultUri.substring(0, resultUri.length() - 1);
+                }
+            } else if (!resultUri.endsWith("/")) {
+                resultUri += "/";
+            }
+            String encodedPath = HttpUtils.urlEncode(path, true);
+            if (escapeDoubleSlash) {
+                encodedPath = encodedPath.replace("//", "/%2F");
+            }
+            resultUri += encodedPath;
+        } else if (!resultUri.endsWith("/")) {
+            resultUri += "/";
+        }
+
+        return resultUri;
+    }
+
+    /**
+     * Fetches a file from the URI given and returns an input stream to it.
+     *
+     * @param uri the uri of the file to fetch
+     * @param config optional configuration overrides
+     * @return an InputStream containing the retrieved data
+     * @throws IOException on error
+     */
+    public static InputStream fetchFile(
+            final URI uri,
+            final ClientConfiguration config) throws IOException {
+        final URL url = uri.toURL();
+        // TODO: support proxy?
+        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setConnectTimeout(getConnectionTimeout(config));
+        connection.setReadTimeout(getSocketTimeout(config));
+        connection.addRequestProperty("User-Agent", getUserAgent(config));
+
+        if (connection.getResponseCode() != HTTP_STATUS_OK) {
+            final InputStream is = connection.getErrorStream();
+            if (is != null) {
+                is.close();
+            }
+            connection.disconnect();
+            throw new IOException("Error fetching file from " + uri + ": "
+                    + connection.getResponseMessage());
+        }
+
+        return connection.getInputStream();
+    }
+
+    static String getUserAgent(final ClientConfiguration config) {
+        String userAgent = null;
+
+        if (config != null) {
+            userAgent = config.getUserAgent();
+        }
+
+        if (userAgent == null) {
+            userAgent = ClientConfiguration.DEFAULT_USER_AGENT;
+        } else if (!ClientConfiguration.DEFAULT_USER_AGENT.equals(userAgent)) {
+            userAgent += ", " + ClientConfiguration.DEFAULT_USER_AGENT;
+        }
+
+        return userAgent;
+    }
+
+    static int getConnectionTimeout(final ClientConfiguration config) {
+        if (config != null) {
+            return config.getConnectionTimeout();
+        }
+        return ClientConfiguration.DEFAULT_CONNECTION_TIMEOUT;
+    }
+
+    static int getSocketTimeout(final ClientConfiguration config) {
+        if (config != null) {
+            return config.getSocketTimeout();
+        }
+        return ClientConfiguration.DEFAULT_SOCKET_TIMEOUT;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/IOUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/IOUtils.java
new file mode 100644
index 0000000000..582b61a336
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/IOUtils.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Utilities for IO operations.
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum IOUtils {
+    ;
+
+    private static final Log logger = LogFactory.getLog(IOUtils.class);
+    private static final int BUFFER_SIZE = 1024 * 4;
+
+    /**
+     * Reads and returns the rest of the given input stream as a byte array,
+     * closing the input stream afterwards.
+     * @param is the input stream.
+     * @return the rest of the given input stream.
+     */
+    public static byte[] toByteArray(InputStream is) throws IOException {
+        final ByteArrayOutputStream output = new ByteArrayOutputStream();
+        try {
+            final byte[] b = new byte[BUFFER_SIZE];
+            int n = 0;
+            while ((n = is.read(b)) != -1) {
+                output.write(b, 0, n);
+            }
+            return output.toByteArray();
+        } finally {
+            output.close();
+        }
+    }
+
+    /**
+     * Reads and returns the rest of the given input stream as a string, closing
+     * the input stream afterwards.
+     * @param is the input stream.
+     * @return the rest of the given input stream.
+     */
+    public static String toString(InputStream is) throws IOException {
+        return new String(toByteArray(is), StringUtils.UTF8);
+    }
+
+    /**
+     * Closes the given Closeable quietly.
+     *
+     * @param is the given closeable
+     * @param log logger used to log any failure should the close fail
+     */
+    public static void closeQuietly(Closeable is, Log log) {
+        if (is != null) {
+            try {
+                is.close();
+            } catch (final IOException ex) {
+                if (logger.isDebugEnabled()) {
+                    logger.debug("Ignore failure in closing the Closeable", ex);
+                }
+            }
+        }
+    }
+
+    /**
+     * Releases the given {@link Closeable} especially if it was an instance of
+     * {@link Releasable}.
+     * <p>
+     * For example, the creation of a <code>ResettableInputStream</code> would
+     * entail physically opening a file. If the opened file is meant to be
+     * closed only (in a finally block) by the very same code block that created
+     * it, then it is necessary that the release method must not be called while
+     * the execution is made in other stack frames. In such case, as other stack
+     * frames may inadvertently or indirectly call the close method of the
+     * stream, the creator of the stream would need to explicitly disable the
+     * accidental closing via <code>ResettableInputStream#disableClose()</code>,
+     * so that the release method becomes the only way to truly close the opened
+     * file.
+     * @param is the closeable.
+     * @param log the log.
+     */
+    public static void release(Closeable is, Log log) {
+        closeQuietly(is, log);
+    }
+
+    /**
+     * Copies all bytes from the given input stream to the given output stream.
+     * Caller is responsible for closing the streams.
+     * @param in the input stream.
+     * @param out the output stream.
+     *
+     * @return the count of bytes copied.
+     * @throws IOException if there is any IO exception during read or write.
+     */
+    public static long copy(InputStream in, OutputStream out)
+            throws IOException {
+        final byte[] buf = new byte[BUFFER_SIZE];
+        long count = 0;
+        int n = 0;
+        while ((n = in.read(buf)) > -1) {
+            out.write(buf, 0, n);
+            count += n;
+        }
+        return count;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/ImmutableMapParameter.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ImmutableMapParameter.java
new file mode 100644
index 0000000000..49d7b5e1cb
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ImmutableMapParameter.java
@@ -0,0 +1,289 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * An immutable map that could be built by convenient constructors.
+ * <p>
+ * Example of using map Builder:
+ *
+ * <pre>
+ * {
+ *     &#064;code
+ *     Map&lt;String, AttibuteValue&gt; item =
+ *             new ImmutableMapParameter.Builder&lt;String, AttibuteValue&gt;()
+ *                     .put(&quot;one&quot;, new AttibuteValue(&quot;1&quot;))
+ *                     .put(&quot;two&quot;, new AttibuteValue(&quot;2&quot;))
+ *                     .put(&quot;three&quot;, new AttibuteValue(&quot;3&quot;))
+ *                     .build();
+ * }
+ * </pre>
+ *
+ * For <i>small</i> immutable maps (up to five entries), the
+ * {@code ImmutableMapParamter.of()} methods are preferred:
+ *
+ * <pre>
+ * {@code
+ *   Map<String, AttibuteValue> item =
+ *       ImmutableMapParameter
+ *           .of("one", new AttributeValue("1"),
+ *               "two", new AttributeValue("2"),
+ *               "three", new AttributeValue("3"),
+ * }
+ * </pre>
+ *
+ * @param <K> Class of the key for the map.
+ * @param <V> Class of the value for the map.
+ */
+public final class ImmutableMapParameter<K, V> implements Map<K, V> {
+
+    private static final String UNMODIFIABLE_MESSAGE = "This is an immutable map.";
+    private static final String DUPLICATED_KEY_MESSAGE = "Duplicate keys are provided.";
+
+    private final Map<K, V> map;
+
+    private ImmutableMapParameter(Map<K, V> map) {
+        this.map = map;
+    }
+
+    /**
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     * @return a new MapParameterBuilder instance.
+     */
+    public static <K, V> Builder<K, V> builder() {
+        return new Builder<K, V>();
+    }
+
+    /**
+     * @return an ImmutableMapParameter instance containing a single entry.
+     *
+     * @param k0 Key of the single entry.
+     * @param v0 Value of the single entry.
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     */
+    public static <K, V> ImmutableMapParameter<K, V> of(K k0, V v0) {
+        Map<K, V> map = Collections.singletonMap(k0, v0);
+        return new ImmutableMapParameter<K, V>(map);
+    }
+
+    /**
+     * @return an ImmutableMapParameter instance containing two entries.
+     *
+     * @param k0 Key of the first entry.
+     * @param v0 Value of the first entry.
+     * @param k1 Key of the second entry.
+     * @param v1 Value of the second entry.
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     */
+    public static <K, V> ImmutableMapParameter<K, V> of(K k0, V v0, K k1, V v1) {
+        Map<K, V> map = new HashMap<K, V>();
+        putAndWarnDuplicateKeys(map, k0, v0);
+        putAndWarnDuplicateKeys(map, k1, v1);
+        return new ImmutableMapParameter<K, V>(map);
+    }
+
+    /**
+     * @return an ImmutableMapParameter instance containing three entries.
+     *
+     * @param k0 Key of the first entry.
+     * @param v0 Value of the first entry.
+     * @param k1 Key of the second entry.
+     * @param v1 Value of the second entry.
+     * @param k2 Key of the third entry.
+     * @param v2 Value of the third entry.
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     */
+    public static <K, V> ImmutableMapParameter<K, V> of(K k0, V v0, K k1, V v1, K k2, V v2) {
+        Map<K, V> map = new HashMap<K, V>();
+        putAndWarnDuplicateKeys(map, k0, v0);
+        putAndWarnDuplicateKeys(map, k1, v1);
+        putAndWarnDuplicateKeys(map, k2, v2);
+        return new ImmutableMapParameter<K, V>(map);
+    }
+
+    /**
+     * @return an ImmutableMapParameter instance containing four entries.
+     *
+     * @param k0 Key of the first entry.
+     * @param v0 Value of the first entry.
+     * @param k1 Key of the second entry.
+     * @param v1 Value of the second entry.
+     * @param k2 Key of the third entry.
+     * @param v2 Value of the third entry.
+     * @param k3 Key of the fourth entry.
+     * @param v3 Value of the fourth entry.
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     */
+    public static <K, V> ImmutableMapParameter<K, V> of(K k0, V v0, K k1, V v1, K k2, V v2, K k3,
+            V v3) {
+        Map<K, V> map = new HashMap<K, V>();
+        putAndWarnDuplicateKeys(map, k0, v0);
+        putAndWarnDuplicateKeys(map, k1, v1);
+        putAndWarnDuplicateKeys(map, k2, v2);
+        putAndWarnDuplicateKeys(map, k3, v3);
+        return new ImmutableMapParameter<K, V>(map);
+    }
+
+    /**
+     * @return an ImmutableMapParameter instance containing five entries.
+     *
+     * @param k0 Key of the first entry.
+     * @param v0 Value of the first entry.
+     * @param k1 Key of the second entry.
+     * @param v1 Value of the second entry.
+     * @param k2 Key of the third entry.
+     * @param v2 Value of the third entry.
+     * @param k3 Key of the fourth entry.
+     * @param v3 Value of the fourth entry.
+     * @param k4 Key of the fifth entry.
+     * @param v4 Value of the fifth entry.
+     * @param <K> Class of the key for the map.
+     * @param <V> Class of the value for the map.
+     */
+    public static <K, V> ImmutableMapParameter<K, V> of(K k0, V v0, K k1, V v1, K k2, V v2, K k3,
+            V v3, K k4, V v4) {
+        Map<K, V> map = new HashMap<K, V>();
+        putAndWarnDuplicateKeys(map, k0, v0);
+        putAndWarnDuplicateKeys(map, k1, v1);
+        putAndWarnDuplicateKeys(map, k2, v2);
+        putAndWarnDuplicateKeys(map, k3, v3);
+        putAndWarnDuplicateKeys(map, k4, v4);
+        return new ImmutableMapParameter<K, V>(map);
+    }
+
+    /** Inherited methods **/
+
+    @Override
+    public boolean containsKey(Object key) {
+        return map.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return map.containsValue(value);
+    }
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return map.entrySet();
+    }
+
+    @Override
+    public V get(Object key) {
+        return map.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return map.isEmpty();
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return map.keySet();
+    }
+
+    @Override
+    public int size() {
+        return map.size();
+    }
+
+    @Override
+    public Collection<V> values() {
+        return map.values();
+    }
+
+    /** Unsupported methods **/
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException(UNMODIFIABLE_MESSAGE);
+    }
+
+    @Override
+    public V put(K key, V value) {
+        throw new UnsupportedOperationException(UNMODIFIABLE_MESSAGE);
+    }
+
+    @Override
+    @SuppressWarnings("checkstyle:hiddenfield")
+    public void putAll(Map<? extends K, ? extends V> map) {
+        throw new UnsupportedOperationException(UNMODIFIABLE_MESSAGE);
+    }
+
+    @Override
+    public V remove(Object key) {
+        throw new UnsupportedOperationException(UNMODIFIABLE_MESSAGE);
+    }
+
+    private static <K, V> void putAndWarnDuplicateKeys(Map<K, V> map, K key, V value) {
+        if (map.containsKey(key))
+            throw new IllegalArgumentException(DUPLICATED_KEY_MESSAGE);
+        map.put(key, value);
+    }
+
+    /**
+     * A convenient builder for creating ImmutableMapParameter instances.
+     */
+    public static class Builder<K, V> {
+
+        private final Map<K, V> entries;
+
+        /**
+         * Builder.
+         */
+        public Builder() {
+            this.entries = new HashMap<K, V>();
+        }
+
+        /**
+         * Add a key-value pair into the built map. The method will throw
+         * IllegalArgumentException immediately when duplicate keys are
+         * provided.
+         * @param key the key.
+         * @param value the value.
+         * @return Returns a reference to this object so that method calls can
+         *         be chained together.
+         */
+        public Builder<K, V> put(K key, V value) {
+            putAndWarnDuplicateKeys(entries, key, value);
+            return this;
+        }
+
+        /**
+         * Generates and returns a new ImmutableMapParameter instance which
+         * contains all the entries added into the Builder by {@code put()}
+         * method.
+         * @return a new ImmutableMapParameter instance
+         */
+        public ImmutableMapParameter<K, V> build() {
+            HashMap<K, V> builtMap = new HashMap<K, V>();
+            builtMap.putAll(entries);
+            return new ImmutableMapParameter<K, V>(builtMap);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/LengthCheckInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/LengthCheckInputStream.java
new file mode 100644
index 0000000000..02a4ca0037
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/LengthCheckInputStream.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2014-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Used to perform length check to ensure the number of bytes read from the
+ * underlying input stream is the same as the expected total.
+ */
+public class LengthCheckInputStream extends SdkFilterInputStream {
+
+    /** Include skipped bytes. */
+    public static final boolean INCLUDE_SKIPPED_BYTES = true;
+
+    /** Exclude skipped bytes. */
+    public static final boolean EXCLUDE_SKIPPED_BYTES = false;
+    /**
+     * Total number of bytes expected to be read from the underlying input
+     * stream.
+     */
+    private final long expectedLength;
+    /**
+     * True if skipped bytes are to be included as part of the data length;
+     * false otherwise.
+     */
+    private final boolean includeSkipped;
+    /**
+     * The length of the data read from the underlying input stream so far.
+     */
+    private long dataLength;
+    private long marked; // used for mark-and-reset purposes
+
+    /**
+     * Constructs an input stream that performs length check to ensure the
+     * number of bytes read from the underlying input stream is the same as the
+     * expected total.
+     *
+     * @param in the underlying input stream
+     * @param expectedLength the total length of the data in bytes expected to
+     *            be read from the underlying input stream; must be
+     *            non-negative.
+     * @param includeSkipped true if bytes skipped are to be considered as part
+     *            of the data length; false otherwise. Typically, this parameter
+     *            should be set to false for uploading data to AWS, but set to
+     *            true for receiving data from AWS.
+     */
+    public LengthCheckInputStream(InputStream in, long expectedLength,
+            boolean includeSkipped) {
+        super(in);
+        if (expectedLength < 0)
+            throw new IllegalArgumentException();
+        this.expectedLength = expectedLength;
+        this.includeSkipped = includeSkipped;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws AmazonClientException if the data length read has exceeded the
+     *             expected total, or if the total data length is not the same
+     *             as the expected total.
+     */
+    @Override
+    public int read() throws IOException {
+        final int c = super.read();
+        if (c >= 0)
+            dataLength++;
+        checkLength(c == -1);
+        return c;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws AmazonClientException if the data length read has exceeded the
+     *             expected total, or if the total data length is not the same
+     *             as the expected total.
+     */
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        int readLen = super.read(b, off, len);
+        dataLength += readLen >= 0 ? readLen : 0;
+        checkLength(readLen == -1);
+        return readLen;
+    }
+
+    @Override
+    public void mark(int readlimit) {
+        super.mark(readlimit);
+        marked = dataLength;
+    }
+
+    @Override
+    public void reset() throws IOException {
+        super.reset();
+        if (super.markSupported()) {
+            dataLength = marked;
+        }
+    }
+
+    /**
+     * Checks the data length read so far against the expected total.
+     *
+     * @param eof true if end of stream has been encountered; false otherwise
+     * @throws AmazonClientException if the data length read has exceeded the
+     *             expected total, or if the total data length is not the same
+     *             as the expected total.
+     */
+    private void checkLength(boolean eof) {
+        if (eof) {
+            if (dataLength != expectedLength) {
+                throw new AmazonClientException("Data read (" + dataLength
+                        + ") has a different length than the expected ("
+                        + expectedLength + ")");
+            }
+        } else if (dataLength > expectedLength) {
+            throw new AmazonClientException("More data read (" + dataLength
+                    + ") than expected (" + expectedLength + ")");
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws AmazonClientException if {@link #includeSkipped} is true and the
+     *             data length skipped has exceeded the expected total.
+     */
+    @Override
+    public long skip(long n) throws IOException {
+        final long skipped = super.skip(n);
+        if (includeSkipped && skipped > 0) {
+            dataLength += skipped;
+            checkLength(false);
+        }
+        return skipped;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Md5Utils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Md5Utils.java
new file mode 100644
index 0000000000..f2556efc37
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Md5Utils.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2012-2018 Amazon Technologies, Inc.
+ *
+ * Portions copyright 2006-2009 James Murty. Please see LICENSE.txt
+ * for applicable license terms and NOTICE.txt for applicable notices.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.LogFactory;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Utility methods for computing MD5 sums.
+ */
+public class Md5Utils {
+
+    private static final int FOURTEEN = 14;
+    private static final int SIXTEEN_K = 1 << FOURTEEN;
+
+    /**
+     * Computes the MD5 hash of the data in the given input stream and returns
+     * it as an array of bytes. Note this method closes the given input stream
+     * upon completion.
+     * @param is the input stream.
+     * @return MD5 hash of the data.
+     */
+    public static byte[] computeMD5Hash(InputStream is) throws IOException {
+        BufferedInputStream bis = new BufferedInputStream(is);
+        try {
+            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+            byte[] buffer = new byte[SIXTEEN_K];
+            int bytesRead;
+            while ((bytesRead = bis.read(buffer, 0, buffer.length)) != -1) {
+                messageDigest.update(buffer, 0, bytesRead);
+            }
+            return messageDigest.digest();
+        } catch (NoSuchAlgorithmException e) {
+            // should never get here
+            throw new IllegalStateException(e);
+        } finally {
+            try {
+                bis.close();
+            } catch (Exception e) {
+                LogFactory.getLog(Md5Utils.class).debug(
+                        "Unable to close input stream of hash candidate: " + e);
+            }
+        }
+    }
+
+    /**
+     * @param is the input stream.
+     * @return the MD5 in base64 for the data from the given input stream. Note
+     * this method closes the given input stream upon completion.
+     */
+    public static String md5AsBase64(InputStream is) throws IOException {
+        return Base64.encodeAsString(computeMD5Hash(is));
+    }
+
+    /**
+     * Computes the MD5 hash of the given data and returns it as an array of
+     * bytes.
+     * @param input the input in bytes.
+     * @return the MD5 hash of the data.
+     */
+    public static byte[] computeMD5Hash(byte[] input) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(input);
+        } catch (NoSuchAlgorithmException e) {
+            // should never get here
+            throw new IllegalStateException(e);
+        }
+    }
+
+    /**
+     * @param input the input in bytes.
+     * @return the MD5 in base64 for the given byte array.
+     */
+    public static String md5AsBase64(byte[] input) {
+        return Base64.encodeAsString(computeMD5Hash(input));
+    }
+
+    /**
+     * Computes the MD5 of the given file.
+     * @param file the file.
+     * @return the MD5 hash of the data.
+     */
+    public static byte[] computeMD5Hash(File file) throws IOException {
+        return computeMD5Hash(new FileInputStream(file));
+    }
+
+    /**
+     * @param file the file.
+     * @return the MD5 in base64 for the given file.
+     */
+    public static String md5AsBase64(File file) throws IOException {
+        return Base64.encodeAsString(computeMD5Hash(file));
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/NamespaceRemovingInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/NamespaceRemovingInputStream.java
new file mode 100644
index 0000000000..a241e2afc4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/NamespaceRemovingInputStream.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * FilterInputStream implementation that wraps an InputStream containing an XML
+ * document, and removes the XML namespace attribute from the XML document.
+ */
+class NamespaceRemovingInputStream extends SdkFilterInputStream {
+
+    private static final int BUFFER_SIZE = 200;
+
+    /** look ahead buffer */
+    private final byte[] lookAheadData = new byte[BUFFER_SIZE];
+
+    /** Set to true once the namespace has been removed */
+    private boolean hasRemovedNamespace = false;
+
+    /**
+     * Constructs a new NamespaceRemovingInputStream wrapping the specified
+     * InputStream.
+     *
+     * @param in The InputStream containing an XML document whose XML namespace
+     *            is to be removed.
+     */
+    public NamespaceRemovingInputStream(InputStream in) {
+        // Wrap our input stream in a buffered input stream to ensure
+        // that it support mark/reset
+        super(new BufferedInputStream(in));
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.io.FilterInputStream#read()
+     */
+    @Override
+    public int read() throws IOException {
+        abortIfNeeded();
+        int b = in.read();
+        if (b == 'x' && !hasRemovedNamespace) {
+            lookAheadData[0] = (byte) b;
+            in.mark(lookAheadData.length);
+            int bytesRead = in.read(lookAheadData, 1, lookAheadData.length - 1);
+            in.reset();
+
+            String string = new String(lookAheadData, 0, bytesRead + 1, StringUtils.UTF8);
+
+            int numberCharsMatched = matchXmlNamespaceAttribute(string);
+            if (numberCharsMatched > 0) {
+                for (int i = 0; i < numberCharsMatched - 1; i++) {
+                    in.read();
+                }
+                b = in.read();
+                hasRemovedNamespace = true;
+            }
+        }
+
+        return b;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.io.FilterInputStream#read(byte[], int, int)
+     */
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        for (int i = 0; i < len; i++) {
+            int j = this.read();
+            if (j == -1) {
+                if (i == 0)
+                    return -1;
+                return i;
+            }
+
+            b[i + off] = (byte) j;
+        }
+
+        return len;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see java.io.FilterInputStream#read(byte[])
+     */
+    @Override
+    public int read(byte[] b) throws IOException {
+        return this.read(b, 0, b.length);
+    }
+
+    /**
+     * Checks if the string starts with a complete XML namespace attribute, and
+     * if so, returns the number of characters that match.
+     *
+     * @param s The string to check for an XML namespace definition.
+     * @return -1 if no XML namespace definition was found, otherwise the length
+     *         of the identified XML namespace definition.
+     */
+    private int matchXmlNamespaceAttribute(String s) {
+        /*
+         * The regex we're simulating is: "xmlns\\s*=\\s*\".+?\".*"
+         */
+        StringPrefixSlicer stringSlicer = new StringPrefixSlicer(s);
+        if (!stringSlicer.removePrefix("xmlns"))
+            return -1;
+
+        stringSlicer.removeRepeatingPrefix(" ");
+        if (!stringSlicer.removePrefix("="))
+            return -1;
+        stringSlicer.removeRepeatingPrefix(" ");
+
+        if (!stringSlicer.removePrefix("\""))
+            return -1;
+        if (!stringSlicer.removePrefixEndingWith("\""))
+            return -1;
+
+        return s.length() - stringSlicer.getString().length();
+    }
+
+    /**
+     * Utility class to help test and remove specified prefixes from a string.
+     */
+    private static final class StringPrefixSlicer {
+        private String s;
+
+        public StringPrefixSlicer(String s) {
+            this.s = s;
+        }
+
+        /**
+         * @return The remaining String (minus any prefixes that have been
+         *         removed).
+         */
+        public String getString() {
+            return s;
+        }
+
+        public boolean removePrefix(String prefix) {
+            if (!s.startsWith(prefix))
+                return false;
+            s = s.substring(prefix.length());
+            return true;
+        }
+
+        public boolean removeRepeatingPrefix(String prefix) {
+            if (!s.startsWith(prefix))
+                return false;
+
+            while (s.startsWith(prefix)) {
+                s = s.substring(prefix.length());
+            }
+            return true;
+        }
+
+        public boolean removePrefixEndingWith(String marker) {
+            int i = s.indexOf(marker);
+            if (i < 0)
+                return false;
+            s = s.substring(i + marker.length());
+            return true;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/ResponseMetadataCache.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ResponseMetadataCache.java
new file mode 100644
index 0000000000..55cd7fae9d
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ResponseMetadataCache.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.ResponseMetadata;
+
+import java.util.LinkedHashMap;
+import java.util.Map.Entry;
+
+/**
+ * Cache of response metadata for recently executed requests for diagnostic
+ * purposes. This cache has a max size and as entries are added, the oldest
+ * entry is aged out once the max size has been reached.
+ */
+public class ResponseMetadataCache {
+    private final InternalCache internalCache;
+
+    /**
+     * Creates a new cache that will contain, at most the specified number of
+     * entries.
+     *
+     * @param maxEntries The maximum size of this cache.
+     */
+    public ResponseMetadataCache(int maxEntries) {
+        internalCache = new InternalCache(maxEntries);
+    }
+
+    /**
+     * Adds a new entry to this cache, possibly evicting the oldest entry if the
+     * cache is at its size limit.
+     *
+     * @param obj The key by which to store the metadata.
+     * @param metadata The metadata for this entry.
+     */
+    public synchronized void add(Object obj, ResponseMetadata metadata) {
+        if (obj == null)
+            return;
+        internalCache.put(System.identityHashCode(obj), metadata);
+    }
+
+    /**
+     * Returns the response metadata associated with the specified object, or
+     * null if no metadata is associated with that object.
+     *
+     * @param obj The key by which the desired metadata is stored.
+     * @return The response metadata associated with the given object key,
+     *         otherwise null if no metadata is associated with that object.
+     */
+    public ResponseMetadata get(Object obj) {
+        // System.identityHashCode isn't guaranteed to be unique
+        // on all platforms, but should be reasonable enough to use
+        // for a few requests at a time. We can always easily move
+        // to our own unique IDs if needed.
+        return internalCache.get(System.identityHashCode(obj));
+    }
+
+    /**
+     * Simple implementation of LinkedHashMap that overrides the
+     * <code>removeEldestEntry</code> method to turn LinkedHashMap into a
+     * LRU(ish) cache that automatically evicts old entries.
+     */
+    private static final class InternalCache extends LinkedHashMap<Integer, ResponseMetadata> {
+        private int maxSize;
+
+        public InternalCache(int maxSize) {
+            super(maxSize);
+            this.maxSize = maxSize;
+        }
+
+        @Override
+        protected boolean removeEldestEntry(Entry eldest) {
+            return size() > maxSize;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/RuntimeHttpUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/RuntimeHttpUtils.java
new file mode 100644
index 0000000000..fce2caaba2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/RuntimeHttpUtils.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.util;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.Protocol;
+import com.amazonaws.Request;
+
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.Map;
+
+/**
+ * RuntimeHttpUtils class.
+ */
+public class RuntimeHttpUtils {
+    private static final String COMMA = ", ";
+    private static final String SPACE = " ";
+
+    /**
+     * @param endpoint the endpoint.
+     * @param config the client configuration.
+     * @return an URI for the given endpoint. Prefixes the protocol if the
+     * endpoint given does not have it.
+     *
+     * @throws IllegalArgumentException if the inputs are null.
+     */
+    public static URI toUri(String endpoint, ClientConfiguration config) {
+
+        if (config == null) {
+            throw new IllegalArgumentException("ClientConfiguration cannot be null");
+        }
+        return toUri(endpoint, config.getProtocol());
+    }
+
+    /**
+     * @param endpoint the endpoint.
+     * @param protocol the protocol.
+     * @return an URI for the given endpoint. Prefixes the protocol if the
+     * endpoint given does not have it.
+     *
+     * @throws IllegalArgumentException if the inputs are null.
+     */
+    public static URI toUri(String endpoint, Protocol protocol) {
+        if (endpoint == null) {
+            throw new IllegalArgumentException("endpoint cannot be null");
+        }
+
+        /*
+         * If the endpoint doesn't explicitly specify a protocol to use, then
+         * we'll defer to the default protocol specified in the client
+         * configuration.
+         */
+        if (!endpoint.contains("://")) {
+            endpoint = protocol.toString() + "://" + endpoint;
+        }
+
+        try {
+            return new URI(endpoint);
+        } catch (final URISyntaxException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Converts the specified request object into a URL, containing all the
+     * specified parameters, the specified request endpoint, etc.
+     *
+     * @param request The request to convert into a URL.
+     * @param removeLeadingSlashInResourcePath Whether the leading slash in
+     *            resource-path should be removed before appending to the
+     *            endpoint.
+     * @param urlEncode True if request resource path should be URL encoded
+     * @return A new URL representing the specified request.
+     */
+    public static URL convertRequestToUrl(Request<?> request,
+            boolean removeLeadingSlashInResourcePath,
+            boolean urlEncode) {
+        String resourcePath = urlEncode ? HttpUtils.urlEncode(request.getResourcePath(), true)
+                : request.getResourcePath();
+
+        // Removed the padding "/" that was already added into the request's
+        // resource path.
+        if (removeLeadingSlashInResourcePath
+                && resourcePath.startsWith("/")) {
+            resourcePath = resourcePath.substring(1);
+        }
+
+        // Some http client libraries (e.g. Apache HttpClient) cannot handle
+        // consecutive "/"s between URL authority and path components.
+        // So we escape "////..." into "/%2F%2F%2F...", in the same way as how
+        // we treat consecutive "/"s in AmazonS3Client#presignRequest(...)
+
+        String urlPath = "/" + resourcePath;
+        urlPath = urlPath.replaceAll("(?<=/)/", "%2F");
+        final StringBuilder url = new StringBuilder(request.getEndpoint().toString());
+        url.append(urlPath);
+
+        StringBuilder queryParams = new StringBuilder();
+        final Map<String, String> requestParams = request.getParameters();
+        for (final Map.Entry<String, String> entry : requestParams.entrySet()) {
+            queryParams = queryParams.length() > 0 ? queryParams
+                    .append("&") : queryParams.append("?");
+            queryParams.append(HttpUtils.urlEncode(entry.getKey(), false))
+                    .append("=")
+                    .append(HttpUtils.urlEncode(entry.getValue(), false));
+        }
+
+        url.append(queryParams.toString());
+
+        try {
+            return new URL(url.toString());
+        } catch (final MalformedURLException e) {
+            throw new AmazonClientException(
+                    "Unable to convert request to well formed URL: " + e.getMessage(), e);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/ServiceClientHolderInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ServiceClientHolderInputStream.java
new file mode 100644
index 0000000000..c105a2c442
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ServiceClientHolderInputStream.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2011-2018 Amazon Technologies, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.AmazonWebServiceClient;
+import com.amazonaws.internal.SdkFilterInputStream;
+
+import java.io.InputStream;
+
+/**
+ * This wrapper input stream holds a reference to the service client. This is
+ * mainly done to avoid the AmazonWebServiceClient object being garbage
+ * collected when the client reads data from the input stream.
+ */
+public class ServiceClientHolderInputStream extends SdkFilterInputStream {
+
+    @SuppressWarnings("unused")
+    private AmazonWebServiceClient client;
+
+    /**
+     * Constructor.
+     * @param in the input stream.
+     * @param client the AmazonWebServiceClient.
+     */
+    public ServiceClientHolderInputStream(InputStream in,
+            AmazonWebServiceClient client) {
+        super(in);
+        this.client = client;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringInputStream.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringInputStream.java
new file mode 100644
index 0000000000..d3dcec6317
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringInputStream.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+
+import java.io.ByteArrayInputStream;
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Simple wrapper for ByteArrayInputStream that will automatically encode the
+ * string as UTF-8 data, and still allows access to the original string.
+ */
+public class StringInputStream extends ByteArrayInputStream {
+
+    private final String string;
+
+    /**
+     * Constructor.
+     * @param s the string.
+     * @throws UnsupportedEncodingException
+     */
+    public StringInputStream(String s) throws UnsupportedEncodingException {
+        super(s.getBytes(UTF8));
+        this.string = s;
+    }
+
+    /**
+     * Returns the original string specified when this input stream was
+     * constructed.
+     *
+     * @return The original string specified when this input stream was
+     *         constructed.
+     */
+    public String getString() {
+        return string;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringUtils.java
new file mode 100644
index 0000000000..1d4c7f2d56
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/StringUtils.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * Utilities for converting objects to strings.
+ */
+public class StringUtils {
+
+    private static final String DEFAULT_ENCODING = "UTF-8";
+
+    /** UTF8. */
+    public static final Charset UTF8 = Charset.forName(DEFAULT_ENCODING);
+
+    /**
+     * Converts object to Integer.
+     * @param value object value.
+     * @return Integer.
+     */
+    public static Integer toInteger(StringBuilder value) {
+        return Integer.parseInt(value.toString());
+    }
+
+    /**
+     * Converts object to string.
+     * @param value object value.
+     * @return String.
+     */
+    public static String toString(StringBuilder value) {
+        return value.toString();
+    }
+
+    /**
+     * Converts
+     * @param value object value.
+     * @return Boolean.
+     */
+    public static Boolean toBoolean(StringBuilder value) {
+        return Boolean.getBoolean(value.toString());
+    }
+
+    /**
+     * Converts Integer to String.
+     * @param value Integer value.
+     * @return String.
+     */
+    public static String fromInteger(Integer value) {
+        return Integer.toString(value);
+    }
+
+    /**
+     * Converts Long to String.
+     * @param value Long value.
+     * @return String.
+     */
+    public static String fromLong(Long value) {
+        return Long.toString(value);
+    }
+
+    /**
+     * Converts String to String.
+     * @param value String value.
+     * @return String.
+     */
+    public static String fromString(String value) {
+        return value;
+    }
+
+    /**
+     * Converts Boolean to String.
+     * @param value Boolean value.
+     * @return String.
+     */
+    public static String fromBoolean(Boolean value) {
+        return Boolean.toString(value);
+    }
+
+    /**
+     * Converts BigInteger to String.
+     * @param value BigInteger value.
+     * @return String.
+     */
+    public static String fromBigInteger(BigInteger value) {
+        return value.toString();
+    }
+
+    /**
+     * Converts BigDecimal to String.
+     * @param value Big Decimal value.
+     * @return String.
+     */
+    public static String fromBigDecimal(BigDecimal value) {
+        return value.toString();
+    }
+
+    /**
+     * Converts from String to BigInteger.
+     * @param s String value.
+     * @return BigInteger.
+     */
+    public static BigInteger toBigInteger(String s) {
+        return new BigInteger(s);
+    }
+
+    /**
+     * Converts from String to BigDecimal.
+     * @param s String value.
+     * @return BigDecimal.
+     */
+    public static BigDecimal toBigDecimal(String s) {
+        return new BigDecimal(s);
+    }
+
+    /**
+     * Converts Float to String.
+     * @param value Float value.
+     * @return String.
+     */
+    public static String fromFloat(Float value) {
+        return Float.toString(value);
+    }
+
+    /**
+     * Converts the specified date to an ISO 8601 timestamp string and returns
+     * it.
+     *
+     * @param value The date to format as an ISO 8601 timestamp string.
+     * @return An ISO 8601 timestamp string created from the specified date.
+     */
+    public static String fromDate(Date value) {
+        return DateUtils.formatISO8601Date(value);
+    }
+
+    /**
+     * Returns the string representation of the specified double.
+     *
+     * @param d The double to represent as a string.
+     * @return The string representation of the specified double.
+     */
+    public static String fromDouble(Double d) {
+        return Double.toString(d);
+    }
+
+    /**
+     * Returns the string representation of the specified Byte.
+     *
+     * @param b The Byte to represent as a string.
+     * @return The string representation of the specified Byte.
+     */
+    public static String fromByte(Byte b) {
+        return Byte.toString(b);
+    }
+
+    /**
+     * Base64 encodes the data in the specified byte buffer and returns it as a
+     * base64 encoded string.
+     *
+     * @param byteBuffer The data to base64 encode and return as a string.
+     * @return The base64 encoded contents of the specified byte buffer.
+     */
+    public static String fromByteBuffer(ByteBuffer byteBuffer) {
+        if (byteBuffer.hasArray()) {
+            return Base64.encodeAsString(byteBuffer.array());
+        }
+        final byte[] binaryData = new byte[byteBuffer.limit()];
+        byteBuffer.get(binaryData);
+        return Base64.encodeAsString(binaryData);
+    }
+
+    /**
+     * Finds partToMatch in original string and replaces.
+     * @param originalString original string.
+     * @param partToMatch string to match.
+     * @param replacement string to replace with.
+     * @return replaced string.
+     */
+    public static String replace(String originalString, String partToMatch, String replacement) {
+        StringBuffer buffer = new StringBuffer(originalString.length());
+        buffer.append(originalString);
+
+        int indexOf = buffer.indexOf(partToMatch);
+        while (indexOf != -1) {
+            buffer = buffer.replace(indexOf, indexOf + partToMatch.length(), replacement);
+            indexOf = buffer.indexOf(partToMatch);
+        }
+
+        return buffer.toString();
+    }
+
+    /**
+     * Joins the strings in parts with joiner between each string
+     *
+     * @param joiner the string to insert between the strings in parts
+     * @param parts the parts to join
+     * @return joined string.
+     */
+    public static String join(String joiner, String... parts) {
+        final StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < parts.length; i++) {
+            builder.append(parts[i]);
+            if (i < parts.length - 1) {
+                builder.append(joiner);
+            }
+        }
+        return builder.toString();
+    }
+
+    /**
+     * Converts a string to lower case with Locale.ENGLISH.
+     *
+     * @param str the string to lower case
+     * @return the lower case of the string, or null if the string is null
+     */
+    public static String lowerCase(String str) {
+        if (str == null) {
+            return null;
+        } else if (str.isEmpty()) {
+            return "";
+        } else {
+            return str.toLowerCase(Locale.ENGLISH);
+        }
+    }
+
+    /**
+     * Converts a string to upper case with Locale.ENGLISH.
+     *
+     * @param str the string to upper case
+     * @return the upper case of the string, or null if the string is null
+     */
+    public static String upperCase(String str) {
+        if (str == null) {
+            return null;
+        } else if (str.isEmpty()) {
+            return "";
+        } else {
+            return str.toUpperCase(Locale.ENGLISH);
+        }
+    }
+
+    /**
+     * Checks if a CharSequence is whitespace, empty ("") or null.
+     *
+     * @param cs the CharSequence to check, may be null
+     * @return if the CharSequence is null, empty or whitespace
+     */
+    @SuppressWarnings("checkstyle:innerassignment")
+    public static boolean isBlank(final CharSequence cs) {
+        int strLen;
+        if (cs == null || (strLen = cs.length()) == 0) {
+            return true;
+        }
+        for (int i = 0; i < strLen; i++) {
+            if (!Character.isWhitespace(cs.charAt(i))) {
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/Throwables.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Throwables.java
new file mode 100644
index 0000000000..7504ea050f
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/Throwables.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2013-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * Utility for use with errors or exceptions.
+ */
+@SuppressWarnings("checkstyle:nowhitespacebefore")
+public enum Throwables {
+    ;
+
+    private static final int MAX_RETRY = 1000;
+    /**
+     * @param orig the throwable.
+     * @return the root cause of the given throwable, or null if the given
+     * throwable is null. If the root cause is over 1000 level deep, the
+     * original throwable will be returned defensively as this is heuristically
+     * considered a circular reference, however unlikely.
+     */
+    public static Throwable getRootCause(Throwable orig) {
+        if (orig == null)
+            return orig;
+        Throwable t = orig;
+        // defend against (malicious?) circularity
+        for (int i = 0; i < MAX_RETRY; i++) {
+            Throwable cause = t.getCause();
+            if (cause == null)
+                return t;
+            t = cause;
+        }
+        // Too bad. Return the original exception.
+        LogFactory.getLog(Throwables.class).debug(
+                "Possible circular reference detected on " + orig.getClass()
+                        + ": [" + orig + "]");
+        return orig;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfo.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfo.java
new file mode 100644
index 0000000000..a12464125b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfo.java
@@ -0,0 +1,389 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Used both as a base class and a minimal support of timing info.
+ * <p>
+ * In contrast to {@link TimingInfoFullSupport}, which is intended to be a full
+ * support of the timing info, this class only provides a minimal support of
+ * start and end time (ie with no-ops for sub-event measurements) for backward
+ * compatiblity reasons.
+ * <p>
+ * This class is instantiated instead of {@link TimingInfoFullSupport} when
+ * request metric collection is not required during a particular service
+ * request/response cycle.
+ */
+public class TimingInfo {
+    private static final double TIME_CONVERSION = 1000.0;
+    static final int UNKNOWN = -1;
+    /**
+     * The wall clock time (as the number of milliseconds since Epoch) of when
+     * the timing measurement starts; or null if unknown. This field is not
+     * meant to be used for timing measurement. For more info, see:
+     * https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
+     */
+    private final Long startEpochTimeMilli;
+    /**
+     * Start time in nanosecond used for timing measurement. Note the value in
+     * this field may have nothing to do with the wall clock time. The wall
+     * clock time of when the timing measurement starts can optionally be
+     * captured in {@link #startEpochTimeMilli}. For more info, see:
+     * https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
+     * <p>
+     * Note System.nanoTime() can return negative values.
+     */
+    private final long startTimeNano;
+    /**
+     * End time in nanosecond used for timing measurement or null if unknown.
+     * Note the value in this field is only meant to be used for timing
+     * measurement, and is not directly related to the wall clock time. For more
+     * info, see:
+     * https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
+     * <p>
+     * Note System.nanoTime() can return negative values.
+     */
+    private Long endTimeNano;
+
+    /**
+     * Captures the current wall clock time (since epoch in millisecond) and the
+     * current time (in nanosecond) used for timing measurement. For more info,
+     * see: https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
+     * @return the TimingInfo.
+     */
+    public static TimingInfo startTiming() {
+        return new TimingInfo(Long.valueOf(System.currentTimeMillis()), System.nanoTime(), null);
+    }
+
+    /**
+     * Captures the current wall clock time (since epoch in millisecond) and the
+     * current time (in nanosecond) used for timing measurement. For more info,
+     * see: https://blogs.oracle.com/dholmes/entry/inside_the_hotspot_vm_clocks
+     * @return the TimingInfo.
+     */
+    public static TimingInfo startTimingFullSupport() {
+        return new TimingInfoFullSupport(Long.valueOf(System.currentTimeMillis()),
+                System.nanoTime(), null);
+    }
+
+    /**
+     * Captures the given start time in nanosecond, ignoring the wall clock
+     * time.
+     *
+     * @param startTimeNano start time in nanosecond
+     * @return the TimingInfo.
+     */
+    public static TimingInfo startTimingFullSupport(long startTimeNano) {
+        return new TimingInfoFullSupport(null, startTimeNano, null);
+    }
+
+    /**
+     * Returns a {@link TimingInfoFullSupport} based on the given start and end
+     * time in nanosecond, ignoring the wall clock time.
+     *
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond
+     * @return the TimingInfo.
+     */
+    public static TimingInfo newTimingInfoFullSupport(long startTimeNano, long endTimeNano) {
+        return new TimingInfoFullSupport(null, startTimeNano, Long.valueOf(endTimeNano));
+    }
+
+    /**
+     * Returns a {@link TimingInfoFullSupport} based on the given start time
+     * since epoch in millisecond, and the given start and end time in
+     * nanosecond.
+     *
+     * @param startEpochTimeMilli start time since epoch in millisecond
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond
+     * @return the TimingInfo.
+     */
+    public static TimingInfo newTimingInfoFullSupport(
+            long startEpochTimeMilli, long startTimeNano, long endTimeNano) {
+        return new TimingInfoFullSupport(Long.valueOf(startEpochTimeMilli), startTimeNano,
+                Long.valueOf(endTimeNano));
+    }
+
+    /**
+     * @param startTimeNano start time nano.
+     * @param endTimeNano end time nano.
+     * @return an instance of {@link TimingInfo} that is not modifiable, given
+     * the start and end nano times.
+     */
+    public static TimingInfo unmodifiableTimingInfo(long startTimeNano, Long endTimeNano) {
+        return new TimingInfoUnmodifiable(null, startTimeNano, endTimeNano);
+    }
+
+    /**
+     * @return an instance of {@link TimingInfo} that is not modifiable.
+     *
+     * @param startEpochTimeMilli start time since epoch in millisecond
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond; or null if not known
+     */
+    public static TimingInfo unmodifiableTimingInfo(long startEpochTimeMilli, long startTimeNano,
+            Long endTimeNano) {
+        return new TimingInfoUnmodifiable(startEpochTimeMilli, startTimeNano, endTimeNano);
+    }
+
+    /**
+     * A private ctor to facilitate the deprecation of using millisecond and
+     * migration to using nanosecond for timing measurement.
+     *
+     * @param startEpochTimeMilli start time since epoch in millisecond
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond; or null if not known
+     */
+    protected TimingInfo(Long startEpochTimeMilli, long startTimeNano, Long endTimeNano) {
+        this.startEpochTimeMilli = startEpochTimeMilli;
+        this.startTimeNano = startTimeNano;
+        this.endTimeNano = endTimeNano;
+    }
+
+    @Deprecated
+    public final long getStartTime() {
+        return isStartEpochTimeMilliKnown()
+                ? startEpochTimeMilli
+                // best effort even though technically this is incorrect
+                : TimeUnit.NANOSECONDS.toMillis(startTimeNano);
+    }
+
+    /**=
+     * @return the star epoch time in milliseconds.
+     */
+    @Deprecated
+    public final long getStartEpochTimeMilli() {
+        Long v = getStartEpochTimeMilliIfKnown();
+        return v == null ? UNKNOWN : v.longValue();
+    }
+
+    /**
+     * Retrieves the start epoch time in milliseconds if known.
+     * @return start epch time in milliseconds.
+     */
+    public final Long getStartEpochTimeMilliIfKnown() {
+        return startEpochTimeMilli;
+    }
+
+    /**
+     * @return the start time nano.
+     */
+    public final long getStartTimeNano() {
+        return startTimeNano;
+    }
+
+    /**
+     * @return the end time.
+     */
+    @Deprecated
+    public final long getEndTime() {
+        return getEndEpochTimeMilli();
+    }
+
+    /**
+     * @return the end epoch time in milliseconds.
+     */
+    @Deprecated
+    public final long getEndEpochTimeMilli() {
+        Long v = getEndEpochTimeMilliIfKnown();
+        return v == null ? UNKNOWN : v.longValue();
+    }
+
+    /**
+     * @return the end epoch time in milliseconds.
+     */
+    public final Long getEndEpochTimeMilliIfKnown() {
+        return isStartEpochTimeMilliKnown() && isEndTimeKnown()
+                // make use of the wall clock time and elpased time
+                ? startEpochTimeMilli.longValue()
+                        + TimeUnit.NANOSECONDS.toMillis(endTimeNano.longValue() - startTimeNano)
+                : null;
+    }
+
+    /**
+     * @return the end time nano.
+     */
+    public final long getEndTimeNano() {
+        return endTimeNano == null ? UNKNOWN : endTimeNano;
+    }
+
+    /**
+     * @return the end time nano if known.
+     */
+    public final Long getEndTimeNanoIfKnown() {
+        return endTimeNano;
+    }
+
+    /**
+     * @return time duration in milliseconds.
+     */
+    @Deprecated
+    public final double getTimeTakenMillis() {
+        Double v = getTimeTakenMillisIfKnown();
+        return v == null ? UNKNOWN : v.doubleValue();
+    }
+
+    /**
+     * @return the time duration in nano if known.
+     */
+    public final Double getTimeTakenMillisIfKnown() {
+        return isEndTimeKnown()
+                ? durationMilliOf(startTimeNano, endTimeNano)
+                : null;
+    }
+
+    /**
+     * @param startTimeNano start time nano.
+     * @param endTimeNano end time nano.
+     * @return the duration in milliseconds as double, preserving the decimal
+     * precision as necessary, for the given start and end time in nanoseconds.
+     */
+    public static double durationMilliOf(long startTimeNano, long endTimeNano) {
+        double micros = TimeUnit.NANOSECONDS.toMicros(endTimeNano - startTimeNano);
+        return micros / TIME_CONVERSION; // convert microseconds to milliseconds in
+                                // double rather than long, preserving the
+                                // precision
+    }
+
+    /**
+     * @return the elapsed time in milliseconds.
+     */
+    @Deprecated
+    public final long getElapsedTimeMillis() {
+        Double v = getTimeTakenMillisIfKnown();
+        return v == null ? UNKNOWN : v.longValue();
+    }
+
+    /**
+     * @return true if end time nano is known.
+     */
+    public final boolean isEndTimeKnown() {
+        return endTimeNano != null;
+    }
+
+    /**
+     * @return if start epoch time in milliseconds is known.
+     */
+    public final boolean isStartEpochTimeMilliKnown() {
+        return startEpochTimeMilli != null;
+    }
+
+    @Override
+    public final String toString() {
+        return String.valueOf(getTimeTakenMillis());
+    }
+
+    @Deprecated
+    public void setEndTime(long endTimeMilli) {
+        this.endTimeNano = Long.valueOf(TimeUnit.MILLISECONDS.toNanos(endTimeMilli));
+    }
+
+    /**
+     * @param endTimeNano the end time nano.
+     */
+    public void setEndTimeNano(long endTimeNano) {
+        this.endTimeNano = endTimeNano;
+    }
+
+    /**
+     * @return the TimingInfo.
+     */
+    public TimingInfo endTiming() {
+        this.endTimeNano = Long.valueOf(System.nanoTime());
+        return this;
+    }
+
+    /**
+     * @param subMeasurementName the sub measurement name.
+     * @param timingInfo the timing info.
+     */
+    public void addSubMeasurement(String subMeasurementName, TimingInfo timingInfo) {
+    }
+
+    /**
+     * @param subMeasurementName the sub measurement name.
+     * @return the TimingInfo.
+     */
+    public TimingInfo getSubMeasurement(String subMeasurementName) {
+        return null;
+    }
+
+    /**
+     * @param subMesurementName the sub measurement name.
+     * @param index the index.
+     * @return the TimingInfo.
+     */
+    public TimingInfo getSubMeasurement(String subMesurementName, int index) {
+        return null;
+    }
+
+    /**
+     * @param subMeasurementName the sub measurement name.
+     * @return the TimingInfo.
+     */
+    public TimingInfo getLastSubMeasurement(String subMeasurementName) {
+        return null;
+    }
+
+    /**
+     * @param subMeasurementName the sub measurement name.
+     * @return the TimingInfo list.
+     */
+    public List<TimingInfo> getAllSubMeasurements(String subMeasurementName) {
+        return null;
+    }
+
+    /**
+     * @return map of string to list of the TimingInfo.
+     */
+    public Map<String, List<TimingInfo>> getSubMeasurementsByName() {
+        return Collections.emptyMap();
+    }
+
+    /**
+     * @param key the key.
+     * @return the counter.
+     */
+    public Number getCounter(String key) {
+        return null;
+    }
+
+    /**
+     * @return Map of all of the counters.
+     */
+    public Map<String, Number> getAllCounters() {
+        return Collections.emptyMap();
+    }
+
+    /**
+     * @param key the key.
+     * @param count the count.
+     */
+    public void setCounter(String key, long count) {
+    }
+
+    /**=
+     * @param key the key.
+     */
+    public void incrementCounter(String key) {
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoFullSupport.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoFullSupport.java
new file mode 100644
index 0000000000..72e161b1be
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoFullSupport.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.LogFactory;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * In contrast to {@link TimingInfo}, which is intended to be a minimal support
+ * of the timing info, this class is the full support of timing info including
+ * features related to sub-measurements and counters.
+ * <p>
+ * This class is instantiated instead of {@link TimingInfo} when request metric
+ * collection is required during a particular service request/response cycle.
+ */
+class TimingInfoFullSupport extends TimingInfo {
+    private final Map<String, List<TimingInfo>> subMeasurementsByName = new HashMap<String, List<TimingInfo>>();
+    private final Map<String, Number> countersByName = new HashMap<String, Number>();
+
+    /**
+     * A private ctor to facilitate the deprecation of using millisecond and
+     * migration to using nanosecond for timing measurement.
+     *
+     * @param startEpochTimeMilli start time since epoch in millisecond
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond; or null if not known
+     * @see TimingInfo#startTimingFullSupport()
+     * @see TimingInfo#startTimingFullSupport(long)
+     * @see TimingInfo#newTimingInfoFullSupport(long, long)
+     * @see TimingInfo#newTimingInfoFullSupport(long, long, long)
+     */
+    TimingInfoFullSupport(Long startEpochTimeMilli, long startTimeNano, Long endTimeNano) {
+        super(startEpochTimeMilli, startTimeNano, endTimeNano);
+    }
+
+    @Override
+    public void addSubMeasurement(String subMeasurementName, TimingInfo ti) {
+        List<TimingInfo> timings = subMeasurementsByName.get(subMeasurementName);
+        if (timings == null) {
+            timings = new ArrayList<TimingInfo>();
+            subMeasurementsByName.put(subMeasurementName, timings);
+        }
+        if (ti.isEndTimeKnown()) {
+            timings.add(ti);
+        } else {
+            LogFactory.getLog(getClass()).debug(
+                    "Skip submeasurement timing info with no end time for "
+                            + subMeasurementName);
+        }
+    }
+
+    @Override
+    public TimingInfo getSubMeasurement(String subMeasurementName) {
+        return getSubMeasurement(subMeasurementName, 0);
+    }
+
+    @Override
+    public TimingInfo getSubMeasurement(String subMesurementName, int index) {
+
+        List<TimingInfo> timings = subMeasurementsByName.get(subMesurementName);
+        if (index < 0 || timings == null || timings.size() == 0
+                || index >= timings.size()) {
+            return null;
+        }
+
+        return timings.get(index);
+    }
+
+    @Override
+    public TimingInfo getLastSubMeasurement(String subMeasurementName) {
+
+        if (subMeasurementsByName == null || subMeasurementsByName.size() == 0) {
+            return null;
+        }
+
+        List<TimingInfo> timings = subMeasurementsByName.get(subMeasurementName);
+        if (timings == null || timings.size() == 0) {
+            return null;
+        }
+
+        return timings.get(timings.size() - 1);
+    }
+
+    @Override
+    public List<TimingInfo> getAllSubMeasurements(String subMeasurementName) {
+        return subMeasurementsByName.get(subMeasurementName);
+    }
+
+    @Override
+    public Map<String, List<TimingInfo>> getSubMeasurementsByName() {
+        return subMeasurementsByName;
+    }
+
+    @Override
+    public Number getCounter(String key) {
+        return countersByName.get(key);
+    }
+
+    @Override
+    public Map<String, Number> getAllCounters() {
+        return countersByName;
+    }
+
+    @Override
+    public void setCounter(String key, long count) {
+        countersByName.put(key, count);
+    }
+
+    @Override
+    public void incrementCounter(String key) {
+
+        int count = 0;
+        Number counter = getCounter(key);
+
+        if (counter != null) {
+            count = counter.intValue();
+        }
+
+        setCounter(key, ++count);
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoUnmodifiable.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoUnmodifiable.java
new file mode 100644
index 0000000000..ff37db3ff4
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/TimingInfoUnmodifiable.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+/**
+ * A {@link TimingInfo} that is unmodifiable.
+ */
+@SuppressWarnings("checkstyle:parametername")
+final class TimingInfoUnmodifiable extends TimingInfo {
+    /**
+     * @see TimingInfo#unmodifiableTimingInfo(long, Long)
+     * @see TimingInfo#unmodifiableTimingInfo(long, long, Long)
+     * @param startEpochTimeMilli start time since epoch in millisecond; or null
+     *            if not known
+     * @param startTimeNano start time in nanosecond
+     * @param endTimeNano end time in nanosecond; or null if not known
+     */
+    TimingInfoUnmodifiable(Long startEpochTimeMilli, long startTimeNano, Long endTimeNano) {
+        super(startEpochTimeMilli, startTimeNano, endTimeNano);
+    }
+
+    /**
+     * Always throws {@link UnsupportedOperationException}.
+     */
+    @Override
+    public void setEndTime(long _) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Always throws {@link UnsupportedOperationException}.
+     */
+    @Override
+    public void setEndTimeNano(long _) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Always throws {@link UnsupportedOperationException}.
+     */
+    @Override
+    public TimingInfo endTiming() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/ValidationUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ValidationUtils.java
new file mode 100644
index 0000000000..58284e6f2b
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/ValidationUtils.java
@@ -0,0 +1,113 @@
+package com.amazonaws.util;
+
+import java.util.Collection;
+
+/**
+ * ValidationUtils class.
+ */
+public class ValidationUtils {
+    /**
+     * Asserts that the given object is non-null and returns it.
+     *
+     * @param object Object to assert on
+     * @param fieldName Field name to display in exception message if null
+     * @param <T> the type of object.
+     * @return Object if non null
+     */
+    public static <T> T assertNotNull(T object, String fieldName) {
+        if (object == null) {
+            throw new IllegalArgumentException(String.format("%s cannot be null", fieldName));
+        }
+        return object;
+    }
+
+    /**
+     * <p>
+     * Asserts that the specified parameter value is not <code>null</code> and
+     * if it is, throws an <code>IllegalArgumentException</code> with the
+     * specified error message.
+     * </p>
+     *
+     * @param parameterValue The parameter value being checked.
+     * @param errorMessage The error message to include in the
+     *            IllegalArgumentException if the specified parameter is null.
+     */
+    public static void assertParameterNotNull(Object parameterValue, String errorMessage) {
+        if (parameterValue == null) {
+            throw new IllegalArgumentException(errorMessage);
+        }
+    }
+
+    /**
+     * Asserts that all of the objects are null.
+     * @param messageIfNull message.
+     * @param objects objects.
+     * @throws IllegalArgumentException if any object provided was NOT null.
+     */
+    public static void assertAllAreNull(String messageIfNull, Object... objects) {
+        for (final Object object : objects) {
+            if (object != null) {
+                throw new IllegalArgumentException(messageIfNull);
+            }
+        }
+    }
+
+    /**
+     * Asserts that the given number is positive (non-negative and non-zero).
+     *
+     * @param num Number to validate
+     * @param fieldName Field name to display in exception message if not
+     *            positive.
+     * @return Number if positive.
+     */
+    public static int assertIsPositive(int num, String fieldName) {
+        if (num <= 0) {
+            throw new IllegalArgumentException(String.format("%s must be positive", fieldName));
+        }
+        return num;
+    }
+
+    /**
+     * Asserts that it is not empty.
+     * @param collection collection.
+     * @param fieldName field name.
+     * @param <T> the collection type.
+     * @return collection.
+     */
+    public static <T extends Collection<?>> T assertNotEmpty(T collection, String fieldName) {
+        assertNotNull(collection, fieldName);
+        if (collection.isEmpty()) {
+            throw new IllegalArgumentException(String.format("%s cannot be empty", fieldName));
+        }
+        return collection;
+    }
+
+    /**
+     * Asserts that it is not empty.
+     * @param array array.
+     * @param fieldName field name.
+     * @param <T> array type.
+     * @return array.
+     */
+    public static <T> T[] assertNotEmpty(T[] array, String fieldName) {
+        assertNotNull(array, fieldName);
+        if (array.length == 0) {
+            throw new IllegalArgumentException(String.format("%s cannot be empty", fieldName));
+        }
+        return array;
+    }
+
+    /**
+     * Asserts that the string is not empty.
+     * @param string the string.
+     * @param fieldName the field name.
+     * @return the string.
+     */
+    public static String assertStringNotEmpty(String string, String fieldName) {
+        assertNotNull(string, fieldName);
+        if (string.isEmpty()) {
+            throw new IllegalArgumentException(String.format("%s cannot be empty", fieldName));
+        }
+        return string;
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/VersionInfoUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/VersionInfoUtils.java
new file mode 100644
index 0000000000..feb4bff2b2
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/VersionInfoUtils.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * Utility class for accessing AWS SDK versioning information.
+ */
+public class VersionInfoUtils {
+
+    private static final int DEFAULT_STRING_LENGTH = 128;
+
+    /** SDK version info */
+    private static volatile String version = "2.6.19";
+                                                                // changed build
+                                                                // logic
+
+    /** SDK platform info */
+    private static volatile String platform = "android"; // this will be changed
+                                                         // build logic
+
+    /** User Agent info */
+    private static volatile String userAgent;
+
+    /** Shared logger for any issues while loading version information */
+    private static final Log log = LogFactory.getLog(VersionInfoUtils.class);
+
+    /**
+     * Returns the current version for the AWS SDK in which this class is
+     * running. Version information is obtained from from the
+     * versionInfo.properties file which the AWS Java SDK build process
+     * generates.
+     *
+     * @return The current version for the AWS SDK, if known, otherwise returns
+     *         a string indicating that the version information is not
+     *         available.
+     */
+    public static String getVersion() {
+        return version;
+    }
+
+    /**
+     * Returns the current platform for the AWS SDK in which this class is
+     * running. Version information is obtained from from the
+     * versionInfo.properties file which the AWS Java SDK build process
+     * generates.
+     *
+     * @return The current platform for the AWS SDK, if known, otherwise returns
+     *         a string indicating that the platform information is not
+     *         available.
+     */
+    public static String getPlatform() {
+        return platform;
+    }
+
+    /**
+     * @return Returns the User Agent string to be used when communicating with
+     *         the AWS services. The User Agent encapsulates SDK, Java, OS and
+     *         region information.
+     */
+    public static String getUserAgent() {
+        if (userAgent == null) {
+            synchronized (VersionInfoUtils.class) {
+                if (userAgent == null)
+                    initializeUserAgent();
+            }
+        }
+        return userAgent;
+    }
+
+    /**
+     * Loads the versionInfo.properties file from the AWS Java SDK and stores
+     * the information so that the file doesn't have to be read the next time
+     * the data is needed.
+     */
+    private static void initializeUserAgent() {
+        userAgent = userAgent();
+    }
+
+    static String userAgent() {
+        StringBuilder buffer = new StringBuilder(DEFAULT_STRING_LENGTH);
+
+        buffer.append("aws-sdk-");
+        buffer.append(StringUtils.lowerCase(VersionInfoUtils.getPlatform()));
+        buffer.append("/");
+
+        buffer.append(VersionInfoUtils.getVersion());
+        buffer.append(" ");
+        buffer.append(replaceSpaces(System.getProperty("os.name")));
+        buffer.append("/");
+        buffer.append(replaceSpaces(System.getProperty("os.version")));
+
+        buffer.append(" ");
+        buffer.append(replaceSpaces(System.getProperty("java.vm.name")));
+        buffer.append("/");
+        buffer.append(replaceSpaces(System.getProperty("java.vm.version")));
+        buffer.append("/");
+        buffer.append(replaceSpaces(System.getProperty("java.version")));
+
+        String language = System.getProperty("user.language");
+        String region = System.getProperty("user.region");
+
+        if (language != null && region != null) {
+            buffer.append(" ");
+            buffer.append(replaceSpaces(language));
+            buffer.append("_");
+            buffer.append(replaceSpaces(region));
+        }
+        return buffer.toString();
+    }
+
+    /**
+     * Replace any spaces in the input with underscores.
+     *
+     * @param input the input
+     * @return the input with spaces replaced by underscores
+     */
+    private static String replaceSpaces(final String input) {
+        return input.replace(' ', '_');
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/XMLWriter.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XMLWriter.java
new file mode 100644
index 0000000000..a5a33433b1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XMLWriter.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2011-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import com.amazonaws.AmazonClientException;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Date;
+import java.util.Stack;
+
+/**
+ * Utility for creating easily creating XML documents, one element at a time.
+ */
+public class XMLWriter {
+
+    /** Standard XML prolog to add to the beginning of each XML document. */
+    private static final String PROLOG = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
+
+    /**
+     * The writer to which the XML document created by this writer will be
+     * written.
+     */
+    private final Writer writer;
+
+    /** Optional XML namespace attribute value to include in the root element. */
+    private final String xmlns;
+
+    private Stack<String> elementStack = new Stack<String>();
+    private boolean rootElement = true;
+
+    /**
+     * Creates a new XMLWriter, ready to write an XML document to the specified
+     * writer. The XML document will not specify an xmlns attribute.
+     *
+     * @param w The writer this XMLWriter will write to.
+     */
+    public XMLWriter(Writer w) {
+        this(w, null);
+    }
+
+    /**
+     * Creates a new XMLWriter, ready to write an XML document to the specified
+     * writer. The root element in the XML document will specify an xmlns
+     * attribute with the specified namespace parameter.
+     *
+     * @param w The writer this XMLWriter will write to.
+     * @param xmlns The XML namespace to include in the xmlns attribute of the
+     *            root element.
+     */
+    public XMLWriter(Writer w, String xmlns) {
+        this.writer = w;
+        this.xmlns = xmlns;
+        append(PROLOG);
+    }
+
+    /**
+     * Starts a new element with the specified name at the current position in
+     * the in-progress XML document.
+     *
+     * @param element The name of the new element.
+     * @return This XMLWriter so that additional method calls can be chained
+     *         together.
+     */
+    public XMLWriter startElement(String element) {
+        append("<" + element);
+        if (rootElement && xmlns != null) {
+            append(" xmlns=\"" + xmlns + "\"");
+            rootElement = false;
+        }
+        append(">");
+        elementStack.push(element);
+        return this;
+    }
+
+    /**
+     * Closes the last opened element at the current position in the in-progress
+     * XML document.
+     *
+     * @return This XMLWriter so that additional method calls can be chained
+     *         together.
+     */
+    public XMLWriter endElement() {
+        String lastElement = elementStack.pop();
+        append("</" + lastElement + ">");
+        return this;
+    }
+
+    /**
+     * Adds the specified value as text to the current position of the in
+     * progress XML document.
+     *
+     * @param s The text to add to the XML document.
+     * @return This XMLWriter so that additional method calls can be chained
+     *         together.
+     */
+    public XMLWriter value(String s) {
+        append(escapeXMLEntities(s));
+        return this;
+    }
+
+    /**
+     * Adds the specified date as text to the current position of the
+     * in-progress XML document.
+     *
+     * @param date The date to add to the XML document.
+     * @return This XMLWriter so that additional method calls can be chained
+     *         together.
+     */
+    public XMLWriter value(Date date) {
+        append(escapeXMLEntities(StringUtils.fromDate(date)));
+        return this;
+    }
+
+    /**
+     * Adds the string representation of the specified object to the current
+     * position of the in progress XML document.
+     *
+     * @param obj The object to translate to a string and add to the XML
+     *            document.
+     * @return This XMLWriter so that additional method calls can be chained
+     *         together.
+     */
+    public XMLWriter value(Object obj) {
+        append(escapeXMLEntities(obj.toString()));
+        return this;
+    }
+
+    private void append(String s) {
+        try {
+            writer.append(s);
+        } catch (IOException e) {
+            throw new AmazonClientException("Unable to write XML document", e);
+        }
+    }
+
+    private String escapeXMLEntities(String s) {
+        /**
+         * Unescape any escaped characters.
+         */
+        if (s.contains("&")) {
+            s = s.replace("&quot;", "\"");
+            s = s.replace("&apos;", "'");
+            s = s.replace("&lt;", "<");
+            s = s.replace("&gt;", ">");
+            // Ampersands should always be the last to unescape
+            s = s.replace("&amp;", "&");
+        }
+        // Ampersands should always be the first to escape
+        s = s.replace("&", "&amp;");
+        s = s.replace("\"", "&quot;");
+        s = s.replace("'", "&apos;");
+        s = s.replace("<", "&lt;");
+        s = s.replace(">", "&gt;");
+        return s;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/XmlUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XmlUtils.java
new file mode 100644
index 0000000000..8da03000e5
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XmlUtils.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.xml.sax.ContentHandler;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * XmlUtils class.
+ */
+public class XmlUtils {
+
+    /**
+     * Parse.
+     * @param in the input stream.
+     * @param handler the content handler.
+     * @return parsed XMLReader.
+     * @throws SAXException
+     * @throws IOException
+     */
+    public static XMLReader parse(InputStream in, ContentHandler handler)
+            throws SAXException, IOException {
+
+        XMLReader reader = XMLReaderFactory.createXMLReader();
+        reader.setContentHandler(handler);
+        reader.parse(new InputSource(in));
+        in.close();
+        return reader;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java
new file mode 100644
index 0000000000..6c8b863014
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/XpathUtils.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2010-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.SAXException;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+
+/**
+ * Utility methods for extracting data from XML documents using Xpath
+ * expressions.
+ */
+public class XpathUtils {
+
+    /** Shared logger */
+    private static Log log = LogFactory.getLog(XpathUtils.class);
+
+    private static DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+
+    /**
+     * InputStream to Document.
+     * @param is the input stream.
+     * @return the Document.
+     * @throws SAXException
+     * @throws IOException
+     * @throws ParserConfigurationException
+     */
+    public static Document documentFrom(InputStream is)
+            throws SAXException, IOException, ParserConfigurationException {
+        is = new NamespaceRemovingInputStream(is);
+        Document doc = factory.newDocumentBuilder().parse(is);
+        is.close();
+
+        return doc;
+    }
+
+    /**
+     * Xml string to Document.
+     * @param xml the xml string.
+     * @return the Document.
+     * @throws SAXException
+     * @throws IOException
+     * @throws ParserConfigurationException
+     */
+    public static Document documentFrom(String xml) throws SAXException,
+            IOException, ParserConfigurationException {
+        return documentFrom(new ByteArrayInputStream(xml.getBytes(StringUtils.UTF8)));
+    }
+
+    /**
+     * URL to Document,
+     * @param url the URL.
+     * @return the Document.
+     * @throws SAXException
+     * @throws IOException
+     * @throws ParserConfigurationException
+     */
+    public static Document documentFrom(URL url) throws SAXException,
+            IOException, ParserConfigurationException {
+        return documentFrom(url.openStream());
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the results as a
+     * Double.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Double result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Double asDouble(String expression, Node node)
+            throws XPathExpressionException {
+        String doubleString = evaluateAsString(expression, node);
+        return (isEmptyString(doubleString)) ? null : Double.valueOf(doubleString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * string.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The string result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static String asString(String expression, Node node)
+            throws XPathExpressionException {
+        return evaluateAsString(expression, node);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as an
+     * Integer.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Integer result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Integer asInteger(String expression, Node node)
+            throws XPathExpressionException {
+        String intString = evaluateAsString(expression, node);
+        return (isEmptyString(intString)) ? null : Integer.valueOf(intString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * Boolean.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Boolean result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Boolean asBoolean(String expression, Node node)
+            throws XPathExpressionException {
+        String booleanString = evaluateAsString(expression, node);
+        return (isEmptyString(booleanString)) ? null : Boolean.valueOf(booleanString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * Float.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Float result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Float asFloat(String expression, Node node)
+            throws XPathExpressionException {
+        String floatString = evaluateAsString(expression, node);
+        return (isEmptyString(floatString)) ? null : Float.valueOf(floatString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * Long.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Long result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Long asLong(String expression, Node node)
+            throws XPathExpressionException {
+        String longString = evaluateAsString(expression, node);
+        return (isEmptyString(longString)) ? null : Long.valueOf(longString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * Byte.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Byte result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Byte asByte(String expression, Node node)
+            throws XPathExpressionException {
+        String byteString = evaluateAsString(expression, node);
+        return (isEmptyString(byteString)) ? null : Byte.valueOf(byteString);
+    }
+
+    /**
+     * Evaluates the specified XPath expression and returns the result as a
+     * Date. Assumes that the node's text is formatted as an ISO 8601 date, as
+     * specified by xs:dateTime.
+     *
+     * @param expression The XPath expression to evaluate.
+     * @param node The node to run the expression on.
+     * @return The Date result.
+     * @throws XPathExpressionException If there was a problem processing the
+     *             specified XPath expression.
+     */
+    public static Date asDate(String expression, Node node)
+            throws XPathExpressionException {
+        String dateString = evaluateAsString(expression, node);
+        if (isEmptyString(dateString))
+            return null;
+
+        return DateUtils.parseISO8601Date(dateString);
+    }
+
+    /**
+     * Evaluates the specified xpath expression, base64 decodes the data and
+     * returns the result as a ByteBuffer.
+     *
+     * @param expression The Xpath expression to evaluate.
+     * @param node The node on which to evaluate the expression.
+     * @return A ByteBuffer of base64 decoded data from the result of evaluating
+     *         the specified Xpath expression.
+     * @throws XPathExpressionException If there are any problems evaluating the
+     *             Xpath expression.
+     */
+    public static ByteBuffer asByteBuffer(String expression, Node node)
+            throws XPathExpressionException {
+        String base64EncodedString = evaluateAsString(expression, node);
+        if (isEmptyString(base64EncodedString))
+            return null;
+
+        if (!isEmpty(node)) {
+            byte[] decodedBytes = Base64.decode(base64EncodedString);
+            return ByteBuffer.wrap(decodedBytes);
+        }
+        return null;
+    }
+
+    /**
+     * Returns true if the specified node is null or has no children.
+     *
+     * @param node The node to test.
+     * @return True if the specified node is null or has no children.
+     */
+    public static boolean isEmpty(Node node) {
+        return (node == null);
+    }
+
+    /**
+     * Returns the length of the specified node list.
+     *
+     * @param list The node list to measure.
+     * @return The length of the specified node list.
+     */
+    public static int nodeLength(NodeList list) {
+        return list == null ? 0 : list.getLength();
+    }
+
+    /**
+     * Evaluates the specified expression on the specified node and returns the
+     * result as a String.
+     *
+     * @param expression The Xpath expression to evaluate.
+     * @param node The node on which to evaluate the expression.
+     * @return The result of evaluating the specified expression, or null if the
+     *         evaluation didn't return any result.
+     * @throws XPathExpressionException If there are any problems evaluating the
+     *             Xpath expression.
+     */
+    private static String evaluateAsString(String expression, Node node)
+            throws XPathExpressionException {
+        if (isEmpty(node))
+            return null;
+
+        if (!".".equals(expression)) {
+            /*
+             * If the expression being evaluated doesn't select a node, we want
+             * to return null to distinguish between cases where a node isn't
+             * present (which should be represented as null) and when a node is
+             * present, but empty (which should be represented as the empty
+             * string). We skip this test if the expression is "." since we've
+             * already checked that the node exists.
+             */
+            if (asNode(expression, node) == null)
+                return null;
+        }
+
+        String s = xpath().evaluate(expression, node);
+
+        return s.trim();
+    }
+
+    /**
+     * @param nodeName the node name.
+     * @param node the node.
+     * @return the Node.
+     * @throws XPathExpressionException
+     */
+    public static Node asNode(String nodeName, Node node)
+            throws XPathExpressionException {
+        if (node == null)
+            return null;
+        return (Node) xpath().evaluate(nodeName, node, XPathConstants.NODE);
+    }
+
+    /**
+     * @return true if the specified string is null or empty.
+     *
+     * @param s The string to test.
+     * @return True if the specified string is null or empty.
+     */
+    private static boolean isEmptyString(String s) {
+        if (s == null)
+            return true;
+        if ("".equals(s.trim()))
+            return true;
+
+        return false;
+    }
+
+    /**
+     * @return a new instance of XPath, which is not thread safe and not
+     * reentrant.
+     */
+    public static XPath xpath() {
+        return XPathFactory.newInstance().newXPath();
+    }
+
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonFactory.java
new file mode 100644
index 0000000000..8f8b093764
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonFactory.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import java.io.Reader;
+import java.io.Writer;
+
+/**
+ * A JSON factory that creates JSON reader and writer.
+ */
+public interface AwsJsonFactory {
+
+    /**
+     * Creates a JSON reader
+     *
+     * @param in input {@link Reader}
+     * @return a JSON reader
+     */
+    AwsJsonReader getJsonReader(Reader in);
+
+    /**
+     * Creates a JSON writer
+     *
+     * @param out output {@link Writer}
+     * @return a JSON writer
+     */
+    AwsJsonWriter getJsonWriter(Writer out);
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonReader.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonReader.java
new file mode 100644
index 0000000000..977b237114
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonReader.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import java.io.IOException;
+import java.io.Reader;
+
+/**
+ * A streaming JSON reader.
+ */
+public interface AwsJsonReader {
+    /**
+     * Consumes the next token and asserts that it is the beginning of an array.
+     *
+     * @throws IOException
+     */
+    void beginArray() throws IOException;
+
+    /**
+     * Consumes the next token and asserts that it is the end of an array.
+     *
+     * @throws IOException
+     */
+    void endArray() throws IOException;
+
+    /**
+     * Consumes the next token and asserts that it is the beginning of an
+     * object.
+     *
+     * @throws IOException
+     */
+    void beginObject() throws IOException;
+
+    /**
+     * Consumes the next token and asserts that it is the end of an object.
+     *
+     * @throws IOException
+     */
+    void endObject() throws IOException;
+
+    /**
+     * Returns true if the next token is either {@link AwsJsonToken#BEGIN_ARRAY}
+     * or {@link AwsJsonToken#BEGIN_OBJECT}.
+     *
+     * @return true if it's an array or an object
+     * @throws IOException
+     */
+    boolean isContainer() throws IOException;
+
+    /**
+     * If in an array or an object, returns true if there are more elements.
+     *
+     * @return true if the array or object has more elements, false otherwise.
+     * @throws IOException
+     */
+    boolean hasNext() throws IOException;
+
+    /**
+     * If the next token is {@link AwsJsonToken#FIELD_NAME}, gets the field name
+     * as {@link String}, and consumes it.
+     * 
+     * @return field name
+     * @throws IOException
+     */
+    String nextName() throws IOException;
+
+    /**
+     * Gets the next value as {@link String}, or null if the token is
+     * {@link AwsJsonToken#VALUE_NULL}.
+     *
+     * @return the next value as {@link String}
+     * @throws IOException
+     */
+    String nextString() throws IOException;
+
+    /**
+     * Gets the next token but doesn't consume it.
+     *
+     * @return the next token
+     * @throws IOException
+     */
+    AwsJsonToken peek() throws IOException;
+
+    /**
+     * Skips a value.
+     *
+     * @throws IOException
+     */
+    void skipValue() throws IOException;
+
+    /**
+     * Closes this reader as well as the underlying {@link Reader}.
+     *
+     * @throws IOException
+     */
+    void close() throws IOException;
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonToken.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonToken.java
new file mode 100644
index 0000000000..6a2688cef1
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonToken.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+/**
+ * The token types returned from {@link AwsJsonReader#peek()}.
+ */
+public enum AwsJsonToken {
+    /** The beginning of an array '[' */
+    BEGIN_ARRAY,
+    /** The end of an array ']' */
+    END_ARRAY,
+    /** The beginning of an object '{' */
+    BEGIN_OBJECT,
+    /** The end of an object '}' */
+    END_OBJECT,
+    /** A field name in an object */
+    FIELD_NAME,
+    /** Boolean value, either true of false */
+    VALUE_BOOLEAN,
+    /** Value null */
+    VALUE_NULL,
+    /** A number, can be long, double */
+    VALUE_NUMBER,
+    /** A string value, with quotes */
+    VALUE_STRING,
+    /** None of the above as fail-safe */
+    UNKNOWN
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonWriter.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonWriter.java
new file mode 100644
index 0000000000..e61238d527
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/AwsJsonWriter.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+/**
+ * A streaming JSON writer.
+ */
+public interface AwsJsonWriter {
+
+    /**
+     * Writes the character '[' as the beginning of an array
+     *
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter beginArray() throws IOException;
+
+    /**
+     * Writes the character ']' as the end of an array
+     *
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter endArray() throws IOException;
+
+    /**
+     * Writes the character '{' as the beginning of an object
+     *
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter beginObject() throws IOException;
+
+    /**
+     * Writes the character '}' as the end of an object
+     *
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter endObject() throws IOException;
+
+    /**
+     * Writes the field name in an object
+     *
+     * @param name field name
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter name(String name) throws IOException;
+
+    /**
+     * Writes a {@link String} value
+     *
+     * @param value {@link String} value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(String value) throws IOException;
+
+    /**
+     * Writes a boolean value, either true or false
+     *
+     * @param value boolean value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(boolean value) throws IOException;
+
+    /**
+     * Writes a double value
+     *
+     * @param value double value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(double value) throws IOException;
+
+    /**
+     * Writes a long value
+     *
+     * @param value long value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(long value) throws IOException;
+
+    /**
+     * Writes a {@link Number} value. It outputs the string representation of
+     * the value by invoking {@link Number#toString()}. Unlike passing
+     * {@link Number#toString()} to {@link #value(String)}, this doesn't include
+     * double quote.
+     *
+     * @param value {@link Number} value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(Number value) throws IOException;
+
+    /**
+     * Writes a {@link Date} value as epoch time in seconds in a number format.
+     * For example, <code>new Date(1423875641895L)</code> will be encoded as a
+     * number <code>1423875641.895</code>.
+     *
+     * @param value {@link Date} value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(Date value) throws IOException;
+
+    /**
+     * Writes a {@link ByteBuffer} value
+     *
+     * @param value {@link ByteBuffer} value
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value(ByteBuffer value) throws IOException;
+
+    /**
+     * Writes a null value, i.e. literal 'null'
+     *
+     * @return the writer itself
+     * @throws IOException
+     */
+    AwsJsonWriter value() throws IOException;
+
+    /**
+     * Makes sure all buffered data is written to the underlying {@link Writer}.
+     *
+     * @throws IOException
+     */
+    void flush() throws IOException;
+
+    /**
+     * Flushes and closes this writer as well as the underlying {@link Writer}.
+     *
+     * @throws IOException
+     */
+    void close() throws IOException;
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/DateDeserializer.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/DateDeserializer.java
new file mode 100644
index 0000000000..41841f0011
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/DateDeserializer.java
@@ -0,0 +1,70 @@
+package com.amazonaws.util.json;
+
+import com.amazonaws.util.DateUtils;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+import java.lang.reflect.Type;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * The DateDeserializer class.
+ */
+public class DateDeserializer implements JsonDeserializer<Date>, JsonSerializer<Date> {
+
+    private SimpleDateFormat mSimpleDateFormat;
+    private final List<String> dateFormats;
+    private final SimpleDateFormat mIso8601DateFormat;
+
+    /**
+     * Constructor.
+     * @param dateFormats the array of date formats.
+     */
+    public DateDeserializer(String[] dateFormats) {
+        this.dateFormats = Arrays.asList(dateFormats);
+        this.mIso8601DateFormat = new SimpleDateFormat(DateUtils.ISO8601_DATE_PATTERN);
+    }
+
+    @Override
+    @SuppressWarnings("checkstyle:emptyblock")
+    public Date deserialize(JsonElement element, Type arg1, JsonDeserializationContext context) {
+        final String dateString = element.getAsString();
+        Date date = null;
+        for (final String df : dateFormats) {
+            try {
+                date = new Date();
+                mSimpleDateFormat = new SimpleDateFormat(df);
+                date.setTime(mSimpleDateFormat.parse(dateString).getTime());
+                return date;
+            } catch (final ParseException e) {
+                // swallow , will try next type of date format
+            }
+        }
+        // default to default implementation
+        try {
+            return DateFormat.getDateInstance(DateFormat.DEFAULT).parse(dateString);
+        } catch (final ParseException e) {
+            throw new JsonParseException(e.getMessage(), e);
+        }
+
+    }
+
+    @Override
+    public JsonElement serialize(Date src, Type typeOfSrc,
+            JsonSerializationContext context) {
+        synchronized (mIso8601DateFormat) {
+            final String dateFormatAsString = mIso8601DateFormat.format(src);
+            return new JsonPrimitive(dateFormatAsString);
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/GsonFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/GsonFactory.java
new file mode 100644
index 0000000000..978f8d9112
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/GsonFactory.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import com.amazonaws.util.BinaryUtils;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+/**
+ * An implementation of {@link AwsJsonFactory} with Gson.
+ */
+final class GsonFactory implements AwsJsonFactory {
+
+    @Override
+    public AwsJsonReader getJsonReader(Reader in) {
+        return new GsonReader(in);
+    }
+
+    @Override
+    public AwsJsonWriter getJsonWriter(Writer out) {
+        return new GsonWriter(out);
+    }
+
+    private static final class GsonReader implements AwsJsonReader {
+        private final JsonReader reader;
+
+        public GsonReader(Reader in) {
+            this.reader = new JsonReader(in);
+        }
+
+        @Override
+        public void beginArray() throws IOException {
+            reader.beginArray();
+        }
+
+        @Override
+        public void endArray() throws IOException {
+            reader.endArray();
+        }
+
+        @Override
+        public void beginObject() throws IOException {
+            reader.beginObject();
+        }
+
+        @Override
+        public void endObject() throws IOException {
+            reader.endObject();
+        }
+
+        @Override
+        public boolean isContainer() throws IOException {
+            JsonToken token = reader.peek();
+            return JsonToken.BEGIN_ARRAY.equals(token)
+                    || JsonToken.BEGIN_OBJECT.equals(token);
+        }
+
+        @Override
+        public boolean hasNext() throws IOException {
+            return reader.hasNext();
+        }
+
+        @Override
+        public String nextName() throws IOException {
+            return reader.nextName();
+        }
+
+        @Override
+        public String nextString() throws IOException {
+            JsonToken token = reader.peek();
+            if (JsonToken.NULL.equals(token)) {
+                reader.nextNull();
+                return null;
+            }
+            if (JsonToken.BOOLEAN.equals(token)) {
+                return reader.nextBoolean() ? "true" : "false";
+            }
+            return reader.nextString();
+        }
+
+        @Override
+        public void skipValue() throws IOException {
+            reader.skipValue();
+        }
+
+        @Override
+        public AwsJsonToken peek() throws IOException {
+            try {
+                return convert(reader.peek());
+            } catch (EOFException e) {
+                return null;
+            }
+        }
+
+        @Override
+        public void close() throws IOException {
+            reader.close();
+        }
+    }
+
+    private static AwsJsonToken convert(JsonToken token) {
+        if (token == null) {
+            return null;
+        }
+        switch (token) {
+            case BEGIN_ARRAY:
+                return AwsJsonToken.BEGIN_ARRAY;
+            case END_ARRAY:
+                return AwsJsonToken.END_ARRAY;
+            case BEGIN_OBJECT:
+                return AwsJsonToken.BEGIN_OBJECT;
+            case END_OBJECT:
+                return AwsJsonToken.END_OBJECT;
+            case NAME:
+                return AwsJsonToken.FIELD_NAME;
+            case BOOLEAN:
+                return AwsJsonToken.VALUE_BOOLEAN;
+            case NUMBER:
+                return AwsJsonToken.VALUE_NUMBER;
+            case NULL:
+                return AwsJsonToken.VALUE_NULL;
+            case STRING:
+                return AwsJsonToken.VALUE_STRING;
+            case END_DOCUMENT:
+                return null;
+            default:
+                return AwsJsonToken.UNKNOWN;
+        }
+    }
+
+    private static final class GsonWriter implements AwsJsonWriter {
+
+        private final JsonWriter writer;
+        private static final int NEGATIVE_THREE = -3;
+
+        public GsonWriter(Writer out) {
+            writer = new JsonWriter(out);
+        }
+
+        @Override
+        public AwsJsonWriter beginArray() throws IOException {
+            writer.beginArray();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter endArray() throws IOException {
+            writer.endArray();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter beginObject() throws IOException {
+            writer.beginObject();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter endObject() throws IOException {
+            writer.endObject();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter name(String name) throws IOException {
+            writer.name(name);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(String value) throws IOException {
+            writer.value(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(boolean value) throws IOException {
+            writer.value(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(double value) throws IOException {
+            writer.value(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(long value) throws IOException {
+            writer.value(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(Number value) throws IOException {
+            writer.value(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(Date value) throws IOException {
+            BigDecimal dateValue = BigDecimal.valueOf(value.getTime());
+            writer.value(dateValue.scaleByPowerOfTen(NEGATIVE_THREE));
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(ByteBuffer value) throws IOException {
+            value.mark();
+            byte[] bytes = new byte[value.remaining()];
+            value.get(bytes, 0, bytes.length);
+            value.reset();
+            writer.value(BinaryUtils.toBase64(bytes));
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value() throws IOException {
+            writer.nullValue();
+            return this;
+        }
+
+        @Override
+        public void flush() throws IOException {
+            writer.flush();
+        }
+
+        @Override
+        public void close() throws IOException {
+            writer.close();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JacksonFactory.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JacksonFactory.java
new file mode 100644
index 0000000000..4e40aaee0c
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JacksonFactory.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.util.BinaryUtils;
+import com.fasterxml.jackson.core.JsonFactory;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.math.BigDecimal;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+/**
+ * An implementation of {@link AwsJsonFactory} with Jackson 2.x
+ */
+final class JacksonFactory implements AwsJsonFactory {
+
+    private final JsonFactory factory = new JsonFactory();
+
+    @Override
+    public AwsJsonReader getJsonReader(Reader in) {
+        return new JacksonReader(factory, in);
+    }
+
+    @Override
+    public AwsJsonWriter getJsonWriter(Writer out) {
+        return new JacksonWriter(factory, out);
+    }
+
+    private static final class JacksonReader implements AwsJsonReader {
+
+        private JsonParser reader;
+        private JsonToken nextToken = null;
+
+        public JacksonReader(JsonFactory factory, Reader in) {
+            try {
+                reader = factory.createJsonParser(in);
+            } catch (IOException e) {
+                throw new AmazonClientException("Failed to create JSON reader", e);
+            }
+        }
+
+        @Override
+        public void beginArray() throws IOException {
+            nextToken();
+            expect(JsonToken.START_ARRAY);
+            clearToken();
+        }
+
+        @Override
+        public void endArray() throws IOException {
+            nextToken();
+            expect(JsonToken.END_ARRAY);
+            clearToken();
+        }
+
+        @Override
+        public void beginObject() throws IOException {
+            nextToken();
+            expect(JsonToken.START_OBJECT);
+            clearToken();
+        }
+
+        @Override
+        public void endObject() throws IOException {
+            nextToken();
+            expect(JsonToken.END_OBJECT);
+            clearToken();
+        }
+
+        @Override
+        public boolean isContainer() throws IOException {
+            nextToken();
+            return JsonToken.START_ARRAY == nextToken || JsonToken.START_OBJECT == nextToken;
+        }
+
+        @Override
+        public boolean hasNext() throws IOException {
+            nextToken();
+            return JsonToken.END_OBJECT != nextToken && JsonToken.END_ARRAY != nextToken;
+        }
+
+        @Override
+        public String nextName() throws IOException {
+            nextToken();
+            expect(JsonToken.FIELD_NAME);
+            clearToken();
+            return reader.getText();
+        }
+
+        @Override
+        public String nextString() throws IOException {
+            nextToken();
+            String s = JsonToken.VALUE_NULL == nextToken ? null : reader.getText();
+            clearToken();
+            return s;
+        }
+
+        @Override
+        public AwsJsonToken peek() throws IOException {
+            nextToken();
+            return convert(nextToken);
+        }
+
+        @Override
+        public void skipValue() throws IOException {
+            nextToken();
+            reader.skipChildren();
+            clearToken();
+        }
+
+        @Override
+        public void close() throws IOException {
+            reader.close();
+        }
+
+        /**
+         * If {@link #nextToken} is null then read the next token. Do nothing
+         * otherwise.
+         *
+         * @throws IOException
+         */
+        private void nextToken() throws IOException {
+            if (nextToken == null) {
+                nextToken = reader.nextToken();
+            }
+        }
+
+        /**
+         * Clears the {@link #nextToken}
+         *
+         * @throws IOException
+         */
+        private void clearToken() throws IOException {
+            nextToken = null;
+        }
+
+        /**
+         * Asserts {@link #nextToken} is the expected token. An
+         * {@link IOException} will be thrown if failed.
+         *
+         * @param token expected token
+         * @throws IOException
+         */
+        private void expect(JsonToken token) throws IOException {
+            if (this.nextToken != token) {
+                throw new IOException("Expected " + token + " but was " + token);
+            }
+        }
+
+    }
+
+    private static AwsJsonToken convert(JsonToken token) {
+        if (token == null) {
+            return null;
+        }
+        switch (token) {
+            case START_ARRAY:
+                return AwsJsonToken.BEGIN_ARRAY;
+            case END_ARRAY:
+                return AwsJsonToken.END_ARRAY;
+            case START_OBJECT:
+                return AwsJsonToken.BEGIN_OBJECT;
+            case END_OBJECT:
+                return AwsJsonToken.END_OBJECT;
+            case FIELD_NAME:
+                return AwsJsonToken.FIELD_NAME;
+            case VALUE_TRUE:
+            case VALUE_FALSE:
+                return AwsJsonToken.VALUE_BOOLEAN;
+            case VALUE_NUMBER_INT:
+            case VALUE_NUMBER_FLOAT:
+                return AwsJsonToken.VALUE_NUMBER;
+            case VALUE_NULL:
+                return AwsJsonToken.VALUE_NULL;
+            case VALUE_STRING:
+                return AwsJsonToken.VALUE_STRING;
+            default:
+                return AwsJsonToken.UNKNOWN;
+        }
+    }
+
+    private static final class JacksonWriter implements AwsJsonWriter {
+        private JsonGenerator writer;
+        private static final int NEGATIVE_THREE = -3;
+
+        public JacksonWriter(JsonFactory factory, Writer out) {
+            try {
+                writer = factory.createGenerator(out);
+            } catch (IOException e) {
+                throw new AmazonClientException("Failed to create json writer", e);
+            }
+        }
+
+        @Override
+        public AwsJsonWriter beginArray() throws IOException {
+            writer.writeStartArray();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter endArray() throws IOException {
+            writer.writeEndArray();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter beginObject() throws IOException {
+            writer.writeStartObject();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter endObject() throws IOException {
+            writer.writeEndObject();
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter name(String name) throws IOException {
+            writer.writeFieldName(name);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(String value) throws IOException {
+            writer.writeString(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(boolean value) throws IOException {
+            writer.writeBoolean(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(double value) throws IOException {
+            writer.writeNumber(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(long value) throws IOException {
+            writer.writeNumber(value);
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(Number value) throws IOException {
+            writer.writeNumber(value.toString());
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(Date value) throws IOException {
+            BigDecimal dateValue = BigDecimal.valueOf(value.getTime());
+            writer.writeNumber(dateValue.scaleByPowerOfTen(NEGATIVE_THREE).toPlainString());
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value(ByteBuffer value) throws IOException {
+            value.mark();
+            byte[] bytes = new byte[value.remaining()];
+            value.get(bytes, 0, bytes.length);
+            value.reset();
+            writer.writeString(BinaryUtils.toBase64(bytes));
+            return this;
+        }
+
+        @Override
+        public AwsJsonWriter value() throws IOException {
+            writer.writeNull();
+            return this;
+        }
+
+        @Override
+        public void flush() throws IOException {
+            writer.flush();
+        }
+
+        @Override
+        public void close() throws IOException {
+            writer.close();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JsonUtils.java b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JsonUtils.java
new file mode 100644
index 0000000000..b0dd265928
--- /dev/null
+++ b/aws-java-sdk-core/src/main/java/com/amazonaws/util/json/JsonUtils.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import com.amazonaws.AmazonClientException;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A utility class to process JSON contents.
+ */
+public class JsonUtils {
+
+    private static volatile AwsJsonFactory factory = new GsonFactory();
+
+    /**
+     * JSON engine
+     */
+    public static enum JsonEngine {
+        /**
+         * An engine powered by the build-in {@link JsonReader} and
+         * {@link JsonWriter} available since Android API 11.
+         */
+        // Android,
+        /**
+         * An engine powered by Gson.
+         *
+         * @see <a href="https://code.google.com/p/google-gson/">Gson</a>
+         */
+        Gson,
+        /**
+         * An engine powered by Jackson 2.x. It's the fastest engine.
+         *
+         * @see <a
+         *      href="https://github.com/FasterXML/jackson-core">jackson-core</a>
+         */
+        Jackson
+    }
+
+    /**
+     * Sets the JSON engine. Default is Gson.
+     *
+     * @param jsonEngine the json engine.
+     */
+    public static void setJsonEngine(JsonEngine jsonEngine) {
+        switch (jsonEngine) {
+            case Gson:
+                factory = new GsonFactory();
+                break;
+            case Jackson:
+                factory = new JacksonFactory();
+                break;
+            default:
+                throw new RuntimeException("Unsupported json engine");
+        }
+    }
+
+    /**
+     * Sets the JSON engine.
+     *
+     * @param factory an {@link AwsJsonFactory}
+     */
+    @SuppressWarnings("checkstyle:hiddenfield")
+    static void setJsonEngine(AwsJsonFactory factory) {
+        if (factory == null) {
+            throw new IllegalArgumentException("factory can't be null");
+        }
+        JsonUtils.factory = factory;
+    }
+
+    /**
+     * Gets a JSON reader. If no JSON engine is available, an
+     * {@link AmazonClientException} will be thrown.
+     *
+     * @param in reader
+     * @return a JSON reader
+     */
+    public static AwsJsonReader getJsonReader(Reader in) {
+        if (factory == null) {
+            throw new IllegalStateException("Json engine is unavailable.");
+        }
+        return factory.getJsonReader(in);
+    }
+
+    /**
+     * Gets a JSON writer. If no JSON engine is available, an
+     * {@link AmazonClientException} will be thrown.
+     *
+     * @param out writer
+     * @return a JSON writer
+     */
+    public static AwsJsonWriter getJsonWriter(Writer out) {
+        if (factory == null) {
+            throw new IllegalStateException("Json engine is unavailable.");
+        }
+        return factory.getJsonWriter(out);
+    }
+
+    /**
+     * Convenient method to convert a JSON string to a map. Any object or array
+     * will be discarded. Number and boolean are stored as string.
+     *
+     * @param in reader
+     * @return a non null, unmodifiable, string to string map
+     */
+    @SuppressWarnings("unchecked")
+    public static Map<String, String> jsonToMap(Reader in) {
+        AwsJsonReader reader = getJsonReader(in);
+        try {
+            // in case it's empty
+            if (reader.peek() == null) {
+                return Collections.EMPTY_MAP;
+            }
+
+            Map<String, String> map = new HashMap<String, String>();
+            reader.beginObject();
+            while (reader.hasNext()) {
+                String key = reader.nextName();
+                if (reader.isContainer()) {
+                    // skip non string nodes
+                    reader.skipValue();
+                } else {
+                    map.put(key, reader.nextString());
+                }
+            }
+            reader.endObject();
+            reader.close();
+
+            return Collections.unmodifiableMap(map);
+        } catch (IOException e) {
+            throw new AmazonClientException("Unable to parse JSON String.", e);
+        }
+    }
+
+    /**
+     * Convenient method to convert a JSON string to a map. Any object or array
+     * will be discarded. Number and boolean are stored as string.
+     *
+     * @param json a JSON encoding string
+     * @return a non null, unmodifiable, string to string map
+     */
+    @SuppressWarnings("unchecked")
+    public static Map<String, String> jsonToMap(String json) {
+        if (json == null || json.isEmpty()) {
+            return Collections.EMPTY_MAP;
+        }
+        return jsonToMap(new StringReader(json));
+    }
+
+    /**
+     * Encode a string to string map as a JSON string.
+     *
+     * @param map map to be encoded
+     * @return a non null JSON string
+     */
+    public static String mapToString(Map<String, String> map) {
+        if (map == null || map.isEmpty()) {
+            return "{}";
+        }
+
+        try {
+            StringWriter out = new StringWriter();
+            AwsJsonWriter writer = getJsonWriter(out);
+            writer.beginObject();
+            for (Map.Entry<String, String> entry : map.entrySet()) {
+                writer.name(entry.getKey()).value(entry.getValue());
+            }
+            writer.endObject();
+            writer.close();
+            return out.toString();
+        } catch (IOException e) {
+            throw new AmazonClientException("Unable to serialize to JSON String.", e);
+        }
+    }
+
+    /**
+     * A helper function to check whether a class is available.
+     *
+     * @param className full name of the class
+     * @return true if found, false otherwise
+     */
+    @SuppressWarnings("unused")
+    private static boolean isClassAvailable(String className) {
+        try {
+            Class.forName(className);
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/main/resources/fabric/com.amazonaws.aws-android-sdk-core.properties b/aws-java-sdk-core/src/main/resources/fabric/com.amazonaws.aws-android-sdk-core.properties
new file mode 100644
index 0000000000..99ade13983
--- /dev/null
+++ b/aws-java-sdk-core/src/main/resources/fabric/com.amazonaws.aws-android-sdk-core.properties
@@ -0,0 +1,3 @@
+fabric-identifier=com.amazonaws.aws-android-sdk-core
+fabric-version=2.6.19
+fabric-build-type=binary
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/AbortedExceptionTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/AbortedExceptionTest.java
new file mode 100644
index 0000000000..e2eb372a6d
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/AbortedExceptionTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+
+import org.junit.Test;
+
+public class AbortedExceptionTest {
+
+    @Test
+    public void testConstructors() {
+        AbortedException ae1 = new AbortedException();
+        assertNull(ae1.getCause());
+        assertEquals(ae1.getMessage(), "");
+
+        AbortedException ae2 = new AbortedException("cause");
+        assertEquals(ae2.getLocalizedMessage(), "cause");
+        assertNull(ae2.getCause());
+
+        Throwable throwable = new Throwable();
+        AbortedException ae3 = new AbortedException(throwable);
+        assertSame(ae3.getCause(), throwable);
+        assertEquals(ae3.getMessage(), "");
+
+        AbortedException ae4 = new AbortedException("test", throwable);
+        assertSame(ae4.getCause(), throwable);
+        assertEquals(ae4.getMessage(), "test");
+    }
+
+    @Test
+    public void testRetryable() {
+
+        AbortedException ae1 = new AbortedException();
+        assertFalse(ae1.isRetryable());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceClientTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceClientTest.java
new file mode 100644
index 0000000000..f13b33d80b
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceClientTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+
+import com.amazonaws.auth.AWS4Signer;
+import com.amazonaws.auth.QueryStringSigner;
+import com.amazonaws.handlers.RequestHandler2;
+import com.amazonaws.http.ExecutionContext;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+public class AmazonWebServiceClientTest {
+
+    @Test
+    public void emptyClient() {
+        final AmazonWebServiceClient client =
+                new AmazonWebServiceClient(new ClientConfiguration()) {
+                };
+
+        try {
+            client.getServiceName();
+        } catch (final IllegalStateException exception) {
+        }
+    }
+
+    @Test
+    public void testDefaultSigner() {
+        final AmazonTestClient client = new AmazonTestClient();
+
+        Assert.assertEquals("test", client.getServiceName());
+        Assert.assertTrue(client.getSigner() instanceof AWS4Signer);
+    }
+
+    @Test
+    public void testOverrideSigner() {
+        final ClientConfiguration config = new ClientConfiguration();
+        config.setSignerOverride("QueryStringSignerType");
+
+        final AmazonTestClient client = new AmazonTestClient(config);
+
+        Assert.assertTrue(client.getSigner() instanceof QueryStringSigner);
+    }
+
+    @Test
+    public void setServiceNameIntern() {
+        final AmazonTestClient client = new AmazonTestClient();
+        assertEquals(client.getServiceName(), client.getServiceNameIntern());
+        final String serviceNameOverride = "foo";
+        assertFalse(serviceNameOverride.equals(client.getServiceName()));
+        client.setServiceNameIntern(serviceNameOverride);
+        assertEquals(serviceNameOverride, client.getServiceName());
+    }
+
+    @Test
+    public void testGetServiceNameWithExplicitInternalConfiguration() {
+        final AmazonSimpleDBClient testClient = new AmazonSimpleDBClient();
+        assertEquals(testClient.getServiceName(), "sdb");
+    }
+
+    @Test
+    public void testGetServiceNameWithAWSPrefix() {
+        final AWSTestClient testClient = new AWSTestClient();
+        assertEquals(testClient.getServiceName(), "test");
+    }
+
+    private static class AmazonTestClient extends AmazonWebServiceClient {
+        public AmazonTestClient() {
+            this(new ClientConfiguration());
+        }
+
+        public AmazonTestClient(final ClientConfiguration config) {
+            super(config);
+            super.setEndpoint("test.us-west-2.amazonaws.com");
+            this.endpointPrefix = "test";
+        }
+    }
+
+    private static class AWSTestClient extends AmazonWebServiceClient {
+        public AWSTestClient() {
+            this(new ClientConfiguration());
+        }
+
+        public AWSTestClient(final ClientConfiguration config) {
+            super(config);
+            super.setEndpoint("test.us-west-2.amazonaws.com");
+            this.endpointPrefix = "test";
+        }
+    }
+
+    // Has an explicitly set name in InternalConfig
+    private static class AmazonSimpleDBClient extends AmazonWebServiceClient {
+        public AmazonSimpleDBClient() {
+            this(new ClientConfiguration());
+        }
+
+        public AmazonSimpleDBClient(final ClientConfiguration config) {
+            super(config);
+            super.setEndpoint("test.us-west-2.amazonaws.com");
+            this.endpointPrefix = "test";
+        }
+    }
+
+    @Test
+    public void testSetEndpoint() throws URISyntaxException {
+        final AmazonTestClient client = new AmazonTestClient();
+        client.setEndpoint("http://www.test.com");
+        assertEquals(client.endpoint, new URI("http://www.test.com"));
+    }
+
+    @Test
+    public void testSetSignerRegionOverride() {
+        final AmazonTestClient client = new AmazonTestClient();
+        client.setSignerRegionOverride("test");
+        assertEquals(client.getSignerRegionOverride(), "test");
+    }
+
+    @Test
+    public void testCreateExecutionContextWithAmazonWebServiceRequest() {
+        final AmazonWebServiceRequest awsr = new TestRequest();
+        final AmazonTestClient client = new AmazonTestClient();
+        final ExecutionContext ec = client.createExecutionContext(awsr);
+        assertEquals(client.requestHandler2s, ec.getRequestHandler2s());
+    }
+
+    @Test
+    public void testCreateExecutionContextWithRequest() {
+        final AmazonWebServiceRequest awsr = new TestRequest();
+        final Request<String> req = new DefaultRequest<String>(awsr, "test");
+
+        final AmazonTestClient client = new AmazonTestClient();
+        final ExecutionContext ec = client.createExecutionContext(req);
+        assertEquals(client.requestHandler2s, ec.getRequestHandler2s());
+    }
+
+    @Test
+    public void testAddAndRemoveRequestHandler2() {
+        final RequestHandler2 rh = new RequestHandler2() {
+
+            @Override
+            public void beforeRequest(Request<?> request) {
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Response<?> response) {
+            }
+
+            @Override
+            public void afterError(Request<?> request, Response<?> response, Exception e) {
+            }
+
+        };
+        final AmazonTestClient client = new AmazonTestClient();
+        client.addRequestHandler(rh);
+        assertEquals(client.requestHandler2s.size(), 1);
+        assertSame(client.requestHandler2s.get(0), rh);
+
+        client.removeRequestHandler(rh);
+        assertEquals(client.requestHandler2s.size(), 0);
+    }
+
+    @Test
+    public void testTimeoffset() {
+        final AmazonTestClient client = new AmazonTestClient();
+        client.withTimeOffset(100);
+        assertEquals(client.getTimeOffset(), 100);
+    }
+
+    private class TestRequest extends AmazonWebServiceRequest {
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceRequestTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceRequestTest.java
new file mode 100644
index 0000000000..7431b91487
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/AmazonWebServiceRequestTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.AnonymousAWSCredentials;
+
+import org.junit.Test;
+
+public class AmazonWebServiceRequestTest {
+
+    @Test
+    public void testSetCredentials() {
+        AmazonWebServiceRequest awsr = new TestRequest();
+        AWSCredentials creds = new AnonymousAWSCredentials();
+        awsr.setRequestCredentials(creds);
+        assertSame(awsr.getRequestCredentials(), creds);
+
+    }
+
+    @Test
+    public void testGetRequestClientOptions() {
+        AmazonWebServiceRequest awsr = new TestRequest();
+        assertNotNull(awsr.getRequestClientOptions());
+    }
+
+    private class TestRequest extends AmazonWebServiceRequest {
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/ClientConfigurationTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/ClientConfigurationTest.java
new file mode 100644
index 0000000000..33836b589f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/ClientConfigurationTest.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.retry.RetryPolicy;
+
+import org.junit.Test;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.TrustManager;
+
+public class ClientConfigurationTest {
+
+    @Test
+    public void testWithAndSetMethods() throws UnknownHostException {
+
+        ClientConfiguration c = new ClientConfiguration();
+
+        c.withConnectionTimeout(1);
+        assertEquals(c.getConnectionTimeout(), 1);
+        c.setConnectionTimeout(1);
+        assertEquals(c.getConnectionTimeout(), 1);
+
+        InetAddress ina = InetAddress.getByName(null);
+        c.withLocalAddress(ina);
+        assertEquals(c.getLocalAddress(), ina);
+        InetAddress localHost = InetAddress.getLocalHost();
+        c.setLocalAddress(localHost);
+        assertEquals(c.getLocalAddress(), localHost);
+
+        c.withMaxConnections(1);
+        assertEquals(c.getMaxConnections(), 1);
+        c.setMaxConnections(2);
+        assertEquals(c.getMaxConnections(), 2);
+
+        c.withMaxErrorRetry(1);
+        assertEquals(c.getMaxErrorRetry(), 1);
+        c.setMaxErrorRetry(2);
+        assertEquals(c.getMaxErrorRetry(), 2);
+
+        c.withPreemptiveBasicProxyAuth(true);
+        assertTrue(c.isPreemptiveBasicProxyAuth());
+        c.setPreemptiveBasicProxyAuth(false);
+        assertFalse(c.isPreemptiveBasicProxyAuth());
+
+        c.withProtocol(Protocol.HTTP);
+        assertEquals(c.getProtocol(), Protocol.HTTP);
+        c.setProtocol(Protocol.HTTPS);
+        assertEquals(c.getProtocol(), Protocol.HTTPS);
+
+        c.withProxyHost("host");
+        assertEquals(c.getProxyHost(), "host");
+        c.setProxyHost("two");
+        assertEquals(c.getProxyHost(), "two");
+
+        c.withProxyPassword("pass");
+        assertEquals(c.getProxyPassword(), "pass");
+        c.setProxyPassword("word");
+        assertEquals(c.getProxyPassword(), "word");
+
+        c.withProxyPort(1);
+        assertEquals(c.getProxyPort(), 1);
+        c.setProxyPort(2);
+        assertEquals(c.getProxyPort(), 2);
+
+        c.withProxyUsername("user");
+        assertEquals(c.getProxyUsername(), "user");
+        c.setProxyUsername("name");
+        assertEquals(c.getProxyUsername(), "name");
+
+        c.withReaper(true);
+        assertTrue(c.useReaper());
+
+        RetryPolicy rp = new RetryPolicy(null, null, 0, false);
+        c.withRetryPolicy(rp);
+        assertSame(rp, c.getRetryPolicy());
+        c.setRetryPolicy(null);
+        assertNull(c.getRetryPolicy());
+
+        c.withSignerOverride("over");
+        assertEquals(c.getSignerOverride(), "over");
+        c.setSignerOverride("ride");
+        assertEquals(c.getSignerOverride(), "ride");
+
+        c.withSocketBufferSizeHints(0, 1);
+        assertEquals(c.getSocketBufferSizeHints()[0], 0);
+        assertEquals(c.getSocketBufferSizeHints()[1], 1);
+        c.setSocketBufferSizeHints(2, 3);
+        assertEquals(c.getSocketBufferSizeHints()[0], 2);
+        assertEquals(c.getSocketBufferSizeHints()[1], 3);
+
+        c.withSocketTimeout(0);
+        assertEquals(c.getSocketTimeout(), 0);
+        c.setSocketTimeout(1);
+        assertEquals(c.getSocketTimeout(), 1);
+
+        c.withUserAgent("ua");
+        assertEquals(c.getUserAgent(), "ua");
+        c.setUserAgent("set");
+        assertEquals(c.getUserAgent(), "set");
+
+        TrustManager trustManager = new TrustManager() {
+        };
+        c.withTrustManager(trustManager);
+        assertSame(trustManager, c.getTrustManager());
+        c.setTrustManager(null);
+        assertNull(c.getTrustManager());
+    }
+
+    @Test
+    public void testCopyConstructor() throws UnknownHostException {
+        ClientConfiguration c = new ClientConfiguration();
+
+        c.withConnectionTimeout(1);
+        InetAddress ina = InetAddress.getByName(null);
+        c.withLocalAddress(ina);
+        c.withMaxConnections(1);
+        c.withMaxErrorRetry(1);
+        c.withPreemptiveBasicProxyAuth(true);
+        c.withProtocol(Protocol.HTTP);
+        c.withProxyHost("host");
+        c.withProxyPassword("pass");
+        c.withProxyPort(1);
+        c.withProxyUsername("user");
+        c.withReaper(true);
+        RetryPolicy rp = new RetryPolicy(null, null, 0, false);
+        c.withRetryPolicy(rp);
+        c.withSignerOverride("over");
+        c.withSocketBufferSizeHints(0, 1);
+        c.withSocketTimeout(0);
+        c.withUserAgent("ua");
+        TrustManager trustManager = new TrustManager() {
+        };
+        c.withTrustManager(trustManager);
+
+        ClientConfiguration n = new ClientConfiguration(c);
+        assertEquals(c.getConnectionTimeout(), n.getConnectionTimeout());
+        assertEquals(c.getLocalAddress(), n.getLocalAddress());
+        assertEquals(c.getMaxConnections(), n.getMaxConnections());
+        assertEquals(c.getMaxErrorRetry(), n.getMaxErrorRetry());
+        assertEquals(c.isPreemptiveBasicProxyAuth(), n.isPreemptiveBasicProxyAuth());
+        assertEquals(c.getProtocol(), n.getProtocol());
+        assertEquals(c.getProxyHost(), n.getProxyHost());
+        assertEquals(c.getProxyPassword(), n.getProxyPassword());
+        assertEquals(c.getProxyPort(), n.getProxyPort());
+        assertEquals(c.getProxyUsername(), n.getProxyUsername());
+        assertEquals(c.useReaper(), n.useReaper());
+        assertEquals(c.getRetryPolicy(), n.getRetryPolicy());
+        assertEquals(c.getSignerOverride(), n.getSignerOverride());
+        assertArrayEquals(c.getSocketBufferSizeHints(), n.getSocketBufferSizeHints());
+        assertEquals(c.getSocketTimeout(), n.getSocketTimeout());
+        assertEquals(c.getUserAgent(), n.getUserAgent());
+        assertSame(c.getTrustManager(), n.getTrustManager());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/DefaultRequestTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/DefaultRequestTest.java
new file mode 100644
index 0000000000..3bdfaf29f6
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/DefaultRequestTest.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+public class DefaultRequestTest {
+
+    @Test
+    public void testWithParameter() {
+        DefaultRequest r = new DefaultRequest("test");
+        r.withParameter("test", "value");
+        assertEquals(r.getParameters().get("test"), "value");
+    }
+
+    @Test
+    public void testWithTimeOffset() {
+        DefaultRequest r = new DefaultRequest("test");
+        r.withTimeOffset(1000);
+        assertEquals(r.getTimeOffset(), 1000);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/RequestClientOptionsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/RequestClientOptionsTest.java
new file mode 100644
index 0000000000..bba91021c6
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/RequestClientOptionsTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.RequestClientOptions.Marker;
+
+import org.junit.Test;
+
+public class RequestClientOptionsTest {
+    @Test
+    public void test() {
+        RequestClientOptions opts = new RequestClientOptions();
+        for (Marker m : Marker.values()) {
+            assertNull(opts.getClientMarker(m));
+        }
+        for (Marker m : Marker.values()) {
+            opts.putClientMarker(m, m.name());
+        }
+        for (Marker m : Marker.values()) {
+            assertEquals(m.name(), opts.getClientMarker(m));
+        }
+        assertEquals(Marker.USER_AGENT.name(), opts.getClientMarker());
+        opts.addClientMarker("2nd-agent");
+        String ua = opts.getClientMarker();
+        assertEquals(ua, Marker.USER_AGENT.name() + " 2nd-agent", ua);
+        opts.appendUserAgent("3rd-agent");
+        ua = opts.getClientMarker();
+        assertEquals(ua, Marker.USER_AGENT.name() + " 2nd-agent 3rd-agent", ua);
+        assertEquals(ua, opts.getClientMarker(Marker.USER_AGENT));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS3SignerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS3SignerTest.java
new file mode 100644
index 0000000000..86e426341f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS3SignerTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Tests for the AWS3 signer implementation.
+ */
+public class AWS3SignerTest {
+
+    /**
+     * A previously computed AWS3 HTTP authorization header from a Coral
+     * Explorer request.
+     */
+    private static final String EXPECTED_AUTHORIZATION_HEADER =
+            "AWS3 AWSAccessKeyId=access,Algorithm=HmacSHA256," +
+                    "SignedHeaders=Host;X-Amz-Date;X-Amz-Target," +
+                    "Signature=ceuBBi+ulAGez7YKUWkrZRLga+L8hE1vi4M95aZVwCw=";
+
+    /** Shared signer for tests to use. */
+    private final AWS3Signer signer = new AWS3Signer();
+
+    /**
+     * Tests that we can calculate an AWS3 HTTP signature and compares it to a
+     * previously computed signature.
+     */
+    @Test
+    public void testHttpSigning() throws Exception {
+        AWSCredentials credentials = new BasicAWSCredentials("access", "secret");
+        Request<?> request = new DefaultRequest<Void>("Foo");
+        request.setContent(new ByteArrayInputStream("{\"TableName\": \"foo\"}"
+                .getBytes(StringUtils.UTF8)));
+        request.setResourcePath("/");
+        request.addHeader("X-Amz-Target",
+                "com.amazon.bigbird.sharedtypes.BigBirdRequestRouterService.DescribeTable");
+        request.setEndpoint(URI.create("http://sdb-func7-3001.sea3:8080"));
+
+        // Override the date, so that we use the same date as
+        // the previously
+        signer.overrideDate("Tue, 15 Mar 2011 20:35:24 GMT");
+        signer.sign(request, credentials);
+
+        String authorization = request.getHeaders().get("X-Amzn-Authorization");
+        assertEquals(EXPECTED_AUTHORIZATION_HEADER, authorization);
+    }
+
+    @Test
+    public void testShouldUseHttps() throws URISyntaxException {
+        Request<?> request = new DefaultRequest("testService");
+        request.setEndpoint(new URI("https://mytest.service.com"));
+        assertTrue(signer.shouldUseHttpsScheme(request));
+    }
+
+    @Test
+    public void testShouldNotUseHttps() throws URISyntaxException {
+        Request<?> request = new DefaultRequest("testService");
+        request.setEndpoint(new URI("http://mytest.service.com"));
+        assertFalse(signer.shouldUseHttpsScheme(request));
+    }
+
+    /**
+     * Tests that if passed anonymous credentials, signer will not generate a
+     * signature
+     */
+    @Test
+    public void testAnonymous() throws Exception {
+        AWSCredentials credentials = new AnonymousAWSCredentials();
+        Request<?> request = new DefaultRequest<Void>("Foo");
+        request.setContent(new ByteArrayInputStream("{\"TableName\": \"foo\"}"
+                .getBytes(StringUtils.UTF8)));
+        request.setResourcePath("/");
+        request.addHeader("X-Amz-Target",
+                "com.amazon.bigbird.sharedtypes.BigBirdRequestRouterService.DescribeTable");
+        request.setEndpoint(URI.create("http://sdb-func7-3001.sea3:8080"));
+
+        // Override the date, so that we use the same date as
+        // the previously
+        signer.overrideDate("Tue, 15 Mar 2011 20:35:24 GMT");
+        signer.sign(request, credentials);
+
+        String authorization = request.getHeaders().get("X-Amzn-Authorization");
+        assertNull(authorization);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS4SignerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS4SignerTest.java
new file mode 100644
index 0000000000..53bf4e0229
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWS4SignerTest.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.net.URI;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
+
+/**
+ * Unit tests for the
+ */
+public class AWS4SignerTest {
+    private final AWS4Signer signer = new AWS4Signer();
+
+    @Test
+    public void testDoubleURLEncode() {
+        // Sanity-check that doubleUrlEncode is true by default.
+        Assert.assertTrue(signer.doubleUrlEncode);
+    }
+
+    @Test
+    public void testSigning() throws Exception {
+
+        final String EXPECTED_AUTHORIZATION_HEADER_WITHOUT_SHA256_HEADER =
+                "AWS4-HMAC-SHA256 Credential=access/19810216/us-east-1/demo/aws4_request, SignedHeaders=host;x-amz-archive-description;x-amz-date, Signature=77fe7c02927966018667f21d1dc3dfad9057e58401cbb9ed64f1b7868288e35a";
+
+        final String EXPECTED_AUTHORIZATION_HEADER_WITH_SHA256_HEADER =
+                "AWS4-HMAC-SHA256 Credential=access/19810216/us-east-1/demo/aws4_request, SignedHeaders=host;x-amz-archive-description;x-amz-date;x-amz-sha256, Signature=e73e20539446307a5dc71252dbd5b97e861f1d1267456abda3ebd8d57e519951";
+
+        final AWSCredentials credentials = new BasicAWSCredentials("access", "secret");
+        // Test request without 'x-amz-sha256' header
+        Request<?> request = generateBasicRequest();
+
+        final Calendar c = new GregorianCalendar();
+        c.set(1981, 1, 16, 6, 30, 0);
+        c.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        signer.overrideDate(c.getTime());
+
+        signer.sign(request, credentials);
+        assertEquals(EXPECTED_AUTHORIZATION_HEADER_WITHOUT_SHA256_HEADER,
+                request.getHeaders().get("Authorization"));
+
+        // Test request with 'x-amz-sha256' header
+        request = generateBasicRequest();
+        request.addHeader("x-amz-sha256", "required");
+
+        signer.sign(request, credentials);
+        assertEquals(EXPECTED_AUTHORIZATION_HEADER_WITH_SHA256_HEADER,
+                request.getHeaders().get("Authorization"));
+    }
+
+    @Test
+    public void testPresigning() throws Exception {
+        final String EXPECTED_AMZ_SIGNATURE = "909d8bc528fec51c0cc6daaa6c29291c519de10f77490d8af57872c29203ebdb";
+        final String EXPECTED_AMZ_CREDENTIALS = "access/19810216/us-east-1/demo/aws4_request";
+        final String EXPECTED_AMZ_HEADER = "19810216T063000Z";
+        final String EXPECTED_AMZ_EXPIRES = "604800";
+        final AWSCredentials credentials = new AWSSessionCredentials() {
+
+            @Override
+            public String getAWSSecretKey() {
+                // TODO Auto-generated method stub
+                return "secret";
+            }
+
+            @Override
+            public String getAWSAccessKeyId() {
+                // TODO Auto-generated method stub
+                return "access";
+            }
+
+            @Override
+            public String getSessionToken() {
+                // TODO Auto-generated method stub
+                return "token";
+            }
+        };
+        // final AWSCredentials credentials = new BasicAWSCredentials("access",
+        // "secret");
+        // Test request without 'x-amz-sha256' header
+
+        final Request<?> request = generateBasicRequest();
+
+        final Calendar c = new GregorianCalendar();
+        c.set(1981, 1, 16, 6, 30, 0);
+        c.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        signer.overrideDate(c.getTime());
+        signer.setServiceName("demo");
+
+        signer.presignRequest(request, credentials, null);
+        assertEquals(EXPECTED_AMZ_SIGNATURE,
+                request.getParameters().get("X-Amz-Signature"));
+        assertEquals(EXPECTED_AMZ_CREDENTIALS,
+                request.getParameters().get("X-Amz-Credential"));
+        assertEquals(EXPECTED_AMZ_HEADER, request.getParameters().get("X-Amz-Date"));
+        assertEquals(EXPECTED_AMZ_EXPIRES, request.getParameters().get("X-Amz-Expires"));
+        assertEquals("token", request.getParameters().get("X-Amz-Security-Token"));
+
+    }
+
+    @Test
+    public void testPresigners2() throws Exception {
+        final AWSCredentials credentials = new AnonymousAWSCredentials();
+        final Request<?> request = generateBasicRequest();
+        final Calendar c = new GregorianCalendar();
+        c.set(1981, 1, 16, 6, 30, 0);
+        c.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        signer.overrideDate(c.getTime());
+        signer.setServiceName("demo");
+
+        signer.presignRequest(request, credentials, null);
+        assertNull(request.getParameters().get("X-Amz-Credential"));
+        assertNull(request.getParameters().get("X-Amz-Date"));
+        assertNull(request.getParameters().get("X-Amz-Expires"));
+        assertNull(request.getParameters().get("X-Amz-Security-Token"));
+
+    }
+
+    @Test
+    public void testCorrectHeadersAreSigned() {
+        // Make sure neccesary headers are signed
+        assertTrue(signer.needsSign("date"));
+        assertTrue(signer.needsSign("Content-MD5"));
+        assertTrue(signer.needsSign("x-amz"));
+        assertTrue(signer.needsSign("X-Amz"));
+        assertTrue(signer.needsSign("host"));
+
+        // Make sure other eachers are not signed
+
+        assertFalse(signer.needsSign(""));
+        assertFalse(signer.needsSign("Content-Type"));
+        assertFalse(signer.needsSign("Content-Length"));
+        assertFalse(signer.needsSign("Signature"));
+        assertFalse(signer.needsSign("Accept-Encoding"));
+        assertFalse(signer.needsSign("Accept"));
+        assertFalse(signer.needsSign("User-Agent"));
+    }
+
+    /**
+     * Tests that if passed anonymous credentials, signer will not generate a
+     * signature
+     */
+    @Test
+    public void testAnonymous() throws Exception {
+        final AWSCredentials credentials = new AnonymousAWSCredentials();
+        final Request<?> request = generateBasicRequest();
+
+        final Calendar c = new GregorianCalendar();
+        c.set(1981, 1, 16, 6, 30, 0);
+        c.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        signer.overrideDate(c.getTime());
+
+        signer.sign(request, credentials);
+
+        assertNull(request.getHeaders().get("Authorization"));
+    }
+
+    private Request<?> generateBasicRequest() {
+        final Request<?> request = new DefaultRequest<Void>("Foo");
+        request.setContent(new ByteArrayInputStream("{\"TableName\": \"foo\"}"
+                .getBytes(StringUtils.UTF8)));
+        request.addHeader("Host", "demo.us-east-1.amazonaws.com");
+        // HTTP header containing multiple spaces in a row.
+        request.addHeader("x-amz-archive-description", "test  test");
+        request.setResourcePath("/");
+        request.setEndpoint(URI.create("http://demo.us-east-1.amazonaws.com"));
+        return request;
+    }
+
+    private String getOldTimeStamp(Date date) {
+        final SimpleDateFormat dateTimeFormat = new SimpleDateFormat(
+                "yyyyMMdd'T'HHmmss'Z'");
+        dateTimeFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
+        return dateTimeFormat.format(date);
+    }
+
+    @Test
+    public void getTimeStamp() {
+        final Date now = new Date();
+        final String timeStamp = new AWS4Signer().getTimeStamp(now.getTime());
+        final String old = getOldTimeStamp(now);
+        assertEquals(old, timeStamp);
+    }
+
+    private String getOldDateStamp(Date date) {
+        final SimpleDateFormat dateStampFormat = new SimpleDateFormat("yyyyMMdd");
+        dateStampFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
+        return dateStampFormat.format(date);
+    }
+
+    @Test
+    public void getDateStamp() {
+        final Date now = new Date();
+        final String dateStamp = new AWS4Signer().getDateStamp(now.getTime());
+        final String old = getOldDateStamp(now);
+        assertEquals(old, dateStamp);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWSCredentialsProviderChainTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWSCredentialsProviderChainTest.java
new file mode 100644
index 0000000000..fa4afdc774
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/AWSCredentialsProviderChainTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.internal.StaticCredentialsProvider;
+
+import org.junit.Test;
+
+public class AWSCredentialsProviderChainTest {
+
+    /**
+     * Tests that, by default, the chain remembers which provider was able to
+     * provide credentials, and only calls that provider for any additional
+     * calls to getCredentials.
+     */
+    @Test
+    public void testReusingLastProvider() throws Exception {
+        MockCredentialsProvider provider1 = new MockCredentialsProvider();
+        provider1.throwException = true;
+        MockCredentialsProvider provider2 = new MockCredentialsProvider();
+        AWSCredentialsProviderChain chain = new AWSCredentialsProviderChain(provider1, provider2);
+
+        assertEquals(0, provider1.getCredentialsCallCount);
+        assertEquals(0, provider2.getCredentialsCallCount);
+
+        chain.getCredentials();
+        assertEquals(1, provider1.getCredentialsCallCount);
+        assertEquals(1, provider2.getCredentialsCallCount);
+
+        chain.getCredentials();
+        assertEquals(1, provider1.getCredentialsCallCount);
+        assertEquals(2, provider2.getCredentialsCallCount);
+
+        chain.getCredentials();
+        assertEquals(1, provider1.getCredentialsCallCount);
+        assertEquals(3, provider2.getCredentialsCallCount);
+    }
+
+    /**
+     * Tests that, when provider caching is disabled, the chain will always try
+     * all providers in the chain, starting with the first, until it finds a
+     * provider that can return credentials.
+     */
+    @Test
+    public void testDisableReusingLastProvider() throws Exception {
+        MockCredentialsProvider provider1 = new MockCredentialsProvider();
+        provider1.throwException = true;
+        MockCredentialsProvider provider2 = new MockCredentialsProvider();
+        AWSCredentialsProviderChain chain = new AWSCredentialsProviderChain(provider1, provider2);
+        chain.setReuseLastProvider(false);
+
+        assertEquals(0, provider1.getCredentialsCallCount);
+        assertEquals(0, provider2.getCredentialsCallCount);
+
+        chain.getCredentials();
+        assertEquals(1, provider1.getCredentialsCallCount);
+        assertEquals(1, provider2.getCredentialsCallCount);
+
+        chain.getCredentials();
+        assertEquals(2, provider1.getCredentialsCallCount);
+        assertEquals(2, provider2.getCredentialsCallCount);
+    }
+
+    private static final class MockCredentialsProvider extends StaticCredentialsProvider {
+        public int getCredentialsCallCount = 0;
+        public boolean throwException = false;
+
+        public MockCredentialsProvider() {
+            super(new BasicAWSCredentials("accessKey", "secretKey"));
+        }
+
+        @Override
+        public AWSCredentials getCredentials() {
+            getCredentialsCallCount++;
+
+            if (throwException)
+                throw new RuntimeException("No credentials");
+            else
+                return super.getCredentials();
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/QueryStringSignerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/QueryStringSignerTest.java
new file mode 100644
index 0000000000..757e09bd14
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/QueryStringSignerTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+
+import org.junit.Test;
+
+import java.net.URI;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+public class QueryStringSignerTest {
+
+    private static final QueryStringSigner signer = new QueryStringSigner();
+    private static final AWSCredentials credentials = new BasicAWSCredentials("123456789",
+            "123456789");
+
+    private static final String EXPECTED_SIGNATURE = "VjYMhf9TWp08zAxXbKDAvUhW9GjJ56QjAuSj3LBsfjM=";
+
+    static {
+        Calendar c = new GregorianCalendar();
+        c.clear();
+        c.set(1981, 1, 16, 6, 30, 0);
+        c.setTimeZone(TimeZone.getTimeZone("UTC"));
+        signer.overrideDate(c.getTime());
+    }
+
+    @Test
+    public void testRequestResourcePath() throws Exception {
+        Request<?> request = new DefaultRequest<Void>(null, "foo");
+        request.setEndpoint(URI.create("http://foo.amazon.com"));
+        request.addParameter("foo", "bar");
+        request.setResourcePath("foo/bar");
+
+        signer.sign(request, credentials);
+        assertNotNull(request.getParameters().get("Signature"));
+        assertEquals(EXPECTED_SIGNATURE, request.getParameters().get("Signature"));
+    }
+
+    @Test
+    public void testRequestAndEndpointResourcePath() throws Exception {
+        Request<?> request = new DefaultRequest<Void>(null, "foo");
+        request.setEndpoint(URI.create("http://foo.amazon.com/foo"));
+        request.addParameter("foo", "bar");
+        request.setResourcePath("/bar");
+
+        signer.sign(request, credentials);
+        assertNotNull(request.getParameters().get("Signature"));
+        assertEquals(EXPECTED_SIGNATURE, request.getParameters().get("Signature"));
+    }
+
+    @Test
+    public void testRequestAndEndpointResourcePathNoSlash() throws Exception {
+        Request<?> request = new DefaultRequest<Void>(null, "foo");
+        request.setEndpoint(URI.create("http://foo.amazon.com/foo"));
+        request.addParameter("foo", "bar");
+        request.setResourcePath("bar");
+
+        signer.sign(request, credentials);
+
+        assertNotNull(request.getParameters().get("Signature"));
+        assertEquals(EXPECTED_SIGNATURE, request.getParameters().get("Signature"));
+    }
+
+    @Test
+    public void testAnonymous() throws Exception {
+        Request<?> request = new DefaultRequest<Void>(null, "foo");
+        request.setEndpoint(URI.create("http://foo.amazon.com/foo"));
+        request.addParameter("foo", "bar");
+        request.setResourcePath("bar");
+
+        signer.sign(request, new AnonymousAWSCredentials());
+
+        assertNull(request.getParameters().get("Signature"));
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyReaderTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyReaderTest.java
new file mode 100644
index 0000000000..1c3f9793e6
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyReaderTest.java
@@ -0,0 +1,377 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.auth.policy.Principal.Services;
+import com.amazonaws.auth.policy.Statement.Effect;
+import com.amazonaws.auth.policy.conditions.ConditionFactory;
+import com.amazonaws.auth.policy.conditions.IpAddressCondition;
+import com.amazonaws.auth.policy.conditions.IpAddressCondition.IpAddressComparisonType;
+import com.amazonaws.auth.policy.conditions.StringCondition;
+import com.amazonaws.auth.policy.conditions.StringCondition.StringComparisonType;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Unit tests for generating AWS policy object from JSON string.
+ */
+public class PolicyReaderTest {
+
+    final String POLICY_VERSION = "2012-10-17";
+
+    @Test
+    public void testPrincipals() throws IOException {
+        Policy policy = new Policy();
+        policy.withStatements(new Statement(Effect.Allow)
+                .withResources(new Resource("resource"))
+                .withPrincipals(new Principal("accountId1"), new Principal("accountId2"))
+                .withActions(new TestAction("action")));
+
+        policy = Policy.fromJson(policy.toJson());
+        assertEquals(1, policy.getStatements().size());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("action", statements.get(0).getActions().get(0).getActionName());
+        assertEquals("resource", statements.get(0).getResources().get(0).getId());
+        assertEquals(2, statements.get(0).getPrincipals().size());
+        assertEquals("AWS", statements.get(0).getPrincipals().get(0).getProvider());
+        assertEquals("accountId1", statements.get(0).getPrincipals().get(0).getId());
+        assertEquals("AWS", statements.get(0).getPrincipals().get(1).getProvider());
+        assertEquals("accountId2", statements.get(0).getPrincipals().get(1).getId());
+
+        policy = new Policy();
+        policy.withStatements(new Statement(Effect.Allow)
+                .withResources(new Resource("resource"))
+                .withPrincipals(new Principal(Services.AmazonEC2),
+                        new Principal(Services.AmazonElasticTranscoder))
+                .withActions(new TestAction("action")));
+        policy = Policy.fromJson(policy.toJson());
+        assertEquals(1, policy.getStatements().size());
+        statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals("action", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(2, statements.get(0).getPrincipals().size());
+        assertEquals("Service", statements.get(0).getPrincipals().get(0).getProvider());
+        assertEquals(Services.AmazonEC2.getServiceId(), statements.get(0).getPrincipals().get(0)
+                .getId());
+        assertEquals("Service", statements.get(0).getPrincipals().get(1).getProvider());
+        assertEquals(Services.AmazonElasticTranscoder.getServiceId(), statements.get(0)
+                .getPrincipals().get(1).getId());
+
+        policy = new Policy();
+        policy.withStatements(new Statement(Effect.Allow).withResources(new Resource("resource"))
+                .withPrincipals(Principal.All)
+                .withActions(new TestAction("action")));
+        policy = Policy.fromJson(policy.toJson());
+        assertEquals(1, policy.getStatements().size());
+        statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals("action", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals(Principal.All, statements.get(0).getPrincipals().get(0));
+
+        policy = new Policy();
+        policy.withStatements(new Statement(Effect.Allow)
+                .withResources(new Resource("resource"))
+                .withPrincipals(Principal.AllUsers, Principal.AllServices,
+                        Principal.AllWebProviders)
+                .withActions(new TestAction("action")));
+        policy = Policy.fromJson(policy.toJson());
+        assertEquals(1, policy.getStatements().size());
+        statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals("action", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(3, statements.get(0).getPrincipals().size());
+        assertEquals(Principal.AllServices, statements.get(0).getPrincipals().get(0));
+        assertEquals(Principal.AllUsers, statements.get(0).getPrincipals().get(1));
+        assertEquals(Principal.AllWebProviders, statements.get(0).getPrincipals().get(2));
+    }
+
+    @Test
+    public void testMultipleConditionKeysForConditionType() throws Exception {
+        Policy policy = new Policy();
+        policy.withStatements(new Statement(Effect.Allow)
+                .withResources(new Resource("arn:aws:sqs:us-east-1:987654321000:MyQueue"))
+                .withPrincipals(Principal.AllUsers)
+                .withActions(new TestAction("foo"))
+                .withConditions(
+                        new StringCondition(StringComparisonType.StringNotLike, "key1", "foo"),
+                        new StringCondition(StringComparisonType.StringNotLike, "key1", "bar")));
+
+        policy = Policy.fromJson(policy.toJson());
+
+        assertEquals(1, policy.getStatements().size());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals("foo", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(0).getConditions().size());
+        assertEquals("StringNotLike", statements.get(0).getConditions().get(0).getType());
+        assertEquals("key1", statements.get(0).getConditions().get(0).getConditionKey());
+        assertEquals(2, statements.get(0).getConditions().get(0).getValues().size());
+        assertEquals("foo", statements.get(0).getConditions().get(0).getValues().get(0));
+        assertEquals("bar", statements.get(0).getConditions().get(0).getValues().get(1));
+    }
+
+    @Test
+    public void testMultipleStatements() throws Exception {
+        Policy policy = new Policy("S3PolicyId1");
+        policy.withStatements(
+                new Statement(Effect.Allow)
+                        .withId("0")
+                        .withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action1"))
+                        .withResources(new Resource("resource"))
+                        .withConditions(
+                                new IpAddressCondition("192.168.143.0/24")),
+                new Statement(Effect.Deny)
+                        .withId("1")
+                        .withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action2"))
+                        .withResources(new Resource("resource"))
+                        .withConditions(new IpAddressCondition("10.1.2.0/24")),
+                new Statement(Effect.Allow)
+                        .withId("2")
+                        .withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action3"))
+                        .withResources(new Resource("resource"))
+                        .withConditions(new IpAddressCondition(IpAddressComparisonType.NotIpAddress,
+                                "192.168.143.188/32")));
+
+        policy = Policy.fromJson(policy.toJson());
+        assertEquals(3, policy.getStatements().size());
+        assertEquals("S3PolicyId1", policy.getId());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("0", statements.get(0).getId());
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals("*", statements.get(0).getPrincipals().get(0).getId());
+        assertEquals("AWS", statements.get(0).getPrincipals().get(0).getProvider());
+        assertEquals(1, statements.get(0).getResources().size());
+        assertEquals("resource", statements.get(0).getResources().get(0).getId());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals("action1", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(0).getConditions().size());
+        assertEquals("IpAddress", statements.get(0).getConditions().get(0).getType());
+        assertEquals(ConditionFactory.SOURCE_IP_CONDITION_KEY, statements.get(0).getConditions()
+                .get(0).getConditionKey());
+        assertEquals(1, statements.get(0).getConditions().get(0).getValues().size());
+        assertEquals("192.168.143.0/24", statements.get(0).getConditions().get(0).getValues()
+                .get(0));
+
+        assertEquals(Effect.Deny, statements.get(1).getEffect());
+        assertEquals("1", statements.get(1).getId());
+        assertEquals(1, statements.get(1).getPrincipals().size());
+        assertEquals("*", statements.get(1).getPrincipals().get(0).getId());
+        assertEquals("AWS", statements.get(1).getPrincipals().get(0).getProvider());
+        assertEquals(1, statements.get(1).getResources().size());
+        assertEquals("resource", statements.get(1).getResources().get(0).getId());
+        assertEquals(1, statements.get(1).getActions().size());
+        assertEquals("action2", statements.get(1).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(1).getConditions().size());
+        assertEquals("IpAddress", statements.get(1).getConditions().get(0).getType());
+        assertEquals(ConditionFactory.SOURCE_IP_CONDITION_KEY, statements.get(0).getConditions()
+                .get(0).getConditionKey());
+        assertEquals(1, statements.get(0).getConditions().get(0).getValues().size());
+        assertEquals("10.1.2.0/24", statements.get(1).getConditions().get(0).getValues().get(0));
+
+        assertEquals(Effect.Allow, statements.get(2).getEffect());
+        assertEquals("2", statements.get(2).getId());
+        assertEquals(1, statements.get(2).getPrincipals().size());
+        assertEquals("*", statements.get(2).getPrincipals().get(0).getId());
+        assertEquals("AWS", statements.get(2).getPrincipals().get(0).getProvider());
+        assertEquals(1, statements.get(2).getResources().size());
+        assertEquals("resource", statements.get(2).getResources().get(0).getId());
+        assertEquals(1, statements.get(2).getActions().size());
+        assertEquals("action3", statements.get(2).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(2).getConditions().size());
+        assertEquals("NotIpAddress", statements.get(2).getConditions().get(0).getType());
+        assertEquals("192.168.143.188/32", statements.get(2).getConditions().get(0).getValues().get(0));
+    }
+
+    @Test
+    public void testNoJsonArray() {
+        String jsonString =
+                "{" +
+                        "\"Version\": \"2012-10-17\"," +
+                        "\"Statement\": [" +
+                        "{" +
+                        "\"Effect\": \"Allow\"," +
+                        "\"Principal\": {" +
+                        "\"AWS\": \"*\"" +
+                        "}," +
+                        "\"Action\": \"sts:AssumeRole\"," +
+                        "\"Condition\": {" +
+                        "\"IpAddress\": {" +
+                        " \"aws:SourceIp\": \"10.10.10.10/32\"" +
+                        "}" +
+                        "}" +
+                        "}" +
+                        "]" +
+                        "}";
+
+        Policy policy = Policy.fromJson(jsonString);
+        assertEquals(POLICY_VERSION, policy.getVersion());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+        assertEquals(1, statements.size());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("sts:AssumeRole", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(1, statements.get(0).getConditions().size());
+        assertEquals("IpAddress", statements.get(0).getConditions().get(0).getType());
+        assertEquals("aws:SourceIp", statements.get(0).getConditions().get(0).getConditionKey());
+        assertEquals(1, statements.get(0).getConditions().get(0).getValues().size());
+        assertEquals("10.10.10.10/32", statements.get(0).getConditions().get(0).getValues().get(0));
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals("*", statements.get(0).getPrincipals().get(0).getId());
+        assertEquals("AWS", statements.get(0).getPrincipals().get(0).getProvider());
+
+    }
+
+    /**
+     * Tests that SAML-based federated user is supported as principal.
+     */
+    @Test
+    public void testFederatedUserBySAMLProvider() {
+        String jsonString =
+                "{" +
+                        "\"Version\":\"2012-10-17\"," +
+                        "\"Statement\":[" +
+                        "{" +
+                        "\"Sid\":\"\"," +
+                        "\"Effect\":\"Allow\"," +
+                        "\"Principal\":{" +
+                        "\"Federated\":\"arn:aws:iam::862954416975:saml-provider/myprovider\"" +
+                        "}," +
+                        "\"Action\":\"sts:AssumeRoleWithSAML\"," +
+                        "\"Condition\":{" +
+                        "\"StringEquals\":{" +
+                        "\"SAML:aud\":\"https://signin.aws.amazon.com/saml\"" +
+                        "}" +
+                        "}" +
+                        "}" +
+                        "]" +
+                        "}";
+
+        Policy policy = Policy.fromJson(jsonString);
+        assertEquals(POLICY_VERSION, policy.getVersion());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+        assertEquals(1, statements.size());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("sts:AssumeRoleWithSAML", statements.get(0).getActions().get(0)
+                .getActionName());
+        assertEquals(1, statements.get(0).getConditions().size());
+        assertEquals("StringEquals", statements.get(0).getConditions().get(0).getType());
+        assertEquals("SAML:aud", statements.get(0).getConditions().get(0).getConditionKey());
+        assertEquals(1, statements.get(0).getConditions().get(0).getValues().size());
+        assertEquals("https://signin.aws.amazon.com/saml", statements.get(0).getConditions().get(0)
+                .getValues().get(0));
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals("arn:aws:iam::862954416975:saml-provider/myprovider", statements.get(0)
+                .getPrincipals().get(0).getId());
+        assertEquals("Federated", statements.get(0).getPrincipals().get(0).getProvider());
+    }
+
+    @Test
+    public void testCloudHSMServicePrincipal() {
+        String jsonString =
+                "{" +
+                        "\"Version\":\"2008-10-17\"," +
+                        "\"Statement\":[" +
+                        "{\"Sid\":\"\"," +
+                        "\"Effect\":\"Allow\"," +
+                        "\"Principal\":{\"Service\":\"cloudhsm.amazonaws.com\"}," +
+                        "\"Action\":\"sts:AssumeRole\"}" +
+                        "]" +
+                        "}";
+        Policy policy = Policy.fromJson(jsonString);
+        assertEquals(POLICY_VERSION, policy.getVersion());
+        List<Statement> statements = new LinkedList<Statement>(policy.getStatements());
+        assertEquals(1, statements.size());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("sts:AssumeRole", statements.get(0).getActions().get(0).getActionName());
+        assertEquals(0, statements.get(0).getConditions().size());
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals(Services.AWSCloudHSM.getServiceId(), statements.get(0).getPrincipals().get(0)
+                .getId());
+        assertEquals("Service", statements.get(0).getPrincipals().get(0).getProvider());
+    }
+
+    private class TestAction implements Action {
+        private final String name;
+
+        public TestAction(String name) {
+            this.name = name;
+        }
+
+        @Override
+        public String getActionName() {
+            return name;
+        }
+    }
+
+    /**
+     * This test case was written as result of the following tt
+     *
+     * @see https://tt.amazon.com/0030871921 When a service is mentioned in the
+     *      principal, we always try to figure out the service from
+     *      <code>com.amazonaws.auth.policy.Principal.Services</code> enum. For
+     *      new services introduced, if the enum is not updated, then the
+     *      parsing fails.
+     */
+    @Test
+    public void testPrincipalWithServiceNotInServicesEnum() {
+        String jsonString = "{" + "\"Version\":\"2008-10-17\","
+                + "\"Statement\":[" + "{" + "\"Sid\":\"\","
+                + "\"Effect\":\"Allow\"," + "\"Principal\":{"
+                + "\"Service\":\"workspaces.amazonaws.com\" " + "},"
+                + "\"Action\":\"sts:AssumeRole\"" + "}" + "]" + "}";
+
+        Policy policy = Policy.fromJson(jsonString);
+        assertEquals(POLICY_VERSION, policy.getVersion());
+        List<Statement> statements = new LinkedList<Statement>(
+                policy.getStatements());
+        assertEquals(1, statements.size());
+        assertEquals(1, statements.get(0).getActions().size());
+        assertEquals(Effect.Allow, statements.get(0).getEffect());
+        assertEquals("sts:AssumeRole", statements.get(0).getActions().get(0)
+                .getActionName());
+        assertEquals(0, statements.get(0).getConditions().size());
+        assertEquals(1, statements.get(0).getPrincipals().size());
+        assertEquals("workspaces.amazonaws.com", statements.get(0)
+                .getPrincipals().get(0).getId());
+        assertEquals("Service", statements.get(0).getPrincipals().get(0)
+                .getProvider());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyTest.java
new file mode 100644
index 0000000000..934e145da5
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/auth/policy/PolicyTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.auth.policy;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+
+import com.amazonaws.auth.policy.Statement.Effect;
+
+import org.junit.Test;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Unit tests for constructing policy objects and serializing them to JSON.
+ */
+public class PolicyTest {
+
+    /**
+     * Tests that a policy correctly assigns unique statement IDs to any added
+     * statements without IDs yet.
+     */
+    @Test
+    public void testStatementIdAssignment() throws Exception {
+        Policy policy = new Policy("S3PolicyId1");
+        policy.withStatements(
+                new Statement(Effect.Allow).withId("0")
+                        .withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action1")),
+                new Statement(Effect.Allow).withId("1")
+                        .withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action1")), new Statement(
+                        Effect.Deny).withPrincipals(Principal.AllUsers)
+                        .withActions(new TestAction("action2")));
+
+        assertValidStatementIds(policy);
+    }
+
+    private class TestAction implements Action {
+        private final String name;
+
+        public TestAction(String name) {
+            this.name = name;
+        }
+
+        @Override
+        public String getActionName() {
+            return name;
+        }
+    }
+
+    /**
+     * Asserts that each statement in the specified policy has a unique ID
+     * assigned to it.
+     */
+    private void assertValidStatementIds(Policy policy) {
+        Set<String> statementIds = new HashSet<String>();
+        for (Statement statement : policy.getStatements()) {
+            assertNotNull(statement.getId());
+            assertFalse(statementIds.contains(statement.getId()));
+            statementIds.add(statement.getId());
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressEventTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressEventTest.java
new file mode 100644
index 0000000000..c6f895cede
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressEventTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+public class ProgressEventTest {
+
+    @Test
+    public void testTwoArgConstructor() {
+        ProgressEvent pe = new ProgressEvent(ProgressEvent.COMPLETED_EVENT_CODE, 100);
+        assertEquals(pe.getBytesTransferred(), 100);
+        assertEquals(pe.getEventCode(), ProgressEvent.COMPLETED_EVENT_CODE);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerCallbackExecutorTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerCallbackExecutorTest.java
new file mode 100644
index 0000000000..1313bc6303
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerCallbackExecutorTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+public class ProgressListenerCallbackExecutorTest {
+
+    @Test
+    public void testPlainConstructor() {
+        ProgressListenerCallbackExecutor exec = new ProgressListenerCallbackExecutor();
+        assertNull(exec.getListener());
+        assertNotNull(ProgressListenerCallbackExecutor.getExecutorService());
+        // Makesure it doesn't blow up
+        exec.progressChanged(new ProgressEvent(0));
+    }
+
+    @Test
+    public void testStaticProgressChangedWrapper() throws InterruptedException {
+        final List<ProgressEvent> capturedEvents = new ArrayList<ProgressEvent>();
+        ProgressListener pl = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                capturedEvents.add(progressEvent);
+            }
+
+        };
+        ProgressEvent toSend = new ProgressEvent(0);
+
+        ProgressListenerCallbackExecutor.progressChanged(pl, toSend);
+        ExecutorService service = ProgressListenerCallbackExecutor.getExecutorService();
+        service.shutdown();
+        service.awaitTermination(10, TimeUnit.SECONDS);
+        ProgressListenerCallbackExecutor.executor = ProgressListenerCallbackExecutor
+                .createNewExecutorService();
+        assertEquals(capturedEvents.size(), 1);
+        assertSame(capturedEvents.get(0), toSend);
+    }
+
+    @Test
+    public void testWrapListener() throws InterruptedException {
+        final List<ProgressEvent> capturedEvents = new ArrayList<ProgressEvent>();
+
+        final List<Long> threadIds = new ArrayList<Long>();
+        threadIds.add(Thread.currentThread().getId());
+        ProgressListener pl = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                threadIds.add(Thread.currentThread().getId());
+                capturedEvents.add(progressEvent);
+            }
+
+        };
+        ProgressEvent toSend = new ProgressEvent(0);
+
+        ProgressListenerCallbackExecutor.wrapListener(pl);
+        pl.progressChanged(toSend);
+
+        ExecutorService service = ProgressListenerCallbackExecutor.getExecutorService();
+        service.shutdown();
+        service.awaitTermination(10, TimeUnit.SECONDS);
+        ProgressListenerCallbackExecutor.executor = ProgressListenerCallbackExecutor
+                .createNewExecutorService();
+        assertEquals(threadIds.size(), 2);
+        assertEquals(capturedEvents.size(), 1);
+        assertSame(capturedEvents.get(0), toSend);
+    }
+
+    @Test
+    public void testStaticMethodsReturnNullWithNullListener() {
+        assertNull(ProgressListenerCallbackExecutor.progressChanged(null, null));
+        assertNull(ProgressListenerCallbackExecutor.wrapListener(null));
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerChainTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerChainTest.java
new file mode 100644
index 0000000000..2a0b8496f9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressListenerChainTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ProgressListenerChainTest {
+
+    @Test
+    public void testProgressListenerChainNoFilters() {
+
+        final ConcurrentHashMap<ProgressListener, ProgressEvent> listenerMap = new ConcurrentHashMap<ProgressListener, ProgressEvent>();
+
+        ProgressListener listener1 = new ProgressListener() {
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                if (listenerMap.get(this) != null) {
+                    fail("recieved unexpected event");
+                } else {
+                    listenerMap.put(this, progressEvent);
+                }
+
+            }
+        };
+
+        ProgressListener listener2 = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                if (listenerMap.get(this) != null) {
+                    fail("recieved unexpected event");
+                } else {
+                    listenerMap.put(this, progressEvent);
+                }
+            }
+
+        };
+
+        ProgressListenerChain chain = new ProgressListenerChain(listener1, listener2);
+        ProgressEvent event = new ProgressEvent(0);
+        chain.progressChanged(event);
+        assertSame(listenerMap.get(listener1), event);
+        assertSame(listenerMap.get(listener2), event);
+    }
+
+    @Test
+    public void testProgressListenerChainWithFilters() {
+
+        final ConcurrentHashMap<ProgressListener, ProgressEvent> listenerMap = new ConcurrentHashMap<ProgressListener, ProgressEvent>();
+
+        ProgressListener listener1 = new ProgressListener() {
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                if (listenerMap.get(this) != null) {
+                    fail("recieved unexpected event");
+                } else {
+                    listenerMap.put(this, progressEvent);
+                }
+
+            }
+        };
+
+        ProgressListener listener2 = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                if (listenerMap.get(this) != null) {
+                    fail("recieved unexpected event");
+                } else {
+                    listenerMap.put(this, progressEvent);
+                }
+            }
+
+        };
+
+        ProgressListenerChain chain = new ProgressListenerChain(
+                new ProgressListenerChain.ProgressEventFilter() {
+
+                    @Override
+                    public ProgressEvent filter(ProgressEvent progressEvent) {
+                        progressEvent.setBytesTransferred(100);
+                        return progressEvent;
+                    }
+
+                }, listener1, listener2);
+        ProgressEvent event = new ProgressEvent(0);
+        chain.progressChanged(event);
+        assertSame(listenerMap.get(listener1), event);
+        assertSame(listenerMap.get(listener2), event);
+        assertEquals(listenerMap.get(listener1).getBytesTransferred(), 100);
+        assertEquals(listenerMap.get(listener2).getBytesTransferred(), 100);
+    }
+
+    @Test
+    public void testAddAndRemoveListeners() {
+        ProgressListener listener1 = new ProgressListener() {
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                // NoOp for this test
+            }
+        };
+
+        ProgressListener listener2 = new ProgressListener() {
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+                // NoOp for this test
+            }
+        };
+
+        ProgressListenerChain chain = new ProgressListenerChain(listener1);
+        chain.addProgressListener(listener2);
+
+        List<ProgressListener> listeners = chain.getListeners();
+        assertEquals(listeners.size(), 2);
+
+        chain.removeProgressListener(listener1);
+        listeners = chain.getListeners();
+        assertEquals(listeners.size(), 1);
+        assertSame(listeners.get(0), listener2);
+
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressReportingInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressReportingInputStreamTest.java
new file mode 100644
index 0000000000..71bb4ed9dd
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/event/ProgressReportingInputStreamTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.event;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+public class ProgressReportingInputStreamTest {
+
+    private InputStream is;
+    private ProgressListenerCallbackExecutor callback;
+    private ProgressListener listener;
+    private File testFile;
+
+    // The minimum threshold for notifications is 1024*8 = 8192... 17408
+    // =1024*17
+    // for 2 notifications plus a 1024 buffer
+    private int numberOfBytesToWrite = 17408;
+
+    @Before
+    public void setup() throws IOException {
+        testFile = File.createTempFile("AndroidProgressReportingInputStreamTest", null);
+        FileOutputStream fos = new FileOutputStream(testFile);
+
+        byte[] dummyData = new byte[numberOfBytesToWrite];
+        Random rand = new Random();
+        rand.nextBytes(dummyData);
+
+        fos.write(dummyData);
+        fos.flush();
+        fos.close();
+
+        is = new FileInputStream(testFile);
+    }
+
+    @After
+    public void teardown() throws IOException {
+        assertTrue(testFile.delete());
+    }
+
+    @Test
+    public void testNotifiedOfAllBytesNoEventCompletedFired() throws InterruptedException,
+            IOException {
+        // By default we should not recieve a event completed event
+
+        final Map<Long, Integer> countMap = new HashMap<Long, Integer>();
+        ProgressListener listener = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+
+                synchronized (countMap) {
+                    if (countMap.size() >= 3) {
+                        fail("Unexpected progress event found: " + progressEvent);
+                    }
+                    Integer curr = countMap.get(progressEvent.getBytesTransferred());
+                    if (curr == null) {
+                        curr = 0;
+                    }
+                    countMap.put(progressEvent.getBytesTransferred(), ++curr);
+                    countMap.notifyAll();
+                }
+
+            }
+
+        };
+
+        ProgressListenerCallbackExecutor executor = new ProgressListenerCallbackExecutor(listener);
+
+        ProgressReportingInputStream testStream = null;
+        try {
+            testStream = new ProgressReportingInputStream(is, executor);
+            while (testStream.read() != -1) {
+            }
+        } finally {
+            testStream.close();
+        }
+
+        callback.executor.shutdown();
+        assertTrue(callback.executor.awaitTermination(10, TimeUnit.SECONDS));
+        callback.executor = callback.createNewExecutorService();
+
+        assertTrue(countMap.size() == 2);
+        assertEquals(countMap.get(new Long(1024)).intValue(), 1);
+        assertEquals(countMap.get(new Long(8192)).intValue(), 2);
+    }
+
+    @Test
+    public void testNotifiedOfAllByteWithEventCompletedFired() throws InterruptedException,
+            IOException {
+        final Map<Long, Integer> countMap = new HashMap<Long, Integer>();
+        ProgressListener listener = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+
+                synchronized (countMap) {
+                    if (countMap.size() >= 3) {
+                        fail("Unexpected progress event found: " + progressEvent);
+                    }
+                    if (progressEvent.getBytesTransferred() == 1024) {
+                        assertTrue(progressEvent.eventCode == ProgressEvent.COMPLETED_EVENT_CODE);
+                    }
+                    Integer curr = countMap.get(progressEvent.getBytesTransferred());
+                    if (curr == null) {
+                        curr = 0;
+                    }
+                    countMap.put(progressEvent.getBytesTransferred(), ++curr);
+                    countMap.notifyAll();
+                }
+
+            }
+
+        };
+
+        ProgressListenerCallbackExecutor executor = new ProgressListenerCallbackExecutor(listener);
+
+        ProgressReportingInputStream testStream = null;
+        try {
+            testStream = new ProgressReportingInputStream(is, executor);
+            testStream.setFireCompletedEvent(true);
+            while (testStream.read() != -1) {
+            }
+        } finally {
+            testStream.close();
+        }
+
+        callback.executor.shutdown();
+        assertTrue(callback.executor.awaitTermination(10, TimeUnit.SECONDS));
+        callback.executor = callback.createNewExecutorService();
+
+        assertTrue(countMap.size() == 2);
+        assertEquals(countMap.get(new Long(1024)).intValue(), 1);
+        assertEquals(countMap.get(new Long(8192)).intValue(), 2);
+    }
+
+    @Test
+    public void testNotifiedOfReset() throws InterruptedException,
+            IOException {
+        byte[] buff = new byte[numberOfBytesToWrite];
+        is.read(buff);
+        ByteArrayInputStream bais = new ByteArrayInputStream(buff);
+
+        final Map<Long, Integer> countMap = new HashMap<Long, Integer>();
+        ProgressListener listener = new ProgressListener() {
+
+            @Override
+            public void progressChanged(ProgressEvent progressEvent) {
+
+                synchronized (countMap) {
+                    if (countMap.size() >= 2) {
+                        fail("Unexpected progress event found: " + progressEvent);
+                    }
+                    if (progressEvent.getBytesTransferred() == 500) {
+                        assertTrue(progressEvent.getEventCode() == ProgressEvent.RESET_EVENT_CODE);
+                        Integer curr = countMap.get(progressEvent.getBytesTransferred());
+                        if (curr == null) {
+                            curr = 0;
+                        }
+
+                        countMap.put(progressEvent.getBytesTransferred(), ++curr);
+                        countMap.notifyAll();
+                    }
+                }
+
+            }
+
+        };
+
+        ProgressListenerCallbackExecutor executor = new ProgressListenerCallbackExecutor(listener);
+
+        ProgressReportingInputStream testStream = null;
+        try {
+            testStream = new ProgressReportingInputStream(bais, executor);
+            testStream.mark(600);
+            byte[] bytes = new byte[500];
+            testStream.read(bytes);
+            testStream.reset();
+        } finally {
+            testStream.close();
+        }
+
+        callback.executor.shutdown();
+        assertTrue(callback.executor.awaitTermination(10, TimeUnit.SECONDS));
+        callback.executor = callback.createNewExecutorService();
+
+        assertTrue(countMap.size() == 1);
+        assertEquals(countMap.get(new Long(500)).intValue(), 1);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/HandleChainFactoryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/HandleChainFactoryTest.java
new file mode 100644
index 0000000000..903edf8563
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/HandleChainFactoryTest.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonClientException;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.List;
+
+public class HandleChainFactoryTest {
+
+    @Test
+    public void testNewRequestHandler2Chain() throws IOException {
+
+        HandlerChainFactory factory = new HandlerChainFactory();
+        List<RequestHandler2> chain = factory
+                .newRequestHandler2Chain("/com/amazonaws/handlers/request.handler2s");
+
+        assertEquals(chain.size(), 1);
+        assertTrue(chain.get(0) instanceof MockRequestHandler2);
+    }
+
+    @Test
+    public void testNewRequestHandler1Chain() throws IOException {
+
+        HandlerChainFactory factory = new HandlerChainFactory();
+        List<RequestHandler2> chain = factory
+                .newRequestHandlerChain("/com/amazonaws/handlers/request.handlers");
+
+        assertEquals(chain.size(), 1);
+        assertTrue(chain.get(0) instanceof RequestHandler2Adaptor);
+        assertEquals(chain.get(0).hashCode(), 1);
+    }
+
+    @Test(expected = AmazonClientException.class)
+    public void testNewRequestHandlerChainFailsWhenRequest1AndRequest2HandlersMixed()
+            throws IOException {
+
+        HandlerChainFactory factory = new HandlerChainFactory();
+        List<RequestHandler2> chain = factory
+                .newRequestHandlerChain("/com/amazonaws/handlers/mixed.handlers");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler1.java b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler1.java
new file mode 100644
index 0000000000..7cc7ef3fb9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler1.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.util.TimingInfo;
+
+public class MockRequestHandler1 implements RequestHandler {
+
+    @Override
+    public void beforeRequest(Request<?> request) {
+    }
+
+    @Override
+    public void afterResponse(Request<?> request, Object response, TimingInfo timingInfo) {
+    }
+
+    @Override
+    public void afterError(Request<?> request, Exception e) {
+    }
+
+    @Override
+    public int hashCode() {
+        return 1;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler2.java b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler2.java
new file mode 100644
index 0000000000..a7fef6e2f9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/MockRequestHandler2.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import com.amazonaws.Request;
+import com.amazonaws.Response;
+
+public class MockRequestHandler2 extends RequestHandler2 {
+
+    @Override
+    public void beforeRequest(Request<?> request) {
+    }
+
+    @Override
+    public void afterResponse(Request<?> request, Response<?> response) {
+    }
+
+    @Override
+    public void afterError(Request<?> request, Response<?> response, Exception e) {
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/RequestHandler2AdaptorTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/RequestHandler2AdaptorTest.java
new file mode 100644
index 0000000000..b8875354e3
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/handlers/RequestHandler2AdaptorTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.handlers;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.Request;
+import com.amazonaws.util.TimingInfo;
+
+import org.junit.Test;
+
+public class RequestHandler2AdaptorTest {
+    final boolean[] bs = new boolean[3];
+
+    @Test
+    public void testDelegation() {
+        for (int i = 0; i < bs.length; i++) {
+            assertFalse(bs[i]);
+        }
+        RequestHandler old = createRequestHandler();
+        RequestHandler2 v2 = new RequestHandler2Adaptor(old);
+        v2.beforeRequest(null);
+        int i = 0;
+        assertTrue("beforeRequest is expected to have been invoked", bs[i++]);
+        bs[i - 1] = false; // reset the flag
+        v2.afterResponse(null, null);
+        assertTrue("beforeRequest is expected to have been invoked", bs[i++]);
+        bs[i - 1] = false; // reset the flag
+        v2.afterError(null, null, null);
+        assertTrue("beforeRequest is expected to have been invoked", bs[i++]);
+        bs[i - 1] = false; // reset the flag
+    }
+
+    @Test
+    public void sameOldButDiffAdapters() {
+        RequestHandler old = createRequestHandler();
+        RequestHandler2 new1 = new RequestHandler2Adaptor(old);
+        RequestHandler2 new2 = new RequestHandler2Adaptor(old);
+        assertNotSame(new1, new2);
+        assertEquals(new1, new2);
+        assertTrue(new1.hashCode() == new2.hashCode());
+    }
+
+    @Test
+    public void diffOldDiffAdapters() {
+        RequestHandler old1 = createRequestHandler();
+        RequestHandler old2 = createRequestHandler();
+        RequestHandler2 new1 = new RequestHandler2Adaptor(old1);
+        RequestHandler2 new2 = new RequestHandler2Adaptor(old2);
+        assertNotSame(new1, new2);
+        assertFalse(new1.equals(new2));
+        assertFalse(new1.hashCode() == new2.hashCode());
+    }
+
+    RequestHandler createRequestHandler() {
+        return new RequestHandler() {
+            @Override
+            public void beforeRequest(Request<?> request) {
+                bs[0] = true;
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Object response,
+                    TimingInfo timingInfo) {
+                bs[1] = true;
+            }
+
+            @Override
+            public void afterError(Request<?> request, Exception e) {
+                bs[2] = true;
+            }
+        };
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/AmazonHttpClientTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/AmazonHttpClientTest.java
new file mode 100644
index 0000000000..196e1253ed
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/AmazonHttpClientTest.java
@@ -0,0 +1,730 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+import com.amazonaws.RequestClientOptions;
+import com.amazonaws.Response;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.AnonymousAWSCredentials;
+import com.amazonaws.auth.Signer;
+import com.amazonaws.handlers.CredentialsRequestHandler;
+import com.amazonaws.handlers.RequestHandler2;
+import com.amazonaws.internal.CRC32MismatchException;
+import com.amazonaws.metrics.RequestMetricCollector;
+import com.amazonaws.util.AWSRequestMetrics;
+
+import org.easymock.Capture;
+import org.easymock.EasyMock;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class AmazonHttpClientTest {
+    private HttpClient httpClient;
+    private AmazonHttpClient client;
+
+    @Before
+    public void setUp() {
+        ClientConfiguration config = new ClientConfiguration();
+
+        httpClient = EasyMock.createMock(HttpClient.class);
+        EasyMock.reset(httpClient);
+
+        client = new AmazonHttpClient(config, httpClient);
+    }
+
+    @Test
+    public void testTemporaryRedirect() throws IOException, URISyntaxException {
+        HttpResponse redirectResponse = HttpResponse.builder().statusCode(307)
+                .header("Location", "https://www.redirect.com").build();
+        HttpResponse successfulResponse = HttpResponse.builder().statusCode(200).content(null)
+                .build();
+        final Request<?> request = new DefaultRequest<String>(new AmazonWebServiceRequest() {
+
+        }, "TestService");
+        request.setHttpMethod(HttpMethodName.GET);
+        request.setEndpoint(new URI("https://www.test.com"));
+        request.setResourcePath("/test/table");
+
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                AmazonWebServiceResponse<String> awsResponse = new AmazonWebServiceResponse<String>();
+                awsResponse.setResult("Result");
+                return awsResponse;
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+        };
+
+        ExecutionContext ec = EasyMock.createMock(ExecutionContext.class);
+
+        EasyMock.reset(httpClient, ec);
+
+        final List<Boolean> signerCalled = new ArrayList<Boolean>();
+
+        EasyMock.expect(ec.getAwsRequestMetrics()).andReturn(new AWSRequestMetrics()).anyTimes();
+        EasyMock.expect(ec.getContextUserAgent()).andReturn("TestUserAgent").anyTimes();
+        EasyMock.expect(ec.getCredentials()).andReturn(new AnonymousAWSCredentials());
+        EasyMock.expect(ec.getSignerByURI(EasyMock.anyObject(URI.class))).andReturn(new Signer() {
+
+            @Override
+            public void sign(Request<?> requestToSign, AWSCredentials credentials) {
+                assertSame(request, requestToSign);
+                assertTrue(credentials instanceof AnonymousAWSCredentials);
+                signerCalled.add(true);
+            }
+        });
+
+        EasyMock
+                .expect(httpClient.execute(EasyMock.<HttpRequest> anyObject()))
+                .andReturn(redirectResponse);
+
+        Capture<HttpRequest> capture = new Capture<HttpRequest>();
+
+        EasyMock.expect(httpClient.execute(EasyMock.capture(capture)))
+                .andReturn(successfulResponse);
+
+        EasyMock.replay(httpClient, ec);
+
+        Response<String> response = client.executeHelper(request, responseHandler, null, ec);
+
+        assertEquals(response.getAwsResponse(), "Result");
+        assertEquals(signerCalled.size(), 2);
+        assertTrue(signerCalled.get(0));
+        assertTrue(signerCalled.get(1));
+        assertEquals(capture.getValue().getUri().toString(), "https://www.redirect.com/");
+
+        EasyMock.verify(httpClient, ec);
+    }
+
+    @Test
+    public void testRetryIOExceptionFromExecute() throws IOException {
+        IOException exception = new IOException("BOOM");
+
+        EasyMock
+                .expect(httpClient.execute(EasyMock.<HttpRequest> anyObject()))
+                .andThrow(exception)
+                .times(4);
+
+        EasyMock.replay(httpClient);
+
+        ExecutionContext context = new ExecutionContext();
+
+        Request<?> request = new DefaultRequest<Object>("testsvc");
+        request.setEndpoint(java.net.URI.create(
+                "http://testsvc.region.amazonaws.com"));
+        request.addHeader(HttpHeader.CONTENT_LENGTH, "0");
+        request.setContent(new ByteArrayInputStream(new byte[0]));
+
+        try {
+
+            client.execute(request, null, null, context);
+            Assert.fail("No exception when request repeatedly fails!");
+
+        } catch (AmazonClientException e) {
+            Assert.assertSame(exception, e.getCause());
+        }
+
+        // Verify that we called execute 4 times.
+        EasyMock.verify(httpClient);
+    }
+
+    @Test
+    public void testRetryIOExceptionFromHandler() throws Exception {
+        final IOException exception = new IOException("BOOM");
+
+        HttpResponseHandler<AmazonWebServiceResponse<Object>> handler =
+                EasyMock.createMock(HttpResponseHandler.class);
+
+        EasyMock
+                .expect(handler.needsConnectionLeftOpen())
+                .andReturn(false)
+                .anyTimes();
+
+        EasyMock
+                .expect(handler.handle(EasyMock.<HttpResponse> anyObject()))
+                .andThrow(exception)
+                .times(4);
+
+        HttpResponse response = HttpResponse.builder()
+                .content(new ByteArrayInputStream(new byte[0]))
+                .statusCode(200)
+                .statusText("OK")
+                .build();
+
+        EasyMock
+                .expect(httpClient.execute(EasyMock.<HttpRequest> anyObject()))
+                .andReturn(response)
+                .times(4);
+
+        EasyMock.replay(handler, httpClient);
+
+        ExecutionContext context = new ExecutionContext();
+
+        Request<?> request = new DefaultRequest<Object>("testsvc");
+        request.setEndpoint(java.net.URI.create(
+                "http://testsvc.region.amazonaws.com"));
+        request.addHeader(HttpHeader.CONTENT_LENGTH, "0");
+        request.setContent(new java.io.ByteArrayInputStream(new byte[0]));
+
+        try {
+
+            client.execute(request, handler, null, context);
+            Assert.fail("No exception when request repeatedly fails!");
+
+        } catch (AmazonClientException e) {
+            Assert.assertSame(exception, e.getCause());
+        }
+
+        // Verify that we called execute 4 times.
+        EasyMock.verify(httpClient);
+    }
+
+    @Test
+    public void testHandleResponse() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(200).build();
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                AmazonWebServiceResponse<String> awsResponse = new AmazonWebServiceResponse<String>();
+                awsResponse.setResult("Result");
+                return awsResponse;
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+
+        assertEquals("Result", client.handleResponse(request, responseHandler, httpResponse,
+                new ExecutionContext()));
+    }
+
+    @Test(expected = RuntimeException.class)
+    public void testHandleResponseWithNullResult() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(200).build();
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                return null;
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+
+        client.handleResponse(request, responseHandler, httpResponse,
+                new ExecutionContext());
+    }
+
+    @Test(expected = CRC32MismatchException.class)
+    public void testHandleResponseThrowsCRC32MisMatch() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(200).build();
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new CRC32MismatchException("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+
+        client.handleResponse(request, responseHandler, httpResponse,
+                new ExecutionContext());
+    }
+
+    @Test(expected = IOException.class)
+    public void testHandleResponseThrowsIOException() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(200).build();
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new IOException("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+
+        client.handleResponse(request, responseHandler, httpResponse,
+                new ExecutionContext());
+    }
+
+    @Test(expected = Exception.class)
+    public void testHandleResponseThrowsGenericException() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(200).build();
+        HttpResponseHandler<AmazonWebServiceResponse<String>> responseHandler = new HttpResponseHandler<AmazonWebServiceResponse<String>>() {
+
+            @Override
+            public AmazonWebServiceResponse<String> handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new Exception("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+
+        client.handleResponse(request, responseHandler, httpResponse,
+                new ExecutionContext());
+    }
+
+    @Test
+    public void testHandleErrorResponse() throws IOException {
+
+        final Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(400).build();
+        HttpResponseHandler<AmazonServiceException> errorResponseHandler = new HttpResponseHandler<AmazonServiceException>() {
+
+            @Override
+            public AmazonServiceException handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                AmazonServiceException ase = new AmazonServiceException("Test");
+                ase.setErrorCode("TestError");
+                ase.setErrorType(ErrorType.Service);
+                ase.setServiceName(request.getServiceName());
+                ase.setStatusCode(response.getStatusCode());
+                return ase;
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+        AmazonServiceException e = client.handleErrorResponse(request, errorResponseHandler,
+                httpResponse);
+        assertEquals(e.getStatusCode(), 400);
+        assertEquals(e.getErrorCode(), "TestError");
+        assertEquals(e.getErrorType(), ErrorType.Service);
+        assertEquals(e.getServiceName(), "ServiceName");
+    }
+
+    @Test
+    public void testHandleErrorResponseHandlerFailsWith413() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(413).build();
+        HttpResponseHandler<AmazonServiceException> errorResponseHandler = new HttpResponseHandler<AmazonServiceException>() {
+
+            @Override
+            public AmazonServiceException handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new Exception("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+        AmazonServiceException e = client.handleErrorResponse(request, errorResponseHandler,
+                httpResponse);
+        assertEquals(e.getStatusCode(), 413);
+        assertEquals(e.getErrorCode(), "Request entity too large");
+        assertEquals(e.getErrorType(), ErrorType.Client);
+        assertEquals(e.getServiceName(), "ServiceName");
+    }
+
+    @Test
+    public void testHandleErrorResponseHandlerFailsWith503() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder()
+                .statusText("Service unavailable")
+                .statusCode(503).build();
+        HttpResponseHandler<AmazonServiceException> errorResponseHandler = new HttpResponseHandler<AmazonServiceException>() {
+
+            @Override
+            public AmazonServiceException handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new Exception("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+        AmazonServiceException e = client.handleErrorResponse(request, errorResponseHandler,
+                httpResponse);
+        assertEquals(e.getStatusCode(), 503);
+        assertEquals(e.getErrorCode(), "Service unavailable");
+        assertEquals(e.getErrorType(), ErrorType.Service);
+        assertEquals(e.getServiceName(), "ServiceName");
+    }
+
+    @Test(expected = AmazonClientException.class)
+    public void testHandleErrorResponseHandlerFailsWithUnknownException() throws IOException {
+
+        Request<?> request = new DefaultRequest<String>("ServiceName");
+        final HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(400).build();
+        HttpResponseHandler<AmazonServiceException> errorResponseHandler = new HttpResponseHandler<AmazonServiceException>() {
+
+            @Override
+            public AmazonServiceException handle(HttpResponse response) throws Exception {
+                assertSame(response, httpResponse);
+                throw new Exception("test");
+            }
+
+            @Override
+            public boolean needsConnectionLeftOpen() {
+                return false;
+            }
+
+        };
+        AmazonServiceException e = client.handleErrorResponse(request, errorResponseHandler,
+                httpResponse);
+    }
+
+    @Test
+    public void testClockskewOffset() {
+        HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .header("Date", "Sat, 06 Nov 2004 08:49:37 GMT")
+                .statusCode(400).build();
+        AmazonServiceException ase = new AmazonServiceException("ClockSkew");
+
+        // assert date is > 10 years
+        int offset = client.parseClockSkewOffset(httpResponse, ase);
+        assertTrue(offset > 315400000);
+    }
+
+    @Test
+    public void testClockskewOffsetWithDateInBodyOfException() {
+        HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .statusCode(400).build();
+        AmazonServiceException ase = new AmazonServiceException("(20041106T084937Z - 15)");
+
+        // assert date is > 10 years
+        int offset = client.parseClockSkewOffset(httpResponse, ase);
+        assertTrue(offset > 315400000);
+    }
+
+    @Test
+    public void testClockskewOffsetWithBogusDateAsssumesOffsetIsZero() {
+        HttpResponse httpResponse = new HttpResponse.Builder().statusText("TestResponse")
+                .header("Date", "Sat, 064 Jann 20044 08:49:37 GMT")
+                .statusCode(400).build();
+
+        AmazonServiceException ase = new AmazonServiceException("ClockSkew");
+        // assert date is > 10 years
+        int offset = client.parseClockSkewOffset(httpResponse, ase);
+        assertEquals(offset, 0);
+    }
+
+    @Test
+    public void testRequestHander2s() {
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        final List<Object> calls = new ArrayList<Object>();
+        List<RequestHandler2> handlers = new ArrayList<RequestHandler2>();
+
+        RequestHandler2 defaultHandler = new RequestHandler2() {
+
+            @Override
+            public void beforeRequest(Request<?> request) {
+                assertSame(testRequest, request);
+                calls.add(this);
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Response<?> response) {
+            }
+
+            @Override
+            public void afterError(Request<?> request, Response<?> response, Exception e) {
+            }
+
+        };
+        RequestHandler2 credentialHandler = new CredentialsRequestHandler() {
+
+            @Override
+            public void beforeRequest(Request<?> request) {
+                assertSame(testRequest, request);
+                calls.add(this);
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Response<?> response) {
+            }
+
+            @Override
+            public void afterError(Request<?> request, Response<?> response, Exception e) {
+            }
+
+        };
+
+        handlers.add(defaultHandler);
+        handlers.add(credentialHandler);
+        ExecutionContext ec = new ExecutionContext(handlers, false, null);
+        client.requestHandler2s(testRequest, ec);
+        assertEquals(calls.size(), 2);
+        assertTrue(calls.contains(defaultHandler));
+        assertTrue(calls.contains(credentialHandler));
+    }
+
+    @Test
+    public void testAfterError() {
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        final Response<?> testResponse = new Response<String>("test",
+                new HttpResponse.Builder().build());
+        final List<Object> calls = new ArrayList<Object>();
+        List<RequestHandler2> handlers = new ArrayList<RequestHandler2>();
+        final AmazonClientException ace = new AmazonClientException("Test exception");
+
+        RequestHandler2 handler = new RequestHandler2() {
+
+            @Override
+            public void beforeRequest(Request<?> request) {
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Response<?> response) {
+            }
+
+            @Override
+            public void afterError(Request<?> request, Response<?> response, Exception e) {
+                assertSame(testRequest, request);
+                assertSame(testResponse, response);
+                assertSame(e, ace);
+                calls.add(this);
+            }
+
+        };
+
+        handlers.add(handler);
+        client.afterError(testRequest, testResponse, handlers, ace);
+        assertEquals(calls.size(), 1);
+        assertTrue(calls.contains(handler));
+    }
+
+    @Test
+    public void testAfterResponse() {
+
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        final Response<?> testResponse = new Response<String>("test",
+                new HttpResponse.Builder().build());
+        final List<Object> calls = new ArrayList<Object>();
+        List<RequestHandler2> handlers = new ArrayList<RequestHandler2>();
+
+        RequestHandler2 handler = new RequestHandler2() {
+
+            @Override
+            public void beforeRequest(Request<?> request) {
+            }
+
+            @Override
+            public void afterResponse(Request<?> request, Response<?> response) {
+                assertSame(testRequest, request);
+                assertSame(testResponse, response);
+                calls.add(this);
+            }
+
+            @Override
+            public void afterError(Request<?> request, Response<?> response, Exception e) {
+            }
+
+        };
+
+        handlers.add(handler);
+        client.afterResponse(testRequest, handlers, testResponse, null);
+        assertEquals(calls.size(), 1);
+        assertTrue(calls.contains(handler));
+    }
+
+    @Test
+    public void testDeprecatedConstructors() {
+        ClientConfiguration conf = new ClientConfiguration();
+        RequestMetricCollector rmc = RequestMetricCollector.NONE;
+        AmazonHttpClient defaultToUrlClient = new AmazonHttpClient(conf, rmc);
+        assertTrue(defaultToUrlClient.httpClient instanceof UrlHttpClient);
+        assertSame(defaultToUrlClient.config, conf);
+
+        UrlHttpClient urlClient = new UrlHttpClient(conf);
+        AmazonHttpClient deprecatedSpecifiedConstrucotr = new AmazonHttpClient(conf, urlClient, rmc);
+        assertSame(deprecatedSpecifiedConstrucotr.config, conf);
+        assertSame(deprecatedSpecifiedConstrucotr.httpClient, urlClient);
+    }
+
+    @Test
+    public void testResetRequestAfterErrorWithNullContent() {
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        testRequest.setContent(null);
+        Exception cause = new Exception();
+
+        // Should be no-op
+        client.resetRequestAfterError(testRequest, cause);
+    }
+
+    @Test(expected = AmazonClientException.class)
+    public void testResetRequestAfterErrorWithNonRepeatableContent() {
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        testRequest.setContent(new InputStream() {
+
+            @Override
+            public boolean markSupported() {
+                return false;
+            }
+
+            @Override
+            public int read() throws IOException {
+                return 0;
+            }
+        });
+        Exception cause = new Exception();
+
+        // Should be no-op
+        client.resetRequestAfterError(testRequest, cause);
+    }
+
+    @Test(expected = AmazonClientException.class)
+    public void testResetRequestAfterErrorWithNonResetableContent() {
+        final Request<?> testRequest = new DefaultRequest<String>("test");
+        testRequest.setContent(new InputStream() {
+
+            @Override
+            public void reset() {
+                throw new RuntimeException("CannotReset");
+            }
+
+            @Override
+            public int read() throws IOException {
+                return 0;
+            }
+        });
+        Exception cause = new Exception();
+
+        // Should be no-op
+        client.resetRequestAfterError(testRequest, cause);
+    }
+
+    @Test
+    public void testCreateUserAgent() {
+        String existingUA = "Existing";
+        String additionalUA = "Additional";
+        String ua = AmazonHttpClient.createUserAgentString(existingUA, additionalUA);
+        assertEquals(ua, (existingUA + " " + additionalUA));
+    }
+
+    @Test
+    public void testCreateUserAgentWithDuplicateAddition() {
+        String existingUA = "Existing";
+        String additionalUA = "Existing";
+        String ua = AmazonHttpClient.createUserAgentString(existingUA, additionalUA);
+        assertEquals(ua, (existingUA));
+    }
+
+    @Test
+    public void testSetUserAgentDefault() {
+        ClientConfiguration config = new ClientConfiguration();
+        client = new AmazonHttpClient(config);
+
+        final Request<?> request = new DefaultRequest<String>("ServiceName");
+        client.setUserAgent(request);
+        String userAgent = request.getHeaders().get("User-Agent");
+        assertEquals("same user agent", ClientConfiguration.DEFAULT_USER_AGENT, userAgent);
+    }
+
+    @Test
+    public void testSetUserAgentCustom() {
+        String versionInfoUserAgent = ClientConfiguration.DEFAULT_USER_AGENT;
+        String customUserAgent = "custom_user_agent";
+        String requestUserAgent = "request_user_agent";
+        String targetUserAgent = versionInfoUserAgent + " " + requestUserAgent + " "
+                + customUserAgent;
+
+        AmazonWebServiceRequest originalRequest = new AmazonWebServiceRequest() {
+        };
+        RequestClientOptions opts = originalRequest.getRequestClientOptions();
+        opts.appendUserAgent("request_user_agent");
+        ClientConfiguration config = new ClientConfiguration();
+        config.setUserAgent("custom_user_agent");
+        client = new AmazonHttpClient(config);
+
+        final Request<?> request = new DefaultRequest<String>(originalRequest, "ServiceName");
+        client.setUserAgent(request);
+        String userAgent = request.getHeaders().get("User-Agent");
+        assertEquals("same user agent", targetUserAgent, userAgent);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/DefaultErrorResponseHandlerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/DefaultErrorResponseHandlerTest.java
new file mode 100644
index 0000000000..060601b9ca
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/DefaultErrorResponseHandlerTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+import org.w3c.dom.Node;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+public class DefaultErrorResponseHandlerTest {
+
+    @Test
+    public void testDefaultErrorResponseHandler() throws Exception {
+        List<Unmarshaller<AmazonServiceException, Node>> unmarshallerList = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();
+        String xmlResponse = "<error>TestError</error>";
+        HttpResponse errorResponse = new HttpResponse.Builder()
+                .statusCode(400)
+                .statusText("Error")
+                .content(new ByteArrayInputStream(xmlResponse.getBytes(StringUtils.UTF8)))
+                .build();
+
+        final List<Boolean> called = new ArrayList<Boolean>();
+
+        Unmarshaller<AmazonServiceException, Node> incorrectUnmarshaller = new Unmarshaller<AmazonServiceException, Node>() {
+            @Override
+            public AmazonServiceException unmarshall(Node in) throws Exception {
+                called.add(true);
+                return null;
+            }
+        };
+
+        Unmarshaller<AmazonServiceException, Node> correctUnmarshaller = new Unmarshaller<AmazonServiceException, Node>() {
+            @Override
+            public AmazonServiceException unmarshall(Node in) throws Exception {
+                called.add(true);
+                in = in.getFirstChild();
+                assertEquals(in.getNodeName(), "error");
+                assertEquals(
+                        in.getTextContent(), "TestError");
+                AmazonServiceException ase = new AmazonServiceException("TestAse");
+                return ase;
+            }
+        };
+
+        unmarshallerList.add(incorrectUnmarshaller);
+        unmarshallerList.add(correctUnmarshaller);
+
+        DefaultErrorResponseHandler handler = new DefaultErrorResponseHandler(unmarshallerList);
+        AmazonServiceException e = handler.handle(errorResponse);
+        assertEquals(e.getErrorMessage(), "TestAse");
+        assertEquals(e.getStatusCode(), 400);
+        assertEquals(called.size(), 2);
+        assertTrue(called.get(0));
+        assertTrue(called.get(1));
+    }
+
+    @Test(expected = AmazonClientException.class)
+    public void testDefaultErrorResponseHandlerNoUsefulUnmarshallers() throws Exception {
+        List<Unmarshaller<AmazonServiceException, Node>> unmarshallerList = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();
+        String xmlResponse = "<error>TestError</error>";
+        HttpResponse errorResponse = new HttpResponse.Builder()
+                .statusCode(400)
+                .statusText("Error")
+                .content(new ByteArrayInputStream(xmlResponse.getBytes(StringUtils.UTF8)))
+                .build();
+
+        final List<Boolean> called = new ArrayList<Boolean>();
+
+        Unmarshaller<AmazonServiceException, Node> incorrectUnmarshaller = new Unmarshaller<AmazonServiceException, Node>() {
+            @Override
+            public AmazonServiceException unmarshall(Node in) throws Exception {
+                called.add(true);
+                return null;
+            }
+        };
+
+        unmarshallerList.add(incorrectUnmarshaller);
+
+        DefaultErrorResponseHandler handler = new DefaultErrorResponseHandler(unmarshallerList);
+        try {
+            handler.handle(errorResponse);
+        } finally {
+            assertEquals(called.size(), 1);
+            assertTrue(called.get(0));
+        }
+    }
+
+    @Test
+    public void testDefaultErrorResponseHandlerCannotGetContent() throws Exception {
+        List<Unmarshaller<AmazonServiceException, Node>> unmarshallerList = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();
+        HttpResponse errorResponse = new HttpResponse.Builder()
+                .statusCode(400)
+                .statusText("Error")
+                .content(new InputStream() {
+
+                    @Override
+                    public int read() throws IOException {
+                        throw new IOException("Test IOException");
+                    }
+
+                })
+                .build();
+
+        DefaultErrorResponseHandler handler = new DefaultErrorResponseHandler(unmarshallerList);
+        AmazonServiceException e = handler.handle(errorResponse);
+        assertEquals(e.getErrorCode(),
+                errorResponse.getStatusCode() + " " + errorResponse.getStatusText());
+        assertEquals(e.getStatusCode(), 400);
+        assertEquals(e.getErrorType(), ErrorType.Unknown);
+    }
+
+    @Test
+    public void testDefaultErrorResponseHandlerDoesNotNeedConnectionLeftOpen() throws Exception {
+        DefaultErrorResponseHandler handler = new DefaultErrorResponseHandler(null);
+        assertFalse(handler.needsConnectionLeftOpen());
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestFactoryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestFactoryTest.java
new file mode 100644
index 0000000000..b2939c877f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestFactoryTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.net.URI;
+import java.util.Map;
+
+public class HttpRequestFactoryTest {
+
+    private HttpRequestFactory factory;
+    private Request<?> request;
+    private ClientConfiguration clientConfiguration;
+    private ExecutionContext context;
+
+    @Before
+    public void setup() {
+        factory = new HttpRequestFactory();
+        request = new DefaultRequest<Object>("dummy");
+        request.setEndpoint(URI.create("https://s3.amazonaws.com"));
+        clientConfiguration = new ClientConfiguration();
+        context = new ExecutionContext();
+    }
+
+    @Test
+    public void testContextUserAgent() {
+        final String contextUserAgent = "context_user_agent";
+        context.setContextUserAgent(contextUserAgent);
+        final HttpRequest httpRequest = factory.createHttpRequest(request, clientConfiguration, context);
+        final String userAgent = httpRequest.getHeaders().get(HttpHeader.USER_AGENT);
+        assertTrue("context user agent", userAgent.endsWith(contextUserAgent));
+    }
+
+    @Test
+    public void testHeaders() {
+        final HttpRequest httpRequest = factory.createHttpRequest(request, clientConfiguration, context);
+        final Map<String, String> headers = httpRequest.getHeaders();
+        // assert basic headers
+        assertNotNull(headers.get(HttpHeader.HOST));
+        assertNotNull(headers.get(HttpHeader.CONTENT_TYPE));
+    }
+
+    @Test
+    public void testEnableCompression() {
+        clientConfiguration.withEnableGzip(true);
+        final HttpRequest httpRequest = factory.createHttpRequest(request, clientConfiguration, context);
+        final Map<String, String> headers = httpRequest.getHeaders();
+        assertEquals("accept encoding is gzip", "gzip", headers.get("Accept-Encoding"));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestTest.java
new file mode 100644
index 0000000000..e22983903a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpRequestTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+
+public class HttpRequestTest {
+
+    private String method;
+    private URI uri;
+    private Map<String, String> headers;
+    private InputStream content;
+    private HttpRequest request;
+
+    @Before
+    public void setup() {
+        method = "GET";
+        uri = URI.create("http://amazon.com");
+        headers = new HashMap<String, String>();
+        content = new ByteArrayInputStream("content".getBytes(StringUtils.UTF8));
+    }
+
+    @Test
+    public void testSimpleConstructor() {
+        request = new HttpRequest(method, uri);
+        assertEquals("method", method, request.getMethod());
+        assertEquals("url", uri, request.getUri());
+        assertNull("no content", request.getContent());
+        assertTrue("empty header", request.getHeaders().isEmpty());
+    }
+
+    @Test
+    public void testGetters() {
+        for (int i = 0; i < 10; i++) {
+            headers.put("key" + i, "value" + i);
+        }
+        request = new HttpRequest(method, uri, headers, content);
+        assertEquals("method", method, request.getMethod());
+        assertEquals("url", uri, request.getUri());
+        assertEquals("content", content, request.getContent());
+        assertTrue("has headers", request.getHeaders().size() == 10);
+    }
+
+    @Test
+    public void testContentLength() {
+        long contentLength = 100;
+        headers.put(HttpHeader.CONTENT_LENGTH, String.valueOf(contentLength));
+        HttpRequest request = new HttpRequest(method, uri, headers, null);
+        assertTrue("content length", request.getContentLength() == contentLength);
+    }
+
+    @Test
+    public void testNoContentLength() {
+        // content length isn't set in the header
+        request = new HttpRequest(method, uri, headers, content);
+        assertTrue("content length", request.getContentLength() == 0);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void testUnmodifierableHeaders() {
+        request = new HttpRequest(method, uri);
+        request.getHeaders().put("key", "value");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpResponseTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpResponseTest.java
new file mode 100644
index 0000000000..078075b527
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/HttpResponseTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.util.IOUtils;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class HttpResponseTest {
+
+    private HttpResponse response;
+    private HttpResponse.Builder builder;
+    private String statusText;
+    private int statusCode;
+    private InputStream content;
+
+    @Before
+    public void setup() {
+        statusText = "OK";
+        statusCode = 200;
+        content = new ByteArrayInputStream("content".getBytes(StringUtils.UTF8));
+    }
+
+    @Test
+    public void testBuilder() throws Exception {
+        builder = HttpResponse.builder()
+                .statusCode(statusCode)
+                .statusText(statusText)
+                .content(content);
+        for (int i = 0; i < 10; i++) {
+            builder.header("key" + i, "value" + i);
+        }
+        response = builder.build();
+        assertEquals("status text", statusText, response.getStatusText());
+        assertTrue("status code", statusCode == response.getStatusCode());
+        assertTrue("has headers", 10 == response.getHeaders().size());
+        assertEquals("content", content, response.getContent());
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void testUnmodifierableHeaders() {
+        builder = HttpResponse.builder()
+                .statusCode(statusCode)
+                .statusText(statusText)
+                .content(content);
+        response = builder.build();
+        response.getHeaders().put("key", "value");
+    }
+
+    @Test
+    public void testContentEncodingGZIP() throws Exception {
+        String str = "content to be zipped";
+        InputStream zippedContent = getGzippedInputStream(str);
+        builder = HttpResponse.builder()
+                .header("Content-Encoding", "gzip")
+                .content(zippedContent);
+        response = builder.build();
+        InputStream unzippedContent = response.getContent();
+        assertTrue(unzippedContent instanceof GZIPInputStream);
+        String result = IOUtils.toString(unzippedContent);
+        assertEquals("unzip correctly", str, result);
+    }
+
+    @Test
+    public void testContentEncodingIdentity() throws Exception {
+        builder = HttpResponse.builder()
+                .header("Content-Encoding", "identity")
+                .content(content);
+        response = builder.build();
+        assertFalse("Not gzip", response.getContent() instanceof GZIPInputStream);
+        assertEquals("same content", "content", IOUtils.toString(response.getContent()));
+    }
+
+    @Test
+    public void testContentEncodingGZIPRaw() throws Exception {
+        String str = "content to be zipped";
+        InputStream zippedContent = getGzippedInputStream(str);
+        builder = HttpResponse.builder()
+                .header("Content-Encoding", "gzip")
+                .content(zippedContent);
+        response = builder.build();
+        InputStream rawContent = response.getRawContent();
+        assertFalse("Not gzip", rawContent instanceof GZIPInputStream);
+        GZIPInputStream gis = new GZIPInputStream(rawContent);
+        String result = IOUtils.toString(gis);
+        assertEquals("unzip correctly", str, result);
+    }
+
+    private InputStream getGzippedInputStream(String str) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        GZIPOutputStream gos = new GZIPOutputStream(baos);
+        gos.write(str.getBytes(StringUtils.UTF8));
+        gos.finish();
+        byte[] content = baos.toByteArray();
+        gos.close();
+
+        return new ByteArrayInputStream(content);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/IdleConnectionReaperTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/IdleConnectionReaperTest.java
new file mode 100644
index 0000000000..fb6b415ec0
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/IdleConnectionReaperTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.ClientConnectionRequest;
+import org.apache.http.conn.ManagedClientConnection;
+import org.apache.http.conn.routing.HttpRoute;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+
+public class IdleConnectionReaperTest {
+    @Before
+    public void init() {
+        IdleConnectionReaper.shutdown();
+    }
+
+    @Test
+    public void forceShutdown() throws Exception {
+        // final int threadCount = getThreadCount();
+        assertEquals(0, IdleConnectionReaper.size());
+        for (int i = 0; i < 3; i++) {
+            assertTrue(IdleConnectionReaper
+                    .registerConnectionManager(new TestClientConnectionManager()));
+            assertEquals(1, IdleConnectionReaper.size());
+            // Thread.sleep(100);
+            // assertTrue(getThreadCount() > threadCount);
+            assertTrue(IdleConnectionReaper.shutdown());
+            assertEquals(0, IdleConnectionReaper.size());
+            // Thread.sleep(100);
+            // assertTrue(getThreadCount() == threadCount);
+            assertFalse(IdleConnectionReaper.shutdown());
+        }
+        // assertEquals(threadCount, getThreadCount());
+    }
+
+    @Test
+    public void autoShutdown() throws Exception {
+        // final int threadCount = getThreadCount();
+        assertEquals(0, IdleConnectionReaper.size());
+        for (int i = 0; i < 3; i++) {
+            ClientConnectionManager m = new TestClientConnectionManager();
+            ClientConnectionManager m2 = new TestClientConnectionManager();
+            assertTrue(IdleConnectionReaper
+                    .registerConnectionManager(m));
+            assertEquals(1, IdleConnectionReaper.size());
+            // Thread.sleep(100);
+            // assertTrue(getThreadCount() > threadCount);
+            assertTrue(IdleConnectionReaper
+                    .registerConnectionManager(m2));
+            assertEquals(2, IdleConnectionReaper.size());
+            assertTrue(IdleConnectionReaper.removeConnectionManager(m));
+            assertEquals(1, IdleConnectionReaper.size());
+            // Thread.sleep(100);
+            // assertTrue(getThreadCount() > threadCount);
+            assertTrue(IdleConnectionReaper.removeConnectionManager(m2));
+            assertEquals(0, IdleConnectionReaper.size());
+            // Thread.sleep(100);
+            // assertEquals(threadCount, getThreadCount());
+            assertFalse(IdleConnectionReaper.shutdown());
+        }
+        // assertEquals(threadCount, getThreadCount());
+    }
+
+    // This method doesn't seem to work on desktop
+    // public int getThreadCount() {
+    // ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
+    // return threadMXBean.getThreadCount();
+    // }
+
+    private static class TestClientConnectionManager implements ClientConnectionManager {
+        @Override
+        public void shutdown() {
+        }
+
+        @Override
+        public ClientConnectionRequest requestConnection(HttpRoute route, Object state) {
+            return null;
+        }
+
+        @Override
+        public void releaseConnection(ManagedClientConnection conn, long validDuration,
+                TimeUnit timeUnit) {
+        }
+
+        @Override
+        public SchemeRegistry getSchemeRegistry() {
+            return null;
+        }
+
+        @Override
+        public void closeIdleConnections(long idletime, TimeUnit tunit) {
+        }
+
+        @Override
+        public void closeExpiredConnections() {
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonErrorResponseHandlerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonErrorResponseHandlerTest.java
new file mode 100644
index 0000000000..72f23b113c
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonErrorResponseHandlerTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class JsonErrorResponseHandlerTest {
+
+    private JsonErrorResponseHandler handler;
+    private HttpResponse response;
+
+    @Before
+    public void setup() {
+        handler = new JsonErrorResponseHandler(Arrays.asList(new JsonErrorUnmarshaller()));
+    }
+
+    @Test
+    public void testRestJsonErrorResponse() throws Exception {
+        String body = "{\"message\":\"Clock is skewed\"}";
+        ByteArrayInputStream content = new ByteArrayInputStream(body.getBytes(StringUtils.UTF8));
+        response = HttpResponse.builder()
+                .content(content)
+                .statusCode(403)
+                .header("x-amzn-ErrorType", "InvalidSignatureException")
+                .build();
+        AmazonServiceException ase = handler.handle(response);
+        assertEquals(ase.getErrorCode(), "InvalidSignatureException");
+    }
+
+    @Test
+    public void testJsonErrorResponse() throws Exception {
+        String body = "{\"__type\":\"InvalidSignatureException\",\"message\":\"Clock is skewed\"}";
+        ByteArrayInputStream content = new ByteArrayInputStream(body.getBytes(StringUtils.UTF8));
+        response = HttpResponse.builder()
+                .content(content)
+                .statusCode(403)
+                .build();
+        AmazonServiceException ase = handler.handle(response);
+        assertEquals(ase.getErrorCode(), "InvalidSignatureException");
+    }
+
+    @Test
+    public void testJsonErrorResponseReturnsNullIfExceptionIsNull() throws Exception {
+        List<JsonErrorUnmarshaller> exceptionUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
+        exceptionUnmarshallers.add(new JsonErrorUnmarshaller() {
+
+            @Override
+            public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+                return null;
+            }
+
+        });
+        handler = new JsonErrorResponseHandler(exceptionUnmarshallers);
+        response = HttpResponse.builder()
+                .statusCode(403)
+                .content(new ByteArrayInputStream("{}".getBytes(StringUtils.UTF8)))
+                .build();
+        assertNull(handler.handle(response));
+    }
+
+    @Test
+    public void testJsonErrorResponseReturnsServiceErrorTypeIfErrorStatus5XX() throws Exception {
+        List<JsonErrorUnmarshaller> exceptionUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
+        exceptionUnmarshallers.add(new JsonErrorUnmarshaller() {
+
+            @Override
+            public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+                return new AmazonServiceException("TestException");
+            }
+
+        });
+        handler = new JsonErrorResponseHandler(exceptionUnmarshallers);
+        response = HttpResponse.builder()
+                .statusCode(500)
+                .content(new ByteArrayInputStream("{}".getBytes(StringUtils.UTF8)))
+                .build();
+        AmazonServiceException returnedException = handler.handle(response);
+        assertEquals(returnedException.getErrorType(), ErrorType.Service);
+    }
+
+    @Test
+    public void testJsonErrorResponseReturnsXAmzRequestId() throws Exception {
+        List<JsonErrorUnmarshaller> exceptionUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
+        exceptionUnmarshallers.add(new JsonErrorUnmarshaller() {
+
+            @Override
+            public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+                return new AmazonServiceException("TestException");
+            }
+
+        });
+        handler = new JsonErrorResponseHandler(exceptionUnmarshallers);
+        response = HttpResponse.builder()
+                .statusCode(500)
+                .header("X-Amzn-RequestId", "55")
+                .content(new ByteArrayInputStream("{}".getBytes(StringUtils.UTF8)))
+                .build();
+        AmazonServiceException returnedException = handler.handle(response);
+        assertEquals(returnedException.getRequestId(), "55");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonResponseHandlerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonResponseHandlerTest.java
new file mode 100644
index 0000000000..fef82ba7a4
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/JsonResponseHandlerTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.transform.JsonUnmarshallerContext;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.zip.CRC32;
+
+public class JsonResponseHandlerTest {
+
+    @Test
+    public void testHandleWithCRC32() throws Exception {
+        ByteArrayInputStream bais = new ByteArrayInputStream(
+                "{\"key\" :\"Content\"}".getBytes(StringUtils.UTF8));
+
+        CRC32 crc32 = new CRC32();
+        crc32.update("{\"key\" :\"Content\"}".getBytes(StringUtils.UTF8));
+        HttpResponse response = new HttpResponse.Builder().statusText("testResponse")
+                .statusCode(200).header("testKey", "testValue")
+                .header("x-amz-crc32", String.valueOf(crc32.getValue())).content(bais).build();
+
+        Unmarshaller<String, JsonUnmarshallerContext> unmarshaller = new Unmarshaller<String, JsonUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(JsonUnmarshallerContext in) throws Exception {
+                in.getReader().beginObject();
+                in.getReader().nextName();
+                return in.getReader().nextString();
+            }
+
+        };
+
+        JsonResponseHandler<String> toTest = new JsonResponseHandler<String>(unmarshaller);
+
+        // Is a no-op. just adding for code coverage of the no-op
+        toTest.registerAdditionalMetadataExpressions(null);
+
+        AmazonWebServiceResponse<String> awsResponse = toTest.handle(response);
+        assertEquals(awsResponse.getResult(), "Content");
+    }
+
+    @Test
+    public void testHandleWithNoCRC32() throws Exception {
+        ByteArrayInputStream bais = new ByteArrayInputStream(
+                "{\"key\" :\"Content\"}".getBytes(StringUtils.UTF8));
+
+        HttpResponse response = new HttpResponse.Builder().statusText("testResponse")
+                .statusCode(200).header("testKey", "testValue").content(bais).build();
+
+        Unmarshaller<String, JsonUnmarshallerContext> unmarshaller = new Unmarshaller<String, JsonUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(JsonUnmarshallerContext in) throws Exception {
+                in.getReader().beginObject();
+                in.getReader().nextName();
+                return in.getReader().nextString();
+            }
+
+        };
+
+        JsonResponseHandler<String> toTest = new JsonResponseHandler<String>(unmarshaller);
+
+        AmazonWebServiceResponse<String> awsResponse = toTest.handle(response);
+        assertEquals(awsResponse.getResult(), "Content");
+    }
+
+    @Test
+    public void testHandleWithNullContent() throws Exception {
+
+        HttpResponse response = new HttpResponse.Builder().statusText("testResponse")
+                .statusCode(200).header("testKey", "testValue").content(null).build();
+
+        Unmarshaller<String, JsonUnmarshallerContext> unmarshaller = new Unmarshaller<String, JsonUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(JsonUnmarshallerContext in) throws Exception {
+                in.getReader().beginObject();
+                assertFalse(in.getReader().hasNext());
+                return "NullContent";
+            }
+
+        };
+
+        JsonResponseHandler<String> toTest = new JsonResponseHandler<String>(unmarshaller);
+
+        AmazonWebServiceResponse<String> awsResponse = toTest.handle(response);
+        assertEquals(awsResponse.getResult(), "NullContent");
+    }
+
+    @Test
+    public void testHandleNeedsConnectionLeftOpen() throws Exception {
+        ByteArrayInputStream bais = new ByteArrayInputStream(
+                "{\"key\" :\"Content\"}".getBytes(StringUtils.UTF8));
+        CRC32 crc32 = new CRC32();
+        crc32.update("{\"key\" :\"Content\"}".getBytes(StringUtils.UTF8));
+        HttpResponse response = new HttpResponse.Builder().statusText("testResponse")
+                .statusCode(200).header("testKey", "testValue").content(bais).build();
+
+        final List<InputStream> capture = new ArrayList<InputStream>();
+
+        Unmarshaller<String, JsonUnmarshallerContext> unmarshaller = new Unmarshaller<String, JsonUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(JsonUnmarshallerContext in) throws Exception {
+                capture.add(in.getHttpResponse().getContent());
+                return "OpenConnection";
+            }
+
+        };
+
+        JsonResponseHandler<String> toTest = new JsonResponseHandler<String>(unmarshaller);
+        toTest.needsConnectionLeftOpen = true;
+        assertTrue(toTest.needsConnectionLeftOpen());
+
+        AmazonWebServiceResponse<String> awsResponse = toTest.handle(response);
+        assertEquals(awsResponse.getResult(), "OpenConnection");
+        assertSame(capture.get(0), bais);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/StaxResponseHandlerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/StaxResponseHandlerTest.java
new file mode 100644
index 0000000000..23124e8e78
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/StaxResponseHandlerTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.AmazonWebServiceResponse;
+import com.amazonaws.transform.StaxUnmarshallerContext;
+import com.amazonaws.transform.Unmarshaller;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+
+public class StaxResponseHandlerTest {
+
+    @Test
+    public void testHandleWithContent() throws Exception {
+        final ByteArrayInputStream bais = new ByteArrayInputStream(
+                ("<data>Content</data>").getBytes(StringUtils.UTF8));
+        final HttpResponse response = new HttpResponse.Builder().header("testKey", "testValue")
+                .header("x-amzn-RequestId", "99")
+                .content(bais).build();
+
+        Unmarshaller<String, StaxUnmarshallerContext> unmarshaller = new Unmarshaller<String, StaxUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(StaxUnmarshallerContext in) throws Exception {
+                in.nextEvent();
+                String content = in.readText();
+                assertEquals(content, "Content");
+                assertEquals(in.getHeader("testKey"), "testValue");
+                return content;
+            }
+
+        };
+
+        StaxResponseHandler<String> handler = new StaxResponseHandler<String>(unmarshaller);
+        AmazonWebServiceResponse<String> awsr = handler.handle(response);
+        assertEquals(awsr.getResponseMetadata().getRequestId(), "99");
+        assertEquals(awsr.getResult(), "Content");
+    }
+
+    @Test
+    public void testHandleWithNullContent() throws Exception {
+        final HttpResponse response = new HttpResponse.Builder().header("testKey", "testValue")
+                .content(null).build();
+
+        Unmarshaller<String, StaxUnmarshallerContext> unmarshaller = new Unmarshaller<String, StaxUnmarshallerContext>() {
+
+            @Override
+            public String unmarshall(StaxUnmarshallerContext in) throws Exception {
+                assertEquals(in.getHeader("testKey"), "testValue");
+                return "Test";
+            }
+
+        };
+
+        StaxResponseHandler<String> handler = new StaxResponseHandler<String>(unmarshaller);
+        assertEquals(handler.handle(response).getResult(), "Test");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/UrlHttpClientTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/UrlHttpClientTest.java
new file mode 100644
index 0000000000..237d42d60f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/UrlHttpClientTest.java
@@ -0,0 +1,407 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.SDKGlobalConfiguration;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.ProtocolException;
+import java.net.UnknownHostException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+
+public class UrlHttpClientTest {
+
+    private ClientConfiguration conf;
+    private MockUrlHttpClient client;
+
+    @Before
+    public void setup() {
+        conf = new ClientConfiguration();
+        client = new MockUrlHttpClient(conf);
+    }
+
+    @Test
+    public void testBasicCurlBuilder() throws URISyntaxException, IOException {
+        conf.setCurlLogging(true);
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"));
+        assertEquals(0, client.getLogList().size());
+        //assertEquals("curl -X POST https://www.test.com", client.getLogList().get(0));
+    }
+
+    @Test
+    public void testCurlBuilderWithHeaders() throws URISyntaxException, IOException {
+        conf.setCurlLogging(true);
+        final Map<String, String> headers = new HashMap<String, String>();
+        headers.put("key1", "value1");
+        headers.put("key2", "value2");
+
+        final HashSet<String> expectedCurlHeaders = new HashSet<String>();
+        for (final Map.Entry<String, String> entry : headers.entrySet()) {
+            expectedCurlHeaders.add("\"" + entry.getKey() + ":" + entry.getValue() + "\"");
+        }
+       
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"),
+                headers,
+                null /* stream */);
+        
+        
+        try {
+            client.execute(request);
+        } catch (final UnknownHostException exception) {
+            return;
+        }
+
+        assertTrue("Expected UnknownHostException. UnknownHostException not thrown while executing the request.", true);
+
+        /*
+        assertEquals(client.getLogList().size(), 1);
+
+        final String[] parts = client.getLogList().get(0).split(" ");
+        assertEquals(8, parts.length);
+        assertEquals("curl", parts[0]);
+        assertEquals("-X", parts[1]);
+        assertEquals("POST", parts[2]);
+        assertEquals("-H", parts[3]);
+        assertTrue(expectedCurlHeaders.contains(parts[4]));
+        expectedCurlHeaders.remove(parts[4]);
+        assertEquals("-H", parts[5]);
+        assertTrue(expectedCurlHeaders.contains(parts[6]));
+        expectedCurlHeaders.remove(parts[6]);
+        assertTrue(expectedCurlHeaders.isEmpty());
+        assertEquals("https://www.test.com", parts[7]);
+        */
+    }
+
+    @Test
+    public void testCurlBuilderWithData() throws URISyntaxException, IOException {
+        conf.setCurlLogging(true);
+        final String dataString = "content";
+        final byte[] data = dataString.getBytes("UTF-8");
+
+        final Map<String, String> headers = new HashMap<String, String>();
+        headers.put(HttpHeader.CONTENT_LENGTH, String.valueOf(data.length));
+
+        final InputStream stream = new ByteArrayInputStream(data);
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"),
+                headers, stream);
+        
+        try {
+            client.execute(request);
+        } catch (final UnknownHostException exception) {
+            return;
+        }
+
+        assertTrue("Expected UnknownHostException. UnknownHostException not thrown while executing the request.", true);
+
+        /*
+        assertEquals(1, client.getLogList().size());
+        assertEquals(
+                "curl -X POST -H \"Content-Length:" + String.valueOf(data.length) + "\" -d '"
+                        + dataString + "' https://www.test.com",
+                client.getLogList().get(0));
+        */
+    }
+
+    @Test
+    public void testOverflowInCurl() throws URISyntaxException, IOException {
+        conf.setCurlLogging(true);
+        final long tooManyBytes = Integer.MAX_VALUE + 1L;
+        final InputStream stream = new ByteArrayInputStream("content".getBytes("UTF-8"));
+        final Map<String, String> headers = new HashMap<String, String>();
+        headers.put(HttpHeader.CONTENT_LENGTH, String.valueOf(tooManyBytes));
+        
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"),
+                headers, stream);
+        request.setStreaming(true);
+        
+        try {
+            client.execute(request);
+        } catch (final UnknownHostException exception) {
+            return;
+        }
+
+        assertTrue("Expected UnknownHostException. UnknownHostException not thrown while executing the request.", true);
+
+        /*
+        assertEquals(1,client.getLogList().size());
+        assertEquals(
+                "Failed to create curl, content too long", client.getLogList().get(0));
+        */
+    }
+
+    @Test
+    public void testApplyHeaders() throws ProtocolException, MalformedURLException,
+            URISyntaxException {
+
+        final Map<String, String> headers = new HashMap<String, String>();
+        headers.put("testKey", "testValue");
+        headers.put(HttpHeader.CONTENT_LENGTH, "I should not be added");
+        headers.put(HttpHeader.HOST, "I should not be added");
+
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"), headers,
+                null);
+
+        final HttpsURLConnection conn = (HttpsURLConnection) client.applyHeadersAndMethod(request,
+                new MockHttpURLConnection(new URL("https://www.test.com")));
+        assertEquals(conn.getRequestProperty("testKey"), "testValue");
+        assertNull(conn.getRequestProperty(HttpHeader.CONTENT_LENGTH));
+        assertNull(conn.getRequestProperty(HttpHeader.HOST));
+        assertEquals(conn.getRequestMethod(), "POST");
+    }
+
+    @Test
+    public void testConfigureConnection() throws MalformedURLException, URISyntaxException {
+        final Map<String, String> headers = new HashMap<String, String>();
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"),
+                headers,
+                null);
+        final HttpsURLConnection conn = new MockHttpURLConnection(new URL("https://www.test.com"));
+        client.configureConnection(request, conn);
+
+        assertEquals(conn.getConnectTimeout(), conf.getConnectionTimeout());
+        assertEquals(conn.getReadTimeout(), conf.getSocketTimeout());
+        assertSame(conn.getHostnameVerifier(), HttpsURLConnection.getDefaultHostnameVerifier());
+        assertFalse(conn.getInstanceFollowRedirects());
+        assertFalse("disable cache", conn.getUseCaches());
+    }
+
+    //commenting as we donot support this. See https://support.google.com/faqs/answer/6346016
+    @Test
+    public void testConfigureConnectionWithCertCheckingDisabled()
+            throws MalformedURLException, URISyntaxException {
+        final Map<String, String> headers = new HashMap<String, String>();
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"),
+                headers,
+                null);
+        final HttpsURLConnection conn = new MockHttpURLConnection(new URL("https://www.test.com"));
+        System.setProperty(SDKGlobalConfiguration.DISABLE_CERT_CHECKING_SYSTEM_PROPERTY, "true");
+        client.configureConnection(request, conn);
+
+        assertEquals(conn.getConnectTimeout(), conf.getConnectionTimeout());
+        assertEquals(conn.getReadTimeout(), conf.getSocketTimeout());
+        assertFalse(conn.getInstanceFollowRedirects());
+        assertFalse("disable cache", conn.getUseCaches());
+        //assertTrue(conn.getHostnameVerifier().verify("https://some.bogus.com", null));
+        //assertTrue(conn.getHostnameVerifier()
+        //        .verify("https://bucket.withdot.s3.amazonaws.com", null));
+        System.clearProperty(SDKGlobalConfiguration.DISABLE_CERT_CHECKING_SYSTEM_PROPERTY);
+    }
+
+    @Test
+    public void testCreateResponse() throws URISyntaxException, IOException {
+        final HttpRequest request = new HttpRequest("PUT", new URI("https://www.test.com"));
+        final MockHttpURLConnection conn = new MockHttpURLConnection(new URL("https://www.test.com"));
+
+        final Map<String, List<String>> headerFields = new HashMap<String, List<String>>();
+        final List<String> header1 = new ArrayList<String>();
+        header1.add("value1");
+        header1.add("ExtraValue");
+        headerFields.put("key1", header1);
+
+        final List<String> header2 = new ArrayList<String>();
+        header2.add("value2");
+        headerFields.put("key2", header2);
+
+        final List<String> nullHeader = new ArrayList<String>();
+        headerFields.put(null, nullHeader);
+
+        conn.setHeaderFields(headerFields);
+        conn.setResponseCode(200);
+        conn.setErrorStream(null);
+        final ByteArrayInputStream bais = new ByteArrayInputStream("test".getBytes(StringUtils.UTF8));
+        conn.setInputStream(bais);
+        conn.setResponseMessage("TestMessage");
+
+        final HttpResponse response = client.createHttpResponse(request, conn);
+        assertEquals(response.getHeaders().get("key1"), "value1");
+        assertEquals(response.getHeaders().get("key2"), "value2");
+        assertEquals(response.getHeaders().size(), 2);
+        assertEquals(response.getStatusCode(), 200);
+        assertEquals(response.getStatusText(), "TestMessage");
+        assertSame(response.getContent(), bais);
+    }
+
+    @Test
+    public void testWriteContentToConnection() throws URISyntaxException, IOException {
+        final ByteArrayInputStream bais = new ByteArrayInputStream("Content".getBytes(StringUtils.UTF8));
+        final Map<String, String> headers = new HashMap<String, String>();
+        headers.put(HttpHeader.CONTENT_LENGTH,
+                String.valueOf("Content".getBytes(StringUtils.UTF8).length));
+        final HttpRequest request = new HttpRequest("POST", new URI("https://www.test.com"), headers,
+                bais);
+
+        final MockHttpURLConnection connection = new MockHttpURLConnection(
+                new URL("https://www.test.com"));
+
+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        connection.setOutputStream(baos);
+
+        client.writeContentToConnection(request, connection);
+        final ByteArrayOutputStream connOs = (ByteArrayOutputStream) connection.getOutputStream();
+        assertEquals(new String(connOs.toByteArray(), StringUtils.UTF8), "Content");
+    }
+}
+
+class MockHttpURLConnection extends HttpsURLConnection {
+
+    String responseMessage;
+    int responseCode;
+    InputStream errorStream;
+    InputStream inputStream;
+    OutputStream outputStream;
+
+    Map<String, List<String>> headerFields;
+
+    protected MockHttpURLConnection(URL u) {
+        super(u);
+    }
+
+    public void setOutputStream(OutputStream os) {
+        outputStream = os;
+    }
+
+    @Override
+    public OutputStream getOutputStream() {
+        return outputStream;
+    }
+
+    @Override
+    public String getResponseMessage() {
+        return responseMessage;
+    }
+
+    public void setResponseMessage(String responseMessage) {
+        this.responseMessage = responseMessage;
+    }
+
+    @Override
+    public int getResponseCode() {
+        return responseCode;
+    }
+
+    public void setResponseCode(int responseCode) {
+        this.responseCode = responseCode;
+    }
+
+    @Override
+    public InputStream getErrorStream() {
+        return errorStream;
+    }
+
+    public void setErrorStream(InputStream errorStream) {
+        this.errorStream = errorStream;
+    }
+
+    @Override
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    public void setInputStream(InputStream inputStream) {
+        this.inputStream = inputStream;
+    }
+
+    @Override
+    public Map<String, List<String>> getHeaderFields() {
+        return headerFields;
+    }
+
+    public void setHeaderFields(Map<String, List<String>> headerFields) {
+        this.headerFields = headerFields;
+    }
+
+    @Override
+    public void disconnect() {
+    }
+
+    @Override
+    public boolean usingProxy() {
+        return false;
+    }
+
+    @Override
+    public void connect() throws IOException {
+    }
+
+    @Override
+    public String getCipherSuite() {
+        return null;
+    }
+
+    @Override
+    public Certificate[] getLocalCertificates() {
+        return null;
+    }
+
+    @Override
+    public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
+        return null;
+    }
+
+}
+
+class MockUrlHttpClient extends UrlHttpClient {
+
+    private final ArrayList<String> mLogList = new ArrayList<String>();
+
+    public MockUrlHttpClient(ClientConfiguration config) {
+        super(config);
+    }
+
+    public ArrayList<String> getLogList() {
+        return mLogList;
+    }
+
+    @Override
+    protected void printToLog(String message) {
+        mLogList.add(message);
+    }
+
+    @Override
+    protected HttpURLConnection getUrlConnection(URL url) throws IOException {
+        final MockHttpURLConnection connection = new MockHttpURLConnection(url);
+        connection.setOutputStream(new ByteArrayOutputStream());
+        return connection;
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionManagerFactoryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionManagerFactoryTest.java
new file mode 100644
index 0000000000..3daaa3851b
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionManagerFactoryTest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http.conn;
+
+import static org.junit.Assert.assertTrue;
+
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.ClientConnectionRequest;
+import org.apache.http.conn.ManagedClientConnection;
+import org.apache.http.conn.routing.HttpRoute;
+import org.apache.http.conn.scheme.SchemeRegistry;
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+
+public class ClientConnectionManagerFactoryTest {
+    ClientConnectionManager noop = new ClientConnectionManager() {
+        @Override
+        public SchemeRegistry getSchemeRegistry() {
+            return null;
+        }
+
+        @Override
+        public ClientConnectionRequest requestConnection(HttpRoute route,
+                Object state) {
+            return null;
+        }
+
+        @Override
+        public void releaseConnection(ManagedClientConnection conn,
+                long validDuration, TimeUnit timeUnit) {
+        }
+
+        @Override
+        public void closeIdleConnections(long idletime, TimeUnit tunit) {
+        }
+
+        @Override
+        public void closeExpiredConnections() {
+        }
+
+        @Override
+        public void shutdown() {
+        }
+    };
+
+    @Test
+    public void wrapOnce() {
+        ClientConnectionManager wrapped = ClientConnectionManagerFactory.wrap(noop);
+        assertTrue(wrapped instanceof Wrapped);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void wrapTwice() {
+        ClientConnectionManager wrapped = ClientConnectionManagerFactory.wrap(noop);
+        ClientConnectionManagerFactory.wrap(wrapped);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionRequestFactoryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionRequestFactoryTest.java
new file mode 100644
index 0000000000..e4ade14ef0
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/http/conn/ClientConnectionRequestFactoryTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.http.conn;
+
+import static org.junit.Assert.assertTrue;
+
+import org.apache.http.conn.ClientConnectionRequest;
+import org.apache.http.conn.ConnectionPoolTimeoutException;
+import org.apache.http.conn.ManagedClientConnection;
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+
+public class ClientConnectionRequestFactoryTest {
+    ClientConnectionRequest noop = new ClientConnectionRequest() {
+        @Override
+        public ManagedClientConnection getConnection(long timeout, TimeUnit tunit)
+                throws InterruptedException, ConnectionPoolTimeoutException {
+            return null;
+        }
+
+        @Override
+        public void abortRequest() {
+        }
+    };
+
+    @Test
+    public void wrapOnce() {
+        ClientConnectionRequest wrapped = ClientConnectionRequestFactory.wrap(noop);
+        assertTrue(wrapped instanceof Wrapped);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void wrapTwice() {
+        ClientConnectionRequest wrapped = ClientConnectionRequestFactory.wrap(noop);
+        ClientConnectionRequestFactory.wrap(wrapped);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/DynamoDBBackoffStrategyTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/DynamoDBBackoffStrategyTest.java
new file mode 100644
index 0000000000..0a1ccdaf5c
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/DynamoDBBackoffStrategyTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+public class DynamoDBBackoffStrategyTest {
+
+    @Test
+    public void testDynamoDBBackoffStrategy() {
+        CustomBackoffStrategy ddb = DynamoDBBackoffStrategy.DEFAULT;
+
+        assertEquals(ddb.getBackoffPeriod(-1), 0);
+        assertEquals(ddb.getBackoffPeriod(0), 0);
+        assertEquals(ddb.getBackoffPeriod(1), 50);
+        assertEquals(ddb.getBackoffPeriod(2), 100);
+        assertEquals(ddb.getBackoffPeriod(3), 200);
+        assertEquals(ddb.getBackoffPeriod(100), Integer.MAX_VALUE);
+
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/ListWithAutoConstructFlagTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/ListWithAutoConstructFlagTest.java
new file mode 100644
index 0000000000..afcaa3b3f8
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/ListWithAutoConstructFlagTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+
+public class ListWithAutoConstructFlagTest {
+
+    @Test
+    public void testListWithAutoConstructFlag() {
+        ListWithAutoConstructFlag<String> noArgs = new ListWithAutoConstructFlag<String>();
+        ListWithAutoConstructFlag<String> collect = new ListWithAutoConstructFlag<String>(
+                new ArrayList<String>());
+        ListWithAutoConstructFlag<String> capacity = new ListWithAutoConstructFlag<String>(5);
+
+        assertFalse(noArgs.isAutoConstruct());
+        assertFalse(collect.isAutoConstruct());
+        assertFalse(capacity.isAutoConstruct());
+
+        noArgs.setAutoConstruct(true);
+        collect.setAutoConstruct(true);
+        capacity.setAutoConstruct(true);
+
+        assertTrue(noArgs.isAutoConstruct());
+        assertTrue(collect.isAutoConstruct());
+        assertTrue(capacity.isAutoConstruct());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkDigestInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkDigestInputStreamTest.java
new file mode 100644
index 0000000000..91cec24f4a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkDigestInputStreamTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import static org.junit.Assert.assertArrayEquals;
+
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public class SdkDigestInputStreamTest {
+
+    @Test
+    public void testSkip() throws NoSuchAlgorithmException, IOException {
+        byte[] bytes = "Content".getBytes(StringUtils.UTF8);
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+
+        MessageDigest md = MessageDigest.getInstance("SHA-256");
+
+        // Calculate the expected digest
+        byte[] expected = md.digest(bytes);
+
+        SdkDigestInputStream sdis = new SdkDigestInputStream(bais, md);
+        sdis.skip(2);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        int curr = -1;
+        while ((curr = sdis.read()) != -1) {
+            baos.write(curr);
+        }
+        baos.flush();
+
+        MessageDigest inputStreamMD = sdis.getMessageDigest();
+        assertArrayEquals(expected, inputStreamMD.digest());
+        assertArrayEquals("ntent".getBytes(StringUtils.UTF8), baos.toByteArray());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkFilterInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkFilterInputStreamTest.java
new file mode 100644
index 0000000000..f35acbf235
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkFilterInputStreamTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.AbortedException;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+public class SdkFilterInputStreamTest {
+
+    @Test
+    public void testShouldAbort() throws InterruptedException {
+        final List<Integer> abortionCount = new ArrayList<Integer>();
+
+        Thread t = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+
+                ByteArrayInputStream bais = new ByteArrayInputStream(
+                        "Content".getBytes(StringUtils.UTF8));
+                TestInputStream tis = new TestInputStream(bais);
+
+                long counter = 0;
+                while (counter < Long.MAX_VALUE) {
+                    counter++;
+                    if (Thread.currentThread().isInterrupted()) {
+                        try {
+                            tis.abortIfNeeded();
+                        } catch (AbortedException e) {
+                        }
+                        abortionCount.add(tis.getAbortions());
+                        break;
+                    }
+                }
+
+            }
+
+        });
+
+        t.start();
+        Thread.sleep(1000);
+        t.interrupt();
+        Thread.sleep(1000);
+        assertEquals(abortionCount.size(), 1);
+        assertEquals(abortionCount.get(0), new Integer(1));
+    }
+
+    private class TestInputStream extends SdkFilterInputStream {
+
+        InputStream wrapped;
+        int abortions = 0;
+
+        public TestInputStream(InputStream is) {
+            super(is);
+            wrapped = is;
+        }
+
+        protected InputStream getWrappedInputStream() {
+            return null;
+        }
+
+        @Override
+        public int read() throws IOException {
+            return wrapped.read();
+        }
+
+        @Override
+        public void abort() {
+            abortions++;
+        }
+
+        public int getAbortions() {
+            return abortions;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkInputStreamTest.java
new file mode 100644
index 0000000000..09f8180c1e
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/SdkInputStreamTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.AbortedException;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+public class SdkInputStreamTest {
+
+    @Test
+    public void testShouldAbort() throws InterruptedException {
+        final List<Integer> abortionCount = new ArrayList<Integer>();
+
+        Thread t = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+
+                ByteArrayInputStream bais = new ByteArrayInputStream(
+                        "Content".getBytes(StringUtils.UTF8));
+                TestInputStream tis = new TestInputStream(bais);
+
+                long counter = 0;
+                while (counter < Long.MAX_VALUE) {
+                    counter++;
+                    if (Thread.currentThread().isInterrupted()) {
+                        try {
+                            tis.abortIfNeeded();
+                        } catch (AbortedException e) {
+                        }
+                        abortionCount.add(tis.getAbortions());
+                        break;
+                    }
+                }
+
+            }
+
+        });
+
+        t.start();
+        Thread.sleep(1000);
+        t.interrupt();
+        Thread.sleep(1000);
+        assertEquals(abortionCount.size(), 1);
+        assertEquals(abortionCount.get(0), new Integer(1));
+    }
+
+    private class TestInputStream extends SdkInputStream {
+
+        InputStream wrapped;
+        int abortions = 0;
+
+        public TestInputStream(InputStream is) {
+            wrapped = is;
+        }
+
+        @Override
+        protected InputStream getWrappedInputStream() {
+            return null;
+        }
+
+        @Override
+        public int read() throws IOException {
+            return wrapped.read();
+        }
+
+        @Override
+        public void abort() throws IOException {
+            abortions++;
+        }
+
+        public int getAbortions() {
+            return abortions;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/internal/config/InternalConfigTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/config/InternalConfigTest.java
new file mode 100644
index 0000000000..f444f43d92
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/internal/config/InternalConfigTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.internal.config;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+
+import com.amazonaws.regions.Regions;
+
+import org.junit.Test;
+
+public class InternalConfigTest {
+    @Test
+    public void s3() throws Exception {
+        InternalConfig config = new InternalConfig();
+        s3Assertions(config);
+    }
+
+    private void s3Assertions(InternalConfig config) {
+        // S3
+        SignerConfig signer = config.getSignerConfig("s3");
+        assertEquals("S3SignerType", signer.getSignerType());
+        // S3 BJS
+        signer = config.getSignerConfig("s3", "cn-north-1");
+        assertEquals("AWSS3V4SignerType", signer.getSignerType());
+        // S3 us-east-1
+        signer = config.getSignerConfig("s3", Regions.US_EAST_1.name());
+        assertEquals("S3SignerType", signer.getSignerType());
+    }
+
+    @Test
+    public void cloudfront() throws Exception {
+        InternalConfig config = new InternalConfig();
+        cloudfrontAssertions(config);
+    }
+
+    private void cloudfrontAssertions(InternalConfig config) {
+        SignerConfig signer = config.getSignerConfig("cloudfront");
+        assertEquals("AWS4SignerType", signer.getSignerType());
+    }
+
+    @Test
+    public void ec2() throws Exception {
+        InternalConfig config = new InternalConfig();
+        ec2Assertions(config);
+    }
+
+    private void ec2Assertions(InternalConfig config) {
+        SignerConfig signer = config.getSignerConfig("ec2");
+        assertEquals("QueryStringSignerType", signer.getSignerType());
+        // EC2 BJS
+        signer = config.getSignerConfig("ec2", "cn-north-1");
+        assertEquals("AWS4SignerType", signer.getSignerType());
+        // EC2 us-east-1
+        signer = config.getSignerConfig("ec2", Regions.US_EAST_1.name());
+        assertEquals("QueryStringSignerType", signer.getSignerType());
+    }
+
+    @Test
+    public void dynamoDB() throws Exception {
+        InternalConfig config = new InternalConfig();
+        dynamoDBAssertions(config);
+    }
+
+    private void dynamoDBAssertions(InternalConfig config) {
+        SignerConfig signer = config.getSignerConfig("dynamodb");
+        assertEquals("AWS4SignerType", signer.getSignerType());
+        // DynamoDB BJS
+        signer = config.getSignerConfig("dynamodb", "cn-north-1");
+        assertEquals("AWS4SignerType", signer.getSignerType());
+        // DynamoDB us-east-1
+        signer = config.getSignerConfig("dynamodb", Regions.US_EAST_1.name());
+        assertEquals("AWS4SignerType", signer.getSignerType());
+    }
+
+    @Test
+    public void factory() throws Exception {
+        InternalConfig config = InternalConfig.Factory.getInternalConfig();
+        assertSame(config, InternalConfig.Factory.getInternalConfig());
+        assertNotNull(config);
+        s3Assertions(config);
+        cloudfrontAssertions(config);
+        ec2Assertions(config);
+        dynamoDBAssertions(config);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/metrics/AwsSdkMetricsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/metrics/AwsSdkMetricsTest.java
new file mode 100644
index 0000000000..43c704be03
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/metrics/AwsSdkMetricsTest.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.metrics;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.util.AWSRequestMetrics.Field;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Set;
+
+public class AwsSdkMetricsTest {
+    /**
+     * By default the AWS SDK metric collection is disabled. Enabling it should
+     * fail unless the necessary CloudWatch related jars are on the classpath.
+     * Therefore, this test is expected to fail in enabling the default metric
+     * collection, but have absolutely no impact otherwise.
+     */
+    @Test
+    public void enableDefaultMetrics() {
+        Assert.assertFalse(AwsSdkMetrics.enableDefaultMetrics());
+    }
+
+    @Test
+    public void test() {
+        // by default, it's disabled
+        assertFalse(AwsSdkMetrics.isDefaultMetricsEnabled());
+        // won't be anble to enable unless the default impl library is on the
+        // classpath
+        assertFalse(AwsSdkMetrics.enableDefaultMetrics());
+        assertFalse(AwsSdkMetrics.isDefaultMetricsEnabled());
+        assertSame(RequestMetricCollector.NONE, AwsSdkMetrics.getRequestMetricCollector());
+        assertFalse(AwsSdkMetrics.isDefaultMetricsEnabled());
+        // effectively no effect
+        AwsSdkMetrics.disableMetrics();
+        assertFalse(AwsSdkMetrics.isDefaultMetricsEnabled());
+    }
+
+    @Test
+    public void defaultMetricTypes() {
+        // Default set of predefined metric types is not empty
+        Set<MetricType> set = AwsSdkMetrics.getPredefinedMetrics();
+        assertNotNull(set);
+        assertTrue(set.size() > 0);
+        // Clear out the default set of predefined metric types
+        AwsSdkMetrics.set(Collections.<MetricType> emptyList());
+        Set<MetricType> empty = AwsSdkMetrics.getPredefinedMetrics();
+        assertNotNull(empty);
+        assertTrue(empty.size() == 0);
+        // Reconfigure the default set of predefined metric types back to the
+        // original
+        AwsSdkMetrics.set(set);
+        Set<MetricType> set2 = AwsSdkMetrics.getPredefinedMetrics();
+        assertNotNull(set2);
+        assertTrue(set2.size() > 0);
+        // Not the same due to ensuring thread-safety
+        assertNotSame(set, set2);
+    }
+
+    @Test
+    public void setNullOrEmpty() {
+        Set<MetricType> orig = AwsSdkMetrics.getPredefinedMetrics();
+        assertTrue(orig.size() > 0);
+        AwsSdkMetrics.set(null);
+        Set<MetricType> empty = AwsSdkMetrics.getPredefinedMetrics();
+        assertTrue(empty.size() == 0);
+        AwsSdkMetrics.set(null);
+        Set<MetricType> stillEmpty = AwsSdkMetrics.getPredefinedMetrics();
+        assertSame(empty, stillEmpty);
+        AwsSdkMetrics.set(Collections.<MetricType> emptySet());
+        Set<MetricType> empty3 = AwsSdkMetrics.getPredefinedMetrics();
+        assertSame(empty, empty3);
+        AwsSdkMetrics.set(orig);
+    }
+
+    @Test
+    public void addNull() {
+        assertFalse(AwsSdkMetrics.add(null));
+    }
+
+    @Test
+    public void addAllNull() {
+        assertFalse(AwsSdkMetrics.addAll(null));
+        assertFalse(AwsSdkMetrics.addAll(Collections.<MetricType> emptyList()));
+    }
+
+    @Test
+    public void removeNull() {
+        assertFalse(AwsSdkMetrics.remove(null));
+    }
+
+    @Test
+    public void addAndRemove() {
+        Set<MetricType> orig = AwsSdkMetrics.getPredefinedMetrics();
+        AwsSdkMetrics.set(null);
+        // Test add and remove
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().isEmpty());
+        AwsSdkMetrics.add(Field.ClientExecuteTime);
+        assertFalse(AwsSdkMetrics.getPredefinedMetrics().isEmpty());
+        AwsSdkMetrics.remove(Field.ClientExecuteTime);
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().isEmpty());
+        // Test add more than one entry
+        AwsSdkMetrics.add(Field.ClientExecuteTime);
+        AwsSdkMetrics.add(Field.Exception);
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().size() == 2);
+        AwsSdkMetrics.set(null);
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().isEmpty());
+        // Test addAll
+        AwsSdkMetrics.addAll(Arrays.asList(Field.Exception, Field.ClientExecuteTime));
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().size() == 2);
+        AwsSdkMetrics.set(orig);
+        assertTrue(AwsSdkMetrics.getPredefinedMetrics().size() == orig.size());
+    }
+
+    @Test
+    public void setJvmMetricsExcluded() {
+        final boolean b = AwsSdkMetrics.isMachineMetricExcluded();
+        AwsSdkMetrics.setMachineMetricsExcluded(b);
+        assertTrue(b == AwsSdkMetrics.isMachineMetricExcluded());
+        AwsSdkMetrics.setMachineMetricsExcluded(!b);
+        assertFalse(b == AwsSdkMetrics.isMachineMetricExcluded());
+        AwsSdkMetrics.setMachineMetricsExcluded(b);
+        assertTrue(b == AwsSdkMetrics.isMachineMetricExcluded());
+    }
+
+    @Test
+    public void setPerHostMetricsIncluded() {
+        final boolean b = AwsSdkMetrics.isPerHostMetricIncluded();
+        AwsSdkMetrics.setPerHostMetricsIncluded(b);
+        assertTrue(b == AwsSdkMetrics.isPerHostMetricIncluded());
+        AwsSdkMetrics.setPerHostMetricsIncluded(!b);
+        assertFalse(b == AwsSdkMetrics.isPerHostMetricIncluded());
+        AwsSdkMetrics.setPerHostMetricsIncluded(b);
+        assertTrue(b == AwsSdkMetrics.isPerHostMetricIncluded());
+    }
+
+    @Test
+    public void isMetricEnabled() {
+        // originally disabled
+        assertFalse(AwsSdkMetrics.isMetricsEnabled());
+        // set to NONE, so still disabled
+        AwsSdkMetrics.setMetricCollector(MetricCollector.NONE);
+        assertFalse(AwsSdkMetrics.isMetricsEnabled());
+        // set to a custom collector, so now considered enabled
+        AwsSdkMetrics.setMetricCollector(new MetricCollector() {
+            @Override
+            public boolean start() {
+                return true;
+            }
+
+            @Override
+            public boolean stop() {
+                return false;
+            }
+
+            @Override
+            public boolean isEnabled() {
+                return true;
+            }
+
+            @Override
+            public RequestMetricCollector getRequestMetricCollector() {
+                return RequestMetricCollector.NONE;
+            }
+
+            @Override
+            public ServiceMetricCollector getServiceMetricCollector() {
+                return ServiceMetricCollector.NONE;
+            }
+        });
+        assertTrue(AwsSdkMetrics.isMetricsEnabled());
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionMetadataTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionMetadataTest.java
new file mode 100644
index 0000000000..e25dd5d424
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionMetadataTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.LinkedList;
+import java.util.List;
+
+public class RegionMetadataTest {
+
+    private static RegionMetadata metadata;
+
+    @BeforeClass
+    public static void setUp() {
+        List<Region> regions = new LinkedList<Region>();
+
+        Region region = new Region("us-east-1", null);
+        region.getServiceEndpoints().put("s3", "s3.amazonaws.com");
+        regions.add(region);
+
+        region = new Region("us-west-1", null);
+        region.getServiceEndpoints().put("s3", "s3-us-west-1.amazonaws.com");
+        regions.add(region);
+
+        regions.add(new Region("cn-north-1", "amazonaws.com.cn"));
+
+        metadata = new RegionMetadata(regions);
+    }
+
+    @Test
+    public void testGetRegion() {
+        Region region = metadata.getRegion("us-east-1");
+        Assert.assertNotNull(region);
+        Assert.assertEquals("us-east-1", region.getName());
+
+        region = metadata.getRegion("us-west-1");
+        Assert.assertNotNull(region);
+        Assert.assertEquals("us-west-1", region.getName());
+
+        region = metadata.getRegion("cn-north-1");
+        Assert.assertNotNull(region);
+        Assert.assertEquals("cn-north-1", region.getName());
+
+        region = metadata.getRegion("bogus-monkeys");
+        Assert.assertNull(region);
+    }
+
+    @Test
+    public void testGetRegionsForService() {
+        List<Region> regions = metadata.getRegionsForService("s3");
+        Assert.assertNotNull(regions);
+        Assert.assertEquals(2, regions.size());
+
+        Assert.assertEquals("us-east-1", regions.get(0).getName());
+        Assert.assertEquals("us-west-1", regions.get(1).getName());
+
+        regions = metadata.getRegionsForService("bogus-monkeys");
+        Assert.assertNotNull(regions);
+        Assert.assertTrue(regions.isEmpty());
+    }
+
+    @Test
+    public void testGetRegionByEndpoint() {
+        Region region =
+                metadata.getRegionByEndpoint("s3-us-west-1.amazonaws.com");
+
+        Assert.assertNotNull(region);
+        Assert.assertEquals("us-west-1", region.getName());
+
+        try {
+            metadata.getRegionByEndpoint("bogus-monkeys");
+            Assert.fail("Expected an IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionTest.java
new file mode 100644
index 0000000000..ebe57fca64
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+
+import com.amazonaws.AmazonWebServiceClient;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.auth.AWSCredentialsProvider;
+
+import org.junit.Test;
+
+public class RegionTest {
+
+    private static final String DEFAULT_DOMAIN = "amazonaws.com";
+
+    @Test
+    public void testDefaultDomain() {
+        final String serviceName = "s3";
+        assertEquals("empty domain", DEFAULT_DOMAIN, new Region(serviceName, "").getDomain());
+        assertEquals("null domain", DEFAULT_DOMAIN, new Region(serviceName, null).getDomain());
+    }
+
+    @Test
+    public void testRegionEquals() {
+        final Region usWest2 = RegionUtils.getRegion("us-west-2");
+        final Region other = RegionUtils.getRegionByEndpoint("s3.us-west-2.amazonaws.com");
+
+        assertEquals(usWest2, other);
+    }
+
+    @Test
+    public void testInstantiateClientNoConfigOrCredentials() {
+        final Region usEast1 = Region.getRegion(Regions.US_EAST_1);
+        final AmazonServiceClient asc = usEast1.createClient(AmazonServiceClient.class, null, null);
+        assertNotNull(asc);
+        assertNull(asc.provider);
+        assertNull(asc.conf);
+    }
+
+    @Test
+    public void testInstantiateClient() {
+        final Region usEast1 = Region.getRegion(Regions.US_EAST_1);
+        final AWSCredentialsProvider prov = new AWSCredentialsProvider() {
+
+            @Override
+            public AWSCredentials getCredentials() {
+                return null;
+            }
+
+            @Override
+            public void refresh() {
+            }
+
+        };
+
+        final ClientConfiguration conf = new ClientConfiguration();
+
+        final AmazonServiceClient asc = usEast1.createClient(AmazonServiceClient.class, prov, conf);
+        assertNotNull(asc);
+        assertSame(asc.provider, prov);
+        assertSame(asc.conf, conf);
+    }
+
+    @Test
+    public void testInstantiateClientNoConfig() {
+        final Region usEast1 = Region.getRegion(Regions.US_EAST_1);
+        final AWSCredentialsProvider prov = new AWSCredentialsProvider() {
+
+            @Override
+            public AWSCredentials getCredentials() {
+                return null;
+            }
+
+            @Override
+            public void refresh() {
+            }
+
+        };
+        final AmazonServiceClient asc = usEast1.createClient(AmazonServiceClient.class, prov, null);
+        assertNotNull(asc);
+        assertSame(asc.provider, prov);
+        assertNull(asc.conf);
+    }
+
+    @Test
+    public void testInstantiateClientNoCredentials() {
+        final Region usEast1 = Region.getRegion(Regions.US_EAST_1);
+        final ClientConfiguration conf = new ClientConfiguration();
+        conf.setConnectionTimeout(5);
+        final AmazonServiceClient asc = usEast1.createClient(AmazonServiceClient.class, null, conf);
+        assertNotNull(asc);
+        assertSame(asc.conf, conf);
+        assertNull(asc.provider);
+    }
+
+    private static class AmazonServiceClient extends AmazonWebServiceClient {
+
+        AWSCredentialsProvider provider;
+        ClientConfiguration conf;
+
+        public AmazonServiceClient() {
+            super(new ClientConfiguration());
+            this.conf = null;
+            this.provider = null;
+        }
+
+        public AmazonServiceClient(ClientConfiguration conf) {
+            super(conf);
+            this.provider = null;
+            this.conf = conf;
+        }
+
+        public AmazonServiceClient(AWSCredentialsProvider provider, ClientConfiguration conf) {
+            super(conf);
+            this.provider = provider;
+            this.conf = conf;
+        }
+
+        public AmazonServiceClient(AWSCredentialsProvider provider) {
+            super(new ClientConfiguration());
+            this.provider = provider;
+            this.conf = null;
+        }
+
+        @Override
+        public String getEndpoint() {
+            return endpoint.toString();
+        }
+
+        @Override
+        public String getEndpointPrefix() {
+            return "amazon";
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionUtilsTest.java
new file mode 100644
index 0000000000..908449ff58
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionUtilsTest.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import java.util.List;
+
+public class RegionUtilsTest {
+
+    @Test
+    public void testGetRegionByEndpoint() {
+
+        Region usWest2 = RegionUtils.getRegionByEndpoint("s3.us-west-2.amazonaws.com");
+        Region standard = RegionUtils.getRegionByEndpoint("s3.amazonaws.com");
+
+        assertEquals(usWest2.getName(), "us-west-2");
+        assertEquals(usWest2.getServiceEndpoint(ServiceAbbreviations.S3),
+                "s3.us-west-2.amazonaws.com");
+        assertEquals(standard.getName(), "us-east-1");
+        assertEquals(standard.getServiceEndpoint(ServiceAbbreviations.S3), "s3.amazonaws.com");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testGetRegionByEndpointWithBogusEndpoint() {
+
+        Region standard = RegionUtils.getRegionByEndpoint("bogus.amazonaws.com");
+    }
+
+    @Test
+    public void testGetRegionsForService() {
+        List<Region> regions = RegionUtils.getRegionsForService(ServiceAbbreviations.SimpleDB);
+        assertEquals(regions.size(), 8);
+        boolean usEast1 = false;
+        boolean usWest1 = false;
+        for (Region curr : regions) {
+            if (curr.getName().equalsIgnoreCase("us-east-1")) {
+                usEast1 = true;
+                assertEquals(curr.getServiceEndpoint(ServiceAbbreviations.SimpleDB),
+                        "sdb.amazonaws.com");
+
+            }
+            if (curr.getName().equalsIgnoreCase("us-west-1"))
+                usWest1 = true;
+
+        }
+
+        assertTrue(usEast1);
+        assertTrue(usWest1);
+
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionsTest.java
new file mode 100644
index 0000000000..38e188fc97
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionsTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.regions;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class RegionsTest {
+
+    @Test
+    public void testDefaultDomain() {
+        final Region region = new Region("region", null);
+        Assert.assertEquals("amazonaws.com", region.getDomain());
+    }
+
+    @Test
+    public void testFromName() {
+        final Regions usEast1 = Regions.fromName("us-east-1");
+        assertEquals(usEast1, Regions.US_EAST_1);
+        final Regions cn1 = Regions.fromName("cn-north-1");
+        assertEquals(cn1, Regions.CN_NORTH_1);
+        final Regions govCloud = Regions.fromName("us-gov-west-1");
+        assertEquals(govCloud, Regions.GovCloud);
+        assertEquals(usEast1.getName(), "us-east-1");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/retry/AmazonHttpClientRetryPolicyTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/AmazonHttpClientRetryPolicyTest.java
new file mode 100644
index 0000000000..794cd114f0
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/AmazonHttpClientRetryPolicyTest.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.Request;
+import com.amazonaws.http.AmazonHttpClient;
+import com.amazonaws.http.ExecutionContext;
+import com.amazonaws.util.AWSRequestMetrics;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.UUID;
+
+/**
+ * Tests that {@link AmazonHttpClient#executeHelper()} method passes the correct
+ * context information into the configured RetryPolicy.
+ */
+public class AmazonHttpClientRetryPolicyTest extends RetryPolicyTestBase {
+
+    private static final int EXPECTED_RETRY_COUNT = 5;
+    private static final Random random = new Random();
+
+    /** Reset the RetryPolicy and restart collecting context data */
+    @Before
+    public void resetContextData() {
+        retryCondition = new ContextDataCollectionRetryCondition();
+        backoffStrategy = new ContextDataCollectionBackoffStrategy();
+        // Reset the RetryPolicy
+        clientConfiguration.setRetryPolicy(
+                new RetryPolicy(retryCondition,
+                        backoffStrategy,
+                        EXPECTED_RETRY_COUNT, // max error retry
+                        false)); // ignore the maxErrorRetry in
+                                 // ClientConfiguration level
+    }
+
+    /**
+     * Tests AmazonHttpClient's behavior upon simulated service exceptions when
+     * the request payload is repeatable.
+     */
+    @Test
+    public void testServiceExceptionHandling() {
+        int random500StatusCode = 500 + random.nextInt(100);
+        String randomErrorCode = UUID.randomUUID().toString();
+
+        // A mock HttpClient that always returns the specified status and error
+        // code.
+        injectMockHttpClient(testedClient, new ReturnServiceErrorHttpClient(random500StatusCode,
+                randomErrorCode));
+
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        Request<?> testedRepeatableRequest = getSampleRequestWithRepeatableContent(originalRequest);
+
+        // It should keep retrying until it reaches the max retry limit and
+        // throws the simulated ASE.
+        AmazonServiceException expectedServiceException = null;
+        try {
+            testedClient.execute(testedRepeatableRequest,
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonServiceException is expected.");
+        } catch (AmazonServiceException ase) {
+            // We should see the original service exception
+            Assert.assertEquals(random500StatusCode, ase.getStatusCode());
+            Assert.assertEquals(randomErrorCode, ase.getErrorCode());
+            expectedServiceException = ase;
+        }
+
+        // Verifies that the correct information was passed into the
+        // RetryCondition and BackoffStrategy
+        verifyExpectedContextData(retryCondition,
+                originalRequest,
+                expectedServiceException,
+                EXPECTED_RETRY_COUNT);
+        verifyExpectedContextData(backoffStrategy,
+                originalRequest,
+                expectedServiceException,
+                EXPECTED_RETRY_COUNT);
+
+        // We also want to check the RequestCount metric is correctly captured.
+        Assert.assertEquals(
+                EXPECTED_RETRY_COUNT + 1, // request count = retries + 1
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+
+    /**
+     * Tests AmazonHttpClient's behavior upon simulated IOException during
+     * executing the http request when the request payload is repeatable.
+     */
+    @Test
+    public void testIOExceptioinHandling() {
+        // A mock HttpClient that always throws the specified IOException object
+        IOException simulatedIOException = new IOException("fake IOException");
+        injectMockHttpClient(testedClient, new ThrowingExceptionHttpClient(simulatedIOException));
+
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        Request<?> testedRepeatableRequest = getSampleRequestWithRepeatableContent(originalRequest);
+
+        // It should keep retrying until it reaches the max retry limit and
+        // throws the an ACE containing the simulated IOException.
+        AmazonClientException expectedClientException = null;
+        try {
+            testedClient.execute(testedRepeatableRequest,
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonClientException is expected.");
+        } catch (AmazonClientException ace) {
+            Assert.assertTrue(simulatedIOException == ace.getCause());
+            expectedClientException = ace;
+        }
+
+        // Verifies that the correct information was passed into the
+        // RetryCondition and BackoffStrategy
+        verifyExpectedContextData(retryCondition,
+                originalRequest,
+                expectedClientException,
+                EXPECTED_RETRY_COUNT);
+        verifyExpectedContextData(backoffStrategy,
+                originalRequest,
+                expectedClientException,
+                EXPECTED_RETRY_COUNT);
+
+        // We also want to check the RequestCount metric is correctly captured.
+        Assert.assertEquals(
+                EXPECTED_RETRY_COUNT + 1, // request count = retries + 1
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+
+    /**
+     * Tests AmazonHttpClient's behavior upon simulated service exceptions when
+     * the request payload is not repeatable.
+     */
+    @Test
+    public void testServiceExceptionHandlingWithNonRepeatableRequestContent() {
+        int random500StatusCode = 500 + random.nextInt(100);
+        String randomErrorCode = UUID.randomUUID().toString();
+
+        // A mock HttpClient that always returns the specified status and error
+        // code.
+        injectMockHttpClient(testedClient, new ReturnServiceErrorHttpClient(random500StatusCode,
+                randomErrorCode));
+
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        // A non-repeatable request
+        Request<?> testedNonRepeatableRequest = getSampleRequestWithNonRepeatableContent(originalRequest);
+
+        // It should fail directly and throw the ASE, without consulting the
+        // custom shouldRetry(..) method.
+        try {
+            testedClient.execute(testedNonRepeatableRequest,
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonServiceException is expected.");
+        } catch (AmazonServiceException ase) {
+            Assert.assertEquals(random500StatusCode, ase.getStatusCode());
+            Assert.assertEquals(randomErrorCode, ase.getErrorCode());
+        }
+
+        // Verifies that shouldRetry and calculateSleepTime were never called
+        verifyExpectedContextData(retryCondition,
+                null,
+                null,
+                0);
+        verifyExpectedContextData(backoffStrategy,
+                null,
+                null,
+                0);
+
+        // The captured RequestCount should be 1
+        Assert.assertEquals(
+                1,
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+
+    /**
+     * Tests AmazonHttpClient's behavior upon simulated IOException when the
+     * request payload is not repeatable.
+     */
+    @Test
+    public void testIOExceptionHandlingWithNonRepeatableRequestContent() {
+        // A mock HttpClient that always throws the specified IOException object
+        IOException simulatedIOException = new IOException("fake IOException");
+        injectMockHttpClient(testedClient, new ThrowingExceptionHttpClient(simulatedIOException));
+
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        // A non-repeatable request
+        Request<?> testedRepeatableRequest = getSampleRequestWithNonRepeatableContent(originalRequest);
+
+        // It should fail directly and throw an ACE containing the simulated
+        // IOException, without consulting the
+        // custom shouldRetry(..) method.
+        try {
+            testedClient.execute(testedRepeatableRequest,
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonClientException is expected.");
+        } catch (AmazonClientException ace) {
+            Assert.assertTrue(simulatedIOException == ace.getCause());
+        }
+
+        // Verifies that shouldRetry and calculateSleepTime were never called
+        verifyExpectedContextData(retryCondition,
+                null,
+                null,
+                0);
+        verifyExpectedContextData(backoffStrategy,
+                null,
+                null,
+                0);
+
+        // The captured RequestCount should be 1
+        Assert.assertEquals(
+                1,
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+
+    /**
+     * Tests AmazonHttpClient's behavior upon simulated RuntimeException (which
+     * should be handled as an unexpected failure and not retried).
+     */
+    @Test
+    public void testUnexpectedFailureHandling() {
+        // A mock HttpClient that always throws an NPE
+        NullPointerException simulatedNPE = new NullPointerException("fake NullPointerException");
+        injectMockHttpClient(testedClient, new ThrowingExceptionHttpClient(simulatedNPE));
+
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        Request<?> testedRepeatableRequest = getSampleRequestWithRepeatableContent(originalRequest);
+
+        // It should fail directly and throw the simulated NPE, without
+        // consulting the custom shouldRetry(..) method.
+        try {
+            testedClient.execute(testedRepeatableRequest,
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonClientException is expected.");
+        } catch (NullPointerException npe) {
+            Assert.assertTrue(simulatedNPE == npe);
+        }
+
+        // Verifies that shouldRetry and calculateSleepTime were never called
+        verifyExpectedContextData(retryCondition,
+                null,
+                null,
+                0);
+        verifyExpectedContextData(backoffStrategy,
+                null,
+                null,
+                0);
+
+        // The captured RequestCount should be 1
+        Assert.assertEquals(
+                1,
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/retry/ClientConfigurationMaxErrorRetryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/ClientConfigurationMaxErrorRetryTest.java
new file mode 100644
index 0000000000..1afdcf17e2
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/ClientConfigurationMaxErrorRetryTest.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.http.AmazonHttpClient;
+import com.amazonaws.http.ExecutionContext;
+import com.amazonaws.util.AWSRequestMetrics;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Random;
+
+/**
+ * Tests the behavior when both
+ * {@link ClientConfiguration#setMaxErrorRetry(int)} and
+ * {@link ClientConfiguration#setRetryPolicy(RetryPolicy)} are used.
+ */
+public class ClientConfigurationMaxErrorRetryTest extends RetryPolicyTestBase {
+
+    private static final Random random = new Random();
+
+    @Before
+    public void resetClientConfiguration() {
+        clientConfiguration = new ClientConfiguration();
+        testedClient = new AmazonHttpClient(clientConfiguration);
+        injectMockHttpClient(testedClient, new ReturnServiceErrorHttpClient(500,
+                "fake 500 service error"));
+    }
+
+    /**
+     * -- No explicit calls on ClientConfiguration#setMaxErrorRetry(int); --
+     * Default RetryPolicy's.
+     */
+    @Test
+    public void testDefaultMaxErrorRetry() {
+        /* SDK default */
+        Assert.assertTrue(clientConfiguration.getRetryPolicy() == PredefinedRetryPolicies.DEFAULT);
+
+        // Don't change any of the default settings in ClientConfiguration
+        testActualRetries(PredefinedRetryPolicies.DEFAULT_MAX_ERROR_RETRY);
+
+        /* DynamoDB default */
+        // Change to dynamodb default policy.
+        clientConfiguration.setRetryPolicy(PredefinedRetryPolicies.DYNAMODB_DEFAULT);
+        testActualRetries(PredefinedRetryPolicies.DYNAMODB_DEFAULT_MAX_ERROR_RETRY);
+    }
+
+    /**
+     * -- Explicitly set maxErrorRetry in ClientConfiguration level; --
+     * Default/custom RetryPolicy's that don't override such setting.
+     */
+    @Test
+    public void testClientConfigLevelMaxErrorRetry() {
+        int CLIENT_CONFIG_LEVEL_MAX_RETRY = random.nextInt(3);
+        clientConfiguration.setMaxErrorRetry(CLIENT_CONFIG_LEVEL_MAX_RETRY);
+
+        // SDK default policy should honor the ClientConfig level maxErrorRetry
+        testActualRetries(CLIENT_CONFIG_LEVEL_MAX_RETRY);
+
+        // DynamoDB default policy should also honor that
+        clientConfiguration.setRetryPolicy(PredefinedRetryPolicies.DYNAMODB_DEFAULT);
+        testActualRetries(CLIENT_CONFIG_LEVEL_MAX_RETRY);
+
+        // A custom policy that honors the ClientConfig level maxErrorRetry
+        clientConfiguration.setRetryPolicy(new RetryPolicy(null, null, 5, true));
+        testActualRetries(CLIENT_CONFIG_LEVEL_MAX_RETRY);
+    }
+
+    /**
+     * -- Explicitly set maxErrorRetry in ClientConfiguration level; -- Custom
+     * RetryPolicy's that want to override such setting.
+     */
+    @Test
+    public void testRetryPolicyLevelMaxErrorRetry() {
+        // This should be ignored
+        clientConfiguration.setMaxErrorRetry(random.nextInt(3));
+
+        // A custom policy that doesn't honor the ClientConfig level
+        // maxErrorRetry
+        int RETRY_POLICY_LEVEL_MAX_ERROR_RETRY = 5;
+        clientConfiguration.setRetryPolicy(new RetryPolicy(null, null,
+                RETRY_POLICY_LEVEL_MAX_ERROR_RETRY, false));
+        testActualRetries(RETRY_POLICY_LEVEL_MAX_ERROR_RETRY);
+
+        // A custom policy that "honors" the ClientConfig level maxErrorRetry,
+        // but actually denies any retry in its condition.
+        clientConfiguration.setRetryPolicy(new RetryPolicy(
+                new RetryPolicy.RetryCondition() {
+
+                    @Override
+                    public boolean shouldRetry(
+                            AmazonWebServiceRequest originalRequest,
+                            AmazonClientException exception,
+                            int retriesAttempted) {
+                        return false;
+                    }
+                }, null, RETRY_POLICY_LEVEL_MAX_ERROR_RETRY, true)
+                );
+        // No retry is expected
+        testActualRetries(0);
+    }
+
+    /**
+     * Verifies the request is actually retried for the expected times.
+     */
+    private static void testActualRetries(int expectedRetryAttempts) {
+        // The ExecutionContext should collect the expected RequestCount
+        ExecutionContext context = new ExecutionContext(true);
+
+        try {
+            testedClient.execute(getSampleRequestWithRepeatableContent(originalRequest),
+                    null,
+                    errorResponseHandler,
+                    context);
+            Assert.fail("AmazonServiceException is expected.");
+        } catch (AmazonServiceException ase) {
+        }
+
+        // Check the RequestCount metric equals the expected value.
+        Assert.assertEquals(
+                expectedRetryAttempts + 1, // request count = retries + 1
+                context.getAwsRequestMetrics()
+                        .getTimingInfo()
+                        .getCounter(AWSRequestMetrics.Field.RequestCount.toString()).intValue());
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/retry/NonRepeatableInputStream.java b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/NonRepeatableInputStream.java
new file mode 100644
index 0000000000..7252d96af9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/NonRepeatableInputStream.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.internal.SdkInputStream;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+class NonRepeatableInputStream extends SdkInputStream {
+
+    private final String nonRepeatableContent;
+    private int pos;
+
+    public NonRepeatableInputStream(String content) {
+        nonRepeatableContent = content;
+        pos = 0;
+    }
+
+    @Override
+    public int read() throws IOException {
+        if (pos >= nonRepeatableContent.length())
+            return -1;
+        return nonRepeatableContent.charAt(pos++);
+    }
+
+    @Override
+    protected InputStream getWrappedInputStream() {
+        return null;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryPolicyTestBase.java b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryPolicyTestBase.java
new file mode 100644
index 0000000000..b9d8133c2d
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryPolicyTestBase.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.retry;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+import com.amazonaws.http.AmazonHttpClient;
+import com.amazonaws.http.HttpClient;
+import com.amazonaws.http.HttpRequest;
+import com.amazonaws.http.HttpResponse;
+import com.amazonaws.http.HttpResponseHandler;
+import com.amazonaws.util.StringInputStream;
+
+import org.junit.Assert;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Field;
+import java.net.URI;
+import java.util.LinkedList;
+import java.util.List;
+
+/** Some utility class and method for testing RetryCondition */
+public class RetryPolicyTestBase {
+
+    protected static ClientConfiguration clientConfiguration = new ClientConfiguration();
+    protected static AmazonHttpClient testedClient = new AmazonHttpClient(clientConfiguration);
+    protected static final AmazonWebServiceRequest originalRequest = new TestAmazonWebServiceRequest();
+    protected static final HttpResponseHandler<AmazonServiceException> errorResponseHandler = new TestHttpResponseHandler();
+
+    /**
+     * The retry condition and back-off strategy implementations that record all
+     * the context data passed into shouldRetry and calculateSleepTime methods.
+     */
+    protected static ContextDataCollectionRetryCondition retryCondition;
+    protected static ContextDataCollectionBackoffStrategy backoffStrategy;
+
+    public static void injectMockHttpClient(AmazonHttpClient amazonHttpClient,
+            HttpClient mockHttpClient) {
+        try {
+            Field f = AmazonHttpClient.class.getDeclaredField("httpClient");
+            f.setAccessible(true);
+            f.set(amazonHttpClient, mockHttpClient);
+        } catch (Exception e) {
+            Assert.fail("Cannot inject the mock HttpClient object. " + e.getMessage());
+        }
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static Request<?> getSampleRequestWithRepeatableContent(
+            AmazonWebServiceRequest amazonWebServiceRequest) {
+        DefaultRequest<?> request = new DefaultRequest(
+                amazonWebServiceRequest, "non-existent-service");
+        request.setEndpoint(URI.create("http://non-existent-service.amazonaws.com"));
+        // StringInputStream#markSupported() returns true
+        try {
+            String content = "Some content that could be read for multiple times.";
+            request.setContent(new StringInputStream(content));
+            request.addHeader("Content-Length", String.valueOf(content.length()));
+        } catch (UnsupportedEncodingException e) {
+            Assert.fail("Unable to set up the request content");
+        }
+        return request;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static Request<?> getSampleRequestWithNonRepeatableContent(
+            AmazonWebServiceRequest amazonWebServiceRequest) {
+        DefaultRequest<?> request = new DefaultRequest(
+                amazonWebServiceRequest, "non-existent-service");
+        request.setEndpoint(URI.create("http://non-existent-service.amazonaws.com"));
+        // NonRepeatableInputStream#markSupported() returns false
+        String content = "Some content that could only be read once.";
+        request.setContent(new NonRepeatableInputStream(content));
+        request.addHeader("Content-Length", String.valueOf(content.length()));
+        return request;
+    }
+
+    public static class ContextDataCollectionRetryCondition extends
+            ContextDataCollection implements RetryPolicy.RetryCondition {
+
+        @Override
+        public boolean shouldRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retriesAttempted) {
+            collect(originalRequest, exception, retriesAttempted);
+            return true;
+        }
+    }
+
+    public static class ContextDataCollectionBackoffStrategy extends
+            ContextDataCollection implements RetryPolicy.BackoffStrategy {
+
+        @Override
+        public long delayBeforeNextRetry(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception,
+                int retriesAttempted) {
+            collect(originalRequest, exception, retriesAttempted);
+            return 0; // immediately retry to speed-up the test
+        }
+    }
+
+    private static class ContextDataCollection {
+
+        public List<AmazonWebServiceRequest> failedRequests = new LinkedList<AmazonWebServiceRequest>();
+        public List<AmazonClientException> exceptions = new LinkedList<AmazonClientException>();
+        public List<Integer> retriesAttemptedValues = new LinkedList<Integer>();
+
+        public void collect(AmazonWebServiceRequest originalRequest,
+                AmazonClientException exception, int retriesAttempted) {
+            failedRequests.add(originalRequest);
+            exceptions.add(exception);
+            retriesAttemptedValues.add(retriesAttempted);
+        }
+    }
+
+    /**
+     * Verifies the RetryCondition has collected the expected context
+     * information.
+     */
+    public static void verifyExpectedContextData(ContextDataCollection contextDataCollection,
+            AmazonWebServiceRequest failedRequest,
+            AmazonClientException expectedException,
+            int expectedRetries) {
+
+        Assert.assertEquals(expectedRetries, contextDataCollection.failedRequests.size());
+        Assert.assertEquals(expectedRetries, contextDataCollection.exceptions.size());
+        Assert.assertEquals(expectedRetries, contextDataCollection.retriesAttemptedValues.size());
+
+        if (expectedRetries > 0) {
+            // It should keep getting the same original request instance
+            for (AmazonWebServiceRequest seenRequest : contextDataCollection.failedRequests) {
+                Assert.assertTrue(seenRequest == failedRequest);
+            }
+
+            // Verify the exceptions
+            if (expectedException instanceof AmazonServiceException) {
+                // It should get service exceptions with the expected error and
+                // status code
+                AmazonServiceException ase = (AmazonServiceException) expectedException;
+                for (AmazonClientException seenException : contextDataCollection.exceptions) {
+                    Assert.assertTrue(seenException instanceof AmazonServiceException);
+                    Assert.assertEquals(ase.getErrorCode(),
+                            ((AmazonServiceException) seenException).getErrorCode());
+                    Assert.assertEquals(ase.getStatusCode(),
+                            ((AmazonServiceException) seenException).getStatusCode());
+                }
+            } else {
+                // Client exceptions should have the same expected cause (the
+                // same
+                // throwable instance from the mock HttpClient).
+                Throwable expectedCause = expectedException.getCause();
+                for (AmazonClientException seenException : contextDataCollection.exceptions) {
+                    Assert.assertTrue(expectedCause == seenException.getCause());
+                }
+            }
+
+            // It should get "retriesAttempted" values starting from 0
+            int expectedRetriesAttempted = 0;
+            for (int seenRetriesAttempted : contextDataCollection.retriesAttemptedValues) {
+                Assert.assertEquals(expectedRetriesAttempted++, seenRetriesAttempted);
+            }
+        }
+
+    }
+
+    public static class TestAmazonWebServiceRequest extends AmazonWebServiceRequest {
+    }
+
+    /**
+     * An error response handler implementation that simply - keeps the status
+     * code - sets the error code by the status text (which comes from the
+     * reason phrase in the low-level response)
+     */
+    public static class TestHttpResponseHandler implements
+            HttpResponseHandler<AmazonServiceException> {
+
+        @Override
+        public AmazonServiceException handle(
+                com.amazonaws.http.HttpResponse response) throws Exception {
+            AmazonServiceException ase = new AmazonServiceException("Fake service exception.");
+            ase.setStatusCode(response.getStatusCode());
+            ase.setErrorCode(response.getStatusText());
+            return ase;
+        }
+
+        @Override
+        public boolean needsConnectionLeftOpen() {
+            return false;
+        }
+    }
+
+    /**
+     * A mock HttpClient implementation that does nothing but throws the
+     * specified IOException or RuntimeException upon any call on execute(...)
+     * method.
+     */
+    public static class ThrowingExceptionHttpClient implements HttpClient {
+
+        private final Throwable t;
+
+        /**
+         * @param t An IOException or RuntimeException object.
+         */
+        public ThrowingExceptionHttpClient(Throwable t) {
+            this.t = t;
+        }
+
+        @Override
+        public HttpResponse execute(HttpRequest request) throws IOException {
+            if (t instanceof IOException) {
+                throw (IOException) t;
+            } else if (t instanceof RuntimeException) {
+                throw (RuntimeException) t;
+            } else {
+                Assert.fail("The expected throwable should be either an IOException or RuntimeException.");
+                return null;
+            }
+        }
+
+        @Override
+        public void shutdown() {
+            // No op
+        }
+    }
+
+    /**
+     * A mock HttpClient implementation that does nothing but directly returns a
+     * BasicHttpResponse object with the specified status code upon any call on
+     * execute(...) method.
+     */
+    public static class ReturnServiceErrorHttpClient implements HttpClient {
+
+        private final int statusCode;
+        private final String reasonPhrase;
+
+        /**
+         * @param statusCode The status code to be included in the error
+         *            response.
+         */
+        public ReturnServiceErrorHttpClient(int statusCode, String reasonPhrase) {
+            this.statusCode = statusCode;
+            this.reasonPhrase = reasonPhrase;
+        }
+
+        @Override
+        public HttpResponse execute(HttpRequest request) throws IOException {
+            return HttpResponse.builder()
+                    .statusCode(statusCode)
+                    .statusText(reasonPhrase)
+                    .build();
+        }
+
+        @Override
+        public void shutdown() {
+            // No op
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryUtilsTest.java
new file mode 100644
index 0000000000..ac2bbe9f32
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/retry/RetryUtilsTest.java
@@ -0,0 +1,25 @@
+package com.amazonaws.retry;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AbortedException;
+
+import org.junit.Test;
+
+import java.io.InterruptedIOException;
+import java.net.SocketTimeoutException;
+
+public class RetryUtilsTest {
+
+    @Test
+    public void testIsInterruptedException() {
+        assertTrue(RetryUtils.isInterrupted(new AbortedException()));
+        Exception interrupted = new Exception(new InterruptedException());
+        assertTrue(RetryUtils.isInterrupted(interrupted));
+        Exception interruptedio = new Exception(new InterruptedIOException());
+        assertTrue(RetryUtils.isInterrupted(interruptedio));
+        Exception socketTimeout = new Exception(new SocketTimeoutException());
+        assertFalse(RetryUtils.isInterrupted(socketTimeout));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonExceptionUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonExceptionUnmarshallerTest.java
new file mode 100644
index 0000000000..05f8f3b81a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonExceptionUnmarshallerTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.http.HttpResponse;
+import com.amazonaws.http.JsonErrorResponseHandler.JsonErrorResponse;
+import com.amazonaws.transform.JsonErrorUnmarshaller;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+
+public class JsonExceptionUnmarshallerTest {
+
+    String errorResponse = "{\"__type\":\"com.amazonaws.javaSDK#InternalServerError\",\"message\":\"Requested resource not found\",\"field1\":\"value1\",\"Field2\":\"value2\"}";
+
+    @Test
+    public void testJsonExceptionUnmarshallerWithAdditionalFields() throws Exception {
+        HttpResponse response = HttpResponse.builder()
+                .content(new ByteArrayInputStream(errorResponse.getBytes("UTF-8")))
+                .build();
+
+        JsonErrorResponse error = JsonErrorResponse.fromResponse(response);
+        AmazonServiceException ase = new InternalServerErrorExceptionUnmarshaller()
+                .unmarshall(error);
+
+        assertTrue(ase instanceof InternalServerErrorException);
+        assertEquals("value1", ((InternalServerErrorException) ase).getField1());
+        assertEquals("value2", ((InternalServerErrorException) ase).getField2());
+        assertEquals("InternalServerError", ase.getErrorCode());
+
+        assertEquals("Requested resource not found "
+                + "(Service: null; "
+                + "Status Code: 0; "
+                + "Error Code: InternalServerError; "
+                + "Request ID: null)",
+                ase.getMessage());
+
+    }
+
+    public static class InternalServerErrorExceptionUnmarshaller extends JsonErrorUnmarshaller {
+
+        public InternalServerErrorExceptionUnmarshaller() {
+            super(InternalServerErrorException.class);
+        }
+
+        @Override
+        public AmazonServiceException unmarshall(JsonErrorResponse error) throws Exception {
+            // Bail out if this isn't the right error code that this
+            // marshaller understands.
+            String errorCode = error.getErrorCode();
+            if (errorCode == null || !errorCode.equals("InternalServerError"))
+                return null;
+
+            InternalServerErrorException e = (InternalServerErrorException) super.unmarshall(error);
+
+            e.setField1(error.get("field1"));
+
+            e.setField2(error.get("field2"));
+
+            return e;
+        }
+    }
+
+    public static class InternalServerErrorException extends AmazonServiceException {
+        private static final long serialVersionUID = 1L;
+
+        private String field1;
+
+        private String field2;
+
+        /**
+         * Constructs a new InternalServerErrorException with the specified
+         * error message.
+         *
+         * @param message Describes the error encountered.
+         */
+        public InternalServerErrorException(String message) {
+            super(message);
+        }
+
+        /**
+         * Returns the value of the Field1 property for this object.
+         *
+         * @return The value of the Field1 property for this object.
+         */
+        public String getField1() {
+            return field1;
+        }
+
+        /**
+         * Sets the value of the Field1 property for this object.
+         *
+         * @param field1 The new value for this object's Field1 property.
+         */
+        public void setField1(String field1) {
+            this.field1 = field1;
+        }
+
+        /**
+         * Returns the value of the Field2 property for this object.
+         *
+         * @return The value of the Field2 property for this object.
+         */
+        public String getField2() {
+            return field2;
+        }
+
+        /**
+         * Sets the value of the Field2 property for this object.
+         *
+         * @param field2 The new value for this object's Field2 property.
+         */
+        public void setField2(String field2) {
+            this.field2 = field2;
+        }
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonUnmarshallerTest.java
new file mode 100644
index 0000000000..4989982d79
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/JsonUnmarshallerTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.transform.JsonUnmarshallerContext;
+import com.amazonaws.transform.ListUnmarshaller;
+import com.amazonaws.transform.MapUnmarshaller;
+import com.amazonaws.transform.SimpleTypeJsonUnmarshallers;
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.JsonUtils;
+
+import org.junit.Test;
+
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+public class JsonUnmarshallerTest {
+    public static final String SIMPLE_MAP = "{\"key1\" : \"value1\", \"key2\" : \"value2\"}";
+    public static final String MAP_TO_LIST = "{\"key1\" : [ null, \"value1\"], \"key2\" : [\"value2\"]}";
+
+    @Test
+    public void testSimpleMap() throws Exception {
+        JsonUnmarshallerContext unmarshallerContext = setupUnmarshaller(SIMPLE_MAP);
+        MapUnmarshaller<String> unmarshaller = new MapUnmarshaller<String>(
+                SimpleTypeJsonUnmarshallers.StringJsonUnmarshaller.getInstance());
+        Map<String, String> map = unmarshaller.unmarshall(unmarshallerContext);
+        assertTrue(map.size() == 2);
+        assertEquals("value1", map.get("key1"));
+        assertEquals("value2", map.get("key2"));
+    }
+
+    @Test
+    public void testMapToList() throws Exception {
+        JsonUnmarshallerContext unmarshallerContext = setupUnmarshaller(MAP_TO_LIST);
+        MapUnmarshaller<List<String>> unmarshaller =
+                new MapUnmarshaller<List<String>>(
+                        new ListUnmarshaller<String>(
+                                SimpleTypeJsonUnmarshallers.StringJsonUnmarshaller.getInstance()));
+        Map<String, List<String>> map = unmarshaller.unmarshall(unmarshallerContext);
+        assertTrue(map.size() == 2);
+        assertEquals(Arrays.asList(null, "value1"), map.get("key1"));
+        assertEquals(Arrays.asList("value2"), map.get("key2"));
+    }
+
+    private JsonUnmarshallerContext setupUnmarshaller(String snippet) throws Exception {
+        AwsJsonReader jsonReader = JsonUtils.getJsonReader(new StringReader(snippet));
+        JsonUnmarshallerContext unmarshallerContext = new JsonUnmarshallerContext(jsonReader);
+        return unmarshallerContext;
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/LegacyErrorUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/LegacyErrorUnmarshallerTest.java
new file mode 100644
index 0000000000..ab54d7dfdb
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/LegacyErrorUnmarshallerTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.transform.LegacyErrorUnmarshaller;
+import com.sun.org.apache.xerces.internal.dom.DocumentImpl;
+
+import org.junit.Test;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+import javax.xml.transform.TransformerFactoryConfigurationError;
+
+public class LegacyErrorUnmarshallerTest {
+
+    @Test
+    public void testUnmarshall() throws TransformerFactoryConfigurationError, Exception {
+
+        Document xmlDoc = new DocumentImpl();
+        Element root = xmlDoc.createElement("Response");
+
+        Element requestId = xmlDoc.createElement("RequestID");
+
+        requestId.appendChild(xmlDoc.createTextNode("TestId"));
+
+        Element errors = xmlDoc.createElement("Errors");
+        Element error = xmlDoc.createElement("Error");
+        Element message = xmlDoc.createElement("Message");
+        message.appendChild(xmlDoc.createTextNode("TestMessage"));
+        Element type = xmlDoc.createElement("Type");
+        type.appendChild(xmlDoc.createTextNode("server"));
+        Element code = xmlDoc.createElement("Code");
+        code.appendChild(xmlDoc.createTextNode("TestCode"));
+
+        error.appendChild(message);
+        error.appendChild(type);
+        error.appendChild(code);
+        errors.appendChild(error);
+        root.appendChild(errors);
+        root.appendChild(requestId);
+
+        xmlDoc.appendChild(root);
+
+        LegacyErrorUnmarshaller leu = new LegacyErrorUnmarshaller();
+        AmazonServiceException ase = leu.unmarshall(xmlDoc);
+        assertEquals(ase.getErrorCode(), "TestCode");
+        assertEquals(ase.getErrorMessage(), "TestMessage");
+        assertEquals(ase.getErrorType(), ErrorType.Service);
+        assertEquals(ase.getRequestId(), "TestId");
+    }
+
+    @Test
+    public void testGetErrorPropertyPath() {
+        LegacyErrorUnmarshaller leu = new LegacyErrorUnmarshaller();
+        assertEquals(leu.getErrorPropertyPath("Property"), "Response/Errors/Error/Property");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/MapEntryTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/MapEntryTest.java
new file mode 100644
index 0000000000..62ae0e83b3
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/MapEntryTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+public class MapEntryTest {
+
+    @Test
+    public void testMapEntry() {
+        MapEntry<String, String> me = new MapEntry<String, String>();
+        me.setKey("Key");
+        me.setValue("Value");
+        assertEquals(me.getKey(), "Key");
+        assertEquals(me.getValue(), "Value");
+
+        assertTrue(me instanceof java.util.Map.Entry);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallerTest.java
new file mode 100644
index 0000000000..e958249e76
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeJsonUnmarshallerTest.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.util.Base64;
+import com.amazonaws.util.StringUtils;
+import com.amazonaws.util.json.AwsJsonReader;
+import com.amazonaws.util.json.AwsJsonWriter;
+import com.amazonaws.util.json.JsonUtils;
+
+import org.junit.Test;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+public class SimpleTypeJsonUnmarshallerTest {
+
+    @Test
+    public void testBigDecimalJsonUnmarshaller() throws Exception {
+        BigDecimal bd = new BigDecimal("1.5");
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("bd");
+        jw.value(bd.toPlainString());
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.BigDecimalJsonUnmarshaller bdUnmarshaller = SimpleTypeJsonUnmarshallers.BigDecimalJsonUnmarshaller
+                .getInstance();
+        BigDecimal unmarshalledBD = bdUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledBD.toPlainString(), bd.toPlainString());
+    }
+
+    @Test
+    public void testBigIntegerJsonUnmarshaller() throws Exception {
+        BigInteger bi = new BigInteger("13459712934871293847891231293874");
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("bi");
+        jw.value(bi.toString());
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.BigIntegerJsonUnmarshaller biUnmarshaller = SimpleTypeJsonUnmarshallers.BigIntegerJsonUnmarshaller
+                .getInstance();
+        BigInteger unmarshalledBI = biUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledBI.toString(), bi.toString());
+    }
+
+    @Test
+    public void testBooleanJsonUnmarshaller() throws Exception {
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("boolean");
+        jw.value("true");
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.BooleanJsonUnmarshaller bUnmarshaller = SimpleTypeJsonUnmarshallers.BooleanJsonUnmarshaller
+                .getInstance();
+        Boolean unmarshalledB = bUnmarshaller.unmarshall(context);
+
+        assertTrue(unmarshalledB);
+    }
+
+    @Test
+    public void testByteBufferJsonUnmarshaller() throws Exception {
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("bb");
+        jw.value(Base64.encodeAsString("byte".getBytes(StringUtils.UTF8)));
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.ByteBufferJsonUnmarshaller bbUnmarshaller = SimpleTypeJsonUnmarshallers.ByteBufferJsonUnmarshaller
+                .getInstance();
+        ByteBuffer unmarshalledBb = bbUnmarshaller.unmarshall(context);
+        ByteBuffer expected = ByteBuffer.wrap("byte".getBytes(StringUtils.UTF8));
+        assertTrue(unmarshalledBb.equals(expected));
+    }
+
+    @Test
+    public void testByteJsonUnmarshaller() throws Exception {
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("b");
+        jw.value(Byte.valueOf("127"));
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.ByteJsonUnmarshaller bUnmarshaller = SimpleTypeJsonUnmarshallers.ByteJsonUnmarshaller
+                .getInstance();
+        Byte unmarshalledB = bUnmarshaller.unmarshall(context);
+        Byte expected = Byte.valueOf("127");
+        assertTrue(unmarshalledB.equals(expected));
+    }
+
+    @Test
+    public void testDateJsonUnmarshaller() throws Exception {
+        Date date = new Date();
+        date.setTime(1000);
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("date");
+        jw.value(date);
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.DateJsonUnmarshaller dateUnmarshaller = SimpleTypeJsonUnmarshallers.DateJsonUnmarshaller
+                .getInstance();
+        Date unmarshalledDate = dateUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledDate.getTime(), date.getTime());
+    }
+
+    @Test
+    public void testDoubleJsonUnmarshaller() throws Exception {
+        Double dub = new Double(5.5);
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("dub");
+        jw.value(dub);
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.DoubleJsonUnmarshaller dubUnmarshaller = SimpleTypeJsonUnmarshallers.DoubleJsonUnmarshaller
+                .getInstance();
+        Double unmarshalledDub = dubUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledDub.doubleValue(), 5.5, .001);
+    }
+
+    @Test
+    public void testFloatJsonUnmarshaller() throws Exception {
+        Float f = new Float(5.5);
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("f");
+        jw.value(f);
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.FloatJsonUnmarshaller fUnmarshaller = SimpleTypeJsonUnmarshallers.FloatJsonUnmarshaller
+                .getInstance();
+        Float unmarshalledF = fUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledF.floatValue(), 5.5, .001);
+    }
+
+    @Test
+    public void testIntegerJsonUnmarshaller() throws Exception {
+        Integer i = new Integer(5);
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("i");
+        jw.value(i);
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.IntegerJsonUnmarshaller iUnmarshaller = SimpleTypeJsonUnmarshallers.IntegerJsonUnmarshaller
+                .getInstance();
+        Integer unmarshalledI = iUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledI.intValue(), 5);
+    }
+
+    @Test
+    public void testLongJsonUnmarshaller() throws Exception {
+        Long l = new Long(5L);
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("l");
+        jw.value(l);
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.LongJsonUnmarshaller lUnmarshaller = SimpleTypeJsonUnmarshallers.LongJsonUnmarshaller
+                .getInstance();
+        Long unmarshalledL = lUnmarshaller.unmarshall(context);
+        assertEquals(unmarshalledL.longValue(), 5L);
+    }
+
+    @Test
+    public void testStringJsonUnmarshaller() throws Exception {
+
+        StringWriter sw = new StringWriter();
+        AwsJsonWriter jw = JsonUtils.getJsonWriter(sw);
+        jw.beginObject();
+        jw.name("s");
+        jw.value("String");
+        jw.endObject();
+        String json = sw.toString();
+
+        StringReader sr = new StringReader(json);
+        AwsJsonReader jr = JsonUtils.getJsonReader(sr);
+        JsonUnmarshallerContext context = new JsonUnmarshallerContext(jr);
+        context.getReader().beginObject();
+        context.getReader().nextName();
+
+        SimpleTypeJsonUnmarshallers.StringJsonUnmarshaller sUnmarshaller = SimpleTypeJsonUnmarshallers.StringJsonUnmarshaller
+                .getInstance();
+        assertEquals(sUnmarshaller.unmarshall(context), "String");
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallerTest.java
new file mode 100644
index 0000000000..28c00b766a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/SimpleTypeStaxUnmarshallerTest.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import com.amazonaws.AmazonClientException;
+import com.amazonaws.util.Base64;
+import com.amazonaws.util.DateUtils;
+import com.amazonaws.util.StringUtils;
+
+import org.junit.Test;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.util.Date;
+
+public class SimpleTypeStaxUnmarshallerTest {
+
+    /** Shared factory for creating XML event readers */
+    private static final XmlPullParserFactory xmlPullParserFactory;
+    static {
+        try {
+            xmlPullParserFactory = XmlPullParserFactory.newInstance();
+        } catch (XmlPullParserException xppe) {
+            throw new AmazonClientException("Couldn't initialize XmlPullParserFactory", xppe);
+        }
+    }
+
+    @Test
+    public void testBigDecimalStaxUnmarshaller() throws Exception {
+        BigDecimal bd = new BigDecimal("1.5");
+
+        SimpleTypeStaxUnmarshallers.BigDecimalStaxUnmarshaller bdUnmarshaller = SimpleTypeStaxUnmarshallers.BigDecimalStaxUnmarshaller
+                .getInstance();
+        BigDecimal unmarshalledBD = bdUnmarshaller.unmarshall(getContext(bd.toPlainString()));
+        assertEquals(unmarshalledBD.toPlainString(), bd.toPlainString());
+    }
+
+    @Test
+    public void testBigIntegerStaxUnmarshaller() throws Exception {
+        BigInteger data = new BigInteger("1534523");
+
+        SimpleTypeStaxUnmarshallers.BigIntegerStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.BigIntegerStaxUnmarshaller
+                .getInstance();
+        BigInteger unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertEquals(unmarshalled.intValue(), 1534523);
+    }
+
+    @Test
+    public void testBooleanStaxUnmarshaller() throws Exception {
+        Boolean data = new Boolean(true);
+
+        SimpleTypeStaxUnmarshallers.BooleanStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.BooleanStaxUnmarshaller
+                .getInstance();
+        Boolean unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertTrue(unmarshalled);
+    }
+
+    @Test
+    public void testByteBufferStaxUnmarshaller() throws Exception {
+        SimpleTypeStaxUnmarshallers.ByteBufferStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.ByteBufferStaxUnmarshaller
+                .getInstance();
+        ByteBuffer unmarshalled = unmarshaller.unmarshall(getContext(Base64.encodeAsString("byte"
+                .getBytes(StringUtils.UTF8))));
+        assertEquals(unmarshalled, ByteBuffer.wrap("byte".getBytes(StringUtils.UTF8)));
+    }
+
+    @Test
+    public void testByteStaxUnmarshaller() throws Exception {
+        SimpleTypeStaxUnmarshallers.ByteStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.ByteStaxUnmarshaller
+                .getInstance();
+        Byte unmarshalled = unmarshaller.unmarshall(getContext("127"));
+        assertEquals(unmarshalled, Byte.valueOf("127"));
+    }
+
+    @Test
+    public void testDateStaxUnmarshaller() throws Exception {
+        Date data = new Date(1000);
+
+        SimpleTypeStaxUnmarshallers.DateStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.DateStaxUnmarshaller
+                .getInstance();
+        Date unmarshalled = unmarshaller.unmarshall(getContext(DateUtils.formatISO8601Date(data)));
+        assertEquals(unmarshalled.getTime(), data.getTime());
+    }
+
+    @Test
+    public void testDoubleStaxUnmarshaller() throws Exception {
+        Double data = new Double(1000.0);
+
+        SimpleTypeStaxUnmarshallers.DoubleStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.DoubleStaxUnmarshaller
+                .getInstance();
+        Double unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertEquals(unmarshalled, 1000.0, .01);
+    }
+
+    @Test
+    public void testLongStaxUnmarshaller() throws Exception {
+        Long data = new Long(1000L);
+
+        SimpleTypeStaxUnmarshallers.LongStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.LongStaxUnmarshaller
+                .getInstance();
+        Long unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertEquals(unmarshalled, Long.valueOf(1000L));
+    }
+
+    @Test
+    public void testIntegerStaxUnmarshaller() throws Exception {
+        Integer data = new Integer(1000);
+
+        SimpleTypeStaxUnmarshallers.IntegerStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.IntegerStaxUnmarshaller
+                .getInstance();
+        Integer unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertEquals(unmarshalled, new Integer(1000));
+    }
+
+    @Test
+    public void testFloatStaxUnmarshaller() throws Exception {
+        Float data = new Float(1000.0);
+
+        SimpleTypeStaxUnmarshallers.FloatStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.FloatStaxUnmarshaller
+                .getInstance();
+        Float unmarshalled = unmarshaller.unmarshall(getContext(data.toString()));
+        assertEquals(unmarshalled, new Float(1000.0));
+    }
+
+    @Test
+    public void testStringStaxUnmarshaller() throws Exception {
+        SimpleTypeStaxUnmarshallers.StringStaxUnmarshaller unmarshaller = SimpleTypeStaxUnmarshallers.StringStaxUnmarshaller
+                .getInstance();
+        String unmarshalled = unmarshaller.unmarshall(getContext("String"));
+        assertEquals(unmarshalled, "String");
+    }
+
+    private StaxUnmarshallerContext getContext(String elementData) throws XmlPullParserException,
+            IOException {
+        XmlPullParser xpp = xmlPullParserFactory.newPullParser();
+        String xml = "<tag>" + elementData + "</tag>";
+        StringReader sr = new StringReader(xml);
+        xpp.setInput(sr);
+
+        StaxUnmarshallerContext suc = new StaxUnmarshallerContext(xpp);
+        suc.nextEvent();
+        return suc;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StandardErrorUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StandardErrorUnmarshallerTest.java
new file mode 100644
index 0000000000..8613afa35f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StandardErrorUnmarshallerTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+
+import com.amazonaws.AmazonServiceException;
+import com.amazonaws.AmazonServiceException.ErrorType;
+import com.amazonaws.transform.StandardErrorUnmarshaller;
+import com.sun.org.apache.xerces.internal.dom.DocumentImpl;
+
+import org.junit.Test;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+import javax.xml.transform.TransformerFactoryConfigurationError;
+
+public class StandardErrorUnmarshallerTest {
+
+    @Test
+    public void testUnmarshall() throws TransformerFactoryConfigurationError, Exception {
+
+        Document xmlDoc = new DocumentImpl();
+        Element root = xmlDoc.createElement("ErrorResponse");
+
+        Element requestId = xmlDoc.createElement("RequestId");
+
+        requestId.appendChild(xmlDoc.createTextNode("TestId"));
+
+        Element error = xmlDoc.createElement("Error");
+        Element message = xmlDoc.createElement("Message");
+        message.appendChild(xmlDoc.createTextNode("TestMessage"));
+        Element type = xmlDoc.createElement("Type");
+        type.appendChild(xmlDoc.createTextNode("Receiver"));
+
+        error.appendChild(message);
+        error.appendChild(type);
+        root.appendChild(error);
+        root.appendChild(requestId);
+
+        xmlDoc.appendChild(root);
+
+        StandardErrorUnmarshaller seu = new StandardErrorUnmarshaller();
+        AmazonServiceException ase = seu.unmarshall(xmlDoc);
+        assertEquals(ase.getErrorMessage(), "TestMessage");
+        assertEquals(ase.getErrorType(), ErrorType.Service);
+        assertEquals(ase.getRequestId(), "TestId");
+
+        Element code = xmlDoc.createElement("Code");
+        code.appendChild(xmlDoc.createTextNode("TestCode"));
+    }
+
+    @Test
+    public void testParseErrorCode() throws Exception {
+        Document xmlDoc = new DocumentImpl();
+        Element root = xmlDoc.createElement("ErrorResponse");
+        Element error = xmlDoc.createElement("Error");
+        Element code = xmlDoc.createElement("Code");
+
+        code.appendChild(xmlDoc.createTextNode("TestCode"));
+
+        error.appendChild(code);
+        root.appendChild(error);
+        xmlDoc.appendChild(root);
+
+        StandardErrorUnmarshaller seu = new StandardErrorUnmarshaller();
+        assertEquals("TestCode", seu.parseErrorCode(xmlDoc));
+    }
+
+    @Test
+    public void testGetPropertyPath() {
+        StandardErrorUnmarshaller seu = new StandardErrorUnmarshaller();
+        assertEquals(seu.getErrorPropertyPath("Property"), "ErrorResponse/Error/Property");
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StaxUnmarshallerContextTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StaxUnmarshallerContextTest.java
new file mode 100644
index 0000000000..6116b53aac
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/StaxUnmarshallerContextTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.HashMap;
+import java.util.Map;
+
+public class StaxUnmarshallerContextTest {
+    private static final XmlPullParserFactory factory;
+    static {
+        try {
+            factory = XmlPullParserFactory.newInstance();
+        } catch (XmlPullParserException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static final String XML_STRING =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+                    + "<DescribeImagesResponse xmlns=\"http://ec2.amazonaws.com/doc/2014-05-01/\">"
+                    + "  <requestId>12345</requestId>"
+                    + "  <architecture>architecture value</architecture>"
+                    + "  <imageSet>"
+                    + "    <item>"
+                    + "      <id>id</id>"
+                    + "    </item>"
+                    + "    <item>"
+                    + "      <id>id</id>"
+                    + "    </item>"
+                    + "  </imageSet>"
+                    + "</DescribeImagesResponse>";
+
+    private StaxUnmarshallerContext context;
+
+    private StaxUnmarshallerContext getContext(String xml, Map<String, String> headers)
+            throws Exception {
+        XmlPullParser xpp = factory.newPullParser();
+        Reader reader = new StringReader(xml);
+        xpp.setInput(reader);
+        return new StaxUnmarshallerContext(xpp, headers);
+    }
+
+    @Test
+    public void testParse() throws Exception {
+        context = getContext(XML_STRING, null);
+        assertTrue("start of document", context.isStartOfDocument());
+
+        // test nextEvent(), getCurrentDepth(), and readText()
+        assertTrue("/DescribeImagesResponse", context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 1);
+        assertTrue("/DescribeImagesResponse/requestId",
+                context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 2);
+        assertEquals("requestId", "12345", context.readText());
+        assertTrue("depth reduced by 1 after readText()", context.getCurrentDepth() == 1);
+
+        assertTrue("/DescribeImagesResponse/architecture",
+                context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 2);
+        assertEquals("architecture", "architecture value", context.readText());
+
+        assertTrue("/DescribeImagesResponse/imageSet",
+                context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 2);
+        assertTrue("/DescribeImagesResponse/imageSet/item",
+                context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 3);
+        assertTrue("/DescribeImagesResponse/imageSet/item/id",
+                context.nextEvent() == XmlPullParser.START_TAG);
+        assertTrue(context.getCurrentDepth() == 4);
+
+        // test testExpression
+        assertTrue(". always match", context.testExpression(".", 4));
+        assertTrue(context.testExpression("id", 4));
+        assertTrue("default is current depth", context.testExpression("id"));
+        assertTrue(context.testExpression("item/id", 3));
+        assertTrue(context.testExpression("imageSet/item/id", 2));
+        assertFalse("depth not match", context.testExpression("imageSet/item/id", 3));
+        assertFalse("expression not match", context.testExpression("imageSet/item_id", 2));
+    }
+
+    @Test
+    public void testMetadata() throws Exception {
+        String key = "AWS_REQUEST_ID";
+        context = getContext(XML_STRING, null);
+        context.registerMetadataExpression("ResponseMetadata/RequestId", 2, key);
+        context.registerMetadataExpression("requestId", 2, key);
+        while (context.nextEvent() != XmlPullParser.END_DOCUMENT)
+            ;
+        assertNotNull(context.getMetadata().get(key));
+        assertEquals("request id", "12345", context.getMetadata().get(key));
+    }
+
+    @Test
+    public void testHeader() throws Exception {
+        Map<String, String> headers = new HashMap<String, String>();
+        headers.put("key", "value");
+        context = getContext("", headers);
+        assertNull("non existing key", context.getHeader("invalid key"));
+        assertEquals("header value", "value", context.getHeader("key"));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/transform/VoidStaxUnmarshallerTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/VoidStaxUnmarshallerTest.java
new file mode 100644
index 0000000000..c978226bd9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/transform/VoidStaxUnmarshallerTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.transform;
+
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.AmazonClientException;
+
+import org.junit.Test;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+public class VoidStaxUnmarshallerTest {
+
+    /** Shared factory for creating XML event readers */
+    private static final XmlPullParserFactory xmlPullParserFactory;
+    static {
+        try {
+            xmlPullParserFactory = XmlPullParserFactory.newInstance();
+        } catch (XmlPullParserException xppe) {
+            throw new AmazonClientException("Couldn't initialize XmlPullParserFactory", xppe);
+        }
+    }
+
+    @Test
+    public void testUnmarshall() throws XmlPullParserException, IOException, Exception {
+        VoidStaxUnmarshaller<String> vsu = new VoidStaxUnmarshaller<String>();
+        assertNull(vsu.unmarshall(getContext("Junk")));
+        assertNull(vsu.unmarshall(getContext("")));
+    }
+
+    private StaxUnmarshallerContext getContext(String elementData) throws XmlPullParserException,
+            IOException {
+        XmlPullParser xpp = xmlPullParserFactory.newPullParser();
+        String xml = "<tag>" + elementData + "</tag>";
+        StringReader sr = new StringReader(xml);
+        xpp.setInput(sr);
+
+        StaxUnmarshallerContext suc = new StaxUnmarshallerContext(xpp);
+        suc.nextEvent();
+        return suc;
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/AwsHostNameUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/AwsHostNameUtilsTest.java
new file mode 100644
index 0000000000..c89f2edfa1
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/AwsHostNameUtilsTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.net.URI;
+
+/** Unit tests for the utility methods that parse information from AWS URLs. */
+public class AwsHostNameUtilsTest {
+
+    private static final URI IAM_ENDPOINT = URI.create("https://iam.amazonaws.com");
+    private static final URI IAM_REGION_ENDPOINT = URI
+            .create("https://iam.us-west-2.amazonaws.com");
+    private static final URI EC2_REGION_ENDPOINT = URI
+            .create("https://ec2.us-west-2.amazonaws.com");
+    private static final URI S3_ENDPOINT = URI.create("https://s3.amazonaws.com");
+    private static final URI S3_BUCKET_ENDPOINT = URI
+            .create("https://bucket.name.with.periods.s3.amazonaws.com");
+    private static final URI S3_REGION_ENDPOINT = URI.create("https://s3-eu-west-1.amazonaws.com");
+    private static final URI S3_BUCKET_REGION_ENDPOINT = URI
+            .create("https://bucket.name.with.periods.s3-eu-west-1.amazonaws.com");
+
+    @Test
+    public void testParseServiceName() {
+        // Verify that parseServiceName keeps working the way it used to.
+        assertEquals("iam", AwsHostNameUtils.parseServiceName(IAM_ENDPOINT));
+        assertEquals("iam", AwsHostNameUtils.parseServiceName(IAM_REGION_ENDPOINT));
+        assertEquals("ec2", AwsHostNameUtils.parseServiceName(EC2_REGION_ENDPOINT));
+        assertEquals("s3", AwsHostNameUtils.parseServiceName(S3_ENDPOINT));
+        assertEquals("s3", AwsHostNameUtils.parseServiceName(S3_BUCKET_ENDPOINT));
+        assertEquals("s3", AwsHostNameUtils.parseServiceName(S3_REGION_ENDPOINT));
+        assertEquals("s3", AwsHostNameUtils.parseServiceName(S3_BUCKET_REGION_ENDPOINT));
+    }
+
+    @Test
+    public void testStandardNoHint() {
+        // Verify that standard endpoints parse correctly without a service hint
+        assertEquals("us-east-1", AwsHostNameUtils.parseRegionName("iam.amazonaws.com", null));
+        assertEquals("us-west-2",
+                AwsHostNameUtils.parseRegionName("iam.us-west-2.amazonaws.com", null));
+        assertEquals("us-west-2",
+                AwsHostNameUtils.parseRegionName("ec2.us-west-2.amazonaws.com", null));
+
+        assertEquals("us-east-1", AwsHostNameUtils.parseRegionName("s3.amazonaws.com", null));
+        assertEquals("us-east-1",
+                AwsHostNameUtils.parseRegionName("bucket.name.s3.amazonaws.com", null));
+
+        assertEquals("eu-west-1",
+                AwsHostNameUtils.parseRegionName("s3-eu-west-1.amazonaws.com", null));
+        assertEquals("eu-west-1",
+                AwsHostNameUtils.parseRegionName("s3.eu-west-1.amazonaws.com", null));
+        assertEquals("eu-west-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3-eu-west-1.amazonaws.com", null));
+        assertEquals("eu-west-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3.eu-west-1.amazonaws.com", null));
+    }
+
+    @Test
+    public void testStandard() {
+        // Verify that standard endpoints parse correctly with a service hint
+        assertEquals("us-east-1", AwsHostNameUtils.parseRegionName("iam.amazonaws.com", "iam"));
+        assertEquals("us-west-2",
+                AwsHostNameUtils.parseRegionName("iam.us-west-2.amazonaws.com", "iam"));
+        assertEquals("us-west-2",
+                AwsHostNameUtils.parseRegionName("ec2.us-west-2.amazonaws.com", "ec2"));
+
+        assertEquals("us-east-1", AwsHostNameUtils.parseRegionName("s3.amazonaws.com", "s3"));
+        assertEquals("us-east-1",
+                AwsHostNameUtils.parseRegionName("bucket.name.s3.amazonaws.com", "s3"));
+
+        assertEquals("eu-west-1",
+                AwsHostNameUtils.parseRegionName("s3-eu-west-1.amazonaws.com", "s3"));
+        assertEquals("eu-west-1",
+                AwsHostNameUtils.parseRegionName("s3.eu-west-1.amazonaws.com", "s3"));
+        assertEquals("eu-west-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3-eu-west-1.amazonaws.com", "s3"));
+        assertEquals("eu-west-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3.eu-west-1.amazonaws.com", "s3"));
+    }
+
+    @Test
+    public void testBJS() {
+        // Verify that BJS endpoints parse correctly even though they're
+        // non-standard.
+        assertEquals("cn-north-1",
+                AwsHostNameUtils.parseRegionName("iam.cn-north-1.amazonaws.com.cn", "iam"));
+        assertEquals("cn-north-1",
+                AwsHostNameUtils.parseRegionName("ec2.cn-north-1.amazonaws.com.cn", "ec2"));
+        assertEquals("cn-north-1",
+                AwsHostNameUtils.parseRegionName("s3.cn-north-1.amazonaws.com.cn", "s3"));
+        assertEquals("cn-north-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3.cn-north-1.amazonaws.com.cn", "s3"));
+    }
+
+    @Test
+    public void testS3SpecialRegions() {
+        assertEquals("us-east-1",
+                AwsHostNameUtils.parseRegionName("s3-external-1.amazonaws.com", null));
+        assertEquals("us-east-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3-external-1.amazonaws.com", null));
+
+        assertEquals("us-gov-west-1",
+                AwsHostNameUtils.parseRegionName("s3-fips-us-gov-west-1.amazonaws.com", null));
+        assertEquals("us-gov-west-1", AwsHostNameUtils.parseRegionName(
+                "bucket.name.with.periods.s3-fips-us-gov-west-1.amazonaws.com", null));
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base16CodecTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base16CodecTest.java
new file mode 100644
index 0000000000..66ac42aaf4
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base16CodecTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.UUID;
+
+/**
+ * @author hchar
+ */
+public class Base16CodecTest
+{
+    @Test
+    public void testVectorsPerRfc4648()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException
+    {
+        String[] testVectors = {
+                "",
+                "f",
+                "fo",
+                "foo",
+                "foob",
+                "fooba",
+                "foobar",
+        };
+        String[] expected = {
+                "",
+                "66",
+                "666F",
+                "666F6F",
+                "666F6F62",
+                "666F6F6261",
+                "666F6F626172",
+        };
+        for (int i = 0; i < testVectors.length; i++) {
+            String data = testVectors[i];
+            byte[] source = data.getBytes("UTF-8");
+            String b16encoded = Base16.encodeAsString(data.getBytes("UTF-8"));
+            Assert.assertEquals(expected[i], b16encoded);
+            byte[] b16 = b16encoded.getBytes("UTF-8");
+
+            byte[] decoded = Base16.decode(b16);
+            Assert.assertTrue(Arrays.equals(source, decoded));
+        }
+    }
+
+    @Test
+    public void testCodecConsistency()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException
+    {
+        byte[] decoded = null;
+
+        for (int h = 0; h < 1000; h++) {
+            byte[] digest = MessageDigest.getInstance("SHA-1").digest(
+                    UUID.randomUUID().toString().getBytes("UTF-8")
+                    );
+            String b16Encoded = Base16.encodeAsString(digest);
+            {
+                decoded = Base16.decode(b16Encoded);
+                Assert.assertTrue(Arrays.equals(decoded, digest));
+            }
+            { // test decoding case insensitivity
+                decoded = Base16.decode(StringUtils.lowerCase(b16Encoded));
+                Assert.assertTrue(Arrays.equals(decoded, digest));
+            }
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base64CodecTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base64CodecTest.java
new file mode 100644
index 0000000000..4eb9f248c2
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Base64CodecTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.UUID;
+
+public class Base64CodecTest
+{
+    @Test
+    public void testVectorsPerRfc4648() throws NoSuchAlgorithmException,
+            UnsupportedEncodingException {
+        String[] testVectors = {
+                "",
+                "f",
+                "fo",
+                "foo",
+                "foob",
+                "fooba",
+                "foobar",
+        };
+        String[] expected = {
+                "",
+                "Zg==",
+                "Zm8=",
+                "Zm9v",
+                "Zm9vYg==",
+                "Zm9vYmE=",
+                "Zm9vYmFy",
+        };
+
+        for (int i = 0; i < testVectors.length; i++) {
+            String data = testVectors[i];
+            byte[] source = data.getBytes("UTF-8");
+            String b64encoded = Base64.encodeAsString(data.getBytes("UTF-8"));
+            Assert.assertEquals(expected[i], b64encoded);
+            byte[] b64 = b64encoded.getBytes("UTF-8");
+
+            byte[] decoded = Base64.decode(b64);
+            Assert.assertTrue(Arrays.equals(source, decoded));
+        }
+    }
+
+    @Test
+    public void testCodecConsistency() throws NoSuchAlgorithmException,
+            UnsupportedEncodingException {
+        byte[] decoded = null;
+
+        for (int h = 0; h < 1000; h++) {
+            byte[] digest = MessageDigest.getInstance("SHA-1").digest(
+                    UUID.randomUUID().toString().getBytes("UTF-8"));
+            String b64Encoded = Base64.encodeAsString(digest);
+            decoded = Base64.decode(b64Encoded);
+            Assert.assertTrue(Arrays.equals(decoded, digest));
+        }
+    }
+
+    @Test
+    public void testImpossibleCases() {
+        final String[] BASE64_IMPOSSIBLE_CASES = {
+                "ZE==",
+                "ZmC=",
+                "Zm9vYE==",
+                "Zm9vYmC=",
+        };
+
+        for (String s : BASE64_IMPOSSIBLE_CASES) {
+            try {
+                Base64.decode(s);
+                Assert.fail();
+            } catch (IllegalArgumentException ex) {
+                // expected
+            }
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/BinaryUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/BinaryUtilsTest.java
new file mode 100644
index 0000000000..2dbefe03df
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/BinaryUtilsTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+public class BinaryUtilsTest {
+
+    @Test
+    public void testToAndFromHex() {
+        byte[] b = {
+                -1, 0, 127, -128
+        };
+        // ff 00 7f 80
+        String hex = BinaryUtils.toHex(b);
+        assertEquals(hex.substring(0, 2), "ff");
+        assertEquals(hex.substring(2, 4), "00");
+        assertEquals(hex.substring(4, 6), "7f");
+        assertEquals(hex.substring(6, 8), "80");
+        byte[] bytes = BinaryUtils.fromHex(hex);
+        assertArrayEquals(b, bytes);
+    }
+
+    @Test
+    public void testByteBufferToStream() throws IOException {
+        byte[] content = "content".getBytes(StringUtils.UTF8);
+        ByteBuffer bb = ByteBuffer.wrap(content);
+        InputStream is = BinaryUtils.toStream(bb);
+        int curr = -1;
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        while ((curr = is.read()) != -1) {
+            baos.write(curr);
+        }
+        assertArrayEquals(content, baos.toByteArray());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/CRC32ChecksumInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/CRC32ChecksumInputStreamTest.java
new file mode 100644
index 0000000000..bdfb7ad274
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/CRC32ChecksumInputStreamTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.zip.CRC32;
+
+/**
+ * Test CRC32ChecksumInputStream can calculate CRC32 checksum correctly.
+ */
+public class CRC32ChecksumInputStreamTest {
+
+    private final String TEST_DARA = "Jason, Yifei, Zach";
+
+    @Test
+    public void testCRC32Checksum() throws IOException {
+        CRC32 crc32 = new CRC32();
+        crc32.update(TEST_DARA.getBytes(StringUtils.UTF8));
+        long expectedCRC32Checksum = crc32.getValue();
+        CRC32ChecksumCalculatingInputStream crc32InputStream = new CRC32ChecksumCalculatingInputStream(
+                new ByteArrayInputStream(TEST_DARA.getBytes(StringUtils.UTF8)));
+        while (crc32InputStream.read() != -1)
+            ;
+        assertEquals(expectedCRC32Checksum, crc32InputStream.getCRC32Checksum());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassLoaderHelperTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassLoaderHelperTest.java
new file mode 100644
index 0000000000..58c024e431
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassLoaderHelperTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Test;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.URL;
+
+public class ClassLoaderHelperTest {
+
+    @Test
+    public void testGetResource() throws IOException {
+        URL testURL = ClassLoaderHelper.getResource("ClassLoaderHelperTestFile", this.getClass());
+        BufferedReader br = new BufferedReader(new FileReader(testURL.getFile()));
+        assertEquals(br.readLine(), "TestFile");
+        assertNull(br.readLine());
+        br.close();
+
+        testURL = ClassLoaderHelper.getResource("ClassLoaderHelperTestFile", true, String.class);
+        br = new BufferedReader(new FileReader(testURL.getFile()));
+        assertEquals(br.readLine(), "TestFile");
+        assertNull(br.readLine());
+        br.close();
+    }
+
+    @Test
+    public void testGetResourceAsStream() throws IOException {
+        InputStream is = ClassLoaderHelper.getResourceAsStream("ClassLoaderHelperTestFile",
+                this.getClass());
+        BufferedReader br = new BufferedReader(new InputStreamReader(is, StringUtils.UTF8));
+        assertEquals(br.readLine(), "TestFile");
+        assertNull(br.readLine());
+        br.close();
+
+        is = ClassLoaderHelper.getResourceAsStream("ClassLoaderHelperTestFile", true, String.class);
+        br = new BufferedReader(new InputStreamReader(is, StringUtils.UTF8));
+        assertEquals(br.readLine(), "TestFile");
+        assertNull(br.readLine());
+        br.close();
+    }
+
+    @Test
+    public void testGetClass() throws ClassNotFoundException {
+        Class<?> testClass = ClassLoaderHelper.loadClass(
+                "com.amazonaws.util.ClassLoaderHelperTest", String.class);
+        assertEquals(testClass.getName(), this.getClass().getName());
+
+        testClass = ClassLoaderHelper.loadClass("com.amazonaws.util.ClassLoaderHelperTest", true,
+                this.getClass());
+        assertEquals(testClass.getName(), this.getClass().getName());
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassesTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassesTest.java
new file mode 100644
index 0000000000..e7fd754760
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ClassesTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+
+import org.joda.time.DateTimeZone;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.jar.Attributes;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+public class ClassesTest {
+    private static final boolean VERBOSE = false;
+
+    @Test
+    public void basics() {
+        // super class of ClassesTest is Object
+        assertSame(getClass(), Classes.childClassOf(Object.class, this));
+        // super class of Object is null
+        assertSame(Object.class, Classes.childClassOf(null, this));
+        // not reflexive
+        assertNull(Classes.childClassOf(ClassesTest.class, this));
+    }
+
+    @Test
+    public void jarFileOf() throws IOException {
+        JarFile jf = Classes.jarFileOf(DateTimeZone.class);
+        Manifest mf = jf.getManifest();
+        Attributes attrs = mf.getMainAttributes();
+        String name = attrs.getValue("Bundle-Name");
+        String version = attrs.getValue("Bundle-Version");
+        if (VERBOSE) {
+            System.out.println(name);
+            System.out.println(version);
+        }
+        assertNotNull(name);
+        assertNotNull(version);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/DateUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/DateUtilsTest.java
new file mode 100644
index 0000000000..1a19598586
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/DateUtilsTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.joda.time.DateTimeZone;
+import org.joda.time.format.DateTimeFormat;
+import org.joda.time.format.DateTimeFormatter;
+import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.tz.FixedDateTimeZone;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.SimpleTimeZone;
+
+public class DateUtilsTest {
+    private static final boolean DEBUG = false;
+
+    private final DateTimeZone GMT = new FixedDateTimeZone("GMT", "GMT", 0, 0);
+    private final DateTimeFormatter iso8601DateFormat =
+            ISODateTimeFormat.dateTime().withZone(GMT);
+    private final DateTimeFormatter alternateIso8601DateFormat =
+            DateTimeFormat.forPattern(DateUtils.ALTERNATE_ISO8601_DATE_PATTERN).withZone(GMT);
+    private final DateTimeFormatter rfc822DateFormat =
+            DateTimeFormat.forPattern(DateUtils.RFC822_DATE_PATTERN)
+                    .withLocale(Locale.US)
+                    .withZone(GMT);
+    private final DateTimeFormatter compressedIso8601DateFormat =
+            DateTimeFormat.forPattern(DateUtils.COMPRESSED_DATE_PATTERN)
+                    .withZone(GMT);
+
+    @Test
+    public void tt0031561767() throws ParseException {
+        String input = "Fri, 16 May 2014 23:56:46 GMT";
+        Date date = DateUtils.parseRFC822Date(input);
+        assertEquals(input, DateUtils.formatRFC822Date(date));
+    }
+
+    @Test
+    public void testIso8601Date() {
+        Date date = new Date();
+        String expected = iso8601DateFormat.print(date.getTime());
+        String actual = DateUtils.formatISO8601Date(date);
+        assertEquals(expected, actual);
+
+        Date expectedDate = new Date(iso8601DateFormat.parseMillis(expected));
+        Date actualDate = DateUtils.parseISO8601Date(actual);
+        assertEquals(expectedDate, actualDate);
+    }
+
+    @Ignore("Joda has issue handling format string 'z'")
+    @Test
+    public void testRfc822Date() {
+        Date date = new Date();
+        String expected = rfc822DateFormat.print(date.getTime());
+        String actual = DateUtils.formatRFC822Date(date);
+        assertEquals(expected, actual);
+
+        Date expectedDate = new Date(rfc822DateFormat.parseMillis(expected));
+        Date actualDate = DateUtils.parseRFC822Date(actual);
+        assertEquals(expectedDate, actualDate);
+    }
+
+    @Test
+    public void testCompressedIso8601Date() throws ParseException {
+        Date date = new Date();
+        String formatted = compressedIso8601DateFormat.print(date.getTime());
+        Date expected = new Date(compressedIso8601DateFormat.parseMillis(formatted));
+        Date actual = DateUtils.parseCompressedISO8601Date(formatted);
+        assertEquals(expected, actual);
+    }
+
+    @Test
+    public void testAlternativeIso8601Date() throws ParseException {
+        Date date = new Date();
+        String formatted = alternateIso8601DateFormat.print(date.getTime());
+
+        Date expectedDate = new Date(alternateIso8601DateFormat.parseMillis(formatted));
+        Date actualDate = DateUtils.parseISO8601Date(formatted);
+        assertEquals(expectedDate, actualDate);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void invalidDate() throws ParseException {
+        final String input = "2014-03-06T14:28:58.000 Z";
+        System.out.println(DateUtils.parseISO8601Date(input));
+    }
+
+    @Test
+    public void testIssue233() throws ParseException {
+        // https://github.com/aws/aws-sdk-java/issues/233
+        final String edgeCase = "292278994-08-17T07:12:55.807Z";
+        Date expected = DateUtils.parseISO8601Date(edgeCase);
+        String formatted = DateUtils.formatISO8601Date(expected);
+        if (DEBUG)
+            System.out.println("formatted: " + formatted);
+        assertEquals(edgeCase, formatted);
+        Date parsed = DateUtils.parseISO8601Date(edgeCase);
+        if (DEBUG)
+            System.out.println("parsed: " + parsed);
+        assertEquals(expected, parsed);
+    }
+
+    @Test
+    public void testIssue233JodaTimeLimit() throws ParseException {
+        // https://github.com/aws/aws-sdk-java/issues/233
+        String s = DateUtils.formatISO8601Date(new Date(Long.MAX_VALUE));
+        System.out.println("s: " + s);
+        Date date = DateUtils.parseISO8601Date(s);
+        System.out.println("date: " + date);
+    }
+
+    @Test
+    public void testIssueDaysDiff() throws ParseException {
+        // https://github.com/aws/aws-sdk-java/issues/233
+        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
+        sdf.setTimeZone(new SimpleTimeZone(0, "GMT"));
+        String edgeCase = "292278994-08-17T07:12:55.807Z";
+        String testCase = "292278993-08-17T07:12:55.807Z";
+        Date od = DateUtils.parseISO8601Date(edgeCase);
+        Date testd = DateUtils.parseISO8601Date(testCase);
+        long diff = od.getTime() - testd.getTime();
+        assertTrue(diff == 365L * 24 * 60 * 60 * 1000);
+    }
+
+    @Test
+    public void testIssue233Overflows() throws ParseException {
+        String[] cases = {
+                // 1 milli second passed the max time
+                "292278994-08-17T07:12:55.808Z",
+                // 1 year passed the max year
+                "292278995-01-17T07:12:55.807Z",
+        };
+        for (String edgeCase : cases) {
+            try {
+                Date parsed = DateUtils.parseISO8601Date(edgeCase);
+                System.out.println("date: " + parsed);
+                fail("Unexpected success: " + parsed);
+            } catch (IllegalArgumentException ex) {
+                assertTrue(ex.getCause() instanceof ParseException);
+            }
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/EncodingSchemeEnumTests.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/EncodingSchemeEnumTests.java
new file mode 100644
index 0000000000..03d632e1b4
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/EncodingSchemeEnumTests.java
@@ -0,0 +1,28 @@
+package com.amazonaws.util;
+
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class EncodingSchemeEnumTests {
+
+    @Test
+    public void encodingScheme() {
+        Assert.assertEquals("dGVzdHN0cmluZw==",
+                EncodingSchemeEnum.BASE64.encodeAsString("teststring".getBytes(StringUtils.UTF8)));
+        Assert.assertEquals("teststring",
+                new String(EncodingSchemeEnum.BASE64.decode("dGVzdHN0cmluZw==")));
+
+        Assert.assertEquals("ORSXG5DTORZGS3TH",
+                EncodingSchemeEnum.BASE32.encodeAsString("teststring".getBytes(StringUtils.UTF8)));
+        Assert.assertEquals("teststring",
+                new String(EncodingSchemeEnum.BASE32.decode("ORSXG5DTORZGS3TH")));
+
+        Assert.assertEquals("74657374737472696E67",
+                EncodingSchemeEnum.BASE16.encodeAsString("teststring".getBytes(StringUtils.UTF8)));
+        Assert.assertEquals("teststring",
+                new String(EncodingSchemeEnum.BASE16.decode("74657374737472696E67")));
+
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/FileUtils.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/FileUtils.java
new file mode 100644
index 0000000000..48f4fc4b51
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/FileUtils.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+/**
+ * Helper class that helps in creating and writing data to temporary files.
+ */
+public class FileUtils {
+
+    /**
+     * Returns a reference to the file created with the given file name in the
+     * System's temporary directory.
+     *
+     * @param fileName
+     * @return a reference to the file
+     * @throws IOException
+     */
+    public static File createTempFileForTesting(String fileName) throws IOException {
+        return File.createTempFile(String.valueOf(System.currentTimeMillis()),
+                fileName);
+
+    }
+
+    /**
+     * Creates a file with the given name in the System's temporary directory.
+     * Adds the data to the given file and returns the reference to the file.
+     *
+     * @param fileName
+     * @param data
+     * @return reference to the file.
+     * @throws IOException
+     */
+    public static File createTempFileForTesting(String fileName, String data)
+            throws IOException {
+        return appendDataToTempFile(File.createTempFile(
+                String.valueOf(System.currentTimeMillis()), fileName), data);
+
+    }
+
+    /**
+     * Appends the given data to the file specified in the input and returns the
+     * reference to the file.
+     *
+     * @param file
+     * @param dataToAppend
+     * @return reference to the file.
+     * @throws IOException
+     */
+    public static File appendDataToTempFile(File file, String dataToAppend)
+            throws IOException {
+        FileWriter outputWriter = new FileWriter(file);
+
+        try {
+            outputWriter.append(dataToAppend);
+        } finally {
+            outputWriter.close();
+        }
+
+        return file;
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/HttpUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/HttpUtilsTest.java
new file mode 100644
index 0000000000..01eb55a3c0
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/HttpUtilsTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Request;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+public class HttpUtilsTest {
+    @Test
+    public void testEncodeNull() {
+        Assert.assertEquals("urlEncode(null) returned something unexpected",
+                "",
+                HttpUtils.urlEncode(null, false));
+    }
+
+    @Test
+    public void testEncodeEmptyString() {
+        Assert.assertEquals("urlEncode(\"\") returned something unexpected",
+                "",
+                HttpUtils.urlEncode("", false));
+    }
+
+    @Test
+    public void testNoEncoding() {
+        // The un-reserved characters according to RFC 3986
+        final String test =
+                "abcdefghijklmnopqrstuvwxyz"
+                        + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                        + "0123456789"
+                        + "-_.~";
+
+        Assert.assertEquals("urlEncode(\"" + test + "\") returned something "
+                + "unexpected",
+                test,
+                HttpUtils.urlEncode(test, false));
+    }
+
+    @Test
+    public void testNoEncodingPath() {
+        // The un-reserved characters according to RFC 3986, with the addition
+        // of '/' - in path mode, we allow this through unencoded.
+
+        final String test =
+                "abcdefghijklmnopqrstuvwxyz"
+                        + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                        + "0123456789"
+                        + "-_.~/";
+
+        Assert.assertEquals("urlEncode(\"" + test + "\") returned something "
+                + "unexpected",
+                test,
+                HttpUtils.urlEncode(test, true));
+    }
+
+    @Test
+    public void testEncoding() {
+        // The other ASCII printable characters, which should be encoded.
+        final String test =
+                "\t\n\r "
+                        + "!\"#$"
+                        + "%&'("
+                        + ")*+,"
+                        + "/:;<"
+                        + "=>?@"
+                        + "[\\]^"
+                        + "`{|}";
+
+        final String expected =
+                "%09%0A%0D%20" // \t \n \r <space>
+                        + "%21%22%23%24" // ! " # $
+                        + "%25%26%27%28" // % & ' (
+                        + "%29%2A%2B%2C" // ) * + ,
+                        + "%2F%3A%3B%3C" // / : ; <
+                        + "%3D%3E%3F%40" // = > ? @
+                        + "%5B%5C%5D%5E" // [ \ ] ^
+                        + "%60%7B%7C%7D"; // ` { | }
+
+        Assert.assertEquals("urlEncode(\"" + test + "\") returned something "
+                + "unexpected",
+                expected,
+                HttpUtils.urlEncode(test, false));
+
+        Assert.assertEquals("urlDecode(\"" + expected + "\") returned something "
+                + "unexpected",
+                test,
+                HttpUtils.urlDecode(expected));
+    }
+
+    @Test
+    public void testEncodeParameters() {
+
+        final Request<?> request = new DefaultRequest<String>("TestRequest");
+        request.addParameter("FirstKey", "FirstValue");
+        request.addParameter("LastKey", "LastValue");
+        final String encoded = HttpUtils.encodeParameters(request);
+        assertEquals(encoded, "FirstKey=FirstValue&LastKey=LastValue");
+
+    }
+
+    @Test
+    public void testEncodeParametersReturnsNullOnEmptyParameters() {
+
+        final Request<?> request = new DefaultRequest<String>("TestRequest");
+        final String encoded = HttpUtils.encodeParameters(request);
+        assertNull(encoded);
+
+    }
+
+    @Test
+    public void testGetUserAgent() {
+        assertEquals(HttpUtils.getUserAgent(null), ClientConfiguration.DEFAULT_USER_AGENT);
+        final ClientConfiguration conf = new ClientConfiguration();
+        assertEquals(HttpUtils.getUserAgent(conf), ClientConfiguration.DEFAULT_USER_AGENT);
+        conf.setUserAgent("New");
+        assertEquals(HttpUtils.getUserAgent(conf),
+                "New, " + ClientConfiguration.DEFAULT_USER_AGENT);
+    }
+
+    @Test
+    public void testAppendUriHandlesMergingSlashes() {
+        final String baseURI = "/my/uri/";
+        final String path = "/path/to/add/";
+        final String appended = HttpUtils.appendUri(baseURI, path);
+        assertEquals(appended, "/my/uri/path/to/add/");
+    }
+
+    @Test
+    public void testAppendUriHandlesMergingWithoutSlashes() {
+        final String baseURI = "/my/uri";
+        final String path = "path/to/add/";
+        final String appended = HttpUtils.appendUri(baseURI, path);
+        assertEquals(appended, "/my/uri/path/to/add/");
+    }
+
+    @Test
+    public void testIsUsingNonDefaultPort() throws URISyntaxException {
+        final URI http = new URI("http://www.http.com:80");
+        assertFalse(HttpUtils.isUsingNonDefaultPort(http));
+        final URI https = new URI("https://www.https.com:443");
+        assertFalse(HttpUtils.isUsingNonDefaultPort(https));
+    }
+
+    @Test
+    public void testGetConnectionTimeout() {
+        assertEquals(HttpUtils.getConnectionTimeout(null),
+                ClientConfiguration.DEFAULT_CONNECTION_TIMEOUT);
+        final ClientConfiguration conf = new ClientConfiguration();
+        conf.setConnectionTimeout(10);
+        assertEquals(HttpUtils.getConnectionTimeout(conf), 10);
+    }
+
+    @Test
+    public void testGetSocketTimeout() {
+        assertEquals(HttpUtils.getSocketTimeout(null), ClientConfiguration.DEFAULT_SOCKET_TIMEOUT);
+        final ClientConfiguration conf = new ClientConfiguration();
+        conf.setSocketTimeout(10);
+        assertEquals(HttpUtils.getSocketTimeout(conf), 10);
+    }
+
+    @Test
+    public void testAppendUriNoPath() {
+        final String host = "foo.com/";
+        final String resourcePath = "";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, true), "foo.com/");
+    }
+
+    @Test
+    public void testAppendUriNoPathTrailingSlashAdded() {
+        final String host = "foo.com";
+        final String resourcePath = "";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, true), "foo.com/");
+    }
+
+    @Test
+    public void testAppendUriTrimExtraHostTrailingSlash() {
+        final String host = "foo.com/";
+        final String resourcePath = "bar";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, true), "foo.com/bar");
+    }
+
+    @Test
+    public void testAppendUriEscapeDoubleSlash() {
+        final String host = "foo.com";
+        final String resourcePath = "aws//android/sdk";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, true),
+                "foo.com/aws/%2Fandroid/sdk");
+    }
+
+    public void testEncodeDecode() {
+        final String host = "foo.com";
+        final String resourcePath = "aws//android/sdk";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, true),
+                "foo.com/aws/%2Fandroid/sdk");
+    }
+
+    @Test
+    public void testAppendUriNoEscapeDoubleSlash() {
+        final String host = "foo.com";
+        final String resourcePath = "aws//android/sdk";
+        Assert.assertEquals(HttpUtils.appendUri(host, resourcePath, false),
+                "foo.com/aws//android/sdk");
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/IOUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/IOUtilsTest.java
new file mode 100644
index 0000000000..4b072d4c77
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/IOUtilsTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class IOUtilsTest {
+
+    @Test
+    public void testEmptyByteArray() throws Exception {
+        String s = IOUtils.toString(new ByteArrayInputStream(new byte[0]));
+        assertEquals("", s);
+    }
+
+    @Test
+    public void testZeroByteStream() throws Exception {
+        String s = IOUtils.toString(new InputStream() {
+            @Override
+            public int read() throws IOException {
+                return -1;
+            }
+        });
+        assertEquals("", s);
+    }
+
+    @Test
+    public void test() throws Exception {
+        String s = IOUtils.toString(new ByteArrayInputStream("Testing".getBytes(StringUtils.UTF8)));
+        assertEquals("Testing", s);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ImmutableMapParameterTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ImmutableMapParameterTest.java
new file mode 100644
index 0000000000..7031c6bb69
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ImmutableMapParameterTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * Unit tests for the ImmutableMapParameterTest class.
+ */
+public class ImmutableMapParameterTest {
+
+    @Test
+    public void testMapBuilder() {
+        Map<Integer, String> builtMap = new ImmutableMapParameter.Builder<Integer, String>()
+                .put(1, "one")
+                .put(2, "two")
+                .put(3, "three")
+                .build();
+        assertEquals(3, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        assertEquals("two", builtMap.get(2));
+        assertEquals("three", builtMap.get(3));
+    }
+
+    @Test
+    public void testOfBuilder() {
+        Map<Integer, String> builtMap = ImmutableMapParameter.of(1, "one");
+        assertEquals(1, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        builtMap = ImmutableMapParameter.of(1, "one", 2, "two");
+        assertEquals(2, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        assertEquals("two", builtMap.get(2));
+        builtMap = ImmutableMapParameter.of(1, "one", 2, "two", 3, "three");
+        assertEquals(3, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        assertEquals("two", builtMap.get(2));
+        assertEquals("three", builtMap.get(3));
+        builtMap = ImmutableMapParameter.of(1, "one", 2, "two", 3, "three", 4, "four");
+        assertEquals(4, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        assertEquals("two", builtMap.get(2));
+        assertEquals("three", builtMap.get(3));
+        assertEquals("four", builtMap.get(4));
+        builtMap = ImmutableMapParameter.of(1, "one", 2, "two", 3, "three", 4, "four", 5, "five");
+        assertEquals(5, builtMap.size());
+        assertEquals("one", builtMap.get(1));
+        assertEquals("two", builtMap.get(2));
+        assertEquals("three", builtMap.get(3));
+        assertEquals("four", builtMap.get(4));
+        assertEquals("five", builtMap.get(5));
+    }
+
+    @Test
+    public void testErrorOnDuplicateKeys() {
+        try {
+            Map<Integer, String> builtMap = new ImmutableMapParameter.Builder<Integer, String>()
+                    .put(1, "one")
+                    .put(1, "two")
+                    .build();
+            fail("IllegalArgumentException expected.");
+        } catch (IllegalArgumentException iae) {
+        } catch (Exception e) {
+            fail("IllegalArgumentException expected.");
+        }
+    }
+
+    @Test
+    public void testMapOperations() {
+        Map<Integer, String> builtMap = new ImmutableMapParameter.Builder<Integer, String>()
+                .put(1, "one")
+                .put(2, "two")
+                .put(3, "three")
+                .build();
+        assertTrue(builtMap.containsKey(1));
+        assertTrue(builtMap.containsValue("one"));
+        assertTrue(builtMap.values().contains("one"));
+        assertEquals("one", builtMap.get(1));
+        assertEquals(3, builtMap.entrySet().size());
+        assertEquals(3, builtMap.values().size());
+
+        assertEquals(3, builtMap.size());
+
+        /** Unsupported methods **/
+        try {
+            builtMap.clear();
+            fail("UnsupportedOperationException expected.");
+        } catch (UnsupportedOperationException iae) {
+        } catch (Exception e) {
+            fail("UnsupportedOperationException expected.");
+        }
+        try {
+            builtMap.put(4, "four");
+            fail("UnsupportedOperationException expected.");
+        } catch (UnsupportedOperationException iae) {
+        } catch (Exception e) {
+            fail("UnsupportedOperationException expected.");
+        }
+        try {
+            builtMap.putAll(Collections.singletonMap(4, "four"));
+            fail("UnsupportedOperationException expected.");
+        } catch (UnsupportedOperationException iae) {
+        } catch (Exception e) {
+            fail("UnsupportedOperationException expected.");
+        }
+        try {
+            builtMap.remove(1);
+            fail("UnsupportedOperationException expected.");
+        } catch (UnsupportedOperationException iae) {
+        } catch (Exception e) {
+            fail("UnsupportedOperationException expected.");
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/LengthCheckInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/LengthCheckInputStreamTest.java
new file mode 100644
index 0000000000..5f62f50bf0
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/LengthCheckInputStreamTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.LengthCheckInputStream.EXCLUDE_SKIPPED_BYTES;
+import static com.amazonaws.util.LengthCheckInputStream.INCLUDE_SKIPPED_BYTES;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import com.amazonaws.AmazonClientException;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class LengthCheckInputStreamTest {
+
+    String sampleData = "__________1234567890__________12345678901234567890"
+            + "12345678901234567890123456789012345678901234567890"
+            + "12345678901234567890123456789012345678901234567890"
+            + "12345678901234567890123456789012345678901234567890"
+            + "12345678901234567890123456789012345678909876543210";
+
+    /**
+     * Tests if the content length set in the stream equals the bytes read from
+     * the stream. If any exception is thrown, then the test fails.
+     */
+    @Test
+    public void testContentLength() throws Exception {
+        InputStream in = new ByteArrayInputStream(sampleData.getBytes(StringUtils.UTF8));
+
+        LengthCheckInputStream rvis = new LengthCheckInputStream(in,
+                sampleData.getBytes(StringUtils.UTF8).length, INCLUDE_SKIPPED_BYTES);
+        try {
+            StreamUtils.consumeInputStream(rvis);
+        } catch (Exception e) {
+            fail();
+        }
+
+        rvis.close();
+    }
+
+    /**
+     * This test case initiates a mark at the start, reads the first 100 bytes
+     * from the stream. Now the stream is reset and it is drained. At the last
+     * read, the length validation must be success.
+     */
+    @Test
+    public void testMarkInitiallyAndReset() throws Exception {
+        InputStream in = new ByteArrayInputStream(sampleData.getBytes(StringUtils.UTF8));
+        LengthCheckInputStream rvis = new LengthCheckInputStream(in,
+                sampleData.getBytes(StringUtils.UTF8).length, INCLUDE_SKIPPED_BYTES);
+        rvis.mark(100);
+        rvis.read(new byte[100]);
+        rvis.reset();
+        rvis.read(new byte[sampleData.getBytes(StringUtils.UTF8).length]);
+        try {
+            rvis.read();
+        } catch (Exception e) {
+            fail();
+        }
+
+        rvis.close();
+        StreamUtils.consumeInputStream(rvis);
+
+    }
+
+    /**
+     * This test case initiates a mark after reading 100 bytes from the stream.
+     * Reads the next 100 bytes from the stream. Now the stream is reset and it
+     * is drained. At the last read, the length validation must fail because the
+     * stream was initialized with wrong expected length.
+     */
+    @Test
+    public void testMarkAndResetWithWrongExpectedLength() throws Exception {
+        InputStream in = new ByteArrayInputStream(sampleData.getBytes(StringUtils.UTF8));
+        LengthCheckInputStream rvis = new LengthCheckInputStream(in,
+                sampleData.getBytes(StringUtils.UTF8).length + 1, INCLUDE_SKIPPED_BYTES);
+
+        rvis.read(new byte[100]);
+        rvis.mark(100);
+        rvis.read(new byte[100]);
+        rvis.reset();
+        rvis.read(new byte[sampleData.getBytes(StringUtils.UTF8).length - 100]);
+        try {
+            rvis.read();
+            fail();
+        } catch (Exception e) {
+            System.out
+                    .println("Exception occurred. Message: " + e.getMessage());
+        }
+
+        rvis.close();
+
+    }
+
+    /**
+     * This test case initiates a marks the stream initially, drains the whole
+     * stream. Resets the stream and drains again.
+     */
+    @Test
+    public void testMarkAndResetAtEnd() throws Exception {
+        InputStream in = new ByteArrayInputStream(sampleData.getBytes(StringUtils.UTF8));
+        LengthCheckInputStream rvis = new LengthCheckInputStream(in,
+                sampleData.getBytes(StringUtils.UTF8).length, INCLUDE_SKIPPED_BYTES);
+
+        rvis.mark(100);
+        StreamUtils.consumeInputStream(rvis);
+        rvis.reset();
+        StreamUtils.consumeInputStream(rvis);
+
+        try {
+            rvis.read();
+        } catch (Exception e) {
+            fail();
+        }
+        rvis.close();
+
+    }
+
+    /**
+     * Actual number of bytes consumed is exactly what's expected, when skipped
+     * bytes are included.
+     */
+    @Test
+    public void testSkipIncluded() throws IOException {
+        byte[] bytes = new byte[100];
+        InputStream is = new LengthCheckInputStream(
+                new ByteArrayInputStream(bytes), 100, INCLUDE_SKIPPED_BYTES);
+        assertTrue(10 == is.skip(10));
+        StreamUtils.consumeInputStream(is);
+        is.close();
+    }
+
+    /**
+     * Actual number of bytes consumed is more than what's expected, when
+     * skipped bytes are included.
+     */
+    @Test
+    public void testSkipIncludedFailure() throws IOException {
+        byte[] bytes = new byte[100];
+        InputStream is = new LengthCheckInputStream(
+                new ByteArrayInputStream(bytes), 90, INCLUDE_SKIPPED_BYTES);
+        assertTrue(10 == is.skip(10));
+        try {
+            StreamUtils.consumeInputStream(is);
+            fail();
+        } catch (AmazonClientException ex) {
+            // expected
+        }
+        is.close();
+    }
+
+    /**
+     * Actual number of bytes consumed is exactly what's expected, when skipped
+     * bytes are excluded.
+     */
+    @Test
+    public void testSkipExcluded() throws IOException {
+        byte[] bytes = new byte[100];
+        InputStream is = new LengthCheckInputStream(
+                new ByteArrayInputStream(bytes), 90, EXCLUDE_SKIPPED_BYTES);
+        assertTrue(10 == is.skip(10));
+        StreamUtils.consumeInputStream(is);
+        is.close();
+    }
+
+    /**
+     * Actual number of bytes consumed is less than what's expected, when
+     * skipped bytes are excluded.
+     */
+    @Test
+    public void testSkipExcludedFailure() throws IOException {
+        byte[] bytes = new byte[100];
+        LengthCheckInputStream is = new LengthCheckInputStream(
+                new ByteArrayInputStream(bytes), 100, EXCLUDE_SKIPPED_BYTES);
+        assertTrue(10 == is.skip(10));
+        try {
+            StreamUtils.consumeInputStream(is);
+            fail();
+        } catch (AmazonClientException ex) {
+            // expected
+        }
+        is.close();
+    }
+
+    /**
+     * Skipped more than what's expected.
+     */
+    @Test
+    public void testOverSkipped() throws IOException {
+        byte[] bytes = new byte[100];
+        LengthCheckInputStream is = new LengthCheckInputStream(
+                new ByteArrayInputStream(bytes), 99, INCLUDE_SKIPPED_BYTES);
+        try {
+            is.skip(100);
+            fail();
+        } catch (AmazonClientException ex) {
+            // expected
+        }
+        is.close();
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/Md5UtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Md5UtilsTest.java
new file mode 100644
index 0000000000..6d94fe1899
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/Md5UtilsTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.apache.commons.io.FileUtils;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+
+public class Md5UtilsTest {
+
+    @Test
+    public void testBytes() {
+        byte[] md5 = Md5Utils.computeMD5Hash("Testing MD5".getBytes(StringUtils.UTF8));
+        assertEquals("0b4f503b8eb7714ce12402406895cf68", StringUtils.lowerCase(Base16.encodeAsString(md5)));
+
+        String b64 = Md5Utils.md5AsBase64("Testing MD5".getBytes(StringUtils.UTF8));
+        assertEquals("C09QO463cUzhJAJAaJXPaA==", b64);
+    }
+
+    @Test
+    public void testStream() throws IOException {
+        byte[] md5 = Md5Utils.computeMD5Hash(new ByteArrayInputStream("Testing MD5"
+                .getBytes(StringUtils.UTF8)));
+        assertEquals("0b4f503b8eb7714ce12402406895cf68", StringUtils.lowerCase(Base16.encodeAsString(md5)));
+
+        String b64 = Md5Utils.md5AsBase64(new ByteArrayInputStream("Testing MD5"
+                .getBytes(StringUtils.UTF8)));
+        assertEquals("C09QO463cUzhJAJAaJXPaA==", b64);
+    }
+
+    @Test
+    public void testFile() throws Exception {
+        File f = File.createTempFile("Md5UtilsTest-", "txt");
+        f.deleteOnExit();
+        FileUtils.writeStringToFile(f, "Testing MD5");
+        byte[] md5 = Md5Utils.computeMD5Hash(f);
+        assertEquals("0b4f503b8eb7714ce12402406895cf68", StringUtils.lowerCase(Base16.encodeAsString(md5)));
+
+        String b64 = Md5Utils.md5AsBase64(f);
+        assertEquals("C09QO463cUzhJAJAaJXPaA==", b64);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/NamespaceRemovingInputStreamTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/NamespaceRemovingInputStreamTest.java
new file mode 100644
index 0000000000..a5c84db63e
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/NamespaceRemovingInputStreamTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.apache.commons.io.IOUtils;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * Test for filtering out XML namespace attributes when reading XML.
+ */
+public class NamespaceRemovingInputStreamTest {
+
+    private static final String SAMPLE_RESPONSE_1 =
+            "<DomainMetadataResponse xmlns=\"http://sdb.amazonaws.com/doc/2009-04-15/\">\n" +
+                    "  <DomainMetadataResult>\n" +
+                    "    <ItemCount>195078</ItemCount>\n" +
+                    "  </DomainMetadataResult>\n" +
+                    "  <ResponseMetadata>\n" +
+                    "        <RequestId>b1e8f1f7-42e9-494c-ad09-2674e557526d</RequestId>\n" +
+                    "  </ResponseMetadata>\n" +
+                    "</DomainMetadataResponse>";
+
+    private static final String SAMPLE_RESPONSE_2 =
+            "<DomainMetadataResponse xmlns = \"http://sdb.amazonaws.com/doc/2009-04-15/\">\n" +
+                    "  <DomainMetadataResult>\n" +
+                    "    <ItemCount>195078</ItemCount>\n" +
+                    "  </DomainMetadataResult>\n" +
+                    "  <ResponseMetadata>\n" +
+                    "        <RequestId>b1e8f1f7-42e9-494c-ad09-2674e557526d</RequestId>\n" +
+                    "  </ResponseMetadata>\n" +
+                    "</DomainMetadataResponse>";
+
+    private static final String SAMPLE_RESPONSE_3 =
+            "<DomainMetadataResponse xmlns=  \"http://sdb.amazonaws.com/doc/2009-04-15/\">\n" +
+                    "  <DomainMetadataResult>\n" +
+                    "    <ItemCount>195078</ItemCount>\n" +
+                    "  </DomainMetadataResult>\n" +
+                    "  <ResponseMetadata>\n" +
+                    "        <RequestId>b1e8f1f7-42e9-494c-ad09-2674e557526d</RequestId>\n" +
+                    "  </ResponseMetadata>\n" +
+                    "</DomainMetadataResponse>";
+
+    private static final String EXPECTED_RESULT =
+            "<DomainMetadataResponse >\n" +
+                    "  <DomainMetadataResult>\n" +
+                    "    <ItemCount>195078</ItemCount>\n" +
+                    "  </DomainMetadataResult>\n" +
+                    "  <ResponseMetadata>\n" +
+                    "        <RequestId>b1e8f1f7-42e9-494c-ad09-2674e557526d</RequestId>\n" +
+                    "  </ResponseMetadata>\n" +
+                    "</DomainMetadataResponse>";
+
+    @Test
+    public void testNamespaceRemoval() throws Exception {
+        assertEquals(EXPECTED_RESULT, removeNamespace(SAMPLE_RESPONSE_1));
+        assertEquals(EXPECTED_RESULT, removeNamespace(SAMPLE_RESPONSE_2));
+        assertEquals(EXPECTED_RESULT, removeNamespace(SAMPLE_RESPONSE_3));
+    }
+
+    private String removeNamespace(String xml) throws Exception {
+        NamespaceRemovingInputStream inputStream = new NamespaceRemovingInputStream(
+                new ByteArrayInputStream(xml.getBytes(StringUtils.UTF8)));
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        IOUtils.copy(inputStream, outputStream);
+
+        return new String(outputStream.toByteArray(), StringUtils.UTF8);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ResponseMetadataCacheTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ResponseMetadataCacheTest.java
new file mode 100644
index 0000000000..5585fdeef8
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ResponseMetadataCacheTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import com.amazonaws.AmazonWebServiceRequest;
+import com.amazonaws.ResponseMetadata;
+
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Random;
+
+/** Tests for the response metadata cache class. */
+public class ResponseMetadataCacheTest {
+
+    /** Tests that the cache correctly evicts the oldest entries. */
+    @Test
+    public void testEviction() {
+        ResponseMetadataCache cache = new ResponseMetadataCache(3);
+
+        AmazonWebServiceRequest key1 = new TestRequest();
+        AmazonWebServiceRequest key2 = new TestRequest();
+        AmazonWebServiceRequest key3 = new TestRequest();
+        AmazonWebServiceRequest key4 = new TestRequest();
+        ResponseMetadata metadata1 = newResponseMetadata();
+        ResponseMetadata metadata2 = newResponseMetadata();
+        ResponseMetadata metadata3 = newResponseMetadata();
+        ResponseMetadata metadata4 = newResponseMetadata();
+
+        // Fill the cache
+        cache.add(key1, metadata1);
+        cache.add(key2, metadata2);
+        cache.add(key3, metadata3);
+
+        // Verify all entries are still there
+        assertEquals(metadata1, cache.get(key1));
+        assertEquals(metadata2, cache.get(key2));
+        assertEquals(metadata3, cache.get(key3));
+
+        // Add another and make sure the oldest is evicted
+        cache.add(key4, metadata4);
+        assertNull(cache.get(key1));
+        assertEquals(metadata2, cache.get(key2));
+        assertEquals(metadata3, cache.get(key3));
+        assertEquals(metadata4, cache.get(key4));
+    }
+
+    private class TestRequest extends AmazonWebServiceRequest {
+    }
+
+    private ResponseMetadata newResponseMetadata() {
+        HashMap<String, String> metadata = new HashMap<String, String>();
+        metadata.put("foo", "bar-" + new Random().nextLong());
+        return new ResponseMetadata(metadata);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/RuntimeHttpUtilsTests.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/RuntimeHttpUtilsTests.java
new file mode 100644
index 0000000000..79ef525d8a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/RuntimeHttpUtilsTests.java
@@ -0,0 +1,66 @@
+
+package com.amazonaws.util;
+
+import com.amazonaws.ClientConfiguration;
+import com.amazonaws.DefaultRequest;
+import com.amazonaws.Protocol;
+import com.amazonaws.Request;
+
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.io.ByteArrayInputStream;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
+public class RuntimeHttpUtilsTests {
+
+    @Rule
+    public final ExpectedException exception = ExpectedException.none();
+
+    @Test
+    public void testconvertRequestToUrl() throws MalformedURLException {
+        final Request<?> request = new DefaultRequest<Void>("Foo");
+        request.setContent(new ByteArrayInputStream("testcontent"
+                .getBytes(StringUtils.UTF8)));
+        request.addHeader("Host", "demo.us-east-1.amazonaws.com");
+        // HTTP header containing multiple spaces in a row.
+        request.addHeader("x-amz-archive-description", "test  test");
+        request.setResourcePath("/");
+        request.setEndpoint(URI.create("http://demo.us-east-1.amazonaws.com"));
+
+        final Map<String, String> parameters = new HashMap<String, String>();
+        parameters.put("foo", "bar");
+        parameters.put("temple", "run");
+        request.setParameters(parameters);
+        final RuntimeHttpUtils utils = new RuntimeHttpUtils();
+
+        Assert.assertEquals(new URL("http://demo.us-east-1.amazonaws.com/?foo=bar&temple=run"),
+                RuntimeHttpUtils.convertRequestToUrl(request, true, false));
+
+    }
+
+    @Test
+    public void testUri() throws MalformedURLException, URISyntaxException {
+        Assert.assertEquals(new URI("https://demo.us-east-1.amazonaws.com/"),
+                RuntimeHttpUtils.toUri("demo.us-east-1.amazonaws.com/",
+                        new ClientConfiguration().withProtocol(Protocol.HTTPS)));
+
+        exception.expect(IllegalArgumentException.class);
+        RuntimeHttpUtils.toUri(null, new ClientConfiguration());
+
+        exception.expect(IllegalArgumentException.class);
+        RuntimeHttpUtils.toUri(null, (ClientConfiguration) null);
+
+        Assert.assertEquals(new URI("http://demo.us-east-1.amazonaws.com/"),
+                RuntimeHttpUtils.toUri("https://demo.us-east-1.amazonaws.com/",
+                        new ClientConfiguration().withProtocol(Protocol.HTTP)));
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/StreamUtils.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/StreamUtils.java
new file mode 100644
index 0000000000..483e076726
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/StreamUtils.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+public class StreamUtils {
+    public static void consumeInputStream(InputStream in) throws IOException {
+        byte[] buffer = new byte[1024 * 10];
+        while (in.read(buffer) > -1) {
+        }
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/StringUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/StringUtilsTest.java
new file mode 100644
index 0000000000..b10ed3dfb7
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/StringUtilsTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.StringUtils.UTF8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+import java.util.Locale;
+
+/**
+ * Unit tests for the StringUtils class.
+ */
+public class StringUtilsTest {
+
+    /**
+     * Tests that {@link StringUtils#fromByteBuffer(ByteBuffer)} correctly
+     * base64 encodes the contents in a ByteBuffer and returns the correct
+     * result.
+     */
+    @Test
+    public void testFromByteBuffer() {
+        final String expectedData = "hello world";
+        final String expectedEncodedData = "aGVsbG8gd29ybGQ=";
+
+        final ByteBuffer byteBuffer = ByteBuffer.wrap(expectedData.getBytes(UTF8));
+        final String encodedData = StringUtils.fromByteBuffer(byteBuffer);
+
+        assertEquals(expectedEncodedData, encodedData);
+    }
+
+    /**
+     * Tests that we can correctly convert Bytes to strings.
+     */
+    @Test
+    public void testFromByte() {
+        assertEquals("123", StringUtils.fromByte(new Byte("123")));
+        assertEquals("-99", StringUtils.fromByte(new Byte("-99")));
+    }
+
+    @Test
+    public void testUTF8Charset() {
+        assertEquals(UTF8.displayName(), "UTF-8");
+    }
+
+    @Test
+    public void testReplace() {
+        final String orig = "To have or not to have";
+        final String replacement = "be";
+        assertEquals(StringUtils.replace(orig, "have", replacement), "To be or not to be");
+    }
+
+    @Test
+    public void testJoiner() {
+        final String part1 = "one";
+        final String part2 = "two";
+        final String part3 = "one";
+        final String part4 = "four";
+        final String join1 = StringUtils.join("+", part1, part2, part3);
+        assertEquals(StringUtils.join("=", join1, part4), "one+two+one=four");
+    }
+
+    @Test
+    public void testLowerCase() {
+        assertNull("null", StringUtils.lowerCase(null));
+        assertEquals("empty string", "", StringUtils.lowerCase(""));
+        assertEquals("aBc -> abc", "abc", StringUtils.lowerCase("aBc"));
+
+        // https://github.com/aws/aws-sdk-android/issues/96
+        final Locale defaultLocale = Locale.getDefault();
+        Locale.setDefault(new Locale("tr", "TR"));
+        assertEquals("turkish locale", "x-amz-invocation-type",
+                StringUtils.lowerCase("X-Amz-Invocation-Type"));
+        Locale.setDefault(defaultLocale);
+    }
+
+    @Test
+    public void testUpperCase() {
+        assertNull("null", StringUtils.upperCase(null));
+        assertEquals("empty string", "", StringUtils.upperCase(""));
+        assertEquals("aBc -> ABC", "ABC", StringUtils.upperCase("aBc"));
+
+        // https://github.com/aws/aws-sdk-android/issues/96
+        final Locale defaultLocale = Locale.getDefault();
+        Locale.setDefault(new Locale("tr", "TR"));
+        assertEquals("turkish locale", "X-AMZ-INVOCATION-TYPE",
+                StringUtils.upperCase("X-Amz-Invocation-Type"));
+        Locale.setDefault(defaultLocale);
+    }
+
+    @Test
+    public void isBlankTest() {
+        Assert.assertTrue(StringUtils.isBlank(""));
+        Assert.assertTrue(StringUtils.isBlank(null));
+        Assert.assertFalse(StringUtils.isBlank("12334"));
+        Assert.assertTrue(StringUtils.isBlank("  "));
+    }
+
+    @Test
+    public void otherTest() {
+        Assert.assertEquals("123.45", StringUtils.fromDouble(123.45));
+        Assert.assertEquals("123", StringUtils.fromInteger(123));
+        Assert.assertEquals("123.45", StringUtils.fromFloat(123.45f));
+        Assert.assertEquals("abcd", StringUtils.toString(new StringBuilder("abcd")));
+        Assert.assertEquals(false, StringUtils.toBoolean(new StringBuilder("true")));
+        Assert.assertEquals("1234567890", StringUtils.fromLong(1234567890L));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ThrowablesTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ThrowablesTest.java
new file mode 100644
index 0000000000..3ad0f597fd
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ThrowablesTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+
+import org.junit.Test;
+
+public class ThrowablesTest {
+
+    @Test
+    public void typical() {
+        Throwable a = new Throwable();
+        Throwable b = new Throwable(a);
+        assertSame(a, Throwables.getRootCause(b));
+        assertSame(a, Throwables.getRootCause(a));
+    }
+
+    @Test
+    public void circularRef() {
+        // God forbidden
+        Throwable a = new Throwable();
+        Throwable b = new Throwable(a);
+        a.initCause(b);
+        assertSame(b, Throwables.getRootCause(b));
+        assertSame(a, Throwables.getRootCause(a));
+    }
+
+    @Test
+    public void nullCause() {
+        Throwable a = new Throwable();
+        assertSame(a, Throwables.getRootCause(a));
+    }
+
+    @Test
+    public void simplyNull() {
+        assertNull(Throwables.getRootCause(null));
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/TimingInfoTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/TimingInfoTest.java
new file mode 100644
index 0000000000..5fcf0ce56f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/TimingInfoTest.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static com.amazonaws.util.TimingInfo.UNKNOWN;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+
+public class TimingInfoTest {
+    @Test
+    public void startEndTiming() {
+        // Start timing
+        final long startTimeNano = System.nanoTime();
+        final long startTimeMilli = System.currentTimeMillis();
+        TimingInfo[] tis = {
+                TimingInfo.startTimingFullSupport(),
+                TimingInfo.startTiming()
+        };
+        for (TimingInfo ti : tis) {
+            assertTrue(ti.isStartEpochTimeMilliKnown());
+            assertTrue(ti.getStartTimeNano() >= startTimeNano);
+            assertTrue(ti.getStartEpochTimeMilli() >= startTimeMilli);
+            // End time is not known
+            assertFalse(ti.isEndTimeKnown());
+            assertTrue(ti.getEndTimeNano() == UNKNOWN);
+            assertTrue(ti.getEndEpochTimeMilli() == UNKNOWN);
+            assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+            assertTrue(ti.getTimeTakenMillis() == UNKNOWN);
+            assertTrue(ti.getElapsedTimeMillis() == UNKNOWN);
+            // End timing
+            ti.endTiming();
+            assertTrue(ti.isEndTimeKnown());
+            assertTrue(ti.getEndTimeNano() >= startTimeNano);
+            assertTrue(ti.getEndEpochTimeMilli() >= startTimeMilli);
+            assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+            assertTrue(ti.getTimeTakenMillis() >= 0);
+            assertTrue(ti.getElapsedTimeMillis() >= 0);
+        }
+    }
+
+    @Test
+    public void newTimingWithClockTime() throws InterruptedException {
+        final long startTimeMilli = System.currentTimeMillis();
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeMilli, startTimeNano,
+                endTimeNano);
+        assertTrue(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() == startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilli() == startTimeMilli);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNano() > startTimeNano);
+        assertTrue(ti.getEndEpochTimeMilli() >= startTimeMilli);
+        assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+        assertTrue(ti.getTimeTakenMillis() >= 0);
+        assertTrue(ti.getElapsedTimeMillis() >= 0);
+    }
+
+    @Test
+    public void newTimingWithNoClockTime() throws InterruptedException {
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeNano, endTimeNano);
+        assertFalse(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() == startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilli() == UNKNOWN);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNano() > startTimeNano);
+        assertTrue(ti.getEndEpochTimeMilli() == UNKNOWN);
+        assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+        assertTrue(ti.getTimeTakenMillis() >= 0);
+        assertTrue(ti.getElapsedTimeMillis() >= 0);
+    }
+
+    // Test the absurd case when the start/end times were insanely swapped
+    // perhaps by accident ?
+    @Test
+    public void absurdTimingWithNoClock() throws InterruptedException {
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        // absurdly swap the start/end times
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(endTimeNano, startTimeNano);
+        assertFalse(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() > startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilli() == UNKNOWN);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNano() < endTimeNano);
+        assertTrue(ti.getEndEpochTimeMilli() == UNKNOWN);
+        assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+        double double_diff = TimeUnit.NANOSECONDS.toMicros(startTimeNano - endTimeNano) / 1000.0;
+        assertTrue(ti.getTimeTakenMillis() == double_diff);
+        long long_diff = TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getElapsedTimeMillis() == long_diff);
+    }
+
+    // Test the absurd case when the start/end times were insanely swapped
+    // perhaps by accident
+    @Test
+    public void absurdTimingWithClock() throws InterruptedException {
+        final long startTimeMilli = System.currentTimeMillis();
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        // absurdly swap the start/end times
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeMilli, endTimeNano,
+                startTimeNano);
+        assertTrue(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() > startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilli() == startTimeMilli);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNano() < endTimeNano);
+        long end_epoch_time = startTimeMilli
+                + TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getEndEpochTimeMilli() == end_epoch_time);
+        assertTrue(ti.getEndTime() == ti.getEndEpochTimeMilli());
+        double double_diff = TimeUnit.NANOSECONDS.toMicros(startTimeNano - endTimeNano) / 1000.0;
+        assertTrue(ti.getTimeTakenMillis() == double_diff);
+        long long_diff = TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getElapsedTimeMillis() == long_diff);
+    }
+
+    @Test
+    public void startEndTimingIfKnown() {
+        // Start timing
+        final long startTimeNano = System.nanoTime();
+        final long startTimeMilli = System.currentTimeMillis();
+        TimingInfo ti = TimingInfo.startTimingFullSupport();
+        assertTrue(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() >= startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilliIfKnown().longValue() >= startTimeMilli);
+        // End time is not known
+        assertFalse(ti.isEndTimeKnown());
+        assertNull(ti.getEndTimeNanoIfKnown());
+        assertNull(ti.getEndEpochTimeMilliIfKnown());
+        assertNull(ti.getTimeTakenMillisIfKnown());
+        // End timing
+        ti.endTiming();
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNanoIfKnown().longValue() >= startTimeNano);
+        assertTrue(ti.getEndEpochTimeMilliIfKnown().longValue() >= startTimeMilli);
+        assertTrue(ti.getEndEpochTimeMilli() == ti.getEndEpochTimeMilliIfKnown().longValue());
+        assertTrue(ti.getTimeTakenMillisIfKnown().longValue() >= 0);
+    }
+
+    @Test
+    public void newTimingWithClockTimeIfKnown() throws InterruptedException {
+        final long startTimeMilli = System.currentTimeMillis();
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeMilli, startTimeNano,
+                endTimeNano);
+        assertTrue(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() == startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilliIfKnown().longValue() == startTimeMilli);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNanoIfKnown().longValue() > startTimeNano);
+        assertTrue(ti.getEndEpochTimeMilliIfKnown().longValue() >= startTimeMilli);
+        assertTrue(ti.getEndEpochTimeMilliIfKnown().longValue() == ti.getEndEpochTimeMilli());
+        assertTrue(ti.getTimeTakenMillisIfKnown().longValue() >= 0);
+    }
+
+    @Test
+    public void newTimingWithNoClockTimeIfKnown() throws InterruptedException {
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeNano, endTimeNano);
+        assertFalse(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() == startTimeNano);
+        assertNull(ti.getStartEpochTimeMilliIfKnown());
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNanoIfKnown().longValue() > startTimeNano);
+        assertNull(ti.getEndEpochTimeMilliIfKnown());
+        assertTrue(ti.getTimeTakenMillisIfKnown().longValue() >= 0);
+    }
+
+    // Test the absurd case when the start/end times were insanely swapped
+    // perhaps by accident ?
+    @Test
+    public void absurdTimingWithNoClockIfKnown() throws InterruptedException {
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        // absurdly swap the start/end times
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(endTimeNano, startTimeNano);
+        assertFalse(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() > startTimeNano);
+        assertNull(ti.getStartEpochTimeMilliIfKnown());
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNanoIfKnown().longValue() < endTimeNano);
+        assertNull(ti.getEndEpochTimeMilliIfKnown());
+        double double_diff = TimeUnit.NANOSECONDS.toMicros(startTimeNano - endTimeNano) / 1000.0;
+        assertTrue(ti.getTimeTakenMillisIfKnown().doubleValue() == double_diff);
+        long long_diff = TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getTimeTakenMillisIfKnown().longValue() == long_diff);
+    }
+
+    // Test the absurd case when the start/end times were insanely swapped
+    // perhaps by accident
+    @Test
+    public void absurdTimingWithClockIfKnown() throws InterruptedException {
+        final long startTimeMilli = System.currentTimeMillis();
+        final long startTimeNano = System.nanoTime();
+        Thread.sleep(1);// sleep for 1 millisecond
+        final long endTimeNano = System.nanoTime();
+        // absurdly swap the start/end times
+        TimingInfo ti = TimingInfo.newTimingInfoFullSupport(startTimeMilli, endTimeNano,
+                startTimeNano);
+        assertTrue(ti.isStartEpochTimeMilliKnown());
+        assertTrue(ti.getStartTimeNano() > startTimeNano);
+        assertTrue(ti.getStartEpochTimeMilliIfKnown().longValue() == startTimeMilli);
+        assertTrue(ti.isEndTimeKnown());
+        assertTrue(ti.getEndTimeNanoIfKnown().longValue() < endTimeNano);
+        long end_epoch_time = startTimeMilli
+                + TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getEndEpochTimeMilliIfKnown().longValue() == end_epoch_time);
+        assertTrue(ti.getEndEpochTimeMilliIfKnown().longValue() == ti.getEndEpochTimeMilli());
+        double double_diff = TimeUnit.NANOSECONDS.toMicros(startTimeNano - endTimeNano) / 1000.0;
+        assertTrue(ti.getTimeTakenMillisIfKnown().doubleValue() == double_diff);
+        long long_diff = TimeUnit.NANOSECONDS.toMillis(startTimeNano - endTimeNano);
+        assertTrue(ti.getTimeTakenMillisIfKnown().longValue() == long_diff);
+    }
+
+    @Test
+    public void subEventsEnabled() {
+        TimingInfo ti = TimingInfo.startTimingFullSupport();
+        ti.addSubMeasurement("m1", TimingInfo.startTimingFullSupport());
+        assertNotNull(ti.getAllSubMeasurements("m1"));
+
+        ti.incrementCounter("c1");
+        assertTrue(ti.getAllCounters().size() == 1);
+
+        ti.setCounter("c2", 0);
+        assertTrue(ti.getAllCounters().size() == 2);
+    }
+
+    @Test
+    public void subEventsDisabled() {
+        TimingInfo ti = TimingInfo.startTiming();
+        ti.addSubMeasurement("m1", TimingInfo.startTiming());
+        assertNull(ti.getAllSubMeasurements("m1"));
+
+        ti.incrementCounter("c1");
+        assertTrue(ti.getAllCounters().size() == 0);
+
+        ti.setCounter("c2", 0);
+        assertTrue(ti.getAllCounters().size() == 0);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/ValidationUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ValidationUtilsTest.java
new file mode 100644
index 0000000000..a07833d4fd
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/ValidationUtilsTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2015-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+public class ValidationUtilsTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertNotNull_NullObject_ThrowsException() {
+        ValidationUtils.assertNotNull(null, "someField");
+    }
+
+    @Test
+    public void assertNotNull_NonNullObject_ReturnsSameObject() {
+        final String nonNullString = "foo";
+        assertEquals(nonNullString, ValidationUtils.assertNotNull(nonNullString, "nonNullString"));
+    }
+
+    @Test
+    public void assertAllAreNull_AllNull_DoesNotThrow() {
+        ValidationUtils.assertAllAreNull("foo", null, null, null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertAllAreNull_SomeNull_ThrowsException() {
+        ValidationUtils.assertAllAreNull("foo", null, "non-null", null, null);
+    }
+
+    @Test
+    public void assertAllAreNull_NoneProvided_DoesNotThrow() {
+        ValidationUtils.assertAllAreNull("foo");
+    }
+
+    @Test
+    public void assertIsPositive_PositiveNumber_ReturnsSameNumber() {
+        assertEquals(42, ValidationUtils.assertIsPositive(42, "num"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertIsPositive_Zero_ThrowsException() {
+        ValidationUtils.assertIsPositive(0, "num");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertIsPositive_NegativeNumber_ThrowsException() {
+        ValidationUtils.assertIsPositive(-9001, "num");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertStringNotEmpty_NullString_ThrowsException() {
+        ValidationUtils.assertStringNotEmpty(null, "someString");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertStringNotEmpty_EmptyString_ThrowsException() {
+        ValidationUtils.assertStringNotEmpty("", "someString");
+    }
+
+    @Test
+    public void assertStringNotEmpty_NonEmptyString_ReturnsSameString() {
+        final String string = "foo";
+        assertEquals(string, ValidationUtils.assertStringNotEmpty(string, "someString"));
+    }
+
+    @Test
+    public void assertNotEmpty_NonNullCollection_ReturnsSameObject() {
+        final List<String> testList = new ArrayList<String>();
+        testList.add("sample");
+        assertEquals(testList, ValidationUtils.assertNotEmpty(testList, "testList"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertNotEmpty_NullCollection_ThrowsException() {
+        ValidationUtils.assertNotEmpty((Collection<String>) null, "someCollection");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertNotEmpty_EmptyCollection_ThrowsException() {
+        final List<String> testList = new ArrayList<String>();
+        ValidationUtils.assertNotEmpty(testList, "testList");
+    }
+
+    @Test
+    public void assertNotEmpty_NonNullArray_ReturnsSameObject() {
+        final String[] array = new String[] {
+                "foo", "bar"
+        };
+        assertArrayEquals(array, ValidationUtils.assertNotEmpty(array, "array"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertNotEmpty_NullArray_ThrowsException() {
+        ValidationUtils.assertNotEmpty((String[]) null, "array");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void assertNotEmpty_EmptyArray_ThrowsException() {
+        ValidationUtils.assertNotEmpty(new String[0], "array");
+    }
+
+}
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/VersionInfoUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/VersionInfoUtilsTest.java
new file mode 100644
index 0000000000..1389ea04db
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/VersionInfoUtilsTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import org.junit.Test;
+
+public class VersionInfoUtilsTest {
+
+    @Test
+    public void getVersion() {
+        assertEquals("2.6.19", VersionInfoUtils.getVersion());
+    }
+
+    @Test
+    public void userAgent() {
+        String userAgent = VersionInfoUtils.userAgent();
+        System.out.println(userAgent);
+        System.out.println(userAgent.length());
+        assertNotNull(userAgent);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/XMLWriterTests.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/XMLWriterTests.java
new file mode 100644
index 0000000000..d08966c681
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/XMLWriterTests.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import java.io.StringWriter;
+import java.util.Calendar;
+import java.util.Date;
+
+public class XMLWriterTests {
+
+    @Test
+    public void testEscapeXMLEntitiesProperlyEscapedFromString() {
+
+        String expectedString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Test>quote &quot;&quot; apostrophe &apos;&apos; lessthan &lt;&lt; greaterthan &gt;&gt; ampersand &amp;&amp;</Test>";
+        StringWriter sw = new StringWriter();
+        XMLWriter xw = new XMLWriter(sw);
+        xw.startElement("Test");
+        xw.value("quote &quot;\" apostrophe &apos;' lessthan &lt;< greaterthan &gt;> ampersand &amp;&");
+        xw.endElement();
+        sw.flush();
+
+        assertEquals(sw.toString(), expectedString);
+    }
+
+    @Test
+    public void testEscapeXMLEntitiesProperlyEscapedFromObject() {
+
+        final String objectValue = "quote &quot;&quot; apostrophe &apos;&apos; lessthan &lt;&lt; greaterthan &gt;&gt; ampersand &amp;&amp;";
+        String expectedString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Test>" + objectValue
+                + "</Test>";
+        Object objectToWrite = new Object() {
+            @Override
+            public String toString() {
+                return objectValue;
+            }
+        };
+
+        StringWriter sw = new StringWriter();
+        XMLWriter xw = new XMLWriter(sw);
+        xw.startElement("Test");
+        xw.value(objectToWrite);
+        xw.endElement();
+        sw.flush();
+
+        assertEquals(sw.toString(), expectedString);
+    }
+
+    @Test
+    public void testXMLWriterWithDates() {
+
+        Calendar cal = Calendar.getInstance();
+        cal.clear();
+        cal.set(2015, 4, 24);
+        Date date = cal.getTime();
+
+        String expectedString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Test>"
+                + StringUtils.fromDate(date) + "</Test>";
+        StringWriter sw = new StringWriter();
+        XMLWriter xw = new XMLWriter(sw);
+        xw.startElement("Test");
+        xw.value(date);
+        xw.endElement();
+        sw.flush();
+
+        assertEquals(sw.toString(), expectedString);
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/XpathUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/XpathUtilsTest.java
new file mode 100644
index 0000000000..66270c572e
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/XpathUtilsTest.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+
+import java.nio.ByteBuffer;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+
+/**
+ * Unit tests for the XpathUtils class.
+ *
+ * @author fulghum@amazon.com
+ */
+public class XpathUtilsTest {
+
+    /** Test data for all tests to share */
+    private static final String DOCUMENT =
+            "<Foo>" +
+                    "    <Title>Boo</Title>" +
+                    "    <Count Foo='Bar'>1</Count>" +
+                    "    <Enabled>true</Enabled>" +
+                    "    <Usage>0.0000071759</Usage>" +
+                    "    <Since>2008-10-07T11:51:50.000Z</Since>" +
+                    "    <Item>A</Item>" +
+                    "    <Item>B</Item>" +
+                    "    <Item>C</Item>" +
+                    "    <Empty></Empty>" +
+                    "    <Blob>aGVsbG8gd29ybGQ=</Blob>" +
+                    "    <PositiveByte>123</PositiveByte>" +
+                    "    <NegativeByte>-99</NegativeByte>" +
+                    "</Foo>";
+
+    /** Test XML document with a namespace */
+    private static final String DOCUMENT_WITH_NAMESPACE =
+            "<?xml version=\"1.0\"?> \n"
+                    +
+                    "<AllocateAddressResponse xmlns=\"http://ec2.amazonaws.com/doc/2009-04-04/\"> \n"
+                    +
+                    "    <requestId>a074658d-7624-433e-b4e9-9271f6f5264b</requestId> \n" +
+                    "    <publicIp>174.129.242.223</publicIp> \n" +
+                    "</AllocateAddressResponse> \n";
+
+    @Test
+    public void testXmlDocumentWithNamespace() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT_WITH_NAMESPACE);
+        Node root = XpathUtils.asNode("/", document);
+        assertNotNull(root);
+        Node node = XpathUtils.asNode("AllocateAddressResponse", document);
+        assertNotNull(node);
+
+    }
+
+    @Test
+    public void testGetRoot() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        Node childTitleNode = XpathUtils.asNode("Foo/Title", document);
+        Node childAsRoot = XpathUtils.asNode("/", childTitleNode);
+        assertEquals("#document", childAsRoot.getNodeName());
+    }
+
+    @Test
+    public void testAsString() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertEquals("Boo", XpathUtils.asString("Foo/Title", document));
+        assertEquals("", XpathUtils.asString("Foo/Empty", document));
+        assertEquals("Bar", XpathUtils.asString("Foo/Count/@Foo", document));
+        Document namespaceDocument = XpathUtils.documentFrom(DOCUMENT_WITH_NAMESPACE);
+        assertEquals("174.129.242.223",
+                XpathUtils.asString("/AllocateAddressResponse/publicIp", namespaceDocument));
+    }
+
+    @Test
+    public void testAsInteger() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertEquals((Integer) 1, XpathUtils.asInteger("Foo/Count", document));
+        assertEquals(null, XpathUtils.asInteger("Foo/Empty", document));
+    }
+
+    @Test
+    public void testAsBoolean() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertEquals(true, XpathUtils.asBoolean("Foo/Enabled", document));
+        assertEquals(null, XpathUtils.asBoolean("Foo/Empty", document));
+    }
+
+    @Test
+    public void testAsFloat() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertEquals((Float) 0.0000071759f, XpathUtils.asFloat("Foo/Usage", document));
+        assertEquals(null, XpathUtils.asFloat("Foo/Empty", document));
+    }
+
+    /**
+     * Tests that we can correctly pull a Byte out of an XML document.
+     */
+    @Test
+    public void testAsByte() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertEquals(new Byte((byte) 123), XpathUtils.asByte("Foo/PositiveByte", document));
+        assertEquals(new Byte((byte) -99), XpathUtils.asByte("Foo/NegativeByte", document));
+        assertEquals(null, XpathUtils.asByte("Foo/Empty", document));
+    }
+
+    /**
+     * Tests that we can correctly parse out a Date from an XML document.
+     */
+    @Test
+    public void testAsDate() throws Exception {
+        /*
+         * The example date in our test XML document is:
+         * 2008-10-07T11:51:50.000Z So we construct that same date and verify
+         * that it matches what we parsed out of the XML.
+         */
+        Calendar expectedDate = new GregorianCalendar();
+        expectedDate.set(Calendar.YEAR, 2008);
+        expectedDate.set(Calendar.MONTH, Calendar.OCTOBER);
+        expectedDate.set(Calendar.DAY_OF_MONTH, 7);
+        expectedDate.set(Calendar.AM_PM, Calendar.AM);
+        expectedDate.set(Calendar.HOUR, 11);
+        expectedDate.set(Calendar.MINUTE, 51);
+        expectedDate.set(Calendar.SECOND, 50);
+        expectedDate.set(Calendar.MILLISECOND, 0);
+        expectedDate.setTimeZone(new SimpleTimeZone(0, "UTC"));
+
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        Date date = XpathUtils.asDate("Foo/Since", document);
+        assertNotNull(date);
+        assertEquals(expectedDate.getTimeInMillis(), date.getTime());
+
+        assertEquals(null, XpathUtils.asDate("Foo/Empty", document));
+    }
+
+    @Test
+    public void testIsEmpty() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        Node emptyNode = XpathUtils.asNode("Foo/Fake", document);
+        Node realNode = XpathUtils.asNode("Foo/Count", document);
+
+        assertTrue(XpathUtils.isEmpty(emptyNode));
+        assertFalse(XpathUtils.isEmpty(realNode));
+    }
+
+    @Test
+    public void testAsNode() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        Node node = XpathUtils.asNode("Foo/Title", document);
+        assertNotNull(node);
+        assertEquals("Title", node.getNodeName());
+    }
+
+    /**
+     * Tests that we return null when a specified expression doesn't evaluate
+     * anything (instead of passing that null/empty value to a parser and
+     * getting an error in the parser).
+     */
+    @Test
+    public void testMissingNodes() throws Exception {
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        assertNull(XpathUtils.asDouble("non-existant-node/name", document));
+        assertNull(XpathUtils.asLong("non-existant-node/name", document));
+        assertNull(XpathUtils.asInteger("non-existant-node/name", document));
+        assertNull(XpathUtils.asDate("non-existant-node/name", document));
+        assertNull(XpathUtils.asFloat("non-existant-node/name", document));
+        assertNull(XpathUtils.asString("non-existant-node/name", document));
+    }
+
+    /**
+     * Tests that {@link XpathUtils#asByteBuffer(String, Node)} correctly base64
+     * decodes the XML text data and transforms it into a ByteBuffer.
+     */
+    @Test
+    public void testAsByteBuffer() throws Exception {
+        String expectedData = "hello world";
+
+        Document document = XpathUtils.documentFrom(DOCUMENT);
+        ByteBuffer byteBuffer = XpathUtils.asByteBuffer("Foo/Blob", document);
+        assertEquals(expectedData.length(), byteBuffer.limit());
+
+        String data = new String(byteBuffer.array(), StringUtils.UTF8);
+        assertEquals(expectedData, data);
+
+        assertEquals(null, XpathUtils.asByteBuffer("Foo/Empty", document));
+    }
+
+}
diff --git a/aws-java-sdk-core/src/test/java/com/amazonaws/util/json/JsonUtilsTest.java b/aws-java-sdk-core/src/test/java/com/amazonaws/util/json/JsonUtilsTest.java
new file mode 100644
index 0000000000..14d42a944a
--- /dev/null
+++ b/aws-java-sdk-core/src/test/java/com/amazonaws/util/json/JsonUtilsTest.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *    http://aws.amazon.com/apache2.0
+ *
+ * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amazonaws.util.json;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import com.amazonaws.util.json.JsonUtils.JsonEngine;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.nio.ByteBuffer;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+public class JsonUtilsTest {
+    private static final String JSON_STRING = "{\"string\":\"string\","
+            + "\"long\":123,"
+            + "\"double\":123.45,"
+            + "\"null\":null,"
+            + "\"true\":true,"
+            + "\"false\":false,"
+            + "\"encoding\":\"Chlo\","
+            + "\"array\":[\"string\",123,123.45,null,true,false],"
+            + "\"object\":{}"
+            + "}";
+
+    @Test
+    public void testJsonToMap() {
+        Map<String, String> map = JsonUtils.jsonToMap(JSON_STRING);
+        assertEquals("string value", "string", map.get("string"));
+        assertEquals("long value", "123", map.get("long"));
+        assertEquals("double value", "123.45", map.get("double"));
+        assertEquals("null value", null, map.get("null"));
+        assertEquals("true value", "true", map.get("true"));
+        assertEquals("false value", "false", map.get("false"));
+        assertEquals("encoding", "Chlo", map.get("encoding"));
+        assertNull("array is ignored", map.get("array"));
+        assertNull("object is ignored", map.get("object"));
+    }
+
+    @Test
+    public void testMapToJson() {
+        Map<String, String> source = new HashMap<String, String>();
+        source.put("string", "string");
+        source.put("long", "123");
+        source.put("double", "123.45");
+        source.put("null", null);
+        source.put("true", "true");
+        source.put("false", "false");
+        source.put("encoding", "Chlo");
+
+        String json = JsonUtils.mapToString(source);
+        Map<String, String> map = JsonUtils.jsonToMap(json);
+        assertEquals("string value", "string", map.get("string"));
+        assertEquals("long value", "123", map.get("long"));
+        assertEquals("double value", "123.45", map.get("double"));
+        assertEquals("null value", null, map.get("null"));
+        assertEquals("true value", "true", map.get("true"));
+        assertEquals("false value", "false", map.get("false"));
+        assertEquals("encoding", "Chlo", map.get("encoding"));
+    }
+
+    @Test
+    public void testEmptyMapToJson() {
+        Map<String, String> source = new HashMap<String, String>();
+        assertEquals("empty map", "{}", JsonUtils.mapToString(source));
+    }
+
+    @Test
+    public void testNullJsonToMap() {
+        String nullStr = null;
+        Map<String, String> map = JsonUtils.jsonToMap(nullStr);
+        assertNotNull("map isn't null", map);
+        assertTrue("map is empty", map.isEmpty());
+    }
+
+    @Test
+    public void testEmptyJsonToMap() {
+        String json = "";
+        Map<String, String> map = JsonUtils.jsonToMap(json);
+        assertTrue("empty string", map.isEmpty());
+    }
+
+    @Test
+    public void testJsonReader() throws IOException {
+        AwsJsonReader reader = JsonUtils.getJsonReader(new StringReader(JSON_STRING));
+        reader.beginObject();
+        assertTrue("has properties", reader.hasNext());
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("string")) {
+                assertTrue("VALUE_STRING", AwsJsonToken.VALUE_STRING == reader.peek());
+                assertEquals("string value", "string", reader.nextString());
+            } else if (name.equals("long")) {
+                assertTrue("VALUE_NUMBER", AwsJsonToken.VALUE_NUMBER == reader.peek());
+                assertEquals("long value", "123", reader.nextString());
+            } else if (name.equals("double")) {
+                assertTrue("VALUE_NUMBER", AwsJsonToken.VALUE_NUMBER == reader.peek());
+                assertEquals("double value", "123.45", reader.nextString());
+            } else if (name.equals("null")) {
+                assertTrue("VALUE_NULL", AwsJsonToken.VALUE_NULL == reader.peek());
+                assertNull("null value", reader.nextString());
+            } else if (name.equals("true")) {
+                assertTrue("VALUE_BOOLEAN", AwsJsonToken.VALUE_BOOLEAN == reader.peek());
+                assertEquals("true value", "true", reader.nextString());
+            } else if (name.equals("false")) {
+                assertTrue("VALUE_BOOLEAN", AwsJsonToken.VALUE_BOOLEAN == reader.peek());
+                assertEquals("false value", "false", reader.nextString());
+            } else if (name.equals("encoding")) {
+                assertTrue("VALUE_STRING", AwsJsonToken.VALUE_STRING == reader.peek());
+                assertEquals("encoding", "Chlo", reader.nextString());
+            } else if (name.equals("array")) {
+                assertTrue("BEGIN_ARRAY", AwsJsonToken.BEGIN_ARRAY == reader.peek());
+                reader.beginArray();
+                assertTrue("has next", reader.hasNext());
+                assertEquals("string value", "string", reader.nextString());
+                assertEquals("long value", "123", reader.nextString());
+                assertEquals("double value", "123.45", reader.nextString());
+                assertNull("null value", reader.nextString());
+                assertEquals("true value", "true", reader.nextString());
+                assertEquals("false value", "false", reader.nextString());
+                reader.endArray();
+            } else if (name.equals("object")) {
+                assertTrue("BEGIN_OBJECT", AwsJsonToken.BEGIN_OBJECT == reader.peek());
+                reader.beginObject();
+                assertFalse("empty object", reader.hasNext());
+                reader.endObject();
+            } else {
+                fail("should not reach here");
+            }
+        }
+        reader.endObject();
+    }
+
+    @Test
+    public void testJsonWriter() throws IOException {
+        StringWriter out = new StringWriter();
+        AwsJsonWriter writer = JsonUtils.getJsonWriter(out);
+        writer.beginObject()
+                .name("string").value("string")
+                .name("long").value(123)
+                .name("double").value(123.45)
+                .name("null").value()
+                .name("true").value(true)
+                .name("false").value(false)
+                .name("encoding").value("Chlo")
+                .name("array").beginArray()
+                .value("string").value(123).value(123.45).value().value(true).value(false)
+                .endArray()
+                .name("object").beginObject().endObject()
+                .endObject().close();
+        String json = out.toString();
+        assertEquals("same json", JSON_STRING, json);
+    }
+
+    @Test
+    public void testReadPerformance() throws IOException {
+        Map<String, String> map = new HashMap<String, String>();
+        for (int i = 0; i < 5000; i++) {
+            map.put("key" + i, "value" + i);
+        }
+        String json = JsonUtils.mapToString(map);
+
+        JsonUtils.setJsonEngine(JsonEngine.Jackson);
+        long start = System.nanoTime();
+        for (int i = 0; i < 1000; i++) {
+            JsonUtils.jsonToMap(json);
+        }
+        System.out.println("Serialize a 5000 properties map 1000 times");
+        System.out.println("Jackson read elapsed: "
+                + (System.nanoTime() - start) / 1000000 + "ms");
+
+        JsonUtils.setJsonEngine(JsonEngine.Gson);
+        start = System.nanoTime();
+        for (int i = 0; i < 1000; i++) {
+            JsonUtils.jsonToMap(json);
+        }
+        System.out.println("Gson read elapsed: "
+                + (System.nanoTime() - start) / 1000000 + "ms");
+    }
+
+    @Test
+    public void testWritePerformance() throws IOException {
+        Map<String, String> map = new HashMap<String, String>();
+        for (int i = 0; i < 5000; i++) {
+            map.put("key" + i, "value" + i);
+        }
+
+        System.out.println("Deserialize a JSON string with a 5000 properties map 1000 times");
+        JsonUtils.setJsonEngine(JsonEngine.Jackson);
+        long start = System.nanoTime();
+        for (int i = 0; i < 1000; i++) {
+            JsonUtils.mapToString(map);
+        }
+        System.out.println("Jackson write elapsed: "
+                + (System.nanoTime() - start) / 1000000 + "ms");
+
+        JsonUtils.setJsonEngine(JsonEngine.Gson);
+        start = System.nanoTime();
+        for (int i = 0; i < 1000; i++) {
+            JsonUtils.mapToString(map);
+        }
+        System.out.println("Gson write elapsed: "
+                + (System.nanoTime() - start) / 1000000 + "ms");
+    }
+
+    @Test
+    public void testDate() throws IOException {
+        Date d = new Date(1423875641895L);
+        String target = "1423875641.895";
+
+        JsonUtils.setJsonEngine(JsonEngine.Gson);
+        StringWriter out = new StringWriter();
+        // This is wrapped in an array so that Gson doesn't complain about
+        // invalid JSON encoding
+        JsonUtils.getJsonWriter(out)
+                .beginArray().value(d).endArray()
+                .close();
+        assertEquals("[" + target + "]", out.toString());
+        out.getBuffer().setLength(0); // clear string writer
+
+        JsonUtils.setJsonEngine(JsonEngine.Jackson);
+        JsonUtils.getJsonWriter(out)
+                .beginArray().value(d).endArray()
+                .close();
+        assertEquals("[" + target + "]", out.toString());
+    }
+
+    @Test
+    public void testByteBuffer() throws IOException {
+        ByteBuffer bb = generateByteBuffer(16);
+        // Note: the target string is back filled with the output of the above
+        // byte buffer
+        String target = "AAECAwQFBgcICQoLDA0ODw==";
+
+        JsonUtils.setJsonEngine(JsonEngine.Gson);
+        StringWriter out = new StringWriter();
+        JsonUtils.getJsonWriter(out)
+                .beginArray().value(bb).endArray()
+                .close();
+        assertEquals("[\"" + target + "\"]", out.toString());
+        out.getBuffer().setLength(0);
+
+        JsonUtils.setJsonEngine(JsonEngine.Jackson);
+        JsonUtils.getJsonWriter(out)
+                .beginArray().value(bb).endArray()
+                .close();
+        assertEquals("[\"" + target + "\"]", out.toString());
+    }
+
+    private ByteBuffer generateByteBuffer(int length) {
+        byte[] bytes = new byte[length];
+        for (int i = 0; i < length; i++) {
+            bytes[i] = (byte) (i % Byte.MAX_VALUE);
+        }
+        return ByteBuffer.wrap(bytes);
+    }
+}
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/auth/sessionResponseExpired.json b/aws-java-sdk-core/src/test/resources/com/amazonaws/auth/sessionResponseExpired.json
new file mode 100644
index 0000000000..3965ae2ad6
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/auth/sessionResponseExpired.json
@@ -0,0 +1,9 @@
+{
+  "Code" : "Success",
+  "LastUpdated" : "2012-05-02T22:55:54Z",
+  "Type" : "AWS-HMAC",
+  "AccessKeyId" : "ACCESS_KEY_ID",
+  "SecretAccessKey" : "SECRET_ACCESS_KEY",
+  "Token" : "TOKEN_TOKEN_TOKEN",
+  "Expiration" : "2012-05-03T04:55:54Z"
+}
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/mixed.handlers b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/mixed.handlers
new file mode 100644
index 0000000000..e1ad44b1db
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/mixed.handlers
@@ -0,0 +1,2 @@
+com.amazonaws.handlers.MockRequestHandler2
+com.amazonaws.handlers.MockRequestHandler1
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handler2s b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handler2s
new file mode 100644
index 0000000000..620ca4aa8f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handler2s
@@ -0,0 +1,3 @@
+com.amazonaws.handlers.MockRequestHandler2
+
+
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handlers b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handlers
new file mode 100644
index 0000000000..5280b65d02
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/handlers/request.handlers
@@ -0,0 +1,3 @@
+
+
+com.amazonaws.handlers.MockRequestHandler1
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/sdk/versionInfo.properties b/aws-java-sdk-core/src/test/resources/com/amazonaws/sdk/versionInfo.properties
new file mode 100644
index 0000000000..08bcc181e2
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/sdk/versionInfo.properties
@@ -0,0 +1,2 @@
+version = 1.2.3
+platform = java
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/com/amazonaws/util/ClassLoaderHelperTestFile b/aws-java-sdk-core/src/test/resources/com/amazonaws/util/ClassLoaderHelperTestFile
new file mode 100644
index 0000000000..58dfa6977f
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/com/amazonaws/util/ClassLoaderHelperTestFile
@@ -0,0 +1 @@
+TestFile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/AccessKeyNotSpecified.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/AccessKeyNotSpecified.tst
new file mode 100644
index 0000000000..0f827745d4
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/AccessKeyNotSpecified.tst
@@ -0,0 +1,8 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[test]
+aws_access_key_id=testProfile1
+aws_secret_access_key=testProfile1
+[test2]
+aws_secret_access_key=testProfile2
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoBraces.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoBraces.tst
new file mode 100644
index 0000000000..87fd1a1db8
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoBraces.tst
@@ -0,0 +1,6 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+test
+aws_access_key_id=testProfile
+aws_secret_access_key=testProfile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoClosingBraces.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoClosingBraces.tst
new file mode 100644
index 0000000000..42a0a316b5
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoClosingBraces.tst
@@ -0,0 +1,6 @@
+[default
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[  ]
+aws_access_key_id=testProfile
+aws_secret_access_key=testProfile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoOpeningBraces.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoOpeningBraces.tst
new file mode 100644
index 0000000000..83243284cb
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithNoOpeningBraces.tst
@@ -0,0 +1,6 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+test]
+aws_access_key_id=testProfile
+aws_secret_access_key=testProfile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithSpaces.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithSpaces.tst
new file mode 100644
index 0000000000..444f11d655
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfileNameWithSpaces.tst
@@ -0,0 +1,6 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[  ]
+aws_access_key_id=testProfile
+aws_secret_access_key=testProfile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesContainingOtherConfigurations.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesContainingOtherConfigurations.tst
new file mode 100644
index 0000000000..85c40afcf8
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesContainingOtherConfigurations.tst
@@ -0,0 +1,12 @@
+[default]
+aws_secret_access_key = defaultAccessKey
+aws_access_key_id = defaultSecretAccessKey
+region = us-west-2
+
+
+[test]
+output = sdfsdf
+region = saa
+aws_access_key_id = test
+aws_secret_access_key = test key
+
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithComments.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithComments.tst
new file mode 100644
index 0000000000..8e0f5c2459
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithComments.tst
@@ -0,0 +1,30 @@
+# I love comments...
+
+# [a]
+[a]
+#aws_access_key_id=wrong-key
+aws_access_key_id=a
+# More comments...
+aws_secret_access_key=a
+unsupported_property=foo
+
+# More comments...
+
+[b]
+# More comments...
+aws_access_key_id=b
+aws_secret_access_key=b
+
+[c]
+aws_access_key_id=c
+# More comments...
+aws_secret_access_key=c
+aws_session_token=c
+
+[d]
+aws_access_key_id=d
+aws_secret_access_key=d
+# More comments...
+aws_session_token=d
+
+# More comments...
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithNoProfileName.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithNoProfileName.tst
new file mode 100644
index 0000000000..ce1e65ea03
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithNoProfileName.tst
@@ -0,0 +1,6 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[]
+aws_access_key_id=testProfile
+aws_secret_access_key=testProfile
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSameProfileName.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSameProfileName.tst
new file mode 100644
index 0000000000..72975bf3d9
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSameProfileName.tst
@@ -0,0 +1,10 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[test]
+aws_access_key_id=testProfile1
+aws_secret_access_key=testProfile1
+[test]
+aws_access_key_id=testProfile2
+aws_secret_access_key=testProfile2
+aws_session_token = testProfile2
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSecretAccessKeyNotSpecified.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSecretAccessKeyNotSpecified.tst
new file mode 100644
index 0000000000..43715f8617
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithSecretAccessKeyNotSpecified.tst
@@ -0,0 +1,8 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[profile test]
+aws_access_key_id=testProfile1
+aws_secret_access_key=testProfile1
+[profile test2]
+aws_access_key_id=testProfile2
\ No newline at end of file
diff --git a/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithTwoAccessKeyUnderSameProfile.tst b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithTwoAccessKeyUnderSameProfile.tst
new file mode 100644
index 0000000000..7a0db577a6
--- /dev/null
+++ b/aws-java-sdk-core/src/test/resources/resources/profileconfig/ProfilesWithTwoAccessKeyUnderSameProfile.tst
@@ -0,0 +1,10 @@
+[default]
+aws_access_key_id=testDefault
+aws_secret_access_key=testDefault
+[profile test]
+aws_access_key_id=testProfile1
+aws_secret_access_key=testProfile1
+[profile test2]
+aws_access_key_id=testProfile2
+aws_access_key_id=testProfile3
+aws_secret_access_key=testProfile2
\ No newline at end of file
