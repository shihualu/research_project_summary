diff --git a/.gitignore b/.gitignore
index 76806924..8cfcff0b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,45 @@
-library/bin
-library/build
-library/gen
-library/.project
-library/.classpath
-library/library.iml
-library/.gradle
+.DS_Store
+
+# built application files
+*.apk
+*.ap_
+
+# files for the dex VM
+*.dex
+
+# Java class files
 *.class
+
+# generated files
+bin/
+gen/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Eclipse project files
+.classpath
+.project
+
+*.a
+*.dylib
+*.log
+*.o
+*.pot
+*.pyc
+*.pydevproject
+*.so
+*.suo
+*.xcworkspace
+*_ReSharper*
+
 .DS_Store
+._.DS_Store
+
+project.properties
+
+.settings
+build/
+.gradle/
+.idea
+*.iml
diff --git a/.travis.yml b/.travis.yml
index ab91b91e..6e0beddd 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,13 +1,31 @@
 language: android
+jdk: oraclejdk7
+
+env:
+  global:
+    - TERM=dumb
 android:
   components:
-    - sys-img-x86-android-17
-    - build-tools-19.1.0
-    - android-17
-    - android-19
-
+    - sys-img-armeabi-v7a-android-23
+    - tools
+    - build-tools-23.0.3
+    - android-23
+    - extra-android-m2repository
 before_script:
-  - cd library
-
+  - sudo service postgresql stop || true
+  - sudo service mysql stop || true
+  - sudo service memcached stop || true
+  - sudo service bootlogd stop || true
+  - sudo service elasticsearch stop || true
+  - sudo service mongodb stop || true
+  - sudo service neo4j stop || true
+  - sudo service cassandra stop || true
+  - sudo service riak stop || true
+  - sudo service rsync stop || true
+  - sudo service x11-common stop || true
 script:
-  - ant travis-all
+  - ./gradlew clean build connectedCheck coveralls
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..7015053d
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,94 @@
+# Sugar Releases
+
+## [Unreleased]
+
+
+## v1.5
+### Added
+* [#328](https://github.com/satyan/sugar/pull/328) @jedid auto add new columns during database upgrade, fix [#299](https://github.com/satyan/sugar/issues/299) and [#151](https://github.com/satyan/sugar/issues/151)
+* [#389](https://github.com/satyan/sugar/pull/389) @alfmatos MultiUnique DSL to handle MultiColumn Unique Table constraint
+* @sibeliusseraphini update, updateInTx methods based on Unique values of SugarRecord
+* [#155](https://github.com/satyan/sugar/issues/155) @benohalloran adding Cursors for Cursor Adapters [Pull 312](https://github.com/satyan/sugar/pull/312)
+* [#430](https://github.com/satyan/sugar/pull/430) @sibeliusseraphini update to roboelectric 3.0 and target android-32
+
+### Changed
+* [#437](https://github.com/satyan/sugar/pull/437) @dnalves removing guava dependency, using synchronized WeakHashMap instead
+* [#423](https://github.com/satyan/sugar/pull/423) @sibeliusseraphini moving changelog of README.md to CHANGELOG.md
+
+### Fixed
+* [#362](https://github.com/satyan/sugar/pull/362) @mitchyboy9 fixed NoClassDefFoundError
+* [#455](https://github.com/satyan/sugar/pull/455) @nurolopher fixed travis and coveralls config 
+* [#434](https://github.com/satyan/sugar/pull/434) @bendaniel10 fix multi-dex
+* [#410](https://github.com/satyan/sugar/pull/410) [#408](https://github.com/satyan/sugar/pull/408) @RoyMontoya simplify code
+* [#327](https://github.com/satyan/sugar/pull/327) @tracytheron support multi-dex
+* [#373](https://github.com/satyan/sugar/pull/373) @salimkamboh use existing tables
+
+## v1.4
+### Added
+* [#306](https://github.com/satyan/sugar/pull/306) @Shyish return boolean/integer on delete methods
+* [#304](https://github.com/satyan/sugar/pull/304) @benohalloran add support to enum type
+* [#197](https://github.com/satyan/sugar/pull/197) @andresteves add suport for bytes[]
+* [#293](https://github.com/satyan/sugar/pull/293) @neilw4 support NULL in queries
+* [#273](https://github.com/satyan/sugar/pull/273) @dominicwong617 findById support an array of ids
+* [#246](https://github.com/satyan/sugar/pull/246) @kwf2030 use sqlite\_master to check whether table already exist
+* [#253](https://github.com/satyan/sugar/pull/202) @JeroenMols add bulk delete
+* [#285](https://github.com/satyan/sugar/pull/202) @Shyish add listAll with orderBy param
+* No need to extend SugarApp - just call SugarContext.init(Context) instead
+* [#129](https://github.com/satyan/sugar/pull/129) @satyan support sugar entities using @Table annotations
+
+### Fixed
+* [#314](https://github.com/satyan/sugar/pull/314) @abscondment fix StrictMode DexFile
+* [#303](https://github.com/satyan/sugar/pull/303) @RossinesP fixed saving row string bug
+* [#258](https://github.com/satyan/sugar/pull/258) @nosrak113 change SugarRecord ID to private to not conflit with other libraries
+* [#254](https://github.com/satyan/sugar/pull/254) @jivimberg use weak keys to keep track of annotated entities
+* [#215](https://github.com/satyan/sugar/issues/215) @jivimberg fix bug persisting relationship
+* [#185](https://github.com/satyan/sugar/issues/185) [#243](https://github.com/satyan/sugar/issues/243) @whoshuu fix save and update method
+* [#202](https://github.com/satyan/sugar/pull/202) @allieus improve getDomainsClass()
+* [#104](https://github.com/satyan/sugar/issues/104) @whoshuu fix nesting "and" and "or"
+
+## v1.4 Beta [[jar](https://github.com/satyan/sugar/releases/download/v1.4_beta/sugar-1.4_beta.jar)]
+### Added
+* [#112](https://github.com/satyan/sugar/pull/112) @androdevcafe added Unique and NotNull annotations
+* [#78](https://github.com/satyan/sugar/pull/78) @HiddenCleverde capability to specify primary key
+
+### Fixed
+* [#113](https://github.com/satyan/sugar/pull/113) @whoshuu override findById to support int
+* [#106](https://github.com/satyan/sugar/issues/106) @whoshuu add documentation to onTerminate
+* [#54](https://github.com/satyan/sugar/issues/54) @whoshuu simplify count interface
+* [#43](https://github.com/satyan/sugar/issues/43) @whoshuu return id on save
+* [#72](https://github.com/satyan/sugar/issues/72) @whoshuu allow null values to Date and Calendar objects
+* [#96](https://github.com/satyan/sugar/issues/96) @whoshuu roboeletric fallback
+
+## v1.3 [[jar](https://github.com/satyan/sugar/releases/download/v1.3/sugar-1.3.jar)]
+
+- Transaction Support
+- Bulk Insert of records 
+- Encrypted datastore (branch : sugar-cipher using sqlcipher)
+- Removed Constructor with context parameter. Needs default constructor now.
+- Enhancements to QueryBuilder
+- Bug fixes and other improvements.
+
+## v1.2 [[jar](https://github.com/satyan/sugar/releases/download/v1.2/sugar-1.2.jar)]
+
+- package restriction for domain classes.
+- metadata caching
+- QueryBuilder v1
+- Database Migrations
+- Provision for Raw queries
+- Better and more organized api guide and usage instructions.
+
+## v1.1 [[jar](https://github.com/satyan/sugar/releases/download/v1.1/sugar-1.1.jar)]
+
+- Static api doesn't take context anymore. Hence
+
+```java
+Book.findById(context, Book.class, 1);
+```
+
+becomes
+
+```java
+Book.findById(Book.class, 1);
+```
+
+- Some cleanup in the code.
diff --git a/README.md b/README.md
index 4480e154..6986479b 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,15 @@
-# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar)
+# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar) [![Coverage Status](https://coveralls.io/repos/satyan/sugar/badge.svg?branch=master)](https://coveralls.io/r/satyan/sugar?branch=master) [![Code Triagers Badge](http://www.codetriage.com/satyan/sugar/badges/users.svg)](http://www.codetriage.com/satyan/sugar)
+
+[![Join the chat at https://gitter.im/satyan/sugar](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/satyan/sugar?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 Insanely easy way to work with Android databases.
 
-Official documentation can be found [here](http://satyan.github.io/sugar). The example application is provided in the **example** folder in the source.
+Official documentation can be found [here](http://satyan.github.io/sugar) - Check some examples below. The example application is provided in the **example** folder in the source.
+
+## Looking for contributors
+We need contributors to help maintain this project, ask @satyan for repo permission
+
+Otherwise you can use another ORM, like https://github.com/requery/requery or https://realm.io/
 
 ## Features
 
@@ -21,7 +28,7 @@ There are four ways to install Sugar:
 This is the preferred way. Simply add:
 
 ```groovy
-compile 'com.github.satyan:sugar:1.3'
+compile 'com.github.satyan:sugar:1.5'
 ```
 
 to your project dependencies and run `gradle build` or `gradle assemble`.
@@ -34,7 +41,7 @@ Declare the dependency in Maven:
 <dependency>
     <groupId>com.github.satyan</groupId>
     <artifactId>sugar</artifactId>
-    <version>1.3</version>
+    <version>1.5</version>
 </dependency>
 ```
 
@@ -42,50 +49,161 @@ Declare the dependency in Maven:
 
 Download the source code and import it as a library project in Eclipse. The project is available in the folder **library**. For more information on how to do this, read [here](http://developer.android.com/tools/projects/index.html#LibraryProjects).
 
-#### Use a jar
+#### As a jar
 
 Visit the [releases](https://github.com/satyan/sugar/releases) page to download jars directly. You can drop them into your `libs` folder and configure the Java build path to include the library. See this [tutorial](http://www.vogella.com/tutorials/AndroidLibraryProjects/article.html) for an excellent guide on how to do this.
 
+
+### How to use master version
+First, download sugar repository
+```
+git clone git@github.com:satyan/sugar.git
+```
+
+include this in your **settings.gradle**
+```gradle
+include ':app' // your module app
+include ':sugar'
+
+def getLocalProperty(prop) {
+	Properties properties = new Properties()
+	properties.load(new File(rootDir.absolutePath + '/local.properties').newDataInputStream())
+	return properties.getProperty(prop, '')
+}
+
+project(':sugar').projectDir = new File(getLocalProperty('sugar.dir'))
+
+```
+
+include this in your **local.properties**
+```
+sugar.dir=/path/to/sugar/library
+```
+
+add sugar project to the dependencies of your main project (build.gradle)
+```gradle
+dependencies {
+    compile project(':sugar')
+}
+```
+
+You should also comment this line just comment this line (library/build.gradle): https://github.com/satyan/sugar/blob/master/library%2Fbuild.gradle#L2
+
+```gradle
+// apply from: '../maven_push.gradle'
+```
 ===================
 
-After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html).
+After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html) **Outdated**. Check examples of 1.4 and master below: 
 
-## Contributing
+## Examples
+### SugarRecord
+```java
+public class Book extends SugarRecord {
+  @Unique
+  String isbn;
+  String title;
+  String edition;
+
+  // Default constructor is necessary for SugarRecord
+  public Book() {
+
+  }
+
+  public Book(String isbn, String title, String edition) {
+    this.isbn = isbn;
+    this.title = title;
+    this.edition = edition;
+  }
+}
+```
+or
+```java
+@Table
+public class Book { ... }
+```
 
-Please fork this repository and contribute back using [pull requests](https://github.com/satyan/sugar/pulls). Features can be requested using [issues](https://github.com/satyan/sugar/issues). All code, comments, and critiques are greatly appreciated.
+### Save Entity
+```java
+Book book = new Book("isbn123", "Title here", "2nd edition")
+book.save();
+```
 
-## Changelog
+or
+```java
+SugarRecord.save(book); // if using the @Table annotation 
+```
 
-#### v1.3 [[jar](https://github.com/satyan/sugar/releases/download/v1.3/sugar-1.3.jar)]
+### Load Entity
+```java
+Book book = Book.findById(Book.class, 1);
+```
 
-- Transaction Support
-- Bulk Insert of records 
-- Encrypted datastore (branch : sugar-cipher using sqlcipher)
-- Removed Constructor with context parameter. Needs default constructor now.
-- Enhancements to QueryBuilder
-- Bug fixes and other improvements.
+### Update Entity
+```java
+Book book = Book.findById(Book.class, 1);
+book.title = "updated title here"; // modify the values
+book.edition = "3rd edition";
+book.save(); // updates the previous entry with new values.
+```
 
-#### v1.2 [[jar](https://github.com/satyan/sugar/releases/download/v1.2/sugar-1.2.jar)]
 
-- package restriction for domain classes.
-- metadata caching
-- QueryBuilder v1
-- Database Migrations
-- Provision for Raw queries
-- Better and more organized api guide and usage instructions.
+### Delete Entity
+```java
+Book book = Book.findById(Book.class, 1);
+book.delete();
+```
+
+or
+```java
+SugarRecord.delete(book); // if using the @Table annotation 
+```
 
-#### v1.1 [[jar](https://github.com/satyan/sugar/releases/download/v1.1/sugar-1.1.jar)]
+### Update Entity based on Unique values
+```java
+Book book = new Book("isbn123", "Title here", "2nd edition")
+book.save();
 
-- Static api doesn't take context anymore. Hence
+// Update book with isbn123
+Book sameBook = new Book("isbn123", "New Title", "5th edition")
+sameBook.update();
 
+book.getId() == sameBook.getId(); // true
+```
+
+or
 ```java
-Book.findById(context, Book.class, 1);
+SugarRecord.update(sameBook); // if using the @Table annotation 
 ```
 
-becomes
+### Bulk Insert
+```java
+List<Book> books = new ArrayList<>();
+books.add(new Book("isbn123", "Title here", "2nd edition"))
+books.add(new Book("isbn456", "Title here 2", "3nd edition"))
+books.add(new Book("isbn789", "Title here 3", "4nd edition"))
+SugarRecord.saveInTx(books);
+```
 
+### When using ProGuard
 ```java
-Book.findById(Book.class, 1);
+# Ensures entities remain un-obfuscated so table and columns are named correctly
+-keep class com.yourpackage.yourapp.domainclasspackage.** { *; }
 ```
 
-- Some cleanup in the code.
+### Known Issues. 
+#### 1. Instant Run. 
+Instant-Run seems to prevent Sugar ORM from finding the "table" classes, therefore it cannot create the DB tables if you run the app for the first time 
+
+When running your app for the first time Turn off Instant run once to allow for the DB tables to be created
+You can enable it after the tables have been created. 
+
+To disable Instant-Run in Android Studio: 
+
+``(Preferences (Mac) or Settings (PC) -> Build, Execution, Deployment -> Instant Run -> Untick "Enable Instant Run..." )``
+
+## [CHANGELOG](https://github.com/satyan/sugar/blob/master/CHANGELOG.md)
+
+## Contributing
+
+Please fork this repository and contribute back using [pull requests](https://github.com/satyan/sugar/pulls). Features can be requested using [issues](https://github.com/satyan/sugar/issues). All code, comments, and critiques are greatly appreciated.
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..030e1cb3
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,103 @@
+apply plugin: 'jacoco'
+apply plugin: 'com.github.kt3k.coveralls'
+apply plugin: 'java'
+
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.0.0'
+        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.3.1'
+    }
+}
+
+def isReleaseBuild() {
+    return version.contains("SNAPSHOT") == false
+}
+test{
+    testLogging{
+        exceptionFormat = 'full'
+    }
+}
+allprojects {
+    version = VERSION_NAME
+    group = GROUP
+
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        jcenter()
+    }
+}
+
+subprojects { proj ->
+    apply plugin: 'jacoco'
+
+    jacoco {
+        version "0.7.1.201405082137"
+    }
+
+    task jacocoTestReport(type: JacocoReport) {
+        group = "Reporting"
+        description = "Generate Jacoco coverage reports after running tests."
+        reports {
+            xml.enabled = true
+            html.enabled = true
+        }
+        classDirectories = fileTree(
+            dir: 'build/intermediates/classes/debug',
+            excludes: ['**/R*.class',
+                       '**/BuildConfig*'])
+        sourceDirectories = files('src/main/java')
+        executionData = files('build/jacoco/testDebugUnitTest.exec')
+        doFirst {
+            files('build/intermediates/classes/debug').getFiles().each { file ->
+                if (file.name.contains('$$')) {
+                    file.renameTo(file.path.replace('$$', '$'))
+                }
+            }
+        }
+    }
+}
+
+jacoco {
+    toolVersion "0.7.1.201405082137"
+}
+
+task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
+    group = "Reporting"
+    description = 'Generates an aggregate report from all subprojects'
+    dependsOn(subprojects.jacocoTestReport)
+
+    additionalSourceDirs = files('library/src/main/java')
+    sourceDirectories = files('library/src/main/java')
+    classDirectories = files('library/build/intermediates/classes/debug')
+    executionData = files(subprojects.jacocoTestReport.executionData)
+
+    reports {
+        html.enabled = true
+        xml.enabled = true
+    }
+
+    onlyIf = {
+        true
+    }
+
+    doFirst {
+        executionData = files(executionData.findAll { it.exists() })
+    }
+}
+
+coveralls {
+    sourceDirs = files('library/src/main/java').flatten()
+    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
+}
+
+tasks.coveralls {
+    group = 'Coverage reports'
+    description = 'Uploads the aggregated coverage report to Coveralls'
+
+    dependsOn jacocoRootReport
+    onlyIf { System.env.'CI' }
+}
\ No newline at end of file
diff --git a/example/build.gradle b/example/build.gradle
new file mode 100644
index 00000000..a8b90f05
--- /dev/null
+++ b/example/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.3"
+
+    defaultConfig {
+        applicationId "com.example"
+        minSdkVersion 9
+        targetSdkVersion 23
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+}
+
+dependencies {
+    compile project (':library')
+    compile 'com.android.support:appcompat-v7:23.3.0'
+}
diff --git a/example/build.properties b/example/build.properties
old mode 100755
new mode 100644
diff --git a/example/build.xml b/example/build.xml
old mode 100755
new mode 100644
diff --git a/example/example/project.properties b/example/example/project.properties
deleted file mode 100644
index debfe960..00000000
--- a/example/example/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-3
-android.library.reference.1=../library
diff --git a/example/local.properties b/example/local.properties
deleted file mode 100755
index 2543c8bd..00000000
--- a/example/local.properties
+++ /dev/null
@@ -1,10 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must *NOT* be checked in Version Control Systems,
-# as it contains information specific to your local configuration.
-
-# location of the SDK. This is only used by Ant
-# For customization when using a Version Control System, please read the
-# header note.
-sdk.dir=/home/satya/software/android-sdk-linux_x86
diff --git a/example/proguard.cfg b/example/proguard.cfg
deleted file mode 100755
index 12dd0392..00000000
--- a/example/proguard.cfg
+++ /dev/null
@@ -1,36 +0,0 @@
--optimizationpasses 5
--dontusemixedcaseclassnames
--dontskipnonpubliclibraryclasses
--dontpreverify
--verbose
--optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
-
--keep public class * extends android.app.Activity
--keep public class * extends android.app.Application
--keep public class * extends android.app.Service
--keep public class * extends android.content.BroadcastReceiver
--keep public class * extends android.content.ContentProvider
--keep public class * extends android.app.backup.BackupAgentHelper
--keep public class * extends android.preference.Preference
--keep public class com.android.vending.licensing.ILicensingService
-
--keepclasseswithmembernames class * {
-    native <methods>;
-}
-
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet);
-}
-
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet, int);
-}
-
--keepclassmembers enum * {
-    public static **[] values();
-    public static ** valueOf(java.lang.String);
-}
-
--keep class * implements android.os.Parcelable {
-  public static final android.os.Parcelable$Creator *;
-}
diff --git a/example/res/layout/notelist.xml b/example/res/layout/notelist.xml
deleted file mode 100755
index b07f003f..00000000
--- a/example/res/layout/notelist.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-        android:orientation="vertical" android:layout_width="fill_parent"
-        android:layout_height="fill_parent" android:paddingRight="8dp"
-        android:paddingLeft="8dp">
-
-        <ListView android:id="@id/android:list" android:layout_width="fill_parent"
-                android:layout_height="fill_parent" android:layout_weight="1"
-                android:drawSelectorOnTop="false">
-
-        </ListView>
-
-        <LinearLayout android:id="@+id/LinearLayout01"
-                android:layout_height="wrap_content" android:orientation="horizontal"
-                android:background="#FFFFFF" android:layout_width="fill_parent"
-                android:padding="5dp">
-
-                <Button android:id="@+id/Button01" android:layout_width="wrap_content"
-                        android:layout_height="wrap_content" android:lines="2" android:width="100dp"
-                        android:text="Add Note" />
-
-        </LinearLayout>
-
-
-</LinearLayout>
\ No newline at end of file
diff --git a/example/src/com/example/AddNoteActivity.java b/example/src/com/example/AddNoteActivity.java
deleted file mode 100755
index aba5e236..00000000
--- a/example/src/com/example/AddNoteActivity.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.example;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import static com.orm.SugarRecord.save;
-
-
-public class AddNoteActivity extends Activity {
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        LinearLayout view = (LinearLayout) findViewById(R.id.layout);
-        TextView titleText = new TextView(this);
-        titleText.setText("Title");
-        TextView descText = new TextView(this);
-        descText.setText("Description");
-        TextView tagText = new TextView(this);
-        tagText.setText("Tag");
-        final EditText titleBox = new EditText(this);
-        final EditText descBox = new EditText(this);
-        final EditText tagBox = new EditText(this);
-
-        Button save = new Button(this);
-        save.setText("Save");
-        view.addView(titleText);
-        view.addView(titleBox);
-        view.addView(descText);
-        view.addView(descBox);
-        view.addView(tagText);
-        view.addView(tagBox);
-        view.addView(save);
-
-        save.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                Tag tag = new Tag(tagBox.getText().toString());
-                save(tag);
-                save(new Note(10 + (int) (10 * Math.random()), titleBox.getText().toString(), descBox.getText().toString(), tag));
-                Intent intent = new Intent(AddNoteActivity.this, NoteListActivity.class);
-                startActivity(intent);
-            }
-        });
-
-    }
-}
\ No newline at end of file
diff --git a/example/src/com/example/NewNote.java b/example/src/com/example/NewNote.java
deleted file mode 100644
index a80e2d4a..00000000
--- a/example/src/com/example/NewNote.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.example;
-
-import com.orm.dsl.Table;
-
-@Table(name = "new_note")
-public class NewNote {
-
-    public long id;
-    public String name;
-
-}
diff --git a/example/src/com/example/Note.java b/example/src/com/example/Note.java
deleted file mode 100755
index b83f730f..00000000
--- a/example/src/com/example/Note.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.example;
-
-import com.orm.dsl.Column;
-import com.orm.dsl.Table;
-
-@Table(name = "Note")
-public class Note {
-
-    private long id;
-
-    @Column(name = "noteId", unique = true, notNull = true)
-    private int noteId;
-
-    private String title;
-    private String description;
-   private String name;
-    private Integer noteNumber = 2;
-    private Float tagNumber = 4.0f;
-    private float tagNo = 5.0f;
-    private Boolean isTag = true;
-    private boolean isTagged = false;
-    private Double noteTagNo = 40.5;
-    private double noteTagNumber = 24.4;
-    private Tag tag;
-
-    public Note(){
-    }
-
-    public Note(int noteId, String title, String description, Tag tag) {
-        this.noteId = noteId;
-        this.title = title;
-        this.description = description;
-        this.tag = tag;
-    }
-
-    public int getNoteId() {
-        return noteId;
-    }
-
-    public void setNoteId(int noteId) {
-        this.noteId = noteId;
-    }
-
-    public String getTitle() {
-        return title;
-    }
-
-    public void setTitle(String title) {
-        this.title = title;
-    }
-
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description){
-        this.description = description;
-    }
-
-    public Tag getTag() {
-        return tag;
-    }
-
-    @Override
-    public String toString() {
-        return title + "id: " + noteId;
-
-    }
-}
diff --git a/example/src/com/example/NoteListActivity.java b/example/src/com/example/NoteListActivity.java
deleted file mode 100755
index 09877f2d..00000000
--- a/example/src/com/example/NoteListActivity.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.example;
-
-import android.app.ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import com.orm.SugarRecord;
-import com.orm.query.Condition;
-import com.orm.query.Select;
-
-import java.util.List;
-
-
-public class NoteListActivity extends ListActivity {
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.notelist);
-
-        List<Note> notes = Select.from(Note.class).orderBy("title").list();//Note.listAll(Note.class);
-        List<NewNote> list = SugarRecord.listAll(NewNote.class);
-
-        setListAdapter(new ArrayAdapter<Note>(this, android.R.layout.simple_list_item_1, notes));
-
-        findViewById(R.id.Button01).setOnClickListener(new View.OnClickListener() {
-            public void onClick(View view) {
-                Intent intent = new Intent(NoteListActivity.this, AddNoteActivity.class);
-                startActivity(intent);
-            }
-        });
-        
-        // TEST COUNT
-//        android.util.Log.d("COUNT", "Count: " + Select.from(Note.class).where("title like '%ba%'").count() +"/"+notes.size());
-        Log.d("COUNT", "Count: " + Select.from(Note.class).where(new Condition[]{new Condition("title").eq("note")}).count() + "/" + notes.size());
-    }
-
-}
\ No newline at end of file
diff --git a/example/src/com/example/NoteRelation.java b/example/src/com/example/NoteRelation.java
deleted file mode 100644
index a64d055a..00000000
--- a/example/src/com/example/NoteRelation.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.example;
-
-import android.content.Context;
-import com.orm.dsl.Table;
-
-@Table(name = "note_relation")
-public class NoteRelation {
-    String name;
-    int noteId;
-
-
-    public NoteRelation() {
-    }
-
-    public NoteRelation(Context context, String name, int noteId) {
-        this.name = name;
-        this.noteId = noteId;
-
-    }
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public int getNoteId() {
-        return noteId;
-    }
-
-    public void setNoteId(int noteId) {
-        this.noteId = noteId;
-    }
-
-
-}
diff --git a/example/src/com/example/SugarActivity.java b/example/src/com/example/SugarActivity.java
deleted file mode 100755
index b7130f86..00000000
--- a/example/src/com/example/SugarActivity.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package com.example;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import com.orm.SugarRecord;
-
-import static com.orm.SugarRecord.save;
-
-public class SugarActivity extends Activity
-{
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-        SugarRecord.deleteAll(Note.class);
-        SugarRecord.deleteAll(TextNote.class);
-        SugarRecord.deleteAll(Tag.class);
-        SugarRecord.deleteAll(NewNote.class);
-        initDb();
-        Intent intent = new Intent(this, NoteListActivity.class);
-        startActivity(intent);
-    }
-
-     private void initDb() {
-
-        Tag t1 = new Tag("tag1");
-        Tag t2 = new Tag("tag2");
-         save(t1);
-         save(t2);
-
-        Note n1 = new Note( 10, "note1", "description1", t1);
-        Note n2 = new Note(11, "note12", "description2", t1);
-        Note n3 = new Note( 12, "note13", "description3", t2);
-        Note n4 = new Note( 13, "note4", "description4", t2);
-
-         TextNote textNote = new TextNote();
-         textNote.desc = "Test";
-
-         save(textNote);
-         save(n1);
-         save(n2);
-         save(n3);
-         save(n4);
-
-         n1.setDescription("matrix");
-         n1.setTitle("atrix");
-         save(n1);
-         n2.setDescription("matrix");
-         n2.setTitle("satrix");
-         save(n2);
-         n3.setDescription("matrix");
-         n3.setTitle("batrix");
-         save(n3);
-
-         NewNote newNote = new NewNote();
-         newNote.name = "name";
-         save(newNote);
-
-     }
-}
diff --git a/example/src/com/example/Tag.java b/example/src/com/example/Tag.java
deleted file mode 100755
index 6600c14a..00000000
--- a/example/src/com/example/Tag.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.example;
-
-import com.orm.dsl.Table;
-
-@Table(name = "tag")
-public class Tag {
-    private String name;
-
-    public Tag(String name) {
-        this.name = name;
-    }
-
-    public Tag() {
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    @Override
-    public String toString() {
-        return getName();
-    }
-}
diff --git a/example/src/com/example/TextNote.java b/example/src/com/example/TextNote.java
deleted file mode 100644
index 91b7a33c..00000000
--- a/example/src/com/example/TextNote.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.example;
-
-import com.orm.dsl.Table;
-
-@Table(name = "text_note")
-public class TextNote extends Note {
-
-    public String desc;
-
-    public TextNote() {
-    }
-
-
-}
diff --git a/example/AndroidManifest.xml b/example/src/main/AndroidManifest.xml
old mode 100755
new mode 100644
similarity index 78%
rename from example/AndroidManifest.xml
rename to example/src/main/AndroidManifest.xml
index e03f036a..eb802533
--- a/example/AndroidManifest.xml
+++ b/example/src/main/AndroidManifest.xml
@@ -4,16 +4,12 @@
       android:versionCode="1"
       android:versionName="1.0">
     <application android:label="@string/app_name" android:icon="@drawable/icon" android:name="ClientApp">
-        <activity android:name="SugarActivity"
-                  android:label="@string/app_name">
+        <activity android:name=".activities.SugarActivity" android:label="@string/app_name">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
-        <activity android:name=".NoteListActivity"/>
-        <activity android:name=".AddNoteActivity"/>
-
         <meta-data android:name="DATABASE" android:value="sugar_example.db" />
         <meta-data android:name="VERSION" android:value="3" />
         <meta-data android:name="QUERY_LOG" android:value="true" />
diff --git a/example/assets/sugar_upgrades/3.sql b/example/src/main/assets/sugar_upgrades/3.sql
similarity index 100%
rename from example/assets/sugar_upgrades/3.sql
rename to example/src/main/assets/sugar_upgrades/3.sql
diff --git a/example/src/main/java/com/example/activities/SugarActivity.java b/example/src/main/java/com/example/activities/SugarActivity.java
new file mode 100644
index 00000000..81044546
--- /dev/null
+++ b/example/src/main/java/com/example/activities/SugarActivity.java
@@ -0,0 +1,18 @@
+package com.example.activities;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+import com.example.R;
+
+
+public class SugarActivity extends Activity
+{
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+    }
+}
diff --git a/example/res/drawable-hdpi/icon.png b/example/src/main/res/drawable-hdpi/icon.png
similarity index 100%
rename from example/res/drawable-hdpi/icon.png
rename to example/src/main/res/drawable-hdpi/icon.png
diff --git a/example/res/drawable-ldpi/icon.png b/example/src/main/res/drawable-ldpi/icon.png
similarity index 100%
rename from example/res/drawable-ldpi/icon.png
rename to example/src/main/res/drawable-ldpi/icon.png
diff --git a/example/res/drawable-mdpi/icon.png b/example/src/main/res/drawable-mdpi/icon.png
similarity index 100%
rename from example/res/drawable-mdpi/icon.png
rename to example/src/main/res/drawable-mdpi/icon.png
diff --git a/example/res/layout/main.xml b/example/src/main/res/layout/main.xml
similarity index 100%
rename from example/res/layout/main.xml
rename to example/src/main/res/layout/main.xml
diff --git a/example/res/values/strings.xml b/example/src/main/res/values/strings.xml
similarity index 100%
rename from example/res/values/strings.xml
rename to example/src/main/res/values/strings.xml
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..35b4c26f
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,34 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+org.gradle.daemon=true
+
+VERSION_NAME=2
+VERSION_CODE=2
+GROUP=com.github.satyan
+
+POM_DESCRIPTION=Sugar ORM - Insanely easy way to work with android database
+POM_URL=https://github.com/satyan/sugar
+POM_SCM_URL=https://github.com/satyan/sugar
+POM_SCM_CONNECTION=scm:git@github.com:satyan/sugar.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:satyan/sugar.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+POM_DEVELOPER_ID=satyan
+POM_DEVELOPER_NAME=Satya Narayan
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..8c0fb64a
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..b0bb3ffb
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Sat Apr 09 17:51:14 ART 2016
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100755
index 00000000..aec99730
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/build.gradle b/library/build.gradle
index 43157b3c..907162ee 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,29 +1,36 @@
-buildscript {
-        repositories {
-            mavenCentral()
-        }
+apply plugin: 'com.android.library'
+apply from: '../maven_push.gradle'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.3"
 
-        dependencies {
-            classpath 'com.android.tools.build:gradle:0.9.+'
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
         }
     }
+    testOptions {
+        unitTests.returnDefaultValues = true
+    }
+    lintOptions {
+        abortOnError false
+    }
+}
 
-    apply plugin: 'android-library'
+dependencies {
+    testCompile 'junit:junit:4.12'
+    testCompile 'org.robolectric:robolectric:3.0'
+}
 
-    dependencies {
-        compile 'com.android.support:support-v4:19.0.1'
-    }
+task libraryJar(type: Jar) {
+    dependsOn assembleRelease
+    from android.sourceSets.main.java.srcDirs,
+         ['build/intermediates/classes/release/'] // Add the release classes into the jar
+    baseName 'sugar'
+}
 
-    android {
-        compileSdkVersion 19
-        buildToolsVersion "19.0.3"
-        sourceSets {
-            main {
-                manifest.srcFile 'AndroidManifest.xml'
-                java.srcDirs = ['src']
-                resources.srcDirs = ['src']
-                res.srcDirs = ['res']
-                assets.srcDirs = ['assets']
-            }
-        }
-    }
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100644
index 00000000..07fe1d15
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Sugar ORM
+POM_ARTIFACT_ID=sugar
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/library/project.properties b/library/project.properties
deleted file mode 100644
index 05d02d38..00000000
--- a/library/project.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-android.library=true
-# Project target.
-target=android-15
diff --git a/library/res/values/strings.xml b/library/res/values/strings.xml
deleted file mode 100644
index 0d2c4cc4..00000000
--- a/library/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-</resources>
\ No newline at end of file
diff --git a/library/src/com/orm/SchemaGenerator.java b/library/src/com/orm/SchemaGenerator.java
deleted file mode 100644
index a7f25b51..00000000
--- a/library/src/com/orm/SchemaGenerator.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package com.orm;
-
-import android.content.Context;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
-import android.util.Log;
-import com.orm.dsl.Column;
-import com.orm.dsl.NotNull;
-import com.orm.dsl.Unique;
-import com.orm.util.NamingHelper;
-import com.orm.util.NumberComparator;
-import com.orm.util.QueryBuilder;
-import com.orm.util.ReflectionUtil;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Field;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-import static com.orm.util.ReflectionUtil.getDomainClasses;
-
-public class SchemaGenerator {
-
-    private Context context;
-
-    public SchemaGenerator(Context context) {
-        this.context = context;
-    }
-
-    public void createDatabase(SQLiteDatabase sqLiteDatabase) {
-        List<Class> domainClasses = getDomainClasses(context);
-        for (Class domain : domainClasses) {
-            createTable(domain, sqLiteDatabase);
-        }
-    }
-
-    public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        List<Class> domainClasses = getDomainClasses(context);
-        for (Class domain : domainClasses) {
-            try {  // we try to do a select, if fails then (?) there isn't the table
-                sqLiteDatabase.query(NamingHelper.toSQLName(domain), null, null, null, null, null, null);
-            } catch (SQLiteException e) {
-                Log.i("Sugar", String.format("Creating table on update (error was '%s')",
-                        e.getMessage()));
-                createTable(domain, sqLiteDatabase);
-            }
-        }
-        executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
-    }
-
-    public void deleteTables(SQLiteDatabase sqLiteDatabase) {
-        List<Class> tables = getDomainClasses(context);
-        for (Class table : tables) {
-            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toSQLName(table));
-        }
-    }
-
-    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        boolean isSuccess = false;
-
-        try {
-            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
-            Collections.sort(files, new NumberComparator());
-            for (String file : files) {
-                Log.i("Sugar", "filename : " + file);
-
-                try {
-                    int version = Integer.valueOf(file.replace(".sql", ""));
-
-                    if ((version > oldVersion) && (version <= newVersion)) {
-                        executeScript(db, file);
-                        isSuccess = true;
-                    }
-                } catch (NumberFormatException e) {
-                    Log.i("Sugar", "not a sugar script. ignored." + file);
-                }
-
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return isSuccess;
-    }
-
-    private void executeScript(SQLiteDatabase db, String file) {
-        try {
-            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
-            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-            String line;
-            while ((line = reader.readLine()) != null) {
-                Log.i("Sugar script", line);
-                db.execSQL(line.toString());
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        Log.i("Sugar", "Script executed");
-    }
-
-    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "Create table");
-        List<Field> fields = ReflectionUtil.getTableFields(table);
-        String tableName = NamingHelper.toSQLName(table);
-        StringBuilder sb = new StringBuilder("CREATE TABLE ");
-        sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
-
-        for (Field column : fields) {
-            String columnName = NamingHelper.toSQLName(column);
-            String columnType = QueryBuilder.getColumnType(column.getType());
-
-            if (columnType != null) {
-                if (columnName.equalsIgnoreCase("Id")) {
-                    continue;
-                }
-
-                if (column.isAnnotationPresent(Column.class)) {
-                    Column columnAnnotation = column.getAnnotation(Column.class);
-                    columnName = columnAnnotation.name();
-
-                    sb.append(", ").append(columnName).append(" ").append(columnType);
-
-                    if (columnAnnotation.notNull()) {
-                        if (columnType.endsWith(" NULL")) {
-                            sb.delete(sb.length() - 5, sb.length());
-                        }
-                        sb.append(" NOT NULL");
-                    }
-
-                    if (columnAnnotation.unique()) {
-                        sb.append(" UNIQUE");
-                    }
-
-                } else {
-                    sb.append(", ").append(columnName).append(" ").append(columnType);
-
-                    if (column.isAnnotationPresent(NotNull.class)) {
-                        if (columnType.endsWith(" NULL")) {
-                            sb.delete(sb.length() - 5, sb.length());
-                        }
-                        sb.append(" NOT NULL");
-                    }
-
-                    if (column.isAnnotationPresent(Unique.class)) {
-                        sb.append(" UNIQUE");
-                    }
-                }
-            }
-        }
-
-        sb.append(" ) ");
-        Log.i("Sugar", "Creating table " + tableName);
-
-        if (!"".equals(sb.toString())) {
-            try {
-                sqLiteDatabase.execSQL(sb.toString());
-            } catch (SQLException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-}
diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
deleted file mode 100644
index a15110a3..00000000
--- a/library/src/com/orm/SugarDb.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.orm;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-import com.orm.util.ManifestHelper;
-import com.orm.util.SugarCursorFactory;
-
-import static com.orm.util.ManifestHelper.getDatabaseVersion;
-import static com.orm.util.ManifestHelper.getDebugEnabled;
-
-public class SugarDb extends SQLiteOpenHelper {
-
-    private final SchemaGenerator schemaGenerator;
-    private SQLiteDatabase sqLiteDatabase;
-
-    public SugarDb(Context context) {
-        super(context, ManifestHelper.getDatabaseName(context),
-                new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
-        schemaGenerator = new SchemaGenerator(context);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase sqLiteDatabase) {
-        schemaGenerator.createDatabase(sqLiteDatabase);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        schemaGenerator.doUpgrade(sqLiteDatabase, oldVersion, newVersion);
-    }
-
-    public synchronized SQLiteDatabase getDB() {
-        if (this.sqLiteDatabase == null) {
-            this.sqLiteDatabase = getWritableDatabase();
-        }
-
-        return this.sqLiteDatabase;
-    }
-
-}
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
deleted file mode 100644
index d3a5e8fc..00000000
--- a/library/src/com/orm/SugarRecord.java
+++ /dev/null
@@ -1,286 +0,0 @@
-package com.orm;
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-import android.text.TextUtils;
-import android.util.Log;
-import com.orm.dsl.Table;
-import com.orm.util.NamingHelper;
-import com.orm.util.ReflectionUtil;
-
-import java.lang.reflect.Field;
-import java.util.*;
-
-import static com.orm.SugarContext.getSugarContext;
-
-public class SugarRecord {
-
-    protected Long id = null;
-
-    public static <T> void deleteAll(Class<T> type) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(NamingHelper.toSQLName(type), null, null);
-    }
-
-    public static <T> void deleteAll(Class<T> type, String whereClause, String... whereArgs) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause, whereArgs);
-    }
-
-    @SuppressWarnings("deprecation")
-    public static <T> void saveInTx(T... objects) {
-        saveInTx(Arrays.asList(objects));
-    }
-
-    @SuppressWarnings("deprecation")
-    public static <T> void saveInTx(Collection<T> objects) {
-        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
-        try {
-            sqLiteDatabase.beginTransaction();
-            sqLiteDatabase.setLockingEnabled(false);
-            for (T object: objects) {
-                SugarRecord.save(object);
-            }
-            sqLiteDatabase.setTransactionSuccessful();
-        } catch (Exception e) {
-            Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
-        } finally {
-            sqLiteDatabase.endTransaction();
-            sqLiteDatabase.setLockingEnabled(true);
-        }
-    }
-
-    public static <T> List<T> listAll(Class<T> type) {
-        return find(type, null, null, null, null, null);
-    }
-
-    public static <T> T findById(Class<T> type, Long id) {
-        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
-        if (list.isEmpty()) return null;
-        return list.get(0);
-    }
-
-    public static <T> T findById(Class<T> type, Integer id) {
-        return findById(type, Long.valueOf(id));
-    }
-
-    public static <T> Iterator<T> findAll(Class<T> type) {
-        return findAsIterator(type, null, null, null, null, null);
-    }
-
-    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
-        return findAsIterator(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
-        return new CursorIterator<T>(type, c);
-    }
-
-    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
-                groupBy, null, orderBy, limit);
-        return new CursorIterator<T>(type, c);
-    }
-
-    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
-        return find(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
-
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(c, entity);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-
-        return toRet;
-    }
-
-    public static void executeQuery(String query, String... arguments) {
-        getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
-    }
-
-    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
-                groupBy, null, orderBy, limit);
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(c, entity);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-        return toRet;
-    }
-
-    public static <T> long count(Class<?> type) {
-        return count(type, null, null, null, null, null);
-    }
-
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
-    	return count(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-
-        long toRet = -1;
-        String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
-        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + NamingHelper.toSQLName(type) + filter);
-
-        if (whereArgs != null) {
-            for (int i = whereArgs.length; i != 0; i--) {
-                sqLiteStatament.bindString(i, whereArgs[i - 1]);
-            }
-        }
-
-        try {
-            toRet = sqLiteStatament.simpleQueryForLong();
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            sqLiteStatament.close();
-        }
-
-        return toRet;
-    }
-
-    public static long save(Object object) {
-        return save(getSugarContext().getSugarDb().getDB(), object);
-    }
-
-    static long save(SQLiteDatabase db, Object object) {
-        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
-        ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
-            ReflectionUtil.addFieldValueToColumn(values, column, object);
-        }
-
-        long id = db.insertWithOnConflict(NamingHelper.toSQLName(object.getClass()), null, values,
-                SQLiteDatabase.CONFLICT_REPLACE);
-
-        if (SugarRecord.class.isAssignableFrom(object.getClass())) {
-            ReflectionUtil.setFieldValueForId(object, id);
-        }
-        Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
-
-        return id;
-    }
-
-    private static void inflate(Cursor cursor, Object object) {
-        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
-
-        for (Field field : columns) {
-            if (field.getClass().isAnnotationPresent(Table.class)) {
-                try {
-                    long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toSQLName(field)));
-                    field.set(object, (id > 0) ? findById(field.getType(), id) : null);
-                } catch (IllegalAccessException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
-            }
-        }
-    }
-
-    public void delete() {
-        SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
-        db.delete(NamingHelper.toSQLName(getClass()), "Id=?", new String[]{getId().toString()});
-        Log.i("Sugar", getClass().getSimpleName() + " deleted : " + getId().toString());
-    }
-
-    public long save() {
-        return save(getSugarContext().getSugarDb().getDB(), this);
-    }
-
-    @SuppressWarnings("unchecked")
-    void inflate(Cursor cursor) {
-        inflate(cursor, this);
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    static class CursorIterator<E> implements Iterator<E> {
-        Class<E> type;
-        Cursor cursor;
-
-        public CursorIterator(Class<E> type, Cursor cursor) {
-            this.type = type;
-            this.cursor = cursor;
-        }
-
-        @Override
-        public boolean hasNext() {
-            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
-        }
-
-        @Override
-        public E next() {
-            E entity = null;
-            if (cursor == null || cursor.isAfterLast()) {
-                throw new NoSuchElementException();
-            }
-
-            if (cursor.isBeforeFirst()) {
-                cursor.moveToFirst();
-            }
-
-            try {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(cursor, entity);
-            } catch (Exception e) {
-                e.printStackTrace();
-            } finally {
-                cursor.moveToNext();
-                if (cursor.isAfterLast()) {
-                    cursor.close();
-                }
-            }
-
-            return entity;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-}
diff --git a/library/src/com/orm/SugarTransactionHelper.java b/library/src/com/orm/SugarTransactionHelper.java
deleted file mode 100644
index 0f2683f2..00000000
--- a/library/src/com/orm/SugarTransactionHelper.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.orm;
-
-import android.database.sqlite.SQLiteDatabase;
-import android.util.Log;
-
-public class SugarTransactionHelper {
-
-    public static void doInTansaction(SugarTransactionHelper.Callback callback) {
-        SQLiteDatabase database = SugarContext.getSugarContext().getSugarDb().getDB();
-        database.beginTransaction();
-
-        try {
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Callback executing within transaction");
-            callback.manipulateInTransaction();
-            database.setTransactionSuccessful();
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Callback successfully executed within transaction");
-        } catch (Throwable e) {
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Could execute callback within transaction", e);
-        } finally {
-            database.endTransaction();
-        }
-
-    }
-
-    public static interface Callback {
-        void manipulateInTransaction();
-    }
-
-}
diff --git a/library/src/com/orm/util/Collection.java b/library/src/com/orm/util/Collection.java
deleted file mode 100644
index fe7a7e63..00000000
--- a/library/src/com/orm/util/Collection.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.orm.util;
-import java.util.*;
-
-public class Collection {
-
-    public static <T> List<T> list(T... args) {
-        return Arrays.asList(args);
-    }
-
-    public static <T> Set<T> set(T... args) {
-        Set<T> result = new HashSet<T>(args.length);
-        result.addAll(Arrays.asList(args));
-        return result;
-    }
-
-    public static <K, V> Map<K, V> map(Entry<? extends K, ? extends V>... entries) {
-        Map<K, V> result = new HashMap<K, V>(entries.length);
-
-        for (Entry<? extends K, ? extends V> entry : entries)
-            if (entry.value != null)
-                result.put(entry.key, entry.value);
-
-        return result;
-    }
-
-    public static <K, V> Entry<K, V> entry(K key, V value) {
-        return new Entry<K, V>(key, value);
-    }
-
-    public static class Entry<K, V> {
-        K key;
-        V value;
-
-        public Entry(K key, V value) {
-            this.key = key;
-            this.value = value;
-        }
-    }
-
-}
diff --git a/library/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
similarity index 65%
rename from library/AndroidManifest.xml
rename to library/src/main/AndroidManifest.xml
index a48c294b..849de626 100644
--- a/library/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -2,7 +2,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.orm.dsl"
           android:versionCode="1"
-          android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8" />
+          android:versionName="1.3.1">
 
 </manifest>
\ No newline at end of file
diff --git a/library/src/main/java/com/orm/SchemaGenerator.java b/library/src/main/java/com/orm/SchemaGenerator.java
new file mode 100644
index 00000000..c25407fc
--- /dev/null
+++ b/library/src/main/java/com/orm/SchemaGenerator.java
@@ -0,0 +1,300 @@
+package com.orm;
+
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import com.orm.annotation.Column;
+import com.orm.annotation.MultiUnique;
+import com.orm.annotation.NotNull;
+import com.orm.annotation.Unique;
+import com.orm.dsl.BuildConfig;
+import com.orm.helper.ManifestHelper;
+import com.orm.util.KeyWordUtil;
+import com.orm.util.MigrationFileParser;
+import com.orm.helper.NamingHelper;
+import com.orm.util.NumberComparator;
+import com.orm.util.QueryBuilder;
+import com.orm.util.ReflectionUtil;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.orm.util.ReflectionUtil.getDomainClasses;
+import static com.orm.util.ContextUtil.getAssets;
+
+public class SchemaGenerator {
+    public static final String NULL = " NULL";
+    public static final String NOT_NULL = " NOT NULL";
+    public static final String UNIQUE = " UNIQUE";
+    public static final String SUGAR = "Sugar";
+
+    //Prevent instantiation
+    private SchemaGenerator() { }
+
+    public static SchemaGenerator getInstance() {
+        return new SchemaGenerator();
+    }
+
+    public void createDatabase(SQLiteDatabase sqLiteDatabase) {
+        List<Class> domainClasses = getDomainClasses();
+        for (Class domain : domainClasses) {
+            createTable(domain, sqLiteDatabase);
+            afterTableCreated(domain,sqLiteDatabase);
+        }
+
+    }
+
+    public void afterTableCreated(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        String fileName = table.getSimpleName() + ".sql";
+        executeScript(sqLiteDatabase,"sugar_after_create/" ,fileName);
+
+    }
+
+    public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        List<Class> domainClasses = getDomainClasses();
+        String sql = "select count(*) from sqlite_master where type='table' and name='%s';";
+
+        for (Class domain : domainClasses) {
+            String tableName = NamingHelper.toTableName(domain);
+            Cursor c = sqLiteDatabase.rawQuery(String.format(sql, tableName), null);
+            if (c.moveToFirst() && c.getInt(0) == 0) {
+                createTable(domain, sqLiteDatabase);
+            } else {
+                addColumns(domain, sqLiteDatabase);
+            }
+        }
+        executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    protected ArrayList<String> getColumnNames(SQLiteDatabase sqLiteDatabase, String tableName) {
+        Cursor resultsQuery = sqLiteDatabase.query(tableName, null, null, null, null, null, null);
+        //Check if columns match vs the one on the domain class
+        ArrayList<String> columnNames = new ArrayList<>();
+        for (int i = 0; i < resultsQuery.getColumnCount(); i++) {
+            String columnName = resultsQuery.getColumnName(i);
+            columnNames.add(columnName);
+        }
+        resultsQuery.close();
+        return columnNames;
+    }
+
+
+    public void deleteTables(SQLiteDatabase sqLiteDatabase) {
+        List<Class> tables = getDomainClasses();
+        for (Class table : tables) {
+            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toTableName(table));
+        }
+    }
+
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean isSuccess = false;
+
+        try {
+            List<String> files = Arrays.asList(getAssets().list("sugar_upgrades"));
+            Collections.sort(files, new NumberComparator());
+            for (String file : files) {
+                if(ManifestHelper.isDebugEnabled()) {
+                    Log.i(SUGAR, "filename : " + file);
+                }
+
+                try {
+                    int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if ((version > oldVersion) && (version <= newVersion)) {
+                        executeScript(db,"sugar_upgrades/" ,file);
+                        isSuccess = true;
+                    }
+                } catch (NumberFormatException e) {
+                    if(ManifestHelper.isDebugEnabled()) {
+                        Log.i(SUGAR, "not a sugar script. ignored." + file);
+                    }
+                }
+
+            }
+        } catch (IOException e) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.e(SUGAR, e.getMessage());
+            }
+        }
+
+        return isSuccess;
+    }
+
+    private void executeScript(SQLiteDatabase db,String path ,String file) {
+        try {
+            InputStream is = getAssets().open(path + file);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            StringBuilder sb = new StringBuilder();
+            String line;
+            while ((line = reader.readLine()) != null) {
+                sb.append(line);
+            }
+            MigrationFileParser migrationFileParser = new MigrationFileParser(sb.toString());
+            for(String statement: migrationFileParser.getStatements()){
+                if(ManifestHelper.isDebugEnabled()) {
+                    Log.i("Sugar script", statement);
+                }
+                if (!statement.isEmpty()) {
+                    db.execSQL(statement);
+                }
+            }
+
+        } catch (IOException e) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.e(SUGAR, e.getMessage());
+            }
+        }
+
+        if(ManifestHelper.isDebugEnabled()) {
+            Log.i(SUGAR, "Script executed");
+        }
+    }
+
+    private void addColumns(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toTableName(table);
+        ArrayList<String> presentColumns = getColumnNames(sqLiteDatabase, tableName);
+        ArrayList<String> alterCommands = new ArrayList<>();
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toColumnName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (column.isAnnotationPresent(Column.class)) {
+                Column columnAnnotation = column.getAnnotation(Column.class);
+                columnName = columnAnnotation.name();
+            }
+
+            if (!presentColumns.contains(columnName)) {
+                StringBuilder sb = new StringBuilder("ALTER TABLE ");
+                sb.append(tableName).append(" ADD COLUMN ").append(columnName).append(" ").append(columnType);
+                if (column.isAnnotationPresent(NotNull.class)) {
+                    if (columnType.endsWith(" NULL")) {
+                        sb.delete(sb.length() - 5, sb.length());
+                    }
+                    sb.append(" NOT NULL");
+                }
+
+                // Unique is not working on ALTER TABLE
+//                if (column.isAnnotationPresent(Unique.class)) {
+//                    sb.append(" UNIQUE");
+//                }
+                alterCommands.add(sb.toString());
+            }
+        }
+
+        for (String command : alterCommands) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i("Sugar", command);
+            }
+            sqLiteDatabase.execSQL(command);
+        }
+    }
+
+    protected String createTableSQL(Class<?> table) {
+        if(ManifestHelper.isDebugEnabled()) {
+            Log.i(SUGAR, "Create table if not exists");
+        }
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toTableName(table);
+
+        if(KeyWordUtil.isKeyword(tableName)) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "ERROR, SQLITE RESERVED WORD USED IN " + tableName);
+            }
+        }
+
+        StringBuilder sb = new StringBuilder("CREATE TABLE IF NOT EXISTS ");
+        sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toColumnName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+                if (columnName.equalsIgnoreCase("Id")) {
+                    continue;
+                }
+
+                if (column.isAnnotationPresent(Column.class)) {
+                    Column columnAnnotation = column.getAnnotation(Column.class);
+                    columnName = columnAnnotation.name();
+
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (columnAnnotation.notNull()) {
+                        if (columnType.endsWith(NULL)) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(NOT_NULL);
+                    }
+
+                    if (columnAnnotation.unique()) {
+                        sb.append(UNIQUE);
+                    }
+
+                } else {
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (column.isAnnotationPresent(NotNull.class)) {
+                        if (columnType.endsWith(NULL)) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(NOT_NULL);
+                    }
+
+                    if (column.isAnnotationPresent(Unique.class)) {
+                        sb.append(UNIQUE);
+                    }
+                }
+            }
+        }
+
+        if (table.isAnnotationPresent(MultiUnique.class)) {
+            String constraint = table.getAnnotation(MultiUnique.class).value();
+
+            sb.append(", UNIQUE(");
+
+            String[] constraintFields = constraint.split(",");
+            for(int i = 0; i < constraintFields.length; i++) {
+                String columnName = NamingHelper.toSQLNameDefault(constraintFields[i]);
+                sb.append(columnName);
+
+                if(i < (constraintFields.length -1)) {
+                    sb.append(",");
+                }
+            }
+
+            sb.append(") ON CONFLICT REPLACE");
+        }
+
+        sb.append(" ) ");
+        if(ManifestHelper.isDebugEnabled()) {
+            Log.i(SUGAR, "Creating table " + tableName);
+        }
+
+        return sb.toString();
+    }
+
+    protected void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        String createSQL = createTableSQL(table);
+
+        if (!createSQL.isEmpty()) {
+            try {
+                sqLiteDatabase.execSQL(createSQL);
+            } catch (SQLException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+}
diff --git a/library/src/com/orm/SugarApp.java b/library/src/main/java/com/orm/SugarApp.java
similarity index 91%
rename from library/src/com/orm/SugarApp.java
rename to library/src/main/java/com/orm/SugarApp.java
index 5140e1ee..cab35ca7 100644
--- a/library/src/com/orm/SugarApp.java
+++ b/library/src/main/java/com/orm/SugarApp.java
@@ -1,7 +1,5 @@
 package com.orm;
 
-import com.orm.SugarContext;
-
 import android.app.Application;
 
 public class SugarApp extends Application {
diff --git a/library/src/com/orm/SugarContext.java b/library/src/main/java/com/orm/SugarContext.java
similarity index 55%
rename from library/src/com/orm/SugarContext.java
rename to library/src/main/java/com/orm/SugarContext.java
index ea853766..61609986 100644
--- a/library/src/com/orm/SugarContext.java
+++ b/library/src/main/java/com/orm/SugarContext.java
@@ -2,15 +2,22 @@
 
 import android.content.Context;
 
+import com.orm.util.ContextUtil;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.WeakHashMap;
+
 public class SugarContext {
 
+    private static SugarDbConfiguration dbConfiguration = null;
     private static SugarContext instance = null;
     private SugarDb sugarDb;
-    private Context context;
+    private Map<Object, Long> entitiesMap;
 
-    private SugarContext(Context context) {
-        this.context = context;
-        this.sugarDb = new SugarDb(context);
+    private SugarContext() {
+        this.sugarDb = SugarDb.getInstance();
+        this.entitiesMap = Collections.synchronizedMap(new WeakHashMap<Object, Long>());
     }
     
     public static SugarContext getSugarContext() {
@@ -21,14 +28,23 @@ public static SugarContext getSugarContext() {
     }
 
     public static void init(Context context) {
-        instance = new SugarContext(context);
+        ContextUtil.init(context);
+        instance = new SugarContext();
+        dbConfiguration = null;
+    }
+
+    public static void init(Context context, SugarDbConfiguration configuration) {
+        init(context);
+        dbConfiguration = configuration;
     }
 
+
     public static void terminate() {
         if (instance == null) {
             return;
         }
         instance.doTerminate();
+        ContextUtil.terminate();
     }
 
     /*
@@ -43,8 +59,15 @@ private void doTerminate() {
         }
     }
 
-    protected SugarDb getSugarDb() {
+    public static SugarDbConfiguration getDbConfiguration() {
+        return dbConfiguration;
+    }
+
+    public SugarDb getSugarDb() {
         return sugarDb;
     }
 
+    public Map<Object, Long> getEntitiesMap() {
+        return entitiesMap;
+    }
 }
diff --git a/library/src/main/java/com/orm/SugarDataSource.java b/library/src/main/java/com/orm/SugarDataSource.java
new file mode 100644
index 00000000..d2d9aa2c
--- /dev/null
+++ b/library/src/main/java/com/orm/SugarDataSource.java
@@ -0,0 +1,441 @@
+package com.orm;
+
+import android.database.Cursor;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+
+import static com.orm.util.ThreadUtil.*;
+
+/**
+ * SugarDataSource provides basic crud operations and simplifies SugarRecord by using callbacks and
+ * performing Asynchronous execution to run queries.
+ *
+ * @author jonatan.salas
+ */
+@SuppressWarnings("all")
+public final class SugarDataSource<T> {
+    private final Class<T> sClass;
+
+    /**
+     * SugarDataSource constructor with params
+     *
+     * @param tClass class argument used then to run SugarRecord class queries
+     */
+    private SugarDataSource(Class<T> tClass) {
+        if (null == tClass) {
+            throw new IllegalArgumentException("sClass shouldn't be null!");
+        }
+
+        this.sClass = tClass;
+    }
+
+    /**
+     * SugarDataSource static method to construct an Instance of this class.
+     *
+     * @param sClass class argument used then to run SugarRecord class queries
+     * @param <T> generic argument that must be a SugarRecord extended class or @Table annotated class
+     * @return an instance of SugarDataSource
+     */
+    public static <T> SugarDataSource<T> getInstance(Class<T> sClass) {
+        return new SugarDataSource<>(sClass);
+    }
+
+    /**
+     * Method used to perform an Asynchronous insert. It works on top of SugarRecord class, executes the
+     * insert query using Futures.
+     *
+     * @param object the object you want to insert. It must be a SugarRecord extended class or @Table annotated class
+     * @param successCallback the callback for a successful insert operation
+     * @param errorCallback the callback for an error in insert operation
+     */
+    public void insert(final T object, final SuccessCallback<Long> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+        checkNotNull(object);
+
+        final Callable<Long> call = new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                return SugarRecord.save(object);
+            }
+        };
+
+        final Future<Long> future = doInBackground(call);
+        Long id;
+
+        try {
+            id = future.get();
+
+            if (null == id) {
+                errorCallback.onError(new Exception("Error when performing insert of " + object.toString()));
+            } else {
+                successCallback.onSuccess(id);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that performs a bulk insert. It works on top of SugarRecord class, and executes the query
+     * asynchronously using Futures.
+     *
+     * @param objects the list of objects that you want to insert. They must be SugarRecord extended objects or @Table annotatd objects.
+     * @param successCallback the callback for successful bulk insert operation
+     * @param errorCallback the callback for an error in bulk insert operation
+     */
+    public void bulkInsert(final List<T> objects, final SuccessCallback<List<Long>> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+        checkNotNull(objects);
+
+        final Callable<List<Long>> call = new Callable<List<Long>>() {
+            @Override
+            public List<Long> call() throws Exception {
+                List<Long> ids = new ArrayList<>(objects.size());
+
+                for (int i = 0; i < objects.size(); i++) {
+                    Long id = SugarRecord.save(objects.get(i));
+                    ids.add(i, id);
+                }
+
+                return ids;
+            }
+        };
+
+        final Future<List<Long>> future = doInBackground(call);
+        List<Long> ids;
+
+        try {
+            ids = future.get();
+
+            if (null == ids || ids.isEmpty()) {
+                errorCallback.onError(new Exception("Error when performing bulk insert"));
+            } else {
+                successCallback.onSuccess(ids);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that performs a findById, It works on top of SugarRecord class providing asynchronous
+     * execution with the use of Futures.
+     *
+     * @param id the id of the object you want to retrieve
+     * @param successCallback the callback to execute when the operation is successful
+     * @param errorCallback the callback to execute when the operation has a trouble
+     */
+    public void findById(final Long id, final SuccessCallback<T> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+        checkNotNull(id);
+
+        final Callable<T> call = new Callable<T>() {
+            @Override
+            public T call() throws Exception {
+                return SugarRecord.findById(getSugarClass(), id);
+            }
+        };
+
+        final Future<T> future = doInBackground(call);
+        T object;
+
+        try {
+            object = future.get();
+
+            if (null == object) {
+                errorCallback.onError(new Exception("The object with " + id.toString() + "doesn't exist in database"));
+            } else {
+                successCallback.onSuccess(object);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that provides you the ability of perform a custom query and retrieve a cursor. It works on top of SugarRecord class,
+     * All the code is executed asynchronously with the usage of Futures and callbacks.
+     *
+     * @param whereClause the clause of the search
+     * @param whereArgs the arguments for the search
+     * @param groupBy the form that you want to group them
+     * @param orderBy the form that you want to order
+     * @param limit the limit of objects to want
+     * @param successCallback the callback to be executed if the operation is successful
+     * @param errorCallback the callback to be executed if the operation has an error
+     */
+    public void query(final String whereClause, final String[] whereArgs, final String groupBy, final String orderBy, final String limit, final SuccessCallback<Cursor> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+
+        final Callable<Cursor> call = new Callable<Cursor>() {
+            @Override
+            public Cursor call() throws Exception {
+                return SugarRecord.getCursor(getSugarClass(), whereClause, whereArgs, groupBy, orderBy, limit);
+            }
+        };
+
+        final Future<Cursor> future = doInBackground(call);
+        Cursor cursor;
+
+        try {
+            cursor = future.get();
+
+            if (null == cursor) {
+                errorCallback.onError(new Exception("Problem when trying to get the cursor"));
+            } else {
+                successCallback.onSuccess(cursor);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that list all elements. It run a SugarRecord.listAll but it's code is performed asynchronously
+     * with the usage of Futures and callbacks.
+     *
+     * @param orderBy the way you want to order the objects you get
+     * @param successCallback the callback that is performed if the operation is successful
+     * @param errorCallback the callback that is performed if your code has an error
+     */
+    public void listAll(final String orderBy, final SuccessCallback<List<T>> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+
+        final Callable<List<T>> call = new Callable<List<T>>() {
+            @Override
+            public List<T> call() throws Exception {
+                return SugarRecord.listAll(getSugarClass(), orderBy);
+            }
+        };
+
+        final Future<List<T>> future = doInBackground(call);
+        List<T> objects;
+
+        try {
+            objects = future.get();
+
+            if (null == objects || objects.isEmpty()) {
+                errorCallback.onError(new Exception("There are no objects in the database"));
+            } else {
+                successCallback.onSuccess(objects);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+
+    /**
+     * Method that works on top of SugarRecord.update and runs the code asynchronously via Futures
+     * and callbacks.
+     *
+     * @param object the object you want to update
+     * @param successCallback the callback that will be performed if the update is successful
+     * @param errorCallback the callback that will be performed if the update has an error
+     */
+    public void update(final T object, final SuccessCallback<Long> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+        checkNotNull(object);
+
+        final Callable<Long> call = new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                return SugarRecord.update(object);
+            }
+        };
+
+        final Future<Long> future = doInBackground(call);
+        Long id;
+
+        try {
+            id = future.get();
+
+            if (null == id) {
+                errorCallback.onError(new Exception("Error when performing update of " + object.toString()));
+            } else {
+                successCallback.onSuccess(id);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * This method works on top of SugarRecord and provides asynchronous code execution via the usage of
+     * Futures and callbacks to handle success result and error.
+     *
+     * @param object the object you want to delete
+     * @param successCallback the callback to be performed when the operation is successful
+     * @param errorCallback the callback to be performed when the operation has an error
+     */
+    public void delete(final T object, final SuccessCallback<Boolean> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+        checkNotNull(object);
+
+        final Callable<Boolean> call = new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                return SugarRecord.delete(object);
+            }
+        };
+
+        final Future<Boolean> future = doInBackground(call);
+        Boolean isDeleted;
+
+        try {
+            isDeleted = future.get();
+
+            if (null == isDeleted || !isDeleted) {
+                errorCallback.onError(new Exception("Error when performing delete of " + object.toString()));
+            } else {
+                successCallback.onSuccess(isDeleted);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that performs a selective delete. The code is executed asynchronously via the usage of Futures
+     * and result callbacks
+     *
+     * @param whereClause the clause for the search
+     * @param whereArgs the values
+     * @param successCallback the callback to be executed if there is no trouble
+     * @param errorCallback the callback to be executed if there is an error
+     */
+    public void delete(final String whereClause, final String[] whereArgs, final SuccessCallback<Integer> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+
+        final Callable<Integer> call = new Callable<Integer>() {
+            @Override
+            public Integer call() throws Exception {
+                return SugarRecord.deleteAll(getSugarClass(), whereClause, whereArgs);
+            }
+        };
+
+        final Future<Integer> future = doInBackground(call);
+        Integer count;
+
+        try {
+            count = future.get();
+
+            if (null == count) {
+                errorCallback.onError(new Exception("Error when performing delete of all elements"));
+            } else {
+                successCallback.onSuccess(count);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that deletes all data in a SQLite table.
+     *
+     * @param successCallback the callback that is executed if the operation is succesful
+     * @param errorCallback the callback that is executed if there is an error
+     */
+    public void deleteAll(final SuccessCallback<Integer> successCallback, final ErrorCallback errorCallback) {
+        delete(null, null, successCallback, errorCallback);
+    }
+
+    /**
+     * Method that performs a count
+     *
+     * @param successCallback the callback that is executed if this is successful
+     * @param errorCallback the callback that is executed if there is an error
+     */
+    public void count(final SuccessCallback<Long> successCallback, final ErrorCallback errorCallback) {
+        checkNotNull(successCallback);
+        checkNotNull(errorCallback);
+
+        final Callable<Long> call = new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                return SugarRecord.count(getSugarClass());
+            }
+        };
+
+        final Future<Long> future = doInBackground(call);
+        Long count;
+
+        try {
+            count = future.get();
+
+            if (null == count) {
+                errorCallback.onError(new Exception("Error when trying to get count"));
+            } else {
+                successCallback.onSuccess(count);
+            }
+
+        } catch (Exception e) {
+            errorCallback.onError(e);
+        }
+    }
+
+    /**
+     * Method that checks an object to be not null
+     *
+     * @param object the object to be checked
+     */
+    protected void checkNotNull(Object object) {
+        if (null == object) {
+            throw new IllegalArgumentException("object shouldn't be null");
+        }
+    }
+
+    public Class<T> getSugarClass() {
+        return sClass;
+    }
+
+    /**
+     * The callback to be executed when some SugarDataSource operation is successful.
+     *
+     * @author jonatan.salas
+     * @param <S> the parameter of the result that is passed to onSuccess method
+     */
+    public interface SuccessCallback<S> {
+
+        /**
+         * This code is executed if there is no trouble on any SugarDataSource operation.
+         *
+         * @param result the result of some SugarDatasource operation
+         */
+        void onSuccess(final S result);
+    }
+
+    /**
+     * The callback to be executed when some SugarDataSource operation has an error.
+     *
+     * @author jonatan.salas
+     */
+    public interface ErrorCallback {
+
+        /**
+         * This method is executed if some trouble is detected when using some SugarDataSource method.
+         *
+         * @param e the exception thrown by the method of SugarDataSource you have invoked
+         */
+        void onError(final Exception e);
+    }
+}
diff --git a/library/src/main/java/com/orm/SugarDb.java b/library/src/main/java/com/orm/SugarDb.java
new file mode 100644
index 00000000..bc71ba23
--- /dev/null
+++ b/library/src/main/java/com/orm/SugarDb.java
@@ -0,0 +1,86 @@
+package com.orm;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+import com.orm.dsl.BuildConfig;
+import com.orm.helper.ManifestHelper;
+import com.orm.util.SugarCursorFactory;
+
+import static com.orm.util.ContextUtil.getContext;
+import static com.orm.helper.ManifestHelper.getDatabaseVersion;
+import static com.orm.helper.ManifestHelper.getDbName;
+import static com.orm.SugarContext.getDbConfiguration;
+
+public class SugarDb extends SQLiteOpenHelper {
+    private static final String LOG_TAG = "Sugar";
+
+    private final SchemaGenerator schemaGenerator;
+    private SQLiteDatabase sqLiteDatabase;
+    private int openedConnections = 0;
+
+    //Prevent instantiation
+    private SugarDb() {
+        super(getContext(), getDbName(), new SugarCursorFactory(ManifestHelper.isDebugEnabled()), getDatabaseVersion());
+        schemaGenerator = SchemaGenerator.getInstance();
+    }
+
+    public static SugarDb getInstance() {
+        return new SugarDb();
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+        schemaGenerator.createDatabase(sqLiteDatabase);
+    }
+
+    @Override
+    public void onConfigure(SQLiteDatabase db) {
+        final SugarDbConfiguration configuration = getDbConfiguration();
+
+        if (null != configuration) {
+            db.setLocale(configuration.getDatabaseLocale());
+            db.setMaximumSize(configuration.getMaxSize());
+            db.setPageSize(configuration.getPageSize());
+        }
+
+        super.onConfigure(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        schemaGenerator.doUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    public synchronized SQLiteDatabase getDB() {
+        if (this.sqLiteDatabase == null) {
+            this.sqLiteDatabase = getWritableDatabase();
+        }
+
+        return this.sqLiteDatabase;
+    }
+
+    @Override
+    public synchronized SQLiteDatabase getReadableDatabase() {
+        if(ManifestHelper.isDebugEnabled()) {
+            Log.d(LOG_TAG, "getReadableDatabase");
+        }
+        openedConnections++;
+        return super.getReadableDatabase();
+    }
+
+    @Override
+    public synchronized void close() {
+        if(ManifestHelper.isDebugEnabled()) {
+            Log.d(LOG_TAG, "getReadableDatabase");
+        }
+        openedConnections--;
+        if(openedConnections == 0) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "closing");
+            }
+            super.close();
+        }
+    }
+}
diff --git a/library/src/main/java/com/orm/SugarDbConfiguration.java b/library/src/main/java/com/orm/SugarDbConfiguration.java
new file mode 100644
index 00000000..161fce26
--- /dev/null
+++ b/library/src/main/java/com/orm/SugarDbConfiguration.java
@@ -0,0 +1,62 @@
+package com.orm;
+
+import java.util.Locale;
+
+/**
+ * @author jonatan.salas
+ */
+public class SugarDbConfiguration {
+
+    /**
+     * Tells SQLite which is the database default locale
+     */
+    private Locale databaseLocale;
+
+    /**
+     * Tells SQLite how much it can grow
+     */
+    private Long maxSize;
+
+    /**
+     * Tells SQLite the page size that have
+     */
+    private Long pageSize;
+
+    public SugarDbConfiguration() { }
+
+    public Locale getDatabaseLocale() {
+        return databaseLocale;
+    }
+
+    public SugarDbConfiguration setDatabaseLocale(Locale databaseLocale) {
+        this.databaseLocale = databaseLocale;
+        return this;
+    }
+
+    public Long getMaxSize() {
+        return maxSize;
+    }
+
+    public SugarDbConfiguration setMaxSize(Long maxSize) {
+        this.maxSize = maxSize;
+        return this;
+    }
+
+    public Long getPageSize() {
+        return pageSize;
+    }
+
+    public SugarDbConfiguration setPageSize(Long pageSize) {
+        this.pageSize = pageSize;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "SugarDbConfiguration{" +
+                ", databaseLocale=" + databaseLocale +
+                ", maxSize=" + maxSize +
+                ", pageSize=" + pageSize +
+                '}';
+    }
+}
diff --git a/library/src/main/java/com/orm/SugarRecord.java b/library/src/main/java/com/orm/SugarRecord.java
new file mode 100644
index 00000000..2ade2ba3
--- /dev/null
+++ b/library/src/main/java/com/orm/SugarRecord.java
@@ -0,0 +1,550 @@
+package com.orm;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+import android.util.Log;
+import com.orm.annotation.Table;
+import com.orm.annotation.Unique;
+import com.orm.helper.ManifestHelper;
+import com.orm.helper.NamingHelper;
+import com.orm.inflater.EntityInflater;
+import com.orm.util.QueryBuilder;
+import com.orm.util.ReflectionUtil;
+import com.orm.util.SugarCursor;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import static com.orm.SugarContext.getSugarContext;
+
+public class SugarRecord {
+    public static final String SUGAR = "Sugar";
+
+    private Long id = null;
+
+    private static SQLiteDatabase getSugarDataBase() {
+        return getSugarContext().getSugarDb().getDB();
+    }
+
+    public static <T> int deleteAll(Class<T> type) {
+        return deleteAll(type, null);
+    }
+
+    public static <T> int deleteAll(Class<T> type, String whereClause, String... whereArgs) {
+        return getSugarDataBase().delete(NamingHelper.toTableName(type), whereClause, whereArgs);
+    }
+
+    public static <T> Cursor getCursor(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        Cursor raw = getSugarDataBase().query(NamingHelper.toTableName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
+        return new SugarCursor(raw);
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void saveInTx(T... objects) {
+        saveInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void saveInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarDataBase();
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object: objects) {
+                save(object);
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "Error in saving in transaction " + e.getMessage());
+            }
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void updateInTx(T... objects) {
+        updateInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void updateInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarDataBase();
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object: objects) {
+                update(object);
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "Error in saving in transaction " + e.getMessage());
+            }
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> int deleteInTx(T... objects) {
+        return deleteInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> int deleteInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarDataBase();
+        int deletedRows = 0;
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object : objects) {
+                if (delete(object)) {
+                    ++deletedRows;
+                }
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            deletedRows = 0;
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "Error in deleting in transaction " + e.getMessage());
+            }
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+        return deletedRows;
+    }
+
+    public static <T> List<T> listAll(Class<T> type) {
+        return find(type, null, null, null, null, null);
+    }
+
+    public static <T> List<T> listAll(Class<T> type, String orderBy) {
+        return find(type, null, null, null, orderBy, null);
+    }
+
+    public static <T> T findById(Class<T> type, Long id) {
+        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+        if (list.isEmpty()) return null;
+        return list.get(0);
+    }
+
+    public static <T> T findById(Class<T> type, Integer id) {
+        return findById(type, Long.valueOf(id));
+    }
+
+    public static <T> List<T> findById(Class<T> type, String... ids) {
+        String whereClause = "id IN (" + QueryBuilder.generatePlaceholders(ids.length) + ")";
+        return find(type, whereClause, ids);
+    }
+
+    public static <T> T first(Class<T>type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " + NamingHelper.toTableName(type) + " ORDER BY ID ASC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public static <T> T last(Class<T>type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " + NamingHelper.toTableName(type) + " ORDER BY ID DESC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public static <T> Iterator<T> findAll(Class<T> type) {
+        return findAsIterator(type, null, null, null, null, null);
+    }
+
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
+        return findAsIterator(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        Cursor cursor = getSugarDataBase().rawQuery(query, arguments);
+        return new CursorIterator<>(type, cursor);
+    }
+
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        Cursor cursor = getSugarDataBase().query(NamingHelper.toTableName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
+        return new CursorIterator<>(type, cursor);
+    }
+
+    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
+        return find(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
+        Cursor cursor = getSugarDataBase().rawQuery(query, arguments);
+
+        return getEntitiesFromCursor(cursor, type);
+    }
+
+    public static void executeQuery(String query, String... arguments) {
+        getSugarDataBase().execSQL(query, arguments);
+    }
+
+    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+
+        String args[];
+        args = (whereArgs == null) ? null : replaceArgs(whereArgs);
+
+        Cursor cursor = getSugarDataBase().query(NamingHelper.toTableName(type), null, whereClause, args,
+                groupBy, null, orderBy, limit);
+
+        return getEntitiesFromCursor(cursor, type);
+    }
+
+    public static <T> List<T> findOneToMany(Class<T> type, String relationFieldName, Object relationObject, Long relationObjectId) {
+        String args[] = { String.valueOf(relationObjectId) };
+        String whereClause = NamingHelper.toSQLNameDefault(relationFieldName) + " = ?";
+
+        Cursor cursor = getSugarDataBase().query(NamingHelper.toTableName(type), null, whereClause, args,
+                null, null, null, null);
+
+        return getEntitiesFromCursor(cursor, type, relationFieldName, relationObject);
+    }
+
+    public static <T> List<T> getEntitiesFromCursor(Cursor cursor, Class<T> type){
+        return getEntitiesFromCursor(cursor, type, null, null);
+    }
+
+    public static <T> List<T> getEntitiesFromCursor(Cursor cursor, Class<T> type, String relationFieldName, Object relationObject){
+        T entity;
+        List<T> result = new ArrayList<>();
+        try {
+            while (cursor.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                new EntityInflater()
+                        .withCursor(cursor)
+                        .withObject(entity)
+                        .withEntitiesMap(getSugarContext().getEntitiesMap())
+                        .withRelationFieldName(relationFieldName)
+                        .withRelationObject(relationObject)
+                        .inflate();
+                result.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            cursor.close();
+        }
+
+        return result;
+    }
+
+    public static <T> long count(Class<T> type) {
+        return count(type, null, null, null, null, null);
+    }
+
+    public static <T> long count(Class<T> type, String whereClause, String... whereArgs) {
+    	return count(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> long count(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        long result = -1;
+        String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
+        SQLiteStatement sqliteStatement;
+        try {
+            sqliteStatement = getSugarDataBase().compileStatement("SELECT count(*) FROM " + NamingHelper.toTableName(type) + filter);
+        } catch (SQLiteException e) {
+            e.printStackTrace();
+            return result;
+        }
+
+        if (whereArgs != null) {
+            for (int i = whereArgs.length; i != 0; i--) {
+                sqliteStatement.bindString(i, whereArgs[i - 1]);
+            }
+        }
+
+        try {
+            result = sqliteStatement.simpleQueryForLong();
+        } finally {
+            sqliteStatement.close();
+        }
+
+        return result;
+    }
+
+    public static <T> long sum(Class<T> type, String field) {
+        return sum(type, field, null, null);
+    }
+
+    public static <T> long sum(Class<T> type, String field, String whereClause, String... whereArgs) {
+        long result = -1;
+        String filter = (!TextUtils.isEmpty(whereClause)) ? " where " + whereClause : "";
+        SQLiteStatement sqLiteStatement;
+        try {
+            sqLiteStatement = getSugarDataBase().compileStatement("SELECT sum(" + field + ") FROM " + NamingHelper.toTableName(type) + filter);
+        } catch (SQLiteException e) {
+            e.printStackTrace();
+            return result;
+        }
+
+        if (whereArgs != null) {
+            for (int i = whereArgs.length; i != 0; i--) {
+                sqLiteStatement.bindString(i, whereArgs[i - 1]);
+            }
+        }
+
+        try {
+            result = sqLiteStatement.simpleQueryForLong();
+        } finally {
+            sqLiteStatement.close();
+        }
+
+        return result;
+    }
+
+    public static long save(Object object) {
+        return save(getSugarDataBase(), object);
+    }
+
+    static long save(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getSugarContext().getEntitiesMap();
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+        Field idField = null;
+        for (Field column : columns) {
+            ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
+            if (column.getName().equals("id")) {
+                idField = column;
+            }
+        }
+
+        boolean isSugarEntity = isSugarEntity(object.getClass());
+        if (isSugarEntity && entitiesMap.containsKey(object)) {
+                values.put("id", entitiesMap.get(object));
+        }
+
+        long id = db.insertWithOnConflict(NamingHelper.toTableName(object.getClass()), null, values,
+                SQLiteDatabase.CONFLICT_REPLACE);
+
+        if (object.getClass().isAnnotationPresent(Table.class)) {
+            if (idField != null) {
+                idField.setAccessible(true);
+                try {
+                    idField.set(object, id);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                entitiesMap.put(object, id);
+            }
+        } else if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+            ((SugarRecord) object).setId(id);
+        }
+
+        if (ManifestHelper.isDebugEnabled()) {
+            Log.i(SUGAR, object.getClass().getSimpleName() + " saved : " + id);
+        }
+
+        return id;
+    }
+
+    public static long update(Object object) {
+        return update(getSugarDataBase(), object);
+    }
+
+    static long update(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getSugarContext().getEntitiesMap();
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+
+        StringBuilder whereClause = new StringBuilder();
+        List<String> whereArgs = new ArrayList<>();
+
+        for (Field column : columns) {
+            if(column.isAnnotationPresent(Unique.class)) {
+                try {
+                    column.setAccessible(true);
+                    String columnName = NamingHelper.toColumnName(column);
+                    Object columnValue = column.get(object);
+
+                    whereClause.append(columnName).append(" = ?");
+                    whereArgs.add(String.valueOf(columnValue));
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                if (!column.getName().equals("id")) {
+                    ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
+                }
+            }
+        }
+
+        String[] whereArgsArray = whereArgs.toArray(new String[whereArgs.size()]);
+        // Get SugarRecord based on Unique values
+        long rowsEffected = db.update(NamingHelper.toTableName(object.getClass()), values, whereClause.toString(), whereArgsArray);
+
+        if (rowsEffected == 0) {
+            return save(db, object);
+        } else {
+            return rowsEffected;
+        }
+    }
+
+    public static boolean isSugarEntity(Class<?> objectClass) {
+        return objectClass.isAnnotationPresent(Table.class) || SugarRecord.class.isAssignableFrom(objectClass);
+    }
+
+    public boolean delete() {
+        Long id = getId();
+        Class<?> type = getClass();
+        if (id != null && id > 0L) {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, type.getSimpleName() + " deleted : " + id);
+            }
+            return getSugarDataBase().delete(NamingHelper.toTableName(type), "Id=?", new String[]{id.toString()}) == 1;
+        } else {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "Cannot delete object: " + type.getSimpleName() + " - object has not been saved");
+            }
+            return false;
+        }
+    }
+
+    public static boolean delete(Object object) {
+        Class<?> type = object.getClass();
+        if (type.isAnnotationPresent(Table.class)) {
+            try {
+                Field field = type.getDeclaredField("id");
+                field.setAccessible(true);
+                Long id = (Long) field.get(object);
+                if (id != null && id > 0L) {
+                    boolean deleted = getSugarDataBase().delete(NamingHelper.toTableName(type), "Id=?", new String[]{id.toString()}) == 1;
+                    if(ManifestHelper.isDebugEnabled()) {
+                        Log.i(SUGAR, type.getSimpleName() + " deleted : " + id);
+                    }
+                    return deleted;
+                } else {
+                    if(ManifestHelper.isDebugEnabled()) {
+                        Log.i(SUGAR, "Cannot delete object: " + object.getClass().getSimpleName() + " - object has not been saved");
+                    }
+                    return false;
+                }
+            } catch (NoSuchFieldException e) {
+                if(ManifestHelper.isDebugEnabled()) {
+                    Log.i(SUGAR, "Cannot delete object: " + object.getClass().getSimpleName() + " - annotated object has no id");
+                }
+                return false;
+            } catch (IllegalAccessException e) {
+                if(ManifestHelper.isDebugEnabled()) {
+                    Log.i(SUGAR, "Cannot delete object: " + object.getClass().getSimpleName() + " - can't access id");
+                }
+                return false;
+            }
+        } else if (SugarRecord.class.isAssignableFrom(type)) {
+            return ((SugarRecord) object).delete();
+        } else {
+            if(ManifestHelper.isDebugEnabled()) {
+                Log.i(SUGAR, "Cannot delete object: " + object.getClass().getSimpleName() + " - not persisted");
+            }
+            return false;
+        }
+    }
+
+    public long save() {
+        return save(getSugarDataBase(), this);
+    }
+
+    public long update() {
+        return update(getSugarDataBase(), this);
+    }
+
+    @SuppressWarnings("unchecked")
+    void inflate(Cursor cursor) {
+        new EntityInflater()
+                .withCursor(cursor)
+                .withObject(this)
+                .withEntitiesMap(getSugarContext().getEntitiesMap())
+                .inflate();
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    static class CursorIterator<E> implements Iterator<E> {
+        Class<E> type;
+        Cursor cursor;
+
+        public CursorIterator(Class<E> type, Cursor cursor) {
+            this.type = type;
+            this.cursor = cursor;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
+        }
+
+        @Override
+        public E next() {
+            E entity = null;
+            if (cursor == null || cursor.isAfterLast()) {
+                throw new NoSuchElementException();
+            }
+
+            if (cursor.isBeforeFirst()) {
+                cursor.moveToFirst();
+            }
+
+            try {
+                entity = type.getDeclaredConstructor().newInstance();
+                new EntityInflater()
+                        .withCursor(cursor)
+                        .withObject(entity)
+                        .withEntitiesMap(getSugarContext().getEntitiesMap())
+                        .inflate();
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                cursor.moveToNext();
+                if (cursor.isAfterLast()) {
+                    cursor.close();
+                }
+            }
+
+            return entity;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static String[] replaceArgs(String[] args){
+
+        String [] replace = new String[args.length];
+        for (int i=0; i<args.length; i++){
+
+            replace[i]= (args[i].equals("true")) ? replace[i]="1" : (args[i].equals("false")) ? replace[i]="0" : args[i];
+
+        }
+
+        return replace;
+
+    }
+
+}
diff --git a/library/src/com/orm/dsl/Column.java b/library/src/main/java/com/orm/annotation/Column.java
similarity index 64%
rename from library/src/com/orm/dsl/Column.java
rename to library/src/main/java/com/orm/annotation/Column.java
index 2c47e3c0..ce4c2376 100644
--- a/library/src/com/orm/dsl/Column.java
+++ b/library/src/main/java/com/orm/annotation/Column.java
@@ -1,9 +1,12 @@
-package com.orm.dsl;
+package com.orm.annotation;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Column {
     String name();
     boolean unique() default false;
diff --git a/library/src/com/orm/dsl/Ignore.java b/library/src/main/java/com/orm/annotation/Ignore.java
similarity index 53%
rename from library/src/com/orm/dsl/Ignore.java
rename to library/src/main/java/com/orm/annotation/Ignore.java
index 9678d33a..d214a559 100644
--- a/library/src/com/orm/dsl/Ignore.java
+++ b/library/src/main/java/com/orm/annotation/Ignore.java
@@ -1,8 +1,11 @@
-package com.orm.dsl;
+package com.orm.annotation;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Ignore {
 }
diff --git a/library/src/main/java/com/orm/annotation/MultiUnique.java b/library/src/main/java/com/orm/annotation/MultiUnique.java
new file mode 100644
index 00000000..fbdaa0df
--- /dev/null
+++ b/library/src/main/java/com/orm/annotation/MultiUnique.java
@@ -0,0 +1,15 @@
+package com.orm.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Inherited
+public @interface MultiUnique {
+    String value();
+}
+
diff --git a/library/src/com/orm/dsl/NotNull.java b/library/src/main/java/com/orm/annotation/NotNull.java
similarity index 53%
rename from library/src/com/orm/dsl/NotNull.java
rename to library/src/main/java/com/orm/annotation/NotNull.java
index b2361851..f3a6f585 100644
--- a/library/src/com/orm/dsl/NotNull.java
+++ b/library/src/main/java/com/orm/annotation/NotNull.java
@@ -1,8 +1,11 @@
-package com.orm.dsl;
+package com.orm.annotation;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface NotNull {
 }
diff --git a/library/src/main/java/com/orm/annotation/OneToMany.java b/library/src/main/java/com/orm/annotation/OneToMany.java
new file mode 100644
index 00000000..5423256b
--- /dev/null
+++ b/library/src/main/java/com/orm/annotation/OneToMany.java
@@ -0,0 +1,16 @@
+package com.orm.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by ukasz Wesoowski on 28.07.2016.
+ */
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface OneToMany {
+    String targetField();
+}
diff --git a/library/src/com/orm/dsl/Table.java b/library/src/main/java/com/orm/annotation/Table.java
similarity index 57%
rename from library/src/com/orm/dsl/Table.java
rename to library/src/main/java/com/orm/annotation/Table.java
index 0dfaa18b..82ffc15b 100644
--- a/library/src/com/orm/dsl/Table.java
+++ b/library/src/main/java/com/orm/annotation/Table.java
@@ -1,9 +1,12 @@
-package com.orm.dsl;
+package com.orm.annotation;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
 public @interface Table {
     String name() default "";
 }
diff --git a/library/src/com/orm/dsl/Unique.java b/library/src/main/java/com/orm/annotation/Unique.java
similarity index 53%
rename from library/src/com/orm/dsl/Unique.java
rename to library/src/main/java/com/orm/annotation/Unique.java
index 7384b749..a6027e05 100644
--- a/library/src/com/orm/dsl/Unique.java
+++ b/library/src/main/java/com/orm/annotation/Unique.java
@@ -1,8 +1,11 @@
-package com.orm.dsl;
+package com.orm.annotation;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Unique {
 }
diff --git a/library/src/com/orm/util/ManifestHelper.java b/library/src/main/java/com/orm/helper/ManifestHelper.java
similarity index 53%
rename from library/src/com/orm/util/ManifestHelper.java
rename to library/src/main/java/com/orm/helper/ManifestHelper.java
index fb65724c..cab85fd2 100644
--- a/library/src/com/orm/util/ManifestHelper.java
+++ b/library/src/main/java/com/orm/helper/ManifestHelper.java
@@ -1,39 +1,46 @@
-package com.orm.util;
+package com.orm.helper;
 
-import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
 
+import static com.orm.util.ContextUtil.*;
+
 /**
  * Helper class for accessing properties in the AndroidManifest
  */
-public class ManifestHelper {
+public final class ManifestHelper {
+    private static final String LOG_TAG = "Sugar";
+    private static Boolean debugEnabled = null;
 
     /**
      * Key for the database name meta data.
      */
     public final static String METADATA_DATABASE = "DATABASE";
+
     /**
-     * Key for the database verison meta data.
+     * Key for the database version meta data.
      */
     public final static String METADATA_VERSION = "VERSION";
     public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
     public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+
     /**
      * The default name for the database unless specified in the AndroidManifest.
      */
     public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
 
+    //Prevent instantiation
+    private ManifestHelper() { }
+
     /**
      * Grabs the database version from the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
      *         not present
      */
-    public static int getDatabaseVersion(Context context) {
-        Integer databaseVersion = getMetaDataInteger(context, METADATA_VERSION);
+    public static int getDatabaseVersion() {
+        Integer databaseVersion = getMetaDataInteger(METADATA_VERSION);
 
         if ((databaseVersion == null) || (databaseVersion == 0)) {
             databaseVersion = 1;
@@ -43,13 +50,12 @@ public static int getDatabaseVersion(Context context) {
     }
 
     /**
-     * Grabs the domain name of the model classes from the manifest. 
+     * Grabs the domain name of the model classes from the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the package String that Sugar uses to search for model classes
      */
-    public static String getDomainPackageName(Context context){
-        String domainPackageName = getMetaDataString(context, METADATA_DOMAIN_PACKAGE_NAME);
+    public static String getDomainPackageName() {
+        String domainPackageName = getMetaDataString(METADATA_DOMAIN_PACKAGE_NAME);
 
         if (domainPackageName == null) {
             domainPackageName = "";
@@ -61,12 +67,11 @@ public static String getDomainPackageName(Context context){
     /**
      * Grabs the name of the database file specified in the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
      *         {@link #DATABASE_DEFAULT_NAME} if not present
      */
-    public static String getDatabaseName(Context context) {
-        String databaseName = getMetaDataString(context, METADATA_DATABASE);
+    public static String getDatabaseName() {
+        String databaseName = getMetaDataString(METADATA_DATABASE);
 
         if (databaseName == null) {
             databaseName = DATABASE_DEFAULT_NAME;
@@ -75,59 +80,62 @@ public static String getDatabaseName(Context context) {
         return databaseName;
     }
 
+    public static String getDbName() {
+        return getDatabaseName();
+    }
+
     /**
      * Grabs the debug flag from the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return true if the debug flag is enabled
      */
-    public static boolean getDebugEnabled(Context context) {
-        return getMetaDataBoolean(context, METADATA_QUERY_LOG);
+    public static boolean isDebugEnabled() {
+        return (null == debugEnabled) ? debugEnabled = getMetaDataBoolean(METADATA_QUERY_LOG) : debugEnabled;
     }
 
-    private static String getMetaDataString(Context context, String name) {
+    private static String getMetaDataString(String name) {
+        PackageManager pm = getPackageManager();
         String value = null;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getString(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "Couldn't find config value: " + name);
+            }
         }
 
         return value;
     }
 
-    private static Integer getMetaDataInteger(Context context, String name) {
+    private static Integer getMetaDataInteger(String name) {
+        PackageManager pm = getPackageManager();
         Integer value = null;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getInt(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "Couldn't find config value: " + name);
+            }
         }
 
         return value;
     }
 
-    private static Boolean getMetaDataBoolean(Context context, String name) {
+    private static Boolean getMetaDataBoolean(String name) {
+        PackageManager pm = getPackageManager();
         Boolean value = false;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getBoolean(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d(LOG_TAG, "Couldn't find config value: " + name);
         }
 
         return value;
     }
-
 }
diff --git a/library/src/main/java/com/orm/helper/MultiDexHelper.java b/library/src/main/java/com/orm/helper/MultiDexHelper.java
new file mode 100644
index 00000000..588908cd
--- /dev/null
+++ b/library/src/main/java/com/orm/helper/MultiDexHelper.java
@@ -0,0 +1,113 @@
+package com.orm.helper;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Build;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.List;
+
+import dalvik.system.DexFile;
+
+import static com.orm.util.ContextUtil.getSharedPreferences;
+import static com.orm.util.ContextUtil.getPackageManager;
+import static com.orm.util.ContextUtil.getPackageName;
+
+/**
+ * Created by xudshen@hotmail.com on 14/11/13.
+ */
+//http://stackoverflow.com/a/26892658
+public final class MultiDexHelper {
+    private static final String EXTRACTED_NAME_EXT = ".classes";
+    private static final String EXTRACTED_SUFFIX = ".zip";
+    private static final String INSTANT_RUN_DEX_DIR_PATH = "files/instant-run/dex/";
+    private static final String SECONDARY_FOLDER_NAME = "code_cache" + File.separator + "secondary-dexes";
+    private static final String PREFS_FILE = "multidex.version";
+    private static final String KEY_DEX_NUMBER = "dex.number";
+
+    //Prevent instantiation..
+    private MultiDexHelper() { }
+
+    @SuppressWarnings("all")
+    private static SharedPreferences getMultiDexPreferences() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+            return getSharedPreferences(PREFS_FILE, Context.MODE_PRIVATE);
+        } else {
+            return getSharedPreferences(PREFS_FILE, Context.MODE_MULTI_PROCESS);
+        }
+    }
+
+    /**
+     * get all the dex path
+     *
+     * @return all the dex path, including the ones in the newly added instant-run folder
+     * @throws PackageManager.NameNotFoundException
+     * @throws IOException
+     */
+    public static List<String> getSourcePaths() throws PackageManager.NameNotFoundException, IOException {
+        ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(getPackageName(), 0);
+        File sourceApk = new File(applicationInfo.sourceDir);
+        File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);
+        File instantRunDir = new File(applicationInfo.dataDir, INSTANT_RUN_DEX_DIR_PATH); //default instant-run dir
+
+        List<String> sourcePaths = new ArrayList<>();
+        sourcePaths.add(applicationInfo.sourceDir); //add the default apk path
+
+        if (instantRunDir.exists()) { //check if app using instant run
+            for(final File dexFile : instantRunDir.listFiles()) { //add all sources from instan-run
+                sourcePaths.add(dexFile.getAbsolutePath());
+            }
+        }
+
+        //the prefix of extracted file, ie: test.classes
+        String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;
+        //the total dex numbers
+        int totalDexNumber = getMultiDexPreferences().getInt(KEY_DEX_NUMBER, 1);
+
+        for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {
+            //for each dex file, ie: test.classes2.zip, test.classes3.zip...
+            String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;
+            File extractedFile = new File(dexDir, fileName);
+            if (extractedFile.isFile()) {
+                sourcePaths.add(extractedFile.getAbsolutePath());
+                //we ignore the verify zip part
+            }
+        }
+
+        return sourcePaths;
+    }
+
+    /**
+     * get all the classes name in "classes.dex", "classes2.dex", ....
+     *
+     * @return all the classes name
+     * @throws PackageManager.NameNotFoundException
+     * @throws IOException
+     */
+    public static List<String> getAllClasses() throws PackageManager.NameNotFoundException, IOException {
+        List<String> classNames = new ArrayList<>();
+        for (String path : getSourcePaths()) {
+            try {
+                DexFile dexfile;
+                if (path.endsWith(EXTRACTED_SUFFIX)) {
+                    //NOT use new DexFile(path), because it will throw "permission error in /data/dalvik-cache"
+                    dexfile = DexFile.loadDex(path, path + ".tmp", 0);
+                } else {
+                    dexfile = new DexFile(path);
+                }
+                Enumeration<String> dexEntries = dexfile.entries();
+                while (dexEntries.hasMoreElements()) {
+                    classNames.add(dexEntries.nextElement());
+                }
+            } catch (IOException e) {
+                throw new IOException("Error at loading dex file '" + path + "'");
+            }
+        }
+        return classNames;
+    }
+}
diff --git a/library/src/com/orm/util/NamingHelper.java b/library/src/main/java/com/orm/helper/NamingHelper.java
similarity index 77%
rename from library/src/com/orm/util/NamingHelper.java
rename to library/src/main/java/com/orm/helper/NamingHelper.java
index dd86f8d1..0ae3128b 100644
--- a/library/src/com/orm/util/NamingHelper.java
+++ b/library/src/main/java/com/orm/helper/NamingHelper.java
@@ -1,16 +1,14 @@
-package com.orm.util;
+package com.orm.helper;
 
-import android.text.TextUtils;
-
-import com.orm.dsl.Column;
-import com.orm.dsl.Table;
+import com.orm.annotation.Column;
+import com.orm.annotation.Table;
 
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
 
-public class NamingHelper {
+public final class NamingHelper {
+
+    //Prevent instantiation
+    private NamingHelper() { }
 
     /**
      * Converts a given CamelCasedString to UPPER_CASE_UNDER_SCORE.
@@ -38,9 +36,9 @@ public static String toSQLNameDefault(String camelCased) {
             } else if (Character.isUpperCase(c)) {
                 if (Character.isLetterOrDigit(prevChar)) {
                     if (Character.isLowerCase(prevChar)) {
-                        sb.append('_').append(Character.toUpperCase(c));
+                        sb.append('_').append(c);
                     } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
-                        sb.append('_').append(Character.toUpperCase(c));
+                        sb.append('_').append(c);
                     } else {
                         sb.append(c);
                     }
@@ -58,11 +56,11 @@ public static String toSQLNameDefault(String camelCased) {
      *
      * @param field  the {@link java.lang.reflect.Field} that will be mapped
      * @return the name of the given Field as represented in the database. If the Field is annotated
-     *         with {@link com.orm.dsl.Column} then the {@link com.orm.dsl.Column#name()} will be
+     *         with {@link com.orm.annotation.Column} then the {@link com.orm.annotation.Column#name()} will be
      *         returned. Else, the Field's {@link java.lang.reflect.Field#getName()} will be
      *         converted from CamelCase to UNDER_SCORE notation
      */
-    public static String toSQLName(Field field) {
+    public static String toColumnName(Field field) {
         if (field.isAnnotationPresent(Column.class)) {
             Column annotation = field.getAnnotation(Column.class);
             return annotation.name();
@@ -74,12 +72,12 @@ public static String toSQLName(Field field) {
     /**
      * Maps a Java Class to the name of the class.
      *
-     * @param table  the generic {@link java.lang.Class<T>} that defines a database table
-     * @return if the given class is annotated with {@link com.orm.dsl.Table} then the value for
-     *         {@link com.orm.dsl.Table#name()} will be returned. Else, the class' simple name will 
+     * @param table  the generic {@link java.lang.Class} that defines a database table
+     * @return if the given class is annotated with {@link com.orm.annotation.Table} then the value for
+     *         {@link com.orm.annotation.Table#name()} will be returned. Else, the class' simple name will
      *         be converted from CamelCase to UNDER_SCORE notation
      */
-    public static String toSQLName(Class<?> table) {
+    public static String toTableName(Class<?> table) {
         if (table.isAnnotationPresent(Table.class)) {
             Table annotation = table.getAnnotation(Table.class);
             if ("".equals(annotation.name())) {
diff --git a/library/src/main/java/com/orm/helper/SugarTransactionHelper.java b/library/src/main/java/com/orm/helper/SugarTransactionHelper.java
new file mode 100644
index 00000000..dbb9ca26
--- /dev/null
+++ b/library/src/main/java/com/orm/helper/SugarTransactionHelper.java
@@ -0,0 +1,41 @@
+package com.orm.helper;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import static com.orm.SugarContext.getSugarContext;
+
+public final class SugarTransactionHelper {
+    private static final String LOG_TAG = SugarTransactionHelper.class.getSimpleName();
+
+    //Prevent instantiation..
+    private SugarTransactionHelper() { }
+
+    public static void doInTransaction(Callback callback) {
+        final SQLiteDatabase database = getSugarContext().getSugarDb().getDB();
+        database.beginTransaction();
+
+        try {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "Callback executing within transaction");
+            }
+
+            callback.manipulateInTransaction();
+            database.setTransactionSuccessful();
+
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "Callback successfully executed within transaction");
+            }
+        } catch (Throwable e) {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.d(LOG_TAG, "Could execute callback within transaction", e);
+            }
+        } finally {
+            database.endTransaction();
+        }
+    }
+
+    public interface Callback {
+        void manipulateInTransaction();
+    }
+}
diff --git a/library/src/main/java/com/orm/inflater/EntityInflater.java b/library/src/main/java/com/orm/inflater/EntityInflater.java
new file mode 100644
index 00000000..5d71e5df
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/EntityInflater.java
@@ -0,0 +1,75 @@
+package com.orm.inflater;
+
+import android.database.Cursor;
+import com.orm.SugarRecord;
+import com.orm.inflater.field.*;
+import com.orm.util.ReflectionUtil;
+
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public class EntityInflater {
+    private Cursor cursor;
+    private Object object;
+    private Object relationObject;
+    private String relationFieldName;
+    private Map<Object, Long> entitiesMap;
+
+    public EntityInflater withCursor(Cursor cursor) {
+        this.cursor = cursor;
+        return this;
+    }
+
+    public EntityInflater withObject(Object object) {
+        this.object = object;
+        return this;
+    }
+
+    public EntityInflater withRelationObject(Object relationObject) {
+        this.relationObject = relationObject;
+        return this;
+    }
+
+    public EntityInflater withRelationFieldName(String relationFieldName) {
+        this.relationFieldName = relationFieldName;
+        return this;
+    }
+
+    public EntityInflater withEntitiesMap(Map<Object, Long> entitiesMap) {
+        this.entitiesMap = entitiesMap;
+        return this;
+    }
+
+    public void inflate() {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        Long objectId = cursor.getLong(cursor.getColumnIndex(("ID")));
+        if (!entitiesMap.containsKey(object)) {
+            entitiesMap.put(object, objectId);
+        }
+
+        FieldInflater fieldInflater;
+
+        for (Field field : columns) {
+            field.setAccessible(true);
+            Class<?> fieldType = field.getType();
+
+            if (SugarRecord.isSugarEntity(fieldType)) {
+                if (field.getName().equals(relationFieldName)) {
+                    fieldInflater = new RelationEntityFieldInflater(field, cursor, object, fieldType, relationObject);
+                } else {
+                    fieldInflater = new EntityFieldInflater(field, cursor, object, fieldType);
+                }
+            } else if (fieldType.equals(List.class)) {
+                fieldInflater = new ListFieldInflater(field, cursor, object, fieldType);
+            } else {
+                fieldInflater = new DefaultFieldInflater(field, cursor, object, fieldType);
+            }
+
+            fieldInflater.inflate();
+        }
+    }
+}
diff --git a/library/src/main/java/com/orm/inflater/field/DefaultFieldInflater.java b/library/src/main/java/com/orm/inflater/field/DefaultFieldInflater.java
new file mode 100644
index 00000000..d1cd8542
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/field/DefaultFieldInflater.java
@@ -0,0 +1,21 @@
+package com.orm.inflater.field;
+
+import android.database.Cursor;
+import com.orm.util.ReflectionUtil;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public class DefaultFieldInflater extends FieldInflater {
+
+    public DefaultFieldInflater(Field field, Cursor cursor, Object object, Class<?> fieldType) {
+        super(field, cursor, object, fieldType);
+    }
+
+    @Override
+    public void inflate() {
+        ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
+    }
+}
diff --git a/library/src/main/java/com/orm/inflater/field/EntityFieldInflater.java b/library/src/main/java/com/orm/inflater/field/EntityFieldInflater.java
new file mode 100644
index 00000000..9eda8f8e
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/field/EntityFieldInflater.java
@@ -0,0 +1,29 @@
+package com.orm.inflater.field;
+
+import android.database.Cursor;
+import android.util.Log;
+import com.orm.SugarRecord;
+import com.orm.helper.NamingHelper;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public class EntityFieldInflater extends FieldInflater {
+    private static final String LOG_TAG = "EntityFieldInflater";
+
+    public EntityFieldInflater(Field field, Cursor cursor, Object object, Class<?> fieldType) {
+        super(field, cursor, object, fieldType);
+    }
+
+    @Override
+    public void inflate() {
+        try {
+            long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toColumnName(field)));
+            field.set(object, (id > 0) ? SugarRecord.findById(fieldType, id) : null);
+        } catch (IllegalAccessException e) {
+            Log.e(LOG_TAG, String.format("Error while inflating entity field %s", field), e);
+        }
+    }
+}
diff --git a/library/src/main/java/com/orm/inflater/field/FieldInflater.java b/library/src/main/java/com/orm/inflater/field/FieldInflater.java
new file mode 100644
index 00000000..87795340
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/field/FieldInflater.java
@@ -0,0 +1,24 @@
+package com.orm.inflater.field;
+
+import android.database.Cursor;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public abstract class FieldInflater {
+    protected Field field;
+    protected Cursor cursor;
+    protected Object object;
+    protected Class<?> fieldType;
+
+    public FieldInflater(Field field, Cursor cursor, Object object, Class<?> fieldType) {
+        this.field = field;
+        this.cursor = cursor;
+        this.object = object;
+        this.fieldType = fieldType;
+    }
+
+    public abstract void inflate();
+}
diff --git a/library/src/main/java/com/orm/inflater/field/ListFieldInflater.java b/library/src/main/java/com/orm/inflater/field/ListFieldInflater.java
new file mode 100644
index 00000000..5fa7496c
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/field/ListFieldInflater.java
@@ -0,0 +1,38 @@
+package com.orm.inflater.field;
+
+import android.database.Cursor;
+import android.util.Log;
+import com.orm.SugarRecord;
+import com.orm.annotation.OneToMany;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.ParameterizedType;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public class ListFieldInflater extends FieldInflater {
+    private static final String LOG_TAG = "ListFieldInflater";
+
+    public ListFieldInflater(Field field, Cursor cursor, Object object, Class<?> fieldType) {
+        super(field, cursor, object, fieldType);
+    }
+
+    @Override
+    public void inflate() {
+        if (field.isAnnotationPresent(OneToMany.class)) {
+            try {
+                Long objectId = cursor.getLong(cursor.getColumnIndex(("ID")));
+
+                ParameterizedType genericListType = (ParameterizedType) field.getGenericType();
+                Class<?> genericListClass = (Class<?>) genericListType.getActualTypeArguments()[0];
+                String targetName = field.getAnnotation(OneToMany.class).targetField();
+                field.set(object, SugarRecord.findOneToMany(genericListClass, targetName, object, objectId));
+            } catch (IllegalAccessException e) {
+                Log.e(LOG_TAG, String.format("Error while inflating list field %s", field), e);
+            }
+        } else {
+            Log.w(LOG_TAG, String.format("List field %s has not OneToMany annotation", field));
+        }
+    }
+}
diff --git a/library/src/main/java/com/orm/inflater/field/RelationEntityFieldInflater.java b/library/src/main/java/com/orm/inflater/field/RelationEntityFieldInflater.java
new file mode 100644
index 00000000..72df20f7
--- /dev/null
+++ b/library/src/main/java/com/orm/inflater/field/RelationEntityFieldInflater.java
@@ -0,0 +1,29 @@
+package com.orm.inflater.field;
+
+import android.database.Cursor;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by ukasz Wesoowski on 03.08.2016.
+ */
+public class RelationEntityFieldInflater extends EntityFieldInflater {
+    private static final String LOG_TAG = "RelEntityFieldInflater";
+
+    protected Object relationObject;
+
+    public RelationEntityFieldInflater(Field field, Cursor cursor, Object object, Class<?> fieldType, Object relationObject) {
+        super(field, cursor, object, fieldType);
+        this.relationObject = relationObject;
+    }
+
+    @Override
+    public void inflate() {
+        try {
+            field.set(object, relationObject);
+        } catch (IllegalAccessException e) {
+            Log.e(LOG_TAG, String.format("Error while inflating %s field", field), e);
+        }
+    }
+}
diff --git a/library/src/com/orm/query/Condition.java b/library/src/main/java/com/orm/query/Condition.java
similarity index 64%
rename from library/src/com/orm/query/Condition.java
rename to library/src/main/java/com/orm/query/Condition.java
index 989bd458..52ae052c 100644
--- a/library/src/com/orm/query/Condition.java
+++ b/library/src/main/java/com/orm/query/Condition.java
@@ -1,5 +1,7 @@
 package com.orm.query;
 
+import com.orm.SugarRecord;
+
 public class Condition {
 
     private String property;
@@ -12,7 +14,9 @@
         LESSER_THAN(" < "),
         NOT_EQUALS (" != "),
         LIKE(" LIKE "),
-        NOT_LIKE(" NOT LIKE ");
+        NOT_LIKE(" NOT LIKE "),
+        IS_NULL(" IS NULL "),
+        IS_NOT_NULL(" IS NOT NULL ");
 
         private String symbol;
 
@@ -40,41 +44,59 @@ public static Condition prop(String property) {
     }
 
     public Condition eq(Object value) {
-        this.value = value;
+        if (value == null) {
+            return isNull();
+        }
+        setValue(value);
         check = Check.EQUALS;
         return this;
     }
 
     public Condition like(Object value) {
-        this.value = value;
+        setValue(value);
         check = Check.LIKE;
         return this;
     }
 
     public Condition notLike(Object value) {
-        this.value = value;
+        setValue(value);
         check = Check.NOT_LIKE;
         return this;
     }
 
     public Condition notEq(Object value) {
-        this.value = value;
+        if (value == null) {
+            return isNotNull();
+        }
+        setValue(value);
         check = Check.NOT_EQUALS;
         return this;
     }
 
     public Condition gt(Object value) {
-        this.value = value;
+        setValue(value);
         check = Check.GREATER_THAN;
         return this;
     }
 
     public Condition lt(Object value) {
-        this.value = value;
+        setValue(value);
         check = Check.LESSER_THAN;
         return this;
     }
 
+    public Condition isNull() {
+        setValue(null);
+        check = Check.IS_NULL;
+        return this;
+    }
+
+    public Condition isNotNull() {
+        setValue(null);
+        check = Check.IS_NOT_NULL;
+        return this;
+    }
+
     public String getProperty() {
         return property;
     }
@@ -91,4 +113,12 @@ public String getCheckSymbol() {
         return check.getSymbol();
     }
 
+    private void setValue(Object value) {
+        if (value instanceof SugarRecord) {
+            this.value = ((SugarRecord)value).getId();
+        } else {
+            this.value = value;
+        }
+    }
+
 }
diff --git a/library/src/com/orm/query/Select.java b/library/src/main/java/com/orm/query/Select.java
similarity index 58%
rename from library/src/com/orm/query/Select.java
rename to library/src/main/java/com/orm/query/Select.java
index 9e91543c..cc57199d 100644
--- a/library/src/com/orm/query/Select.java
+++ b/library/src/main/java/com/orm/query/Select.java
@@ -1,29 +1,41 @@
 package com.orm.query;
 
+import android.database.Cursor;
+
 import com.orm.SugarRecord;
-import com.orm.util.NamingHelper;
+import com.orm.helper.NamingHelper;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 public class Select<T> implements Iterable {
+    private static final String SPACE = " ";
+    private static final String SINGLE_QUOTE = "'";
+    private static final String LEFT_PARENTHESIS = "(";
+    private static final String RIGHT_PARENTHESIS = ")";
+    private static final String SELECT_FROM = "SELECT * FROM ";
+    private static final String WHERE = "WHERE ";
+    private static final String ORDER_BY = "ORDER BY ";
+    private static final String GROUP_BY = "GROUP BY ";
+    private static final String LIMIT = "LIMIT ";
+    private static final String OFFSET = "OFFSET ";
 
     private Class<T> record;
     private String[] arguments;
     private String whereClause = "";
-    private String orderBy;
-    private String groupBy;
-    private String limit;
-    private String offset;
-    private List<Object> args = new ArrayList<Object>();
+    private String orderBy = "";
+    private String groupBy = "";
+    private String limit = "";
+    private String offset = "";
+    private List<String> args = new ArrayList<>();
 
     public Select(Class<T> record) {
         this.record = record;
     }
 
     public static <T> Select<T> from(Class<T> record) {
-        return new Select<T>(record);
+        return new Select<>(record);
     }
 
     public Select<T> orderBy(String prop) {
@@ -41,6 +53,11 @@ public Select(Class<T> record) {
         return this;
     }
 
+    public Select<T> offset(String offset) {
+        this.offset = offset;
+        return this;
+    }
+
     public Select<T> where(String whereClause) {
         this.whereClause = whereClause;
         return this;
@@ -54,10 +71,10 @@ public Select(Class<T> record) {
     }
 
     private void mergeConditions(Condition[] conditions, Condition.Type type) {
-        StringBuilder toAppend = new StringBuilder("");
+        StringBuilder toAppend = new StringBuilder();
         for (Condition condition : conditions) {
             if (toAppend.length() != 0) {
-                toAppend.append(" ").append(type.name()).append(" ");
+                toAppend.append(SPACE).append(type.name()).append(SPACE);
             }
 
             if (Condition.Check.LIKE.equals(condition.getCheck()) ||
@@ -65,24 +82,28 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
                 toAppend
                     .append(condition.getProperty())
                     .append(condition.getCheckSymbol())
-                    .append("'")
+                    .append(SINGLE_QUOTE)
                     .append(condition.getValue().toString())
-                    .append("'");
-
+                    .append(SINGLE_QUOTE);
+            } else if (Condition.Check.IS_NULL.equals(condition.getCheck()) ||
+                    Condition.Check.IS_NOT_NULL.equals(condition.getCheck())) {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol());
             } else {
                 toAppend
                     .append(condition.getProperty())
                     .append(condition.getCheckSymbol())
                     .append("? ");
-                args.add(condition.getValue());
+                args.add(condition.getValue().toString());
             }
         }
         
-        if (!"".equals(whereClause)) {
-            whereClause += " " + type.name() + " ";
+        if (!whereClause.isEmpty()) {
+            whereClause += SPACE + type.name() + SPACE;
         }
 
-        whereClause += "(" + toAppend + ")";
+        whereClause += LEFT_PARENTHESIS + toAppend + RIGHT_PARENTHESIS;
     }
 
     public Select<T> whereOr(Condition... args) {
@@ -106,6 +127,9 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
         return this;
     }
 
+    public Cursor getCursor() {
+       return SugarRecord.getCursor(record, whereClause, arguments, groupBy, orderBy, limit);
+    }
     public List<T> list() {
         if (arguments == null) {
             arguments = convertArgs(args);
@@ -133,22 +157,26 @@ public T first() {
     
     String toSql() {
         StringBuilder sql = new StringBuilder();
-        sql.append("SELECT * FROM ").append(NamingHelper.toSQLName(this.record)).append(" ");
+        sql.append(SELECT_FROM).append(NamingHelper.toTableName(this.record)).append(SPACE);
+
+        if (!whereClause.isEmpty()) {
+            sql.append(WHERE).append(whereClause).append(SPACE);
+        }
 
-        if (whereClause != null) {
-            sql.append("WHERE ").append(whereClause).append(" ");
+        if (!orderBy.isEmpty()) {
+            sql.append(ORDER_BY).append(orderBy).append(SPACE);
         }
 
-        if (orderBy != null) {
-            sql.append("ORDER BY ").append(orderBy).append(" ");
+        if (!groupBy.isEmpty()) {
+            sql.append(GROUP_BY).append(groupBy).append(SPACE);
         }
 
-        if (limit != null) {
-            sql.append("LIMIT ").append(limit).append(" ");
+        if (!limit.isEmpty()) {
+            sql.append(LIMIT).append(limit).append(SPACE);
         }
 
-        if (offset != null) {
-            sql.append("OFFSET ").append(offset).append(" ");
+        if (!offset.isEmpty()) {
+            sql.append(OFFSET).append(offset).append(SPACE);
         }
 
         return sql.toString();
@@ -162,14 +190,8 @@ String getWhereCond() {
         return convertArgs(args);
     }
 
-    private String[] convertArgs(List<Object> argsList) {
-        String[] argsArray = new String[argsList.size()];
-
-        for (int i = 0; i < argsList.size(); i++) {
-             argsArray[i] = argsList.get(i).toString();
-        }
-
-        return argsArray;
+    private String[] convertArgs(List<String> argsList) {
+        return argsList.toArray(new String[argsList.size()]);
     }
 
     @Override
diff --git a/library/src/main/java/com/orm/util/ContextUtil.java b/library/src/main/java/com/orm/util/ContextUtil.java
new file mode 100644
index 00000000..3e6eff58
--- /dev/null
+++ b/library/src/main/java/com/orm/util/ContextUtil.java
@@ -0,0 +1,48 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.content.res.AssetManager;
+
+/**
+ * @author jonatan.salas
+ */
+public final class ContextUtil {
+    private static Context ctx;
+
+    //Prevent instantiation
+    private ContextUtil() { }
+
+    public static void init(Context context) {
+        if (null == context) {
+            throw new IllegalArgumentException("context shouldn't be null!");
+        }
+
+        ctx = context;
+    }
+
+    public static void terminate() {
+        ctx = null;
+    }
+
+    public static Context getContext() {
+        return ctx;
+    }
+
+    public static AssetManager getAssets() {
+        return getContext().getAssets();
+    }
+
+    public static PackageManager getPackageManager() {
+        return getContext().getPackageManager();
+    }
+
+    public static String getPackageName() {
+        return getContext().getPackageName();
+    }
+
+    public static SharedPreferences getSharedPreferences(String name, int mode) {
+        return getContext().getSharedPreferences(name, mode);
+    }
+}
diff --git a/library/src/main/java/com/orm/util/KeyWordUtil.java b/library/src/main/java/com/orm/util/KeyWordUtil.java
new file mode 100644
index 00000000..8983e7cf
--- /dev/null
+++ b/library/src/main/java/com/orm/util/KeyWordUtil.java
@@ -0,0 +1,41 @@
+package com.orm.util;
+
+/**
+ * @author jonatan.salas
+ */
+public final class KeyWordUtil {
+
+    private static final String[] KEY_WORDS = new String[] {
+            "", "ABORT", "ACTION", "ADD", "AFTER", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ATTACH",
+            "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK",
+            "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_DATE",
+            "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE",
+            "DESC", "DETACH", "DISTINCT", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUSIVE",
+            "EXISTS", "EXPLAIN", "FAIL", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", "HAVING",
+            "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD",
+            "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LEFT", "LIKE", "LIMIT", "MATCH", "NATURAL",
+            "NO", "NOT", "NOTNULL", "NULL", "OF", "OFFSET", "ON", "OR", "ORDER", "OUTER", "PLAN", "PRAGMA",
+            "PRIMARY", "QUERY", "RAISE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME",
+            "REPLACE", "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP",
+            "TEMPORARY", "THEN", "TO", "TRANSACTION", "TRIGGER", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM",
+            "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WITH", "WITHOUT"
+    };
+
+    //Prevent instantiation
+    private KeyWordUtil() { }
+
+    public static boolean isKeyword(String word) {
+        if (null == word) {
+            return false;
+        }
+
+        for (String keyWord: KEY_WORDS) {
+            if (keyWord.equals(word)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
+
diff --git a/library/src/main/java/com/orm/util/MigrationFileParser.java b/library/src/main/java/com/orm/util/MigrationFileParser.java
new file mode 100644
index 00000000..1691a1eb
--- /dev/null
+++ b/library/src/main/java/com/orm/util/MigrationFileParser.java
@@ -0,0 +1,21 @@
+package com.orm.util;
+
+/**
+ * Created by Nursultan Turdaliev on 12/4/15.
+ */
+public class MigrationFileParser {
+
+    private String content;
+
+    /**
+     * @param content
+     */
+    public MigrationFileParser(String content){
+        this.content = content.replaceAll("(\\/\\*([\\s\\S]*?)\\*\\/)|(--(.)*)|(\n)","");
+    }
+
+    public String[] getStatements(){
+        return this.content.split(";");
+    }
+
+}
diff --git a/library/src/com/orm/util/NumberComparator.java b/library/src/main/java/com/orm/util/NumberComparator.java
similarity index 79%
rename from library/src/com/orm/util/NumberComparator.java
rename to library/src/main/java/com/orm/util/NumberComparator.java
index b39ca9c9..a6a08053 100644
--- a/library/src/com/orm/util/NumberComparator.java
+++ b/library/src/main/java/com/orm/util/NumberComparator.java
@@ -2,9 +2,12 @@
 
 import java.util.Comparator;
 
+import static java.lang.Character.isDigit;
+import static java.lang.Character.isSpaceChar;
+
 public class NumberComparator implements Comparator<Object> {
 
-    private static char charAt(String s, int i) {
+    protected static char charAt(String s, int i) {
         if (i >= s.length()) {
             return '\000';
         }
@@ -12,7 +15,7 @@ private static char charAt(String s, int i) {
         return s.charAt(i);
     }
 
-    private int compareRight(String a, String b) {
+    protected int compareRight(String a, String b) {
         int bias = 0;
         int ia = 0;
         int ib = 0;
@@ -20,13 +23,13 @@ private int compareRight(String a, String b) {
             char ca = charAt(a, ia);
             char cb = charAt(b, ib);
 
-            if ((!Character.isDigit(ca)) && (!Character.isDigit(cb))) {
+            if ((!isDigit(ca)) && (!isDigit(cb))) {
                 return bias;
             }
-            if (!Character.isDigit(ca)) {
+            if (!isDigit(ca)) {
                 return -1;
             }
-            if (!Character.isDigit(cb)) {
+            if (!isDigit(cb)) {
                 return 1;
             }
             if (ca < cb) {
@@ -49,15 +52,15 @@ public int compare(Object o1, Object o2) {
 
         int ia = 0;
         int ib = 0;
-        int nza = 0;
-        int nzb = 0;
+        int nza;
+        int nzb;
         while (true) {
             nza = nzb = 0;
 
             char ca = charAt(a, ia);
             char cb = charAt(b, ib);
 
-            while ((Character.isSpaceChar(ca)) || (ca == '0')) {
+            while ((isSpaceChar(ca)) || (ca == '0')) {
                 if (ca == '0') {
                     nza++;
                 } else {
@@ -67,7 +70,7 @@ public int compare(Object o1, Object o2) {
                 ca = charAt(a, ++ia);
             }
 
-            while ((Character.isSpaceChar(cb)) || (cb == '0')) {
+            while ((isSpaceChar(cb)) || (cb == '0')) {
                 if (cb == '0') {
                     nzb++;
                 } else {
@@ -77,7 +80,7 @@ public int compare(Object o1, Object o2) {
                 cb = charAt(b, ++ib);
             }
             int result;
-            if ((Character.isDigit(ca)) && (Character.isDigit(cb)) &&
+            if ((isDigit(ca)) && (isDigit(cb)) &&
                     ((result = compareRight(a.substring(ia), b.substring(ib))) != 0)) {
                 return result;
             }
diff --git a/library/src/com/orm/util/QueryBuilder.java b/library/src/main/java/com/orm/util/QueryBuilder.java
similarity index 65%
rename from library/src/com/orm/util/QueryBuilder.java
rename to library/src/main/java/com/orm/util/QueryBuilder.java
index 6de9e8ca..e1c3557f 100644
--- a/library/src/com/orm/util/QueryBuilder.java
+++ b/library/src/main/java/com/orm/util/QueryBuilder.java
@@ -2,6 +2,10 @@
 
 import com.orm.SugarRecord;
 
+import java.lang.RuntimeException;
+import java.lang.StringBuilder;
+import java.math.BigDecimal;
+
 public class QueryBuilder {
 
     public static String getColumnType(Class<?> type) {
@@ -31,11 +35,24 @@ public static String getColumnType(Class<?> type) {
             return "FLOAT";
         }
 
-        if ((type.equals(String.class)) || (type.equals(Character.TYPE))) {
+        if ((type.equals(String.class)) || (type.equals(Character.TYPE)) ||
+                (type.equals(BigDecimal.class))) {
             return "TEXT";
         }
 
         return "";
     }
 
+    public static String generatePlaceholders(int numberOfArgs) {
+        if (numberOfArgs < 1) {
+            throw new RuntimeException("The number of arguments must be greater than or equal to 1.");
+        }
+
+        StringBuilder stringBuilder = new StringBuilder(numberOfArgs * 2 - 1);
+        stringBuilder.append("?");
+        for (int i = 1; i < numberOfArgs; i++) {
+            stringBuilder.append(",?");
+        }
+        return stringBuilder.toString();
+    }
 }
diff --git a/library/src/com/orm/util/ReflectionUtil.java b/library/src/main/java/com/orm/util/ReflectionUtil.java
similarity index 57%
rename from library/src/com/orm/util/ReflectionUtil.java
rename to library/src/main/java/com/orm/util/ReflectionUtil.java
index 3dc2b59d..18943d09 100644
--- a/library/src/com/orm/util/ReflectionUtil.java
+++ b/library/src/main/java/com/orm/util/ReflectionUtil.java
@@ -1,36 +1,50 @@
 package com.orm.util;
 
 import android.content.ContentValues;
-import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.util.Log;
+
 import com.orm.SugarRecord;
-import com.orm.dsl.Ignore;
-import com.orm.dsl.Table;
-import dalvik.system.DexFile;
+import com.orm.annotation.Ignore;
+import com.orm.annotation.Table;
+import com.orm.helper.ManifestHelper;
+import com.orm.helper.MultiDexHelper;
+import com.orm.helper.NamingHelper;
 
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
 import java.net.URL;
 import java.sql.Timestamp;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+
+public final class ReflectionUtil {
 
-public class ReflectionUtil {
+    //Prevent instantiation..
+    private ReflectionUtil() { }
 
     public static List<Field> getTableFields(Class table) {
         List<Field> fieldList = SugarConfig.getFields(table);
         if (fieldList != null) return fieldList;
 
-        Log.d("Sugar", "Fetching properties");
-        List<Field> typeFields = new ArrayList<Field>();
+        if (ManifestHelper.isDebugEnabled()) {
+            Log.d("Sugar", "Fetching properties");
+        }
+        List<Field> typeFields = new ArrayList<>();
 
         getAllFields(typeFields, table);
 
-        List<Field> toStore = new ArrayList<Field>();
+        List<Field> toStore = new ArrayList<>();
         for (Field field : typeFields) {
             if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
                 toStore.add(field);
@@ -51,14 +65,30 @@
         return fields;
     }
 
-    public static void addFieldValueToColumn(ContentValues values, Field column, Object object) {
+    public static void addFieldValueToColumn(ContentValues values, Field column, Object object,
+                                             Map<Object, Long> entitiesMap) {
         column.setAccessible(true);
         Class<?> columnType = column.getType();
         try {
-            String columnName = NamingHelper.toSQLName(column);
+            String columnName = NamingHelper.toColumnName(column);
             Object columnValue = column.get(object);
 
-            if (SugarRecord.class.isAssignableFrom(columnType)) {
+            if (columnType.isAnnotationPresent(Table.class)) {
+                Field field;
+                try {
+                    field = columnType.getDeclaredField("id");
+                    field.setAccessible(true);
+                    if(columnValue != null) {
+                        values.put(columnName,String.valueOf(field.get(columnValue)));
+                    } else {
+                        values.putNull(columnName);
+                    }
+                } catch (NoSuchFieldException e) {
+                    if (entitiesMap.containsKey(columnValue)) {
+                        values.put(columnName, entitiesMap.get(columnValue));
+                    }
+                }
+            } else if (SugarRecord.class.isAssignableFrom(columnType)) {
                 values.put(columnName,
                         (columnValue != null)
                                 ? String.valueOf(((SugarRecord) columnValue).getId())
@@ -76,6 +106,12 @@ public static void addFieldValueToColumn(ContentValues values, Field column, Obj
                     values.put(columnName, (Double) columnValue);
                 } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
                     values.put(columnName, (Boolean) columnValue);
+                } else if (columnType.equals(BigDecimal.class)) {
+                    try {
+                        values.put(columnName, column.get(object).toString());
+                    } catch (NullPointerException e) {
+                        values.putNull(columnName);
+                    }
                 } else if (Timestamp.class.equals(columnType)) {
                     try {
                         values.put(columnName, ((Timestamp) column.get(object)).getTime());
@@ -94,9 +130,19 @@ public static void addFieldValueToColumn(ContentValues values, Field column, Obj
                     } catch (NullPointerException e) {
                         values.put(columnName, (Long) null);
                     }
+                } else if (columnType.equals(byte[].class)) {
+                    if (columnValue == null) {
+                        values.put(columnName, "".getBytes());
+                    } else {
+                        values.put(columnName, (byte[]) columnValue);
+                    }
+                } else if (columnType.equals(List.class)) {
+                    //ignore
                 } else {
                     if (columnValue == null) {
                         values.putNull(columnName);
+                    } else if (columnType.isEnum()) {
+                        values.put(columnName, ((Enum) columnValue).name());
                     } else {
                         values.put(columnName, String.valueOf(columnValue));
                     }
@@ -104,7 +150,9 @@ public static void addFieldValueToColumn(ContentValues values, Field column, Obj
             }
 
         } catch (IllegalAccessException e) {
-            Log.e("Sugar", e.getMessage());
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.e("Sugar", e.getMessage());
+            }
         }
     }
 
@@ -112,17 +160,25 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
         field.setAccessible(true);
         try {
             Class fieldType = field.getType();
-            String colName = NamingHelper.toSQLName(field);
+            String colName = NamingHelper.toColumnName(field);
 
             int columnIndex = cursor.getColumnIndex(colName);
 
+            //TODO auto upgrade to add new columns
+            if (columnIndex < 0) {
+                if (ManifestHelper.isDebugEnabled()) {
+                    Log.e("SUGAR", "Invalid colName, you should upgrade database");
+                }
+                return;
+            }
+
             if (cursor.isNull(columnIndex)) {
                 return;
             }
 
             if (colName.equalsIgnoreCase("id")) {
                 long cid = cursor.getLong(columnIndex);
-                field.set(object, Long.valueOf(cid));
+                field.set(object, cid);
             } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
                 field.set(object,
                         cursor.getLong(columnIndex));
@@ -135,9 +191,6 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
             } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
                 field.set(object,
                         cursor.getString(columnIndex).equals("1"));
-            } else if (field.getType().getName().equals("[B")) {
-                field.set(object,
-                        cursor.getBlob(columnIndex));
             } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
                 field.set(object,
                         cursor.getInt(columnIndex));
@@ -147,6 +200,9 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
             } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
                 field.set(object,
                         cursor.getShort(columnIndex));
+            } else if (fieldType.equals(BigDecimal.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : new BigDecimal(val));
             } else if (fieldType.equals(Timestamp.class)) {
                 long l = cursor.getLong(columnIndex);
                 field.set(object, new Timestamp(l));
@@ -158,6 +214,13 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
                 Calendar c = Calendar.getInstance();
                 c.setTimeInMillis(l);
                 field.set(object, c);
+            } else if (fieldType.equals(byte[].class)) {
+                byte[] bytes = cursor.getBlob(columnIndex);
+                if (bytes == null) {
+                    field.set(object, "".getBytes());
+                } else {
+                    field.set(object, cursor.getBlob(columnIndex));
+                }
             } else if (Enum.class.isAssignableFrom(fieldType)) {
                 try {
                     Method valueOf = field.getType().getMethod("valueOf", String.class);
@@ -165,56 +228,71 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
                     Object enumVal = valueOf.invoke(field.getType(), strVal);
                     field.set(object, enumVal);
                 } catch (Exception e) {
-                    Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                    if (ManifestHelper.isDebugEnabled()) {
+                        Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                    }
                 }
-            } else
-                Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
-        } catch (IllegalArgumentException e) {
-            Log.e("field set error", e.getMessage());
-        } catch (IllegalAccessException e) {
-            Log.e("field set error", e.getMessage());
+            } else {
+                if (ManifestHelper.isDebugEnabled()) {
+                    Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
+                }
+            }
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.e("field set error", e.getMessage());
+            }
         }
     }
 
-    public static void setFieldValueForId(Object object, Long value) {
-
+    private static Field getDeepField(String fieldName, Class<?> type) throws NoSuchFieldException {
         try {
-            Field field = object.getClass().getField("id");
+            return type.getDeclaredField(fieldName);
+        } catch (NoSuchFieldException e) {
+            Class superclass = type.getSuperclass();
+            if (superclass != null) {
+                return getDeepField(fieldName, superclass);
+            } else {
+                throw e;
+            }
+        }
+    }
 
+    public static void setFieldValueForId(Object object, Long value) {
+        try {
+            Field field = getDeepField("id", object.getClass());
             field.setAccessible(true);
             field.set(object, value);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (NoSuchFieldException e) {
+        } catch (Exception e) {
             e.printStackTrace();
         }
     }
 
-    public static List<Class> getDomainClasses(Context context) {
-        List<Class> domainClasses = new ArrayList<Class>();
+    public static List<Class> getDomainClasses() {
+        List<Class> domainClasses = new ArrayList<>();
         try {
-            for (String className : getAllClasses(context)) {
-                if (className.startsWith(ManifestHelper.getDomainPackageName(context))) {
-                    Class domainClass = getDomainClass(className, context);
-                    if (domainClass != null) domainClasses.add(domainClass);
-                }
+            for (String className : getAllClasses()) {
+                Class domainClass = getDomainClass(className);
+                if (domainClass != null) domainClasses.add(domainClass);
+            }
+        } catch (IOException | PackageManager.NameNotFoundException  e) {
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.e("Sugar", e.getMessage());
             }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
         }
 
         return domainClasses;
     }
 
 
-    private static Class getDomainClass(String className, Context context) {
+    private static Class getDomainClass(String className) {
         Class<?> discoveredClass = null;
         try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
+            discoveredClass = Class.forName(className, true, Thread.currentThread().getContextClassLoader());
+        } catch (Throwable e) {
+            String error = (e.getMessage() == null) ? "getDomainClass " + className + " error" : e.getMessage();
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.e("Sugar", error);
+            }
         }
 
         if ((discoveredClass != null) &&
@@ -223,7 +301,9 @@ private static Class getDomainClass(String className, Context context) {
                         discoveredClass.isAnnotationPresent(Table.class)) &&
                 !Modifier.isAbstract(discoveredClass.getModifiers())) {
 
-            Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+            if (ManifestHelper.isDebugEnabled()) {
+                Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+            }
             return discoveredClass;
 
         } else {
@@ -232,30 +312,36 @@ private static Class getDomainClass(String className, Context context) {
     }
 
 
-    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String path = getSourcePath(context);
-        List<String> classNames = new ArrayList<String>();
+    private static List<String> getAllClasses() throws PackageManager.NameNotFoundException, IOException {
+        String packageName = ManifestHelper.getDomainPackageName();
+        List<String> classNames = new ArrayList<>();
         try {
-            DexFile dexfile = new DexFile(path);
-            Enumeration<String> dexEntries = dexfile.entries();
-            while (dexEntries.hasMoreElements()) {
-                classNames.add(dexEntries.nextElement());
+            List<String> allClasses = MultiDexHelper.getAllClasses();
+            for (String classString : allClasses) {
+                if (classString.startsWith(packageName)) classNames.add(classString);
             }
         } catch (NullPointerException e) {
             ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
             Enumeration<URL> urls = classLoader.getResources("");
-            List<String> fileNames = new ArrayList<String>();
             while (urls.hasMoreElements()) {
+                List<String> fileNames = new ArrayList<>();
                 String classDirectoryName = urls.nextElement().getFile();
-                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
+                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")
+                        || classDirectoryName.contains("retrolambda")) {
                     File classDirectory = new File(classDirectoryName);
                     for (File filePath : classDirectory.listFiles()) {
                         populateFiles(filePath, fileNames, "");
                     }
-                    classNames.addAll(fileNames);
+                    for (String fileName : fileNames) {
+                        if (fileName.startsWith(packageName)) classNames.add(fileName);
+                    }
                 }
             }
         }
+//        } finally {
+//            if (null != dexfile) dexfile.close();
+//        }
+
         return classNames;
     }
 
@@ -281,7 +367,7 @@ private static void populateFiles(File path, List<String> fileNames, String pare
         }
     }
 
-    private static String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
-        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    private static String getSourcePath() throws PackageManager.NameNotFoundException {
+        return ContextUtil.getPackageManager().getApplicationInfo(ContextUtil.getPackageName(), 0).sourceDir;
     }
 }
diff --git a/library/src/com/orm/util/SugarConfig.java b/library/src/main/java/com/orm/util/SugarConfig.java
similarity index 68%
rename from library/src/com/orm/util/SugarConfig.java
rename to library/src/main/java/com/orm/util/SugarConfig.java
index b93da25e..46ebd8da 100644
--- a/library/src/com/orm/util/SugarConfig.java
+++ b/library/src/main/java/com/orm/util/SugarConfig.java
@@ -1,20 +1,14 @@
 package com.orm.util;
 
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.util.Log;
-
 import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-
 public class SugarConfig {
 
-    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
+    static Map<Class<?>, List<Field>> fields = new HashMap<>();
 
     public static void setFields(Class<?> clazz, List<Field> fieldz) {
          fields.put(clazz, fieldz);
@@ -31,7 +25,6 @@ public static void setFields(Class<?> clazz, List<Field> fieldz) {
 
     public static void clearCache() {
         fields.clear();
-        fields = new HashMap<Class<?>, List<Field>>();
+        fields = new HashMap<>();
     }
-
 }
diff --git a/library/src/main/java/com/orm/util/SugarCursor.java b/library/src/main/java/com/orm/util/SugarCursor.java
new file mode 100644
index 00000000..d058c5c1
--- /dev/null
+++ b/library/src/main/java/com/orm/util/SugarCursor.java
@@ -0,0 +1,30 @@
+package com.orm.util;
+
+import android.database.Cursor;
+import android.database.CursorWrapper;
+
+public class SugarCursor extends CursorWrapper {
+
+    public SugarCursor(Cursor cursor) {
+        super(cursor);
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+        try {
+            return super.getColumnIndexOrThrow(columnName);
+        } catch (IllegalArgumentException e) {
+            if (columnName.equals("_id"))
+                return super.getColumnIndexOrThrow("ID");
+            else
+                throw e;
+        }
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+        if (columnName.equals("_id"))
+            columnName = "ID";
+        return super.getColumnIndex(columnName);
+    }
+}
diff --git a/library/src/com/orm/util/SugarCursorFactory.java b/library/src/main/java/com/orm/util/SugarCursorFactory.java
similarity index 99%
rename from library/src/com/orm/util/SugarCursorFactory.java
rename to library/src/main/java/com/orm/util/SugarCursorFactory.java
index 12706516..3274fccc 100644
--- a/library/src/com/orm/util/SugarCursorFactory.java
+++ b/library/src/main/java/com/orm/util/SugarCursorFactory.java
@@ -16,7 +16,6 @@ public SugarCursorFactory() {
     }
 
     public SugarCursorFactory(boolean debugEnabled) {
-
         this.debugEnabled = debugEnabled;
     }
 
diff --git a/library/src/main/java/com/orm/util/ThreadUtil.java b/library/src/main/java/com/orm/util/ThreadUtil.java
new file mode 100644
index 00000000..665e5c2d
--- /dev/null
+++ b/library/src/main/java/com/orm/util/ThreadUtil.java
@@ -0,0 +1,34 @@
+package com.orm.util;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+/**
+ * Util class to deal with threads.
+ *
+ * @author jonatan.salas
+ */
+public final class ThreadUtil {
+
+    //Prevent instantiation..
+    private ThreadUtil() { }
+
+    /**
+     * Submits a Callable object and returns a Future ready to use.
+     *
+     * @param callable the callable you want to submit
+     * @return a Future object
+     */
+    public static Future doInBackground(Callable callable) {
+        final ExecutorService executor = Executors.newSingleThreadExecutor();
+        Future future = executor.submit(callable);
+
+        if(executor.isTerminated()) {
+            executor.shutdown();
+        }
+
+        return future;
+    }
+}
diff --git a/library/src/test/java/com/orm/SchemaGeneratorTest.java b/library/src/test/java/com/orm/SchemaGeneratorTest.java
new file mode 100644
index 00000000..811d1aa1
--- /dev/null
+++ b/library/src/test/java/com/orm/SchemaGeneratorTest.java
@@ -0,0 +1,179 @@
+package com.orm;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.AllAnotatedModel;
+import com.orm.model.EmptyModel;
+import com.orm.model.IntUniqueModel;
+import com.orm.model.MultiColumnUniqueModel;
+import com.orm.model.StringFieldAnnotatedModel;
+import com.orm.model.StringFieldExtendedModel;
+import com.orm.model.StringFieldExtendedModelAnnotatedColumn;
+import com.orm.helper.NamingHelper;
+import com.orm.model.TestRecord;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SchemaGeneratorTest {
+
+    @Test
+    public void testEmptyTableCreation() throws Exception {
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(EmptyModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(EmptyModel.class) +
+                    " ( ID INTEGER PRIMARY KEY AUTOINCREMENT  ) ",
+                createSQL);
+    }
+
+    @Test
+    public void testSimpleColumnTableCreation() throws Exception {
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(StringFieldExtendedModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(StringFieldExtendedModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "STRING TEXT ) ",
+                createSQL);
+
+        String createSQL2 = schemaGenerator.createTableSQL(StringFieldAnnotatedModel.class);
+
+        assertEquals("CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(StringFieldAnnotatedModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "STRING TEXT ) ",
+                createSQL2);
+
+        String createSQL3 = schemaGenerator.createTableSQL(StringFieldExtendedModelAnnotatedColumn.class);
+
+        assertEquals("CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(StringFieldExtendedModelAnnotatedColumn.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "anyName TEXT ) ",
+                createSQL3);
+    }
+
+    @Test
+    public void testUniqueTableCreation() {
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(IntUniqueModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(IntUniqueModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "VALUE INTEGER UNIQUE ) ",
+                createSQL);
+    }
+
+    @Test
+    public void testMultiColumnUniqueTableCreation() {
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(MultiColumnUniqueModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toTableName(MultiColumnUniqueModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "A INTEGER, B INTEGER, " +
+                        "UNIQUE(A, B) ON CONFLICT REPLACE ) ",
+                createSQL);
+    }
+
+    @Test
+    public void testTableCreation() {
+        SQLiteDatabase sqLiteDatabase = SugarContext.getSugarContext().getSugarDb().getDB();
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        schemaGenerator.createTable(TestRecord.class, sqLiteDatabase);
+        String sql = "select count(*) from sqlite_master where type='table' and name='%s';";
+
+        String tableName = NamingHelper.toTableName(TestRecord.class);
+        Cursor c = sqLiteDatabase.rawQuery(String.format(sql, tableName), null);
+
+        if (c.moveToFirst()) {
+            Assert.assertEquals(1, c.getInt(0));
+        }
+
+        if (!c.isClosed()) {
+            c.close();
+        }
+    }
+
+    @Test
+    public void testAnnotatedModelTableCreation() {
+        SQLiteDatabase sqLiteDatabase = SugarContext.getSugarContext().getSugarDb().getDB();
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        schemaGenerator.createTable(AllAnotatedModel.class, sqLiteDatabase);
+        String sql = "select count(*) from sqlite_master where type='table' and name='%s';";
+
+        String tableName = NamingHelper.toTableName(AllAnotatedModel.class);
+        Cursor c = sqLiteDatabase.rawQuery(String.format(sql, tableName), null);
+
+        if (c.moveToFirst()) {
+            Assert.assertEquals(1, c.getInt(0));
+        }
+
+        if (!c.isClosed()) {
+            c.close();
+        }
+    }
+
+    @Test
+    public void testAllTableCreation() {
+        SQLiteDatabase sqLiteDatabase = SugarContext.getSugarContext().getSugarDb().getDB();
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+
+        schemaGenerator.createDatabase(sqLiteDatabase);
+        String sql = "select count(*) from sqlite_master where type='table';";
+
+        Cursor c = sqLiteDatabase.rawQuery(sql, null);
+
+        if (c.moveToFirst()) {
+            Assert.assertEquals(48, c.getInt(0));
+        }
+
+        if (!c.isClosed()) {
+            c.close();
+        }
+    }
+
+    @Test
+    public void testDeleteAllTables() {
+        SQLiteDatabase sqLiteDatabase = SugarContext.getSugarContext().getSugarDb().getDB();
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+
+        schemaGenerator.createDatabase(sqLiteDatabase);
+        schemaGenerator.deleteTables(sqLiteDatabase);
+
+        String sql = "select count(*) from sqlite_master where type='table';";
+
+        Cursor c = sqLiteDatabase.rawQuery(sql, null);
+
+        if (c.moveToFirst()) {
+            //Two tables are by default created by SQLite
+            Assert.assertEquals(2, c.getInt(0));
+        }
+
+        if (!c.isClosed()) {
+            c.close();
+        }
+    }
+
+    @Test
+    public void testGetColumnNames() {
+        SQLiteDatabase sqLiteDatabase = SugarContext.getSugarContext().getSugarDb().getDB();
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        schemaGenerator.createTable(TestRecord.class, sqLiteDatabase);
+
+        List<String> columnNames = schemaGenerator.getColumnNames(sqLiteDatabase, NamingHelper.toTableName(TestRecord.class));
+        Assert.assertEquals(2, columnNames.size());
+    }
+}
diff --git a/library/src/test/java/com/orm/SugarAppTest.java b/library/src/test/java/com/orm/SugarAppTest.java
new file mode 100644
index 00000000..0f247ae8
--- /dev/null
+++ b/library/src/test/java/com/orm/SugarAppTest.java
@@ -0,0 +1,31 @@
+package com.orm;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+
+/**
+ * @author jonatan.salas
+ */
+public final class SugarAppTest {
+
+    @Test
+    public void testOnCreate() {
+        SugarApp app = new SugarApp();
+        app.onCreate();
+
+        SugarContext context = SugarContext.getSugarContext();
+        Assert.assertNotNull(context);
+    }
+
+
+    @Test(expected = NullPointerException.class)
+    public void testOnTerminate() {
+        SugarApp app = new SugarApp();
+        app.onCreate();
+        app.onTerminate();
+
+        SugarContext context = SugarContext.getSugarContext();
+        Assert.assertNull(context);
+    }
+}
diff --git a/library/src/test/java/com/orm/SugarDataSourceTest.java b/library/src/test/java/com/orm/SugarDataSourceTest.java
new file mode 100644
index 00000000..9f3d25ba
--- /dev/null
+++ b/library/src/test/java/com/orm/SugarDataSourceTest.java
@@ -0,0 +1,543 @@
+package com.orm;
+
+import android.database.Cursor;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.TestRecord;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static junit.framework.Assert.*;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SugarDataSourceTest {
+    private SugarDataSource<TestRecord> recordSugarDataSource;
+
+    @Before
+    public void setUp() {
+        recordSugarDataSource = SugarDataSource.getInstance(TestRecord.class);
+    }
+
+    @Test
+    public void testInsertAndDelete() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        assertNotNull(record.getId());
+
+        recordSugarDataSource.delete(
+                record,
+                new SugarDataSource.SuccessCallback<Boolean>() {
+                    @Override
+                    public void onSuccess(Boolean result) {
+                        assertNotNull(result);
+                        assertEquals(true, result.booleanValue());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testInsertAndFindById() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.findById(
+                record.getId(),
+                new SugarDataSource.SuccessCallback<TestRecord>() {
+                    @Override
+                    public void onSuccess(TestRecord result) {
+                        assertEquals(record.getId(), result.getId());
+                        assertEquals(record.getName(), result.getName());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testInsertUpdateAndFindById() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        record.setName("fulano");
+        recordSugarDataSource.update(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        assertEquals(record.getId(), id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.findById(
+                record.getId(),
+                new SugarDataSource.SuccessCallback<TestRecord>() {
+                    @Override
+                    public void onSuccess(TestRecord result) {
+                        assertEquals(record.getId(), result.getId());
+                        assertEquals("fulano", result.getName());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testInsertAndListAll() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        final TestRecord record1 = new TestRecord();
+        record1.setName("fulano");
+
+        recordSugarDataSource.insert(
+                record1,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record1.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        final TestRecord record2 = new TestRecord();
+        record2.setName("mengano");
+
+        recordSugarDataSource.insert(
+                record2,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record2.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.listAll(
+                null,
+                new SugarDataSource.SuccessCallback<List<TestRecord>>() {
+                    @Override
+                    public void onSuccess(List<TestRecord> list) {
+                        assertEquals(3, list.size());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.deleteAll(
+                new SugarDataSource.SuccessCallback<Integer>() {
+                    @Override
+                    public void onSuccess(Integer count) {
+                        assertEquals(3, count.intValue());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testInsertAndCount() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        final TestRecord record1 = new TestRecord();
+        record1.setName("fulano");
+
+        recordSugarDataSource.insert(
+                record1,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record1.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+
+        final TestRecord record2 = new TestRecord();
+        record2.setName("mengano");
+
+        recordSugarDataSource.insert(
+                record2,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record2.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.count(
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long count) {
+                        assertEquals(3, count.longValue());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testInsertAndGetCursor() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        recordSugarDataSource.insert(
+                record,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        final TestRecord record1 = new TestRecord();
+        record1.setName("fulano");
+
+        recordSugarDataSource.insert(
+                record1,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record1.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+
+        final TestRecord record2 = new TestRecord();
+        record2.setName("mengano");
+
+        recordSugarDataSource.insert(
+                record2,
+                new SugarDataSource.SuccessCallback<Long>() {
+                    @Override
+                    public void onSuccess(Long id) {
+                        record2.setId(id);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.listAll(
+                null,
+                new SugarDataSource.SuccessCallback<List<TestRecord>>() {
+                    @Override
+                    public void onSuccess(List<TestRecord> list) {
+                        assertEquals(3, list.size());
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.query(
+                null,
+                null,
+                null,
+                null,
+                null,
+                new SugarDataSource.SuccessCallback<Cursor>() {
+                    @Override
+                    public void onSuccess(Cursor cursor) {
+                        assertNotNull(cursor);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void bulkInsertAndListAllTest() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        final TestRecord record1 = new TestRecord();
+        record1.setName("fulano");
+
+        final TestRecord record2 = new TestRecord();
+        record2.setName("mengano");
+
+        final List<TestRecord> list = new ArrayList<>();
+        list.add(record);
+        list.add(record1);
+        list.add(record2);
+
+        recordSugarDataSource.bulkInsert(
+                list,
+                new SugarDataSource.SuccessCallback<List<Long>>() {
+                    @Override
+                    public void onSuccess(List<Long> ids) {
+                        for (int i = 0; i < list.size(); i++) {
+                            list.get(i).setId(ids.get(i));
+                        }
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+
+        recordSugarDataSource.listAll(
+                null,
+                new SugarDataSource.SuccessCallback<List<TestRecord>>() {
+                    @Override
+                    public void onSuccess(List<TestRecord> testRecords) {
+                        for (int i = 0; i < list.size(); i++) {
+                            TestRecord record1 = list.get(i);
+                            TestRecord record2 = testRecords.get(i);
+
+                            assertEquals(record1.getId(), record2.getId());
+                            assertEquals(record1.getName(), record2.getName());
+                        }
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void nullFindById() {
+        TestRecord record = new TestRecord();
+        record.setId(0L);
+
+        recordSugarDataSource.findById(
+                record.getId(),
+                new SugarDataSource.SuccessCallback<TestRecord>() {
+                    @Override
+                    public void onSuccess(TestRecord object) {
+                        assertNull(object);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        assertNotNull(e.getMessage());
+                    }
+                }
+        );
+    }
+
+    @Test
+    public void testNullListAll() {
+        recordSugarDataSource.listAll(
+                null,
+                new SugarDataSource.SuccessCallback<List<TestRecord>>() {
+                    @Override
+                    public void onSuccess(List<TestRecord> object) {
+                        assertNull(object);
+                    }
+                },
+                new SugarDataSource.ErrorCallback() {
+                    @Override
+                    public void onError(Exception e) {
+                        assertNotNull(e.getMessage());
+                    }
+                }
+        );
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("all")
+    public void testNullConstructor() {
+        SugarDataSource<TestRecord> dataSource = SugarDataSource.getInstance(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    @SuppressWarnings("all")
+    public void testCheckNotNull() {
+        TestRecord record = null;
+        recordSugarDataSource.checkNotNull(record);
+    }
+}
diff --git a/library/src/test/java/com/orm/SugarDbConfigurationTest.java b/library/src/test/java/com/orm/SugarDbConfigurationTest.java
new file mode 100644
index 00000000..64d50df6
--- /dev/null
+++ b/library/src/test/java/com/orm/SugarDbConfigurationTest.java
@@ -0,0 +1,64 @@
+package com.orm;
+
+import com.orm.dsl.BuildConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 16, constants = BuildConfig.class)
+public final class SugarDbConfigurationTest {
+
+    @Test
+    public void testNotNullConfiguration() {
+        SugarDbConfiguration configuration = new SugarDbConfiguration()
+                .setDatabaseLocale(Locale.getDefault())
+                .setMaxSize(1024L)
+                .setPageSize(400L);
+
+        SugarContext.init(RuntimeEnvironment.application, configuration);
+
+        final SugarDbConfiguration config = SugarContext.getDbConfiguration();
+
+        assertEquals(configuration.getDatabaseLocale(), config.getDatabaseLocale());
+        assertEquals(configuration.getMaxSize(), config.getMaxSize());
+        assertEquals(configuration.getPageSize(), config.getPageSize());
+    }
+
+    @Test
+    public void testNullConfiguration() {
+        SugarContext.init(RuntimeEnvironment.application);
+        assertNull(SugarContext.getDbConfiguration());
+    }
+
+//    @Test
+//    public void testNotNullConfigurationWithSugarDb() {
+//        SugarDbConfiguration configuration = new SugarDbConfiguration()
+//                .setDatabaseLocale(Locale.getDefault())
+//                .setMaxSize(100000L)
+//                .setPageSize(100000L);
+//
+//        SugarContext.init(RuntimeEnvironment.application, configuration);
+//
+//        SQLiteDatabase database = SugarContext.getSugarContext().getSugarDb().getDB();
+//        SQLiteDatabase sqLiteDatabase = SugarDb.getInstance().getDB();
+//
+//        assertEquals(database.getMaximumSize(), sqLiteDatabase.getMaximumSize());
+//        assertEquals(database.getPageSize(), sqLiteDatabase.getPageSize());
+//
+//        if (sqLiteDatabase.isOpen()) {
+//            sqLiteDatabase.close();
+//        }
+//    }
+}
diff --git a/library/src/test/java/com/orm/SugarDbTest.java b/library/src/test/java/com/orm/SugarDbTest.java
new file mode 100644
index 00000000..7ff5914a
--- /dev/null
+++ b/library/src/test/java/com/orm/SugarDbTest.java
@@ -0,0 +1,41 @@
+package com.orm;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SugarDbTest {
+    private final SugarDb sugarDb = SugarDb.getInstance();
+
+    @Test
+    //TODO check this better!
+    public void testGetReadableDatabase() {
+        final SQLiteDatabase db = sugarDb.getReadableDatabase();
+        assertEquals(false, db.isReadOnly());
+    }
+
+    @Test
+    public void testGetWritableDatabase() {
+        final SQLiteDatabase db = sugarDb.getWritableDatabase();
+        assertEquals(false, db.isReadOnly());
+    }
+
+    @Test
+    public void testGetDB() {
+        final SQLiteDatabase db = sugarDb.getDB();
+        assertEquals(false, db.isReadOnly());
+    }
+}
diff --git a/example/src/com/example/ClientApp.java b/library/src/test/java/com/orm/app/ClientApp.java
similarity index 93%
rename from example/src/com/example/ClientApp.java
rename to library/src/test/java/com/orm/app/ClientApp.java
index 6e241a9d..e9943aea 100644
--- a/example/src/com/example/ClientApp.java
+++ b/library/src/test/java/com/orm/app/ClientApp.java
@@ -1,9 +1,9 @@
-package com.example;
-
-import com.orm.SugarContext;
+package com.orm.app;
 
 import android.app.Application;
 
+import com.orm.SugarContext;
+
 public class ClientApp extends Application {
 
     @Override
@@ -17,5 +17,4 @@ public void onTerminate() {
         super.onTerminate();
         SugarContext.terminate();
     }
-
 }
diff --git a/library/src/test/java/com/orm/helper/ManifestHelperTest.java b/library/src/test/java/com/orm/helper/ManifestHelperTest.java
new file mode 100644
index 00000000..2fad344c
--- /dev/null
+++ b/library/src/test/java/com/orm/helper/ManifestHelperTest.java
@@ -0,0 +1,60 @@
+package com.orm.helper;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.util.KeyWordUtil;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import static com.orm.helper.ManifestHelper.getDatabaseName;
+import static com.orm.helper.ManifestHelper.getDatabaseVersion;
+import static com.orm.helper.ManifestHelper.getDomainPackageName;
+import static com.orm.helper.ManifestHelper.isDebugEnabled;
+import static com.orm.helper.ManifestHelper.DATABASE_DEFAULT_NAME;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ManifestHelperTest {
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        ManifestHelper helper = ManifestHelper.class.getDeclaredConstructor().newInstance();
+        assertNull(helper);
+    }
+
+
+    @Test
+    public void testGetDbName() {
+        assertEquals(DATABASE_DEFAULT_NAME, getDatabaseName());
+    }
+
+    @Test
+    public void testGetDatabaseName() {
+        assertEquals(DATABASE_DEFAULT_NAME, getDatabaseName());
+    }
+
+    @Test
+    public void testGetDatabaseVersion() {
+        assertEquals(1, getDatabaseVersion());
+    }
+
+    @Test
+    public void testGetDomainPackageName() {
+        assertNotNull(getDomainPackageName());
+    }
+
+    @Test
+    public void testGetDebugEnabled() {
+        assertEquals(false, isDebugEnabled());
+    }
+}
diff --git a/library/src/test/java/com/orm/helper/NamingHelperTest.java b/library/src/test/java/com/orm/helper/NamingHelperTest.java
new file mode 100644
index 00000000..d53769ad
--- /dev/null
+++ b/library/src/test/java/com/orm/helper/NamingHelperTest.java
@@ -0,0 +1,90 @@
+package com.orm.helper;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.TestRecord;
+import com.orm.util.ReflectionUtil;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.orm.helper.NamingHelper.*;
+import static junit.framework.Assert.*;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NamingHelperTest {
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        NamingHelper helper = NamingHelper.class.getDeclaredConstructor().newInstance();
+        assertNull(helper);
+    }
+
+    @Test
+    public void testToSQLNameFromField() {
+        List<Field> fieldList = ReflectionUtil.getTableFields(TestRecord.class);
+
+        if (null != fieldList && !fieldList.isEmpty()) {
+            List<String> columnList = new ArrayList<>();
+
+            for(Field field: fieldList) {
+                columnList.add(toColumnName(field));
+            }
+
+            boolean isIdInList = inList(columnList, "ID");
+            boolean isNameInList = inList(columnList, "NAME");
+
+            assertTrue(isIdInList);
+            assertTrue(isNameInList);
+        }
+    }
+
+    private boolean inList(List<String> list, String searchValue) {
+        for (String val: list) {
+            if (val.equals(searchValue)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Test
+    public void testToSQLNameFromClass() {
+        assertEquals("TEST_RECORD", toTableName(TestRecord.class));
+    }
+
+    @Test
+    public void testToSQLNameCaseConversion() throws Exception {
+        assertToSqlNameEquals("TESTLOWERCASE", "testlowercase");
+        assertToSqlNameEquals("TESTUPPERCASE", "TESTUPPERCASE");
+    }
+
+    @Test
+    public void testToSQLNameUnderscore() {
+        assertToSqlNameEquals("TEST_UNDERSCORE", "testUnderscore");
+        assertToSqlNameEquals("AB_CD", "AbCd");
+        assertToSqlNameEquals("AB_CD", "ABCd");
+        assertToSqlNameEquals("AB_CD", "AbCD");
+        assertToSqlNameEquals("SOME_DETAILS_OBJECT", "SomeDetailsObject");
+        assertToSqlNameEquals("H_OL_A","hOlA");
+        assertToSqlNameEquals("A","a");
+    }
+
+    /**
+     * Helper method that asserts a CamelCaseString is converted to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param expected  a CamelCaseString
+     * @param actual    the expected UPPER_CASE_UNDER_SCORE string
+     */
+    private static void assertToSqlNameEquals(String expected, String actual) {
+        assertEquals(expected, toSQLNameDefault(actual));
+    }
+
+}
diff --git a/library/src/test/java/com/orm/helper/SugarTransactionHelperTest.java b/library/src/test/java/com/orm/helper/SugarTransactionHelperTest.java
new file mode 100644
index 00000000..1fe73708
--- /dev/null
+++ b/library/src/test/java/com/orm/helper/SugarTransactionHelperTest.java
@@ -0,0 +1,84 @@
+package com.orm.helper;
+
+import com.orm.app.ClientApp;
+import com.orm.SugarContext;
+import com.orm.dsl.BuildConfig;
+import com.orm.helper.SugarTransactionHelper;
+import com.orm.model.TestRecord;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNull;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SugarTransactionHelperTest {
+    private List<TestRecord> recordList = new ArrayList<>();
+    private TestRecord record1 = new TestRecord();
+    private TestRecord record2 = new TestRecord();
+    private TestRecord record3 = new TestRecord();
+
+    @Before
+    public void setUp() {
+        SugarContext.init(RuntimeEnvironment.application);
+
+        record1.setId(1L);
+        record1.setName("lala");
+
+        record2.setId(2L);
+        record2.setName("fefe");
+
+        record3.setId(3L);
+        record3.setName("jaja");
+
+        recordList.add(record1);
+        recordList.add(record2);
+        recordList.add(record3);
+    }
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        SugarTransactionHelper helper = SugarTransactionHelper.class.getDeclaredConstructor().newInstance();
+        assertNull(helper);
+    }
+
+    @Test
+    public void testDoInTransaction() {
+        SugarTransactionHelper.doInTransaction(new SugarTransactionHelper.Callback() {
+            @Override
+            public void manipulateInTransaction() {
+                for (TestRecord record: recordList) {
+                    TestRecord.save(record);
+                }
+            }
+        });
+
+        final List<TestRecord> results = TestRecord.listAll(TestRecord.class);
+
+        assertEquals(true, inList(results, record1));
+        assertEquals(true, inList(results, record2));
+        assertEquals(true, inList(results, record3));
+    }
+
+    private boolean inList(List<TestRecord> list, TestRecord testRecord) {
+        for (TestRecord record: list) {
+            if (record.getId().equals(testRecord.getId()) &&
+                record.getName().equals(testRecord.getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/AllAnotatedModel.java b/library/src/test/java/com/orm/model/AllAnotatedModel.java
new file mode 100644
index 00000000..c2fb888d
--- /dev/null
+++ b/library/src/test/java/com/orm/model/AllAnotatedModel.java
@@ -0,0 +1,25 @@
+package com.orm.model;
+
+import com.orm.annotation.Column;
+import com.orm.annotation.Ignore;
+import com.orm.annotation.NotNull;
+import com.orm.annotation.Table;
+import com.orm.annotation.Unique;
+
+/**
+ * @author jonatan.salas
+ */
+@Table
+public class AllAnotatedModel {
+
+    @NotNull @Unique
+    private Long id;
+
+    @Column(notNull = true, name = "name", unique = true)
+    private String name;
+
+    @Ignore
+    private String surname;
+
+    public AllAnotatedModel() { }
+}
diff --git a/library/src/test/java/com/orm/model/BigDecimalFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/BigDecimalFieldAnnotatedModel.java
new file mode 100644
index 00000000..f5529512
--- /dev/null
+++ b/library/src/test/java/com/orm/model/BigDecimalFieldAnnotatedModel.java
@@ -0,0 +1,25 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+import java.math.BigDecimal;
+
+@Table
+public class BigDecimalFieldAnnotatedModel {
+    private BigDecimal decimal;
+    private Long id;
+
+    public BigDecimalFieldAnnotatedModel() {}
+
+    public BigDecimalFieldAnnotatedModel(BigDecimal decimal) {
+        this.decimal = decimal;
+    }
+
+    public BigDecimal getBigDecimal() {
+        return decimal;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/BigDecimalFieldExtendedModel.java b/library/src/test/java/com/orm/model/BigDecimalFieldExtendedModel.java
new file mode 100644
index 00000000..cbcdc3c9
--- /dev/null
+++ b/library/src/test/java/com/orm/model/BigDecimalFieldExtendedModel.java
@@ -0,0 +1,19 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+import java.math.BigDecimal;
+
+public class BigDecimalFieldExtendedModel extends SugarRecord {
+    private BigDecimal decimal;
+
+    public BigDecimalFieldExtendedModel() {}
+
+    public BigDecimalFieldExtendedModel(BigDecimal decimal) {
+        this.decimal = decimal;
+    }
+
+    public BigDecimal getBigDecimal() {
+        return decimal;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/BooleanFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/BooleanFieldAnnotatedModel.java
new file mode 100644
index 00000000..31a8668b
--- /dev/null
+++ b/library/src/test/java/com/orm/model/BooleanFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class BooleanFieldAnnotatedModel {
+    private Boolean objectBoolean;
+    private boolean rawBoolean;
+    private Long id;
+
+    public BooleanFieldAnnotatedModel() {}
+
+    public BooleanFieldAnnotatedModel(Boolean objectBoolean) {
+        this.objectBoolean = objectBoolean;
+    }
+
+    public BooleanFieldAnnotatedModel(boolean rawBoolean) {
+        this.rawBoolean = rawBoolean;
+    }
+
+    public Boolean getBoolean() {
+        return objectBoolean;
+    }
+
+    public boolean getRawBoolean() {
+        return rawBoolean;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/BooleanFieldExtendedModel.java b/library/src/test/java/com/orm/model/BooleanFieldExtendedModel.java
new file mode 100644
index 00000000..0c78c82a
--- /dev/null
+++ b/library/src/test/java/com/orm/model/BooleanFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class BooleanFieldExtendedModel extends SugarRecord {
+    private Boolean objectBoolean;
+    private boolean rawBoolean;
+
+    public BooleanFieldExtendedModel() {}
+
+    public BooleanFieldExtendedModel(Boolean objectBoolean) {
+        this.objectBoolean = objectBoolean;
+    }
+
+    public BooleanFieldExtendedModel(boolean rawBoolean) {
+        this.rawBoolean = rawBoolean;
+    }
+
+    public Boolean getBoolean() {
+        return objectBoolean;
+    }
+
+    public boolean getRawBoolean() {
+        return rawBoolean;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/ByteArrayAnnotatedModel.java b/library/src/test/java/com/orm/model/ByteArrayAnnotatedModel.java
new file mode 100644
index 00000000..4a9f809c
--- /dev/null
+++ b/library/src/test/java/com/orm/model/ByteArrayAnnotatedModel.java
@@ -0,0 +1,23 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class ByteArrayAnnotatedModel {
+    private byte[] byteArray;
+    private Long id;
+
+    public ByteArrayAnnotatedModel() {}
+
+    public ByteArrayAnnotatedModel(byte[] byteArray) {
+        this.byteArray = byteArray;
+    }
+
+    public byte[] getByteArray() {
+        return byteArray;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/ByteArrayExtendedModel.java b/library/src/test/java/com/orm/model/ByteArrayExtendedModel.java
new file mode 100644
index 00000000..7e40208d
--- /dev/null
+++ b/library/src/test/java/com/orm/model/ByteArrayExtendedModel.java
@@ -0,0 +1,17 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class ByteArrayExtendedModel extends SugarRecord {
+    private byte[] byteArray;
+
+    public ByteArrayExtendedModel() {}
+
+    public ByteArrayExtendedModel(byte[] byteArray) {
+        this.byteArray = byteArray;
+    }
+
+    public byte[] getByteArray() {
+        return byteArray;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/DoubleFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/DoubleFieldAnnotatedModel.java
new file mode 100644
index 00000000..2c13e075
--- /dev/null
+++ b/library/src/test/java/com/orm/model/DoubleFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class DoubleFieldAnnotatedModel {
+    private Double objectDouble;
+    private double rawDouble;
+    private Long id;
+
+    public DoubleFieldAnnotatedModel() {}
+
+    public DoubleFieldAnnotatedModel(Double objectDouble) {
+        this.objectDouble = objectDouble;
+    }
+
+    public DoubleFieldAnnotatedModel(double rawDouble) {
+        this.rawDouble = rawDouble;
+    }
+
+    public Double getDouble() {
+        return objectDouble;
+    }
+
+    public double getRawDouble() {
+        return rawDouble;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/DoubleFieldExtendedModel.java b/library/src/test/java/com/orm/model/DoubleFieldExtendedModel.java
new file mode 100644
index 00000000..1a000c3c
--- /dev/null
+++ b/library/src/test/java/com/orm/model/DoubleFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class DoubleFieldExtendedModel extends SugarRecord {
+    private Double objectDouble;
+    private double rawDouble;
+
+    public DoubleFieldExtendedModel() {}
+
+    public DoubleFieldExtendedModel(Double objectDouble) {
+        this.objectDouble = objectDouble;
+    }
+
+    public DoubleFieldExtendedModel(double rawDouble) {
+        this.rawDouble = rawDouble;
+    }
+
+    public Double getDouble() {
+        return objectDouble;
+    }
+
+    public double getRawDouble() {
+        return rawDouble;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/EmptyModel.java b/library/src/test/java/com/orm/model/EmptyModel.java
new file mode 100644
index 00000000..a98ab5e2
--- /dev/null
+++ b/library/src/test/java/com/orm/model/EmptyModel.java
@@ -0,0 +1,10 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class EmptyModel extends SugarRecord {
+    public EmptyModel() { }
+}
diff --git a/library/src/test/java/com/orm/model/EnumFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/EnumFieldAnnotatedModel.java
new file mode 100644
index 00000000..abb3a63f
--- /dev/null
+++ b/library/src/test/java/com/orm/model/EnumFieldAnnotatedModel.java
@@ -0,0 +1,52 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class EnumFieldAnnotatedModel {
+    public static enum DefaultEnum {
+        ONE, TWO
+    }
+
+    public static enum OverrideEnum {
+        ONE, TWO;
+
+        @Override
+        public String toString() {
+            return super.toString().toLowerCase();
+        }
+    }
+
+    private OverrideEnum overrideEnum;
+    private DefaultEnum defaultEnum;
+    private Long id;
+
+    public EnumFieldAnnotatedModel() {
+
+    }
+
+    public EnumFieldAnnotatedModel(OverrideEnum e1, DefaultEnum d1) {
+        overrideEnum = e1;
+        defaultEnum = d1;
+    }
+
+    public DefaultEnum getDefaultEnum() {
+        return defaultEnum;
+    }
+
+    public void setDefaultEnum(DefaultEnum defaultEnum) {
+        this.defaultEnum = defaultEnum;
+    }
+
+    public void setOverrideEnum(OverrideEnum overrideEnum) {
+        this.overrideEnum = overrideEnum;
+    }
+
+    public OverrideEnum getOverrideEnum() {
+        return overrideEnum;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/EnumFieldExtendedModel.java b/library/src/test/java/com/orm/model/EnumFieldExtendedModel.java
new file mode 100644
index 00000000..24ec7725
--- /dev/null
+++ b/library/src/test/java/com/orm/model/EnumFieldExtendedModel.java
@@ -0,0 +1,46 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class EnumFieldExtendedModel extends SugarRecord {
+    public static enum DefaultEnum {
+        ONE, TWO
+    }
+
+    public static enum OverrideEnum {
+        ONE, TWO;
+
+        @Override
+        public String toString() {
+            return super.toString().toLowerCase();
+        }
+    }
+
+    private OverrideEnum overrideEnum;
+    private DefaultEnum defaultEnum;
+
+    public EnumFieldExtendedModel() {
+
+    }
+
+    public EnumFieldExtendedModel(OverrideEnum e1, DefaultEnum d1) {
+        overrideEnum = e1;
+        defaultEnum = d1;
+    }
+
+    public DefaultEnum getDefaultEnum() {
+        return defaultEnum;
+    }
+
+    public void setDefaultEnum(DefaultEnum defaultEnum) {
+        this.defaultEnum = defaultEnum;
+    }
+
+    public void setOverrideEnum(OverrideEnum overrideEnum) {
+        this.overrideEnum = overrideEnum;
+    }
+
+    public OverrideEnum getOverrideEnum() {
+        return overrideEnum;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/FloatFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/FloatFieldAnnotatedModel.java
new file mode 100644
index 00000000..be2f01f5
--- /dev/null
+++ b/library/src/test/java/com/orm/model/FloatFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class FloatFieldAnnotatedModel {
+    private Float objectFloat;
+    private float rawFloat;
+    private Long id;
+
+    public FloatFieldAnnotatedModel() {}
+
+    public FloatFieldAnnotatedModel(Float objectFloat) {
+        this.objectFloat = objectFloat;
+    }
+
+    public FloatFieldAnnotatedModel(float rawFloat) {
+        this.rawFloat = rawFloat;
+    }
+
+    public Float getFloat() {
+        return objectFloat;
+    }
+
+    public float getRawFloat() {
+        return rawFloat;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/FloatFieldExtendedModel.java b/library/src/test/java/com/orm/model/FloatFieldExtendedModel.java
new file mode 100644
index 00000000..e79f1a4b
--- /dev/null
+++ b/library/src/test/java/com/orm/model/FloatFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class FloatFieldExtendedModel extends SugarRecord {
+    private Float objectFloat;
+    private float rawFloat;
+
+    public FloatFieldExtendedModel() {}
+
+    public FloatFieldExtendedModel(Float objectFloat) {
+        this.objectFloat = objectFloat;
+    }
+
+    public FloatFieldExtendedModel(float rawFloat) {
+        this.rawFloat = rawFloat;
+    }
+
+    public Float getFloat() {
+        return objectFloat;
+    }
+
+    public float getRawFloat() {
+        return rawFloat;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/IncompleteAnnotatedModel.java b/library/src/test/java/com/orm/model/IncompleteAnnotatedModel.java
new file mode 100644
index 00000000..64f8436b
--- /dev/null
+++ b/library/src/test/java/com/orm/model/IncompleteAnnotatedModel.java
@@ -0,0 +1,9 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class IncompleteAnnotatedModel {
+    // An annotated model must provide a Long id field. A setter or getter is optional
+    public IncompleteAnnotatedModel() {}
+}
diff --git a/library/src/test/java/com/orm/model/IntUniqueModel.java b/library/src/test/java/com/orm/model/IntUniqueModel.java
new file mode 100644
index 00000000..7a03e3d0
--- /dev/null
+++ b/library/src/test/java/com/orm/model/IntUniqueModel.java
@@ -0,0 +1,19 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+import com.orm.annotation.Unique;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class IntUniqueModel extends SugarRecord {
+
+    @Unique
+    private int value;
+
+    public IntUniqueModel() { }
+
+    public IntUniqueModel(int value) {
+        this.value = value;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/IntegerFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/IntegerFieldAnnotatedModel.java
new file mode 100644
index 00000000..e486d5db
--- /dev/null
+++ b/library/src/test/java/com/orm/model/IntegerFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class IntegerFieldAnnotatedModel {
+    private Integer integer;
+    private int rawInteger;
+    public Long id;
+
+    public IntegerFieldAnnotatedModel() {}
+
+    public IntegerFieldAnnotatedModel(Integer integer) {
+        this.integer = integer;
+    }
+
+    public IntegerFieldAnnotatedModel(int rawInteger) {
+        this.rawInteger = rawInteger;
+    }
+
+    public Integer getInteger() {
+        return integer;
+    }
+
+    public int getInt() {
+        return rawInteger;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/IntegerFieldExtendedModel.java b/library/src/test/java/com/orm/model/IntegerFieldExtendedModel.java
new file mode 100644
index 00000000..407979a3
--- /dev/null
+++ b/library/src/test/java/com/orm/model/IntegerFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class IntegerFieldExtendedModel extends SugarRecord {
+    private Integer integer;
+    private int rawInteger;
+
+    public IntegerFieldExtendedModel() {}
+
+    public IntegerFieldExtendedModel(Integer integer) {
+        this.integer = integer;
+    }
+
+    public IntegerFieldExtendedModel(int rawInteger) {
+        this.rawInteger = rawInteger;
+    }
+
+    public Integer getInteger() {
+        return integer;
+    }
+
+    public int getInt() {
+        return rawInteger;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/LongFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/LongFieldAnnotatedModel.java
new file mode 100644
index 00000000..7f2cd539
--- /dev/null
+++ b/library/src/test/java/com/orm/model/LongFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class LongFieldAnnotatedModel {
+    private Long objectLong;
+    private long rawLong;
+    private Long id;
+
+    public LongFieldAnnotatedModel() {}
+
+    public LongFieldAnnotatedModel(Long objectLong) {
+        this.objectLong = objectLong;
+    }
+
+    public LongFieldAnnotatedModel(long rawLong) {
+        this.rawLong = rawLong;
+    }
+
+    public Long getLong() {
+        return objectLong;
+    }
+
+    public long getRawLong() {
+        return rawLong;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/LongFieldExtendedModel.java b/library/src/test/java/com/orm/model/LongFieldExtendedModel.java
new file mode 100644
index 00000000..66bc7d6d
--- /dev/null
+++ b/library/src/test/java/com/orm/model/LongFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class LongFieldExtendedModel extends SugarRecord {
+    private Long objectLong;
+    private long rawLong;
+
+    public LongFieldExtendedModel() {}
+
+    public LongFieldExtendedModel(Long objectLong) {
+        this.objectLong = objectLong;
+    }
+
+    public LongFieldExtendedModel(long rawLong) {
+        this.rawLong = rawLong;
+    }
+
+    public Long getLong() {
+        return objectLong;
+    }
+
+    public long getRawLong() {
+        return rawLong;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/MultiColumnUniqueModel.java b/library/src/test/java/com/orm/model/MultiColumnUniqueModel.java
new file mode 100644
index 00000000..cea9cd92
--- /dev/null
+++ b/library/src/test/java/com/orm/model/MultiColumnUniqueModel.java
@@ -0,0 +1,21 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+import com.orm.annotation.MultiUnique;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+@MultiUnique("a, b")
+public class MultiColumnUniqueModel extends SugarRecord {
+
+    private int a;
+    private int b;
+
+    public MultiColumnUniqueModel() { }
+
+    public MultiColumnUniqueModel(int a, int b) {
+        this.a = a;
+        this.b = b;
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/model/NestedAnnotatedModel.java b/library/src/test/java/com/orm/model/NestedAnnotatedModel.java
new file mode 100644
index 00000000..f57b2d7a
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedAnnotatedModel.java
@@ -0,0 +1,23 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class NestedAnnotatedModel {
+    private RelationshipAnnotatedModel nested;
+    private Long id;
+
+    public NestedAnnotatedModel() {}
+
+    public NestedAnnotatedModel(RelationshipAnnotatedModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipAnnotatedModel getNested() {
+        return nested;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NestedExtendedModel.java b/library/src/test/java/com/orm/model/NestedExtendedModel.java
new file mode 100644
index 00000000..0b583d95
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedExtendedModel.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+
+import com.orm.SugarRecord;
+
+public class NestedExtendedModel extends SugarRecord {
+    private RelationshipExtendedModel nested;
+
+    public NestedExtendedModel() {}
+
+    public NestedExtendedModel(RelationshipExtendedModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipExtendedModel getNested() {
+        return nested;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NestedMixedAAModel.java b/library/src/test/java/com/orm/model/NestedMixedAAModel.java
new file mode 100644
index 00000000..a96500f5
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedMixedAAModel.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+
+import com.orm.SugarRecord;
+
+public class NestedMixedAAModel extends SugarRecord {
+    private RelationshipMixedAModel nested;
+
+    public NestedMixedAAModel() {}
+
+    public NestedMixedAAModel(RelationshipMixedAModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipMixedAModel getNested() {
+        return nested;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NestedMixedABModel.java b/library/src/test/java/com/orm/model/NestedMixedABModel.java
new file mode 100644
index 00000000..2cbae3db
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedMixedABModel.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+
+import com.orm.SugarRecord;
+
+public class NestedMixedABModel extends SugarRecord {
+    private RelationshipMixedBModel nested;
+
+    public NestedMixedABModel() {}
+
+    public NestedMixedABModel(RelationshipMixedBModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipMixedBModel getNested() {
+        return nested;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NestedMixedBAModel.java b/library/src/test/java/com/orm/model/NestedMixedBAModel.java
new file mode 100644
index 00000000..82de9717
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedMixedBAModel.java
@@ -0,0 +1,24 @@
+package com.orm.model;
+
+
+import com.orm.annotation.Table;
+
+@Table
+public class NestedMixedBAModel {
+    private RelationshipMixedAModel nested;
+    private Long id;
+
+    public NestedMixedBAModel() {}
+
+    public NestedMixedBAModel(RelationshipMixedAModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipMixedAModel getNested() {
+        return nested;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NestedMixedBBModel.java b/library/src/test/java/com/orm/model/NestedMixedBBModel.java
new file mode 100644
index 00000000..6a208b5b
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NestedMixedBBModel.java
@@ -0,0 +1,24 @@
+package com.orm.model;
+
+
+import com.orm.annotation.Table;
+
+@Table
+public class NestedMixedBBModel {
+    private RelationshipMixedBModel nested;
+    private Long id;
+
+    public NestedMixedBBModel() {}
+
+    public NestedMixedBBModel(RelationshipMixedBModel nested) {
+        this.nested = nested;
+    }
+
+    public RelationshipMixedBModel getNested() {
+        return nested;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/NoSugarModel.java b/library/src/test/java/com/orm/model/NoSugarModel.java
new file mode 100644
index 00000000..617a99c4
--- /dev/null
+++ b/library/src/test/java/com/orm/model/NoSugarModel.java
@@ -0,0 +1,7 @@
+package com.orm.model;
+
+
+public class NoSugarModel {
+    public NoSugarModel() {
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/model/RelationshipAnnotatedModel.java b/library/src/test/java/com/orm/model/RelationshipAnnotatedModel.java
new file mode 100644
index 00000000..42b9a4d9
--- /dev/null
+++ b/library/src/test/java/com/orm/model/RelationshipAnnotatedModel.java
@@ -0,0 +1,23 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class RelationshipAnnotatedModel {
+    private SimpleAnnotatedModel simple;
+    private Long id;
+
+    public RelationshipAnnotatedModel() {}
+
+    public RelationshipAnnotatedModel(SimpleAnnotatedModel simple) {
+        this.simple = simple;
+    }
+
+    public SimpleAnnotatedModel getSimple() {
+        return simple;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/RelationshipExtendedModel.java b/library/src/test/java/com/orm/model/RelationshipExtendedModel.java
new file mode 100644
index 00000000..1e4e99bc
--- /dev/null
+++ b/library/src/test/java/com/orm/model/RelationshipExtendedModel.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+
+import com.orm.SugarRecord;
+
+public class RelationshipExtendedModel extends SugarRecord {
+    private SimpleExtendedModel simple;
+
+    public RelationshipExtendedModel() {}
+
+    public RelationshipExtendedModel(SimpleExtendedModel simple) {
+        this.simple = simple;
+    }
+
+    public SimpleExtendedModel getSimple() {
+        return simple;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/RelationshipMixedAModel.java b/library/src/test/java/com/orm/model/RelationshipMixedAModel.java
new file mode 100644
index 00000000..1afa4a82
--- /dev/null
+++ b/library/src/test/java/com/orm/model/RelationshipMixedAModel.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+
+import com.orm.SugarRecord;
+
+public class RelationshipMixedAModel extends SugarRecord {
+    private SimpleAnnotatedModel simple;
+
+    public RelationshipMixedAModel() {}
+
+    public RelationshipMixedAModel(SimpleAnnotatedModel simple) {
+        this.simple = simple;
+    }
+
+    public SimpleAnnotatedModel getSimple() {
+        return simple;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/RelationshipMixedBModel.java b/library/src/test/java/com/orm/model/RelationshipMixedBModel.java
new file mode 100644
index 00000000..2197e62f
--- /dev/null
+++ b/library/src/test/java/com/orm/model/RelationshipMixedBModel.java
@@ -0,0 +1,24 @@
+package com.orm.model;
+
+
+import com.orm.annotation.Table;
+
+@Table
+public class RelationshipMixedBModel {
+    private SimpleExtendedModel simple;
+    private Long id;
+
+    public RelationshipMixedBModel() {}
+
+    public RelationshipMixedBModel(SimpleExtendedModel simple) {
+        this.simple = simple;
+    }
+
+    public SimpleExtendedModel getSimple() {
+        return simple;
+    }
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/ShortFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/ShortFieldAnnotatedModel.java
new file mode 100644
index 00000000..fea8e58e
--- /dev/null
+++ b/library/src/test/java/com/orm/model/ShortFieldAnnotatedModel.java
@@ -0,0 +1,28 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class ShortFieldAnnotatedModel {
+    private Short objectShort;
+    private short rawShort;
+    private Long id;
+
+    public ShortFieldAnnotatedModel() {}
+
+    public ShortFieldAnnotatedModel(Short objectShort) {
+        this.objectShort = objectShort;
+    }
+
+    public ShortFieldAnnotatedModel(short rawShort) {
+        this.rawShort = rawShort;
+    }
+
+    public Short getShort() {
+        return objectShort;
+    }
+
+    public short getRawShort() {
+        return rawShort;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/ShortFieldExtendedModel.java b/library/src/test/java/com/orm/model/ShortFieldExtendedModel.java
new file mode 100644
index 00000000..5e90b9f6
--- /dev/null
+++ b/library/src/test/java/com/orm/model/ShortFieldExtendedModel.java
@@ -0,0 +1,26 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class ShortFieldExtendedModel extends SugarRecord {
+    private Short objectShort;
+    private short rawShort;
+
+    public ShortFieldExtendedModel() {}
+
+    public ShortFieldExtendedModel(Short objectShort) {
+        this.objectShort = objectShort;
+    }
+
+    public ShortFieldExtendedModel(short rawShort) {
+        this.rawShort = rawShort;
+    }
+
+    public Short getShort() {
+        return objectShort;
+    }
+
+    public short getRawShort() {
+        return rawShort;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/SimpleAnnotatedModel.java b/library/src/test/java/com/orm/model/SimpleAnnotatedModel.java
new file mode 100644
index 00000000..918840ed
--- /dev/null
+++ b/library/src/test/java/com/orm/model/SimpleAnnotatedModel.java
@@ -0,0 +1,15 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+
+@Table
+public class SimpleAnnotatedModel {
+    private Long id;
+
+    public SimpleAnnotatedModel() {}
+
+    public Long getId() {
+        return id;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/SimpleExtendedModel.java b/library/src/test/java/com/orm/model/SimpleExtendedModel.java
new file mode 100644
index 00000000..9040145d
--- /dev/null
+++ b/library/src/test/java/com/orm/model/SimpleExtendedModel.java
@@ -0,0 +1,8 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+
+public class SimpleExtendedModel extends SugarRecord {
+    public SimpleExtendedModel() {}
+}
diff --git a/library/src/test/java/com/orm/model/SimpleModel.java b/library/src/test/java/com/orm/model/SimpleModel.java
new file mode 100644
index 00000000..b2659084
--- /dev/null
+++ b/library/src/test/java/com/orm/model/SimpleModel.java
@@ -0,0 +1,33 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class SimpleModel extends SugarRecord {
+    private String str;
+    private int integer;
+    private boolean bool;
+
+    public String getStr() {
+        return str;
+    }
+
+    public void setStr(String str) {
+        this.str = str;
+    }
+
+    public int getInteger() {
+        return integer;
+    }
+
+    public void setInteger(int integer) {
+        this.integer = integer;
+    }
+
+    public boolean isBool() {
+        return bool;
+    }
+
+    public void setBool(boolean bool) {
+        this.bool = bool;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/StringFieldAnnotatedModel.java b/library/src/test/java/com/orm/model/StringFieldAnnotatedModel.java
new file mode 100644
index 00000000..e3220278
--- /dev/null
+++ b/library/src/test/java/com/orm/model/StringFieldAnnotatedModel.java
@@ -0,0 +1,23 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class StringFieldAnnotatedModel {
+    private String string;
+    private Long id;
+
+    public StringFieldAnnotatedModel() {}
+
+    public StringFieldAnnotatedModel(String string) {
+        this.string = string;
+    }
+
+    public String getString() {
+        return string;
+    }
+
+    public void setString(String string) {
+        this.string = string;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/StringFieldAnnotatedNoIdModel.java b/library/src/test/java/com/orm/model/StringFieldAnnotatedNoIdModel.java
new file mode 100644
index 00000000..4b458960
--- /dev/null
+++ b/library/src/test/java/com/orm/model/StringFieldAnnotatedNoIdModel.java
@@ -0,0 +1,22 @@
+package com.orm.model;
+
+import com.orm.annotation.Table;
+
+@Table
+public class StringFieldAnnotatedNoIdModel {
+    private String string;
+
+    public StringFieldAnnotatedNoIdModel() {}
+
+    public StringFieldAnnotatedNoIdModel(String string) {
+        this.string = string;
+    }
+
+    public String getString() {
+        return string;
+    }
+
+    public void setString(String string) {
+        this.string = string;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/StringFieldExtendedModel.java b/library/src/test/java/com/orm/model/StringFieldExtendedModel.java
new file mode 100644
index 00000000..9b79bc61
--- /dev/null
+++ b/library/src/test/java/com/orm/model/StringFieldExtendedModel.java
@@ -0,0 +1,21 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class StringFieldExtendedModel extends SugarRecord {
+    private String string;
+
+    public StringFieldExtendedModel() {}
+
+    public StringFieldExtendedModel(String string) {
+        this.string = string;
+    }
+
+    public String getString() {
+        return string;
+    }
+
+    public void setString(String string) {
+        this.string = string;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/StringFieldExtendedModelAnnotatedColumn.java b/library/src/test/java/com/orm/model/StringFieldExtendedModelAnnotatedColumn.java
new file mode 100644
index 00000000..674d53ba
--- /dev/null
+++ b/library/src/test/java/com/orm/model/StringFieldExtendedModelAnnotatedColumn.java
@@ -0,0 +1,18 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+import com.orm.annotation.Column;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class StringFieldExtendedModelAnnotatedColumn extends SugarRecord {
+    @Column(name="anyName")
+    public String name;
+
+    public StringFieldExtendedModelAnnotatedColumn() { }
+
+    public StringFieldExtendedModelAnnotatedColumn(String name) {
+        this.name = name;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/TestRecord.java b/library/src/test/java/com/orm/model/TestRecord.java
new file mode 100644
index 00000000..64fe7dba
--- /dev/null
+++ b/library/src/test/java/com/orm/model/TestRecord.java
@@ -0,0 +1,21 @@
+package com.orm.model;
+
+import com.orm.SugarRecord;
+
+public class TestRecord extends SugarRecord {
+
+    private String name;
+
+    public TestRecord() {
+        super();
+    }
+
+    public TestRecord setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public String getName() {
+        return name;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/foreignnull/OriginRecord.java b/library/src/test/java/com/orm/model/foreignnull/OriginRecord.java
new file mode 100644
index 00000000..dbcd84bc
--- /dev/null
+++ b/library/src/test/java/com/orm/model/foreignnull/OriginRecord.java
@@ -0,0 +1,20 @@
+package com.orm.model.foreignnull;
+
+import com.orm.annotation.Table;
+
+@Table
+public class OriginRecord {
+
+	private Long id;
+	private OriginRecord origin;
+
+	public OriginRecord() {
+	}
+
+	public OriginRecord(Long id, OriginRecord origin) {
+		this.id = id;
+		this.origin = origin;
+	}
+
+
+}
diff --git a/library/src/test/java/com/orm/model/onetomany/OneToManyModel.java b/library/src/test/java/com/orm/model/onetomany/OneToManyModel.java
new file mode 100644
index 00000000..bb7bd96a
--- /dev/null
+++ b/library/src/test/java/com/orm/model/onetomany/OneToManyModel.java
@@ -0,0 +1,29 @@
+package com.orm.model.onetomany;
+
+import com.orm.SugarRecord;
+import com.orm.annotation.OneToMany;
+
+import java.util.List;
+
+/**
+ * Created by ukasz Wesoowski on 28.07.2016.
+ */
+public class OneToManyModel extends SugarRecord {
+    @OneToMany(targetField = "model")
+    private List<OneToManyRelationModel> models;
+
+    public OneToManyModel() {
+    }
+
+    public OneToManyModel(Long id) {
+        setId(id);
+    }
+
+    public List<OneToManyRelationModel> getModels() {
+        return models;
+    }
+
+    public void setModels(List<OneToManyRelationModel> models) {
+        this.models = models;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/onetomany/OneToManyRelationModel.java b/library/src/test/java/com/orm/model/onetomany/OneToManyRelationModel.java
new file mode 100644
index 00000000..4c17ec56
--- /dev/null
+++ b/library/src/test/java/com/orm/model/onetomany/OneToManyRelationModel.java
@@ -0,0 +1,26 @@
+package com.orm.model.onetomany;
+
+import com.orm.SugarRecord;
+
+/**
+ * Created by ukasz Wesoowski on 28.07.2016.
+ */
+public class OneToManyRelationModel extends SugarRecord {
+    private OneToManyModel model;
+
+    public OneToManyRelationModel() {
+    }
+
+    public OneToManyRelationModel(Long id, OneToManyModel model) {
+        setId(id);
+        this.model = model;
+    }
+
+    public OneToManyModel getModel() {
+        return model;
+    }
+
+    public void setModel(OneToManyModel model) {
+        this.model = model;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationModel.java b/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationModel.java
new file mode 100644
index 00000000..d48e38f0
--- /dev/null
+++ b/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationModel.java
@@ -0,0 +1,27 @@
+package com.orm.model.onetomany;
+
+import com.orm.SugarRecord;
+
+import java.util.List;
+
+/**
+ * Created by ukasz Wesoowski on 27.08.2016.
+ */
+public class WithoutOneToManyAnnotationModel extends SugarRecord {
+    private List<OneToManyRelationModel> models;
+
+    public WithoutOneToManyAnnotationModel() {
+    }
+
+    public WithoutOneToManyAnnotationModel(Long id) {
+        setId(id);
+    }
+
+    public List<OneToManyRelationModel> getModels() {
+        return models;
+    }
+
+    public void setModels(List<OneToManyRelationModel> models) {
+        this.models = models;
+    }
+}
diff --git a/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationRelationModel.java b/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationRelationModel.java
new file mode 100644
index 00000000..34e1eb2a
--- /dev/null
+++ b/library/src/test/java/com/orm/model/onetomany/WithoutOneToManyAnnotationRelationModel.java
@@ -0,0 +1,26 @@
+package com.orm.model.onetomany;
+
+import com.orm.SugarRecord;
+
+/**
+ * Created by ukasz Wesoowski on 27.08.2016.
+ */
+public class WithoutOneToManyAnnotationRelationModel extends SugarRecord {
+    private WithoutOneToManyAnnotationModel model;
+
+    public WithoutOneToManyAnnotationRelationModel() {
+    }
+
+    public WithoutOneToManyAnnotationRelationModel(Long id, WithoutOneToManyAnnotationModel model) {
+        setId(id);
+        this.model = model;
+    }
+
+    public WithoutOneToManyAnnotationModel getModel() {
+        return model;
+    }
+
+    public void setModel(WithoutOneToManyAnnotationModel model) {
+        this.model = model;
+    }
+}
diff --git a/library/src/test/java/com/orm/query/QueryBuilderTests.java b/library/src/test/java/com/orm/query/QueryBuilderTests.java
new file mode 100644
index 00000000..30b220df
--- /dev/null
+++ b/library/src/test/java/com/orm/query/QueryBuilderTests.java
@@ -0,0 +1,30 @@
+package com.orm.query;
+
+import com.orm.util.QueryBuilder;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public final class QueryBuilderTests {
+
+    @Test(expected=RuntimeException.class)
+    public void noArgumentsTest() {
+        QueryBuilder.generatePlaceholders(0);
+    }
+
+    @Test()
+    public void oneArgumentsTest() {
+        assertEquals("?", QueryBuilder.generatePlaceholders(1));
+    }
+
+    @Test
+    public void twoArgumentsTest() {
+        assertEquals("?,?", QueryBuilder.generatePlaceholders(2));
+    }
+
+    @Test
+    public void manyArgumentsTest() {
+        assertEquals("?,?,?,?,?,?,?,?,?,?", QueryBuilder.generatePlaceholders(10));
+    }
+}
diff --git a/library/src/test/java/com/orm/query/SelectTest.java b/library/src/test/java/com/orm/query/SelectTest.java
new file mode 100644
index 00000000..ad0393bd
--- /dev/null
+++ b/library/src/test/java/com/orm/query/SelectTest.java
@@ -0,0 +1,140 @@
+package com.orm.query;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.TestRecord;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SelectTest {
+
+    @Test
+    public void testMergeCondition(){
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  AND prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testWhere(){
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  AND prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void toSqlAllClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .where("foo")
+                .orderBy("doe")
+                .groupBy("john")
+                .limit("5")
+                .offset("10")
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD WHERE foo ORDER BY doe GROUP BY john LIMIT 5 OFFSET 10 ", toSql);
+    }
+
+    @Test
+    public void toSqlNoClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD ", toSql);
+    }
+
+    @Test
+    public void toSqlWhereLimitClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .where("foo")
+                .limit("10")
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD WHERE foo LIMIT 10 ", toSql);
+    }
+
+
+    @Test
+    public void testWhereOr(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  OR prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testAnd(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where.and(Condition.prop("prop").eq(2));
+
+        assertEquals("(test = ? ) AND (prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testOr(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where.or(Condition.prop("prop").eq(2));
+
+        assertEquals("(test = ? ) OR (prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testIsNull() {
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").isNull());
+        assertEquals("(test IS NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq(null));
+        assertEquals("(test IS NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+    }
+
+    @Test
+    public void testIsNotNull() {
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").isNotNull());
+        assertEquals("(test IS NOT NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").notEq(null));
+        assertEquals("(test IS NOT NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/record/BigDecimalFieldTests.java b/library/src/test/java/com/orm/record/BigDecimalFieldTests.java
new file mode 100644
index 00000000..a877a6af
--- /dev/null
+++ b/library/src/test/java/com/orm/record/BigDecimalFieldTests.java
@@ -0,0 +1,59 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.BigDecimalFieldAnnotatedModel;
+import com.orm.model.BigDecimalFieldExtendedModel;
+
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.math.BigDecimal;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class BigDecimalFieldTests {
+    private BigDecimal decimal = new BigDecimal(1234.5678901234567890123456789);
+
+    @Test
+    public void nullBigDecimalExtendedTest() {
+        save(new BigDecimalFieldExtendedModel());
+        BigDecimalFieldExtendedModel model = findById(BigDecimalFieldExtendedModel.class, 1);
+        assertNull(model.getBigDecimal());
+    }
+
+    @Test
+    public void nullBigDecimalAnnotatedTest() {
+        save(new BigDecimalFieldAnnotatedModel());
+        BigDecimalFieldAnnotatedModel model = findById(BigDecimalFieldAnnotatedModel.class, 1);
+        assertNull(model.getBigDecimal());
+    }
+
+    @Test
+    public void bigDecimalExtendedTest() {
+        save(new BigDecimalFieldExtendedModel(decimal));
+        BigDecimalFieldExtendedModel model = findById(BigDecimalFieldExtendedModel.class, 1);
+        assertEquals(decimal, model.getBigDecimal());
+    }
+
+    @Test
+    public void bigDecimalAnnotatedTest() {
+        save(new BigDecimalFieldAnnotatedModel(decimal));
+        BigDecimalFieldAnnotatedModel model = findById(BigDecimalFieldAnnotatedModel.class, 1);
+        assertEquals(decimal, model.getBigDecimal());
+    }
+
+    @After
+    public void after() {
+        decimal = null;
+    }
+}
diff --git a/library/src/test/java/com/orm/record/BooleanFieldTests.java b/library/src/test/java/com/orm/record/BooleanFieldTests.java
new file mode 100644
index 00000000..3a026a48
--- /dev/null
+++ b/library/src/test/java/com/orm/record/BooleanFieldTests.java
@@ -0,0 +1,83 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.BooleanFieldAnnotatedModel;
+import com.orm.model.BooleanFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class BooleanFieldTests {
+
+    @Test
+    public void nullBooleanExtendedTest() {
+        save(new BooleanFieldExtendedModel());
+        BooleanFieldExtendedModel model = findById(BooleanFieldExtendedModel.class, 1);
+        assertNull(model.getBoolean());
+    }
+
+    @Test
+    public void nullRawBooleanExtendedTest() {
+        save(new BooleanFieldExtendedModel());
+        BooleanFieldExtendedModel model = findById(BooleanFieldExtendedModel.class, 1);
+        assertEquals(false, model.getRawBoolean());
+    }
+
+    @Test
+    public void nullBooleanAnnotatedTest() {
+        save(new BooleanFieldAnnotatedModel());
+        BooleanFieldAnnotatedModel model = findById(BooleanFieldAnnotatedModel.class, 1);
+        assertNull(model.getBoolean());
+    }
+
+    @Test
+    public void nullRawBooleanAnnotatedTest() {
+        save(new BooleanFieldAnnotatedModel());
+        BooleanFieldAnnotatedModel model = findById(BooleanFieldAnnotatedModel.class, 1);
+        assertEquals(false, model.getRawBoolean());
+    }
+
+////TODO check this method
+//    @Test
+//    public void objectBooleanExtendedTest() {
+//        save(new BooleanFieldExtendedModel(true));
+//        BooleanFieldExtendedModel model = SugarRecord.findById(BooleanFieldExtendedModel.class, 1);
+//        assertEquals(true, model.getBoolean());
+//    }
+
+    @Test
+    public void rawBooleanExtendedTest() {
+        save(new BooleanFieldExtendedModel(true));
+        BooleanFieldExtendedModel model = findById(BooleanFieldExtendedModel.class, 1);
+        assertEquals(true, model.getRawBoolean());
+    }
+
+//    //TODO check this
+//    @Test
+//    public void objectBooleanAnnotatedTest() {
+//        save(new BooleanFieldAnnotatedModel(true));
+//        BooleanFieldAnnotatedModel model = SugarRecord.findById(BooleanFieldAnnotatedModel.class, 1);
+//
+//        if (null != model) {
+//            assertEquals(true, model.getBoolean());
+//        }
+//    }
+
+    @Test
+    public void rawBooleanAnnotatedTest() {
+        save(new BooleanFieldAnnotatedModel(true));
+        BooleanFieldAnnotatedModel model = findById(BooleanFieldAnnotatedModel.class, 1);
+        assertEquals(true, model.getRawBoolean());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/ByteArrayFieldTests.java b/library/src/test/java/com/orm/record/ByteArrayFieldTests.java
new file mode 100644
index 00000000..450823f2
--- /dev/null
+++ b/library/src/test/java/com/orm/record/ByteArrayFieldTests.java
@@ -0,0 +1,58 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.ByteArrayAnnotatedModel;
+import com.orm.model.ByteArrayExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ByteArrayFieldTests {
+
+    @Test
+    public void nullByteArrayExtendedTest() {
+        byte[] array = "".getBytes();
+        save(new ByteArrayExtendedModel());
+        ByteArrayExtendedModel model = findById(ByteArrayExtendedModel.class, 1);
+        assertEquals(new String(array), new String(model.getByteArray()));
+        assertArrayEquals(array, model.getByteArray());
+    }
+
+    @Test
+    public void nullByteArrayAnnotatedTest() {
+        byte[] array = "".getBytes();
+        save(new ByteArrayAnnotatedModel());
+        ByteArrayAnnotatedModel model = findById(ByteArrayAnnotatedModel.class, 1);
+        assertEquals(new String(array), new String(model.getByteArray()));
+        assertArrayEquals(array, model.getByteArray());
+    }
+
+    @Test
+    public void byteArrayExtendedTest() {
+        byte[] array = "hello".getBytes();
+        save(new ByteArrayExtendedModel(array));
+        ByteArrayExtendedModel model = findById(ByteArrayExtendedModel.class, 1);
+        assertEquals(new String(array), new String(model.getByteArray()));
+        assertArrayEquals(array, model.getByteArray());
+    }
+
+    @Test
+    public void byteArrayAnnotatedTest() {
+        byte[] array = "hello".getBytes();
+        save(new ByteArrayAnnotatedModel(array));
+        ByteArrayAnnotatedModel model = findById(ByteArrayAnnotatedModel.class, 1);
+        assertEquals(new String(array), new String(model.getByteArray()));
+        assertArrayEquals(array, model.getByteArray());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/CursorTests.java b/library/src/test/java/com/orm/record/CursorTests.java
new file mode 100644
index 00000000..a6036a15
--- /dev/null
+++ b/library/src/test/java/com/orm/record/CursorTests.java
@@ -0,0 +1,78 @@
+package com.orm.record;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.database.Cursor;
+import android.os.Build;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CursorAdapter;
+import android.widget.TextView;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.SimpleModel;
+import com.orm.query.Select;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static junit.framework.Assert.assertNotSame;
+import static junit.framework.Assert.assertSame;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class CursorTests {
+
+    @Test
+    public void testColumnNames() {
+        save(new SimpleModel());
+        Cursor c = Select.from(SimpleModel.class).getCursor();
+        for (String col : new String[]{"STR", "INTEGER", "BOOL", "ID"}) {
+            assertNotSame("Missing column for field: " + col, -1, c.getColumnIndex(col));
+        }
+    }
+    @Test
+    public void testSugarCursor() {
+        save(new SimpleModel());
+        Cursor cursor = Select.from(SimpleModel.class).getCursor();
+        assertNotSame("No _id", -1, cursor.getColumnIndex("_id"));
+        assertSame("_id != ID", cursor.getColumnIndex("_id"), cursor.getColumnIndex("ID"));
+    }
+
+    @Test
+    public void testNoColumn() {
+        save(new SimpleModel());
+        Cursor cursor = Select.from(SimpleModel.class).getCursor();
+        assertSame(-1, cursor.getColumnIndex("nonexistent"));
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void testMakeAdapter() {
+        save(new SimpleModel());
+        Cursor c = Select.from(SimpleModel.class).getCursor();
+        CursorAdapter adapter = new CursorAdapter(RuntimeEnvironment.application, c, true) {
+            @Override
+            public View newView(Context context, Cursor cursor, ViewGroup parent) {
+                TextView tv = new TextView(context);
+                String s = cursor.getString(cursor.getColumnIndex("STR"));
+                tv.setText(s);
+                return null;
+            }
+
+            @Override
+            public void bindView(View view, Context context, Cursor cursor) {
+                String s = cursor.getString(cursor.getColumnIndex("STR"));
+                ((TextView) view).setText(s);
+            }
+        };
+
+        Assert.assertNotNull(adapter);
+    }
+}
diff --git a/library/src/test/java/com/orm/record/DoubleFieldTests.java b/library/src/test/java/com/orm/record/DoubleFieldTests.java
new file mode 100644
index 00000000..a05fa3e0
--- /dev/null
+++ b/library/src/test/java/com/orm/record/DoubleFieldTests.java
@@ -0,0 +1,83 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.SugarRecord;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.DoubleFieldAnnotatedModel;
+import com.orm.model.DoubleFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class DoubleFieldTests {
+
+    @Test
+    public void nullDoubleExtendedTest() {
+        save(new DoubleFieldExtendedModel());
+        DoubleFieldExtendedModel model = findById(DoubleFieldExtendedModel.class, 1);
+        assertNull(model.getDouble());
+    }
+
+    @Test
+    public void nullRawDoubleExtendedTest() {
+        save(new DoubleFieldExtendedModel());
+        DoubleFieldExtendedModel model = findById(DoubleFieldExtendedModel.class, 1);
+        assertEquals(0.0, model.getRawDouble(), 0.0000000001);
+    }
+
+    @Test
+    public void nullDoubleAnnotatedTest() {
+        save(new DoubleFieldAnnotatedModel());
+        DoubleFieldAnnotatedModel model = findById(DoubleFieldAnnotatedModel.class, 1);
+        assertNull(model.getDouble());
+    }
+
+    @Test
+    public void nullRawDoubleAnnotatedTest() {
+        save(new DoubleFieldAnnotatedModel());
+        DoubleFieldAnnotatedModel model = findById(DoubleFieldAnnotatedModel.class, 1);
+        assertEquals(0.0, model.getRawDouble(), 0.0000000001);
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void objectDoubleExtendedTest() {
+        Double objectDouble = Double.valueOf(25.0);
+        save(new DoubleFieldExtendedModel(objectDouble));
+        DoubleFieldExtendedModel model = findById(DoubleFieldExtendedModel.class, 1);
+        assertEquals(objectDouble, model.getDouble());
+    }
+
+    @Test
+    public void rawDoubleExtendedTest() {
+        save(new DoubleFieldExtendedModel(25.0));
+        DoubleFieldExtendedModel model = findById(DoubleFieldExtendedModel.class, 1);
+        assertEquals(25.0, model.getRawDouble(), 0.0000000001);
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void objectDoubleAnnotatedTest() {
+        Double objectDouble = Double.valueOf(25.0);
+        save(new DoubleFieldAnnotatedModel(objectDouble));
+        DoubleFieldAnnotatedModel model = findById(DoubleFieldAnnotatedModel.class, 1);
+        assertEquals(objectDouble, model.getDouble());
+    }
+
+    @Test
+    public void rawDoubleAnnotatedTest() {
+        save(new DoubleFieldAnnotatedModel(25.0));
+        DoubleFieldAnnotatedModel model = findById(DoubleFieldAnnotatedModel.class, 1);
+        assertEquals(25.0, model.getRawDouble(), 0.0000000001);
+    }
+}
diff --git a/library/src/test/java/com/orm/record/EnumFieldTests.java b/library/src/test/java/com/orm/record/EnumFieldTests.java
new file mode 100644
index 00000000..42647b00
--- /dev/null
+++ b/library/src/test/java/com/orm/record/EnumFieldTests.java
@@ -0,0 +1,86 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.EnumFieldAnnotatedModel;
+import com.orm.model.EnumFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+import static com.orm.model.EnumFieldExtendedModel.DefaultEnum;
+import static com.orm.model.EnumFieldExtendedModel.OverrideEnum;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class EnumFieldTests {
+
+    @Test
+    public void nullDefaultEnumExtendedTest() {
+        save(new EnumFieldExtendedModel());
+        EnumFieldExtendedModel model = findById(EnumFieldExtendedModel.class, 1);
+        assertNull(model.getDefaultEnum());
+    }
+
+    @Test
+    public void nullOverriddenEnumExtendedTest() {
+        save(new EnumFieldExtendedModel());
+        EnumFieldExtendedModel model = findById(EnumFieldExtendedModel.class, 1);
+        assertNull(model.getOverrideEnum());
+    }
+    @Test
+    public void nullDefaultEnumAnnotatedTest() {
+        save(new EnumFieldAnnotatedModel());
+        EnumFieldAnnotatedModel model = findById(EnumFieldAnnotatedModel.class, 1);
+        assertNull(model.getDefaultEnum());
+    }
+
+    @Test
+    public void nullOverriddenEnumAnnotatedTest() {
+        save(new EnumFieldAnnotatedModel());
+        EnumFieldAnnotatedModel model = findById(EnumFieldAnnotatedModel.class, 1);
+        assertNull(model.getOverrideEnum());
+    }
+
+    @Test
+    public void defaultEnumExtendedTest() {
+        save(new EnumFieldExtendedModel(OverrideEnum.ONE, DefaultEnum.TWO));
+        EnumFieldExtendedModel model = findById(EnumFieldExtendedModel.class, 1);
+        assertNotNull(model);
+        assertEquals(model.getDefaultEnum(), DefaultEnum.TWO);
+    }
+
+    @Test
+    public void overriddenEnumExtendedTest() {
+        save(new EnumFieldExtendedModel(OverrideEnum.ONE, DefaultEnum.TWO));
+        EnumFieldExtendedModel model = findById(EnumFieldExtendedModel.class, 1);
+        assertNotNull(model);
+        assertEquals(model.getOverrideEnum(), OverrideEnum.ONE);
+    }
+
+    @Test
+    public void defaultEnumAnnotatedTest() {
+        save(new EnumFieldAnnotatedModel(EnumFieldAnnotatedModel.OverrideEnum.ONE,
+                EnumFieldAnnotatedModel.DefaultEnum.TWO));
+        EnumFieldAnnotatedModel model = findById(EnumFieldAnnotatedModel.class, 1);
+        assertNotNull(model);
+        assertEquals(model.getDefaultEnum(), EnumFieldAnnotatedModel.DefaultEnum.TWO);
+    }
+
+    @Test
+    public void overriddenEnumAnnotatedTest() {
+        save(new EnumFieldAnnotatedModel(EnumFieldAnnotatedModel.OverrideEnum.ONE,
+                EnumFieldAnnotatedModel.DefaultEnum.TWO));
+        EnumFieldAnnotatedModel model = findById(EnumFieldAnnotatedModel.class, 1);
+        assertNotNull(model);
+        assertEquals(model.getOverrideEnum(), EnumFieldAnnotatedModel.OverrideEnum.ONE);
+    }
+}
diff --git a/library/src/test/java/com/orm/record/FirstAndLastTests.java b/library/src/test/java/com/orm/record/FirstAndLastTests.java
new file mode 100644
index 00000000..1b6db799
--- /dev/null
+++ b/library/src/test/java/com/orm/record/FirstAndLastTests.java
@@ -0,0 +1,199 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.FloatFieldAnnotatedModel;
+import com.orm.model.FloatFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.first;
+import static com.orm.SugarRecord.delete;
+import static com.orm.SugarRecord.findById;
+import static com.orm.SugarRecord.last;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class FirstAndLastTests {
+
+    @Test
+    @SuppressWarnings("all")
+    public void firstExtendedTest() {
+        Float firstObjectFloat = 25F;
+        Float lastObjectFloat = 50F;
+        save(new FloatFieldExtendedModel(firstObjectFloat));
+        save(new FloatFieldExtendedModel(lastObjectFloat));
+        FloatFieldExtendedModel model = first(FloatFieldExtendedModel.class);
+
+        if (null != model) {
+            assertEquals(firstObjectFloat, model.getFloat());
+        }
+    }
+
+    @Test
+    public void firstDeletedRecordExtendedTest() {
+        Float second = 25F;
+
+        save(new FloatFieldExtendedModel(15F));
+        save(new FloatFieldExtendedModel(second));
+        save(new FloatFieldExtendedModel(35F));
+        save(new FloatFieldExtendedModel(45F));
+
+        FloatFieldExtendedModel firstRecord = findById(FloatFieldExtendedModel.class, 1);
+        delete(firstRecord);
+        FloatFieldExtendedModel model = first(FloatFieldExtendedModel.class);
+
+        if (null != model) {
+            assertEquals(second, model.getFloat());
+        }
+    }
+
+    @Test
+    public void lastExtendedTest() {
+        Float last = 50F;
+
+        save(new FloatFieldExtendedModel(25F));
+        save(new FloatFieldExtendedModel(last));
+
+        FloatFieldExtendedModel model = last(FloatFieldExtendedModel.class);
+
+        if (null != model) {
+            assertEquals(last, model.getFloat());
+        }
+    }
+
+    @Test
+    public void lastDeletedRecordExtendedTest() {
+        Float third = 35F;
+
+        save(new FloatFieldExtendedModel(15F));
+        save(new FloatFieldExtendedModel(25F));
+        save(new FloatFieldExtendedModel(third));
+        save(new FloatFieldExtendedModel(45F));
+
+        FloatFieldExtendedModel lastRecord = findById(FloatFieldExtendedModel.class, 4);
+        delete(lastRecord);
+        FloatFieldExtendedModel model = last(FloatFieldExtendedModel.class);
+
+        if (null != model) {
+            assertEquals(third, model.getFloat());
+        }
+    }
+
+    @Test
+    public void nullFirstExtendedTest() {
+        assertNull(first(FloatFieldExtendedModel.class));
+    }
+
+    @Test
+    public void nullLastExtendedTest() {
+        assertNull(last(FloatFieldExtendedModel.class));
+    }
+
+    @Test
+    public void oneItemExtendedTest() {
+        save(new FloatFieldExtendedModel(25F));
+
+        FloatFieldExtendedModel firstModel = first(FloatFieldExtendedModel.class);
+        FloatFieldExtendedModel lastModel = last(FloatFieldExtendedModel.class);
+
+        if (null != firstModel && null != lastModel) {
+            assertEquals(firstModel.getFloat(), lastModel.getFloat());
+        }
+    }
+
+    @Test
+    public void firstAnnotatedTest() {
+        Float first = 25F;
+
+        save(new FloatFieldAnnotatedModel(first));
+        save(new FloatFieldAnnotatedModel(50F));
+
+        FloatFieldAnnotatedModel model = first(FloatFieldAnnotatedModel.class);
+
+        if (null != model) {
+            assertEquals(first, model.getFloat());
+        }
+    }
+
+    @Test
+    public void firstDeletedRecordAnnotatedTest() {
+        Float second = 25F;
+
+        save(new FloatFieldAnnotatedModel(15F));
+        save(new FloatFieldAnnotatedModel(second));
+        save(new FloatFieldAnnotatedModel(35F));
+        save(new FloatFieldAnnotatedModel(45F));
+
+        FloatFieldAnnotatedModel firstRecord = findById(FloatFieldAnnotatedModel.class, 1);
+
+        delete(firstRecord);
+
+        FloatFieldAnnotatedModel model = first(FloatFieldAnnotatedModel.class);
+
+        if (null != model) {
+            assertEquals(second, model.getFloat());
+        }
+    }
+
+    @Test
+    public void lastAnnotatedTest() {
+        Float last = 50F;
+
+        save(new FloatFieldAnnotatedModel(25F));
+        save(new FloatFieldAnnotatedModel(last));
+
+        FloatFieldAnnotatedModel model = last(FloatFieldAnnotatedModel.class);
+
+        if (null != model) {
+            assertEquals(last, model.getFloat());
+        }
+    }
+
+    @Test
+    public void lastDeletedRecordAnnotatedTest() {
+        Float third = 35F;
+
+        save(new FloatFieldAnnotatedModel(15F));
+        save(new FloatFieldAnnotatedModel(25F));
+        save(new FloatFieldAnnotatedModel(third));
+        save(new FloatFieldAnnotatedModel(45F));
+
+        FloatFieldAnnotatedModel lastRecord = findById(FloatFieldAnnotatedModel.class, 4);
+        delete(lastRecord);
+        FloatFieldAnnotatedModel model = last(FloatFieldAnnotatedModel.class);
+
+        if (null != model) {
+            assertEquals(third, model.getFloat());
+        }
+    }
+
+    @Test
+    public void nullFirstAnnotatedTest() {
+        assertNull(first(FloatFieldAnnotatedModel.class));
+    }
+
+    @Test
+    public void nullLastAnnotatedTest() {
+        assertNull(last(FloatFieldAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneItemAnnotatedTest() {
+        save(new FloatFieldAnnotatedModel(25F));
+
+        FloatFieldAnnotatedModel first = first(FloatFieldAnnotatedModel.class);
+        FloatFieldAnnotatedModel last = last(FloatFieldAnnotatedModel.class);
+
+        if (null != first && null != last) {
+            assertEquals(first.getFloat(), last.getFloat());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/FloatFieldTests.java b/library/src/test/java/com/orm/record/FloatFieldTests.java
new file mode 100644
index 00000000..d76516b9
--- /dev/null
+++ b/library/src/test/java/com/orm/record/FloatFieldTests.java
@@ -0,0 +1,80 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.FloatFieldAnnotatedModel;
+import com.orm.model.FloatFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@SuppressWarnings("all")
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class FloatFieldTests {
+    Float aFloat = Float.valueOf(25F);
+
+    @Test
+    public void nullFloatExtendedTest() {
+        save(new FloatFieldExtendedModel());
+        FloatFieldExtendedModel model = findById(FloatFieldExtendedModel.class, 1);
+        assertNull(model.getFloat());
+    }
+
+    @Test
+    public void nullRawFloatExtendedTest() {
+        save(new FloatFieldExtendedModel());
+        FloatFieldExtendedModel model = findById(FloatFieldExtendedModel.class, 1);
+        assertEquals(0F, model.getRawFloat(), 0.0000000001F);
+    }
+
+    @Test
+    public void nullFloatAnnotatedTest() {
+        save(new FloatFieldAnnotatedModel());
+        FloatFieldAnnotatedModel model = findById(FloatFieldAnnotatedModel.class, 1);
+        assertNull(model.getFloat());
+    }
+
+    @Test
+    public void nullRawFloatAnnotatedTest() {
+        save(new FloatFieldAnnotatedModel());
+        FloatFieldAnnotatedModel model = findById(FloatFieldAnnotatedModel.class, 1);
+        assertEquals(0F, model.getRawFloat(), 0.0000000001F);
+    }
+
+    @Test
+    public void objectFloatExtendedTest() {
+        save(new FloatFieldExtendedModel(aFloat));
+        FloatFieldExtendedModel model = findById(FloatFieldExtendedModel.class, 1);
+        assertEquals(aFloat, model.getFloat());
+    }
+
+    @Test
+    public void rawFloatExtendedTest() {
+        save(new FloatFieldExtendedModel(aFloat.floatValue()));
+        FloatFieldExtendedModel model = findById(FloatFieldExtendedModel.class, 1);
+        assertEquals(aFloat.floatValue(), model.getRawFloat(), 0.0000000001F);
+    }
+
+    @Test
+    public void objectFloatAnnotatedTest() {
+        save(new FloatFieldAnnotatedModel(aFloat));
+        FloatFieldAnnotatedModel model = findById(FloatFieldAnnotatedModel.class, 1);
+        assertEquals(aFloat, model.getFloat());
+    }
+
+    @Test
+    public void rawFloatAnnotatedTest() {
+        save(new FloatFieldAnnotatedModel(aFloat.floatValue()));
+        FloatFieldAnnotatedModel model = findById(FloatFieldAnnotatedModel.class, 1);
+        assertEquals(aFloat.floatValue(), model.getRawFloat(), 0.0000000001F);
+    }
+}
diff --git a/library/src/test/java/com/orm/record/IncompleteAnnotatedModelTests.java b/library/src/test/java/com/orm/record/IncompleteAnnotatedModelTests.java
new file mode 100644
index 00000000..0053ed96
--- /dev/null
+++ b/library/src/test/java/com/orm/record/IncompleteAnnotatedModelTests.java
@@ -0,0 +1,32 @@
+package com.orm.record;
+
+import android.database.sqlite.SQLiteException;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.IncompleteAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.delete;
+import static com.orm.SugarRecord.save;
+
+import static org.junit.Assert.assertFalse;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class IncompleteAnnotatedModelTests {
+
+    @Test(expected = SQLiteException.class)
+    public void saveNoIdFieldTest() {
+        save(new IncompleteAnnotatedModel());
+    }
+
+    @Test
+    public void deleteNoIdFieldTest() {
+        assertFalse(delete(new IncompleteAnnotatedModel()));
+    }
+}
diff --git a/library/src/test/java/com/orm/record/IntegerFieldTests.java b/library/src/test/java/com/orm/record/IntegerFieldTests.java
new file mode 100644
index 00000000..faf5fa84
--- /dev/null
+++ b/library/src/test/java/com/orm/record/IntegerFieldTests.java
@@ -0,0 +1,107 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.IntegerFieldAnnotatedModel;
+import com.orm.model.IntegerFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.findById;
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.sum;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class IntegerFieldTests {
+    private Integer integer = 25;
+
+    @Test
+    public void nullIntegerExtendedTest() {
+        save(new IntegerFieldExtendedModel());
+        IntegerFieldExtendedModel model = findById(IntegerFieldExtendedModel.class, 1);
+        assertNull(model.getInteger());
+    }
+
+    @Test
+    public void nullIntExtendedTest() {
+        save(new IntegerFieldExtendedModel());
+        IntegerFieldExtendedModel model = findById(IntegerFieldExtendedModel.class, 1);
+        assertEquals(0, model.getInt());
+    }
+
+    @Test
+    public void nullIntegerAnnotatedTest() {
+        save(new IntegerFieldAnnotatedModel());
+        IntegerFieldAnnotatedModel model = findById(IntegerFieldAnnotatedModel.class, 1);
+        assertNull(model.getInteger());
+    }
+
+    @Test
+    public void nullIntAnnotatedTest() {
+        save(new IntegerFieldAnnotatedModel());
+        IntegerFieldAnnotatedModel model = findById(IntegerFieldAnnotatedModel.class, 1);
+        assertEquals(0, model.getInt());
+    }
+
+    @Test
+    public void integerExtendedTest() {
+        save(new IntegerFieldExtendedModel(integer));
+        IntegerFieldExtendedModel model = findById(IntegerFieldExtendedModel.class, 1);
+        assertEquals(integer, model.getInteger());
+    }
+
+    @Test
+    public void intExtendedTest() {
+        save(new IntegerFieldExtendedModel(integer.intValue()));
+        IntegerFieldExtendedModel model = findById(IntegerFieldExtendedModel.class, 1);
+        assertEquals(integer.intValue(), model.getInt());
+    }
+
+    @Test
+    public void integerAnnotatedTest() {
+        save(new IntegerFieldAnnotatedModel(integer));
+        IntegerFieldAnnotatedModel model = findById(IntegerFieldAnnotatedModel.class, 1);
+        assertEquals(integer, model.getInteger());
+    }
+
+    @Test
+    public void intAnnotatedTest() {
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        IntegerFieldAnnotatedModel model = findById(IntegerFieldAnnotatedModel.class, 1);
+        assertEquals(integer.intValue(), model.getInt());
+    }
+
+
+    @Test
+    public void sumTest() {
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        assertEquals(2 * integer, sum(IntegerFieldAnnotatedModel.class, "raw_integer"));
+    }
+
+    @Test
+    public void whereSumTest() {
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        assertEquals((long) integer, sum(IntegerFieldAnnotatedModel.class,
+                "raw_integer", "id = ?", "1"));
+    }
+
+    @Test
+    public void noSumTest() {
+        assertEquals(0, sum(IntegerFieldAnnotatedModel.class, "raw_integer"));
+    }
+
+    @Test
+    public void brokenSumTest() {
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        save(new IntegerFieldAnnotatedModel(integer.intValue()));
+        assertEquals(-1, sum(IntegerFieldAnnotatedModel.class, "wrongfield"));
+    }
+}
diff --git a/library/src/test/java/com/orm/record/ListAllOrderByTests.java b/library/src/test/java/com/orm/record/ListAllOrderByTests.java
new file mode 100644
index 00000000..548ead23
--- /dev/null
+++ b/library/src/test/java/com/orm/record/ListAllOrderByTests.java
@@ -0,0 +1,62 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.IntegerFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ListAllOrderByTests {
+
+    @Test
+    public void listAllOrderByEmptyTest() {
+        final List<IntegerFieldExtendedModel> list = listAll(IntegerFieldExtendedModel.class, "id");
+        assertEquals(0L, list.size());
+    }
+
+    @Test
+    public void listAllOrderByIdTest() {
+        for (int i = 1; i <= 100; i++) {
+            save(new IntegerFieldExtendedModel(i));
+        }
+
+        List<IntegerFieldExtendedModel> models = listAll(IntegerFieldExtendedModel.class, "id");
+        assertEquals(100L, models.size());
+
+        Long id = models.get(0).getId();
+
+        for (int i = 1; i < 100; i++) {
+            assertTrue(id < models.get(i).getId());
+        }
+    }
+
+    @Test
+    public void listAllOrderByFieldTest() {
+        for (int i = 1; i <= 100; i++) {
+            save(new IntegerFieldExtendedModel(i));
+        }
+
+        List<IntegerFieldExtendedModel> models = listAll(IntegerFieldExtendedModel.class, "raw_integer");
+
+        assertEquals(100L, models.size());
+
+        int raw = models.get(0).getInt();
+
+        for (int i = 1; i < 100; i++) {
+            assertTrue(raw < models.get(i).getInt());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/LongFieldTests.java b/library/src/test/java/com/orm/record/LongFieldTests.java
new file mode 100644
index 00000000..d1516a42
--- /dev/null
+++ b/library/src/test/java/com/orm/record/LongFieldTests.java
@@ -0,0 +1,80 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.LongFieldAnnotatedModel;
+import com.orm.model.LongFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@SuppressWarnings("all")
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class LongFieldTests {
+    private Long aLong = Long.valueOf(25L);
+
+    @Test
+    public void nullLongExtendedTest() {
+        save(new LongFieldExtendedModel());
+        LongFieldExtendedModel model = findById(LongFieldExtendedModel.class, 1);
+        assertNull(model.getLong());
+    }
+
+    @Test
+    public void nullRawLongExtendedTest() {
+        save(new LongFieldExtendedModel());
+        LongFieldExtendedModel model = findById(LongFieldExtendedModel.class, 1);
+        assertEquals(0L, model.getRawLong());
+    }
+
+    @Test
+    public void nullLongAnnotatedTest() {
+        save(new LongFieldAnnotatedModel());
+        LongFieldAnnotatedModel model = findById(LongFieldAnnotatedModel.class, 1);
+        assertNull(model.getLong());
+    }
+
+    @Test
+    public void nullRawLongAnnotatedTest() {
+        save(new LongFieldAnnotatedModel());
+        LongFieldAnnotatedModel model = findById(LongFieldAnnotatedModel.class, 1);
+        assertEquals(0L, model.getRawLong());
+    }
+
+    @Test
+    public void objectLongExtendedTest() {
+        save(new LongFieldExtendedModel(aLong));
+        LongFieldExtendedModel model = findById(LongFieldExtendedModel.class, 1);
+        assertEquals(aLong, model.getLong());
+    }
+
+    @Test
+    public void rawLongExtendedTest() {
+        save(new LongFieldExtendedModel(aLong.longValue()));
+        LongFieldExtendedModel model = findById(LongFieldExtendedModel.class, 1);
+        assertEquals(aLong.longValue(), model.getRawLong());
+    }
+
+    @Test
+    public void objectLongAnnotatedTest() {
+        save(new LongFieldAnnotatedModel(aLong));
+        LongFieldAnnotatedModel model = findById(LongFieldAnnotatedModel.class, 1);
+        assertEquals(aLong, model.getLong());
+    }
+
+    @Test
+    public void rawLongAnnotatedTest() {
+        save(new LongFieldAnnotatedModel(aLong.longValue()));
+        LongFieldAnnotatedModel model = findById(LongFieldAnnotatedModel.class, 1);
+        assertEquals(aLong.longValue(), model.getRawLong());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/MultipleSaveTests.java b/library/src/test/java/com/orm/record/MultipleSaveTests.java
new file mode 100644
index 00000000..73b353ad
--- /dev/null
+++ b/library/src/test/java/com/orm/record/MultipleSaveTests.java
@@ -0,0 +1,111 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.StringFieldAnnotatedModel;
+import com.orm.model.StringFieldAnnotatedNoIdModel;
+import com.orm.model.StringFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class MultipleSaveTests {
+    private String testString = "Test String";
+    private String anotherString = "Another test";
+
+    @Test
+    public void stringMultipleSaveOriginalExtendedTest() {
+        StringFieldExtendedModel model = new StringFieldExtendedModel(testString);
+        long id = save(model);
+        StringFieldExtendedModel query = findById(StringFieldExtendedModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+        }
+
+        model.setString(anotherString);
+
+        assertEquals(id, save(model));
+        assertNull(findById(StringFieldExtendedModel.class, 2));
+    }
+
+    @Test
+    public void stringMultipleSaveQueriedExtendedTest() {
+        StringFieldExtendedModel model = new StringFieldExtendedModel(testString);
+        long id = save(model);
+        StringFieldExtendedModel query = findById(StringFieldExtendedModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+            query.setString(anotherString);
+            assertEquals(id, save(query));
+            assertNull(findById(StringFieldExtendedModel.class, 2));
+        }
+    }
+
+    @Test
+    public void stringMultipleSaveOriginalAnnotatedTest() {
+        StringFieldAnnotatedModel model = new StringFieldAnnotatedModel(testString);
+        long id = save(model);
+        StringFieldAnnotatedModel query = findById(StringFieldAnnotatedModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+            model.setString(anotherString);
+            assertEquals(id, save(model));
+            assertNull(findById(StringFieldAnnotatedModel.class, 2));
+        }
+    }
+
+    @Test
+    public void stringMultipleSaveQueriedAnnotatedTest() {
+        StringFieldAnnotatedModel model = new StringFieldAnnotatedModel(testString);
+        long id = save(model);
+        StringFieldAnnotatedModel query = findById(StringFieldAnnotatedModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+            query.setString(anotherString);
+            assertEquals(id, save(query));
+            assertNull(findById(StringFieldAnnotatedModel.class, 2));
+        }
+    }
+
+    @Test
+    public void stringMultipleSaveOriginalAnnotatedNoIdTest() {
+        StringFieldAnnotatedNoIdModel model = new StringFieldAnnotatedNoIdModel(testString);
+        long id = save(model);
+        StringFieldAnnotatedNoIdModel query = findById(StringFieldAnnotatedNoIdModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+            model.setString(anotherString);
+            assertEquals(id, save(model));
+            assertNull(findById(StringFieldAnnotatedNoIdModel.class, 2));
+        }
+    }
+
+    @Test
+    public void stringMultipleSaveQueriedAnnotatedNoIdTest() {
+        StringFieldAnnotatedNoIdModel model = new StringFieldAnnotatedNoIdModel(testString);
+        long id = save(model);
+        StringFieldAnnotatedNoIdModel query = findById(StringFieldAnnotatedNoIdModel.class, id);
+
+        if (null != query) {
+            assertEquals(testString, query.getString());
+            query.setString(anotherString);
+            assertEquals(id, save(query));
+            assertNull(findById(StringFieldAnnotatedNoIdModel.class, 2));
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedAnnotatedTests.java b/library/src/test/java/com/orm/record/NestedAnnotatedTests.java
new file mode 100644
index 00000000..d7c8ef43
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedAnnotatedTests.java
@@ -0,0 +1,142 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedAnnotatedModel;
+import com.orm.model.RelationshipAnnotatedModel;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NestedAnnotatedTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedAnnotatedModel.class));
+        assertEquals(0L, count(RelationshipAnnotatedModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+        save(nested);
+        save(new NestedAnnotatedModel(nested));
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipAnnotatedModel.class));
+        assertEquals(1L, count(NestedAnnotatedModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+        save(nested);
+        save(new NestedAnnotatedModel(nested));
+        save(new NestedAnnotatedModel(nested));
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipAnnotatedModel.class));
+        assertEquals(2L, count(NestedAnnotatedModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        SimpleAnnotatedModel anotherSimple = new SimpleAnnotatedModel();
+        save(anotherSimple);
+        RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+        save(nested);
+        RelationshipAnnotatedModel anotherNested = new RelationshipAnnotatedModel(anotherSimple);
+        save(anotherNested);
+        save(new NestedAnnotatedModel(nested));
+        save(new NestedAnnotatedModel(anotherNested));
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+        assertEquals(2L, count(RelationshipAnnotatedModel.class));
+        assertEquals(2L, count(NestedAnnotatedModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+        save(nested);
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedAnnotatedModel(nested));
+        }
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipAnnotatedModel.class));
+        assertEquals(100L, count(NestedAnnotatedModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+            save(nested);
+            save(new NestedAnnotatedModel(nested));
+        }
+        assertEquals(100L, count(SimpleAnnotatedModel.class));
+        assertEquals(100L, count(RelationshipAnnotatedModel.class));
+        assertEquals(100L, count(NestedAnnotatedModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedAnnotatedModel(nested));
+        }
+
+        List<NestedAnnotatedModel> models = listAll(NestedAnnotatedModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedAnnotatedModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipAnnotatedModel nested = new RelationshipAnnotatedModel(simple);
+            save(nested);
+            save(new NestedAnnotatedModel(nested));
+        }
+
+        List<NestedAnnotatedModel> models = listAll(NestedAnnotatedModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedAnnotatedModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedExtendedTests.java b/library/src/test/java/com/orm/record/NestedExtendedTests.java
new file mode 100644
index 00000000..eaf8c120
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedExtendedTests.java
@@ -0,0 +1,140 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedExtendedModel;
+import com.orm.model.RelationshipExtendedModel;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NestedExtendedTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedExtendedModel.class));
+        assertEquals(0L, count(RelationshipExtendedModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+        save(nested);
+        save(new NestedExtendedModel(nested));
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipExtendedModel.class));
+        assertEquals(1L, count(NestedExtendedModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+        save(nested);
+        save(new NestedExtendedModel(nested));
+        save(new NestedExtendedModel(nested));
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipExtendedModel.class));
+        assertEquals(2L, count(NestedExtendedModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        SimpleExtendedModel anotherSimple = new SimpleExtendedModel();
+        save(anotherSimple);
+        RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+        save(nested);
+        RelationshipExtendedModel anotherNested = new RelationshipExtendedModel(anotherSimple);
+        save(anotherNested);
+        save(new NestedExtendedModel(nested));
+        save(new NestedExtendedModel(anotherNested));
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipExtendedModel.class));
+        assertEquals(2L, count(NestedExtendedModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+        save(nested);
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedExtendedModel(nested));
+        }
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipExtendedModel.class));
+        assertEquals(100L, count(NestedExtendedModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+            save(nested);
+            save(new NestedExtendedModel(nested));
+        }
+        assertEquals(100L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipExtendedModel.class));
+        assertEquals(100L, count(NestedExtendedModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+        save(nested);
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedExtendedModel(nested));
+        }
+
+        List<NestedExtendedModel> models = listAll(NestedExtendedModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedExtendedModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipExtendedModel nested = new RelationshipExtendedModel(simple);
+            save(nested);
+            save(new NestedExtendedModel(nested));
+        }
+
+        List<NestedExtendedModel> models = listAll(NestedExtendedModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedExtendedModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedMixedAATests.java b/library/src/test/java/com/orm/record/NestedMixedAATests.java
new file mode 100644
index 00000000..9daf3fa9
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedMixedAATests.java
@@ -0,0 +1,141 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedMixedAAModel;
+import com.orm.model.RelationshipMixedAModel;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NestedMixedAATests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedMixedAAModel.class));
+        assertEquals(0L, count(RelationshipMixedAModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+        save(new NestedMixedAAModel(nested));
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(1L, count(NestedMixedAAModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+        save(new NestedMixedAAModel(nested));
+        save(new NestedMixedAAModel(nested));
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(2L, count(NestedMixedAAModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        SimpleAnnotatedModel anotherSimple = new SimpleAnnotatedModel();
+        save(anotherSimple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+        RelationshipMixedAModel anotherNested = new RelationshipMixedAModel(anotherSimple);
+        save(anotherNested);
+        save(new NestedMixedAAModel(nested));
+        save(new NestedMixedAAModel(anotherNested));
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+        assertEquals(2L, count(RelationshipMixedAModel.class));
+        assertEquals(2L, count(NestedMixedAAModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedAAModel(nested));
+        }
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(100L, count(NestedMixedAAModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+            save(nested);
+            save(new NestedMixedAAModel(nested));
+        }
+        assertEquals(100L, count(SimpleAnnotatedModel.class));
+        assertEquals(100L, count(RelationshipMixedAModel.class));
+        assertEquals(100L, count(NestedMixedAAModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedAAModel(nested));
+        }
+
+        List<NestedMixedAAModel> models = listAll(NestedMixedAAModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedAAModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+            save(nested);
+            save(new NestedMixedAAModel(nested));
+        }
+
+        List<NestedMixedAAModel> models = listAll(NestedMixedAAModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedAAModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedMixedABTests.java b/library/src/test/java/com/orm/record/NestedMixedABTests.java
new file mode 100644
index 00000000..fa16b506
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedMixedABTests.java
@@ -0,0 +1,150 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedMixedABModel;
+import com.orm.model.RelationshipMixedBModel;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class NestedMixedABTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedMixedABModel.class));
+        assertEquals(0L, count(RelationshipMixedBModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+
+        save(nested);
+        save(new NestedMixedABModel(nested));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(1L, count(NestedMixedABModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+
+        save(nested);
+        save(new NestedMixedABModel(nested));
+        save(new NestedMixedABModel(nested));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(2L, count(NestedMixedABModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        SimpleExtendedModel anotherSimple = new SimpleExtendedModel();
+        save(anotherSimple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+        RelationshipMixedBModel anotherNested = new RelationshipMixedBModel(anotherSimple);
+
+        save(anotherNested);
+        save(new NestedMixedABModel(nested));
+        save(new NestedMixedABModel(anotherNested));
+
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipMixedBModel.class));
+        assertEquals(2L, count(NestedMixedABModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedABModel(nested));
+        }
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(100L, count(NestedMixedABModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+            save(nested);
+            save(new NestedMixedABModel(nested));
+        }
+
+        assertEquals(100L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipMixedBModel.class));
+        assertEquals(100L, count(NestedMixedABModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedABModel(nested));
+        }
+
+        List<NestedMixedABModel> models = listAll(NestedMixedABModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedABModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+            save(nested);
+            save(new NestedMixedABModel(nested));
+        }
+
+        List<NestedMixedABModel> models = listAll(NestedMixedABModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedABModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedMixedBATests.java b/library/src/test/java/com/orm/record/NestedMixedBATests.java
new file mode 100644
index 00000000..c6f07da5
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedMixedBATests.java
@@ -0,0 +1,151 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.SugarRecord;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedMixedBAModel;
+import com.orm.model.RelationshipMixedAModel;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NestedMixedBATests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedMixedBAModel.class));
+        assertEquals(0L, count(RelationshipMixedAModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+
+        save(nested);
+        save(new NestedMixedBAModel(nested));
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(1L, count(NestedMixedBAModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+
+        save(nested);
+        save(new NestedMixedBAModel(nested));
+        save(new NestedMixedBAModel(nested));
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(2L, count(NestedMixedBAModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        SimpleAnnotatedModel anotherSimple = new SimpleAnnotatedModel();
+        save(anotherSimple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+        RelationshipMixedAModel anotherNested = new RelationshipMixedAModel(anotherSimple);
+
+        save(anotherNested);
+        save(new NestedMixedBAModel(nested));
+        save(new NestedMixedBAModel(anotherNested));
+
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+        assertEquals(2L, count(RelationshipMixedAModel.class));
+        assertEquals(2L, count(NestedMixedBAModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedBAModel(nested));
+        }
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipMixedAModel.class));
+        assertEquals(100L, count(NestedMixedBAModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+            save(nested);
+            save(new NestedMixedBAModel(nested));
+        }
+
+        assertEquals(100L, count(SimpleAnnotatedModel.class));
+        assertEquals(100L, count(RelationshipMixedAModel.class));
+        assertEquals(100L, count(NestedMixedBAModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedBAModel(nested));
+        }
+
+        List<NestedMixedBAModel> models = listAll(NestedMixedBAModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedBAModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            RelationshipMixedAModel nested = new RelationshipMixedAModel(simple);
+            save(nested);
+            save(new NestedMixedBAModel(nested));
+        }
+
+        List<NestedMixedBAModel> models = listAll(NestedMixedBAModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedBAModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NestedMixedBBTests.java b/library/src/test/java/com/orm/record/NestedMixedBBTests.java
new file mode 100644
index 00000000..1eeb2a7d
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NestedMixedBBTests.java
@@ -0,0 +1,150 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NestedMixedBBModel;
+import com.orm.model.RelationshipMixedBModel;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class NestedMixedBBTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(NestedMixedBBModel.class));
+        assertEquals(0L, count(RelationshipMixedBModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+
+        save(nested);
+        save(new NestedMixedBBModel(nested));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(1L, count(NestedMixedBBModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+
+        save(nested);
+        save(new NestedMixedBBModel(nested));
+        save(new NestedMixedBBModel(nested));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(2L, count(NestedMixedBBModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        SimpleExtendedModel anotherSimple = new SimpleExtendedModel();
+        save(anotherSimple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+        RelationshipMixedBModel anotherNested = new RelationshipMixedBModel(anotherSimple);
+
+        save(anotherNested);
+        save(new NestedMixedBBModel(nested));
+        save(new NestedMixedBBModel(anotherNested));
+
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipMixedBModel.class));
+        assertEquals(2L, count(NestedMixedBBModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedBBModel(nested));
+        }
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+        assertEquals(100L, count(NestedMixedBBModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+            save(nested);
+            save(new NestedMixedBBModel(nested));
+        }
+
+        assertEquals(100L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipMixedBModel.class));
+        assertEquals(100L, count(NestedMixedBBModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+        save(nested);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new NestedMixedBBModel(nested));
+        }
+
+        List<NestedMixedBBModel> models = listAll(NestedMixedBBModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedBBModel model : models) {
+            assertEquals(nested.getId(), model.getNested().getId());
+            assertEquals(simple.getId(), model.getNested().getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            RelationshipMixedBModel nested = new RelationshipMixedBModel(simple);
+            save(nested);
+            save(new NestedMixedBBModel(nested));
+        }
+
+        List<NestedMixedBBModel> models = listAll(NestedMixedBBModel.class);
+        assertEquals(100, models.size());
+
+        for (NestedMixedBBModel model : models) {
+            assertEquals(model.getId(), model.getNested().getId());
+            assertEquals(model.getId(), model.getNested().getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/NoSugarModelTests.java b/library/src/test/java/com/orm/record/NoSugarModelTests.java
new file mode 100644
index 00000000..08f43154
--- /dev/null
+++ b/library/src/test/java/com/orm/record/NoSugarModelTests.java
@@ -0,0 +1,34 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.NoSugarModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.delete;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.saveInTx;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class NoSugarModelTests {
+
+    @Test
+    public void deleteTest() throws Exception {
+        NoSugarModel model = new NoSugarModel();
+        assertFalse(delete(model));
+    }
+
+    @Test
+    public void saveInTransactionTest() throws Exception {
+        saveInTx(new NoSugarModel(), new NoSugarModel());
+        assertEquals(-1L, count(NoSugarModel.class));
+    }
+}
diff --git a/library/src/test/java/com/orm/record/OneToManyTest.java b/library/src/test/java/com/orm/record/OneToManyTest.java
new file mode 100644
index 00000000..73a60b57
--- /dev/null
+++ b/library/src/test/java/com/orm/record/OneToManyTest.java
@@ -0,0 +1,139 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.onetomany.OneToManyRelationModel;
+import com.orm.model.onetomany.OneToManyModel;
+import com.orm.model.onetomany.WithoutOneToManyAnnotationModel;
+import com.orm.model.onetomany.WithoutOneToManyAnnotationRelationModel;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static com.orm.SugarRecord.findById;
+import static com.orm.SugarRecord.save;
+
+/**
+ * Created by ukasz Wesoowski on 28.07.2016.
+ */
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class OneToManyTest {
+    @Test
+    public void shouldSaveWithOneToManyRelation() {
+        List<Long> relationIds = Arrays.asList(1l, 2l, 3l, 4l);
+
+        OneToManyModel model = new OneToManyModel(1l);
+        save(model);
+
+        for (long i : relationIds) {
+            save(new OneToManyRelationModel(i, model));
+        }
+
+        OneToManyModel result = findById(OneToManyModel.class, 1l);
+
+        Assert.assertEquals(4, result.getModels().size());
+
+        Assert.assertTrue(relationIds.contains(result.getModels().get(0).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(1).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(2).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(3).getId()));
+
+        Assert.assertEquals(result, result.getModels().get(0).getModel());
+        Assert.assertEquals(result, result.getModels().get(1).getModel());
+        Assert.assertEquals(result, result.getModels().get(2).getModel());
+        Assert.assertEquals(result, result.getModels().get(3).getModel());
+    }
+
+    @Test
+    public void shouldRemoveOneOfManyToOneRelation() {
+        OneToManyModel model = new OneToManyModel(1l);
+        save(model);
+
+        for (long i : Arrays.asList(1l, 2l, 3l, 4l)) {
+            save(new OneToManyRelationModel(i, model));
+        }
+
+        OneToManyModel result = findById(OneToManyModel.class, 1l);
+
+        Assert.assertEquals(4, result.getModels().size());
+
+        OneToManyRelationModel.deleteAll(OneToManyRelationModel.class, "id = ?", String.valueOf(3l));
+
+        result = findById(OneToManyModel.class, 1l);
+
+        Assert.assertEquals(3, result.getModels().size());
+
+        Assert.assertTrue(result.getModels().get(0).getId() != 3l);
+        Assert.assertTrue(result.getModels().get(1).getId() != 3l);
+        Assert.assertTrue(result.getModels().get(2).getId() != 3l);
+    }
+
+    @Test
+    public void shouldNotRemoveRelation() {
+        OneToManyModel model = new OneToManyModel(1l);
+        save(model);
+
+        for (long i : Arrays.asList(1l, 2l, 3l, 4l)) {
+            save(new OneToManyRelationModel(i, model));
+        }
+
+        OneToManyModel result = findById(OneToManyModel.class, 1l);
+
+        result.getModels().clear();
+
+        save(model);
+
+        result = findById(OneToManyModel.class, 1l);
+
+        Assert.assertEquals(4, result.getModels().size());
+    }
+
+    @Test
+    public void shouldNotAddRelation() {
+        List<Long> relationIds = Arrays.asList(1l, 2l, 3l, 4l);
+        OneToManyModel model = new OneToManyModel(1l);
+        save(model);
+
+        for (long i : relationIds) {
+            save(new OneToManyRelationModel(i, model));
+        }
+
+        save(new OneToManyRelationModel(5l, null));
+
+        OneToManyModel result = findById(OneToManyModel.class, 1l);
+
+        Assert.assertEquals(4, result.getModels().size());
+
+        Assert.assertTrue(relationIds.contains(result.getModels().get(0).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(1).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(2).getId()));
+        Assert.assertTrue(relationIds.contains(result.getModels().get(3).getId()));
+
+        Assert.assertEquals(result, result.getModels().get(0).getModel());
+        Assert.assertEquals(result, result.getModels().get(1).getModel());
+        Assert.assertEquals(result, result.getModels().get(2).getModel());
+        Assert.assertEquals(result, result.getModels().get(3).getModel());
+    }
+
+    @Test
+    public void shouldNotInflateList() {
+        List<Long> relationIds = Arrays.asList(1l, 2l, 3l, 4l);
+        WithoutOneToManyAnnotationModel model = new WithoutOneToManyAnnotationModel(1l);
+        save(model);
+
+        for (long i : relationIds) {
+            save(new WithoutOneToManyAnnotationRelationModel(i, model));
+        }
+
+        WithoutOneToManyAnnotationModel result = findById(WithoutOneToManyAnnotationModel.class, 1l);
+
+        Assert.assertEquals(null, result.getModels());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/RelationshipAnnotatedTests.java b/library/src/test/java/com/orm/record/RelationshipAnnotatedTests.java
new file mode 100644
index 00000000..506e0264
--- /dev/null
+++ b/library/src/test/java/com/orm/record/RelationshipAnnotatedTests.java
@@ -0,0 +1,125 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.RelationshipAnnotatedModel;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class RelationshipAnnotatedTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(RelationshipAnnotatedModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+
+        save(simple);
+        save(new RelationshipAnnotatedModel(simple));
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(1L, count(RelationshipAnnotatedModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+
+        save(simple);
+        save(new RelationshipAnnotatedModel(simple));
+        save(new RelationshipAnnotatedModel(simple));
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(2L, count(RelationshipAnnotatedModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+        SimpleAnnotatedModel anotherSimple = new SimpleAnnotatedModel();
+
+        save(anotherSimple);
+        save(new RelationshipAnnotatedModel(simple));
+        save(new RelationshipAnnotatedModel(anotherSimple));
+
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+        assertEquals(2L, count(RelationshipAnnotatedModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipAnnotatedModel(simple));
+        }
+
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertEquals(100L, count(RelationshipAnnotatedModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            save(new RelationshipAnnotatedModel(simple));
+        }
+
+        assertEquals(100L, count(SimpleAnnotatedModel.class));
+        assertEquals(100L, count(RelationshipAnnotatedModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipAnnotatedModel(simple));
+        }
+
+        List<RelationshipAnnotatedModel> models = listAll(RelationshipAnnotatedModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipAnnotatedModel model : models) {
+            assertEquals(simple.getId(), model.getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+            save(simple);
+            save(new RelationshipAnnotatedModel(simple));
+        }
+
+        List<RelationshipAnnotatedModel> models = listAll(RelationshipAnnotatedModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipAnnotatedModel model : models) {
+            assertEquals(model.getId(), model.getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/RelationshipExtendedTests.java b/library/src/test/java/com/orm/record/RelationshipExtendedTests.java
new file mode 100644
index 00000000..f9faeedd
--- /dev/null
+++ b/library/src/test/java/com/orm/record/RelationshipExtendedTests.java
@@ -0,0 +1,125 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.RelationshipExtendedModel;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class RelationshipExtendedTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(RelationshipExtendedModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+
+        save(simple);
+        save(new RelationshipExtendedModel(simple));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipExtendedModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+
+        save(simple);
+        save(new RelationshipExtendedModel(simple));
+        save(new RelationshipExtendedModel(simple));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipExtendedModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        SimpleExtendedModel anotherSimple = new SimpleExtendedModel();
+
+        save(anotherSimple);
+        save(new RelationshipExtendedModel(simple));
+        save(new RelationshipExtendedModel(anotherSimple));
+
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipExtendedModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipExtendedModel(simple));
+        }
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipExtendedModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            save(new RelationshipExtendedModel(simple));
+        }
+
+        assertEquals(100L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipExtendedModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipExtendedModel(simple));
+        }
+
+        List<RelationshipExtendedModel> models = listAll(RelationshipExtendedModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipExtendedModel model : models) {
+            assertEquals(simple.getId(), model.getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            save(new RelationshipExtendedModel(simple));
+        }
+
+        List<RelationshipExtendedModel> models = listAll(RelationshipExtendedModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipExtendedModel model : models) {
+            assertEquals(model.getId(), model.getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/RelationshipMixedATests.java b/library/src/test/java/com/orm/record/RelationshipMixedATests.java
new file mode 100644
index 00000000..35aaa16d
--- /dev/null
+++ b/library/src/test/java/com/orm/record/RelationshipMixedATests.java
@@ -0,0 +1,141 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.RelationshipMixedAModel;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class RelationshipMixedATests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(RelationshipMixedAModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        RelationshipMixedAModel mixedAModel = new RelationshipMixedAModel(simple);
+
+        save(simple);
+        save(mixedAModel);
+
+        assertEquals(1L, count(simple.getClass()));
+        assertEquals(1L, count(mixedAModel.getClass()));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        RelationshipMixedAModel mixedAModel1 = new RelationshipMixedAModel(simple);
+        RelationshipMixedAModel mixedAModel2 = new RelationshipMixedAModel(simple);
+
+
+        save(simple);
+        save(mixedAModel1);
+        save(mixedAModel2);
+
+        assertEquals(1L, count(simple.getClass()));
+        assertEquals(2L, count(mixedAModel1.getClass()));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel anotherSimple = new SimpleAnnotatedModel();
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        RelationshipMixedAModel mixedAModel = new RelationshipMixedAModel(simple);
+        RelationshipMixedAModel anotherMixedAModel = new RelationshipMixedAModel(anotherSimple);
+
+        save(simple);
+        save(anotherSimple);
+        save(mixedAModel);
+        save(anotherMixedAModel);
+
+        assertEquals(2L, count(simple.getClass()));
+        assertEquals(2L, count(mixedAModel.getClass()));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        final SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+        RelationshipMixedAModel mixedAModel = null;
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            mixedAModel = new RelationshipMixedAModel(simple);
+            save(mixedAModel);
+        }
+
+        assertEquals(1L, count(simple.getClass()));
+        assertEquals(100L, count(mixedAModel.getClass()));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        SimpleAnnotatedModel simple = null;
+        RelationshipMixedAModel mixedAModel = null;
+
+        for (int i = 1; i <= 100; i++) {
+            simple = new SimpleAnnotatedModel();
+            mixedAModel = new RelationshipMixedAModel(simple);
+
+            save(simple);
+            save(mixedAModel);
+        }
+
+        assertEquals(100L, count(simple.getClass()));
+        assertEquals(100L, count(mixedAModel.getClass()));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+
+        for (int i = 1; i <= 100; i++) {
+            RelationshipMixedAModel mixedAModel = new RelationshipMixedAModel(simple);
+
+            save(simple);
+            save(mixedAModel);
+        }
+
+        List<RelationshipMixedAModel> models = listAll(RelationshipMixedAModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipMixedAModel model : models) {
+            assertEquals(simple.getId(), model.getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel simple = new SimpleAnnotatedModel();
+
+            save(simple);
+            save(new RelationshipMixedAModel(simple));
+        }
+
+        List<RelationshipMixedAModel> models = listAll(RelationshipMixedAModel.class);
+        assertEquals(100, models.size());
+
+        for (RelationshipMixedAModel model : models) {
+            assertEquals(model.getId(), model.getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/RelationshipMixedBTests.java b/library/src/test/java/com/orm/record/RelationshipMixedBTests.java
new file mode 100644
index 00000000..7792fce8
--- /dev/null
+++ b/library/src/test/java/com/orm/record/RelationshipMixedBTests.java
@@ -0,0 +1,120 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.RelationshipMixedBModel;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public class RelationshipMixedBTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(RelationshipMixedBModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+
+        save(simple);
+        save(new RelationshipMixedBModel(simple));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(1L, count(RelationshipMixedBModel.class));
+    }
+
+    @Test
+    public void twoSameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+
+        save(simple);
+        save(new RelationshipMixedBModel(simple));
+        save(new RelationshipMixedBModel(simple));
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipMixedBModel.class));
+    }
+
+    @Test
+    public void twoDifferentSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        SimpleExtendedModel anotherSimple = new SimpleExtendedModel();
+
+        save(anotherSimple);
+        save(new RelationshipMixedBModel(simple));
+        save(new RelationshipMixedBModel(anotherSimple));
+
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2L, count(RelationshipMixedBModel.class));
+    }
+
+    @Test
+    public void manySameSaveTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipMixedBModel(simple));
+        }
+
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipMixedBModel.class));
+    }
+
+    @Test
+    public void manyDifferentSaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            save(new RelationshipMixedBModel(simple));
+        }
+
+        assertEquals(100L, count(SimpleExtendedModel.class));
+        assertEquals(100L, count(RelationshipMixedBModel.class));
+    }
+
+    @Test
+    public void listAllSameTest() throws Exception {
+        SimpleExtendedModel simple = new SimpleExtendedModel();
+        save(simple);
+        for (int i = 1; i <= 100; i++) {
+            save(new RelationshipMixedBModel(simple));
+        }
+        List<RelationshipMixedBModel> models = listAll(RelationshipMixedBModel.class);
+        assertEquals(100, models.size());
+        for (RelationshipMixedBModel model : models) {
+            assertEquals(simple.getId(), model.getSimple().getId());
+        }
+    }
+
+    @Test
+    public void listAllDifferentTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            SimpleExtendedModel simple = new SimpleExtendedModel();
+            save(simple);
+            save(new RelationshipMixedBModel(simple));
+        }
+        List<RelationshipMixedBModel> models = listAll(RelationshipMixedBModel.class);
+        assertEquals(100, models.size());
+        for (RelationshipMixedBModel model : models) {
+            assertEquals(model.getId(), model.getSimple().getId());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/record/ShortFieldTests.java b/library/src/test/java/com/orm/record/ShortFieldTests.java
new file mode 100644
index 00000000..1a65f676
--- /dev/null
+++ b/library/src/test/java/com/orm/record/ShortFieldTests.java
@@ -0,0 +1,80 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.ShortFieldAnnotatedModel;
+import com.orm.model.ShortFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@SuppressWarnings("all")
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ShortFieldTests {
+    private Short aShort = Short.valueOf((short) 25);
+
+    @Test
+    public void nullShortExtendedTest() {
+        save(new ShortFieldExtendedModel());
+        ShortFieldExtendedModel model = findById(ShortFieldExtendedModel.class, 1);
+        assertNull(model.getShort());
+    }
+
+    @Test
+    public void nullRawShortExtendedTest() {
+        save(new ShortFieldExtendedModel());
+        ShortFieldExtendedModel model = findById(ShortFieldExtendedModel.class, 1);
+        assertEquals((short) 0, model.getRawShort());
+    }
+
+    @Test
+    public void nullShortAnnotatedTest() {
+        save(new ShortFieldAnnotatedModel());
+        ShortFieldAnnotatedModel model = findById(ShortFieldAnnotatedModel.class, 1);
+        assertNull(model.getShort());
+    }
+
+    @Test
+    public void nullRawShortAnnotatedTest() {
+        save(new ShortFieldAnnotatedModel());
+        ShortFieldAnnotatedModel model = findById(ShortFieldAnnotatedModel.class, 1);
+        assertEquals((short) 0, model.getRawShort());
+    }
+
+    @Test
+    public void objectShortExtendedTest() {
+        save(new ShortFieldExtendedModel(aShort));
+        ShortFieldExtendedModel model = findById(ShortFieldExtendedModel.class, 1);
+        assertEquals(aShort, model.getShort());
+    }
+
+    @Test
+    public void rawShortExtendedTest() {
+        save(new ShortFieldExtendedModel(aShort.shortValue()));
+        ShortFieldExtendedModel model = findById(ShortFieldExtendedModel.class, 1);
+        assertEquals(aShort.shortValue(), model.getRawShort());
+    }
+
+    @Test
+    public void objectShortAnnotatedTest() {
+        save(new ShortFieldAnnotatedModel(aShort));
+        ShortFieldAnnotatedModel model = findById(ShortFieldAnnotatedModel.class, 1);
+        assertEquals(aShort, model.getShort());
+    }
+
+    @Test
+    public void rawShortAnnotatedTest() {
+        save(new ShortFieldAnnotatedModel(aShort.shortValue()));
+        ShortFieldAnnotatedModel model = findById(ShortFieldAnnotatedModel.class, 1);
+        assertEquals(aShort.shortValue(), model.getRawShort());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/SimpleAnnotatedModelTests.java b/library/src/test/java/com/orm/record/SimpleAnnotatedModelTests.java
new file mode 100644
index 00000000..a201a9eb
--- /dev/null
+++ b/library/src/test/java/com/orm/record/SimpleAnnotatedModelTests.java
@@ -0,0 +1,373 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.helper.NamingHelper;
+import com.orm.model.SimpleAnnotatedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.deleteAll;
+import static com.orm.SugarRecord.delete;
+import static com.orm.SugarRecord.deleteInTx;
+import static com.orm.SugarRecord.listAll;
+import static com.orm.SugarRecord.findById;
+import static com.orm.SugarRecord.saveInTx;
+import static com.orm.SugarRecord.find;
+import static com.orm.SugarRecord.findAsIterator;
+import static com.orm.SugarRecord.findWithQuery;
+import static com.orm.SugarRecord.findAll;
+import static com.orm.SugarRecord.findWithQueryAsIterator;
+import static com.orm.SugarRecord.executeQuery;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SimpleAnnotatedModelTests {
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void twoSaveTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void manySaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        assertEquals(100L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void defaultIdTest() throws Exception {
+        assertEquals(1L, save(new SimpleAnnotatedModel()));
+    }
+
+    @Test
+    public void whereCountTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        assertEquals(1L, count(SimpleAnnotatedModel.class, "id = ?", new String[]{"1"}));
+    }
+
+    @Test
+    public void whereNoCountTest() throws Exception {
+        assertEquals(0L, count(SimpleAnnotatedModel.class, "id = ?", new String[]{"1"}));
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        assertEquals(0L, count(SimpleAnnotatedModel.class, "id = ?", new String[]{"3"}));
+        assertEquals(0L, count(SimpleAnnotatedModel.class, "id = ?", new String[]{"a"}));
+    }
+
+    @Test
+    public void whereBrokenCountTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        assertEquals(-1L, count(SimpleAnnotatedModel.class, "di = ?", new String[]{"1"}));
+    }
+
+    @Test
+    public void deleteTest() throws Exception {
+        SimpleAnnotatedModel model = new SimpleAnnotatedModel();
+        save(model);
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+        assertTrue(delete(model));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void deleteUnsavedTest() throws Exception {
+        SimpleAnnotatedModel model = new SimpleAnnotatedModel();
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+        assertFalse(delete(model));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void deleteWrongTest() throws Exception {
+        SimpleAnnotatedModel model = new SimpleAnnotatedModel();
+        save(model);
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+
+        Field idField = model.getClass().getDeclaredField("id");
+        idField.setAccessible(true);
+        idField.set(model, Long.MAX_VALUE);
+
+        assertFalse(delete(model));
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void deleteAllTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+
+        assertEquals(100, deleteAll(SimpleAnnotatedModel.class));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void deleteAllWhereTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+
+        assertEquals(99, deleteAll(SimpleAnnotatedModel.class, "id > ?", new String[]{"1"}));
+        assertEquals(1L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void deleteInTransactionFewTest() throws Exception {
+        SimpleAnnotatedModel first = new SimpleAnnotatedModel();
+        SimpleAnnotatedModel second = new SimpleAnnotatedModel();
+        SimpleAnnotatedModel third = new SimpleAnnotatedModel();
+        save(first);
+        save(second);
+        // Not saving last model
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+        assertEquals(2, deleteInTx(first, second, third));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void deleteInTransactionManyTest() throws Exception {
+        List<SimpleAnnotatedModel> models = new ArrayList<>();
+
+        for (int i = 1; i <= 100; i++) {
+            SimpleAnnotatedModel model = new SimpleAnnotatedModel();
+            models.add(model);
+            // Not saving last model
+            if (i < 100) {
+                save(model);
+            }
+        }
+
+        assertEquals(99, count(SimpleAnnotatedModel.class));
+        assertEquals(99, deleteInTx(models));
+        assertEquals(0L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void saveInTransactionTest() throws Exception {
+        saveInTx(new SimpleAnnotatedModel(), new SimpleAnnotatedModel());
+        assertEquals(2L, count(SimpleAnnotatedModel.class));
+    }
+
+    @Test
+    public void listAllTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+
+        List<SimpleAnnotatedModel> models = listAll(SimpleAnnotatedModel.class);
+        assertEquals(100, models.size());
+
+        for (long i = 1; i <= 100; i++) {
+            assertEquals(Long.valueOf(i), models.get((int) i - 1).getId());
+        }
+    }
+
+    @Test
+    public void findTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+
+        List<SimpleAnnotatedModel> models = find(SimpleAnnotatedModel.class, "id = ?", "2");
+
+        assertEquals(1, models.size());
+        assertEquals(2L, models.get(0).getId().longValue());
+    }
+
+    @Test
+    public void findWithQueryTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+
+        List<SimpleAnnotatedModel> models = findWithQuery(SimpleAnnotatedModel.class, "Select * from " +
+                        NamingHelper.toTableName(SimpleAnnotatedModel.class) +
+                        " where id >= ? ", "50");
+
+        for (SimpleAnnotatedModel model : models) {
+            assertEquals(75L, model.getId(), 25L);
+        }
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void findByIdTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        assertEquals(1L, findById(SimpleAnnotatedModel.class, 1L).getId().longValue());
+    }
+
+    @Test
+    public void findByIdIntegerTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        assertEquals(1L, findById(SimpleAnnotatedModel.class, 1).getId().longValue());
+    }
+
+    @Test
+    public void findByIdStringsNullTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        assertEquals(0, findById(SimpleAnnotatedModel.class, new String[]{""}).size());
+    }
+
+    @Test
+    public void findByIdStringsOneTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        List<SimpleAnnotatedModel> models = findById(SimpleAnnotatedModel.class, new String[]{"1"});
+        assertEquals(1, models.size());
+        assertEquals(1L, models.get(0).getId().longValue());
+    }
+
+    @Test
+    public void findByIdStringsTwoTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        save(new SimpleAnnotatedModel());
+        List<SimpleAnnotatedModel> models = findById(SimpleAnnotatedModel.class, new String[]{"1", "3"});
+        assertEquals(2, models.size());
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+    }
+
+    @Test
+    public void findByIdStringsManyTest() throws Exception {
+        for (int i = 1; i <= 10; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        List<SimpleAnnotatedModel> models = findById(SimpleAnnotatedModel.class, new String[]{"1", "3", "6", "10"});
+        assertEquals(4, models.size());
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+        assertEquals(Long.valueOf(6L), models.get(2).getId());
+        assertEquals(Long.valueOf(10L), models.get(3).getId());
+    }
+
+    @Test
+    public void findByIdStringsOrderTest() throws Exception {
+        for (int i = 1; i <= 10; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        List<SimpleAnnotatedModel> models = findById(SimpleAnnotatedModel.class, new String[]{"10", "6", "3", "1"});
+        assertEquals(4, models.size());
+        // The order of the query doesn't matter
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+        assertEquals(Long.valueOf(6L), models.get(2).getId());
+        assertEquals(Long.valueOf(10L), models.get(3).getId());
+    }
+
+    @Test
+    public void findByIdNullTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        assertNull(findById(SimpleAnnotatedModel.class, 2L));
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        Iterator<SimpleAnnotatedModel> cursor = findAll(SimpleAnnotatedModel.class);
+        for (int i = 1; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleAnnotatedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test
+    public void findAsIteratorTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        Iterator<SimpleAnnotatedModel> cursor = findAsIterator(SimpleAnnotatedModel.class,
+                "id >= ?", "50");
+        for (int i = 50; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleAnnotatedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test
+    public void findWithQueryAsIteratorTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleAnnotatedModel());
+        }
+        Iterator<SimpleAnnotatedModel> cursor = findWithQueryAsIterator(SimpleAnnotatedModel.class,
+                        "Select * from " +
+                                NamingHelper.toTableName(SimpleAnnotatedModel.class) +
+                                " where id >= ? ", "50");
+        for (int i = 50; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleAnnotatedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test(expected=NoSuchElementException.class)
+    public void findAsIteratorOutOfBoundsTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        Iterator<SimpleAnnotatedModel> cursor = findAsIterator(SimpleAnnotatedModel.class,
+                "id = ?", "1");
+        assertTrue(cursor.hasNext());
+        SimpleAnnotatedModel model = cursor.next();
+        assertNotNull(model);
+        assertEquals(Long.valueOf(1), model.getId());
+        // This should throw a NoSuchElementException
+        cursor.next();
+    }
+
+    @Test(expected=UnsupportedOperationException.class)
+    public void disallowRemoveCursorTest() throws Exception {
+        save(new SimpleAnnotatedModel());
+        Iterator<SimpleAnnotatedModel> cursor = findAsIterator(SimpleAnnotatedModel.class, "id = ?", "1");
+        assertTrue(cursor.hasNext());
+        SimpleAnnotatedModel model = cursor.next();
+        assertNotNull(model);
+        assertEquals(Long.valueOf(1), model.getId());
+        // This should throw a UnsupportedOperationException
+        cursor.remove();
+    }
+
+    @Test
+    public void vacuumTest() throws Exception {
+        executeQuery("Vacuum");
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/record/SimpleExtendedModelTests.java b/library/src/test/java/com/orm/record/SimpleExtendedModelTests.java
new file mode 100644
index 00000000..e809405d
--- /dev/null
+++ b/library/src/test/java/com/orm/record/SimpleExtendedModelTests.java
@@ -0,0 +1,382 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.helper.NamingHelper;
+import com.orm.model.SimpleExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.count;
+import static com.orm.SugarRecord.delete;
+import static com.orm.SugarRecord.deleteAll;
+import static com.orm.SugarRecord.executeQuery;
+import static com.orm.SugarRecord.find;
+import static com.orm.SugarRecord.findAll;
+import static com.orm.SugarRecord.findById;
+import static com.orm.SugarRecord.findWithQuery;
+import static com.orm.SugarRecord.findAsIterator;
+import static com.orm.SugarRecord.findWithQueryAsIterator;
+import static com.orm.SugarRecord.deleteInTx;
+import static com.orm.SugarRecord.saveInTx;
+import static com.orm.SugarRecord.listAll;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class SimpleExtendedModelTests {
+    private String id = "id = ?";
+
+    @Test
+    public void emptyDatabaseTest() throws Exception {
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void oneSaveTest() throws Exception {
+        save(new SimpleExtendedModel());
+        assertEquals(1L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void twoSaveTest() throws Exception {
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        assertEquals(2L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void manySaveTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        assertEquals(100L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void defaultIdTest() throws Exception {
+        assertEquals(1L, save(new SimpleExtendedModel()));
+    }
+
+    @Test
+    public void whereCountTest() throws Exception {
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        assertEquals(1L, count(SimpleExtendedModel.class, id, new String[]{"1"}));
+    }
+
+    @Test
+    public void whereNoCountTest() throws Exception {
+        assertEquals(0L, count(SimpleExtendedModel.class, id, new String[]{"1"}));
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        assertEquals(0L, count(SimpleExtendedModel.class, id, new String[]{"3"}));
+        assertEquals(0L, count(SimpleExtendedModel.class, id, new String[]{"a"}));
+    }
+
+    @Test
+    public void whereBrokenCountTest() throws Exception {
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        assertEquals(-1L, count(SimpleExtendedModel.class, "di = ?", new String[]{"1"}));
+    }
+
+    @Test
+    public void saveMethodTest() throws Exception {
+        SimpleExtendedModel model = new SimpleExtendedModel();
+        model.save();
+        assertEquals(-1L, count(SimpleExtendedModel.class, "di = ?", new String[]{"1"}));
+    }
+
+    @Test
+    public void deleteTest() throws Exception {
+        SimpleExtendedModel model = new SimpleExtendedModel();
+        save(model);
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        assertTrue(delete(model));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void deleteUnsavedTest() throws Exception {
+        SimpleExtendedModel model = new SimpleExtendedModel();
+        assertEquals(0L, count(SimpleExtendedModel.class));
+        assertFalse(delete(model));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void deleteWrongTest() throws Exception {
+        SimpleExtendedModel model = new SimpleExtendedModel();
+        save(model);
+        assertEquals(1L, count(SimpleExtendedModel.class));
+        Field idField = model.getClass().getSuperclass().getDeclaredField("id");
+        idField.setAccessible(true);
+        idField.set(model, Long.MAX_VALUE);
+        assertFalse(delete(model));
+        assertEquals(1L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void deleteAllTest() throws Exception {
+        int elementNumber = 100;
+        for (int i = 1; i <= elementNumber; i++) {
+            save(new SimpleExtendedModel());
+        }
+        assertEquals(elementNumber, deleteAll(SimpleExtendedModel.class));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void deleteAllWhereTest() throws Exception {
+        int elementNumber = 100;
+        for (int i = 1; i <= elementNumber; i++) {
+            save(new SimpleExtendedModel());
+        }
+        assertEquals(elementNumber - 1, deleteAll(SimpleExtendedModel.class, "id > ?", new String[]{"1"}));
+        assertEquals(1L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void deleteInTransactionFewTest() throws Exception {
+        SimpleExtendedModel first = new SimpleExtendedModel();
+        SimpleExtendedModel second = new SimpleExtendedModel();
+        SimpleExtendedModel third = new SimpleExtendedModel();
+        save(first);
+        save(second);
+        // Not saving last model
+        assertEquals(2L, count(SimpleExtendedModel.class));
+        assertEquals(2, deleteInTx(first, second, third));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void deleteInTransactionManyTest() throws Exception {
+        long elementNumber = 100;
+        List<SimpleExtendedModel> models = new ArrayList<>();
+        for (int i = 1; i <= elementNumber; i++) {
+            SimpleExtendedModel model = new SimpleExtendedModel();
+            models.add(model);
+            // Not saving last model
+            if (i < elementNumber) {
+                save(model);
+            }
+        }
+        assertEquals(elementNumber - 1, count(SimpleExtendedModel.class));
+        assertEquals(elementNumber - 1, deleteInTx(models));
+        assertEquals(0L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void saveInTransactionTest() throws Exception {
+        saveInTx(new SimpleExtendedModel(), new SimpleExtendedModel());
+        assertEquals(2L, count(SimpleExtendedModel.class));
+    }
+
+    @Test
+    public void listAllTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+        List<SimpleExtendedModel> models = listAll(SimpleExtendedModel.class);
+        assertEquals(100, models.size());
+        for (long i = 1; i <= 100; i++) {
+            assertEquals(Long.valueOf(i), models.get((int) i - 1).getId());
+        }
+    }
+
+    @Test
+    public void findTest() throws Exception {
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        List<SimpleExtendedModel> models = find(SimpleExtendedModel.class, "id = ?", "2");
+        assertEquals(1, models.size());
+        assertEquals(Long.valueOf(2L), models.get(0).getId());
+    }
+
+    @Test
+    public void findWithQueryTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+        List<SimpleExtendedModel> models = findWithQuery(SimpleExtendedModel.class, "Select * from " +
+                                          NamingHelper.toTableName(SimpleExtendedModel.class) +
+                                          " where id >= ? ", "50");
+        for (SimpleExtendedModel model : models) {
+            assertEquals(75, model.getId(), 25L);
+        }
+    }
+
+    @Test
+    @SuppressWarnings("all")
+    public void findByIdTest() throws Exception {
+        save(new SimpleExtendedModel());
+        assertEquals(Long.valueOf(1L), findById(SimpleExtendedModel.class, 1L).getId());
+    }
+
+    @Test
+    public void findByIdIntegerTest() throws Exception {
+        save(new SimpleExtendedModel());
+        assertEquals(Long.valueOf(1L), findById(SimpleExtendedModel.class, 1).getId());
+    }
+
+    @Test
+    public void findByIdStringsNullTest() throws Exception {
+        save(new SimpleExtendedModel());
+        assertEquals(0, findById(SimpleExtendedModel.class, new String[]{""}).size());
+    }
+
+    @Test
+    public void findByIdStringsOneTest() throws Exception {
+        save(new SimpleExtendedModel());
+        List<SimpleExtendedModel> models = findById(SimpleExtendedModel.class, new String[]{"1"});
+        assertEquals(1, models.size());
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+    }
+
+    @Test
+    public void findByIdStringsTwoTest() throws Exception {
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+        save(new SimpleExtendedModel());
+
+        List<SimpleExtendedModel> models = findById(SimpleExtendedModel.class, new String[]{"1", "3"});
+
+        assertEquals(2, models.size());
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+    }
+
+    @Test
+    public void findByIdStringsManyTest() throws Exception {
+        for (int i = 1; i <= 10; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        List<SimpleExtendedModel> models = findById(SimpleExtendedModel.class, new String[]{"1", "3", "6", "10"});
+
+        assertEquals(4, models.size());
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+        assertEquals(Long.valueOf(6L), models.get(2).getId());
+        assertEquals(Long.valueOf(10L), models.get(3).getId());
+    }
+
+    @Test
+    public void findByIdStringsOrderTest() throws Exception {
+        for (int i = 1; i <= 10; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        List<SimpleExtendedModel> models = findById(SimpleExtendedModel.class, new String[]{"10", "6", "3", "1"});
+
+        assertEquals(4, models.size());
+        // The order of the query doesn't matter
+        assertEquals(Long.valueOf(1L), models.get(0).getId());
+        assertEquals(Long.valueOf(3L), models.get(1).getId());
+        assertEquals(Long.valueOf(6L), models.get(2).getId());
+        assertEquals(Long.valueOf(10L), models.get(3).getId());
+    }
+
+    @Test
+    public void findByIdNullTest() throws Exception {
+        save(new SimpleExtendedModel());
+        assertNull(findById(SimpleExtendedModel.class, 2L));
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        Iterator<SimpleExtendedModel> cursor = findAll(SimpleExtendedModel.class);
+
+        for (int i = 1; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleExtendedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test
+    public void findAsIteratorTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        Iterator<SimpleExtendedModel> cursor = findAsIterator(SimpleExtendedModel.class, "id >= ?", "50");
+
+        for (int i = 50; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleExtendedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test
+    public void findWithQueryAsIteratorTest() throws Exception {
+        for (int i = 1; i <= 100; i++) {
+            save(new SimpleExtendedModel());
+        }
+
+        Iterator<SimpleExtendedModel> cursor = findWithQueryAsIterator(SimpleExtendedModel.class,
+                                                    "Select * from " +
+                                                    NamingHelper.toTableName(SimpleExtendedModel.class) +
+                                                    " where id >= ? ", "50");
+        for (int i = 50; i <= 100; i++) {
+            assertTrue(cursor.hasNext());
+            SimpleExtendedModel model = cursor.next();
+            assertNotNull(model);
+            assertEquals(Long.valueOf(i), model.getId());
+        }
+    }
+
+    @Test(expected=NoSuchElementException.class)
+    public void findAsIteratorOutOfBoundsTest() throws Exception {
+        save(new SimpleExtendedModel());
+        Iterator<SimpleExtendedModel> cursor = findAsIterator(SimpleExtendedModel.class, id, "1");
+        assertTrue(cursor.hasNext());
+        SimpleExtendedModel model = cursor.next();
+        assertNotNull(model);
+        assertEquals(Long.valueOf(1), model.getId());
+        // This should throw a NoSuchElementException
+        cursor.next();
+    }
+
+    @Test(expected=UnsupportedOperationException.class)
+    public void disallowRemoveCursorTest() throws Exception {
+        save(new SimpleExtendedModel());
+        Iterator<SimpleExtendedModel> cursor = findAsIterator(SimpleExtendedModel.class, id, "1");
+        assertTrue(cursor.hasNext());
+        SimpleExtendedModel model = cursor.next();
+        assertNotNull(model);
+        assertEquals(Long.valueOf(1), model.getId());
+        // This should throw a UnsupportedOperationException
+        cursor.remove();
+    }
+
+    @Test
+    public void vacuumTest() throws Exception {
+        executeQuery("Vacuum");
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/record/StringFieldTests.java b/library/src/test/java/com/orm/record/StringFieldTests.java
new file mode 100644
index 00000000..d9641ad7
--- /dev/null
+++ b/library/src/test/java/com/orm/record/StringFieldTests.java
@@ -0,0 +1,51 @@
+package com.orm.record;
+
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.StringFieldAnnotatedModel;
+import com.orm.model.StringFieldExtendedModel;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static com.orm.SugarRecord.save;
+import static com.orm.SugarRecord.findById;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class StringFieldTests {
+    private String string = "Test String";
+
+    @Test
+    public void nullStringExtendedTest() {
+        save(new StringFieldExtendedModel());
+        StringFieldExtendedModel model = findById(StringFieldExtendedModel.class, 1);
+        assertNull(model.getString());
+    }
+
+    @Test
+    public void nullStringAnnotatedTest() {
+        save(new StringFieldAnnotatedModel());
+        StringFieldAnnotatedModel model = findById(StringFieldAnnotatedModel.class, 1);
+        assertNull(model.getString());
+    }
+
+    @Test
+    public void stringExtendedTest() {
+        save(new StringFieldExtendedModel(string));
+        StringFieldExtendedModel model = findById(StringFieldExtendedModel.class, 1);
+        assertEquals(string, model.getString());
+    }
+
+    @Test
+    public void stringAnnotatedTest() {
+        save(new StringFieldAnnotatedModel(string));
+        StringFieldAnnotatedModel model = findById(StringFieldAnnotatedModel.class, 1);
+        assertEquals(string, model.getString());
+    }
+}
diff --git a/library/src/test/java/com/orm/record/UpdateInTxTest.java b/library/src/test/java/com/orm/record/UpdateInTxTest.java
new file mode 100644
index 00000000..2c5a032f
--- /dev/null
+++ b/library/src/test/java/com/orm/record/UpdateInTxTest.java
@@ -0,0 +1,70 @@
+package com.orm.record;
+
+import com.orm.SugarRecord;
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.TestRecord;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class UpdateInTxTest {
+
+    @Test
+    public void testUpdateInTx() {
+        final TestRecord record = new TestRecord();
+        record.setName("lalala");
+
+        Long id = SugarRecord.save(record);
+        record.setId(id);
+
+        final TestRecord record1 = new TestRecord();
+        record1.setName("lalala");
+
+        Long id1 = SugarRecord.save(record1);
+        record1.setId(id1);
+
+        final TestRecord record2 = new TestRecord();
+        record2.setName("lalala");
+
+        Long id2 = SugarRecord.save(record2);
+        record2.setId(id2);
+
+        final TestRecord record3 = new TestRecord();
+        record3.setName("lalala");
+
+        Long id3 = SugarRecord.save(record3);
+        record3.setId(id3);
+
+        final TestRecord record4 = new TestRecord();
+        record4.setName("lalala");
+
+        Long id4 = SugarRecord.save(record4);
+        record.setId(id4);
+
+        record.setName("fulano");
+        record1.setName("fulano");
+        record2.setName("fulano");
+        record3.setName("fulano");
+        record4.setName("fulano");
+
+        SugarRecord.updateInTx(record, record1, record2, record3, record4);
+
+        List<TestRecord> list = SugarRecord.listAll(TestRecord.class);
+
+        for (TestRecord r: list) {
+            Assert.assertEquals(record.getName(), r.getName());
+        }
+    }
+}
diff --git a/library/src/test/java/com/orm/util/ContextUtilTest.java b/library/src/test/java/com/orm/util/ContextUtilTest.java
new file mode 100644
index 00000000..9ce16c7d
--- /dev/null
+++ b/library/src/test/java/com/orm/util/ContextUtilTest.java
@@ -0,0 +1,62 @@
+package com.orm.util;
+
+import android.content.Context;
+
+import com.orm.app.ClientApp;
+import com.orm.SugarContext;
+import com.orm.dsl.BuildConfig;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
+import static com.orm.util.ContextUtil.*;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ContextUtilTest {
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        ContextUtil contextUtil = ContextUtil.class.getDeclaredConstructor().newInstance();
+        assertNull(contextUtil);
+    }
+
+
+    @Test
+    public void testInitContext() {
+        assertNotNull(getContext());
+    }
+
+    @Test
+    public void testGetAssets() {
+        assertNotNull(getAssets());
+    }
+
+    @Test
+    public void testGetPackageManager() {
+        assertNotNull(getPackageManager());
+    }
+
+    @Test
+    public void testGetPackageName() {
+        assertNotNull(getPackageName());
+    }
+
+    @Test
+    public void testGetPreferences() {
+        assertNotNull(getSharedPreferences("lala", Context.MODE_PRIVATE));
+    }
+
+    @Test
+    public void testTerminateContext() {
+        SugarContext.terminate();
+        assertNull(getContext());
+    }
+}
diff --git a/library/src/test/java/com/orm/util/KeyWordUtilTest.java b/library/src/test/java/com/orm/util/KeyWordUtilTest.java
new file mode 100644
index 00000000..417f1b21
--- /dev/null
+++ b/library/src/test/java/com/orm/util/KeyWordUtilTest.java
@@ -0,0 +1,36 @@
+package com.orm.util;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNull;
+
+/**
+ * @author jonatan.salas
+ */
+public final class KeyWordUtilTest {
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        KeyWordUtil keyWordUtil = KeyWordUtil.class.getDeclaredConstructor().newInstance();
+        assertNull(keyWordUtil);
+    }
+
+    @Test
+    public void testKeyWord() {
+        assertEquals(true, KeyWordUtil.isKeyword("SELECT"));
+        assertEquals(true, KeyWordUtil.isKeyword("TRANSACTION"));
+        assertEquals(true, KeyWordUtil.isKeyword("MATCH"));
+        assertEquals(true, KeyWordUtil.isKeyword("AS"));
+        assertEquals(true, KeyWordUtil.isKeyword("NOTNULL"));
+        assertEquals(true, KeyWordUtil.isKeyword("NOT"));
+        assertEquals(false, KeyWordUtil.isKeyword("PERSONS"));
+        assertEquals(false, KeyWordUtil.isKeyword("NAME"));
+        assertEquals(false, KeyWordUtil.isKeyword("LOCATION"));
+    }
+
+    @Test
+    public void testNullKeyword() {
+        assertEquals(false, KeyWordUtil.isKeyword(null));
+    }
+}
diff --git a/library/src/test/java/com/orm/util/MigrationFileParserTest.java b/library/src/test/java/com/orm/util/MigrationFileParserTest.java
new file mode 100644
index 00000000..9b2d87ce
--- /dev/null
+++ b/library/src/test/java/com/orm/util/MigrationFileParserTest.java
@@ -0,0 +1,44 @@
+package com.orm.util;
+
+import org.junit.Test;
+
+import java.lang.String;
+
+import static junit.framework.Assert.assertEquals;
+
+public final class MigrationFileParserTest {
+
+    @Test
+    public void testSingleLineStatement() {
+        MigrationFileParser singleLineComment = new MigrationFileParser("insert into table--comment");
+
+        String statements[] = singleLineComment.getStatements();
+        assertEquals("Testing single line statement size",1,statements.length);
+        assertEquals("Testing single line statement content","insert into table",statements[0]);
+
+        singleLineComment = new MigrationFileParser("insert into table--comment\n");
+
+        singleLineComment.getStatements();
+        assertEquals("Testing single line statement size",1,statements.length);
+        assertEquals("Testing single line statement content","insert into table",statements[0]);
+    }
+
+    @Test
+    public void testMultiLineComment() {
+        MigrationFileParser multiLineComment = new MigrationFileParser("insert into table /**comment \n new line 2 \n new line 3 */hello");
+
+        String statements[] = multiLineComment.getStatements();
+        assertEquals("Testing multiline statement size",1,statements.length);
+        assertEquals("Testing multiline comment","insert into table hello",statements[0]);
+    }
+
+    @Test
+    public void testMixedComment() {
+        MigrationFileParser mixedComment = new MigrationFileParser("insert into/*multiline\n **comment*/--comment");
+
+        String statements[] = mixedComment.getStatements();
+
+        assertEquals("Testing mixed comment statement size",1,statements.length);
+        assertEquals("Testing mixed comment statments", "insert into", statements[0]);
+    }
+}
diff --git a/library/src/test/java/com/orm/util/NumberComparatorTest.java b/library/src/test/java/com/orm/util/NumberComparatorTest.java
new file mode 100644
index 00000000..aaabf453
--- /dev/null
+++ b/library/src/test/java/com/orm/util/NumberComparatorTest.java
@@ -0,0 +1,48 @@
+package com.orm.util;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author jonatan.salas
+ */
+public final class NumberComparatorTest {
+    private NumberComparator comparator;
+
+    @Before
+    public void setUp() {
+        comparator = new NumberComparator();
+    }
+
+    @Test
+    public void testNumberComparatorWithoutNumbers() {
+        int result = comparator.compare("hola", "hola");
+        assertEquals(0, result);
+    }
+
+    @Test
+    public void testNumberComparatorWithNumbers() {
+        int result = comparator.compare("1", "2");
+        assertEquals(-1, result);
+    }
+
+    @Test
+    public void testComparatorWithNumbers() {
+        int result = comparator.compare("4", "2");
+        assertEquals(1, result);
+    }
+
+    @Test
+    public void testCompareRight() {
+        int result = comparator.compareRight("hola", "hola");
+        assertEquals(0, result);
+    }
+
+    @Test
+    public void testCharAt() {
+        Character c = NumberComparator.charAt("Hola", 0);
+        assertEquals("H", c.toString());
+    }
+}
diff --git a/library/src/test/java/com/orm/util/ReflectionUtilTest.java b/library/src/test/java/com/orm/util/ReflectionUtilTest.java
new file mode 100644
index 00000000..a93e059a
--- /dev/null
+++ b/library/src/test/java/com/orm/util/ReflectionUtilTest.java
@@ -0,0 +1,99 @@
+package com.orm.util;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+import com.orm.SugarContext;
+import com.orm.SugarRecord;
+import com.orm.app.ClientApp;
+import com.orm.dsl.BuildConfig;
+import com.orm.model.TestRecord;
+import com.orm.model.foreignnull.OriginRecord;
+import com.orm.query.Select;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author jonatan.salas
+ */
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(sdk = 18, constants = BuildConfig.class, application = ClientApp.class, packageName = "com.orm.model", manifest = Config.NONE)
+public final class ReflectionUtilTest {
+
+    @Test(expected = IllegalAccessException.class)
+    public void testPrivateConstructor() throws Exception {
+        ReflectionUtil reflectionUtil = ReflectionUtil.class.getDeclaredConstructor().newInstance();
+        Assert.assertNull(reflectionUtil);
+    }
+
+    @Test
+    public void testGetTableFields() {
+        List<Field> fieldList = ReflectionUtil.getTableFields(TestRecord.class);
+        List<String> strings = new ArrayList<>();
+
+        for (Field field: fieldList) {
+            strings.add(field.getName());
+        }
+
+        Assert.assertEquals(true, strings.contains("id"));
+        Assert.assertEquals(true, strings.contains("name"));
+    }
+
+    @Test(expected = NoSuchFieldException.class)
+    public void testAddFieldValueToColumn() throws NoSuchFieldException {
+        SugarContext context = SugarContext.getSugarContext();
+        TestRecord record = new TestRecord();
+        record.setName("lala");
+
+        Field column = TestRecord.class.getField("name");
+        ContentValues values = new ContentValues();
+
+        ReflectionUtil.addFieldValueToColumn(values, column, record, context.getEntitiesMap());
+
+        Assert.assertEquals(record.getName(), values.getAsString("NAME"));
+    }
+
+    @Test
+    public void testSetFieldValueForId() {
+        TestRecord record = new TestRecord();
+        record.setName("Bla bla");
+
+        ReflectionUtil.setFieldValueForId(record, 1L);
+        Assert.assertEquals(1L, record.getId().longValue());
+    }
+
+    @Test
+    public void testGetAllClasses() {
+        List<Class> classes = ReflectionUtil.getDomainClasses();
+        Assert.assertEquals(46, classes.size());
+    }
+
+    @Test(expected = NoSuchFieldException.class)
+    public void testSetFieldValueFromCursor() throws NoSuchFieldException {
+        final TestRecord record = new TestRecord().setName("bla bla");
+        Long id = record.save();
+        record.setId(id);
+
+        Cursor cursor = Select.from(TestRecord.class).getCursor();
+
+        TestRecord testRecord = new TestRecord();
+        Field field = TestRecord.class.getField("name");
+
+        ReflectionUtil.setFieldValueFromCursor(cursor, field, testRecord);
+    }
+
+    @Test
+    public void testForeignNull() throws NoSuchFieldException {
+        final OriginRecord record = new OriginRecord(null,null);
+        SugarRecord.save(record);
+    }
+}
diff --git a/library/src/test/java/com/orm/util/SugarConfigTest.java b/library/src/test/java/com/orm/util/SugarConfigTest.java
new file mode 100644
index 00000000..82943e9e
--- /dev/null
+++ b/library/src/test/java/com/orm/util/SugarConfigTest.java
@@ -0,0 +1,33 @@
+package com.orm.util;
+
+import com.orm.model.TestRecord;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * @author jonatan.salas
+ */
+public final class SugarConfigTest {
+
+    @Test
+    public void testSetGetFields() {
+        Field[] fields = TestRecord.class.getFields();
+
+        List<Field> fieldList = Arrays.asList(fields);
+        SugarConfig.setFields(TestRecord.class, fieldList);
+
+        Assert.assertEquals(fieldList, SugarConfig.getFields(TestRecord.class));
+    }
+
+    @Test
+    public void testClearCache() {
+        SugarConfig.clearCache();
+        Assert.assertEquals(true, SugarConfig.fields.isEmpty());
+    }
+}
diff --git a/library/test/com/orm/NamingHelperTest.java b/library/test/com/orm/NamingHelperTest.java
deleted file mode 100644
index 28c705a0..00000000
--- a/library/test/com/orm/NamingHelperTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.orm;
-
-import com.orm.util.NamingHelper;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertEquals;
-
-public class NamingHelperTest {
-    @Test
-    public void testToSQLNameCaseConversion() throws Exception {
-        assertToSqlNameEquals("TESTLOWERCASE", "testlowercase");
-        assertToSqlNameEquals("TESTUPPERCASE", "TESTUPPERCASE");
-    }
-
-    @Test
-    public void testToSQLNameUnderscore() {
-        assertToSqlNameEquals("TEST_UNDERSCORE", "testUnderscore");
-        assertToSqlNameEquals("AB_CD", "AbCd");
-        assertToSqlNameEquals("AB_CD", "ABCd");
-        assertToSqlNameEquals("AB_CD", "AbCD");
-        assertToSqlNameEquals("SOME_DETAILS_OBJECT", "SomeDetailsObject");
-        assertToSqlNameEquals("H_OL_A","hOlA");
-        assertToSqlNameEquals("A","a");
-    }
-
-    /**
-     * Helper method that asserts a CamelCaseString is converted to UPPER_CASE_UNDER_SCORE.
-     *
-     * @param expected  a CamelCaseString
-     * @param actual    the expected UPPER_CASE_UNDER_SCORE string
-     */
-    private static void assertToSqlNameEquals(String expected, String actual) {
-        assertEquals(expected, NamingHelper.toSQLNameDefault(actual));
-    }
-
-}
diff --git a/library/test/com/orm/query/DummyContext.java b/library/test/com/orm/query/DummyContext.java
deleted file mode 100644
index cb7c6f4b..00000000
--- a/library/test/com/orm/query/DummyContext.java
+++ /dev/null
@@ -1,444 +0,0 @@
-package com.orm.query;
-
-import android.content.*;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.res.AssetManager;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.database.DatabaseErrorHandler;
-import android.database.sqlite.SQLiteDatabase;
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.UserHandle;
-import android.view.Display;
-
-import java.io.*;
-
-public class DummyContext extends Context{
-    @Override
-    public AssetManager getAssets() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Resources getResources() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public PackageManager getPackageManager() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public ContentResolver getContentResolver() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Looper getMainLooper() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Context getApplicationContext() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void setTheme(int i) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Resources.Theme getTheme() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public ClassLoader getClassLoader() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public String getPackageName() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public ApplicationInfo getApplicationInfo() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public String getPackageResourcePath() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public String getPackageCodePath() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public SharedPreferences getSharedPreferences(String s, int i) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public FileInputStream openFileInput(String s) throws FileNotFoundException {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public FileOutputStream openFileOutput(String s, int i) throws FileNotFoundException {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public boolean deleteFile(String s) {
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getFileStreamPath(String s) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getFilesDir() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getExternalFilesDir(String s) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getObbDir() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getCacheDir() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getExternalCacheDir() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public String[] fileList() {
-        return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getDir(String s, int i) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public SQLiteDatabase openOrCreateDatabase(String s, int i, SQLiteDatabase.CursorFactory cursorFactory) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public SQLiteDatabase openOrCreateDatabase(String s, int i, SQLiteDatabase.CursorFactory cursorFactory, DatabaseErrorHandler databaseErrorHandler) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public boolean deleteDatabase(String s) {
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public File getDatabasePath(String s) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public String[] databaseList() {
-        return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Drawable getWallpaper() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Drawable peekWallpaper() {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int getWallpaperDesiredMinimumWidth() {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int getWallpaperDesiredMinimumHeight() {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void setWallpaper(Bitmap bitmap) throws IOException {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void setWallpaper(InputStream inputStream) throws IOException {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void clearWallpaper() throws IOException {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void startActivity(Intent intent) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void startActivity(Intent intent, Bundle options) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-
-    @Override
-    public void startActivities(Intent[] intents) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void startActivities(Intent[] intents, Bundle options) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-
-    @Override
-    public void startIntentSender(IntentSender intentSender, Intent intent, int i, int i1, int i2) throws IntentSender.SendIntentException {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) throws IntentSender.SendIntentException {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendBroadcast(Intent intent, String s) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String s) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendOrderedBroadcast(Intent intent, String s, BroadcastReceiver broadcastReceiver, Handler handler, int i, String s1, Bundle bundle) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendStickyBroadcast(Intent intent) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver broadcastReceiver, Handler handler, int i, String s, Bundle bundle) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void removeStickyBroadcast(Intent intent) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendStickyBroadcastAsUser(Intent intent, UserHandle user) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void removeStickyBroadcastAsUser(Intent intent, UserHandle user) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver broadcastReceiver, IntentFilter intentFilter) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Intent registerReceiver(BroadcastReceiver broadcastReceiver, IntentFilter intentFilter, String s, Handler handler) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void unregisterReceiver(BroadcastReceiver broadcastReceiver) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public ComponentName startService(Intent intent) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public boolean stopService(Intent intent) {
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public boolean bindService(Intent intent, ServiceConnection serviceConnection, int i) {
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void unbindService(ServiceConnection serviceConnection) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public boolean startInstrumentation(ComponentName componentName, String s, Bundle bundle) {
-        return false;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Object getSystemService(String s) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkPermission(String s, int i, int i1) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkCallingPermission(String s) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkCallingOrSelfPermission(String s) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforcePermission(String s, int i, int i1, String s1) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceCallingPermission(String s, String s1) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceCallingOrSelfPermission(String s, String s1) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void grantUriPermission(String s, Uri uri, int i) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void revokeUriPermission(Uri uri, int i) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkUriPermission(Uri uri, int i, int i1, int i2) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkCallingUriPermission(Uri uri, int i) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkCallingOrSelfUriPermission(Uri uri, int i) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public int checkUriPermission(Uri uri, String s, String s1, int i, int i1, int i2) {
-        return 0;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceUriPermission(Uri uri, int i, int i1, int i2, String s) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceCallingUriPermission(Uri uri, int i, String s) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceCallingOrSelfUriPermission(Uri uri, int i, String s) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public void enforceUriPermission(Uri uri, String s, String s1, int i, int i1, int i2, String s2) {
-        //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Context createPackageContext(String s, int i) throws PackageManager.NameNotFoundException {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Context createConfigurationContext(Configuration overrideConfiguration) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    @Override
-    public Context createDisplayContext(Display display) {
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-}
diff --git a/library/test/com/orm/query/SelectTest.java b/library/test/com/orm/query/SelectTest.java
deleted file mode 100644
index a0fa01e9..00000000
--- a/library/test/com/orm/query/SelectTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package com.orm.query;
-
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static com.orm.query.Condition.prop;
-import static junit.framework.Assert.assertEquals;
-
-public class SelectTest {
-
-    @Test
-    public void testMergeCondition(){
-        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
-        assertEquals("test = ? ", where.getWhereCond());
-        assertEquals(1, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-
-        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
-        assertEquals("test = ?  AND prop = ? ", where.getWhereCond());
-        assertEquals(2, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-        assertEquals("2", where.getArgs()[1]);
-    }
-
-
-    @Test
-    public void testWhere(){
-        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
-        assertEquals("test = ? ", where.getWhereCond());
-        assertEquals(1, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-
-        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
-        assertEquals("test = ?  AND prop = ? ", where.getWhereCond());
-        assertEquals(2, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-        assertEquals("2", where.getArgs()[1]);
-    }
-
-
-    @Test
-    public void testWhereOr(){
-        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
-        assertEquals("test = ? ", where.getWhereCond());
-        assertEquals(1, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-
-        where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
-        assertEquals("test = ?  OR prop = ? ", where.getWhereCond());
-        assertEquals(2, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-        assertEquals("2", where.getArgs()[1]);
-    }
-
-    @Test
-    public void testAnd(){
-        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
-        assertEquals("test = ? ", where.getWhereCond());
-        assertEquals(1, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-
-        where.and(Condition.prop("prop").eq(2));
-
-        assertEquals("test = ?  AND prop = ? ", where.getWhereCond());
-        assertEquals(2, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-        assertEquals("2", where.getArgs()[1]);
-    }
-
-    @Test
-    public void testOr(){
-        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
-        assertEquals("test = ? ", where.getWhereCond());
-        assertEquals(1, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-
-        where.or(Condition.prop("prop").eq(2));
-
-        assertEquals("test = ?  OR prop = ? ", where.getWhereCond());
-        assertEquals(2, where.getArgs().length);
-        assertEquals("satya", where.getArgs()[0]);
-        assertEquals("2", where.getArgs()[1]);
-    }
-
-
-}
diff --git a/library/test/com/orm/query/TestRecord.java b/library/test/com/orm/query/TestRecord.java
deleted file mode 100644
index 50997205..00000000
--- a/library/test/com/orm/query/TestRecord.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.orm.query;
-
-import android.content.Context;
-import com.orm.SugarRecord;
-
-public class TestRecord extends SugarRecord {
-
-    private String name;
-
-    public TestRecord(Context context) {
-        super();
-    }
-}
diff --git a/maven_push.gradle b/maven_push.gradle
new file mode 100644
index 00000000..b741e61b
--- /dev/null
+++ b/maven_push.gradle
@@ -0,0 +1,92 @@
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+def sonatypeRepositoryUrl
+if (isReleaseBuild()) {
+    println 'RELEASE BUILD'
+    sonatypeRepositoryUrl = hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+} else {
+    println 'DEBUG BUILD'
+    sonatypeRepositoryUrl = hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+def getRepositoryUsername() {
+    return hasProperty('nexusUsername') ? nexusUsername : ""
+}
+
+def getRepositoryPassword() {
+    return hasProperty('nexusPassword') ? nexusPassword : ""
+}
+
+afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+                pom.artifactId = POM_ARTIFACT_ID
+
+                repository(url: sonatypeRepositoryUrl) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+
+                pom.project {
+                    name POM_NAME
+                    packaging POM_PACKAGING
+                    description POM_DESCRIPTION
+                    url POM_URL
+
+                    scm {
+                        url POM_SCM_URL
+                        connection POM_SCM_CONNECTION
+                        developerConnection POM_SCM_DEV_CONNECTION
+                    }
+
+                    licenses {
+                        license {
+                            name POM_LICENCE_NAME
+                            url POM_LICENCE_URL
+                            distribution POM_LICENCE_DIST
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id POM_DEVELOPER_ID
+                            name POM_DEVELOPER_NAME
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+
+    task androidJavadocs(type: Javadoc) {
+        source = android.sourceSets.main.java.sourceFiles
+    }
+
+    task androidJavadocsJar(type: Jar) {
+        classifier = 'javadoc'
+        //basename = artifact_id
+        from androidJavadocs.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+        classifier = 'sources'
+        //basename = artifact_id
+        from android.sourceSets.main.java.sourceFiles
+    }
+
+    artifacts {
+        //archives packageReleaseJar
+        archives androidSourcesJar
+        archives androidJavadocsJar
+    }
+}
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..507c9f4a
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':library'
+include ':example'
