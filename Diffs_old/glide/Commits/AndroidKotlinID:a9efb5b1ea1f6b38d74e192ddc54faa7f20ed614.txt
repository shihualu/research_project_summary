diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
index 5c5475f08..3cf5d6abf 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -32,6 +32,7 @@
  * runtime.
  *
  * <p>The generated class looks something like this:
+ *
  * <pre>
  * <code>
  *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
@@ -78,8 +79,7 @@
 final class AppModuleGenerator {
   static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
   private static final String GLIDE_LOG_TAG = "Glide";
-  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
-      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME = "GeneratedAppGlideModuleImpl";
   private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
 
   private final ProcessorUtil processorUtil;
@@ -90,8 +90,7 @@
 
   TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
     ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
-    List<String> excludedGlideModuleClassNames =
-        getExcludedGlideModuleClassNames(appGlideModule);
+    List<String> excludedGlideModuleClassNames = getExcludedGlideModuleClassNames(appGlideModule);
 
     List<String> orderedLibraryGlideModuleClassNames =
         new ArrayList<>(libraryGlideModuleClassNames);
@@ -114,16 +113,15 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
         MethodSpec.methodBuilder("applyOptions")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ParameterSpec.builder(
-                ClassName.get("android.content", "Context"), "context")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(
-                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
-                .addAnnotation(nonNull())
-                .build()
-            )
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("android.content", "Context"), "context")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(
+                        ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+                    .addAnnotation(nonNull())
+                    .build())
             .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
             .build();
 
@@ -135,21 +133,22 @@ TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClas
             .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
             .build();
 
-    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
-        .addModifiers(Modifier.FINAL)
-        .addAnnotation(
-            AnnotationSpec.builder(SuppressWarnings.class)
-                .addMember("value", "$S", "deprecation")
-                .build()
-        )
-        .superclass(
-            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
-        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
-        .addMethod(constructor)
-        .addMethod(applyOptions)
-        .addMethod(registerComponents)
-        .addMethod(isManifestParsingEnabled)
-        .addMethod(getExcludedModuleClasses);
+    Builder builder =
+        TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+            .addModifiers(Modifier.FINAL)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "deprecation")
+                    .build())
+            .superclass(
+                ClassName.get(
+                    GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+            .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+            .addMethod(constructor)
+            .addMethod(applyOptions)
+            .addMethod(registerComponents)
+            .addMethod(isManifestParsingEnabled)
+            .addMethod(getExcludedModuleClasses);
 
     ClassName generatedRequestManagerFactoryClassName =
         ClassName.get(
@@ -175,17 +174,19 @@ private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedC
         ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
     ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
         ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
-    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
-        .addModifiers(Modifier.PUBLIC)
-        .addAnnotation(Override.class)
-        .addAnnotation(nonNull())
-        .returns(setOfClassOfWildcardOfObject);
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder("getExcludedModuleClasses")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addAnnotation(nonNull())
+            .returns(setOfClassOfWildcardOfObject);
 
     if (excludedClassNames.isEmpty()) {
       builder.addStatement("return $T.emptySet()", Collections.class);
     } else {
       builder.addStatement(
-          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          "$T excludedClasses = new $T()",
+          setOfClassOfWildcardOfObject,
           hashSetOfClassOfWildcardOfObject);
       for (String excludedClassName : excludedClassNames) {
         // TODO: Remove this when we no longer support manifest parsing.
@@ -206,21 +207,18 @@ private MethodSpec generateRegisterComponents(
         MethodSpec.methodBuilder("registerComponents")
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(ParameterSpec.builder(
-                ClassName.get("android.content", "Context"), "context")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(
-                ClassName.get("com.bumptech.glide", "Glide"), "glide")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(
-                ClassName.get("com.bumptech.glide", "Registry"), "registry")
-                .addAnnotation(nonNull())
-                .build()
-            );
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("android.content", "Context"), "context")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("com.bumptech.glide", "Glide"), "glide")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(ClassName.get("com.bumptech.glide", "Registry"), "registry")
+                    .addAnnotation(nonNull())
+                    .build());
 
     for (String glideModule : libraryGlideModuleClassNames) {
       if (excludedGlideModuleClassNames.contains(glideModule)) {
@@ -235,7 +233,8 @@ private MethodSpec generateRegisterComponents(
     return registerComponents.build();
   }
 
-  private MethodSpec generateConstructor(ClassName appGlideModule,
+  private MethodSpec generateConstructor(
+      ClassName appGlideModule,
       Collection<String> libraryGlideModuleClassNames,
       Collection<String> excludedGlideModuleClassNames) {
     MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
@@ -244,17 +243,26 @@ private MethodSpec generateConstructor(ClassName appGlideModule,
     ClassName androidLogName = ClassName.get("android.util", "Log");
 
     // Add some log lines to indicate to developers which modules where discovered.
-    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
-        androidLogName, GLIDE_LOG_TAG, androidLogName);
-    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+    constructorBuilder.beginControlFlow(
+        "if ($T.isLoggable($S, $T.DEBUG))", androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement(
+        "$T.d($S, $S)",
+        androidLogName,
+        GLIDE_LOG_TAG,
         "Discovered AppGlideModule from annotation: " + appGlideModule);
     // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
     for (String glideModule : libraryGlideModuleClassNames) {
       if (excludedGlideModuleClassNames.contains(glideModule)) {
-        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        constructorBuilder.addStatement(
+            "$T.d($S, $S)",
+            androidLogName,
+            GLIDE_LOG_TAG,
             "AppGlideModule excludes LibraryGlideModule from annotation: " + glideModule);
       } else {
-        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        constructorBuilder.addStatement(
+            "$T.d($S, $S)",
+            androidLogName,
+            GLIDE_LOG_TAG,
             "Discovered LibraryGlideModule from annotation: " + glideModule);
       }
     }
@@ -263,8 +271,8 @@ private MethodSpec generateConstructor(ClassName appGlideModule,
   }
 
   private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
-    Set<String> names = processorUtil.findClassValuesFromAnnotationOnClassAsNames(
-        appGlideModule, Excludes.class);
+    Set<String> names =
+        processorUtil.findClassValuesFromAnnotationOnClassAsNames(appGlideModule, Excludes.class);
     List<String> result = new ArrayList<>(names);
     Collections.sort(result);
     return result;
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
index 3469eff24..9e167cf02 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -14,9 +14,8 @@
 import javax.lang.model.element.TypeElement;
 
 /**
- * Runs the final steps of Glide's annotation process and generates the combined
- * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},
- * {@code com.bumptech.glide.RequestManager}, and
+ * Runs the final steps of Glide's annotation process and generates the combined {@code
+ * AppGlideModule}, {@code com.bumptech.glide.Glide}, {@code com.bumptech.glide.RequestManager}, and
  * {@code com.bumptech.glide.request.RequestOptions} classes.
  */
 final class AppModuleProcessor {
@@ -46,11 +45,11 @@
   }
 
   void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
-     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
-       if (processorUtil.isAppGlideModule(element)) {
-         appGlideModules.add(element);
-       }
-     }
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      if (processorUtil.isAppGlideModule(element)) {
+        appGlideModules.add(element);
+      }
+    }
 
     processorUtil.debugLog("got app modules: " + appGlideModules);
 
@@ -84,8 +83,8 @@ boolean maybeWriteAppModule() {
     String generatedCodePackageName = appModule.getEnclosingElement().toString();
 
     TypeSpec generatedRequestOptions =
-          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
-      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+        requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+    writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
 
     TypeSpec generatedRequestBuilder =
         requestBuilderGenerator.generate(
@@ -94,7 +93,9 @@ boolean maybeWriteAppModule() {
 
     TypeSpec requestManager =
         requestManagerGenerator.generate(
-            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            generatedCodePackageName,
+            generatedRequestOptions,
+            generatedRequestBuilder,
             indexedClassNames.extensions);
     writeRequestManager(generatedCodePackageName, requestManager);
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
index eed0f1243..0e0ebfd1d 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -10,8 +10,8 @@
 import javax.lang.model.element.TypeElement;
 
 /**
- * Writes Indexer classes annotated with {@link Index} for all
- * classes found annotated with {@link GlideExtension}.
+ * Writes Indexer classes annotated with {@link Index} for all classes found annotated with {@link
+ * GlideExtension}.
  */
 final class ExtensionProcessor {
   private final ProcessorUtil processorUtil;
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
index 32a8575d9..d4f2bcd40 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -16,52 +16,48 @@
  * Generates classes based on Glide's annotations that configure Glide, add support for additional
  * resource types, and/or extend Glide's API.
  *
- * <p>This processor discovers all {@code AppGlideModule} and
- * {@code LibraryGlideModule} implementations that are
- * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
- * annotation will be ignored.
+ * <p>This processor discovers all {@code AppGlideModule} and {@code LibraryGlideModule}
+ * implementations that are annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any
+ * implementations missing the annotation will be ignored.
  *
  * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
  * annotated classes.
  *
  * <p>Multiple classes are generated by this processor:
+ *
  * <ul>
- *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a
- *      specific package that will later be used by the processor to discover all
- *      {@code LibraryGlideModule} classes.
- *   <li>For {@code AppGlideModule}s - A single
- *      {@code AppGlideModule} implementation
- *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all
- *     {@code LibraryGlideModule}s and the
- *     original {@code AppGlideModule} in the correct order when Glide is
- *     initialized.
+ *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a specific package that will
+ *       later be used by the processor to discover all {@code LibraryGlideModule} classes.
+ *   <li>For {@code AppGlideModule}s - A single {@code AppGlideModule} implementation ({@code
+ *       com.bumptech.glide.GeneratedAppGlideModule}) that calls all {@code LibraryGlideModule}s and
+ *       the original {@code AppGlideModule} in the correct order when Glide is initialized.
  *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
- *   <ul>
- *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
- *     static versions of all builder methods in the base class and both static and instance
- *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
- *     <li>If one or more methods in one or more
- *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
- *     {@link GlideType}:
- *     <ul>
- *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated
- *       method for each method annotated with
- *       {@link GlideType}.
- *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
- *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s.
- *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in
- *       the {@code com.bumptech.glide.Glide} singleton and returns the generated
- *       {@code com.bumptech.glide.RequestManager} implementation when appropriate.
- *     </ul>
- *   </ul>
+ *       <ul>
+ *         <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
+ *             static versions of all builder methods in the base class and both static and instance
+ *             versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *         <li>If one or more methods in one or more {@link
+ *             com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *             {@link GlideType}:
+ *             <ul>
+ *               <li>A {@code com.bumptech.glide.RequestManager} implementation containing a
+ *                   generated method for each method annotated with {@link GlideType}.
+ *               <li>A {@code
+ *                   com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *                   implementation that produces the generated {@code
+ *                   com.bumptech.glide.RequestManager}s.
+ *               <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static
+ *                   methods in the {@code com.bumptech.glide.Glide} singleton and returns the
+ *                   generated {@code com.bumptech.glide.RequestManager} implementation when
+ *                   appropriate.
+ *             </ul>
+ *       </ul>
  * </ul>
  *
- * <p>{@code AppGlideModule} implementations must only be included in
- * applications, not in libraries. There must be exactly one
- * {@code AppGlideModule} implementation per
- * Application. The {@code AppGlideModule} class is
- * used as a signal that all modules have been found and that the final merged
- * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ * <p>{@code AppGlideModule} implementations must only be included in applications, not in
+ * libraries. There must be exactly one {@code AppGlideModule} implementation per Application. The
+ * {@code AppGlideModule} class is used as a signal that all modules have been found and that the
+ * final merged {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
  */
 @AutoService(Processor.class)
 public final class GlideAnnotationProcessor extends AbstractProcessor {
@@ -96,25 +92,25 @@ public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
   }
 
-   /**
-    * Each round we do the following:
-    * <ol>
-    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
-    *   <li>Find all {@code LibraryGlideModule}s
-    *   <li>For each {@code LibraryGlideModule},
-    *       write an {@code Indexer} with an Annotation with the class name.
-    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
-    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},
-    *       write the {@code GeneratedAppGlideModule}.
-    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished.
-    *       Any further generation of related classes will result in errors.
-    * </ol>
-    */
+  /**
+   * Each round we do the following:
+   *
+   * <ol>
+   *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
+   *   <li>Find all {@code LibraryGlideModule}s
+   *   <li>For each {@code LibraryGlideModule}, write an {@code Indexer} with an Annotation with the
+   *       class name.
+   *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
+   *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule}, write the
+   *       {@code GeneratedAppGlideModule}. Once the {@code GeneratedAppGlideModule} is written, we
+   *       expect to be finished. Any further generation of related classes will result in errors.
+   * </ol>
+   */
   @Override
   public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
-//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {
-//      return false;
-//    }
+    //    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {
+    //      return false;
+    //    }
     processorUtil.process();
     boolean newModulesWritten = libraryModuleProcessor.processModules(env);
     boolean newExtensionWritten = extensionProcessor.processExtensions(env);
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 77c496d8b..32b04a641 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -76,7 +76,8 @@ private static void validateExtensionConstructor(Element element) {
     if (!element.getModifiers().contains(Modifier.PRIVATE)) {
       throw new IllegalArgumentException(
           "RequestOptionsExtensions must be public, with private constructors and only static"
-              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));
+              + " methods. Found a non-private constructor in: "
+              + getEnclosingClassName(element));
     }
     ExecutableElement executableElement = (ExecutableElement) element;
     if (!executableElement.getParameters().isEmpty()) {
@@ -92,11 +93,15 @@ private void validateGlideOption(ExecutableElement executableElement) {
     validateGlideOptionParameters(executableElement);
     TypeMirror returnType = executableElement.getReturnType();
     if (!isBaseRequestOptions(returnType)) {
-      throw new IllegalArgumentException("@GlideOption methods should return a"
-          + " BaseRequestOptions<?> object, but " + getQualifiedMethodName(executableElement)
-          + " returns " + returnType + ". If you're using old style @GlideOption methods, your"
-          + " method may have a void return type, but doing so is deprecated and support will be"
-          + " removed in a future version");
+      throw new IllegalArgumentException(
+          "@GlideOption methods should return a"
+              + " BaseRequestOptions<?> object, but "
+              + getQualifiedMethodName(executableElement)
+              + " returns "
+              + returnType
+              + ". If you're using old style @GlideOption methods, your"
+              + " method may have a void return type, but doing so is deprecated and support will"
+              + " be removed in a future version");
     }
     validateGlideOptionOverride(executableElement);
   }
@@ -107,16 +112,22 @@ private void validateGlideOptionAnnotations(ExecutableElement executableElement)
 
   private static void validateGlideOptionParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().isEmpty()) {
-      throw new IllegalArgumentException("@GlideOption methods must take a "
-          + "BaseRequestOptions<?> object as their first parameter, but "
-          + getQualifiedMethodName(executableElement) + " has none");
+      throw new IllegalArgumentException(
+          "@GlideOption methods must take a "
+              + "BaseRequestOptions<?> object as their first parameter, but "
+              + getQualifiedMethodName(executableElement)
+              + " has none");
     }
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
     if (!isBaseRequestOptions(expected)) {
-      throw new IllegalArgumentException("@GlideOption methods must take a"
-          + " BaseRequestOptions<?> object as their first parameter, but the first parameter in "
-          + getQualifiedMethodName(executableElement) + " is " + expected);
+      throw new IllegalArgumentException(
+          "@GlideOption methods must take a"
+              + " BaseRequestOptions<?> object as their first parameter, but the first parameter"
+              + " in "
+              + getQualifiedMethodName(executableElement)
+              + " is "
+              + expected);
     }
   }
 
@@ -128,14 +139,16 @@ private void validateGlideOptionOverride(ExecutableElement element) {
     int overrideType = processorUtil.getOverrideType(element);
     boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);
     if (isOverridingBaseRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Accidentally attempting to override a method in"
-          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation"
-          + " if this is intentional. Offending method: "
-          + getQualifiedMethodName(element));
+      throw new IllegalArgumentException(
+          "Accidentally attempting to override a method in"
+              + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation"
+              + " if this is intentional. Offending method: "
+              + getQualifiedMethodName(element));
     } else if (!isOverridingBaseRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
-      throw new IllegalArgumentException("Requested to override an existing method in"
-          + " BaseRequestOptions, but no such method was found. Offending method: "
-          + getQualifiedMethodName(element));
+      throw new IllegalArgumentException(
+          "Requested to override an existing method in"
+              + " BaseRequestOptions, but no such method was found. Offending method: "
+              + getQualifiedMethodName(element));
     }
   }
 
@@ -183,24 +196,28 @@ private void validateGlideType(ExecutableElement executableElement) {
     validateGlideTypeAnnotations(executableElement);
     if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
       String expectedClassName = getGlideTypeValue(executableElement);
-      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
-          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement)
-          + " returns: " + returnType + ". If you're using old style @GlideType methods, your"
-          + " method may have a void return type, but doing so is deprecated and support will be"
-          + " removed in a future version");
+      throw new IllegalArgumentException(
+          "@GlideType methods should return a RequestBuilder<"
+              + expectedClassName
+              + "> object, but "
+              + getQualifiedMethodName(executableElement)
+              + " returns: "
+              + returnType
+              + ". If you're using old style @GlideType methods, your"
+              + " method may have a void return type, but doing so is deprecated and support will"
+              + " be removed in a future version");
     }
     validateGlideTypeParameters(executableElement);
   }
 
   private String getGlideTypeValue(ExecutableElement executableElement) {
-    return
-        processorUtil
-            .findClassValuesFromAnnotationOnClassAsNames(
-                executableElement, GlideType.class).iterator().next();
+    return processorUtil
+        .findClassValuesFromAnnotationOnClassAsNames(executableElement, GlideType.class)
+        .iterator()
+        .next();
   }
 
-  private boolean typeMatchesExpected(
-      TypeMirror returnType, ExecutableElement executableElement) {
+  private boolean typeMatchesExpected(TypeMirror returnType, ExecutableElement executableElement) {
     if (!(returnType instanceof DeclaredType)) {
       return false;
     }
@@ -220,17 +237,21 @@ private boolean isRequestBuilder(TypeMirror typeMirror) {
 
   private static void validateGlideTypeParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().size() != 1) {
-      throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first and only parameter, but given multiple for: "
-          + getQualifiedMethodName(executableElement));
+      throw new IllegalArgumentException(
+          "@GlideType methods must take a"
+              + " RequestBuilder object as their first and only parameter, but given multiple for: "
+              + getQualifiedMethodName(executableElement));
     }
 
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror argumentType = first.asType();
     if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
-      throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first and only parameter, but given: " + argumentType
-          + " for: " + getQualifiedMethodName(executableElement));
+      throw new IllegalArgumentException(
+          "@GlideType methods must take a"
+              + " RequestBuilder object as their first and only parameter, but given: "
+              + argumentType
+              + " for: "
+              + getQualifiedMethodName(executableElement));
     }
   }
 
@@ -241,12 +262,13 @@ private void validateGlideTypeAnnotations(ExecutableElement executableElement) {
   private void validateAnnotatedNonNull(ExecutableElement executableElement) {
     Set<String> annotationNames =
         FluentIterable.from(executableElement.getAnnotationMirrors())
-            .transform(new Function<AnnotationMirror, String>() {
-              @Override
-              public String apply(AnnotationMirror input) {
-                return input.getAnnotationType().asElement().toString();
-              }
-            })
+            .transform(
+                new Function<AnnotationMirror, String>() {
+                  @Override
+                  public String apply(AnnotationMirror input) {
+                    return input.getAnnotationType().asElement().toString();
+                  }
+                })
             .toSet();
     boolean noNonNull = true;
     for (ClassName nonNull : nonNulls()) {
@@ -256,12 +278,16 @@ public String apply(AnnotationMirror input) {
       }
     }
     if (noNonNull) {
-      processingEnvironment.getMessager().printMessage(
-          Kind.WARNING,
-          getQualifiedMethodName(executableElement)
-              + " is missing the " + nonNull().reflectionName() + " annotation,"
-              + " please add it to ensure that your extension methods are always returning non-null"
-              + " values");
+      processingEnvironment
+          .getMessager()
+          .printMessage(
+              Kind.WARNING,
+              getQualifiedMethodName(executableElement)
+                  + " is missing the "
+                  + nonNull().reflectionName()
+                  + " annotation,"
+                  + " please add it to ensure that your extension methods are always returning"
+                  + " non-null values");
     }
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
index c1720e466..e44fbe196 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -23,8 +23,9 @@
  * Generates a Glide look-alike that acts as the entry point to the generated API
  * (GlideApp.with(...)).
  *
- * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
- * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name is
+ * configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ *
  * <pre>
  * <code>
  * public final class GlideApp {
@@ -70,16 +71,12 @@
  * </pre>
  */
 final class GlideGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
 
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
 
-  private static final String SUPPRESS_LINT_PACKAGE_NAME =
-      "android.annotation";
-  private static final String SUPPRESS_LINT_CLASS_NAME =
-      "SuppressLint";
+  private static final String SUPPRESS_LINT_PACKAGE_NAME = "android.annotation";
+  private static final String SUPPRESS_LINT_CLASS_NAME = "SuppressLint";
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
@@ -108,11 +105,11 @@ TypeSpec generate(
                 + "\n"
                 + "<p>This class is generated and should not be modified"
                 + "\n"
-                + "@see $T\n", GlideExtension.class, glideType)
+                + "@see $T\n",
+            GlideExtension.class,
+            glideType)
         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
-        .addMethod(MethodSpec.constructorBuilder()
-            .addModifiers(Modifier.PRIVATE)
-            .build())
+        .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build())
         .addMethods(
             generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
         .build();
@@ -120,7 +117,8 @@ TypeSpec generate(
 
   private List<MethodSpec> generateOverridesForGlideMethods(
       final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
-    return Lists.transform(discoverGlideMethodsToOverride(),
+    return Lists.transform(
+        discoverGlideMethodsToOverride(),
         new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
@@ -172,8 +170,8 @@ private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride)
 
   private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
     Elements elements = processingEnv.getElementUtils();
-    TypeElement visibleForTestingTypeElement = elements
-        .getTypeElement(ProcessorUtil.visibleForTesting().reflectionName());
+    TypeElement visibleForTestingTypeElement =
+        elements.getTypeElement(ProcessorUtil.visibleForTesting().reflectionName());
     String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
@@ -185,7 +183,7 @@ private Builder addReturnAnnotations(Builder builder, ExecutableElement methodTo
       if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
         builder.addAnnotation(
             AnnotationSpec.builder(
-                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                    ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
                 .addMember("value", "$S", "VisibleForTests")
                 .build());
       }
@@ -211,15 +209,18 @@ private MethodSpec overrideGlideWithMethod(
         parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
     ParameterSpec parameter = parameters.iterator().next();
 
-    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
-        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-        .addParameters(parameters)
-        .returns(generatedRequestManagerClassName)
-        .addStatement("return ($T) $T.$N($L)",
-            generatedRequestManagerClassName, glideType,
-            methodToOverride.getSimpleName().toString(),
-            parameter.name);
+    Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(parameters)
+            .returns(generatedRequestManagerClassName)
+            .addStatement(
+                "return ($T) $T.$N($L)",
+                generatedRequestManagerClassName,
+                glideType,
+                methodToOverride.getSimpleName().toString(),
+                parameter.name);
 
     return addReturnAnnotations(builder, methodToOverride).build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
index 7ff49feea..cd8038ce8 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -20,6 +20,7 @@
  * AppGlideModule in an application.
  *
  * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ *
  * <pre>
  * <code>
  *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
@@ -32,6 +33,7 @@
  * </pre>
  *
  * <p>The output file generated by this class with a GlideExtension looks like this:
+ *
  * <pre>
  * <code>
  *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
@@ -41,7 +43,6 @@
  *  }
  * </code>
  * </pre>
- * </p>
  */
 final class IndexerGenerator {
   private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
@@ -52,7 +53,7 @@
   }
 
   TypeSpec generate(List<TypeElement> types) {
-    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> modules = new ArrayList<>();
     List<TypeElement> extensions = new ArrayList<>();
     for (TypeElement element : types) {
       if (processorUtil.isExtension(element)) {
@@ -64,8 +65,12 @@ TypeSpec generate(List<TypeElement> types) {
       }
     }
     if (!modules.isEmpty() && !extensions.isEmpty()) {
-      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
-          + "other. Modules: " + modules + " Extensions: " + extensions);
+      throw new IllegalArgumentException(
+          "Given both modules and extensions, expected one or the "
+              + "other. Modules: "
+              + modules
+              + " Extensions: "
+              + extensions);
     }
     if (!modules.isEmpty()) {
       return generate(types, GlideModule.class);
@@ -74,18 +79,17 @@ TypeSpec generate(List<TypeElement> types) {
     }
   }
 
-  private static TypeSpec generate(List<TypeElement> libraryModules,
-      Class<? extends Annotation> annotation) {
-    AnnotationSpec.Builder annotationBuilder =
-        AnnotationSpec.builder(Index.class);
+  private static TypeSpec generate(
+      List<TypeElement> libraryModules, Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder = AnnotationSpec.builder(Index.class);
 
     String value = getAnnotationValue(annotation);
     for (TypeElement childModule : libraryModules) {
       annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
     }
 
-    StringBuilder indexerName = new StringBuilder(
-        INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
+    StringBuilder indexerName =
+        new StringBuilder(INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
     for (TypeElement element : libraryModules) {
       indexerName.append(element.getQualifiedName().toString().replace(".", "_"));
       indexerName.append("_");
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
index d6e6329a7..96054f414 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -9,10 +9,7 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;
 
-/**
- * Generates Indexer classes annotated with {@link Index} for all
- * {@code LibraryGlideModule}s.
- */
+/** Generates Indexer classes annotated with {@link Index} for all {@code LibraryGlideModule}s. */
 final class LibraryModuleProcessor {
   private final ProcessorUtil processorUtil;
   private final IndexerGenerator indexerGenerator;
@@ -23,7 +20,7 @@
   }
 
   boolean processModules(RoundEnvironment env) {
-     // Order matters here, if we find an Indexer below, we return before writing the root module.
+    // Order matters here, if we find an Indexer below, we return before writing the root module.
     // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
     List<TypeElement> libraryGlideModules = new ArrayList<>();
     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
@@ -32,8 +29,10 @@ boolean processModules(RoundEnvironment env) {
       if (processorUtil.isAppGlideModule(element)) {
         continue;
       } else if (!processorUtil.isLibraryGlideModule(element)) {
-        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
-            + " and AppGlideModule implementations, not: " + element);
+        throw new IllegalStateException(
+            "@GlideModule can only be applied to LibraryGlideModule"
+                + " and AppGlideModule implementations, not: "
+                + element);
       }
 
       libraryGlideModules.add(element);
@@ -46,9 +45,10 @@ boolean processModules(RoundEnvironment env) {
 
     TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
     processorUtil.writeIndexer(indexer);
-    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
-        + "indexers are found");
-     // If I write an Indexer in a round in the target package, then try to find all classes in
+    processorUtil.debugLog(
+        "Wrote an Indexer this round, skipping the app module to ensure all "
+            + "indexers are found");
+    // If I write an Indexer in a round in the target package, then try to find all classes in
     // the target package, my newly written Indexer won't be found. Since we wrote a class with
     // an Annotation handled by this processor, we know we will be called again in the next round
     // and we can safely wait to write our AppGlideModule until then.
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index 25c7a8ce8..0471702f0 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -51,9 +51,7 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-/**
- * Utilities for writing classes and logging.
- */
+/** Utilities for writing classes and logging. */
 final class ProcessorUtil {
   private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
   private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
@@ -98,13 +96,13 @@ void process() {
   }
 
   boolean isAppGlideModule(TypeElement element) {
-    return processingEnv.getTypeUtils().isAssignable(element.asType(),
-        appGlideModuleType.asType());
+    return processingEnv.getTypeUtils().isAssignable(element.asType(), appGlideModuleType.asType());
   }
 
   boolean isLibraryGlideModule(TypeElement element) {
-    return processingEnv.getTypeUtils().isAssignable(element.asType(),
-        libraryGlideModuleType.asType());
+    return processingEnv
+        .getTypeUtils()
+        .isAssignable(element.asType(), libraryGlideModuleType.asType());
   }
 
   boolean isExtension(TypeElement element) {
@@ -112,8 +110,7 @@ boolean isExtension(TypeElement element) {
   }
 
   int getOverrideType(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     return glideOption.override();
   }
 
@@ -124,7 +121,10 @@ void writeIndexer(TypeSpec indexer) {
   void writeClass(String packageName, TypeSpec clazz) {
     try {
       debugLog("Writing class:\n" + clazz);
-      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+      JavaFile.builder(packageName, clazz)
+          .skipJavaLangImports(true)
+          .build()
+          .writeTo(processingEnv.getFiler());
     } catch (Throwable e) {
       throw new RuntimeException(e);
     }
@@ -134,8 +134,8 @@ void writeClass(String packageName, TypeSpec clazz) {
       Set<String> classNames, Class<? extends Annotation> annotationClass) {
     List<ExecutableElement> result = new ArrayList<>();
     for (String glideExtensionClassName : classNames) {
-      TypeElement glideExtension = processingEnv.getElementUtils()
-          .getTypeElement(glideExtensionClassName);
+      TypeElement glideExtension =
+          processingEnv.getElementUtils().getTypeElement(glideExtensionClassName);
       for (Element element : glideExtension.getEnclosedElements()) {
         if (element.getAnnotation(annotationClass) != null) {
           result.add((ExecutableElement) element);
@@ -145,17 +145,17 @@ void writeClass(String packageName, TypeSpec clazz) {
     return result;
   }
 
-  List<TypeElement> getElementsFor(
-      Class<? extends Annotation> clazz, RoundEnvironment env) {
+  List<TypeElement> getElementsFor(Class<? extends Annotation> clazz, RoundEnvironment env) {
     Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
     return ElementFilter.typesIn(annotatedElements);
   }
 
   /**
-   * Generates a Javadoc code block for generated methods that delegate to methods in
-   * {@link GlideExtension}s.
+   * Generates a Javadoc code block for generated methods that delegate to methods in {@link
+   * GlideExtension}s.
    *
    * <p>The generated block looks something like this:
+   *
    * <pre>
    * <code>
    *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
@@ -163,7 +163,7 @@ void writeClass(String packageName, TypeSpec clazz) {
    * </pre>
    *
    * @param method The method from the {@link GlideExtension} annotated class that the generated
-   * method this Javadoc will be attached to delegates to.
+   *     method this Javadoc will be attached to delegates to.
    */
   CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
     // Use the simple name of the containing type instead of just the containing type's TypeMirror
@@ -172,30 +172,38 @@ CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
     // With this we get @see RequestOptions#methodName().
     // With just ClassName.get(element.getEnclosingElement().asType()), we get:
     // @see RequestOptions<CHILD>#methodName().
-    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
-        method.getSimpleName().toString(), method.getParameters());
+    return generateSeeMethodJavadoc(
+        getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(),
+        method.getParameters());
   }
 
   /**
    * Generates a Javadoc block for generated methods that delegate to other methods.
    *
    * <p>The generated block looks something like this:
+   *
    * <pre>
    * <code>
    *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
    *         methodParam1, methodParamN)
    * </code>
    * </pre>
+   *
    * @param nameOfClassContainingMethod The simple class name of the class containing the method
-   * without any generic types like {@literal <T>}.
+   *     without any generic types like {@literal <T>}.
    * @param methodSimpleName The name of the method.
    * @param methodParameters A maybe empty list of all the parameters for the method in question.
    */
   CodeBlock generateSeeMethodJavadoc(
-      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      TypeName nameOfClassContainingMethod,
+      String methodSimpleName,
       List<? extends VariableElement> methodParameters) {
-    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
-        methodSimpleName, Lists.transform(methodParameters,
+    return generateSeeMethodJavadocInternal(
+        nameOfClassContainingMethod,
+        methodSimpleName,
+        Lists.transform(
+            methodParameters,
             new Function<VariableElement, Object>() {
               @Override
               public Object apply(VariableElement input) {
@@ -204,10 +212,12 @@ public Object apply(VariableElement input) {
             }));
   }
 
-  CodeBlock generateSeeMethodJavadoc(
-      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
-    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
-        methodSpec.name, Lists.transform(methodSpec.parameters,
+  CodeBlock generateSeeMethodJavadoc(TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(
+        nameOfClassContainingMethod,
+        methodSpec.name,
+        Lists.transform(
+            methodSpec.parameters,
             new Function<ParameterSpec, Object>() {
               @Override
               public Object apply(ParameterSpec input) {
@@ -217,8 +227,7 @@ public Object apply(ParameterSpec input) {
   }
 
   private CodeBlock generateSeeMethodJavadocInternal(
-      TypeName nameOfClassContainingMethod, String methodName,
-      List<Object> safeParameterNames) {
+      TypeName nameOfClassContainingMethod, String methodName, List<Object> safeParameterNames) {
     StringBuilder javadocString = new StringBuilder("@see $T#$L(");
     List<Object> javadocArgs = new ArrayList<>();
     javadocArgs.add(nameOfClassContainingMethod);
@@ -238,8 +247,8 @@ private CodeBlock generateSeeMethodJavadocInternal(
   /**
    * Returns a safe String to use in a Javadoc that will function in a link.
    *
-   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
-   * in {@literal RequestOptions<T>} for example).
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>} in
+   * {@literal RequestOptions<T>} for example).
    */
   private TypeName getJavadocSafeName(Element element) {
     Types typeUtils = processingEnv.getTypeUtils();
@@ -267,12 +276,13 @@ static CodeBlock generateCastingSuperCall(TypeName toReturn, MethodSpec method)
         .add("return ($T) super.$N(", toReturn, method.name)
         .add(
             FluentIterable.from(method.parameters)
-                .transform(new Function<ParameterSpec, String>() {
-                  @Override
-                  public String apply(ParameterSpec input) {
-                    return input.name;
-                  }
-                })
+                .transform(
+                    new Function<ParameterSpec, String>() {
+                      @Override
+                      public String apply(ParameterSpec input) {
+                        return input.name;
+                      }
+                    })
                 .join(Joiner.on(",")))
         .add(");\n")
         .build();
@@ -281,8 +291,7 @@ public String apply(ParameterSpec input) {
   static MethodSpec.Builder overriding(ExecutableElement method) {
     String methodName = method.getSimpleName().toString();
 
-    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
-        .addAnnotation(Override.class);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName).addAnnotation(Override.class);
 
     Set<Modifier> modifiers = method.getModifiers();
     modifiers = new LinkedHashSet<>(modifiers);
@@ -303,9 +312,11 @@ public String apply(ParameterSpec input) {
       builder = builder.addTypeVariable(TypeVariableName.get(var));
     }
 
-    builder = builder.returns(TypeName.get(method.getReturnType()))
-        .addParameters(getParameters(method))
-        .varargs(method.isVarArgs());
+    builder =
+        builder
+            .returns(TypeName.get(method.getReturnType()))
+            .addParameters(getParameters(method))
+            .varargs(method.isVarArgs());
 
     for (TypeMirror thrownType : method.getThrownTypes()) {
       builder = builder.addException(TypeName.get(thrownType));
@@ -343,10 +354,11 @@ public String apply(ParameterSpec input) {
       parameters = new ArrayList<>();
       for (int i = 0; i < copy.size(); i++) {
         ParameterSpec parameter = copy.get(i);
-        parameters.add(ParameterSpec.builder(parameter.type, parameter.name + i)
-            .addModifiers(parameter.modifiers)
-            .addAnnotations(parameter.annotations)
-            .build());
+        parameters.add(
+            ParameterSpec.builder(parameter.type, parameter.name + i)
+                .addModifiers(parameter.modifiers)
+                .addAnnotations(parameter.annotations)
+                .build());
       }
     }
 
@@ -406,8 +418,9 @@ private static String computeParameterName(VariableElement parameter, TypeName t
         }
         rawClassName = rawClassName.substring(indexOfLastWordStart, rawClassName.length());
 
-        name = Character.toLowerCase(rawClassName.charAt(0))
-            + rawClassName.substring(1, rawClassName.length());
+        name =
+            Character.toLowerCase(rawClassName.charAt(0))
+                + rawClassName.substring(1, rawClassName.length());
       }
     }
 
@@ -472,8 +485,8 @@ static ClassName checkResult() {
   }
 
   static List<ClassName> nonNulls() {
-    return Arrays.asList(NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION,
-        ANDROIDX_NONNULL_ANNOTATION);
+    return Arrays.asList(
+        NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION, ANDROIDX_NONNULL_ANNOTATION);
   }
 
   List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
@@ -526,7 +539,9 @@ static ClassName checkResult() {
       if (excludedModuleAnnotationValue == null
           || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {
         throw new IllegalArgumentException(
-            "Failed to find value for: " + annotationClass + " from mirrors: "
+            "Failed to find value for: "
+                + annotationClass
+                + " from mirrors: "
                 + clazz.getAnnotationMirrors());
       }
     }
@@ -552,14 +567,16 @@ static ClassName checkResult() {
   private static String getExcludedModuleClassFromAnnotationAttribute(
       Element clazz, Object attribute) {
     if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {
-      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
-          + ", one or more excluded Modules could not be found at compile time. Ensure that all"
-          + "excluded Modules are included in your classpath.");
+      throw new IllegalArgumentException(
+          "Failed to parse @Excludes for: "
+              + clazz
+              + ", one or more excluded Modules could not be found at compile time. Ensure that all"
+              + "excluded Modules are included in your classpath.");
     }
     Method[] methods = attribute.getClass().getDeclaredMethods();
     if (methods == null || methods.length == 0) {
-      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
-          + ", invalid exclude: " + attribute);
+      throw new IllegalArgumentException(
+          "Failed to parse @Excludes for: " + clazz + ", invalid exclude: " + attribute);
     }
     for (Method method : methods) {
       if (method.getName().equals("getValue")) {
@@ -579,8 +596,7 @@ private static String getExcludedModuleClassFromAnnotationAttribute(
   }
 
   private final class FilterPublicMethods implements Predicate<Element> {
-    @Nullable
-    private final TypeMirror returnType;
+    @Nullable private final TypeMirror returnType;
     private final MethodType methodType;
 
     FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType) {
@@ -616,8 +632,7 @@ boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expected
 
   private boolean isReturnValueTypeMatching(
       ExecutableElement method, TypeMirror expectedReturnType) {
-    return processingEnv.getTypeUtils().isAssignable(
-        method.getReturnType(), expectedReturnType);
+    return processingEnv.getTypeUtils().isAssignable(method.getReturnType(), expectedReturnType);
   }
 
   private static final class ToMethod implements Function<Element, ExecutableElement> {
@@ -628,5 +643,4 @@ public ExecutableElement apply(@Nullable Element input) {
       return (ExecutableElement) input;
     }
   }
-
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index b45ea1779..ca9873c01 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -38,12 +38,12 @@
 import javax.lang.model.type.TypeMirror;
 
 /**
- * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from
- * the base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
- * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
- * classes.
+ * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from the
+ * base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated classes.
  *
  * <p>Generated code looks like this:
+ *
  * <pre>
  * <code>
  * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
@@ -101,13 +101,14 @@
   private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
 
   /**
-   * An arbitrary name of the Generic type in the generated RequestBuilder.
-   * e.g. RequestBuilder<TranscodeType>
+   * An arbitrary name of the Generic type in the generated RequestBuilder. e.g.
+   * RequestBuilder<TranscodeType>
    */
   private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
   /** A set of method names to avoid overriding from RequestOptions. */
   private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
       ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+
   private static final AnnotationSpec NON_NULL = AnnotationSpec.builder(nonNull()).build();
   private static final AnnotationSpec CHECK_RESULT = AnnotationSpec.builder(checkResult()).build();
 
@@ -124,13 +125,13 @@
     this.processingEnv = processingEnv;
     this.processorUtil = processorUtil;
 
-    requestBuilderType = processingEnv.getElementUtils()
-        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+    requestBuilderType =
+        processingEnv.getElementUtils().getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
 
     transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
 
-    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
-        REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsType =
+        processingEnv.getElementUtils().getTypeElement(REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
   TypeSpec generate(
@@ -138,8 +139,7 @@ TypeSpec generate(
       Set<String> glideExtensionClassNames,
       @Nullable TypeSpec generatedOptions) {
     if (generatedOptions != null) {
-      requestOptionsClassName =
-          ClassName.get(generatedCodePackageName, generatedOptions.name);
+      requestOptionsClassName = ClassName.get(generatedCodePackageName, generatedOptions.name);
     } else {
       requestOptionsClassName =
           ClassName.get(
@@ -164,8 +164,8 @@ TypeSpec generate(
             glideExtensionClassNames);
 
     return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
-        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
-            requestBuilderType)
+        .addJavadoc(
+            "Contains all public methods from {@link $T}, all options from\n", requestBuilderType)
         .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
         .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
         .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
@@ -193,9 +193,8 @@ TypeSpec generate(
         .build();
   }
   /**
-   * Generates methods with equivalent names and arguments to methods annotated with
-   * {@link GlideOption} in
-   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * Generates methods with equivalent names and arguments to methods annotated with {@link
+   * GlideOption} in {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
    * {@code com.bumptech.glide.RequestBuilder} subclass.
    */
   private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
@@ -204,98 +203,102 @@ TypeSpec generate(
     if (generatedOptions == null) {
       return Collections.emptyList();
     }
-    return FluentIterable
-        .from(generatedOptions.methodSpecs)
-        .filter(new Predicate<MethodSpec>() {
-          @Override
-          public boolean apply(MethodSpec input) {
-            return isUsefulGeneratedRequestOption(requestOptionsExtensionMethods, input);
-          }
-        })
-        .transform(new Function<MethodSpec, MethodSpec>() {
-          @Override
-          public MethodSpec apply(MethodSpec input) {
-            return generateGeneratedRequestOptionEquivalent(input);
-          }
-        })
+    return FluentIterable.from(generatedOptions.methodSpecs)
+        .filter(
+            new Predicate<MethodSpec>() {
+              @Override
+              public boolean apply(MethodSpec input) {
+                return isUsefulGeneratedRequestOption(requestOptionsExtensionMethods, input);
+              }
+            })
+        .transform(
+            new Function<MethodSpec, MethodSpec>() {
+              @Override
+              public MethodSpec apply(MethodSpec input) {
+                return generateGeneratedRequestOptionEquivalent(input);
+              }
+            })
         .toList();
   }
 
-
   /**
-   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
-   * {@code com.bumptech.glide.RequestBuilder} subclass.
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our {@code
+   * com.bumptech.glide.RequestBuilder} subclass.
    *
-   * <p>Only newly generated methods will be included in the generated
-   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
-   * methods that override other methods to avoid duplicates.
+   * <p>Only newly generated methods will be included in the generated {@code
+   * com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out methods
+   * that override other methods to avoid duplicates.
    */
   private boolean isUsefulGeneratedRequestOption(
-      List<MethodSpec> requestOptionsExtensionMethods,
-      final MethodSpec requestOptionsMethod) {
-    return
-        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionsMethod.name)
-            && requestOptionsMethod.hasModifier(Modifier.PUBLIC)
-            && !requestOptionsMethod.hasModifier(Modifier.STATIC)
-            && requestOptionsMethod.returnType.toString().equals(requestOptionsClassName.toString())
-            && !isExtensionMethod(requestOptionsExtensionMethods, requestOptionsMethod);
+      List<MethodSpec> requestOptionsExtensionMethods, final MethodSpec requestOptionsMethod) {
+    return !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionsMethod.name)
+        && requestOptionsMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionsMethod.hasModifier(Modifier.STATIC)
+        && requestOptionsMethod.returnType.toString().equals(requestOptionsClassName.toString())
+        && !isExtensionMethod(requestOptionsExtensionMethods, requestOptionsMethod);
   }
 
   private boolean isExtensionMethod(
       List<MethodSpec> requestOptionsExtensionMethods, final MethodSpec requestOptionsMethod) {
-     return
-         FluentIterable.from(requestOptionsExtensionMethods).anyMatch(new Predicate<MethodSpec>() {
-           @Override
-           public boolean apply(MethodSpec input) {
-             return input.name.equals(requestOptionsMethod.name)
-                 && input.parameters.equals(requestOptionsMethod.parameters);
-           }
-         });
+    return FluentIterable.from(requestOptionsExtensionMethods)
+        .anyMatch(
+            new Predicate<MethodSpec>() {
+              @Override
+              public boolean apply(MethodSpec input) {
+                return input.name.equals(requestOptionsMethod.name)
+                    && input.parameters.equals(requestOptionsMethod.parameters);
+              }
+            });
   }
 
   /**
-   * Generates a particular method with  an equivalent name and arguments to the given method
-   * from the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   * Generates a particular method with an equivalent name and arguments to the given method from
+   * the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
    */
   private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
-    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
-        .add(".$N(", requestOptionMethod.name)
-        .add(FluentIterable.from(requestOptionMethod.parameters)
-            .transform(new Function<ParameterSpec, String>() {
-              @Override
-              public String apply(ParameterSpec input) {
-                return input.name;
-              }
-            })
-            .join(Joiner.on(", ")))
-        .add(");\n")
-        .build();
+    CodeBlock callRequestOptionsMethod =
+        CodeBlock.builder()
+            .add(".$N(", requestOptionMethod.name)
+            .add(
+                FluentIterable.from(requestOptionMethod.parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
+            .add(");\n")
+            .build();
 
-    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name)
-        .addJavadoc(
-            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
-        .addModifiers(Modifier.PUBLIC)
-        .varargs(requestOptionMethod.varargs)
-        .addAnnotations(
-            FluentIterable.from(requestOptionMethod.annotations)
-                .filter(new Predicate<AnnotationSpec>() {
-                  @Override
-                  public boolean apply(AnnotationSpec input) {
-                    return !input.type.equals(TypeName.get(Override.class))
-                        // SafeVarargs can only be applied to final methods. GlideRequest is
-                        // non-final to allow for mocking.
-                        && !input.type.equals(TypeName.get(SafeVarargs.class))
-                        // We need to combine warnings below.
-                        && !input.type.equals(TypeName.get(SuppressWarnings.class));
-                  }
-                })
-                .toList()
-        )
-        .addTypeVariables(requestOptionMethod.typeVariables)
-        .addParameters(requestOptionMethod.parameters)
-        .returns(generatedRequestBuilderOfTranscodeType)
-        .addCode("return ($T) super", generatedRequestBuilderOfTranscodeType)
-        .addCode(callRequestOptionsMethod);
+    MethodSpec.Builder result =
+        MethodSpec.methodBuilder(requestOptionMethod.name)
+            .addJavadoc(
+                processorUtil.generateSeeMethodJavadoc(
+                    requestOptionsClassName, requestOptionMethod))
+            .addModifiers(Modifier.PUBLIC)
+            .varargs(requestOptionMethod.varargs)
+            .addAnnotations(
+                FluentIterable.from(requestOptionMethod.annotations)
+                    .filter(
+                        new Predicate<AnnotationSpec>() {
+                          @Override
+                          public boolean apply(AnnotationSpec input) {
+                            return !input.type.equals(TypeName.get(Override.class))
+                                // SafeVarargs can only be applied to final methods. GlideRequest is
+                                // non-final to allow for mocking.
+                                && !input.type.equals(TypeName.get(SafeVarargs.class))
+                                // We need to combine warnings below.
+                                && !input.type.equals(TypeName.get(SuppressWarnings.class));
+                          }
+                        })
+                    .toList())
+            .addTypeVariables(requestOptionMethod.typeVariables)
+            .addParameters(requestOptionMethod.parameters)
+            .returns(generatedRequestBuilderOfTranscodeType)
+            .addCode("return ($T) super", generatedRequestBuilderOfTranscodeType)
+            .addCode(callRequestOptionsMethod);
 
     AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);
     if (suppressWarnings != null) {
@@ -304,7 +307,6 @@ public boolean apply(AnnotationSpec input) {
     return result.build();
   }
 
-
   @Nullable
   private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
     Set<String> suppressions = new HashSet<>();
@@ -313,13 +315,16 @@ private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
       for (AnnotationSpec annotation : requestOptionMethod.annotations) {
         if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {
           List<CodeBlock> codeBlocks = annotation.members.get("value");
-          suppressions.addAll(FluentIterable.from(codeBlocks).transform(
-              new Function<CodeBlock, String>() {
-                @Override
-                public String apply(CodeBlock input) {
-                  return input.toString();
-                }
-              }).toSet());
+          suppressions.addAll(
+              FluentIterable.from(codeBlocks)
+                  .transform(
+                      new Function<CodeBlock, String>() {
+                        @Override
+                        public String apply(CodeBlock input) {
+                          return input.toString();
+                        }
+                      })
+                  .toSet());
         }
       }
     }
@@ -346,7 +351,6 @@ public String apply(CodeBlock input) {
     return builder.build();
   }
 
-
   /**
    * Generates overrides of all methods in {@code com.bumptech.glide.RequestBuilder} that return
    * {@code com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
@@ -364,7 +368,6 @@ public MethodSpec apply(ExecutableElement input) {
         });
   }
 
-
   /**
    * Generates an override of a particular method in {@code com.bumptech.glide.RequestBuilder} that
    * returns {@code com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
@@ -379,34 +382,40 @@ private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOver
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType);
-    builder.addCode(CodeBlock.builder()
-        .add("return ($T) super.$N(",
-            generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-        .add(FluentIterable.from(builder.build().parameters)
-            .transform(new Function<ParameterSpec, String>() {
-              @Override
-              public String apply(ParameterSpec input) {
-                return input.name;
-              }
-            })
-            .join(Joiner.on(", ")))
-        .add(");\n")
-        .build());
+    MethodSpec.Builder builder =
+        ProcessorUtil.overriding(methodToOverride).returns(generatedRequestBuilderOfType);
+    builder.addCode(
+        CodeBlock.builder()
+            .add(
+                "return ($T) super.$N(",
+                generatedRequestBuilderOfType,
+                methodToOverride.getSimpleName())
+            .add(
+                FluentIterable.from(builder.build().parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
       builder = builder.addAnnotation(AnnotationSpec.get(mirror));
     }
 
     if (methodToOverride.isVarArgs()) {
-      builder = builder
-          .addModifiers(Modifier.FINAL)
-          .addAnnotation(SafeVarargs.class)
-          .addAnnotation(
-              AnnotationSpec.builder(SuppressWarnings.class)
-                  .addMember("value", "$S", "varargs")
-                  .build());
+      builder =
+          builder
+              .addModifiers(Modifier.FINAL)
+              .addAnnotation(SafeVarargs.class)
+              .addAnnotation(
+                  AnnotationSpec.builder(SuppressWarnings.class)
+                      .addMember("value", "$S", "varargs")
+                      .build());
     }
 
     return builder.build();
@@ -422,38 +431,33 @@ public String apply(ParameterSpec input) {
 
     MethodSpec firstConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
-                .addAnnotation(nonNull())
-                .build()
-            )
-        .addStatement("super($N, $N)", "transcodeClass", "other")
-        .build();
+            .addParameter(
+                ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addStatement("super($N, $N)", "transcodeClass", "other")
+            .build();
 
     ClassName context = ClassName.get("android.content", "Context");
     ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
     ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
     MethodSpec secondConstructor =
         MethodSpec.constructorBuilder()
-            .addParameter(ParameterSpec.builder(glide, "glide")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(requestManager, "requestManager")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
-                .addAnnotation(nonNull())
-                .build()
-            )
-            .addParameter(ParameterSpec.builder(context, "context")
-                .addAnnotation(nonNull())
-                .build()
-            )
+            .addParameter(ParameterSpec.builder(glide, "glide").addAnnotation(nonNull()).build())
+            .addParameter(
+                ParameterSpec.builder(requestManager, "requestManager")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                    .addAnnotation(nonNull())
+                    .build())
+            .addParameter(
+                ParameterSpec.builder(context, "context").addAnnotation(nonNull()).build())
             .addStatement(
                 "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context")
             .build();
@@ -465,16 +469,19 @@ public String apply(ParameterSpec input) {
    * return our generated subclass instead.
    */
   private MethodSpec generateDownloadOnlyRequestMethod() {
-    ParameterizedTypeName generatedRequestBuilderOfFile
-        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    ParameterizedTypeName generatedRequestBuilderOfFile =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
     return MethodSpec.methodBuilder("getDownloadOnlyRequest")
         .addAnnotation(Override.class)
         .addAnnotation(CHECK_RESULT)
         .addAnnotation(NON_NULL)
         .returns(generatedRequestBuilderOfFile)
         .addModifiers(Modifier.PROTECTED)
-        .addStatement("return new $T<>($T.class, $N).apply($N)",
-            generatedRequestBuilderClassName, File.class, "this",
+        .addStatement(
+            "return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName,
+            File.class,
+            "this",
             "DOWNLOAD_ONLY_OPTIONS")
         .build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
index d20a7fd2a..23749b681 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -12,12 +12,13 @@
 import javax.lang.model.util.Elements;
 
 /**
- * Generates an implementation of
- * {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * Generates an implementation of {@code
+ * com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
  * generated {@code com.bumptech.glide.RequestManager} implementation.
  *
  * <p>Generated {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
  * classes look like this:
+ *
  * <pre>
  * <code>
  * public class GeneratedRequestManagerFactory
@@ -32,21 +33,16 @@
  * </pre>
  */
 final class RequestManagerFactoryGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
-  private static final String LIFECYCLE_QUALIFIED_NAME =
-      "com.bumptech.glide.manager.Lifecycle";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME = "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
   private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
-  private static final ClassName CONTEXT_CLASS_NAME =
-      ClassName.get("android.content", "Context");
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
+  private static final ClassName CONTEXT_CLASS_NAME = ClassName.get("android.content", "Context");
 
-  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
-      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME = "com.bumptech.glide";
   static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
       "GeneratedRequestManagerFactory";
 
@@ -81,28 +77,26 @@ TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestMana
                 .addAnnotation(Override.class)
                 .addAnnotation(nonNull())
                 .returns(requestManagerClassName)
-                .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
-                    .addAnnotation(nonNull())
-                    .build()
-                )
-                .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
-                    .addAnnotation(nonNull())
-                    .build()
-                )
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(glideType), "glide")
+                        .addAnnotation(nonNull())
+                        .build())
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                        .addAnnotation(nonNull())
+                        .build())
                 .addParameter(
                     ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
                         .addAnnotation(nonNull())
-                        .build()
-                )
-                .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
-                    .addAnnotation(nonNull())
-                    .build()
-                )
+                        .build())
+                .addParameter(
+                    ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                        .addAnnotation(nonNull())
+                        .build())
                 .addStatement(
                     "return new $T(glide, lifecycle, treeNode, context)",
                     ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
-                .build()
-        )
+                .build())
         .build();
   }
 }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index d66257e87..a47171ce7 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -37,6 +37,7 @@
  * methods from {@link GlideExtension}s and {@link GlideType}.
  *
  * <p>Generated {@code com.bumptech.glide.RequestManager} implementations look like this:
+ *
  * <pre>
  * <code>
  * public final class GeneratedRequestManager extends RequestManager {
@@ -54,19 +55,14 @@
  * </pre>
  */
 final class RequestManagerGenerator {
-  private static final String GLIDE_QUALIFIED_NAME =
-      "com.bumptech.glide.Glide";
-  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
-      "com.bumptech.glide.RequestManager";
-  private static final String LIFECYCLE_QUALIFIED_NAME =
-      "com.bumptech.glide.manager.Lifecycle";
+  private static final String GLIDE_QUALIFIED_NAME = "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME = "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME = "com.bumptech.glide.manager.Lifecycle";
   private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
       "com.bumptech.glide.manager.RequestManagerTreeNode";
-  private static final ClassName CONTEXT_CLASS_NAME =
-      ClassName.get("android.content", "Context");
+  private static final ClassName CONTEXT_CLASS_NAME = ClassName.get("android.content", "Context");
 
-  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
-      "GlideRequests";
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME = "GlideRequests";
 
   private ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
@@ -98,16 +94,20 @@
   }
 
   TypeSpec generate(
-      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      String generatedCodePackageName,
+      @Nullable TypeSpec requestOptions,
+      TypeSpec requestBuilder,
       Set<String> glideExtensions) {
     generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
     return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
         .superclass(requestManagerClassName)
-        .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+        .addJavadoc(
+            "Includes all additions from methods in {@link $T}s\n"
                 + "annotated with {@link $T}\n"
                 + "\n"
                 + "<p>Generated code, do not modify\n",
-            GlideExtension.class, GlideType.class)
+            GlideExtension.class,
+            GlideType.class)
         .addAnnotation(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "deprecation")
@@ -120,8 +120,9 @@ TypeSpec generate(
         .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
         .addMethods(
             FluentIterable.from(
-                Collections.singletonList(
-                    generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                    Collections.singletonList(
+                        generateOverrideSetRequestOptions(
+                            generatedCodePackageName, requestOptions)))
                 .filter(Predicates.<MethodSpec>notNull()))
         .build();
   }
@@ -129,36 +130,34 @@ TypeSpec generate(
   private MethodSpec generateCallSuperConstructor() {
     return MethodSpec.constructorBuilder()
         .addModifiers(Modifier.PUBLIC)
-        .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
-            .addAnnotation(nonNull())
-            .build()
-        )
-        .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
-            .addAnnotation(nonNull())
-            .build()
-        )
-        .addParameter(ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
-            .addAnnotation(nonNull())
-            .build()
-        )
-        .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
-            .addAnnotation(nonNull())
-            .build()
-        )
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(glideType), "glide")
+                .addAnnotation(nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                .addAnnotation(nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addAnnotation(nonNull())
+                .build())
+        .addParameter(
+            ParameterSpec.builder(CONTEXT_CLASS_NAME, "context").addAnnotation(nonNull()).build())
         .addStatement("super(glide, lifecycle, treeNode, context)")
         .build();
   }
 
   private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
     TypeVariableName resourceType = TypeVariableName.get("ResourceType");
-    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
-        .get(ClassName.get(Class.class), resourceType);
+    ParameterizedTypeName classOfResouceType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), resourceType);
 
     ClassName generatedRequestBuilderClassName =
         ClassName.get(generatedCodePackageName, requestBuilder.name);
 
-    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
-        .get(generatedRequestBuilderClassName, resourceType);
+    ParameterizedTypeName requestBuilderOfResourceType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, resourceType);
 
     return MethodSpec.methodBuilder("as")
         .addModifiers(Modifier.PUBLIC)
@@ -167,9 +166,11 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
         .addAnnotation(nonNull())
         .addTypeVariable(TypeVariableName.get("ResourceType"))
         .returns(requestBuilderOfResourceType)
-        .addParameter(classOfResouceType.annotated(AnnotationSpec.builder(nonNull()).build()),
+        .addParameter(
+            classOfResouceType.annotated(AnnotationSpec.builder(nonNull()).build()),
             "resourceClass")
-        .addStatement("return new $T<>(glide, this, resourceClass, context)",
+        .addStatement(
+            "return new $T<>(glide, this, resourceClass, context)",
             this.generatedRequestBuilderClassName)
         .build();
   }
@@ -178,13 +179,15 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
   private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
       final String generatedPackageName) {
     return FluentIterable.from(
-        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
-        .transform(new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(@Nullable ExecutableElement input) {
-            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
-          }
-        })
+            processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(@Nullable ExecutableElement input) {
+                return generateRequestManagerRequestManagerMethodOverride(
+                    generatedPackageName, input);
+              }
+            })
         .toList();
   }
 
@@ -192,12 +195,13 @@ private MethodSpec generateRequestManagerRequestManagerMethodOverride(
       String generatedPackageName, ExecutableElement method) {
     ClassName generatedRequestManagerName =
         ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
-    Builder returns = ProcessorUtil.overriding(method)
-        .addAnnotation(nonNull())
-        .returns(generatedRequestManagerName);
+    Builder returns =
+        ProcessorUtil.overriding(method)
+            .addAnnotation(nonNull())
+            .returns(generatedRequestManagerName);
     return returns
-        .addCode(ProcessorUtil.generateCastingSuperCall(
-            generatedRequestManagerName, returns.build()))
+        .addCode(
+            ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, returns.build()))
         .build();
   }
 
@@ -206,24 +210,26 @@ private MethodSpec generateRequestManagerRequestManagerMethodOverride(
     // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
     // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
     // assignable to the raw RequestBuilder.
-    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
-        .erasure(requestBuilderType.asType());
+    TypeMirror rawRequestBuilder =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
 
     return FluentIterable.from(
-        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
-        .filter(new Predicate<ExecutableElement>() {
-          @Override
-          public boolean apply(ExecutableElement input) {
-            // Skip the <T> as(Class<T>) method.
-            return !input.getSimpleName().toString().equals("as");
-          }
-        })
-        .transform(new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestManagerRequestBuilderMethodOverride(input);
-          }
-        })
+            processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement input) {
+                // Skip the <T> as(Class<T>) method.
+                return !input.getSimpleName().toString().equals("as");
+              }
+            })
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(ExecutableElement input) {
+                return generateRequestManagerRequestBuilderMethodOverride(input);
+              }
+            })
         .toList();
   }
 
@@ -241,8 +247,8 @@ private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
-        .returns(generatedRequestBuilderOfType);
+    MethodSpec.Builder builder =
+        ProcessorUtil.overriding(methodToOverride).returns(generatedRequestBuilderOfType);
     builder.addCode(
         ProcessorUtil.generateCastingSuperCall(generatedRequestBuilderOfType, builder.build()));
 
@@ -252,12 +258,12 @@ private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
     return builder.build();
   }
 
-  private List<MethodSpec> generateExtensionRequestManagerMethods(
-      Set<String> glideExtensions) {
+  private List<MethodSpec> generateExtensionRequestManagerMethods(Set<String> glideExtensions) {
     List<ExecutableElement> requestManagerExtensionMethods =
         processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
 
-    return Lists.transform(requestManagerExtensionMethods,
+    return Lists.transform(
+        requestManagerExtensionMethods,
         new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
@@ -277,8 +283,11 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
 
   private MethodSpec generateAdditionalRequestManagerMethodLegacy(
       ExecutableElement extensionMethod) {
-    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
-        GlideType.class).iterator().next();
+    String returnType =
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(extensionMethod, GlideType.class)
+            .iterator()
+            .next();
     ClassName returnTypeClassName = ClassName.bestGuess(returnType);
     ParameterizedTypeName parameterizedTypeName =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
@@ -291,16 +300,20 @@ private MethodSpec generateAdditionalRequestManagerMethodLegacy(
         .addAnnotation(checkResult())
         .addStatement(
             "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
-        .addStatement("$T.$N(requestBuilder)",
-            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement(
+            "$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName())
         .addStatement("return requestBuilder")
         .build();
   }
 
-  private MethodSpec generateAdditionalRequestManagerMethodNew(
-      ExecutableElement extensionMethod) {
-    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
-        GlideType.class).iterator().next();
+  private MethodSpec generateAdditionalRequestManagerMethodNew(ExecutableElement extensionMethod) {
+    String returnType =
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(extensionMethod, GlideType.class)
+            .iterator()
+            .next();
     ClassName returnTypeClassName = ClassName.bestGuess(returnType);
     ParameterizedTypeName parameterizedTypeName =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
@@ -321,9 +334,9 @@ private MethodSpec generateAdditionalRequestManagerMethodNew(
   }
 
   /**
-   * The {@code RequestOptions} subclass should always be our
-   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
-   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   * The {@code RequestOptions} subclass should always be our generated subclass type to avoid
+   * inadvertent errors where a different subclass is applied that accidentally wipes out some logic
+   * in overidden methods in our generated subclass.
    */
   @Nullable
   private MethodSpec generateOverrideSetRequestOptions(
@@ -334,8 +347,7 @@ private MethodSpec generateOverrideSetRequestOptions(
 
     Elements elementUtils = processingEnv.getElementUtils();
     TypeElement requestOptionsType =
-        elementUtils.getTypeElement(
-            RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+        elementUtils.getTypeElement(RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
 
     // This class may have just been generated and therefore may not be found if we try to obtain
     // it via Elements, so use just the String version instead.
@@ -352,12 +364,14 @@ private MethodSpec generateOverrideSetRequestOptions(
             ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
                 .addAnnotation(nonNull())
                 .build())
-        .beginControlFlow("if ($N instanceof $L)",
-            parameterName, generatedRequestOptionsQualifiedName)
+        .beginControlFlow(
+            "if ($N instanceof $L)", parameterName, generatedRequestOptionsQualifiedName)
         .addStatement("super.$N($N)", methodName, parameterName)
         .nextControlFlow("else")
-        .addStatement("super.setRequestOptions(new $L().apply($N))",
-            generatedRequestOptionsQualifiedName, parameterName)
+        .addStatement(
+            "super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName,
+            parameterName)
         .endControlFlow()
         .build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
index 450ab8326..19b2f4412 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsExtensionGenerator.java
@@ -37,7 +37,8 @@
    * given extension class names.
    */
   List<ExecutableElement> getRequestOptionExtensionMethods(Set<String> glideExtensionClassNames) {
-   return processorUtil.findAnnotatedElementsInClasses(glideExtensionClassNames, GlideOption.class);
+    return processorUtil.findAnnotatedElementsInClasses(
+        glideExtensionClassNames, GlideOption.class);
   }
 
   /**
@@ -56,13 +57,15 @@
     return result;
   }
 
-  private MethodSpec generateMethodsForRequestOptionsExtension(
-      ExecutableElement element) {
+  private MethodSpec generateMethodsForRequestOptionsExtension(ExecutableElement element) {
     // Assert for legacy versions
     if (element.getReturnType().getKind() == TypeKind.VOID) {
       throw new IllegalArgumentException(
-          "The " + element.getSimpleName() + " method annotated with @GlideOption in the "
-              + element.getEnclosingElement().getSimpleName() + " @GlideExtension is using a legacy"
+          "The "
+              + element.getSimpleName()
+              + " method annotated with @GlideOption in the "
+              + element.getEnclosingElement().getSimpleName()
+              + " @GlideExtension is using a legacy"
               + " format that is no longer supported. Please change your method definition so that"
               + " your @GlideModule annotated methods return BaseRequestOptions<?> objects instead"
               + " of null.");
@@ -71,15 +74,16 @@ private MethodSpec generateMethodsForRequestOptionsExtension(
     int overrideType = processorUtil.getOverrideType(element);
 
     String methodName = element.getSimpleName().toString();
-    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
-        .addModifiers(Modifier.PUBLIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
-        .varargs(element.isVarArgs())
-        .returns(containingClassName)
-        .addAnnotation(
-            AnnotationSpec.builder(SuppressWarnings.class)
-                .addMember("value", "$S", "unchecked")
-                .build());
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodName)
+            .addModifiers(Modifier.PUBLIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+            .varargs(element.isVarArgs())
+            .returns(containingClassName)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "unchecked")
+                    .build());
 
     // The 0th element is expected to be a RequestOptions object.
     List<? extends VariableElement> paramElements =
@@ -103,13 +107,14 @@ private MethodSpec generateMethodsForRequestOptionsExtension(
           methodLiterals.append("$L, ");
           methodArgs.add(parameter.name);
         }
-        methodLiterals = new StringBuilder(
-            methodLiterals.substring(0, methodLiterals.length() - 2));
+        methodLiterals =
+            new StringBuilder(methodLiterals.substring(0, methodLiterals.length() - 2));
       }
-      extensionRequestOptionsArgument = CodeBlock.builder()
-          .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
-          .build()
-          .toString();
+      extensionRequestOptionsArgument =
+          CodeBlock.builder()
+              .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+              .build()
+              .toString();
     } else {
       extensionRequestOptionsArgument = "this";
     }
@@ -130,9 +135,7 @@ private MethodSpec generateMethodsForRequestOptionsExtension(
     code.append(")");
     builder.addStatement(code.toString(), args.toArray(new Object[0]));
 
-    builder
-        .addAnnotation(checkResult())
-        .addAnnotation(nonNull());
+    builder.addAnnotation(checkResult()).addAnnotation(nonNull());
 
     return builder.build();
   }
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index f68cde6e8..80005ec1c 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -36,12 +36,12 @@
 import javax.lang.model.element.VariableElement;
 
 /**
- * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions}
- * containing static versions of methods included in the base class and static and instance versions
- * of all methods annotated with {@link GlideOption} in classes annotated with
- * {@link GlideExtension}.
+ * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions} containing
+ * static versions of methods included in the base class and static and instance versions of all
+ * methods annotated with {@link GlideOption} in classes annotated with {@link GlideExtension}.
  *
  * <p>The generated class looks something like this:
+ *
  * <pre>
  * <code>
  * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
@@ -66,7 +66,6 @@
  * }
  * </code>
  * </pre>
- * </p>
  */
 final class RequestOptionsGenerator {
   private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
@@ -92,11 +91,10 @@
       ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
     this.processorUtil = processorUtil;
 
-    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
-        REQUEST_OPTIONS_SIMPLE_NAME);
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME, REQUEST_OPTIONS_SIMPLE_NAME);
 
-    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
-        REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsType =
+        processingEnvironment.getElementUtils().getTypeElement(REQUEST_OPTIONS_QUALIFIED_NAME);
 
     requestOptionsOverrideGenerator =
         new RequestOptionsOverrideGenerator(processingEnvironment, processorUtil);
@@ -110,33 +108,36 @@ TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionCla
         new RequestOptionsExtensionGenerator(glideOptionsName, processorUtil);
     List<MethodAndStaticVar> instanceMethodsForExtensions =
         FluentIterable.from(
-            requestOptionsExtensionGenerator
-                .generateInstanceMethodsForExtensions(glideExtensionClassNames))
-            .transform(new Function<MethodSpec, MethodAndStaticVar>() {
-              @Override
-              public MethodAndStaticVar apply(MethodSpec input) {
-                return new MethodAndStaticVar(input);
-              }
-            })
+                requestOptionsExtensionGenerator.generateInstanceMethodsForExtensions(
+                    glideExtensionClassNames))
+            .transform(
+                new Function<MethodSpec, MethodAndStaticVar>() {
+                  @Override
+                  public MethodAndStaticVar apply(MethodSpec input) {
+                    return new MethodAndStaticVar(input);
+                  }
+                })
             .toList();
 
     List<MethodAndStaticVar> staticMethodsForExtensions =
         FluentIterable.from(
-            requestOptionsExtensionGenerator.getRequestOptionExtensionMethods(
-                glideExtensionClassNames))
-            .filter(new Predicate<ExecutableElement>() {
-              @Override
-              public boolean apply(ExecutableElement input) {
-                return !skipStaticMethod(input);
-              }
-            })
-        .transform(new Function<ExecutableElement, MethodAndStaticVar>() {
-          @Override
-          public MethodAndStaticVar apply(ExecutableElement input) {
-            return generateStaticMethodEquivalentForExtensionMethod(input);
-          }
-        })
-        .toList();
+                requestOptionsExtensionGenerator.getRequestOptionExtensionMethods(
+                    glideExtensionClassNames))
+            .filter(
+                new Predicate<ExecutableElement>() {
+                  @Override
+                  public boolean apply(ExecutableElement input) {
+                    return !skipStaticMethod(input);
+                  }
+                })
+            .transform(
+                new Function<ExecutableElement, MethodAndStaticVar>() {
+                  @Override
+                  public MethodAndStaticVar apply(ExecutableElement input) {
+                    return generateStaticMethodEquivalentForExtensionMethod(input);
+                  }
+                })
+            .toList();
 
     List<MethodAndStaticVar> methodsForExtensions = new ArrayList<>();
     methodsForExtensions.addAll(instanceMethodsForExtensions);
@@ -144,13 +145,14 @@ public MethodAndStaticVar apply(ExecutableElement input) {
 
     Set<MethodSignature> extensionMethodSignatures =
         ImmutableSet.copyOf(
-            Iterables.transform(methodsForExtensions,
+            Iterables.transform(
+                methodsForExtensions,
                 new Function<MethodAndStaticVar, MethodSignature>() {
-              @Override
-              public MethodSignature apply(MethodAndStaticVar f) {
-                return new MethodSignature(f.method);
-              }
-            }));
+                  @Override
+                  public MethodSignature apply(MethodAndStaticVar f) {
+                    return new MethodSignature(f.method);
+                  }
+                }));
 
     List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
     List<MethodSpec> instanceOverrides =
@@ -172,16 +174,17 @@ public MethodSignature apply(MethodAndStaticVar f) {
     }
     allMethodsAndStaticVars.addAll(methodsForExtensions);
 
-    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
-        .addAnnotation(
-            AnnotationSpec.builder(SuppressWarnings.class)
-                .addMember("value", "$S", "deprecation")
-                .build())
-        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
-        .addModifiers(Modifier.FINAL)
-        .addModifiers(Modifier.PUBLIC)
-        .addSuperinterface(Cloneable.class)
-        .superclass(requestOptionsName);
+    TypeSpec.Builder classBuilder =
+        TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+            .addAnnotation(
+                AnnotationSpec.builder(SuppressWarnings.class)
+                    .addMember("value", "$S", "deprecation")
+                    .build())
+            .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+            .addModifiers(Modifier.FINAL)
+            .addModifiers(Modifier.PUBLIC)
+            .addSuperinterface(Cloneable.class)
+            .superclass(requestOptionsName);
 
     for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
       if (methodAndStaticVar.method != null) {
@@ -195,11 +198,13 @@ public MethodSignature apply(MethodAndStaticVar f) {
   }
 
   private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
-    Builder builder = CodeBlock.builder()
-        .add("Automatically generated from {@link $T} annotated classes.\n",
-            GlideExtension.class)
-        .add("\n")
-        .add("@see $T\n", requestOptionsName);
+    Builder builder =
+        CodeBlock.builder()
+            .add(
+                "Automatically generated from {@link $T} annotated classes.\n",
+                GlideExtension.class)
+            .add("\n")
+            .add("@see $T\n", requestOptionsName);
 
     for (String glideExtensionClass : glideExtensionClassNames) {
       builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
@@ -223,12 +228,12 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
   /**
    * This method is a bit of a hack, but it lets us tie the static version of a method with the
    * instance version. In turn that lets us call the instance versions on the generated subclass,
-   * instead of just delegating to the RequestOptions static methods. Using the instance methods
-   * on the generated subclass allows our static methods to properly call code that overrides
-   * an existing method in RequestOptions.
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods on
+   * the generated subclass allows our static methods to properly call code that overrides an
+   * existing method in RequestOptions.
    *
-   * <p>The string names here just map between the static methods in
-   * {@code com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   * <p>The string names here just map between the static methods in {@code
+   * com.bumptech.glide.request.RequestOptions} and the instance methods they call.
    */
   private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
     String equivalentInstanceMethodName;
@@ -266,8 +271,9 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
             .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
             .returns(glideOptionsName);
 
-    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
-        "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
+    StringBuilder createNewOptionAndCall =
+        createNewOptionAndCall(
+            memoize, methodSpecBuilder, "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
@@ -278,13 +284,18 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
 
       // Mix in an incrementing unique id to handle method overloading.
       String staticVariableName = staticMethodName + nextFieldId++;
-      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
-          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
-          .build();
-      methodSpecBuilder.beginControlFlow(
-          "if ($T.$N == null)", glideOptionsName, staticVariableName)
-          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
-              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+      requiredStaticField =
+          FieldSpec.builder(glideOptionsName, staticVariableName)
+              .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+              .build();
+      methodSpecBuilder
+          .beginControlFlow("if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement(
+              "$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName,
+              staticVariableName,
+              glideOptionsName,
+              equivalentInstanceMethodName,
               "autoClone()")
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
@@ -301,9 +312,7 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
-    methodSpecBuilder
-        .addAnnotation(checkResult())
-        .addAnnotation(nonNull());
+    methodSpecBuilder.addAnnotation(checkResult()).addAnnotation(nonNull());
 
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
@@ -311,13 +320,19 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
   private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
     return staticMethod.getParameters().isEmpty()
         || (staticMethod.getParameters().size() == 1
-        && staticMethod.getParameters().get(0).getSimpleName().toString()
-        .equals("android.content.Context"));
+            && staticMethod
+                .getParameters()
+                .get(0)
+                .getSimpleName()
+                .toString()
+                .equals("android.content.Context"));
   }
 
-  private StringBuilder createNewOptionAndCall(boolean memoize,
+  private StringBuilder createNewOptionAndCall(
+      boolean memoize,
       MethodSpec.Builder methodSpecBuilder,
-      String start, List<ParameterSpec> specs) {
+      String start,
+      List<ParameterSpec> specs) {
     StringBuilder createNewOptionAndCall = new StringBuilder(start);
     if (!specs.isEmpty()) {
       methodSpecBuilder.addParameters(specs);
@@ -329,8 +344,9 @@ private StringBuilder createNewOptionAndCall(boolean memoize,
         }
         createNewOptionAndCall.append(", ");
       }
-      createNewOptionAndCall = new StringBuilder(
-          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
+      createNewOptionAndCall =
+          new StringBuilder(
+              createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
     }
     createNewOptionAndCall.append(")");
     return createNewOptionAndCall;
@@ -355,11 +371,12 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
 
     //noinspection ResultOfMethodCallIgnored
     Preconditions.checkNotNull(staticMethodName);
-    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
-        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
-        .varargs(instanceMethod.isVarArgs())
-        .returns(glideOptionsName);
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+            .varargs(instanceMethod.isVarArgs())
+            .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
 
@@ -367,14 +384,14 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     // actual method we want to generate will pass the RequestOptions in to the extension method,
     // but should not itself require a RequestOptions object to be passed in.
     if (parameters.isEmpty()) {
-      throw new IllegalArgumentException(
-          "Expected non-empty parameters for: " + instanceMethod);
+      throw new IllegalArgumentException("Expected non-empty parameters for: " + instanceMethod);
     }
     // Remove is not supported.
     parameters = parameters.subList(1, parameters.size());
 
-    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
-        "new $T().$L(", ProcessorUtil.getParameters(parameters));
+    StringBuilder createNewOptionAndCall =
+        createNewOptionAndCall(
+            memoize, methodSpecBuilder, "new $T().$L(", ProcessorUtil.getParameters(parameters));
 
     FieldSpec requiredStaticField = null;
     if (memoize) {
@@ -385,13 +402,18 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
 
       // Mix in an incrementing unique id to handle method overloading.
       String staticVariableName = staticMethodName + nextFieldId++;
-      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
-          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
-          .build();
-      methodSpecBuilder.beginControlFlow(
-          "if ($T.$N == null)", glideOptionsName, staticVariableName)
-          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
-              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+      requiredStaticField =
+          FieldSpec.builder(glideOptionsName, staticVariableName)
+              .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+              .build();
+      methodSpecBuilder
+          .beginControlFlow("if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement(
+              "$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName,
+              staticVariableName,
+              glideOptionsName,
+              instanceMethodName,
               "autoClone()")
           .endControlFlow()
           .addStatement("return $T.$N", glideOptionsName, staticVariableName);
@@ -415,21 +437,18 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
 
   @Nullable
   private static String getStaticMethodName(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     String result = glideOption != null ? glideOption.staticMethodName() : null;
     return Strings.emptyToNull(result);
   }
 
   private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     return glideOption != null && glideOption.memoizeStaticMethod();
   }
 
   private static boolean skipStaticMethod(ExecutableElement element) {
-    GlideOption glideOption =
-        element.getAnnotation(GlideOption.class);
+    GlideOption glideOption = element.getAnnotation(GlideOption.class);
     return glideOption != null && glideOption.skipStaticMethod();
   }
 
@@ -458,13 +477,15 @@ private static boolean skipStaticMethod(ExecutableElement element) {
       isStatic = spec.modifiers.contains(Modifier.STATIC);
       returnType = spec.returnType;
       parameterTypes =
-          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
-            @Nullable
-            @Override
-            public TypeName apply(ParameterSpec parameterSpec) {
-              return parameterSpec.type;
-            }
-          });
+          Lists.transform(
+              spec.parameters,
+              new Function<ParameterSpec, TypeName>() {
+                @Nullable
+                @Override
+                public TypeName apply(ParameterSpec parameterSpec) {
+                  return parameterSpec.type;
+                }
+              });
     }
 
     @Override
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
index 68cbdb6bd..6dea2d18d 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java
@@ -33,8 +33,8 @@
       ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
 
     this.processorUtil = processorUtil;
-    baseRequestOptionsType = processingEnv.getElementUtils().getTypeElement(
-        BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+    baseRequestOptionsType =
+        processingEnv.getElementUtils().getTypeElement(BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
   List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(TypeName typeToOverrideIn) {
@@ -44,45 +44,43 @@
 
   List<MethodSpec> generateInstanceMethodOverridesForRequestOptions(
       final TypeName typeToOverrideIn, final Set<String> excludedMethods) {
-    return
-        FluentIterable.from(
+    return FluentIterable.from(
             processorUtil.findInstanceMethodsReturning(
                 baseRequestOptionsType, baseRequestOptionsType))
-            .filter(new Predicate<ExecutableElement>() {
+        .filter(
+            new Predicate<ExecutableElement>() {
               @Override
               public boolean apply(ExecutableElement input) {
                 return !excludedMethods.contains(input.getSimpleName().toString());
               }
             })
-            .transform(
-        new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateRequestOptionOverride(typeToOverrideIn, input);
-          }
-        })
+        .transform(
+            new Function<ExecutableElement, MethodSpec>() {
+              @Override
+              public MethodSpec apply(ExecutableElement input) {
+                return generateRequestOptionOverride(typeToOverrideIn, input);
+              }
+            })
         .toList();
   }
 
   private MethodSpec generateRequestOptionOverride(
       TypeName typeToOverrideIn, ExecutableElement methodToOverride) {
     MethodSpec.Builder result =
-        ProcessorUtil.overriding(methodToOverride)
-            .returns(typeToOverrideIn);
+        ProcessorUtil.overriding(methodToOverride).returns(typeToOverrideIn);
     result.addCode(
         CodeBlock.builder()
+            .add("return ($T) super.$N(", typeToOverrideIn, methodToOverride.getSimpleName())
             .add(
-                "return ($T) super.$N(",
-                typeToOverrideIn,
-                methodToOverride.getSimpleName())
-            .add(FluentIterable.from(result.build().parameters)
-                .transform(new Function<ParameterSpec, String>() {
-                  @Override
-                  public String apply(ParameterSpec input) {
-                    return input.name;
-                  }
-                })
-                .join(Joiner.on(", ")))
+                FluentIterable.from(result.build().parameters)
+                    .transform(
+                        new Function<ParameterSpec, String>() {
+                          @Override
+                          public String apply(ParameterSpec input) {
+                            return input.name;
+                          }
+                        })
+                    .join(Joiner.on(", ")))
             .add(");\n")
             .build());
 
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
index 323a4b151..695a8d36e 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -20,13 +20,12 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class.
- */
+/** Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class. */
 @RunWith(JUnit4.class)
-public class AppGlideModuleWithExcludesTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class AppGlideModuleWithExcludesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -34,19 +33,21 @@ public void setUp() {
     compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
-            .compile(
-                forResource("AppModuleWithExcludes.java"),
-                emptyLibraryModule());
+            .compile(forResource("AppModuleWithExcludes.java"), emptyLibraryModule());
     assertThat(compilation).succeededWithoutWarnings();
   }
 
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
   @Test
   @ReferencedResource
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
   }
 
   @Test
@@ -54,8 +55,7 @@ public void compilation_generatesExpectedGlideOptionsClass() throws IOException
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
   }
 
   @Test
@@ -63,8 +63,7 @@ public void compilation_generatesExpectedGlideRequestClass() throws IOException
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
   }
 
   @Test
@@ -72,17 +71,14 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -90,9 +86,7 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
index d8090cf2c..24d316d31 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -20,13 +20,14 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests AppGlideModules that use the @Excludes annotation
- * with a single excluded Module class in a strangely named subpackage.
+ * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class in a
+ * strangely named subpackage.
  */
 @RunWith(JUnit4.class)
-public class AppGlideModuleWithLibraryInPackageTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class AppGlideModuleWithLibraryInPackageTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -40,13 +41,17 @@ public void setUp() {
     assertThat(compilation).succeededWithoutWarnings();
   }
 
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
   @Test
   @ReferencedResource
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
   }
 
   @Test
@@ -54,8 +59,7 @@ public void compilation_generatesExpectedGlideOptionsClass() throws IOException
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
   }
 
   @Test
@@ -63,8 +67,7 @@ public void compilation_generatesExpectedGlideRequestClass() throws IOException
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
   }
 
   @Test
@@ -72,17 +75,14 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -90,9 +90,7 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
index 86fb5b02b..e6484cdac 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -23,9 +23,10 @@
  * Tests AppGlideModules that use the @Excludes annotation with multiple excluded Module classes.
  */
 @RunWith(JUnit4.class)
-public class AppGlideModuleWithMultipleExcludesTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class AppGlideModuleWithMultipleExcludesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -40,13 +41,17 @@ public void setUp() {
     assertThat(compilation).succeededWithoutWarnings();
   }
 
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+
   @Test
   @ReferencedResource
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
   }
 
   @Test
@@ -54,8 +59,7 @@ public void compilation_generatesExpectedGlideOptionsClass() throws IOException
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
   }
 
   @Test
@@ -63,8 +67,7 @@ public void compilation_generatesExpectedGlideRequestClass() throws IOException
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
   }
 
   @Test
@@ -72,17 +75,14 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -90,9 +90,7 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
index d9c18209d..f0717103a 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
@@ -2,7 +2,6 @@
 
 import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
@@ -11,6 +10,7 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -25,13 +25,14 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty
- * {@link com.bumptech.glide.module.LibraryGlideModule} in a single project.
+ * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty {@link
+ * com.bumptech.glide.module.LibraryGlideModule} in a single project.
  */
 @RunWith(JUnit4.class)
-public class EmptyAppAndLibraryGlideModulesTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class EmptyAppAndLibraryGlideModulesTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -39,9 +40,7 @@ public void setUp() {
     compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
-            .compile(
-                emptyAppModule(),
-                emptyLibraryModule());
+            .compile(emptyAppModule(), emptyLibraryModule());
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -55,8 +54,7 @@ public void compilation_generatesAllExpectedFiles() {
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideOptions.java"));
   }
 
   @Test
@@ -64,8 +62,7 @@ public void compilation_generatesExpectedGlideOptionsClass() throws IOException
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
   }
 
   @Test
@@ -73,8 +70,7 @@ public void compilation_generatesExpectedGlideRequestClass() throws IOException
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
   }
 
   @Test
@@ -82,17 +78,14 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -100,9 +93,7 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   @Test
@@ -112,11 +103,15 @@ public void compilation_generatesExpectedIndexer() throws IOException {
         "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
     assertThat(compilation)
         .generatedSourceFile(annotation(expectedClassName))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));
+        .hasSourceEquivalentTo(libraryResource(expectedClassName + ".java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
index 8af5e23d9..f1f241d6c 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.annotation.compiler;
 
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
 import com.google.common.truth.Truth;
@@ -18,22 +18,20 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project.
- */
+/** Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project. */
 @RunWith(JUnit4.class)
-public class EmptyAppGlideModuleTest {
+public class EmptyAppGlideModuleTest implements CompilationProvider {
   private static final String MODULE_NAME = "EmptyAppModule.java";
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
   public void setUp() {
     compilation =
-        javac()
-            .withProcessors(new GlideAnnotationProcessor())
-            .compile(forResource(MODULE_NAME));
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(MODULE_NAME));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -46,54 +44,50 @@ public void compilation_generatesAllExpectedFiles() {
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideRequest.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideRequests.java"));
   }
 
   @Test
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideApp.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(forResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
-}
 
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
index f4776d227..935bd0528 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
 import com.google.common.truth.Truth;
@@ -17,22 +17,19 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project.
- */
+/** Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project. */
 @RunWith(JUnit4.class)
-public class EmptyLibraryGlideModuleTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class EmptyLibraryGlideModuleTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private static final String MODULE_NAME = "EmptyLibraryModule.java";
   private Compilation compilation;
 
   @Before
   public void setUp() {
     compilation =
-        javac()
-            .withProcessors(new GlideAnnotationProcessor())
-            .compile(forResource(MODULE_NAME));
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(MODULE_NAME));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -47,11 +44,15 @@ public void compilation_generatesExpectedIndexer() throws IOException {
         "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
     assertThat(compilation)
         .generatedSourceFile(annotation(expectedClassName))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource(expectedClassName + ".java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
index a3c64b275..196275e97 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.annotation.compiler;
 
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.SubDirectory;
 import com.bumptech.glide.annotation.compiler.test.TestDescription;
@@ -22,11 +22,13 @@
  * Verifies only the output we expect to change based on the various configurations of GlideOptions.
  */
 @RunWith(JUnit4.class)
-public class GlideExtensionOptionsTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class GlideExtensionOptionsTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   @Rule public final TestDescription testDescription = new TestDescription();
   private static final String EXTENSION_NAME = "Extension.java";
+  private Compilation currentCompilation;
 
   @Test
   @SubDirectory("OverrideExtend")
@@ -102,6 +104,11 @@ public void compilation_withSkipStaticMethod_validRequest() throws IOException {
     runTest(Subject.GlideRequest);
   }
 
+  @Override
+  public Compilation getCompilation() {
+    return currentCompilation;
+  }
+
   private enum Subject {
     GlideOptions,
     GlideRequest;
@@ -111,27 +118,21 @@ String file() {
     }
   }
 
-  private void runTest(Subject subject) throws IOException {
+  private void runTest(Subject subject) {
     String subDir = getSubDirectoryName();
-    Compilation compilation =
+    currentCompilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
-            .compile(
-                emptyAppModule(),
-                extension(subDir));
-    assertThat(compilation).succeededWithoutWarnings();
+            .compile(emptyAppModule(), extension(subDir));
+    assertThat(currentCompilation).succeededWithoutWarnings();
 
-    assertThat(compilation)
+    assertThat(currentCompilation)
         .generatedSourceFile(subpackage(subject.name()))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource(subDir, subject.file()).getCharContent(true)));
+        .hasSourceEquivalentTo(forResource(subDir, subject.file()));
   }
 
   private String getSubDirectoryName() {
-    return testDescription
-        .getDescription()
-        .getAnnotation(SubDirectory.class)
-        .value();
+    return testDescription.getDescription().getAnnotation(SubDirectory.class).value();
   }
 
   private JavaFileObject extension(String subdir) {
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
index a67555ea8..6159908d1 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -22,13 +22,14 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Verifies the output of the processor with a simple single extension option in the new
- * option style where extension methods always return values.
+ * Verifies the output of the processor with a simple single extension option in the new option
+ * style where extension methods always return values.
  */
 @RunWith(JUnit4.class)
-public class GlideExtensionWithOptionTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class GlideExtensionWithOptionTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -36,9 +37,7 @@ public void setUp() {
     compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
-            .compile(
-                emptyAppModule(),
-                forResource("ExtensionWithOption.java"));
+            .compile(emptyAppModule(), forResource("ExtensionWithOption.java"));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -51,16 +50,14 @@ public void compilation_generatesAllExpectedFiles() {
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideRequest.java"));
   }
 
   @Test
@@ -68,8 +65,7 @@ public void compilation_generatesExpectedGlideRequestClass() throws IOException
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequests.java"));
   }
 
   @Test
@@ -77,8 +73,7 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
@@ -86,9 +81,7 @@ public void compilationGeneratesExpectedGlideAppClass() throws IOException {
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -96,12 +89,15 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
index af4a4b747..8ed47e14c 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.glide;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
@@ -21,13 +21,12 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Verifies the output of the processor with a simple single extension type.
- */
+/** Verifies the output of the processor with a simple single extension type. */
 @RunWith(JUnit4.class)
-public class GlideExtensionWithTypeTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class GlideExtensionWithTypeTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -35,9 +34,7 @@ public void setUp() {
     compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
-            .compile(
-                emptyAppModule(),
-                forResource("ExtensionWithType.java"));
+            .compile(emptyAppModule(), forResource("ExtensionWithType.java"));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -50,8 +47,7 @@ public void compilation_generatesAllExpectedFiles() {
   public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideOptions"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideOptions.java"));
   }
 
   @Test
@@ -59,16 +55,14 @@ public void compilation_generatesExpectedGlideOptionsClass() throws IOException
   public void compilation_generatesExpectedGlideRequestClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequest"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideRequest.java"));
   }
 
   @Test
   public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideRequests"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource("GlideRequests.java"));
   }
 
   @Test
@@ -76,8 +70,7 @@ public void compilation_generatesExpectedGlideRequestsClass() throws IOException
   public void compilationGeneratesExpectedGlideAppClass() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(subpackage("GlideApp"))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GlideApp.java"));
   }
 
   @Test
@@ -85,9 +78,7 @@ public void compilationGeneratesExpectedGlideAppClass() throws IOException {
   public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedAppGlideModuleImpl.java"));
   }
 
   @Test
@@ -95,12 +86,15 @@ public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IO
   public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
     assertThat(compilation)
         .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
-        .contentsAsUtf8String()
-        .isEqualTo(
-            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+        .hasSourceEquivalentTo(appResource("GeneratedRequestManagerFactory.java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
index a54f7565e..36cd916be 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
@@ -11,9 +11,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests AppGlideModules with invalid usages of the @Excludes annotation.
- */
+/** Tests AppGlideModules with invalid usages of the @Excludes annotation. */
 // Ignore warnings since most methods use assertThrows
 @SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(JUnit4.class)
@@ -63,7 +61,7 @@ public void compilation_withEmptyExcludes_fails() {
 
   @Test
   public void compilation_withNonGlideModule_throws() {
-     Compilation compilation =
+    Compilation compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
             .compile(
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
index 2641be120..ae7568cc8 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -12,9 +12,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves.
- */
+/** Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves. */
 // Avoid warnings when asserting on exceptions.
 @SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(JUnit4.class)
@@ -37,7 +35,6 @@ public void compilation_withPublicConstructor_fails() {
       Throwable cause = e.getCause();
       Truth.assertThat(cause.getMessage()).contains("non-private constructor");
       Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
-
     }
   }
 
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
index e1516bdcb..4e5b7a100 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -81,62 +81,35 @@ public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOr
 
   @Test
   public void compilation_withAnnotatedStaticMethod_withRequestOptionsArg_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption",
-                "  public static BaseRequestOptions<?> doSomething(",
-                "      BaseRequestOptions<?> options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeeded();
   }
 
   @Test
   public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgAndOtherArg_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption",
-                "  public static BaseRequestOptions<?> doSomething(",
-                "      BaseRequestOptions<?> options, Object arg2) {",
-                "    return options;",
-                "  }",
-                "}"));
-    assertThat(compilation).succeeded();
-  }
-
-  @Test
-  public void compilation_overridingOptionWithoutAnnotationType_fails() {
-    assertThrows(
-        RuntimeException.class,
-        new ThrowingRunnable() {
-          @Override
-          public void run() {
-            javac()
-                .withProcessors(new GlideAnnotationProcessor())
-                .compile(
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
                 emptyAppModule(),
                 JavaFileObjects.forSourceLines(
                     "Extension",
@@ -148,12 +121,40 @@ public void run() {
                     "public class Extension {",
                     "  private Extension() {}",
                     "  @GlideOption",
-                    "  public static BaseRequestOptions<?> centerCrop(",
-                    "      BaseRequestOptions<?> options) {",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options, Object arg2) {",
                     "    return options;",
                     "  }",
                     "}"));
+    assertThat(compilation).succeeded();
+  }
 
+  @Test
+  public void compilation_overridingOptionWithoutAnnotationType_fails() {
+    assertThrows(
+        RuntimeException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() {
+            javac()
+                .withProcessors(new GlideAnnotationProcessor())
+                .compile(
+                    emptyAppModule(),
+                    JavaFileObjects.forSourceLines(
+                        "Extension",
+                        "package com.bumptech.glide.test;",
+                        "import com.bumptech.glide.annotation.GlideExtension;",
+                        "import com.bumptech.glide.annotation.GlideOption;",
+                        "import com.bumptech.glide.request.BaseRequestOptions;",
+                        "@GlideExtension",
+                        "public class Extension {",
+                        "  private Extension() {}",
+                        "  @GlideOption",
+                        "  public static BaseRequestOptions<?> centerCrop(",
+                        "      BaseRequestOptions<?> options) {",
+                        "    return options;",
+                        "  }",
+                        "}"));
           }
         });
   }
@@ -190,25 +191,26 @@ public void run() {
 
   @Test
   public void compilation_withOverrideExtend_andOverridingMethod_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
-                "  public static BaseRequestOptions<?> centerCrop(",
-                "      BaseRequestOptions<?> options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                    "  public static BaseRequestOptions<?> centerCrop(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeeded();
   }
 
@@ -244,51 +246,53 @@ public void run() {
 
   @Test
   public void compilation_withOverrideReplace_andOverridingMethod_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
-                "  public static BaseRequestOptions<?> centerCrop(",
-                "      BaseRequestOptions<?> options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                    "  public static BaseRequestOptions<?> centerCrop(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeeded();
   }
 
   @Test
   public void compilation_withRequestOptionsReturnValue_succeeds() {
-     Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import android.support.annotation.NonNull;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @NonNull",
-                "  @GlideOption",
-                "  public static BaseRequestOptions<?> doSomething(",
-                "      BaseRequestOptions<?> options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -327,25 +331,26 @@ public void compilation_withNonRequestOptionsReturnValue_fails() {
 
   @Test
   public void compilation_withMissingNonNullAnnotation_warns() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.BaseRequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption",
-                "  public static BaseRequestOptions<?> doSomething(",
-                "      BaseRequestOptions<?> options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideOption;",
+                    "import com.bumptech.glide.request.BaseRequestOptions;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideOption",
+                    "  public static BaseRequestOptions<?> doSomething(",
+                    "      BaseRequestOptions<?> options) {",
+                    "    return options;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeeded();
     assertThat(compilation).hadWarningCount(1);
     assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
index 0a4c91c82..656bfb1b5 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.annotation.compiler;
 
-
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
@@ -89,26 +88,27 @@ public void run() {
 
   @Test
   public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import android.support.annotation.NonNull;",
-                "import com.bumptech.glide.RequestBuilder;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideType;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @NonNull",
-                "  @GlideType(Number.class)",
-                "  public static RequestBuilder<Number> type(RequestBuilder<Number> builder) {",
-                "    return builder;",
-                "  }",
-                "}"));
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> type(RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -307,8 +307,7 @@ public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectT
       String message = e.getCause().getMessage();
       Truth.assertThat(message)
           .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
-      Truth.assertThat(message)
-          .contains("WrongBuilderTypeExtension");
+      Truth.assertThat(message).contains("WrongBuilderTypeExtension");
     }
   }
 
@@ -375,8 +374,10 @@ public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderPar
       fail();
     } catch (RuntimeException e) {
       String message = e.getCause().getMessage();
-      Truth.assertThat(message).contains("@GlideType methods must take a RequestBuilder object"
-          + " as their first and only parameter");
+      Truth.assertThat(message)
+          .contains(
+              "@GlideType methods must take a RequestBuilder object"
+                  + " as their first and only parameter");
       Truth.assertThat(message).contains("Object");
       Truth.assertThat(message).contains("IncorrectParameterExtension");
     }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
index a80590d83..3cec01e4a 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
@@ -4,6 +4,7 @@
 import static com.google.testing.compile.Compiler.javac;
 import static org.junit.Assert.assertThrows;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
 import com.google.testing.compile.Compilation;
@@ -19,11 +20,14 @@
  * will fail.
  */
 @RunWith(JUnit4.class)
-public class MultipleAppGlideModuleTest {
+public class MultipleAppGlideModuleTest implements CompilationProvider {
   private static final String FIRST_MODULE = "EmptyAppModule1.java";
   private static final String SECOND_MODULE = "EmptyAppModule2.java";
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
+  private Compilation compilation;
 
   // Throws.
   @SuppressWarnings("ResultOfMethodCallIgnored")
@@ -43,21 +47,24 @@ public void run() throws Throwable {
 
   @Test
   public void compilation_withFirstModuleOnly_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(forResource(FIRST_MODULE));
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(FIRST_MODULE));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
   @Test
   public void compilation_withSecondModuleOnly_succeeds() {
-    Compilation compilation = javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(forResource(SECOND_MODULE));
+    compilation =
+        javac().withProcessors(new GlideAnnotationProcessor()).compile(forResource(SECOND_MODULE));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
index b576c08a7..5d6f6947f 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.annotation.compiler;
 
 import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
-import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 
+import com.bumptech.glide.annotation.compiler.test.CompilationProvider;
 import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
 import com.bumptech.glide.annotation.compiler.test.Util;
 import com.google.common.truth.Truth;
@@ -17,13 +17,12 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project.
- */
+/** Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project. */
 @RunWith(JUnit4.class)
-public class MultipleEmptyLibraryGlideModuleTest {
-  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
-      new RegenerateResourcesRule(getClass());
+public class MultipleEmptyLibraryGlideModuleTest implements CompilationProvider {
+  @Rule
+  public final RegenerateResourcesRule regenerateResourcesRule = new RegenerateResourcesRule(this);
+
   private Compilation compilation;
 
   @Before
@@ -32,8 +31,7 @@ public void setUp() {
         javac()
             .withProcessors(new GlideAnnotationProcessor())
             .compile(
-                forResource("EmptyLibraryModule1.java"),
-                forResource("EmptyLibraryModule2.java"));
+                forResource("EmptyLibraryModule1.java"), forResource("EmptyLibraryModule2.java"));
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -49,11 +47,15 @@ public void compilation_generatesExpectedIndexerForModules() throws IOException
             + "_test_EmptyLibraryModule2";
     assertThat(compilation)
         .generatedSourceFile(annotation(expectedClassName))
-        .contentsAsUtf8String()
-        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+        .hasSourceEquivalentTo(forResource(expectedClassName + ".java"));
   }
 
   private JavaFileObject forResource(String name) {
     return Util.forResource(getClass().getSimpleName(), name);
   }
+
+  @Override
+  public Compilation getCompilation() {
+    return compilation;
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java
new file mode 100644
index 000000000..41688bf9d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/CompilationProvider.java
@@ -0,0 +1,8 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.Compilation;
+
+/** Provides the {@link Compilation} used to compile test code. */
+public interface CompilationProvider {
+  Compilation getCompilation();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
index b7194411d..c3366c323 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
@@ -9,16 +9,15 @@
  * Indicates that the method in question is referencing a test resource that it doesn't "own" and
  * should not attempt to regenerate.
  *
- * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources,
- * we're only regenerating them for a single class and only for the single class that has the
- * correct name and directory sequence so that we update the correct file.
+ * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources, we're
+ * only regenerating them for a single class and only for the single class that has the correct name
+ * and directory sequence so that we update the correct file.
  *
  * <p>Ideally this wouldn't be necessary. It would be great if we could find a way to go from the
  * test failure more directly to the actual path of the resource used. Right now we're basically
- * guessing based on this annotation, the class name of the test class, and any values from
- * {@link SubDirectory}. Without this annotation, we'd end up writing files that were never used.
+ * guessing based on this annotation, the class name of the test class, and any values from {@link
+ * SubDirectory}. Without this annotation, we'd end up writing files that were never used.
  */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface ReferencedResource {
-}
+public @interface ReferencedResource {}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
index 66f48c767..7f49f5f27 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
@@ -7,30 +7,28 @@
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
-import org.junit.ComparisonFailure;
+import javax.tools.JavaFileObject;
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
 /**
- * Regenerates test resources for annotation compiler tests when the
- * {@link Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing
- * the project.
+ * Regenerates test resources for annotation compiler tests when the {@link
+ * Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing the
+ * project.
  *
- * <p>This can easily be used via gradle by running:
- * {@code
- *  ./gradlew :annotation:compiler:test:regenerateTestResources
- * }
+ * <p>This can easily be used via gradle by running: {@code ./gradlew
+ * :annotation:compiler:test:regenerateTestResources }
  *
  * <p>Our regenerate task will set the appropriate environment variables that will allow the logic
  * here to succeed. When running the tests normally, this class will do nothing.
  */
 public final class RegenerateResourcesRule implements TestRule {
 
-  private final Class<?> testClass;
+  private CompilationProvider test;
 
-  public RegenerateResourcesRule(Class<?> testClass) {
-    this.testClass = testClass;
+  public RegenerateResourcesRule(CompilationProvider test) {
+    this.test = test;
   }
 
   @Override
@@ -40,7 +38,7 @@ public Statement apply(final Statement base, final Description description) {
       public void evaluate() throws Throwable {
         try {
           base.evaluate();
-        } catch (ComparisonFailure e) {
+        } catch (AssertionError e) {
           String projectRoot = Util.getProjectRootIfRegeneratingTestResources();
           if (projectRoot == null || description.getAnnotation(ReferencedResource.class) != null) {
             throw e;
@@ -52,8 +50,8 @@ public void evaluate() throws Throwable {
   }
 
   private void updateResourceFile(
-      ComparisonFailure e, @NonNull String projectDirectory, Description description) {
-    String testClassName = testClass.getSimpleName();
+      AssertionError e, @NonNull String projectDirectory, Description description) {
+    String testClassName = test.getClass().getSimpleName();
     String testFileName = parseFileNameFromMessage(e);
     String testDirectory = projectDirectory + "/src/test/resources/" + testClassName;
     String subDirectorySegment =
@@ -75,7 +73,7 @@ private void updateResourceFile(
     Writer writer = null;
     try {
       writer = new FileWriter(expectedFile);
-      writer.write(asUnixChars(e.getActual()).toString());
+      writer.write(asUnixChars(parseActual(testFileName)).toString());
       writer.close();
     } catch (IOException e1) {
       throw new RuntimeException("Failed to regenerate test file", e1);
@@ -90,8 +88,21 @@ private void updateResourceFile(
     }
   }
 
+  private String parseActual(String fileName) {
+    for (JavaFileObject javaFileObject : test.getCompilation().generatedSourceFiles()) {
+      if (javaFileObject.getName().contains(fileName)) {
+        try {
+          return javaFileObject.getCharContent(true).toString();
+        } catch (IOException e) {
+          throw new IllegalStateException(e);
+        }
+      }
+    }
+    throw new IllegalStateException("Failed to find source file for name: " + fileName);
+  }
+
   // Parses </SOURCE_OUTPUT/com/bumptech/glide/test/GlideOptions.java> to GlideOptions.java.
-  private static String parseFileNameFromMessage(ComparisonFailure e) {
+  private static String parseFileNameFromMessage(AssertionError e) {
     String message = e.getMessage();
     int firstGreaterThanIndex = message.indexOf('>');
     String substring = message.substring(0, firstGreaterThanIndex);
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
index c0023498a..ad1d0eb23 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.annotation.compiler.test;
 
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -10,8 +9,8 @@
  * Indicates the subdirectory for a particular test that contains the test resource(s) used for the
  * method.
  *
- * <p>Used both by tests to extract the correct subdirectory and by the
- * {@link RegenerateResourcesRule} for the same purpose.
+ * <p>Used both by tests to extract the correct subdirectory and by the {@link
+ * RegenerateResourcesRule} for the same purpose.
  */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
index 2b4c7c72c..1df6aa6c1 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
@@ -4,11 +4,12 @@
 import org.junit.runner.Description;
 
 /**
- * Exposes the {@link Description} for the current test, similar to
- * {@link org.junit.rules.TestName}.
+ * Exposes the {@link Description} for the current test, similar to {@link
+ * org.junit.rules.TestName}.
  */
 public final class TestDescription extends TestWatcher {
   private Description description;
+
   @Override
   protected void starting(Description description) {
     this.description = description;
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
index 64c4f9f08..85d51e38c 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
@@ -17,6 +17,7 @@
    * the unix one.
    */
   private static final String FILE_SEPARATOR = "/";
+
   private static final String LINE_SEPARATOR = "\n";
 
   private Util() {
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
index ecb3b4b05..eb90e12a3 100644
--- a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -4,9 +4,6 @@
 import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.test.AppModuleWithExcludes;
-import java.lang.Class;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 import java.util.HashSet;
 import java.util.Set;
 
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
index 7ab08a74a..a17695bb9 100644
--- a/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java
@@ -4,9 +4,6 @@
 import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.test.AppModuleWithLibraryInPackage;
-import java.lang.Class;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 import java.util.HashSet;
 import java.util.Set;
 
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
index af059c6b1..5a1ab6cf5 100644
--- a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -4,9 +4,6 @@
 import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.test.AppModuleWithMultipleExcludes;
-import java.lang.Class;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 import java.util.HashSet;
 import java.util.Set;
 
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
index 6e307e0ff..96cba1335 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
@@ -5,9 +5,6 @@
 import android.util.Log;
 import com.bumptech.glide.test.EmptyAppModule;
 import com.bumptech.glide.test.EmptyLibraryModule;
-import java.lang.Class;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 import java.util.Collections;
 import java.util.Set;
 
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
index f960738d9..d5cf1ca51 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
@@ -4,9 +4,6 @@
 import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.test.EmptyAppModule;
-import java.lang.Class;
-import java.lang.Override;
-import java.lang.SuppressWarnings;
 import java.util.Collections;
 import java.util.Set;
 
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
index 2a442b0a5..999607c8d 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
@@ -6,7 +6,6 @@
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.test.GlideRequests;
-import java.lang.Override;
 
 /**
  * Generated code, do not modify
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
index 881e98c1b..96ca53a8a 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
@@ -12,8 +12,6 @@
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import java.io.File;
-import java.lang.Deprecated;
-import java.lang.String;
 
 /**
  * The entry point for interacting with Glide for Applications
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
index 41b9eb986..d98aa03c3 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
index 42346164b..2d55ccb10 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
index 9f8cd70cc..2f7e861a6 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -17,13 +17,6 @@
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
index 5cdd03bec..8270da4d9 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
index f3edeea92..96f1f0b02 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
index 10605ac8e..dff549eee 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
index b15070a1b..c4256bca3 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
index 0fa5e1aa2..f7fb1fd8d 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
index f68d6f476..7abc02c1e 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
index 41baaf8ff..147f09618 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
index f4d3bcaa3..cdbc9321e 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
index 9e4a0f16c..dab17f969 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
index f3edeea92..96f1f0b02 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
index 872ab87ed..55c96523b 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
index f3edeea92..96f1f0b02 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
index 311b65c3a..a4b107190 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
index 95a2ffd7d..6201159f0 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -26,15 +26,6 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestListener;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
index 74ffc0dc0..3de187995 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -18,12 +18,6 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.RequestOptions;
-import java.lang.Class;
-import java.lang.Cloneable;
-import java.lang.Deprecated;
-import java.lang.Override;
-import java.lang.SafeVarargs;
-import java.lang.SuppressWarnings;
 
 /**
  * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
index bb35a9fa8..1371210f5 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -17,14 +17,6 @@
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.RequestOptions;
 import java.io.File;
-import java.lang.Class;
-import java.lang.Deprecated;
-import java.lang.Integer;
-import java.lang.Number;
-import java.lang.Object;
-import java.lang.Override;
-import java.lang.String;
-import java.lang.SuppressWarnings;
 import java.net.URL;
 
 /**
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
index 13de814b2..ec5b5cdef 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -6,8 +6,8 @@
 import java.lang.annotation.Target;
 
 /**
- * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
- * from an application.
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded from an
+ * application.
  *
  * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
  *
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
index 790c42bf7..2792e5507 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -12,4 +12,4 @@
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.CLASS)
-public @interface GlideExtension { }
+public @interface GlideExtension {}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index 7db045996..b6fdb2942 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -15,8 +15,8 @@
 @Retention(RetentionPolicy.CLASS)
 public @interface GlideModule {
   /**
-   * Returns the name of the class that will be used as a replacement for
-   * {@code com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   * Returns the name of the class that will be used as a replacement for {@code
+   * com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
    */
   String glideName() default "GlideApp";
 }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
index 58197a802..c2f3c3229 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -6,28 +6,27 @@
 import java.lang.annotation.Target;
 
 /**
- * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@code com.bumptech.glide.request.RequestOptions}.
+ * Identifies methods in {@link GlideExtension} annotated classes that extend {@code
+ * com.bumptech.glide.request.RequestOptions}.
  *
- * <p>All annotated methods will be added to a single
- * {@code com.bumptech.glide.request.RequestOptions} implementation generated per application.
- * Overlapping method names in different extensions may cause errors at compile time.
+ * <p>All annotated methods will be added to a single {@code
+ * com.bumptech.glide.request.RequestOptions} implementation generated per application. Overlapping
+ * method names in different extensions may cause errors at compile time.
  *
  * <p>Static equivalents of annotated methods will also be generated.
  *
  * <p>Methods with this annotation will only be found if they belong to classes annotated with
  * {@link GlideExtension}.
  *
- * <p>The preferred way of writing extension methods returns the provided
- * {@code com.bumptech.glide.request.RequestOptions} object with one or more methods called on it.
- * You must not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object
- * as doing so my cause a {@code ClassCastException} at runtime. Calling either
- * {@code com.bumptech.glide.request.RequestOptions#autoClone()} or
- * {@code com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should
- * typically be avoided. The preferred style looks like:
+ * <p>The preferred way of writing extension methods returns the provided {@code
+ * com.bumptech.glide.request.RequestOptions} object with one or more methods called on it. You must
+ * not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object as doing
+ * so my cause a {@code ClassCastException} at runtime. Calling either {@code
+ * com.bumptech.glide.request.RequestOptions#autoClone()} or {@code
+ * com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should typically
+ * be avoided. The preferred style looks like:
  *
- * <pre>
- * {@code
+ * <pre>{@code
  * {@link @}GlideExtension
  * public class MyExtension {
  *   private MyExtension() {}
@@ -39,18 +38,16 @@
  *         .optionTwo();
  *   }
  * }
- * }
- * </pre>
+ * }</pre>
  *
- * <p>The deprecated way of writing extension methods is simply a static void method. The
- * {@code com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this
- * method to avoid an option method returning a new instance, but using methods like
- * {@code com.bumptech.glide.request.RequestOptions#clone()} or
- * {@code com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in
- * the method being silently ignored. Prefer the new style whenever possible.
+ * <p>The deprecated way of writing extension methods is simply a static void method. The {@code
+ * com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this method to
+ * avoid an option method returning a new instance, but using methods like {@code
+ * com.bumptech.glide.request.RequestOptions#clone()} or {@code
+ * com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in the
+ * method being silently ignored. Prefer the new style whenever possible.
  *
- * <pre>
- * {@code
+ * <pre>{@code
  * {@literal @}GlideExtension
  * public class MyExtension {
  *   private MyExtension() {}
@@ -63,14 +60,13 @@
  *         .optionTwo();
  *   }
  * }
- * }
- * </pre>
+ * }</pre>
  */
 @Target(ElementType.METHOD)
 // Needs to be parsed from class files in JAR.
 @Retention(RetentionPolicy.CLASS)
 public @interface GlideOption {
-   /** Does not intend to override a method in a super class. */
+  /** Does not intend to override a method in a super class. */
   int OVERRIDE_NONE = 0;
   /** Expects to call super and then add additional functionality to an overridden method. */
   int OVERRIDE_EXTEND = 1;
@@ -111,11 +107,12 @@
   /**
    * {@code true} to prevent a static builder method from being generated.
    *
-   * <p>By default static methods are generated for all methods annotated with
-   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
-   * with {@code com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
-   * simply creates a new {@code com.bumptech.glide.request.RequestOptions} object, calls the
-   * instance version of the method on it and returns it. For example:
+   * <p>By default static methods are generated for all methods annotated with {@link GlideOption}.
+   * These static factory methods allow for a cleaner API when used with {@code
+   * com.bumptech.glide.RequestBuilder#apply}. The static factory method by default simply creates a
+   * new {@code com.bumptech.glide.request.RequestOptions} object, calls the instance version of the
+   * method on it and returns it. For example:
+   *
    * <pre>
    * <code>
    * public static GlideOptions noAnimation() {
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
index d3538d99b..9cf17c836 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -6,8 +6,8 @@
 import java.lang.annotation.Target;
 
 /**
- * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@code com.bumptech.glide.RequestManager}.
+ * Identifies methods in {@link GlideExtension} annotated classes that extend {@code
+ * com.bumptech.glide.RequestManager}.
  *
  * <p>If one or more method is found with this annotation, an additional API entry point that
  * exposes a generated {@code com.bumptech.glide.RequestManager} subclass will be created. The
@@ -21,9 +21,9 @@
  * <p>Methods with this annotation will only be found if they are contained in a class annotated
  * with {@link GlideExtension}.
  *
- * <p>Methods annotated with GlideType must have a single parameter. The type of the
- * single parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type
- * matching the value of {@link #value()}.
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the single
+ * parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type matching the value of
+ * {@link #value()}.
  *
  * <p>Compilation will fail if a method annotated with this method is identical to a method in
  * {@code com.bumptech.glide.RequestManager}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
index 81ba54ae1..f9c9d541f 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -16,5 +16,6 @@
 @Retention(RetentionPolicy.CLASS)
 @interface Index {
   String[] modules() default {};
+
   String[] extensions() default {};
 }
diff --git a/build.gradle b/build.gradle
index ea8d78df5..2b10d33d1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,6 +19,8 @@ buildscript {
             classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}"
         }
         classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}"
+        // TODO: Re-enable once import ordering is consistent when exporting with Copybara.
+//        classpath "com.diffplug.spotless:spotless-plugin-gradle:3.23.0"
     }
 }
 
@@ -92,6 +94,24 @@ subprojects { project ->
         duplicatesStrategy = DuplicatesStrategy.FAIL
     }
 
+    // TODO: Re-enable once import ordering is consistent when exporting with Copybara.
+//    def isDisallowedProject =
+//            project.name in ["third_party", "gif_decoder", "gif_encoder", "disklrucache"]
+//    if (!isDisallowedProject) {
+//        apply plugin: "com.diffplug.gradle.spotless"
+//
+//        spotless {
+//            java {
+//                target fileTree('.') {
+//                    include '**/*.java'
+//                    exclude '**/resources/**'
+//                    exclude '**/build/**'
+//                }
+//                googleJavaFormat()
+//            }
+//        }
+//    }
+
     apply plugin: 'checkstyle'
 
     checkstyle {
diff --git a/checkstyle.xml b/checkstyle.xml
index 52a2c2e5d..74ff0487c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -73,7 +73,7 @@
 
         <!-- Allow common trailing comments used to describe suppressions -->
         <module name="TrailingComment">
-          <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
+            <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
         </module>
 
         <!-- Checks for imports. -->
@@ -104,34 +104,6 @@
             <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />
         </module>
 
-        <module name="ImportOrder">
-          <!-- Checks for out of order import statements. -->
-
-          <property name="sortStaticImportsAlphabetically" value="true"/>
-           <property name="severity" value="error"/>
-           <property name="groups" value="*"/>
-           <!-- This ensures that static imports go first. -->
-           <property name="option" value="top"/>
-           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
-           <property name="separated" value="true" />
-         </module>
-
-        <!-- Checks for whitespace. -->
-        <!-- See http://checkstyle.sourceforge.net/config_whitespace.html -->
-        <module name="GenericWhitespace" />
-        <module name="MethodParamPad" />
-        <module name="NoWhitespaceAfter">
-            <property name="tokens"
-                      value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS" />
-        </module>
-        <module name="NoWhitespaceBefore" />
-        <module name="OperatorWrap" />
-        <module name="ParenPad" />
-        <module name="TypecastParenPad" />
-        <module name="WhitespaceAfter" />
-        <module name="WhitespaceAround" />
-
-
         <!-- Modifier Checks. -->
         <!-- See http://checkstyle.sourceforge.net/config_modifier.html -->
         <module name="ModifierOrder" />
@@ -139,7 +111,7 @@
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
         <module name="AvoidNestedBlocks">
-          <property name="allowInSwitchCase" value="true" />
+            <property name="allowInSwitchCase" value="true" />
         </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
@@ -149,7 +121,7 @@
         <module name="LeftCurly" />
         <module name="RightCurly">
             <property name="tokens"
-                      value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_ELSE" />
+              value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_ELSE" />
         </module>
 
         <!-- Checks for common coding problems. -->
@@ -166,13 +138,10 @@
         <module name="SimplifyBooleanReturn" />
         <module name="StringLiteralEquality" />
         <module name="UnnecessaryParentheses" />
-        <module name="LineLength">
-            <property name="max" value="100" />
-        </module>
 
         <!-- Checks for class design. -->
         <!-- See http://checkstyle.sourceforge.net/config_design.html -->
         <module name="FinalClass" />
         <module name="InterfaceIsType" />
     </module>
-</module>
+</module>
\ No newline at end of file
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
index fdc9d34cd..6ed6f2555 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -45,10 +45,7 @@ public void setUp() throws IOException {
   public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
     byte[] data =
         concurrency.get(
-            Glide.with(context)
-                .as(byte[].class)
-                .load(ResourceIds.raw.canonical)
-                .submit());
+            Glide.with(context).as(byte[].class).load(ResourceIds.raw.canonical).submit());
     assertThat(data).isNotNull();
     assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
   }
@@ -56,12 +53,7 @@ public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
   @Test
   public void loadBitmap_asBytes_providesBytesOfBitmap() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    byte[] data =
-        concurrency.get(
-            Glide.with(context)
-                .as(byte[].class)
-                .load(bitmap)
-                .submit());
+    byte[] data = concurrency.get(Glide.with(context).as(byte[].class).load(bitmap).submit());
 
     assertThat(data).isNotNull();
     assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
@@ -84,11 +76,7 @@ public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
   @Test
   public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
     byte[] data =
-        concurrency.get(
-            Glide.with(context)
-                .as(byte[].class)
-                .load(ResourceIds.raw.video)
-                .submit());
+        concurrency.get(Glide.with(context).as(byte[].class).load(ResourceIds.raw.video).submit());
 
     assertThat(data).isNotNull();
     assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
@@ -111,11 +99,7 @@ public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
   @Test
   public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
     byte[] data =
-        concurrency.get(
-            Glide.with(context)
-                .as(byte[].class)
-                .load(writeVideoToFile())
-                .submit());
+        concurrency.get(Glide.with(context).as(byte[].class).load(writeVideoToFile()).submit());
 
     assertThat(data).isNotNull();
     assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
@@ -166,10 +150,7 @@ public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws
   public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
     byte[] data =
         concurrency.get(
-            Glide.with(context)
-                .as(byte[].class)
-                .load(Uri.fromFile(writeVideoToFile()))
-                .submit());
+            Glide.with(context).as(byte[].class).load(Uri.fromFile(writeVideoToFile())).submit());
 
     assertThat(data).isNotNull();
     assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
index 9d89d6838..d9abe6d67 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide;
 
-
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
@@ -37,12 +36,7 @@ public void setUp() {
 
   @Test
   public void asFile_withUrl_succeeds() {
-    File file =
-        concurrency.get(
-            GlideApp.with(context)
-                .asFile()
-                .load(URL)
-                .submit());
+    File file = concurrency.get(GlideApp.with(context).asFile().load(URL).submit());
     assertThat(file).isNotNull();
   }
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index 03f2e9298..86443b823 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -59,8 +59,7 @@
 public class CachingTest {
   private static final int IMAGE_SIZE_PIXELS = 500;
   // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
-  private static final long CACHE_SIZE_BYTES =
-      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+  private static final long CACHE_SIZE_BYTES = IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
 
   @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
   @Mock private RequestListener<Drawable> requestListener;
@@ -78,46 +77,32 @@ public void setUp() {
 
   @Test
   public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
-    Glide.init(
-        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+    Glide.init(context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
 
-    FutureTarget<Drawable> first =
-        GlideApp.with(context)
-            .load(raw.canonical)
-            .submit();
+    FutureTarget<Drawable> first = GlideApp.with(context).load(raw.canonical).submit();
     concurrency.get(first);
 
     concurrency.get(
-        GlideApp.with(context)
-            .load(ResourceIds.raw.canonical)
-            .listener(requestListener)
-            .submit());
+        GlideApp.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
 
     verify(requestListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.MEMORY_CACHE),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
   public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
-    Glide.init(
-        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+    Glide.init(context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
 
     // Allow the request to be run and GCed without being cleared.
-    concurrency.loadOnOtherThread(new Runnable() {
-      @Override
-      public void run() {
-        FutureTarget<Drawable> first =
-            GlideApp.with(context)
-                .load(raw.canonical)
-                .submit();
-        concurrency.get(first);
-      }
-    });
+    concurrency.loadOnOtherThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            FutureTarget<Drawable> first = GlideApp.with(context).load(raw.canonical).submit();
+            concurrency.get(first);
+          }
+        });
 
     // Wait for the weak reference to be cleared and the request to be removed from active
     // resources.
@@ -150,10 +135,7 @@ public void run() {
     }
 
     concurrency.get(
-        GlideApp.with(context)
-            .load(ResourceIds.raw.canonical)
-            .listener(requestListener)
-            .submit());
+        GlideApp.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
 
     verify(requestListener)
         .onResourceReady(
@@ -177,10 +159,11 @@ public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCac
             .setDiskCacheExecutor(mainThreadExecutor)
             .setAnimationExecutor(mainThreadExecutor));
 
-    FutureTarget<Drawable> future = GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    FutureTarget<Drawable> future =
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
     concurrency.get(future);
     GlideApp.with(context).clear(future);
 
@@ -226,11 +209,7 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFr
 
     verify(requestListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.MEMORY_CACHE),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -250,11 +229,12 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecy
     Runtime.getRuntime().gc();
     concurrency.pokeMainThread();
 
-    FutureTarget<Bitmap> future = GlideApp.with(context)
-        .asBitmap()
-        .load(ResourceIds.raw.canonical)
-        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    FutureTarget<Bitmap> future =
+        GlideApp.with(context)
+            .asBitmap()
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
     concurrency.get(future);
     Glide.with(context).clear(future);
 
@@ -323,14 +303,10 @@ public void clearDiskCache_doesNotPreventFutureLoads() {
   public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
     final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
 
-    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context)
-        .load(waitModel)
-        .submit();
+    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context).load(waitModel).submit();
 
-    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context)
-        .load(waitModel)
-        .onlyRetrieveFromCache(true)
-        .submit();
+    FutureTarget<Drawable> onlyFromCacheFuture =
+        GlideApp.with(context).load(waitModel).onlyRetrieveFromCache(true).submit();
     try {
       onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
       fail("Expected only from cache Future to time out");
@@ -350,22 +326,22 @@ public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doe
     // Block the main thread so that we know that both requests will be queued but not started at
     // the same time.
     final CountDownLatch blockMainThread = new CountDownLatch(1);
-    new Handler(Looper.getMainLooper()).post(new Runnable() {
-      @Override
-      public void run() {
-         try {
-          blockMainThread.await();
-        } catch (InterruptedException e) {
-          throw new RuntimeException(e);
-        }
-      }
-    });
+    new Handler(Looper.getMainLooper())
+        .post(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  blockMainThread.await();
+                } catch (InterruptedException e) {
+                  throw new RuntimeException(e);
+                }
+              }
+            });
 
     // Queue the retrieve from cache request first.
-    final Future<Drawable> firstQueuedFuture = GlideApp.with(context)
-        .load(ResourceIds.raw.canonical)
-        .onlyRetrieveFromCache(true)
-        .submit();
+    final Future<Drawable> firstQueuedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).onlyRetrieveFromCache(true).submit();
 
     // Then queue the normal request.
     FutureTarget<Drawable> expectedFuture =
@@ -421,11 +397,7 @@ public void run() {
 
     verify(requestListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.MEMORY_CACHE),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -464,11 +436,7 @@ public void run() {
 
     verify(requestListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.MEMORY_CACHE),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -511,11 +479,12 @@ public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent
   }
 
   private void clearMemoryCacheOnMainThread() {
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
index b98962c90..7a6f39c49 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -55,7 +55,7 @@ public void centerCrop_withSquareSmallerThanImage_returnsSquareImage()
   @Test
   public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
       throws ExecutionException, InterruptedException {
-     Bitmap result =
+    Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
                 .asBitmap()
@@ -70,7 +70,7 @@ public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
   public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage()
       throws ExecutionException, InterruptedException {
     Bitmap result =
-          bitmapRegressionTester.test(
+        bitmapRegressionTester.test(
             GlideApp.with(context)
                 .asBitmap()
                 .load(canonical.getBitmap())
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
index 0f9d5727f..42294b448 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -62,10 +62,10 @@ public void centerInside_withSquareLargerThanImage_returnsOriginalImage()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .centerInside()
-              .override(multipliedWidth));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(multipliedWidth));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth());
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight());
@@ -77,10 +77,10 @@ public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .centerInside()
-              .override(canonical.getWidth() / 10, canonical.getHeight()));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
@@ -89,13 +89,13 @@ public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
   @Test
   public void centerInside_withShortRectangle_fitsWithinMaintainingAspectRatio()
       throws ExecutionException, InterruptedException {
-     Bitmap result =
+    Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .centerInside()
-              .override(canonical.getWidth(), canonical.getHeight() / 2));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
index a2df666d1..34b0b3e80 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -61,10 +61,10 @@ public void circleCrop_withSquareLargerThanImage_returnsUpscaledFitImage()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .circleCrop()
-              .override(multipliedWidth));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(multipliedWidth));
 
     assertThat(result.getWidth()).isEqualTo(multipliedWidth);
     assertThat(result.getHeight()).isEqualTo(multipliedWidth);
@@ -76,10 +76,10 @@ public void circleCrop_withNarrowRectangle_cropsWithin()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .circleCrop()
-              .override(canonical.getWidth() / 10, canonical.getHeight()));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
     assertThat(result.getHeight()).isEqualTo(canonical.getWidth() / 10);
@@ -88,13 +88,13 @@ public void circleCrop_withNarrowRectangle_cropsWithin()
   @Test
   public void circleCrop_withShortRectangle_fitsWithinMaintainingAspectRatio()
       throws ExecutionException, InterruptedException {
-     Bitmap result =
+    Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .circleCrop()
-              .override(canonical.getWidth(), canonical.getHeight() / 2));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getHeight() / 2);
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
index 014d0942b..2fb3016a6 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -31,10 +31,7 @@
   public void load_withJpegAsDataUriString_returnsBitmap() {
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(getDataUriString(CompressFormat.JPEG))
-                .submit());
+            Glide.with(context).asBitmap().load(getDataUriString(CompressFormat.JPEG)).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -42,10 +39,7 @@ public void load_withJpegAsDataUriString_returnsBitmap() {
   public void load_withPngDataUriString_returnsBitmap() {
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(getDataUriString(CompressFormat.PNG))
-                .submit());
+            Glide.with(context).asBitmap().load(getDataUriString(CompressFormat.PNG)).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -53,10 +47,7 @@ public void load_withPngDataUriString_returnsBitmap() {
   public void load_withJpegAsDataUri_returnsBitmap() {
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(getDataUri(CompressFormat.JPEG))
-                .submit());
+            Glide.with(context).asBitmap().load(getDataUri(CompressFormat.JPEG)).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -64,10 +55,7 @@ public void load_withJpegAsDataUri_returnsBitmap() {
   public void load_withPngAsDataUri_returnsBitmap() {
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(getDataUri(CompressFormat.PNG))
-                .submit());
+            Glide.with(context).asBitmap().load(getDataUri(CompressFormat.PNG)).submit());
     assertThat(bitmap).isNotNull();
   }
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
index d84b55ac8..6aa0c33cd 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
@@ -62,12 +62,9 @@ public void loadVideo_downsampleStrategyNone_doesNotUpscale() {
 
   @Test
   public void loadVideo_downsampleDefault_downsamplesVideo() {
-     Bitmap bitmap =
+    Bitmap bitmap =
         concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(ResourceIds.raw.video)
-                .submit(10, 10));
+            GlideApp.with(context).asBitmap().load(ResourceIds.raw.video).submit(10, 10));
 
     assertThat(bitmap).hasDimensions(10, 18);
   }
@@ -108,7 +105,7 @@ public void loadVideo_downsampleAtLeast_downsamplesToLargerSize() {
     assertThat(bitmap).hasDimensions(540, 960);
   }
 
-    @Test
+  @Test
   public void loadVideo_downsampleAtLeast_doesNotUpscale() {
     Bitmap bitmap =
         concurrency.get(
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
index 955fe208b..a06c4b6b2 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -50,51 +50,49 @@ public void tearDown() {
   public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable()
       throws ExecutionException, InterruptedException {
     Drawable colorDrawable = new ColorDrawable(Color.RED);
-    Drawable result = Glide.with(context)
-        .load(colorDrawable)
-        .apply(new RequestOptions()
-            .optionalCenterCrop())
-        .submit()
-        .get();
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().optionalCenterCrop())
+            .submit()
+            .get();
 
     assertThat(result).isInstanceOf(ColorDrawable.class);
     assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
   }
 
-  /**
-   * Transformations that do nothing can simply return the original Bitmap.
-   */
+  /** Transformations that do nothing can simply return the original Bitmap. */
   @Test
   public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable()
       throws ExecutionException, InterruptedException {
     Drawable colorDrawable = new ColorDrawable(Color.RED);
 
-    Drawable result = Glide.with(context)
-        .load(colorDrawable)
-        .apply(new RequestOptions()
-            .centerCrop())
-        .submit(100, 100)
-        .get();
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().centerCrop())
+            .submit(100, 100)
+            .get();
 
     assertThat(result).isInstanceOf(ColorDrawable.class);
     assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
   }
 
   /**
-   * Transformations that produce a different output color/shape/image etc will end up returning
-   * a {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
+   * Transformations that produce a different output color/shape/image etc will end up returning a
+   * {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
    */
   @Test
   public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable()
       throws ExecutionException, InterruptedException {
     Drawable colorDrawable = new ColorDrawable(Color.RED);
 
-    Drawable result = Glide.with(context)
-        .load(colorDrawable)
-        .apply(new RequestOptions()
-            .circleCrop())
-        .submit(100, 100)
-        .get();
+    Drawable result =
+        Glide.with(context)
+            .load(colorDrawable)
+            .apply(new RequestOptions().circleCrop())
+            .submit(100, 100)
+            .get();
 
     Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
     Canvas canvas = new Canvas(redSquare);
@@ -131,12 +129,14 @@ public void load_withColorDrawable_sizeOriginal_requiredTransform_fails()
     Glide.get(context).getRequestManagerRetriever().get(context);
     // Wait until it's added as a lifecycle observer.
     final CountDownLatch latch = new CountDownLatch(1);
-    new Handler(Looper.getMainLooper()).post(new Runnable() {
-      @Override
-      public void run() {
-        latch.countDown();
-      }
-    });
+    new Handler(Looper.getMainLooper())
+        .post(
+            new Runnable() {
+              @Override
+              public void run() {
+                latch.countDown();
+              }
+            });
     latch.await(5, TimeUnit.SECONDS);
 
     // End hacks.
@@ -148,8 +148,7 @@ public void run() {
           public void run() throws Throwable {
             Glide.with(context)
                 .load(colorDrawable)
-                .apply(new RequestOptions()
-                    .centerCrop())
+                .apply(new RequestOptions().centerCrop())
                 .submit()
                 .get();
           }
@@ -162,12 +161,13 @@ public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBit
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
 
-    Drawable result = GlideApp.with(context)
-        .load(drawable)
-        .fitCenter()
-        .override(bitmap.getWidth(), bitmap.getHeight())
-        .submit()
-        .get();
+    Drawable result =
+        GlideApp.with(context)
+            .load(drawable)
+            .fitCenter()
+            .override(bitmap.getWidth(), bitmap.getHeight())
+            .submit()
+            .get();
 
     BitmapSubject.assertThat(result).isNotRecycled();
   }
@@ -175,15 +175,16 @@ public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBit
   @Test
   public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap()
       throws ExecutionException, InterruptedException {
-      Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
 
-    Drawable result = GlideApp.with(context)
-        .load(drawable)
-        .fitCenter()
-        .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
-        .submit()
-        .get();
+    Drawable result =
+        GlideApp.with(context)
+            .load(drawable)
+            .fitCenter()
+            .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
+            .submit()
+            .get();
 
     BitmapSubject.assertThat(result).isNotRecycled();
   }
@@ -196,12 +197,7 @@ public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesInterme
     int width = 100;
     int height = 200;
 
-    GlideApp.with(context)
-        .load(colorDrawable)
-        .fitCenter()
-        .override(width, height)
-        .submit()
-        .get();
+    GlideApp.with(context).load(colorDrawable).fitCenter().override(width, height).submit().get();
 
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     // Make sure we didn't put the same Bitmap twice.
@@ -210,7 +206,8 @@ public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesInterme
 
     assertThat(first).isNotSameInstanceAs(second);
   }
-   @Test
+
+  @Test
   public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput()
       throws ExecutionException, InterruptedException {
     Drawable colorDrawable = new ColorDrawable(Color.RED);
@@ -218,14 +215,15 @@ public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRe
     int width = 100;
     int height = 200;
 
-    Drawable result = GlideApp.with(context)
-        .load(colorDrawable)
-        .circleCrop()
-        .override(width, height)
-        .submit()
-        .get();
+    Drawable result =
+        GlideApp.with(context)
+            .load(colorDrawable)
+            .circleCrop()
+            .override(width, height)
+            .submit()
+            .get();
 
-     BitmapSubject.assertThat(result).isNotRecycled();
+    BitmapSubject.assertThat(result).isNotRecycled();
 
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     // Make sure we didn't put the same Bitmap twice.
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
index 2e6dcbb74..6adc1daec 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -59,7 +59,8 @@ public void setUp() {
   @Test
   public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
     WaitForErrorStrategy strategy = new WaitForErrorStrategy();
-    Glide.init(context,
+    Glide.init(
+        context,
         new GlideBuilder()
             .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
             .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
@@ -67,10 +68,7 @@ public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
     Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
 
     concurrency.get(
-        Glide.with(context)
-            .load(ResourceIds.raw.canonical)
-            .listener(requestListener)
-            .submit());
+        Glide.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
 
     // Writing to the disk cache and therefore the exception caused by our FailEncoder may happen
     // after the request completes, so we should wait for the expected error explicitly.
@@ -84,7 +82,8 @@ public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
   @Test
   public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
     WaitForErrorStrategy strategy = new WaitForErrorStrategy();
-    Glide.init(context,
+    Glide.init(
+        context,
         new GlideBuilder()
             .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
             .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
@@ -92,18 +91,11 @@ public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
     Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
 
     concurrency.get(
-        Glide.with(context)
-            .load(ResourceIds.raw.canonical)
-            .listener(requestListener)
-            .submit());
+        Glide.with(context).load(ResourceIds.raw.canonical).listener(requestListener).submit());
 
     verify(requestListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            any(DataSource.class),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), any(DataSource.class), anyBoolean());
     verify(requestListener, never())
         .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
   }
@@ -115,10 +107,7 @@ public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {
     FutureTarget<Drawable> target =
         Glide.with(context)
             .load((Object) null)
-            .error(
-                Glide.with(context)
-                    .load(errorModel)
-                    .listener(requestListener))
+            .error(Glide.with(context).load(errorModel).listener(requestListener))
             .submit();
 
     Glide.with(context).clear(target);
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
index 5945ef428..152639951 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -71,18 +71,16 @@ public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
     Glide.init(
         context,
         new GlideBuilder()
-            .setDiskCache(new Factory() {
-              @Override
-              public DiskCache build() {
-                return cache;
-              }
-            }));
+            .setDiskCache(
+                new Factory() {
+                  @Override
+                  public DiskCache build() {
+                    return cache;
+                  }
+                }));
 
     Drawable drawable =
-        concurrency.get(
-            Glide.with(context)
-                .load(ResourceIds.raw.canonical)
-                .submit());
+        concurrency.get(Glide.with(context).load(ResourceIds.raw.canonical).submit());
     assertThat(drawable).isNotNull();
   }
 
@@ -95,17 +93,15 @@ public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
     Glide.init(
         context,
         new GlideBuilder()
-            .setDiskCache(new Factory() {
-              @Override
-              public DiskCache build() {
-                return cache;
-              }
-            }));
+            .setDiskCache(
+                new Factory() {
+                  @Override
+                  public DiskCache build() {
+                    return cache;
+                  }
+                }));
 
-    Drawable drawable =
-        concurrency.get(Glide.with(context)
-            .load(raw.canonical)
-            .submit());
+    Drawable drawable = concurrency.get(Glide.with(context).load(raw.canonical).submit());
     assertThat(drawable).isNotNull();
   }
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
index b2f7a4aa4..12b5dab45 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -46,11 +46,7 @@ public void fitCenter_withSquareSmallerThanImage_returnsImageFitWithinSquare()
 
     Bitmap result =
         bitmapRegressionTester.test(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(canonical.getBitmap())
-                .fitCenter()
-                .override(50));
+            GlideApp.with(context).asBitmap().load(canonical.getBitmap()).fitCenter().override(50));
 
     assertThat(result.getWidth()).isEqualTo(50);
     assertThat(result.getHeight()).isEqualTo(37);
@@ -65,10 +61,10 @@ public void fitCenter_withSquareLargerThanImage_returnsUpscaledSquare()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .fitCenter()
-              .override(multipliedWidth));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(multipliedWidth));
 
     assertThat(result.getWidth()).isEqualTo(multipliedWidth);
     assertThat(result.getHeight()).isEqualTo(multipliedHeight);
@@ -80,10 +76,10 @@ public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
     Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .fitCenter()
-              .override(canonical.getWidth() / 10, canonical.getHeight()));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(canonical.getWidth() / 10, canonical.getHeight()));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
@@ -92,13 +88,13 @@ public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
   @Test
   public void fitCenter_withShortRectangle_fitsWithinMaintainingAspectRatio()
       throws ExecutionException, InterruptedException {
-     Bitmap result =
+    Bitmap result =
         bitmapRegressionTester.test(
             GlideApp.with(context)
-              .asBitmap()
-              .load(canonical.getBitmap())
-              .fitCenter()
-              .override(canonical.getWidth(), canonical.getHeight() / 2));
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(canonical.getWidth(), canonical.getHeight() / 2));
 
     assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
     assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
@@ -116,8 +112,7 @@ public void fitCenter_withHugeRectangle_throwsOOM()
         new ThrowingRunnable() {
           @Override
           public void run() throws Throwable {
-            GlideApp
-                .with(context)
+            GlideApp.with(context)
                 .asBitmap()
                 .load(canonical.getBitmap())
                 .fitCenter()
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
index f00da78c7..d3a7f4e4f 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide;
 
-
 import static com.bumptech.glide.test.Matchers.anyBitmap;
 import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
 import static com.bumptech.glide.test.Matchers.anyDrawable;
@@ -74,11 +73,7 @@ public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBi
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Drawable> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .asDrawable()
-                .load(bitmap)
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).asDrawable().load(bitmap).submit(100, 100));
     Glide.with(context).clear(target);
 
     // Allow Glide's resource recycler to run on the main thread.
@@ -96,11 +91,7 @@ public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecyc
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(bitmap)
-            .centerCrop()
-            .submit(100, 100));
+        GlideApp.with(context).asDrawable().load(bitmap).centerCrop().submit(100, 100));
 
     assertThat(bitmap.isRecycled()).isFalse();
   }
@@ -114,10 +105,7 @@ public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Drawable> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .load(bitmap)
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).load(bitmap).submit(100, 100));
     Glide.with(context).clear(target);
 
     // Allow Glide's resource recycler to run on the main thread.
@@ -134,11 +122,7 @@ public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap()
             .setMemoryCache(new MemoryCacheAdapter())
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    concurrency.wait(
-        GlideApp.with(context)
-            .load(bitmap)
-            .centerCrop()
-            .submit(100, 100));
+    concurrency.wait(GlideApp.with(context).load(bitmap).centerCrop().submit(100, 100));
 
     assertThat(bitmap.isRecycled()).isFalse();
   }
@@ -152,11 +136,7 @@ public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitm
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     Target<Bitmap> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(bitmap)
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).asBitmap().load(bitmap).submit(100, 100));
     Glide.with(context).clear(target);
 
     // Allow Glide's resource recycler to run on the main thread.
@@ -173,12 +153,7 @@ public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycle
             .setMemoryCache(new MemoryCacheAdapter())
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
-    concurrency.wait(
-        GlideApp.with(context)
-            .asBitmap()
-            .load(bitmap)
-            .centerCrop()
-            .submit(100, 100));
+    concurrency.wait(GlideApp.with(context).asBitmap().load(bitmap).centerCrop().submit(100, 100));
 
     assertThat(bitmap.isRecycled()).isFalse();
   }
@@ -192,21 +167,18 @@ public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
             .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
             .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .load(bitmap)
-                .centerCrop()
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).load(bitmap).centerCrop().submit(100, 100));
     Glide.with(context).clear(target);
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -217,11 +189,7 @@ public void run() {
 
     verify(drawableListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -234,21 +202,18 @@ public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCach
             .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
-            GlideApp.with(context)
-                .asDrawable()
-                .load(bitmap)
-                .centerCrop()
-                .submit(100, 100));
+            GlideApp.with(context).asDrawable().load(bitmap).centerCrop().submit(100, 100));
     Glide.with(context).clear(target);
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -259,11 +224,7 @@ public void run() {
 
     verify(drawableListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -286,12 +247,13 @@ public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_no
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -302,11 +264,7 @@ public void run() {
 
     verify(drawableListener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -319,21 +277,18 @@ public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache(
             .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Bitmap> target =
         concurrency.wait(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(bitmap)
-                .centerCrop()
-                .submit(100, 100));
+            GlideApp.with(context).asBitmap().load(bitmap).centerCrop().submit(100, 100));
     Glide.with(context).clear(target);
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -344,12 +299,7 @@ public void run() {
             .submit(100, 100));
 
     verify(bitmapListener)
-        .onResourceReady(
-            anyBitmap(),
-            any(),
-            anyBitmapTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+        .onResourceReady(anyBitmap(), any(), anyBitmapTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -373,12 +323,13 @@ public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notF
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -389,11 +340,6 @@ public void run() {
             .submit(100, 100));
 
     verify(bitmapListener)
-        .onResourceReady(
-            anyBitmap(),
-            any(),
-            anyBitmapTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+        .onResourceReady(anyBitmap(), any(), anyBitmapTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
index 56f2e1f40..af8251191 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -72,10 +72,12 @@ public void setUp() throws IOException {
     // started before the encode and loads from source).
     ExecutorService executor = Executors.newSingleThreadExecutor();
     GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
-    Glide.init(context, new GlideBuilder()
-        .setAnimationExecutor(glideExecutor)
-        .setDiskCacheExecutor(glideExecutor)
-        .setSourceExecutor(glideExecutor));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setAnimationExecutor(glideExecutor)
+            .setDiskCacheExecutor(glideExecutor)
+            .setSourceExecutor(glideExecutor));
   }
 
   @Test
@@ -84,12 +86,10 @@ public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDi
     final byte[] canonicalBytes = getCanonicalBytes();
     final byte[] modifiedBytes = getModifiedBytes();
 
-    concurrency.loadOnMainThread(
-        Glide.with(context).load(canonicalBytes), imageView);
+    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
     Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
 
-    concurrency.loadOnMainThread(
-        Glide.with(context).load(modifiedBytes), imageView);
+    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
     Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
 
     // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
@@ -112,17 +112,11 @@ public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDi
     final byte[] modifiedBytes = getModifiedBytes();
 
     concurrency.loadOnMainThread(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(canonicalBytes),
-        imageView);
+        GlideApp.with(context).asDrawable().load(canonicalBytes), imageView);
     Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
 
     concurrency.loadOnMainThread(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(modifiedBytes),
-        imageView);
+        GlideApp.with(context).asDrawable().load(modifiedBytes), imageView);
     Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
 
     // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
@@ -143,10 +137,7 @@ public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_
       throws IOException {
     final byte[] canonicalBytes = getCanonicalBytes();
     concurrency.loadOnMainThread(
-        Glide.with(context)
-            .load(canonicalBytes)
-            .apply(skipMemoryCacheOf(false)),
-        imageView);
+        Glide.with(context).load(canonicalBytes).apply(skipMemoryCacheOf(false)), imageView);
 
     Glide.with(context).clear(imageView);
 
@@ -157,8 +148,9 @@ public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_
             .apply(skipMemoryCacheOf(false)),
         imageView);
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -166,10 +158,7 @@ public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_
       throws IOException {
     final byte[] canonicalBytes = getCanonicalBytes();
     concurrency.loadOnMainThread(
-        Glide.with(context)
-            .asDrawable()
-            .load(canonicalBytes)
-            .apply(skipMemoryCacheOf(false)),
+        Glide.with(context).asDrawable().load(canonicalBytes).apply(skipMemoryCacheOf(false)),
         imageView);
 
     Glide.with(context).clear(imageView);
@@ -182,27 +171,30 @@ public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_
             .apply(skipMemoryCacheOf(false)),
         imageView);
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
   public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
       throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(data)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit());
     GlideApp.with(context).clear(target);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -224,20 +216,22 @@ public void run() {
   public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
       throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(data)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit());
     GlideApp.with(context).clear(target);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -260,11 +254,8 @@ public void run() {
   public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
       throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .skipMemoryCache(false)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).load(data).skipMemoryCache(false).submit());
     GlideApp.with(context).clear(target);
 
     concurrency.wait(
@@ -274,20 +265,18 @@ public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsF
             .listener(requestListener)
             .submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
   public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
       throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .skipMemoryCache(false)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context).asDrawable().load(data).skipMemoryCache(false).submit());
     GlideApp.with(context).clear(target);
 
     concurrency.wait(
@@ -298,104 +287,83 @@ public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsF
             .listener(requestListener)
             .submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
   public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .submit());
+    Target<Drawable> target = concurrency.wait(GlideApp.with(context).load(data).submit());
     GlideApp.with(context).clear(target);
 
-    concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .listener(requestListener)
-            .submit());
+    concurrency.wait(GlideApp.with(context).load(data).listener(requestListener).submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
   public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).asDrawable().load(data).submit());
     GlideApp.with(context).clear(target);
 
     concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .listener(requestListener)
-            .submit());
+        GlideApp.with(context).asDrawable().load(data).listener(requestListener).submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
   public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
-       throws IOException {
+      throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .submit());
+    Target<Drawable> target = concurrency.wait(GlideApp.with(context).load(data).submit());
     GlideApp.with(context).clear(target);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
-    concurrency.wait(
-        GlideApp.with(context)
-            .load(data)
-            .listener(requestListener)
-            .submit());
+    concurrency.wait(GlideApp.with(context).load(data).listener(requestListener).submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
   public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
-       throws IOException {
+      throws IOException {
     byte[] data = getCanonicalBytes();
-    Target<Drawable> target = concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .submit());
+    Target<Drawable> target =
+        concurrency.wait(GlideApp.with(context).asDrawable().load(data).submit());
     GlideApp.with(context).clear(target);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .load(data)
-            .listener(requestListener)
-            .submit());
+        GlideApp.with(context).asDrawable().load(data).listener(requestListener).submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -409,12 +377,13 @@ public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDi
             .load(data)
             .submit());
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -438,18 +407,15 @@ public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkip
       throws IOException {
     byte[] data = getCanonicalBytes();
     concurrency.wait(
-        GlideApp.with(context)
-            .asDrawable()
-            .skipMemoryCache(false)
-            .load(data)
-            .submit());
+        GlideApp.with(context).asDrawable().skipMemoryCache(false).load(data).submit());
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
         GlideApp.with(context)
@@ -459,8 +425,9 @@ public void run() {
             .load(data)
             .submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
   }
 
   @Test
@@ -483,12 +450,13 @@ public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws
             .listener(requestListener)
             .submit());
 
-    verify(requestListener).onResourceReady(
-        anyDrawable(),
-        any(),
-        anyDrawableTarget(),
-        eq(DataSource.DATA_DISK_CACHE),
-        anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
   }
 
   private Bitmap copyFromImageViewDrawable(ImageView imageView) {
@@ -505,7 +473,7 @@ private Bitmap copyFromImageViewDrawable(ImageView imageView) {
     byte[] canonicalBytes = getCanonicalBytes();
     Bitmap bitmap =
         BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
-    return new int[] { bitmap.getWidth(), bitmap.getHeight() };
+    return new int[] {bitmap.getWidth(), bitmap.getHeight()};
   }
 
   private byte[] getModifiedBytes() throws IOException {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
index 20756248d..4e6c503ce 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -62,7 +62,6 @@ public void setUp() {
             .setDiskCacheExecutor(executor);
   }
 
-
   @Test
   public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
     Glide.init(
@@ -73,10 +72,7 @@ public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
     Target<Drawable> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .load(drawable)
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).load(drawable).submit(100, 100));
     Glide.with(context).clear(target);
 
     // Allow Glide's resource recycler to run on the main thread.
@@ -94,11 +90,7 @@ public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
             .setBitmapPool(new BitmapPoolAdapter()));
     Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
-    concurrency.wait(
-        GlideApp.with(context)
-            .load(drawable)
-            .centerCrop()
-            .submit(100, 100));
+    concurrency.wait(GlideApp.with(context).load(drawable).centerCrop().submit(100, 100));
 
     assertThat(bitmap.isRecycled()).isFalse();
   }
@@ -113,36 +105,25 @@ public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
             .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
             .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
-        concurrency.wait(
-            GlideApp.with(context)
-                .load(drawable)
-                .centerCrop()
-                .submit(100, 100));
+        concurrency.wait(GlideApp.with(context).load(drawable).centerCrop().submit(100, 100));
     Glide.with(context).clear(target);
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
-        GlideApp.with(context)
-            .load(drawable)
-            .centerCrop()
-            .listener(listener)
-            .submit(100, 100));
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
 
     verify(listener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -156,36 +137,25 @@ public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCach
             .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
     Target<Drawable> target =
         concurrency.wait(
-            GlideApp.with(context)
-                .asDrawable()
-                .load(drawable)
-                .centerCrop()
-                .submit(100, 100));
+            GlideApp.with(context).asDrawable().load(drawable).centerCrop().submit(100, 100));
     Glide.with(context).clear(target);
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
-        GlideApp.with(context)
-            .load(drawable)
-            .centerCrop()
-            .listener(listener)
-            .submit(100, 100));
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
 
     verify(listener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 
   @Test
@@ -209,26 +179,19 @@ public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_no
 
     assertThat(bitmap.isRecycled()).isFalse();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.get(context).clearMemory();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.get(context).clearMemory();
+          }
+        });
 
     concurrency.wait(
-        GlideApp.with(context)
-            .load(drawable)
-            .centerCrop()
-            .listener(listener)
-            .submit(100, 100));
+        GlideApp.with(context).load(drawable).centerCrop().listener(listener).submit(100, 100));
 
     verify(listener)
         .onResourceReady(
-            anyDrawable(),
-            any(),
-            anyDrawableTarget(),
-            eq(DataSource.LOCAL),
-            anyBoolean());
+            anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
index 38ef87b5c..9d861aeeb 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -38,11 +38,11 @@
 import org.junit.runner.RunWith;
 
 /**
- * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with
- * {@link BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set
- * {@link BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image
- * can be decoded successfully. Glide can mask these failures by decoding some image sources
- * (notably including resource ids) using other data types and decoders.
+ * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with {@link
+ * BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set {@link
+ * BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image can be
+ * decoded successfully. Glide can mask these failures by decoding some image sources (notably
+ * including resource ids) using other data types and decoders.
  *
  * <p>This test ensures that we've worked around the framework issue by loading a variety of images
  * and image types without the normal fallback behavior.
@@ -55,18 +55,11 @@
 
   @Test
   public void loadJpegResource_withNoOtherLoaders_decodesResource() {
-    Glide.get(context).getRegistry()
-        .prepend(
-            Object.class,
-            InputStream.class,
-            new FakeModelLoader<>(ResourceIds.raw.canonical));
+    Glide.get(context)
+        .getRegistry()
+        .prepend(Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.canonical));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -74,18 +67,12 @@ public void loadJpegResource_withNoOtherLoaders_decodesResource() {
   public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap() {
     assumeTrue(
         "Wide gamut is only available on O+", Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
-            Object.class,
-            InputStream.class,
-            new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
     assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
     assertThat(bitmap.getColorSpace())
@@ -94,52 +81,38 @@ public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap(
 
   @Test
   public void loadOpaquePngResource_withNoOtherLoaders_decodesResource() {
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
-            Object.class,
-            InputStream.class,
-            new FakeModelLoader<>(ResourceIds.raw.canonical_png));
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.canonical_png));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void loadTransparentPngResource_withNoOtherLoaders_decodesResource() {
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
             Object.class,
             InputStream.class,
             new FakeModelLoader<>(ResourceIds.raw.canonical_transparent_png));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void loadTransparentGifResource_withNoOtherLoaders_decodesResource() {
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
             Object.class,
             InputStream.class,
             new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -149,7 +122,8 @@ public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesReso
         "Hardware Bitmaps are only supported on O+",
         Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
 
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
             Object.class,
             InputStream.class,
@@ -170,41 +144,25 @@ public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesReso
   @Test
   public void loadTransparentGifResource_withNoOtherLoaders_fromBytes_decodesResource() {
     byte[] data = getBytes(ResourceIds.raw.transparent_gif);
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void loadOpaqueGifResource_withNoOtherLoaders_decodesResource() {
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
-            Object.class,
-            InputStream.class,
-            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(new Object())
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(new Object()).submit());
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void loadOpaqueGifResource_asBytes_decodesResource() {
     byte[] data = getBytes(ResourceIds.raw.opaque_gif);
-     Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -214,11 +172,10 @@ public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource(
         "Hardware Bitmaps are only supported on O+",
         Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
 
-    Glide.get(context).getRegistry()
+    Glide.get(context)
+        .getRegistry()
         .prepend(
-            Object.class,
-            InputStream.class,
-            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+            Object.class, InputStream.class, new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
 
     Bitmap bitmap =
         concurrency.get(
@@ -231,7 +188,6 @@ public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource(
     assertThat(bitmap).isNotNull();
   }
 
-
   private byte[] getBytes(int resourceId) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     InputStream is = null;
@@ -257,9 +213,8 @@ public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource(
     return os.toByteArray();
   }
 
-  private class FakeModelLoader<T> implements
-      ModelLoader<T, InputStream>,
-      ModelLoaderFactory<T, InputStream> {
+  private class FakeModelLoader<T>
+      implements ModelLoader<T, InputStream>, ModelLoaderFactory<T, InputStream> {
 
     private final int resourceId;
 
@@ -269,8 +224,8 @@ public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource(
 
     @android.support.annotation.Nullable
     @Override
-    public LoadData<InputStream> buildLoadData(@NonNull Object o, int width, int height,
-        @NonNull Options options) {
+    public LoadData<InputStream> buildLoadData(
+        @NonNull Object o, int width, int height, @NonNull Options options) {
       return new LoadData<>(new ObjectKey(o), new Fetcher());
     }
 
@@ -286,20 +241,19 @@ public boolean handles(@NonNull Object o) {
     }
 
     @Override
-    public void teardown() { }
+    public void teardown() {}
 
     private final class Fetcher implements DataFetcher<InputStream> {
       private InputStream inputStream;
 
       @Override
-      public void loadData(@NonNull Priority priority,
-          @NonNull DataCallback<? super InputStream> callback) {
+      public void loadData(
+          @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
         inputStream = getInputStreamForResource(context, resourceId);
         callback.onDataReady(inputStream);
       }
 
-      private InputStream getInputStreamForResource(
-          Context context, @DrawableRes int resourceId) {
+      private InputStream getInputStreamForResource(Context context, @DrawableRes int resourceId) {
         Resources resources = context.getResources();
         try {
           Uri parse =
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
index 6a559af37..b7e2566e4 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -23,8 +23,8 @@
 import org.mockito.MockitoAnnotations;
 
 /**
- * Tests that Glide is able to load videos stored in resources and loaded as
- * {@link android.content.res.AssetFileDescriptor}s.
+ * Tests that Glide is able to load videos stored in resources and loaded as {@link
+ * android.content.res.AssetFileDescriptor}s.
  */
 @RunWith(AndroidJUnit4.class)
 public class LoadVideoResourceTest {
@@ -41,11 +41,7 @@ public void setUp() throws IOException {
 
   @Test
   public void loadVideoResourceId_fromInt_decodesFrame() {
-    Drawable frame =
-        concurrency.get(
-            Glide.with(context)
-                .load(ResourceIds.raw.video)
-                .submit());
+    Drawable frame = concurrency.get(Glide.with(context).load(ResourceIds.raw.video).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -67,10 +63,7 @@ public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
   @Test
   public void loadVideoResourceId_fromInteger_decodesFrame() {
     Drawable frame =
-        concurrency.get(
-            Glide.with(context)
-                .load(new Integer(ResourceIds.raw.video))
-                .submit());
+        concurrency.get(Glide.with(context).load(new Integer(ResourceIds.raw.video)).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -92,11 +85,7 @@ public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
   @Test
   public void loadVideoResourceId_asBitmap_decodesFrame() {
     Bitmap frame =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(ResourceIds.raw.video)
-                .submit());
+        concurrency.get(Glide.with(context).asBitmap().load(ResourceIds.raw.video).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -123,11 +112,7 @@ public void loadVideoResourceUri_fromId_decodesFrame() {
             .path(String.valueOf(ResourceIds.raw.video))
             .build();
 
-    Drawable frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .load(uri)
-                .submit());
+    Drawable frame = concurrency.get(GlideApp.with(context).load(uri).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -141,12 +126,7 @@ public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
             .path(String.valueOf(ResourceIds.raw.video))
             .build();
 
-    Bitmap frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(uri)
-                .submit());
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -180,12 +160,7 @@ public void loadVideoResourceUriString_fromId_decodesFrame() {
             .path(String.valueOf(ResourceIds.raw.video))
             .build();
 
-    Bitmap frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(uri.toString())
-                .submit());
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri.toString()).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -222,11 +197,7 @@ public void loadVideoResourceUri_fromName_decodesFrame() {
             .appendPath(resources.getResourceEntryName(resourceId))
             .build();
 
-    Drawable frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .load(uri)
-                .submit());
+    Drawable frame = concurrency.get(GlideApp.with(context).load(uri).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -243,12 +214,7 @@ public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
             .appendPath(resources.getResourceEntryName(resourceId))
             .build();
 
-    Bitmap frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(uri)
-                .submit());
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri).submit());
 
     assertThat(frame).isNotNull();
   }
@@ -288,12 +254,7 @@ public void loadVideoResourceUriString_fromName_decodesFrame() {
             .appendPath(resources.getResourceEntryName(resourceId))
             .build();
 
-    Bitmap frame =
-        concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(uri.toString())
-                .submit());
+    Bitmap frame = concurrency.get(GlideApp.with(context).asBitmap().load(uri.toString()).submit());
 
     assertThat(frame).isNotNull();
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
index efc1fa5d2..cd0423672 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -49,74 +49,62 @@ public void setUp() {
   @Test
   public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
+    Drawable drawable = Glide.with(context).load(android.R.drawable.star_big_off).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(android.R.drawable.star_big_off)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(android.R.drawable.star_big_off)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(android.R.drawable.star_big_off)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(android.R.drawable.star_big_off).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.bitmap_alias)
-        .submit()
-        .get();
+    Drawable drawable = Glide.with(context).load(ResourceIds.drawable.bitmap_alias).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.bitmap_alias)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.bitmap_alias)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.bitmap_alias)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(ResourceIds.drawable.bitmap_alias).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.shape_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.shape_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
@@ -133,7 +121,6 @@ public void run() throws Throwable {
                 .apply(centerCropTransform())
                 .submit()
                 .get();
-
           }
         });
   }
@@ -141,11 +128,12 @@ public void run() throws Throwable {
   @Test
   public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.shape_drawable)
-        .apply(bitmapTransform(new RoundedCorners(10)))
-        .submit(100, 200)
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.shape_drawable)
+            .apply(bitmapTransform(new RoundedCorners(10)))
+            .submit(100, 200)
+            .get();
     assertThat(drawable).isNotNull();
     assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
     assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
@@ -159,11 +147,7 @@ public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
         new ThrowingRunnable() {
           @Override
           public void run() throws Throwable {
-            Glide.with(context)
-                .asBitmap()
-                .load(ResourceIds.drawable.shape_drawable)
-                .submit()
-                .get();
+            Glide.with(context).asBitmap().load(ResourceIds.drawable.shape_drawable).submit().get();
           }
         });
   }
@@ -171,11 +155,12 @@ public void run() throws Throwable {
   @Test
   public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.shape_drawable)
-        .submit(100, 200)
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.shape_drawable)
+            .submit(100, 200)
+            .get();
     assertThat(bitmap).isNotNull();
     assertThat(bitmap.getWidth()).isEqualTo(100);
     assertThat(bitmap.getHeight()).isEqualTo(200);
@@ -184,12 +169,13 @@ public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNu
   @Test
   public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.shape_drawable)
-        .apply(centerCropTransform())
-        .submit(100, 200)
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.shape_drawable)
+            .apply(centerCropTransform())
+            .submit(100, 200)
+            .get();
     assertThat(bitmap).isNotNull();
     assertThat(bitmap.getWidth()).isEqualTo(100);
     assertThat(bitmap.getHeight()).isEqualTo(200);
@@ -198,98 +184,94 @@ public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_
   @Test
   public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.state_list_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.state_list_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.state_list_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.state_list_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.state_list_drawable)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.state_list_drawable)
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.state_list_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.state_list_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.vector_drawable)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.vector_drawable).submit().get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.vector_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.vector_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(drawable).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.vector_drawable)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context).asBitmap().load(ResourceIds.drawable.vector_drawable).submit().get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.vector_drawable)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.vector_drawable)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
     assertThat(bitmap).isNotNull();
   }
 
   @Test
   public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context).load(ResourceIds.drawable.googlelogo_color_120x44dp).submit().get();
 
     assertThat(drawable).isNotNull();
   }
@@ -297,11 +279,12 @@ public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
   @Test
   public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
       throws ExecutionException, InterruptedException {
-    Drawable drawable = Glide.with(context)
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Drawable drawable =
+        Glide.with(context)
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
 
     assertThat(drawable).isNotNull();
   }
@@ -309,11 +292,12 @@ public void load_withNinePatchResourceId_asDrawable_withTransformation_producesN
   @Test
   public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .submit()
+            .get();
 
     assertThat(bitmap).isNotNull();
   }
@@ -321,12 +305,13 @@ public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
   @Test
   public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
       throws ExecutionException, InterruptedException {
-    Bitmap bitmap = Glide.with(context)
-        .asBitmap()
-        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
-        .apply(centerCropTransform())
-        .submit()
-        .get();
+    Bitmap bitmap =
+        Glide.with(context)
+            .asBitmap()
+            .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+            .apply(centerCropTransform())
+            .submit()
+            .get();
 
     assertThat(bitmap).isNotNull();
   }
@@ -337,16 +322,14 @@ public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDraw
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
 
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
+      Drawable drawable = Glide.with(context).load(uri).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -357,17 +340,14 @@ public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .apply(centerCropTransform())
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).apply(centerCropTransform()).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -378,17 +358,14 @@ public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Bitmap bitmap = Glide.with(context).asBitmap().load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -399,18 +376,15 @@ public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_no
     for (String packageName : getInstalledPackages()) {
       int iconResourceId = getResourceId(packageName);
 
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .path(String.valueOf(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .apply(centerCropTransform())
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .path(String.valueOf(iconResourceId))
+              .build();
+
+      Bitmap bitmap =
+          Glide.with(context).asBitmap().apply(centerCropTransform()).load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -423,17 +397,15 @@ public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDr
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .appendPath(resources.getResourceTypeName(iconResourceId))
-          .appendPath(resources.getResourceEntryName(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -446,18 +418,15 @@ public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_non
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .appendPath(resources.getResourceTypeName(iconResourceId))
-          .appendPath(resources.getResourceEntryName(iconResourceId))
-          .build();
-
-      Drawable drawable = Glide.with(context)
-          .load(uri)
-          .apply(centerCropTransform())
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Drawable drawable = Glide.with(context).load(uri).apply(centerCropTransform()).submit().get();
       assertThat(drawable).isNotNull();
     }
   }
@@ -470,18 +439,15 @@ public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitm
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .appendPath(resources.getResourceTypeName(iconResourceId))
-          .appendPath(resources.getResourceEntryName(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Bitmap bitmap = Glide.with(context).asBitmap().load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -494,19 +460,16 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
 
       Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
       Resources resources = toUse.getResources();
-      Uri uri = new Uri.Builder()
-          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
-          .authority(packageName)
-          .appendPath(resources.getResourceTypeName(iconResourceId))
-          .appendPath(resources.getResourceEntryName(iconResourceId))
-          .build();
-
-      Bitmap bitmap = Glide.with(context)
-          .asBitmap()
-          .apply(centerCropTransform())
-          .load(uri)
-          .submit()
-          .get();
+      Uri uri =
+          new Uri.Builder()
+              .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+              .authority(packageName)
+              .appendPath(resources.getResourceTypeName(iconResourceId))
+              .appendPath(resources.getResourceEntryName(iconResourceId))
+              .build();
+
+      Bitmap bitmap =
+          Glide.with(context).asBitmap().apply(centerCropTransform()).load(uri).submit().get();
       assertThat(bitmap).isNotNull();
     }
   }
@@ -515,14 +478,13 @@ public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNu
     Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
     mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
     PackageManager packageManager = context.getPackageManager();
-    List<ResolveInfo> pkgAppsList =
-        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    List<ResolveInfo> pkgAppsList = packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
     Set<String> result = new HashSet<>();
     for (ResolveInfo info : pkgAppsList) {
       String packageName = info.activityInfo.packageName;
       int iconResourceId = getResourceId(packageName);
       if (iconResourceId != 0
-              && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {
+          && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {
         result.add(info.activityInfo.packageName);
       }
     }
@@ -543,32 +505,36 @@ private int getResourceId(String packageName) {
    * Returns {@code true} iff the resource package name is exactly the same as the containing
    * application package name for a given resource id.
    *
-   * <p>The resource package name is the value returned by
-   * {@link Resources#getResourcePackageName(int)}. The application package name is package name of
-   * the enclosing application. If these two things are equal, then we can both construct a Context
-   * for that package and retrieve a resource id for that package from a "standard" resource Uri
+   * <p>The resource package name is the value returned by {@link
+   * Resources#getResourcePackageName(int)}. The application package name is package name of the
+   * enclosing application. If these two things are equal, then we can both construct a Context for
+   * that package and retrieve a resource id for that package from a "standard" resource Uri
    * containing a name instead of an id. If they aren't equal, then we can do only one of the two
    * required tasks, so our Uri load will always fail. To handle this properly, we'd need callers to
    * include both package names in the Uri. I'm not aware of any standardized Uri format for doing
    * so, so these requests will just be treated as unsupported for the time being.
    *
    * <p>Take Calendar (emulators API 24 and below) as an example:
+   *
    * <ul>
-   *     <li>package name: com.google.android.calendar</li>
-   *     <li>resource package name: com.android.calendar</li>
+   *   <li>package name: com.google.android.calendar
+   *   <li>resource package name: com.android.calendar
    * </ul>
+   *
    * We can construct one of two possible Uris:
+   *
    * <ul>
-   *     <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.</li>
-   *     <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<</li>
+   *   <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.
+   *   <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<
    * </ul>
+   *
    * From the first Uri, we can obtain the correct Context/Resources for the calendar package, but
    * our attempts to resolve the correct resource id will fail because we do not have the resource
    * package name. From the second Uri we cannot obtain the Context/Resources for the calendar
    * package because the resource package name doesn't match the application package name.
    */
   private boolean doesApplicationPackageNameMatchResourcePackageName(
-          String applicationPackageName, int iconResourceId) {
+      String applicationPackageName, int iconResourceId) {
     try {
       Context current = context.createPackageContext(applicationPackageName, /*flags=*/ 0);
       String resourcePackageName = current.getResources().getResourcePackageName(iconResourceId);
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
index a87d44a81..e0b51c36c 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
@@ -16,8 +16,8 @@
 import org.junit.Test;
 
 /**
- * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding
- * {@link RequestManager} is paused.
+ * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding {@link
+ * RequestManager} is paused.
  */
 public final class PausedRequestsTest {
   @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
@@ -30,22 +30,20 @@ public void load_withPlaceHolderSet_requestsPaused_displaysPlaceholder() {
     final ImageView imageView = new ImageView(context);
 
     final GlideRequests requests = GlideApp.with(context);
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        requests.pauseAllRequests();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requests.pauseAllRequests();
+          }
+        });
 
     final ColorDrawable expected = new ColorDrawable(Color.RED);
     concurrency.runOnMainThread(
         new Runnable() {
           @Override
           public void run() {
-            requests
-                .load(ResourceIds.drawable.bitmap_alias)
-                .placeholder(expected)
-                .into(imageView);
+            requests.load(ResourceIds.drawable.bitmap_alias).placeholder(expected).into(imageView);
           }
         });
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
index 5a9167a85..d8e8a2431 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -35,22 +35,25 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     context = InstrumentationRegistry.getTargetContext();
     Glide glide = Glide.get(context);
-    requestManager = new RequestManager(glide, new Lifecycle() {
-      @Override
-      public void addListener(@NonNull LifecycleListener listener) {
-        listener.onStart();
-      }
+    requestManager =
+        new RequestManager(
+            glide,
+            new Lifecycle() {
+              @Override
+              public void addListener(@NonNull LifecycleListener listener) {
+                listener.onStart();
+              }
 
-      @Override
-      public void removeListener(@NonNull LifecycleListener listener) {
-        // Do nothing.
-      }
-    }, treeNode, context);
+              @Override
+              public void removeListener(@NonNull LifecycleListener listener) {
+                // Do nothing.
+              }
+            },
+            treeNode,
+            context);
   }
 
-  /**
-   * Tests #2262.
-   */
+  /** Tests #2262. */
   @Test
   public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
     // First destroy our Fragment/Activity RequestManager.
@@ -63,34 +66,34 @@ public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_does
     concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
 
     // Finally clear our new load with any RequestManager other than the one we used to start it.
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.with(context).clear(imageView);
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(context).clear(imageView);
+          }
+        });
   }
 
-  /**
-   * Tests b/69361054.
-   */
+  /** Tests b/69361054. */
   @Test
   public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        requestManager.onDestroy();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            requestManager.onDestroy();
+          }
+        });
 
-    final Target<Drawable> target =
-        concurrency.wait(requestManager.load(raw.canonical).submit());
+    final Target<Drawable> target = concurrency.wait(requestManager.load(raw.canonical).submit());
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.with(context).clear(target);
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(context).clear(target);
+          }
+        });
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
index 91e1c14b2..9a042d3f8 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -30,9 +30,7 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-/**
- * Tests the behaviors of Requests of all types.
- */
+/** Tests the behaviors of Requests of all types. */
 @RunWith(AndroidJUnit4.class)
 public class RequestTest {
   @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
@@ -51,16 +49,13 @@ public void setUp() {
 
     // Some emulators only have a single resize thread, so waiting on a latch will block them
     // forever.
-    Glide.init(context,
-        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+    Glide.init(
+        context, new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
   }
 
   @Test
   public void clear_withSingleRequest_nullsOutDrawableInView() {
-    concurrency.loadOnMainThread(
-        GlideApp.with(context)
-            .load(ResourceIds.raw.canonical),
-        imageView);
+    concurrency.loadOnMainThread(GlideApp.with(context).load(ResourceIds.raw.canonical), imageView);
     assertThat(imageView.getDrawable()).isNotNull();
 
     concurrency.clearOnMainThread(imageView);
@@ -72,10 +67,7 @@ public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
     concurrency.loadOnMainThread(
         GlideApp.with(context)
             .load(ResourceIds.raw.canonical)
-            .thumbnail(
-                GlideApp.with(context)
-                    .load(ResourceIds.raw.canonical)
-                    .override(100, 100)),
+            .thumbnail(GlideApp.with(context).load(ResourceIds.raw.canonical).override(100, 100)),
         imageView);
     assertThat(imageView.getDrawable()).isNotNull();
 
@@ -85,18 +77,16 @@ public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
 
   @Test
   public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
-    concurrency.loadOnMainThread(
-        GlideApp.with(context)
-            .load(ResourceIds.raw.canonical),
-        imageView);
+    concurrency.loadOnMainThread(GlideApp.with(context).load(ResourceIds.raw.canonical), imageView);
     assertThat(imageView.getDrawable()).isNotNull();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
     assertThat(imageView.getDrawable()).isNotNull();
   }
 
@@ -105,19 +95,17 @@ public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
     concurrency.loadOnMainThread(
         GlideApp.with(context)
             .load(ResourceIds.raw.canonical)
-            .thumbnail(
-                GlideApp.with(context)
-                  .load(ResourceIds.raw.canonical)
-                  .override(100, 100)),
+            .thumbnail(GlideApp.with(context).load(ResourceIds.raw.canonical).override(100, 100)),
         imageView);
     assertThat(imageView.getDrawable()).isNotNull();
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
     assertThat(imageView.getDrawable()).isNotNull();
   }
 
@@ -128,17 +116,16 @@ public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
         new Runnable() {
           @Override
           public void run() {
-            GlideApp.with(context)
-                .load(ResourceIds.raw.canonical)
-                .into(imageView);
+            GlideApp.with(context).load(ResourceIds.raw.canonical).into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
           }
         });
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
     assertThat(imageView.getDrawable()).isNull();
     model.countDown();
   }
@@ -152,21 +139,18 @@ public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView
           public void run() {
             GlideApp.with(context)
                 .load(model)
-                .thumbnail(
-                    GlideApp.with(context)
-                    .load(model)
-                    .override(100, 100))
+                .thumbnail(GlideApp.with(context).load(model).override(100, 100))
                 .into(imageView);
-
           }
         });
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
     assertThat(imageView.getDrawable()).isNull();
     model.countDown();
   }
@@ -179,18 +163,20 @@ public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
         GlideApp.with(context)
             .load(mainModel)
             .listener(requestListener)
-                .thumbnail(GlideApp.with(context)
+            .thumbnail(
+                GlideApp.with(context)
                     .load(ResourceIds.raw.canonical)
                     .listener(requestListener)
                     .override(100, 100)),
         imageView);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
 
     verify(requestListener, never())
         .onResourceReady(
@@ -217,18 +203,20 @@ public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawable
         GlideApp.with(context)
             .load(ResourceIds.raw.canonical)
             .listener(requestListener)
-                .thumbnail(GlideApp.with(context)
+            .thumbnail(
+                GlideApp.with(context)
                     .load(thumbModel)
                     .listener(requestListener)
                     .override(100, 100)),
         imageView);
 
-    concurrency.runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        GlideApp.with(context).onStop();
-      }
-    });
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context).onStop();
+          }
+        });
 
     verify(requestListener, never())
         .onResourceReady(
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
index 3e59c4b22..0d8f54aca 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -69,12 +69,13 @@ public void testRoundedCorners_usePool() throws ExecutionException, InterruptedE
 
     Glide.get(context).getBitmapPool().put(redRect);
 
-    Bitmap roundedRect = bitmapRegressionTester.test(
-        GlideApp.with(context)
-            .asBitmap()
-            .load(canonicalBitmap.getBitmap())
-            .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
-            .transform(new RoundedCorners(5)));
+    Bitmap roundedRect =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonicalBitmap.getBitmap())
+                .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
+                .transform(new RoundedCorners(5)));
 
     assertThat(roundedRect).isEqualTo(redRect);
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
index c1b532f3a..fb41e74df 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -42,10 +42,7 @@ public void setUp() {
   public void load_withWideGamutImage_returnsWideGamutBitmap() {
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(ResourceIds.raw.webkit_logo_p3)
-                .submit());
+            Glide.with(context).asBitmap().load(ResourceIds.raw.webkit_logo_p3).submit());
     assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
   }
 
@@ -58,16 +55,11 @@ public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFrom
             .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));
     Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);
 
-    Glide.get(context)
-        .getBitmapPool()
-        .put(expected);
+    Glide.get(context).getBitmapPool().put(expected);
 
     Bitmap bitmap =
         concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(ResourceIds.raw.webkit_logo_p3)
-                .submit());
+            Glide.with(context).asBitmap().load(ResourceIds.raw.webkit_logo_p3).submit());
     assertThat(bitmap).isSameAs(expected);
   }
 
@@ -94,12 +86,7 @@ public void load_withEncodedPngWideGamutImage_decodesWideGamut() {
 
     byte[] data = asPng(toCompress);
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
   }
 
@@ -114,12 +101,7 @@ public void load_withEncodedJpegWideGamutImage_decodesArgb8888() {
 
     byte[] data = asJpeg(toCompress);
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
   }
 
@@ -131,12 +113,7 @@ public void load_withEncodedWebpWideGamutImage_decodesArgb8888() {
 
     byte[] data = asWebp(toCompress);
 
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
   }
 
@@ -150,12 +127,7 @@ public void load_withSmallerWideGamutInPool_decodesBitmap() {
 
     Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);
     byte[] data = asPng(wideGamut);
-    Bitmap bitmap =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap bitmap = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
     assertThat(bitmap).isNotNull();
   }
 
@@ -165,12 +137,7 @@ public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {
     byte[] data = asPng(bitmap);
 
     Bitmap result =
-        concurrency.get(
-            GlideApp.with(context)
-                .asBitmap()
-                .load(data)
-                .circleCrop()
-                .submit());
+        concurrency.get(GlideApp.with(context).asBitmap().load(data).circleCrop().submit());
     assertThat(result).isNotNull();
     assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
   }
@@ -197,16 +164,13 @@ public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bit
     byte[] data = asPng(wideGamut);
 
     Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Glide.init(context, new GlideBuilder()
-        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
     Glide.get(context).getBitmapPool().put(argb8888);
 
-    Bitmap result =
-        concurrency.get(
-            Glide.with(context)
-                .asBitmap()
-                .load(data)
-                .submit());
+    Bitmap result = concurrency.get(Glide.with(context).asBitmap().load(data).submit());
 
     assertThat(result).isSameAs(argb8888);
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
index 94ef1782c..bd47ba690 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -10,9 +10,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
-/**
- * Creates mock {@link GlideExecutor}s.
- */
+/** Creates mock {@link GlideExecutor}s. */
 @VisibleForTesting
 public final class MockGlideExecutor {
   private MockGlideExecutor() {
@@ -29,9 +27,7 @@ public static GlideExecutor newMainThreadExecutor() {
     return newTestExecutor(new DirectExecutorService());
   }
 
-  /**
-   * @deprecated Use {@link #newMainThreadExecutor} instead.
-   */
+  /** @deprecated Use {@link #newMainThreadExecutor} instead. */
   @Deprecated
   public static GlideExecutor newMainThreadUnlimitedExecutor() {
     return newMainThreadExecutor();
@@ -43,10 +39,7 @@ public static GlideExecutor newMainThreadUnlimitedExecutor() {
    */
   private static final class DirectExecutorService extends ForwardingExecutorService {
     private static final StrictMode.ThreadPolicy THREAD_POLICY =
-        new StrictMode.ThreadPolicy.Builder()
-            .detectNetwork()
-            .penaltyDeath()
-            .build();
+        new StrictMode.ThreadPolicy.Builder().detectNetwork().penaltyDeath().build();
 
     private final ExecutorService delegate;
 
@@ -79,18 +72,19 @@ protected ExecutorService delegate() {
 
     @Override
     public void execute(@NonNull final Runnable command) {
-      delegate.execute(new Runnable() {
-        @Override
-        public void run() {
-          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
-          StrictMode.setThreadPolicy(THREAD_POLICY);
-          try {
-            command.run();
-          } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-          }
-        }
-      });
+      delegate.execute(
+          new Runnable() {
+            @Override
+            public void run() {
+              StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+              StrictMode.setThreadPolicy(THREAD_POLICY);
+              try {
+                command.run();
+              } finally {
+                StrictMode.setThreadPolicy(oldPolicy);
+              }
+            }
+          });
     }
 
     private <T> Future<T> getUninterruptibly(Future<T> future) {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
index bdc7fa0fd..955f017f0 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -39,7 +39,7 @@
 /**
  * Runs tests to make sure that DownsampleStrategy provides the output we expect.
  *
- * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ * <p>WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
  */
 @RunWith(AndroidJUnit4.class)
 @SuppressWarnings("VisibleForTests")
@@ -53,77 +53,46 @@ public void calculateScaling_withAtMost() throws IOException {
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(99, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(99, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(99, 12)))
-        .givenImageWithDimensionsOf(800, 100,
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(99, 12)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)))
         .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
-        .givenImageWithDimensionsOf(100, 800,
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(13, 100),
-                    formats(PNG)
-                        .expect(12, 100)),
+                .with(formats(JPEG, WEBP).expect(13, 100), formats(PNG).expect(12, 100)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(13, 100),
-                    formats(PNG, WEBP)
-                        .expect(12, 100)))
+                .with(formats(JPEG).expect(13, 100), formats(PNG, WEBP).expect(12, 100)))
         .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
         // This set of examples demonstrate that webp uses round on N+ and floor < N.
         .setTargetDimensions(13, 13)
-        .givenSquareImageWithDimensionOf(99,
+        .givenSquareImageWithDimensionOf(
+            99,
             atAndAbove(KITKAT)
                 .with(
                     // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)))
-        .givenSquareImageWithDimensionOf(100,
+                    formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)),
+            below(KITKAT).with(formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)))
+        .givenSquareImageWithDimensionOf(
+            100,
             atAndAbove(VERSION_CODES.N)
                 .with(
                     // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
-                    formats(JPEG, WEBP)
-                        .expect(13, 13),
-                    formats(PNG)
-                        .expect(12, 12)),
+                    formats(JPEG, WEBP).expect(13, 13), formats(PNG).expect(12, 12)),
             below(VERSION_CODES.N)
-                .with(
-                    formats(JPEG)
-                        .expect(13, 13),
-                    formats(PNG, WEBP)
-                        .expect(12, 12)))
+                .with(formats(JPEG).expect(13, 13), formats(PNG, WEBP).expect(12, 12)))
         // Upscaling
         .setTargetDimensions(500, 500)
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
@@ -158,33 +127,28 @@ public void calculateScaling_withCenterInside() throws IOException {
         .setTargetDimensions(100, 100)
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(200, 25),
-                    formats(PNG, WEBP)
-                        .expect(199, 25)))
-        .givenImageWithDimensionsOf(800, 100,
+            below(KITKAT).with(formats(JPEG).expect(200, 25), formats(PNG, WEBP).expect(199, 25)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
             below(KITKAT).with(allFormats().expect(200, 25)))
-        .givenImageWithDimensionsOf(801, 100,
+        .givenImageWithDimensionsOf(
+            801,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             apis(KITKAT, VERSION_CODES.M)
-              .with(
-                  formats(JPEG)
-                      .expect(100, 13),
-                  formats(PNG, WEBP)
-                      .expect(100, 12)),
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)),
             below(KITKAT)
                 .with(
                     // JPEG is correct because CENTER_INSIDE wants to give a subsequent
@@ -192,16 +156,17 @@ public void calculateScaling_withCenterInside() throws IOException {
                     // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
                     // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
                     // be called.
-                    formats(JPEG)
-                        .expect(101, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
-        .givenImageWithDimensionsOf(100, 800,
+                    formats(JPEG).expect(101, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
             below(KITKAT).with(allFormats().expect(25, 200)))
         .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
         .setTargetDimensions(897, 897)
-        .givenImageWithDimensionsOf(2208, 1520,
+        .givenImageWithDimensionsOf(
+            2208,
+            1520,
             atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
             below(KITKAT).with(allFormats().expect(1104, 760)))
         // Upscaling
@@ -219,25 +184,33 @@ public void calculateScaling_withCenterOutside() throws IOException {
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
         .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
         .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
         .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
         .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
-        .givenImageWithDimensionsOf(87, 78,
+        .givenImageWithDimensionsOf(
+            87,
+            78,
             atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
             below(KITKAT).with(allFormats().expect(87, 78)))
         // Upscaling
         .setTargetDimensions(500, 500)
-        .givenSquareImageWithDimensionOf(200,
+        .givenSquareImageWithDimensionOf(
+            200,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(200, 200)))
-        .givenSquareImageWithDimensionOf(450,
+        .givenSquareImageWithDimensionOf(
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(450, 450)))
-        .givenImageWithDimensionsOf(200, 450,
+        .givenImageWithDimensionsOf(
+            200,
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
             below(KITKAT).with(allFormats().expect(200, 450)))
         .run();
@@ -270,33 +243,28 @@ public void calculateScaling_withFitCenter() throws IOException {
         .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
         .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
-        .givenImageWithDimensionsOf(300, 300,
+        .givenImageWithDimensionsOf(
+            300,
+            300,
             atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
             below(KITKAT).with(allFormats().expect(150, 150)))
-        .givenImageWithDimensionsOf(799, 100,
+        .givenImageWithDimensionsOf(
+            799,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(200, 25),
-                    formats(PNG, WEBP)
-                        .expect(199, 25)))
-        .givenImageWithDimensionsOf(800, 100,
+            below(KITKAT).with(formats(JPEG).expect(200, 25), formats(PNG, WEBP).expect(199, 25)))
+        .givenImageWithDimensionsOf(
+            800,
+            100,
             atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
             below(KITKAT).with(allFormats().expect(200, 25)))
-        .givenImageWithDimensionsOf(801, 100,
+        .givenImageWithDimensionsOf(
+            801,
+            100,
             atAndAbove(VERSION_CODES.N)
-                .with(
-                    formats(JPEG, WEBP)
-                        .expect(100, 13),
-                    formats(PNG)
-                        .expect(100, 12)),
+                .with(formats(JPEG, WEBP).expect(100, 13), formats(PNG).expect(100, 12)),
             apis(KITKAT, VERSION_CODES.M)
-                .with(
-                    formats(JPEG)
-                        .expect(100, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)),
+                .with(formats(JPEG).expect(100, 13), formats(PNG, WEBP).expect(100, 12)),
             below(KITKAT)
                 .with(
                     // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
@@ -304,60 +272,68 @@ public void calculateScaling_withFitCenter() throws IOException {
                     // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
                     // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
                     // after it that will fix the rounding error.
-                    formats(JPEG)
-                        .expect(101, 13),
-                    formats(PNG, WEBP)
-                        .expect(100, 12)))
-        .givenImageWithDimensionsOf(100, 800,
+                    formats(JPEG).expect(101, 13), formats(PNG, WEBP).expect(100, 12)))
+        .givenImageWithDimensionsOf(
+            100,
+            800,
             atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
             below(KITKAT).with(allFormats().expect(25, 200)))
-        .givenImageWithDimensionsOf(87, 78,
+        .givenImageWithDimensionsOf(
+            87,
+            78,
             atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
             below(KITKAT).with(allFormats().expect(87, 78)))
         .setTargetDimensions(897, 897)
-        .givenImageWithDimensionsOf(2208, 1520,
+        .givenImageWithDimensionsOf(
+            2208,
+            1520,
             atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
             below(KITKAT).with(allFormats().expect(1104, 760)))
         .setTargetDimensions(270, 270)
         // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
         // varies for jpegs.
-        .givenImageWithDimensionsOf(9014, 1638,
+        .givenImageWithDimensionsOf(
+            9014,
+            1638,
             // 15 and 16 will OOM so don't run them.
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
             apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
                 .with(allFormats().expect(281, 51)))
-        .givenImageWithDimensionsOf(1638, 9014,
+        .givenImageWithDimensionsOf(
+            1638,
+            9014,
             // 15 and 16 will OOM so don't run them.
             atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
             apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
                 .with(allFormats().expect(51, 281)))
-        .givenImageWithDimensionsOf(1638, 1638,
+        .givenImageWithDimensionsOf(
+            1638,
+            1638,
             atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
-            below(KITKAT)
-                .with(
-                    formats(JPEG)
-                        .expect(410, 410),
-                    formats(PNG, WEBP)
-                        .expect(409, 409)))
-        .givenImageWithDimensionsOf(4507, 819,
+            below(KITKAT).with(formats(JPEG).expect(410, 410), formats(PNG, WEBP).expect(409, 409)))
+        .givenImageWithDimensionsOf(
+            4507,
+            819,
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
-            below(KITKAT).with(
-                formats(JPEG)
-                    .expect(282, 51),
-                formats(PNG, WEBP)
-                    .expect(281, 51)))
-        .givenImageWithDimensionsOf(4503, 819,
+            below(KITKAT).with(formats(JPEG).expect(282, 51), formats(PNG, WEBP).expect(281, 51)))
+        .givenImageWithDimensionsOf(
+            4503,
+            819,
             atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
             below(KITKAT).with(allFormats().expect(281, 51)))
         // Upscaling
         .setTargetDimensions(500, 500)
-        .givenSquareImageWithDimensionOf(200,
+        .givenSquareImageWithDimensionOf(
+            200,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(200, 200)))
-        .givenSquareImageWithDimensionOf(450,
+        .givenSquareImageWithDimensionOf(
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
             below(KITKAT).with(allFormats().expect(450, 450)))
-        .givenImageWithDimensionsOf(200, 450,
+        .givenImageWithDimensionsOf(
+            200,
+            450,
             atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
             below(KITKAT).with(allFormats().expect(200, 450)))
         .run();
@@ -373,7 +349,8 @@ private static String runScaleTest(
       int targetHeight,
       DownsampleStrategy strategy,
       int expectedWidth,
-      int expectedHeight) throws IOException {
+      int expectedHeight)
+      throws IOException {
     Downsampler downsampler = buildDownsampler();
 
     InputStream is = openBitmapStream(format, initialWidth, initialHeight);
@@ -381,12 +358,23 @@ private static String runScaleTest(
     Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
     try {
       if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
-        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
-            + ", format: " + format + ", strategy: " + strategy + " -"
-            + " Initial " + readableDimens(initialWidth, initialHeight)
-            + " Target " + readableDimens(targetWidth, targetHeight)
-            + " Expected " + readableDimens(expectedWidth, expectedHeight)
-            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+        return "API: "
+            + Build.VERSION.SDK_INT
+            + ", os: "
+            + Build.VERSION.RELEASE
+            + ", format: "
+            + format
+            + ", strategy: "
+            + strategy
+            + " -"
+            + " Initial "
+            + readableDimens(initialWidth, initialHeight)
+            + " Target "
+            + readableDimens(targetWidth, targetHeight)
+            + " Expected "
+            + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received "
+            + readableDimens(bitmap.getWidth(), bitmap.getHeight());
       }
     } finally {
       bitmap.recycle();
@@ -439,8 +427,7 @@ Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) {
       return givenImageWithDimensionsOf(dimension, dimension, apis);
     }
 
-    Tester givenImageWithDimensionsOf(
-        int sourceWidth, int sourceHeight, Api... apis) {
+    Tester givenImageWithDimensionsOf(int sourceWidth, int sourceHeight, Api... apis) {
       testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
       return this;
     }
@@ -477,8 +464,7 @@ void run() throws IOException {
         this.apis = apis;
       }
 
-      List<String> test(DownsampleStrategy strategy)
-          throws IOException {
+      List<String> test(DownsampleStrategy strategy) throws IOException {
         List<String> results = new ArrayList<>();
         for (Api api : apis) {
           results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
@@ -554,7 +540,6 @@ Api with(Formats... formats) {
       for (Formats format : formats) {
         results.addAll(
             format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
-
       }
       return results;
     }
@@ -596,18 +581,20 @@ Formats expect(int width, int height) {
         int sourceHeight,
         int targetWidth,
         int targetHeight,
-        DownsampleStrategy strategy) throws IOException {
+        DownsampleStrategy strategy)
+        throws IOException {
       List<String> result = new ArrayList<>();
       for (CompressFormat format : formats) {
-        String testResult = runScaleTest(
-            format,
-            sourceWidth,
-            sourceHeight,
-            targetWidth,
-            targetHeight,
-            strategy,
-            expectedWidth,
-            expectedHeight);
+        String testResult =
+            runScaleTest(
+                format,
+                sourceWidth,
+                sourceHeight,
+                targetWidth,
+                targetHeight,
+                strategy,
+                expectedWidth,
+                expectedHeight);
         if (testResult != null) {
           result.add(testResult);
         }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 9d5bddd32..68c39b36e 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -79,10 +79,7 @@ public void loadGif_withTransparentGif_sizeOriginal_succeeds()
       throws ExecutionException, InterruptedException {
     GifDrawable gifDrawable =
         concurrencyHelper.get(
-            GlideApp.with(context)
-                .asGif()
-                .load(ResourceIds.raw.transparent_gif)
-                .submit());
+            GlideApp.with(context).asGif().load(ResourceIds.raw.transparent_gif).submit());
     assertThat(gifDrawable).isNotNull();
   }
 
@@ -91,10 +88,7 @@ public void loadGif_withTransparentGif_downsampled_succeeds()
       throws ExecutionException, InterruptedException {
     GifDrawable gifDrawable =
         concurrencyHelper.get(
-            GlideApp.with(context)
-                .asGif()
-                .load(ResourceIds.raw.transparent_gif)
-                .submit(10, 10));
+            GlideApp.with(context).asGif().load(ResourceIds.raw.transparent_gif).submit(10, 10));
     assertThat(gifDrawable).isNotNull();
   }
 
@@ -103,10 +97,7 @@ public void loadGif_withOpaqueGif_sizeOriginal_succeeds()
       throws ExecutionException, InterruptedException {
     GifDrawable gifDrawable =
         concurrencyHelper.get(
-            GlideApp.with(context)
-                .asGif()
-                .load(ResourceIds.raw.opaque_gif)
-                .submit());
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_gif).submit());
     assertThat(gifDrawable).isNotNull();
   }
 
@@ -115,10 +106,7 @@ public void loadGif_withOpaqueGif_downsampled_succeeds()
       throws ExecutionException, InterruptedException {
     GifDrawable gifDrawable =
         concurrencyHelper.get(
-            GlideApp.with(context)
-                .asGif()
-                .load(ResourceIds.raw.opaque_gif)
-                .submit(10, 10));
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_gif).submit(10, 10));
     assertThat(gifDrawable).isNotNull();
   }
 
@@ -127,10 +115,7 @@ public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds()
       throws ExecutionException, InterruptedException {
     GifDrawable gifDrawable =
         concurrencyHelper.get(
-            GlideApp.with(context)
-                .asGif()
-              .load(ResourceIds.raw.opaque_interlaced_gif)
-              .submit());
+            GlideApp.with(context).asGif().load(ResourceIds.raw.opaque_interlaced_gif).submit());
     assertThat(gifDrawable).isNotNull();
   }
 
@@ -167,12 +152,13 @@ public void run() {
             // Make sure a frame is loaded while the drawable is stopped.
             GifState gifState =
                 (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());
-            gifState.frameLoader.setOnEveryFrameReadyListener(new OnEveryFrameListener() {
-              @Override
-              public void onFrameReady() {
-                waitForGifFrame.countDown();
-              }
-            });
+            gifState.frameLoader.setOnEveryFrameReadyListener(
+                new OnEveryFrameListener() {
+                  @Override
+                  public void onFrameReady() {
+                    waitForGifFrame.countDown();
+                  }
+                });
             gifDrawable.start();
             gifDrawable.stop();
           }
@@ -191,10 +177,7 @@ public void run() {
         });
 
     concurrencyHelper.loadOnMainThread(
-        GlideApp.with(context)
-            .load(gifDrawable)
-            .override(Target.SIZE_ORIGINAL),
-        imageView);
+        GlideApp.with(context).load(gifDrawable).override(Target.SIZE_ORIGINAL), imageView);
 
     GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
     assertThat(drawableFromView.isRunning()).isTrue();
@@ -212,9 +195,9 @@ private void addViewToWindow(View view) {
         Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
             ? LayoutParams.TYPE_APPLICATION_OVERLAY
             : Build.VERSION.SDK_INT == Build.VERSION_CODES.M
-                ? LayoutParams.TYPE_TOAST : LayoutParams.TYPE_SYSTEM_ALERT;
-    WindowManager windowManager =
-        (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+                ? LayoutParams.TYPE_TOAST
+                : LayoutParams.TYPE_SYSTEM_ALERT;
+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
     Preconditions.checkNotNull(windowManager).addView(view, layoutParams);
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
index fa8a62338..aae82aaa1 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -24,10 +24,10 @@
  * saved Bitmap.
  *
  * <p>Can be used to generate or re-generate expected {@link Bitmap}s by placing a file named
- * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have
- * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk
- * by adding {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both
- * a test class and a particular method, the values from the method will be used.
+ * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have {@link
+ * android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk by adding
+ * {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both a test
+ * class and a particular method, the values from the method will be used.
  *
  * <p>This class only handles exactly one Bitmap comparison per test method because the resource
  * names it expects and generates are based on the method name.
@@ -55,9 +55,7 @@ public BitmapRegressionTester(Class<?> testClass, TestName testName) {
 
   public Bitmap test(RequestBuilder<Bitmap> request)
       throws ExecutionException, InterruptedException {
-    Bitmap result = request
-        .submit()
-        .get();
+    Bitmap result = request.submit().get();
     if (writeNewExpected()) {
       writeBitmap(result);
     }
@@ -68,7 +66,8 @@ public Bitmap test(RequestBuilder<Bitmap> request)
 
   private String getResourceName() {
     return getClassNameString()
-        + SEPARATOR + testName.getMethodName().toLowerCase()
+        + SEPARATOR
+        + testName.getMethodName().toLowerCase()
         + getSdkIntString()
         + getCpuString();
   }
@@ -151,7 +150,7 @@ private void writeBitmap(Bitmap bitmap) {
     OutputStream os = null;
     try {
       os = new BufferedOutputStream(new FileOutputStream(file));
-      bitmap.compress(CompressFormat.PNG, /*quality=*/100, os);
+      bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
       os.close();
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -173,11 +172,17 @@ private boolean writeNewExpected() {
 
   private Bitmap decodeExpected() {
     int resourceId =
-        context.getResources()
+        context
+            .getResources()
             .getIdentifier(getResourceName(), RESOURCE_TYPE, context.getPackageName());
     if (resourceId == 0) {
-      throw new IllegalArgumentException("Failed to find resource for: " + getResourceName()
-       + " with type: " + RESOURCE_TYPE + " and package: " + context.getPackageName());
+      throw new IllegalArgumentException(
+          "Failed to find resource for: "
+              + getResourceName()
+              + " with type: "
+              + RESOURCE_TYPE
+              + " and package: "
+              + context.getPackageName());
     }
     BitmapFactory.Options options = new BitmapFactory.Options();
     options.inScaled = false;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
index bc795234b..7622db747 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -14,9 +14,7 @@
 import com.google.common.truth.Subject;
 import com.google.common.truth.Truth;
 
-/**
- * Truth assertions for comparing {@link Bitmap}s.
- */
+/** Truth assertions for comparing {@link Bitmap}s. */
 // Test APIs.
 @SuppressWarnings({"WeakerAccess", "unused"})
 public final class BitmapSubject extends Subject<BitmapSubject, Bitmap> {
@@ -54,8 +52,12 @@ protected String actualCustomStringRepresentation() {
   }
 
   private static String getDisplayString(Bitmap bitmap) {
-     return "<"
-        + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "]"
+    return "<"
+        + "["
+        + bitmap.getWidth()
+        + "x"
+        + bitmap.getHeight()
+        + "]"
         + " "
         + bitmap.getConfig()
         + ">";
@@ -80,7 +82,7 @@ public void hasDimensions(int expectedWidth, int expectedHeight) {
     }
   }
 
-  public void isMutable()  {
+  public void isMutable() {
     if (!actual.isMutable()) {
       failWithActual(simpleFact("expected to be mutable"));
     }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
index d990cf4f8..2fc058a03 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -9,10 +9,8 @@
 import com.bumptech.glide.util.Preconditions;
 
 public final class CanonicalBitmap {
-  @Nullable
-  private Bitmap bitmap;
-  @Nullable
-  private Float scaleFactor;
+  @Nullable private Bitmap bitmap;
+  @Nullable private Float scaleFactor;
 
   @NonNull
   public synchronized Bitmap getBitmap() {
@@ -43,11 +41,12 @@ private Bitmap decodeBitmap() {
     int resourceId = ResourceIds.raw.canonical;
     Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);
     if (scaleFactor != null) {
-      result = Bitmap.createScaledBitmap(
-          result,
-          (int) (result.getWidth() * scaleFactor),
-          (int) (result.getHeight() * scaleFactor),
-          /*filter=*/false);
+      result =
+          Bitmap.createScaledBitmap(
+              result,
+              (int) (result.getWidth() * scaleFactor),
+              (int) (result.getHeight() * scaleFactor),
+              /*filter=*/ false);
     }
     // Make sure the Bitmap is immutable.
     return result;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index 20888d70a..cfb88bb10 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -26,9 +26,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-/**
- * Helper for running sections of code on the main thread in emulator tests.
- */
+/** Helper for running sections of code on the main thread in emulator tests. */
 public class ConcurrencyHelper {
   private final Handler handler = new Handler(Looper.getMainLooper());
   private static final long TIMEOUT_SECONDS = 10;
@@ -36,19 +34,20 @@
 
   public <T> T get(final Future<T> future) {
     final AtomicReference<T> reference = new AtomicReference<>();
-    wait(new Waiter() {
-      @Override
-      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
-        try {
-          reference.set(future.get(timeout, timeUnit));
-          return true;
-        } catch (ExecutionException e) {
-          throw new RuntimeException(e.getCause());
-        } catch (TimeoutException e) {
-          return false;
-        }
-      }
-    });
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            try {
+              reference.set(future.get(timeout, timeUnit));
+              return true;
+            } catch (ExecutionException e) {
+              throw new RuntimeException(e.getCause());
+            } catch (TimeoutException e) {
+              return false;
+            }
+          }
+        });
     return reference.get();
   }
 
@@ -59,233 +58,241 @@ public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedExceptio
 
   public void loadOnOtherThread(final Runnable runnable) {
     final AtomicBoolean isDone = new AtomicBoolean();
-    final Thread thread = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        runnable.run();
-        isDone.set(true);
-      }
-    });
+    final Thread thread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                runnable.run();
+                isDone.set(true);
+              }
+            });
     thread.start();
 
-    wait(new Waiter() {
-      @Override
-      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
-        thread.join(timeUnit.toMillis(timeout));
-        return isDone.get();
-      }
-    });
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            thread.join(timeUnit.toMillis(timeout));
+            return isDone.get();
+          }
+        });
   }
 
-  public void loadOnMainThread(
-      final RequestBuilder<Drawable> builder, ImageView imageView) {
+  public void loadOnMainThread(final RequestBuilder<Drawable> builder, ImageView imageView) {
     loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
   }
 
   public void clearOnMainThread(final ImageView imageView) {
-    runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        Glide.with(InstrumentationRegistry.getTargetContext())
-            .clear(imageView);
-      }
-    });
+    runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            Glide.with(InstrumentationRegistry.getTargetContext()).clear(imageView);
+          }
+        });
   }
 
-  public void loadUntilFirstFinish(
-      final RequestBuilder<Drawable> builder, ImageView imageView) {
+  public void loadUntilFirstFinish(final RequestBuilder<Drawable> builder, ImageView imageView) {
     loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
   }
 
-  private <T> void loadUntilFirstFinish(
-      final RequestBuilder<T> builder, final Target<T> target) {
+  private <T> void loadUntilFirstFinish(final RequestBuilder<T> builder, final Target<T> target) {
     final CountDownLatch latch = new CountDownLatch(1);
-    callOnMainThread(new Callable<Target<T>>() {
-      @Override
-      public Target<T> call() {
-        builder.into(new Target<T>() {
+    callOnMainThread(
+        new Callable<Target<T>>() {
           @Override
-          public void onStart() {
-            target.onStart();
-          }
-
-          @Override
-          public void onStop() {
-            target.onStop();
-          }
-
-          @Override
-          public void onDestroy() {
-            target.onDestroy();
-          }
-
-          @Override
-          public void onResourceReady(@NonNull T resource,
-              @Nullable Transition<? super T> transition) {
-            target.onResourceReady(resource, transition);
-            latch.countDown();
-          }
-
-          @Override
-          public void onLoadCleared(@Nullable Drawable placeholder) {
-            target.onLoadCleared(placeholder);
-          }
-
-          @Override
-          public void onLoadStarted(@Nullable Drawable placeholder) {
-            target.onLoadStarted(placeholder);
-          }
-
-          @Override
-          public void onLoadFailed(@Nullable Drawable errorDrawable) {
-            target.onLoadFailed(errorDrawable);
-            latch.countDown();
-          }
-
-          @Override
-          public void getSize(@NonNull SizeReadyCallback cb) {
-            target.getSize(cb);
-          }
-
-          @Override
-          public void removeCallback(@NonNull SizeReadyCallback cb) {
-            target.removeCallback(cb);
-          }
-
-          @Override
-          public void setRequest(@Nullable Request request) {
-            target.setRequest(request);
-          }
-
-          @Nullable
-          @Override
-          public Request getRequest() {
-            return target.getRequest();
+          public Target<T> call() {
+            builder.into(
+                new Target<T>() {
+                  @Override
+                  public void onStart() {
+                    target.onStart();
+                  }
+
+                  @Override
+                  public void onStop() {
+                    target.onStop();
+                  }
+
+                  @Override
+                  public void onDestroy() {
+                    target.onDestroy();
+                  }
+
+                  @Override
+                  public void onResourceReady(
+                      @NonNull T resource, @Nullable Transition<? super T> transition) {
+                    target.onResourceReady(resource, transition);
+                    latch.countDown();
+                  }
+
+                  @Override
+                  public void onLoadCleared(@Nullable Drawable placeholder) {
+                    target.onLoadCleared(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadStarted(@Nullable Drawable placeholder) {
+                    target.onLoadStarted(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+                    target.onLoadFailed(errorDrawable);
+                    latch.countDown();
+                  }
+
+                  @Override
+                  public void getSize(@NonNull SizeReadyCallback cb) {
+                    target.getSize(cb);
+                  }
+
+                  @Override
+                  public void removeCallback(@NonNull SizeReadyCallback cb) {
+                    target.removeCallback(cb);
+                  }
+
+                  @Override
+                  public void setRequest(@Nullable Request request) {
+                    target.setRequest(request);
+                  }
+
+                  @Nullable
+                  @Override
+                  public Request getRequest() {
+                    return target.getRequest();
+                  }
+                });
+            return target;
           }
         });
-        return target;
-      }
-    });
     waitOnLatch(latch);
   }
 
   private <T> void loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
     final CountDownLatch latch = new CountDownLatch(1);
-    callOnMainThread(new Callable<Target<T>>() {
-      @Override
-      public Target<T> call() {
-        builder.into(new Target<T>() {
-          @Override
-          public void onStart() {
-            target.onStart();
-          }
-
-          @Override
-          public void onStop() {
-            target.onStop();
-          }
-
-          @Override
-          public void onDestroy() {
-            target.onDestroy();
-          }
-
-          @Override
-          public void onResourceReady(@NonNull T resource,
-              @Nullable Transition<? super T> transition) {
-            target.onResourceReady(resource, transition);
-            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
-              latch.countDown();
-            }
-          }
-
-          @Override
-          public void onLoadCleared(@Nullable Drawable placeholder) {
-            target.onLoadCleared(placeholder);
-          }
-
+    callOnMainThread(
+        new Callable<Target<T>>() {
           @Override
-          public void onLoadStarted(@Nullable Drawable placeholder) {
-            target.onLoadStarted(placeholder);
-          }
-
-          @Override
-          public void onLoadFailed(@Nullable Drawable errorDrawable) {
-            target.onLoadFailed(errorDrawable);
-            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
-              latch.countDown();
-            }
-          }
-
-          @Override
-          public void getSize(@NonNull SizeReadyCallback cb) {
-            target.getSize(cb);
-          }
-
-          @Override
-          public void removeCallback(@NonNull SizeReadyCallback cb) {
-            target.removeCallback(cb);
-          }
-
-          @Override
-          public void setRequest(@Nullable Request request) {
-            target.setRequest(request);
-          }
-
-          @Nullable
-          @Override
-          public Request getRequest() {
-            return target.getRequest();
+          public Target<T> call() {
+            builder.into(
+                new Target<T>() {
+                  @Override
+                  public void onStart() {
+                    target.onStart();
+                  }
+
+                  @Override
+                  public void onStop() {
+                    target.onStop();
+                  }
+
+                  @Override
+                  public void onDestroy() {
+                    target.onDestroy();
+                  }
+
+                  @Override
+                  public void onResourceReady(
+                      @NonNull T resource, @Nullable Transition<? super T> transition) {
+                    target.onResourceReady(resource, transition);
+                    if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+                      latch.countDown();
+                    }
+                  }
+
+                  @Override
+                  public void onLoadCleared(@Nullable Drawable placeholder) {
+                    target.onLoadCleared(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadStarted(@Nullable Drawable placeholder) {
+                    target.onLoadStarted(placeholder);
+                  }
+
+                  @Override
+                  public void onLoadFailed(@Nullable Drawable errorDrawable) {
+                    target.onLoadFailed(errorDrawable);
+                    if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+                      latch.countDown();
+                    }
+                  }
+
+                  @Override
+                  public void getSize(@NonNull SizeReadyCallback cb) {
+                    target.getSize(cb);
+                  }
+
+                  @Override
+                  public void removeCallback(@NonNull SizeReadyCallback cb) {
+                    target.removeCallback(cb);
+                  }
+
+                  @Override
+                  public void setRequest(@Nullable Request request) {
+                    target.setRequest(request);
+                  }
+
+                  @Nullable
+                  @Override
+                  public Request getRequest() {
+                    return target.getRequest();
+                  }
+                });
+            return target;
           }
         });
-        return target;
-      }
-    });
     waitOnLatch(latch);
   }
 
   public void pokeMainThread() {
-    runOnMainThread(new Runnable() {
-      @Override
-      public void run() {
-        // Do nothing.
-      }
-    });
+    runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Do nothing.
+          }
+        });
   }
 
   public void runOnMainThread(final Runnable runnable) {
-    callOnMainThread(new Callable<Void>() {
-      @Override
-      public Void call() {
-        runnable.run();
-        return null;
-      }
-    });
+    callOnMainThread(
+        new Callable<Void>() {
+          @Override
+          public Void call() {
+            runnable.run();
+            return null;
+          }
+        });
   }
 
   private <T> void callOnMainThread(final Callable<T> callable) {
     final CountDownLatch latch = new CountDownLatch(1);
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          callable.call();
-        } catch (Exception e) {
-          throw new RuntimeException(e);
-        }
-        latch.countDown();
-      }
-    });
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              callable.call();
+            } catch (Exception e) {
+              throw new RuntimeException(e);
+            }
+            latch.countDown();
+          }
+        });
     waitOnLatch(latch);
   }
 
   public static void waitOnLatch(final CountDownLatch latch) {
-    wait(new Waiter() {
-      @Override
-      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
-        return latch.await(timeout, timeUnit);
-      }
-    });
+    wait(
+        new Waiter() {
+          @Override
+          public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+            return latch.await(timeout, timeUnit);
+          }
+        });
   }
 
   private interface Waiter {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
index d941793ea..fadc72d0d 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -6,9 +6,7 @@
 import android.graphics.drawable.Drawable;
 import com.bumptech.glide.request.target.Target;
 
-/**
- * Mockito matchers for various common classes.
- */
+/** Mockito matchers for various common classes. */
 public final class Matchers {
 
   private Matchers() {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
index 2726152f6..1aecbe138 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -47,8 +47,8 @@ private MockModelLoader(ModelT model, DataT data) {
   }
 
   @Override
-  public LoadData<DataT> buildLoadData(@NonNull ModelT modelT, int width, int height,
-      @NonNull Options options) {
+  public LoadData<DataT> buildLoadData(
+      @NonNull ModelT modelT, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(modelT), new MockDataFetcher<>(data));
   }
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
index a6dd3629e..5ca5db97c 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.test;
 
-
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
index 8a6b15ce4..9fde5b48b 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -28,7 +28,7 @@ private ResourceIds() {
 
   public interface drawable {
     int bitmap_alias = getResourceId("drawable", "bitmap_alias");
-    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int googlelogo_color_120x44dp = getResourceId("drawable", "googlelogo_color_120x44dp");
     int shape_drawable = getResourceId("drawable", "shape_drawable");
     int state_list_drawable = getResourceId("drawable", "state_list_drawable");
     int vector_drawable = getResourceId("drawable", "vector_drawable");
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
index 05fc9cc50..91c70d8cd 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
@@ -11,5 +11,4 @@
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface SplitByCpu {
-}
+public @interface SplitByCpu {}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
index bc882430a..fee994178 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
@@ -9,7 +9,7 @@
  * Used by {@link BitmapRegressionTester} to generate SDK specific resources to account for
  * differences in Android's image decoding APIs across versions.
  */
-@Target({ ElementType.METHOD, ElementType.TYPE })
+@Target({ElementType.METHOD, ElementType.TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface SplitBySdk {
   int[] value();
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
index 61263c353..2c589e845 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -7,9 +7,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
-/**
- * Clears out Glide's disk cache and the Glide singleton after every test method.
- */
+/** Clears out Glide's disk cache and the Glide singleton after every test method. */
 public final class TearDownGlide implements TestRule {
 
   @Override
@@ -20,15 +18,17 @@ public void evaluate() throws Throwable {
         try {
           base.evaluate();
         } finally {
-          new ConcurrencyHelper().runOnMainThread(new Runnable() {
-            @Override
-            public void run() {
-              RequestManager requestManager =
-                  Glide.with(InstrumentationRegistry.getTargetContext());
-              requestManager.onStop();
-              requestManager.onDestroy();
-            }
-          });
+          new ConcurrencyHelper()
+              .runOnMainThread(
+                  new Runnable() {
+                    @Override
+                    public void run() {
+                      RequestManager requestManager =
+                          Glide.with(InstrumentationRegistry.getTargetContext());
+                      requestManager.onStop();
+                      requestManager.onDestroy();
+                    }
+                  });
           Glide.tearDown();
         }
       }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
index e702b7fc5..5198312f5 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -19,8 +19,7 @@
  * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
  * is called.
  */
-public final class WaitModelLoader<Model, Data>
-    implements ModelLoader<WaitModel<Model>, Data> {
+public final class WaitModelLoader<Model, Data> implements ModelLoader<WaitModel<Model>, Data> {
 
   private final ModelLoader<Model, Data> wrapped;
 
@@ -32,8 +31,8 @@ private WaitModelLoader(ModelLoader<Model, Data> wrapped) {
   @Override
   public LoadData<Data> buildLoadData(
       @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {
-    LoadData<Data> wrappedLoadData = wrapped
-        .buildLoadData(waitModel.wrapped, width, height, options);
+    LoadData<Data> wrappedLoadData =
+        wrapped.buildLoadData(waitModel.wrapped, width, height, options);
     if (wrappedLoadData == null) {
       return null;
     }
@@ -74,7 +73,8 @@ public void countDown() {
     }
 
     public static synchronized <T> WaitModel<T> waitOn(T model) {
-      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
+      @SuppressWarnings("unchecked")
+      ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
           new Factory<>((Class<T>) model.getClass(), InputStream.class);
       Glide.get(InstrumentationRegistry.getTargetContext())
           .getRegistry()
@@ -85,8 +85,7 @@ public void countDown() {
 
     @NonNull
     @Override
-    public ModelLoader<WaitModel<Model>, Data> build(
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<WaitModel<Model>, Data> build(MultiModelLoaderFactory multiFactory) {
       return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
     }
 
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 0d67e6fd7..df796faf6 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -32,34 +32,39 @@
 import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceEncoder} that can write
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
+ * An {@link com.bumptech.glide.load.ResourceEncoder} that can write {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable} to cache.
  */
 public class ReEncodingGifResourceEncoder implements ResourceEncoder<GifDrawable> {
 
   private static final String KEY_ENCODE_TRANSFORMATION =
       "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
   /**
-   * A boolean option that, if set to <code>true</code>, causes the fully transformed
-   * GIF to be written to cache.
+   * A boolean option that, if set to <code>true</code>, causes the fully transformed GIF to be
+   * written to cache.
    *
-   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
-   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs.
+   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than the
+   * originals. Re-encoding may be worth it to decrease the size of very large GIFs.
    *
    * <p>Defaults to <code>false</code>.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> ENCODE_TRANSFORMATION =
-      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
-        @Override
-        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,
-            @NonNull MessageDigest messageDigest) {
-          if (value) {
-            messageDigest.update(keyBytes);
-          }
-        }
-      });
+      Option.disk(
+          KEY_ENCODE_TRANSFORMATION,
+          false,
+          new Option.CacheKeyUpdater<Boolean>() {
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Boolean value,
+                @NonNull MessageDigest messageDigest) {
+              if (value) {
+                messageDigest.update(keyBytes);
+              }
+            }
+          });
 
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
@@ -87,12 +92,13 @@ public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPoo
   public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
     return encodeTransformation != null && encodeTransformation
-        ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
+        ? EncodeStrategy.TRANSFORMED
+        : EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,
-      @NonNull Options options) {
+  public boolean encode(
+      @NonNull Resource<GifDrawable> resource, @NonNull File file, @NonNull Options options) {
     GifDrawable drawable = resource.get();
     Transformation<Bitmap> transformation = drawable.getFrameTransformation();
     boolean isTransformed = !(transformation instanceof UnitTransformation);
@@ -123,12 +129,17 @@ private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
           // Ignored.
         }
       }
-
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and "
-          + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
-          + " ms");
+      Log.v(
+          TAG,
+          "Re-encoded GIF with "
+              + drawable.getFrameCount()
+              + " frames and "
+              + drawable.getBuffer().limit()
+              + " bytes in "
+              + LogTime.getElapsedMillis(startTime)
+              + " ms");
     }
 
     return success;
@@ -187,8 +198,8 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
     return decoder;
   }
 
-  private Resource<Bitmap> getTransformedFrame(Bitmap currentFrame,
-      Transformation<Bitmap> transformation, GifDrawable drawable) {
+  private Resource<Bitmap> getTransformedFrame(
+      Bitmap currentFrame, Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
     Resource<Bitmap> transformedResource =
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 641dc7357..42bcafa54 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -42,9 +42,7 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
- */
+/** Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ReEncodingGifResourceEncoderTest {
@@ -249,7 +247,7 @@ public void testWritesTransformedBitmaps() {
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(transformedFrame);
     when(frameTransformation.transform(
-        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+            anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 1bc1047a9..ae743353c 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -9,13 +9,13 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
- * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an
+ * OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
index bc81dabc0..9abe0ab02 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -12,9 +12,8 @@
 /**
  * Registers OkHttp related classes via Glide's annotation processor.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  *
  * @deprecated Prefer the okhttp3 version instead.
  */
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index dcac2f768..67ffc6562 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -27,8 +27,14 @@
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  @SuppressWarnings("WeakerAccess") @Synthetic InputStream stream;
-  @SuppressWarnings("WeakerAccess") @Synthetic ResponseBody responseBody;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  InputStream stream;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  ResponseBody responseBody;
 
   // Public API.
   @SuppressWarnings("WeakerAccess")
@@ -38,8 +44,8 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
   }
 
   @Override
-  public void loadData(@NonNull Priority priority,
-      @NonNull final DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
@@ -47,27 +53,31 @@ public void loadData(@NonNull Priority priority,
     }
     Request request = requestBuilder.build();
 
-    client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
-      @Override
-      public void onFailure(Request request, IOException e) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp failed to obtain result", e);
-        }
-        callback.onLoadFailed(e);
-      }
+    client
+        .newCall(request)
+        .enqueue(
+            new com.squareup.okhttp.Callback() {
+              @Override
+              public void onFailure(Request request, IOException e) {
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                  Log.d(TAG, "OkHttp failed to obtain result", e);
+                }
+                callback.onLoadFailed(e);
+              }
 
-      @Override
-      public void onResponse(Response response) throws IOException {
-        responseBody = response.body();
-        if (response.isSuccessful()) {
-          long contentLength = responseBody.contentLength();
-          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-          callback.onDataReady(stream);
-        } else {
-          callback.onLoadFailed(new HttpException(response.message(), response.code()));
-        }
-      }
-    });
+              @Override
+              public void onResponse(Response response) throws IOException {
+                responseBody = response.body();
+                if (response.isSuccessful()) {
+                  long contentLength = responseBody.contentLength();
+                  stream =
+                      ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+                  callback.onDataReady(stream);
+                } else {
+                  callback.onLoadFailed(new HttpException(response.message(), response.code()));
+                }
+              }
+            });
   }
 
   @Override
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 174c446f2..3cc4fbd35 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -32,14 +32,12 @@ public boolean handles(@NonNull GlideUrl url) {
 
   @SuppressWarnings("deprecation")
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
-  /**
-   * The default factory for {@link OkHttpUrlLoader}s.
-   */
+  /** The default factory for {@link OkHttpUrlLoader}s. */
   // Public API.
   @SuppressWarnings({"WeakerAccess", "deprecation"})
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
@@ -57,16 +55,12 @@ private static OkHttpClient getInternalClient() {
       return internalClient;
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton client.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton client. */
     public Factory() {
       this(getInternalClient());
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using given client.
-     */
+    /** Constructor for a new Factory that runs requests using given client. */
     public Factory(OkHttpClient client) {
       this.client = client;
     }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index e58b041dd..29f70cb30 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -9,16 +9,16 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
- * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an
+ * OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
- * annotations.
+ *     annotations.
  */
 @Deprecated
 public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
index b315acbd7..579cdb100 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -13,15 +13,14 @@
 /**
  * Registers OkHttp related classes via Glide's annotation processor.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  */
 @GlideModule
 public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index 2b6a69b38..8dbdcb58e 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -17,9 +17,7 @@
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 
-/**
- * Fetches an {@link InputStream} using the okhttp library.
- */
+/** Fetches an {@link InputStream} using the okhttp library. */
 public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
@@ -39,8 +37,8 @@ public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
   }
 
   @Override
-  public void loadData(@NonNull Priority priority,
-      @NonNull final DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index 8f8f9066c..615ac8cba 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -10,9 +10,7 @@
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
 
-/**
- * A simple model loader for fetching media over http/https using OkHttp.
- */
+/** A simple model loader for fetching media over http/https using OkHttp. */
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final Call.Factory client;
@@ -29,14 +27,12 @@ public boolean handles(@NonNull GlideUrl url) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
-  /**
-   * The default factory for {@link OkHttpUrlLoader}s.
-   */
+  /** The default factory for {@link OkHttpUrlLoader}s. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
@@ -54,9 +50,7 @@ public boolean handles(@NonNull GlideUrl url) {
       return internalClient;
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton client.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton client. */
     public Factory() {
       this(getInternalClient());
     }
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
index 30bf14dcb..4f85b107a 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -7,8 +7,8 @@
 import android.widget.ListView;
 
 /**
- * Converts {@link android.support.v7.widget.RecyclerView.OnScrollListener} events to
- * {@link AbsListView} scroll events.
+ * Converts {@link android.support.v7.widget.RecyclerView.OnScrollListener} events to {@link
+ * AbsListView} scroll events.
  *
  * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
  */
@@ -53,7 +53,8 @@ public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
     int visibleCount = Math.abs(firstVisible - layoutManager.findLastVisibleItemPosition());
     int itemCount = recyclerView.getAdapter().getItemCount();
 
-    if (firstVisible != lastFirstVisible || visibleCount != lastVisibleCount
+    if (firstVisible != lastFirstVisible
+        || visibleCount != lastVisibleCount
         || itemCount != lastItemCount) {
       scrollListener.onScroll(null, firstVisible, visibleCount, itemCount);
       lastFirstVisible = firstVisible;
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 988561eac..21d83ac67 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -17,13 +17,13 @@
  * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
  * cache size.
  *
- * <p> Must be added as a listener to the {@link RecyclerView} using
- * {@link RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its
- * corresponding methods called from another
- * {@link android.support.v7.widget.RecyclerView.OnScrollListener} to function. </p>
+ * <p>Must be added as a listener to the {@link RecyclerView} using {@link
+ * RecyclerView#addOnScrollListener(RecyclerView.OnScrollListener)}, or have its corresponding
+ * methods called from another {@link android.support.v7.widget.RecyclerView.OnScrollListener} to
+ * function.
  *
- * <p> This class only works with {@link android.support.v7.widget.LinearLayoutManager} and
- * subclasses of {@link android.support.v7.widget.LinearLayoutManager}. </p>
+ * <p>This class only works with {@link android.support.v7.widget.LinearLayoutManager} and
+ * subclasses of {@link android.support.v7.widget.LinearLayoutManager}.
  *
  * @param <T> The type of the model being displayed in the {@link RecyclerView}.
  */
@@ -32,29 +32,27 @@
 
   private final RecyclerToListViewScrollListener recyclerScrollListener;
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public RecyclerViewPreloader(@NonNull Activity activity,
+  /** Helper constructor that accepts an {@link Activity}. */
+  public RecyclerViewPreloader(
+      @NonNull Activity activity,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
-      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
     this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,
+  /** Helper constructor that accepts an {@link FragmentActivity}. */
+  public RecyclerViewPreloader(
+      @NonNull FragmentActivity fragmentActivity,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
       @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public RecyclerViewPreloader(@NonNull Fragment fragment,
+  /** Helper constructor that accepts an {@link Fragment}. */
+  public RecyclerViewPreloader(
+      @NonNull Fragment fragment,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
       @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
@@ -63,11 +61,13 @@ public RecyclerViewPreloader(@NonNull Fragment fragment,
 
   /**
    * Helper constructor that accepts an {@link android.app.Fragment}.
+   *
    * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,
    * PreloadSizeProvider<T>)</code> instead.
    */
   @Deprecated
-  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,
+  public RecyclerViewPreloader(
+      @NonNull android.app.Fragment fragment,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
       @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
@@ -78,16 +78,19 @@ public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,
    * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
    * of models to preload for a given position, and the request to use to load images.
    *
-   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadModelProvider Provides models to load and requests capable of loading them.
    * @param preloadDimensionProvider Provides the dimensions of images to load.
-   * @param maxPreload               Maximum number of items to preload.
+   * @param maxPreload Maximum number of items to preload.
    */
-  public RecyclerViewPreloader(@NonNull RequestManager requestManager,
+  public RecyclerViewPreloader(
+      @NonNull RequestManager requestManager,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
-      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
 
-    ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
-        preloadDimensionProvider, maxPreload);
+    ListPreloader<T> listPreloader =
+        new ListPreloader<>(
+            requestManager, preloadModelProvider, preloadDimensionProvider, maxPreload);
     recyclerScrollListener = new RecyclerToListViewScrollListener(listPreloader);
   }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 5756c6172..e5a104c98 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -9,13 +9,13 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
- * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a Volley
+ * based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p> If you're using gradle, you can include this module simply by depending on the aar, the
- * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}.
+ * <p>If you're using gradle, you can include this module simply by depending on the aar, the module
+ * will be merged in by manifest merger. For other build systems or for more more information, see
+ * {@link com.bumptech.glide.module.GlideModule}.
  *
  * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
index 514c62008..1fc3ed877 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -11,19 +11,18 @@
 import java.io.InputStream;
 
 /**
- * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
- * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
- * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default {@link
+ * java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a Volley
+ * based {@link com.bumptech.glide.load.model.ModelLoader}.
  *
- * <p>For Applications that depend on this library and include an
- * {@link AppGlideModule} and Glide's annotation processor, this class
- * will be automatically included.
+ * <p>For Applications that depend on this library and include an {@link AppGlideModule} and Glide's
+ * annotation processor, this class will be automatically included.
  */
 @GlideModule
 public class VolleyLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
index bbc313217..6ed285b1a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -6,17 +6,16 @@
 import java.io.InputStream;
 import java.util.Map;
 
-/**
- * Used to construct a custom Volley request, such as for authentication header decoration.
- */
+/** Used to construct a custom Volley request, such as for authentication header decoration. */
 public interface VolleyRequestFactory {
 
   /**
-   * Returns a Volley request for the given image url. The given future should be put as a
-   * listener or called when the request completes.
+   * Returns a Volley request for the given image url. The given future should be put as a listener
+   * or called when the request completes.
    */
-
-  Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
-      Priority priority, Map<String, String> headers);
-
+  Request<byte[]> create(
+      String url,
+      DataCallback<? super InputStream> callback,
+      Priority priority,
+      Map<String, String> headers);
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 3137fdcdb..7f42066ee 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -17,20 +17,22 @@
 import java.util.Collections;
 import java.util.Map;
 
-/**
- * A DataFetcher backed by volley for fetching images via http.
- */
+/** A DataFetcher backed by volley for fetching images via http. */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "VolleyStreamFetcher";
-  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
-    @Override
-    public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
-        Request.Priority priority, Map<String, String> headers) {
-      return new GlideRequest(url, callback, priority, headers);
-    }
-  };
+  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY =
+      new VolleyRequestFactory() {
+        @Override
+        public Request<byte[]> create(
+            String url,
+            DataCallback<? super InputStream> callback,
+            Request.Priority priority,
+            Map<String, String> headers) {
+          return new GlideRequest(url, callback, priority, headers);
+        }
+      };
 
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
@@ -42,18 +44,19 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
     this(requestQueue, url, DEFAULT_REQUEST_FACTORY);
   }
 
-  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
-      VolleyRequestFactory requestFactory) {
+  public VolleyStreamFetcher(
+      RequestQueue requestQueue, GlideUrl url, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.url = url;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public void loadData(@NonNull Priority priority,
-      @NonNull DataCallback<? super InputStream> callback) {
-    request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
-        url.getHeaders());
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
+    request =
+        requestFactory.create(
+            url.toStringUrl(), callback, glideToVolleyPriority(priority), url.getHeaders());
     requestQueue.add(request);
   }
 
@@ -110,7 +113,10 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
       this(url, callback, priority, Collections.<String, String>emptyMap());
     }
 
-    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority,
+    public GlideRequest(
+        String url,
+        DataCallback<? super InputStream> callback,
+        Priority priority,
         Map<String, String> headers) {
       super(Method.GET, url, null);
       this.callback = callback;
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a5ceda30a..97f868e29 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -11,9 +11,7 @@
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import java.io.InputStream;
 
-/**
- * A simple model loader for fetching media over http/https using Volley.
- */
+/** A simple model loader for fetching media over http/https using Volley. */
 public class VolleyUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final RequestQueue requestQueue;
@@ -38,14 +36,12 @@ public boolean handles(@NonNull GlideUrl url) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl url, int width, int height, @NonNull Options options) {
     return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
   }
 
-  /**
-   * The default factory for {@link VolleyUrlLoader}s.
-   */
+  /** The default factory for {@link VolleyUrlLoader}s. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
@@ -54,16 +50,12 @@ public boolean handles(@NonNull GlideUrl url) {
     private final VolleyRequestFactory requestFactory;
     private final RequestQueue requestQueue;
 
-    /**
-     * Constructor for a new Factory that runs requests using a static singleton request queue.
-     */
+    /** Constructor for a new Factory that runs requests using a static singleton request queue. */
     public Factory(Context context) {
       this(getInternalQueue(context));
     }
 
-    /**
-     * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
-     */
+    /** Constructor for a new Factory that runs requests using the given {@link RequestQueue}. */
     public Factory(RequestQueue requestQueue) {
       this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
     }
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index 740acc113..dc506f696 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -42,11 +42,12 @@
 import org.robolectric.shadows.ShadowSystemClock;
 
 /**
- * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
- * responses.
+ * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server responses.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18,
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
     shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class)
 public class VolleyStreamFetcherServerTest {
   private static final String DEFAULT_PATH = "/fakepath";
@@ -92,8 +93,10 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   @Test
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -104,8 +107,10 @@ public void testHandlesRedirect301s() throws Exception {
   @Test
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(302)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -119,8 +124,10 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String expected = "redirectedData";
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -157,8 +164,10 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   @Test
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -215,9 +224,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  /**
-   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
-   */
+  /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
   @Implements(SystemClock.class)
   public static class FakeSystemClock extends ShadowSystemClock {
 
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
index 5f480de80..c70db9ceb 100644
--- a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -9,13 +9,11 @@
 /**
  * Allows {@link AppGlideModule}s to exclude {@link com.bumptech.glide.annotation.GlideModule}s to
  * ease the migration from {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation
- * processing system and optionally provides a
- * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
+ * processing system and optionally provides a {@link
+ * com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
  */
 abstract class GeneratedAppGlideModule extends AppGlideModule {
-  /**
-   * This method can be removed when manifest parsing is no longer supported.
-   */
+  /** This method can be removed when manifest parsing is no longer supported. */
   @NonNull
   abstract Set<Class<?>> getExcludedModuleClasses();
 
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index a630b4f86..e3d158d9f 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -12,8 +12,8 @@
  */
 // Public API.
 @SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public final class GenericTransitionOptions<TranscodeType> extends
-    TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+public final class GenericTransitionOptions<TranscodeType>
+    extends TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
   /**
    * Removes any existing animation put on the builder.
    *
@@ -30,8 +30,7 @@
    * @see GenericTransitionOptions#transition(int)
    */
   @NonNull
-  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
-      int viewAnimationId) {
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(int viewAnimationId) {
     return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index ce3b5eafb..a78f062e2 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -99,9 +99,9 @@
 import java.util.Set;
 
 /**
- * A singleton to present a simple static interface for building requests with
- * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
- * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
+ * A singleton to present a simple static interface for building requests with {@link
+ * RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool}, {@link
+ * com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
 public class Glide implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
@@ -120,6 +120,7 @@
   private final List<RequestManager> managers = new ArrayList<>();
   private final RequestOptionsFactory defaultRequestOptionsFactory;
   private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+
   @GuardedBy("this")
   @Nullable
   private BitmapPreFiller bitmapPreFiller;
@@ -140,7 +141,7 @@ public static File getPhotoCacheDir(@NonNull Context context) {
    * Returns a directory with the given name in the private cache directory of the application to
    * use to store retrieved media and thumbnails.
    *
-   * @param context   A context.
+   * @param context A context.
    * @param cacheName The name of the subdirectory in which to store the cache.
    * @see #getPhotoCacheDir(android.content.Context)
    */
@@ -183,8 +184,9 @@ private static void checkAndInitializeGlide(@NonNull Context context) {
     // In the thread running initGlide(), one or more classes may call Glide.get(context).
     // Without this check, those calls could trigger infinite recursion.
     if (isInitializing) {
-      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
-          + " use the provided Glide instance instead");
+      throw new IllegalStateException(
+          "You cannot call Glide.get() in registerComponents(),"
+              + " use the provided Glide instance instead");
     }
     isInitializing = true;
     initializeGlide(context);
@@ -192,10 +194,9 @@ private static void checkAndInitializeGlide(@NonNull Context context) {
   }
 
   /**
-   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
-   * Glide's generated API.
-   *
-   * <p>This method will be removed in a future version of Glide.
+   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with Glide's
+   *     generated API.
+   *     <p>This method will be removed in a future version of Glide.
    */
   @VisibleForTesting
   @Deprecated
@@ -217,9 +218,7 @@ public static synchronized void init(@NonNull Context context, @NonNull GlideBui
   @VisibleForTesting
   public static synchronized void tearDown() {
     if (glide != null) {
-      glide.getContext()
-          .getApplicationContext()
-          .unregisterComponentCallbacks(glide);
+      glide.getContext().getApplicationContext().unregisterComponentCallbacks(glide);
       glide.engine.shutdown();
     }
     glide = null;
@@ -240,8 +239,7 @@ private static void initializeGlide(@NonNull Context context, @NonNull GlideBuil
 
     if (annotationGeneratedModule != null
         && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
-      Set<Class<?>> excludedModuleClasses =
-          annotationGeneratedModule.getExcludedModuleClasses();
+      Set<Class<?>> excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();
       Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
       while (iterator.hasNext()) {
         com.bumptech.glide.module.GlideModule current = iterator.next();
@@ -263,7 +261,8 @@ private static void initializeGlide(@NonNull Context context, @NonNull GlideBuil
 
     RequestManagerRetriever.RequestManagerFactory factory =
         annotationGeneratedModule != null
-            ? annotationGeneratedModule.getRequestManagerFactory() : null;
+            ? annotationGeneratedModule.getRequestManagerFactory()
+            : null;
     builder.setRequestManagerFactory(factory);
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
@@ -280,7 +279,9 @@ private static void initializeGlide(@NonNull Context context, @NonNull GlideBuil
             "Attempting to register a Glide v3 module. If you see this, you or one of your"
                 + " dependencies may be including Glide v3 even though you're using Glide v4."
                 + " You'll need to find and remove (or update) the offending dependency."
-                + " The v3 module name is: " + module.getClass().getName(), e);
+                + " The v3 module name is: "
+                + module.getClass().getName(),
+            e);
       }
     }
     if (annotationGeneratedModule != null) {
@@ -301,12 +302,14 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
       result = clazz.getDeclaredConstructor().newInstance();
     } catch (ClassNotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
-            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
-            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
-            + " LibraryGlideModules will be silently ignored");
+        Log.w(
+            TAG,
+            "Failed to find GeneratedAppGlideModule. You should include an"
+                + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
+                + " in your application and a @GlideModule annotated AppGlideModule implementation"
+                + " or LibraryGlideModules will be silently ignored");
       }
-    // These exceptions can't be squashed across all versions of Android.
+      // These exceptions can't be squashed across all versions of Android.
     } catch (InstantiationException e) {
       throwIncorrectGlideModule(e);
     } catch (IllegalAccessException e) {
@@ -320,9 +323,11 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
   }
 
   private static void throwIncorrectGlideModule(Exception e) {
-    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
-        + " If you've manually implemented this class, remove your implementation. The Annotation"
-        + " processor will generate a correct implementation.", e);
+    throw new IllegalStateException(
+        "GeneratedAppGlideModuleImpl is implemented incorrectly."
+            + " If you've manually implemented this class, remove your implementation. The"
+            + " Annotation processor will generate a correct implementation.",
+        e);
   }
 
   Glide(
@@ -358,23 +363,17 @@ private static void throwIncorrectGlideModule(Exception e) {
 
     List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();
     Downsampler downsampler =
-        new Downsampler(
-            imageHeaderParsers,
-            resources.getDisplayMetrics(),
-            bitmapPool,
-            arrayPool);
+        new Downsampler(imageHeaderParsers, resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);
     ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
         VideoDecoder.parcel(bitmapPool);
     ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
     StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
-    ResourceDrawableDecoder resourceDrawableDecoder =
-        new ResourceDrawableDecoder(context);
+    ResourceDrawableDecoder resourceDrawableDecoder = new ResourceDrawableDecoder(context);
     ResourceLoader.StreamFactory resourceLoaderStreamFactory =
         new ResourceLoader.StreamFactory(resources);
-    ResourceLoader.UriFactory resourceLoaderUriFactory =
-        new ResourceLoader.UriFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory = new ResourceLoader.UriFactory(resources);
     ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
         new ResourceLoader.FileDescriptorFactory(resources);
     ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
@@ -403,8 +402,7 @@ private static void throwIncorrectGlideModule(Exception e) {
             Bitmap.class,
             VideoDecoder.asset(bitmapPool))
         .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
-        .append(
-            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
         .append(Bitmap.class, bitmapEncoder)
         /* BitmapDrawables */
         .append(
@@ -455,24 +453,12 @@ private static void throwIncorrectGlideModule(Exception e) {
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
         .append(int.class, InputStream.class, resourceLoaderStreamFactory)
-        .append(
-            int.class,
-            ParcelFileDescriptor.class,
-            resourceLoaderFileDescriptorFactory)
+        .append(int.class, ParcelFileDescriptor.class, resourceLoaderFileDescriptorFactory)
         .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
-        .append(
-            Integer.class,
-            ParcelFileDescriptor.class,
-            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, ParcelFileDescriptor.class, resourceLoaderFileDescriptorFactory)
         .append(Integer.class, Uri.class, resourceLoaderUriFactory)
-        .append(
-            int.class,
-            AssetFileDescriptor.class,
-            resourceLoaderAssetFileDescriptorFactory)
-        .append(
-            Integer.class,
-            AssetFileDescriptor.class,
-            resourceLoaderAssetFileDescriptorFactory)
+        .append(int.class, AssetFileDescriptor.class, resourceLoaderAssetFileDescriptorFactory)
+        .append(Integer.class, AssetFileDescriptor.class, resourceLoaderAssetFileDescriptorFactory)
         .append(int.class, Uri.class, resourceLoaderUriFactory)
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
         .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
@@ -488,14 +474,11 @@ private static void throwIncorrectGlideModule(Exception e) {
             new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
-        .append(
-            Uri.class,
-            InputStream.class,
-            new UriLoader.StreamFactory(contentResolver))
+        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory(contentResolver))
         .append(
             Uri.class,
             ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(contentResolver))
+            new UriLoader.FileDescriptorFactory(contentResolver))
         .append(
             Uri.class,
             AssetFileDescriptor.class,
@@ -510,10 +493,7 @@ private static void throwIncorrectGlideModule(Exception e) {
         .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
         .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(
-            Bitmap.class,
-            BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources))
+        .register(Bitmap.class, BitmapDrawable.class, new BitmapDrawableTranscoder(resources))
         .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
         .register(
             Drawable.class,
@@ -542,19 +522,18 @@ private static void throwIncorrectGlideModule(Exception e) {
    * temporarily store {@link android.graphics.Bitmap}s so they can be reused to avoid garbage
    * collections.
    *
-   * <p> Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
+   * <p>Note - Using this pool directly can lead to undefined behavior and strange drawing errors.
    * Any {@link android.graphics.Bitmap} added to the pool must not be currently in use in any other
    * part of the application. Any {@link android.graphics.Bitmap} added to the pool must be removed
-   * from the pool before it is added a second time. </p>
+   * from the pool before it is added a second time.
    *
-   * <p> Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
+   * <p>Note - To make effective use of the pool, any {@link android.graphics.Bitmap} removed from
    * the pool must eventually be re-added. Otherwise the pool will eventually empty and will not
-   * serve any useful purpose. </p>
+   * serve any useful purpose.
    *
-   * <p> The primary reason this object is exposed is for use in custom
-   * {@link com.bumptech.glide.load.ResourceDecoder}s and
-   * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
-   * recommended. </p>
+   * <p>The primary reason this object is exposed is for use in custom {@link
+   * com.bumptech.glide.load.ResourceDecoder}s and {@link com.bumptech.glide.load.Transformation}s.
+   * Use outside of these classes is not generally recommended.
    */
   @NonNull
   public BitmapPool getBitmapPool() {
@@ -566,9 +545,7 @@ public ArrayPool getArrayPool() {
     return arrayPool;
   }
 
-  /**
-   * @return The context associated with this instance.
-   */
+  /** @return The context associated with this instance. */
   @NonNull
   public Context getContext() {
     return glideContext.getBaseContext();
@@ -584,29 +561,24 @@ GlideContext getGlideContext() {
   }
 
   /**
-   * Pre-fills the {@link BitmapPool} using the given
-   * sizes.
+   * Pre-fills the {@link BitmapPool} using the given sizes.
    *
-   * <p> Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
+   * <p>Enough Bitmaps are added to completely fill the pool, so most or all of the Bitmaps
    * currently in the pool will be evicted. Bitmaps are allocated according to the weights of the
    * given sizes, where each size gets (weight / prefillWeightSum) percent of the pool to fill.
-   * </p>
    *
-   * <p> Note - Pre-filling is done asynchronously using and
-   * {@link IdleHandler}. Any currently running pre-fill will be cancelled
-   * and replaced by a call to this method. </p>
+   * <p>Note - Pre-filling is done asynchronously using and {@link IdleHandler}. Any currently
+   * running pre-fill will be cancelled and replaced by a call to this method.
    *
-   * <p> This method should be used with caution, overly aggressive pre-filling is substantially
+   * <p>This method should be used with caution, overly aggressive pre-filling is substantially
    * worse than not pre-filling at all. Pre-filling should only be started in onCreate to avoid
-   * constantly clearing and re-filling the
-   * {@link BitmapPool}. Rotation should be carefully
+   * constantly clearing and re-filling the {@link BitmapPool}. Rotation should be carefully
    * considered as well. It may be worth calling this method only when no saved instance state
    * exists so that pre-filling only happens when the Activity is first created, rather than on
-   * every rotation. </p>
+   * every rotation.
    *
-   * @param bitmapAttributeBuilders The list of
-   * {@link Builder Builders} representing
-   * individual sizes and configurations of {@link Bitmap}s to be pre-filled.
+   * @param bitmapAttributeBuilders The list of {@link Builder Builders} representing individual
+   *     sizes and configurations of {@link Bitmap}s to be pre-filled.
    */
   @SuppressWarnings("unused") // Public API
   public synchronized void preFillBitmapPool(
@@ -652,9 +624,7 @@ public void trimMemory(int level) {
   /**
    * Clears disk cache.
    *
-   * <p>
-   *     This method should always be called on a background thread, since it is a blocking call.
-   * </p>
+   * <p>This method should always be called on a background thread, since it is a blocking call.
    */
   // Public API.
   @SuppressWarnings({"unused", "WeakerAccess"})
@@ -663,9 +633,7 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
-  /**
-   * Internal method.
-   */
+  /** Internal method. */
   @NonNull
   public RequestManagerRetriever getRequestManagerRetriever() {
     return requestManagerRetriever;
@@ -674,12 +642,12 @@ public RequestManagerRetriever getRequestManagerRetriever() {
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
-   * <p> The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}.
-   * {@link MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and
-   * {@link MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be
-   * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
-   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
-   * to change the default. </p>
+   * <p>The default {@link MemoryCategory} is {@link MemoryCategory#NORMAL}. {@link
+   * MemoryCategory#HIGH} increases Glide's maximum memory usage by up to 50% and {@link
+   * MemoryCategory#LOW} decreases Glide's maximum memory usage by 50%. This method should be used
+   * to temporarily increase or decrease memory usage for a single Activity or part of the app. Use
+   * {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want to
+   * change the default.
    *
    * @return the previous MemoryCategory used by Glide.
    */
@@ -711,17 +679,17 @@ private static RequestManagerRetriever getRetriever(@Nullable Context context) {
   /**
    * Begin a load with Glide by passing in a context.
    *
-   * <p> Any requests started using a context will only have the application level options applied
+   * <p>Any requests started using a context will only have the application level options applied
    * and will not be started or stopped based on lifecycle events. In general, loads should be
    * started at the level the result will be used in. If the resource will be used in a view in a
    * child fragment, the load should be started with {@link #with(android.app.Fragment)}} using that
    * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
    * load should be started with {@link #with(android.app.Fragment)} using the parent fragment. In
    * the same vein, if the resource will be used in a view in an activity, the load should be
-   * started with {@link #with(android.app.Activity)}}. </p>
+   * started with {@link #with(android.app.Activity)}}.
    *
-   * <p> This method is appropriate for resources that will be used outside of the normal fragment
-   * or activity lifecycle (For example in services, or for notification thumbnails). </p>
+   * <p>This method is appropriate for resources that will be used outside of the normal fragment or
+   * activity lifecycle (For example in services, or for notification thumbnails).
    *
    * @param context Any context, will not be retained.
    * @return A RequestManager for the top level application that can be used to start a load.
@@ -748,9 +716,9 @@ public static RequestManager with(@NonNull Activity activity) {
   }
 
   /**
-   * Begin a load with Glide that will tied to the give
-   * {@link android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.FragmentActivity}'s default options.
+   * Begin a load with Glide that will tied to the give {@link
+   * android.support.v4.app.FragmentActivity}'s lifecycle and that uses the given {@link
+   * android.support.v4.app.FragmentActivity}'s default options.
    *
    * @param activity The activity to use.
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
@@ -761,9 +729,9 @@ public static RequestManager with(@NonNull FragmentActivity activity) {
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given
-   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given {@link
+   * android.support.v4.app.Fragment}'s lifecycle and that uses the given {@link
+   * android.support.v4.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
@@ -779,9 +747,9 @@ public static RequestManager with(@NonNull Fragment fragment) {
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
-   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,
-   * {@link android.app.Fragment} will be deprecated. See
-   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555.
+   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead, {@link
+   *     android.app.Fragment} will be deprecated. See
+   *     https://github.com/android/android-ktx/pull/161#issuecomment-363270555.
    */
   @SuppressWarnings("deprecation")
   @Deprecated
@@ -791,8 +759,8 @@ public static RequestManager with(@NonNull android.app.Fragment fragment) {
   }
 
   /**
-   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
-   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment}, {@link
+   * android.app.Fragment}, or {@link Activity} that contains the View.
    *
    * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
    * is a child of the View returned by the {@link Fragment#getView()}} method.
@@ -809,8 +777,8 @@ public static RequestManager with(@NonNull android.app.Fragment fragment) {
    * avoiding entirely or using the {@link Fragment}s from the support library instead.
    *
    * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
-   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
-   * to the {@link FragmentActivity} will be ignored.
+   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached to
+   * the {@link FragmentActivity} will be ignored.
    *
    * @param view The view to search for a containing Fragment or Activity from.
    * @return A RequestManager that can be used to start a load.
@@ -870,14 +838,10 @@ public void onLowMemory() {
     clearMemory();
   }
 
-  /**
-   * Creates a new instance of {@link RequestOptions}.
-   */
+  /** Creates a new instance of {@link RequestOptions}. */
   public interface RequestOptionsFactory {
 
-    /**
-     * Returns a non-null {@link RequestOptions} object.
-     */
+    /** Returns a non-null {@link RequestOptions} object. */
     @NonNull
     RequestOptions build();
   }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index d1c5d8816..ebebf1e40 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -35,9 +35,7 @@
 import java.util.List;
 import java.util.Map;
 
-/**
- * A builder class for setting default structural classes for Glide to use.
- */
+/** A builder class for setting default structural classes for Glide to use. */
 public final class GlideBuilder {
   private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
@@ -50,19 +48,18 @@
   private MemorySizeCalculator memorySizeCalculator;
   private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
-  private RequestOptionsFactory defaultRequestOptionsFactory = new RequestOptionsFactory() {
-    @NonNull
-    @Override
-    public RequestOptions build() {
-      return new RequestOptions();
-    }
-  };
-  @Nullable
-  private RequestManagerFactory requestManagerFactory;
+  private RequestOptionsFactory defaultRequestOptionsFactory =
+      new RequestOptionsFactory() {
+        @NonNull
+        @Override
+        public RequestOptions build() {
+          return new RequestOptions();
+        }
+      };
+  @Nullable private RequestManagerFactory requestManagerFactory;
   private GlideExecutor animationExecutor;
   private boolean isActiveResourceRetentionAllowed;
-  @Nullable
-  private List<RequestListener<Object>> defaultRequestListeners;
+  @Nullable private List<RequestListener<Object>> defaultRequestListeners;
   private boolean isLoggingRequestOriginsEnabled;
 
   /**
@@ -79,8 +76,8 @@ public GlideBuilder setBitmapPool(@Nullable BitmapPool bitmapPool) {
   }
 
   /**
-   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
-   * and retrieved as needed.
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored and
+   * retrieved as needed.
    *
    * @param arrayPool The pool to use.
    * @return This builder.
@@ -123,8 +120,8 @@ public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
   }
 
   /**
-   * Sets the {@link GlideExecutor} to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
    * <p>The thread count defaults to the number of cores available on the device, with a maximum of
    * 4.
@@ -136,7 +133,6 @@ public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
-   *
    * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
    */
   @Deprecated
@@ -145,8 +141,8 @@ public GlideBuilder setResizeExecutor(@Nullable GlideExecutor service) {
   }
 
   /**
-   * Sets the {@link GlideExecutor} to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
    * <p>The thread count defaults to the number of cores available on the device, with a maximum of
    * 4.
@@ -168,14 +164,14 @@ public GlideBuilder setSourceExecutor(@Nullable GlideExecutor service) {
   }
 
   /**
-   * Sets the {@link GlideExecutor} to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
+   * Sets the {@link GlideExecutor} to use when retrieving {@link
+   * com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p>Defaults to a single thread which is usually the best combination of memory usage,
-   * jank, and performance, even on high end devices.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage, jank, and
+   * performance, even on high end devices.
    *
-   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options
-   * for the disk cache executor.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options for
+   * the disk cache executor.
    *
    * @param service The {@link GlideExecutor} to use.
    * @return This builder.
@@ -196,7 +192,7 @@ public GlideBuilder setDiskCacheExecutor(@Nullable GlideExecutor service) {
    *
    * <p>Defaults to one or two threads, depending on the number of cores available.
    *
-   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods if you'd like to specify
    * options for the animation executor.
    *
    * @param service The {@link GlideExecutor} to use.
@@ -213,24 +209,23 @@ public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
-   * <p>Applying additional options with {@link
-   * RequestBuilder#apply(BaseRequestOptions)} will override defaults
-   * set here.
+   * <p>Applying additional options with {@link RequestBuilder#apply(BaseRequestOptions)} will
+   * override defaults set here.
    *
    * @see #setDefaultRequestOptions(RequestOptionsFactory)
-   *
    * @param requestOptions The options to use by default.
    * @return This builder.
    */
   @NonNull
   public GlideBuilder setDefaultRequestOptions(@Nullable final RequestOptions requestOptions) {
-    return setDefaultRequestOptions(new RequestOptionsFactory() {
-      @NonNull
-      @Override
-      public RequestOptions build() {
-        return requestOptions != null ? requestOptions : new RequestOptions();
-      }
-    });
+    return setDefaultRequestOptions(
+        new RequestOptionsFactory() {
+          @NonNull
+          @Override
+          public RequestOptions build() {
+            return requestOptions != null ? requestOptions : new RequestOptions();
+          }
+        });
   }
 
   /**
@@ -238,8 +233,8 @@ public RequestOptions build() {
    * returns this {@code GlideBuilder}.
    *
    * <p>This factory will <em>NOT</em> be called once per load. Instead it will be called a handful
-   * of times and memoized. It's not safe to assume that this factory will be called again for
-   * every new load.
+   * of times and memoized. It's not safe to assume that this factory will be called again for every
+   * new load.
    *
    * <p>Applying additional options with {@link RequestBuilder#apply(BaseRequestOptions)} will
    * override defaults set here.
@@ -258,15 +253,15 @@ public GlideBuilder setDefaultRequestOptions(@NonNull RequestOptionsFactory fact
    *
    * <p>It's preferable but not required for the requested resource class to match the resource
    * class applied here as long as the resource class applied here is assignable from the requested
-   * resource class. For example you can set a default transition for
-   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you
+   * resource class. For example you can set a default transition for {@link
+   * android.graphics.drawable.Drawable} and that default transition will be used if you
    * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or
-   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
-   * register a default transition for both {@link android.graphics.drawable.Drawable} and
-   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for
-   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
-   * {@link android.graphics.drawable.BitmapDrawable}s will be used.
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or {@link
+   * android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
+   * register a default transition for both {@link android.graphics.drawable.Drawable} and {@link
+   * android.graphics.drawable.BitmapDrawable} and then start a request for {@link
+   * android.graphics.drawable.BitmapDrawable}s, the transition you registered for {@link
+   * android.graphics.drawable.BitmapDrawable}s will be used.
    */
   // Public API.
   @SuppressWarnings("unused")
@@ -278,11 +273,10 @@ public GlideBuilder setDefaultRequestOptions(@NonNull RequestOptionsFactory fact
   }
 
   /**
-   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
-   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default {@link
+   * MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
    *
    * @see #setMemorySizeCalculator(MemorySizeCalculator)
-   *
    * @param builder The builder to use (will not be modified).
    * @return This builder.
    */
@@ -294,11 +288,11 @@ public GlideBuilder setMemorySizeCalculator(@NonNull MemorySizeCalculator.Builde
   }
 
   /**
-   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default
-   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
+   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default {@link
+   * MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}.
    *
-   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided
-   * via {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}.
+   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided via
+   * {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}.
    *
    * @param calculator The calculator to use.
    * @return This builder.
@@ -312,9 +306,9 @@ public GlideBuilder setMemorySizeCalculator(@Nullable MemorySizeCalculator calcu
   }
 
   /**
-   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
-   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
-   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory} to use to notify {@link
+   * com.bumptech.glide.RequestManager} of connectivity events. If not set {@link
+   * com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
    *
    * @param factory The factory to use
    * @return This builder.
@@ -330,16 +324,16 @@ public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorF
   /**
    * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
    *
-   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},
-   * {@link Log#WARN}, or {@link Log#ERROR}.
+   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO}, {@link
+   * Log#WARN}, or {@link Log#ERROR}.
    *
-   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including
-   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged
-   * per successful request, including timing logs, although many lines may be logged for
-   * failures including multiple complete stack traces. {@link Log#INFO} means
-   * failed loads will be logged including multiple complete stack traces, but successful loads
-   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be
-   * logged. {@link Log#ERROR} means only exceptional cases will be logged.
+   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including timing
+   * logs and failures. {@link Log#DEBUG} means at most one line will be logged per successful
+   * request, including timing logs, although many lines may be logged for failures including
+   * multiple complete stack traces. {@link Log#INFO} means failed loads will be logged including
+   * multiple complete stack traces, but successful loads will not be logged at all. {@link
+   * Log#WARN} means only summaries of failed loads will be logged. {@link Log#ERROR} means only
+   * exceptional cases will be logged.
    *
    * <p>All logs will be logged using the 'Glide' tag.
    *
@@ -357,53 +351,52 @@ public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorF
   @NonNull
   public GlideBuilder setLogLevel(int logLevel) {
     if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
-      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
-          + " Log.INFO, Log.WARN, or Log.ERROR");
+      throw new IllegalArgumentException(
+          "Log level must be one of Log.VERBOSE, Log.DEBUG," + " Log.INFO, Log.WARN, or Log.ERROR");
     }
     this.logLevel = logLevel;
     return this;
   }
 
   /**
-   * If set to {@code true}, allows Glide to re-capture resources that are loaded into
-   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and
-   * garbage collected without being cleared.
+   * If set to {@code true}, allows Glide to re-capture resources that are loaded into {@link
+   * com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and garbage
+   * collected without being cleared.
    *
    * <p>Defaults to {@code false}.
    *
    * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to
    * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the
-   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses
-   * {@link java.lang.ref.WeakReference}s to track resources that belong to
-   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting
-   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying
-   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,
-   * Glide can return the underlying resource to it's memory cache so that subsequent requests will
-   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take
-   * the system slightly longer to garbage collect the underlying resource because the weak
-   * reference has to be cleared and processed before the hard reference is removed. As a result,
-   * setting this method to {@code true} may transiently increase the memory usage of an
-   * application.
+   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses {@link
+   * java.lang.ref.WeakReference}s to track resources that belong to {@link
+   * com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting this method
+   * to {@code true} allows Glide to also maintain a hard reference to the underlying resource so
+   * that if the {@link com.bumptech.glide.request.target.Target} is garbage collected, Glide can
+   * return the underlying resource to it's memory cache so that subsequent requests will not
+   * unexpectedly re-load the resource from disk or source. As a side affect, it will take the
+   * system slightly longer to garbage collect the underlying resource because the weak reference
+   * has to be cleared and processed before the hard reference is removed. As a result, setting this
+   * method to {@code true} may transiently increase the memory usage of an application.
    *
    * <p>Leaving this method at the default {@code false} value will allow the platform to garbage
    * collect resources more quickly, but will lead to unexpected memory cache misses if callers load
    * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them.
    *
-   * <p>If you set this method to {@code true} you <em>must not</em> call
-   * {@link Bitmap#recycle()} or mutate any Bitmaps returned by Glide. If this method is set to
-   * {@code false}, recycling or mutating Bitmaps is inefficient but safe as long as you do not
-   * clear the corresponding {@link com.bumptech.glide.request.target.Target} used to load the
-   * {@link Bitmap}. However, if you set this method to {@code true} and recycle or mutate any
-   * returned {@link Bitmap}s or other mutable resources, Glide may recover those resources and
-   * attempt to use them later on, resulting in crashes, graphical corruption or undefined behavior.
-   *
-   * <p>Regardless of what value this method is set to, it's always good practice to clear
-   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding
-   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize
-   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from
-   * edge cases. If you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()}
-   * or mutating {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be
-   * avoided. In all cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
+   * <p>If you set this method to {@code true} you <em>must not</em> call {@link Bitmap#recycle()}
+   * or mutate any Bitmaps returned by Glide. If this method is set to {@code false}, recycling or
+   * mutating Bitmaps is inefficient but safe as long as you do not clear the corresponding {@link
+   * com.bumptech.glide.request.target.Target} used to load the {@link Bitmap}. However, if you set
+   * this method to {@code true} and recycle or mutate any returned {@link Bitmap}s or other mutable
+   * resources, Glide may recover those resources and attempt to use them later on, resulting in
+   * crashes, graphical corruption or undefined behavior.
+   *
+   * <p>Regardless of what value this method is set to, it's always good practice to clear {@link
+   * com.bumptech.glide.request.target.Target}s when you're done with the corresponding resource.
+   * Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize resource
+   * re-use, minimize memory overhead and minimize unexpected behavior resulting from edge cases. If
+   * you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()} or mutating
+   * {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be avoided. In all
+   * cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
    *
    * @return This builder.
    */
@@ -419,19 +412,18 @@ public GlideBuilder setIsActiveResourceRetentionAllowed(
   /**
    * Adds a global {@link RequestListener} that will be added to every request started with Glide.
    *
-   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or
-   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
-   * added. Even if an earlier {@link RequestListener} returns {@code true} from
-   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will
-   * not prevent subsequent {@link RequestListener}s from being called.
+   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or to
+   * individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're
+   * added. Even if an earlier {@link RequestListener} returns {@code true} from {@link
+   * RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will not
+   * prevent subsequent {@link RequestListener}s from being called.
    *
    * <p>Because Glide requests can be started for any number of individual resource types, any
-   * listener added here has to accept any generic resource type in
-   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you
-   * must base the behavior of the listener on the resource type, you will need to use
-   * {@code instanceof} to do so. It's not safe to cast resource types without first checking
-   * with {@code instanceof}.
+   * listener added here has to accept any generic resource type in {@link
+   * RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you must base
+   * the behavior of the listener on the resource type, you will need to use {@code instanceof} to
+   * do so. It's not safe to cast resource types without first checking with {@code instanceof}.
    */
   @NonNull
   public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> listener) {
@@ -443,12 +435,12 @@ public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> li
   }
 
   /**
-   * Set to {@code true} to make Glide populate
-   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   * Set to {@code true} to make Glide populate {@link
+   * com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
    *
    * <p>The exception set by this method is not printed by {@link GlideException} and can only be
-   * viewed via a {@link RequestListener} that reads the field via
-   * {@link GlideException#getOrigin()}.
+   * viewed via a {@link RequestListener} that reads the field via {@link
+   * GlideException#getOrigin()}.
    *
    * <p>This is an experimental API that may be removed in the future.
    */
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index b6c580555..b83506ce9 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -26,6 +26,7 @@
   @VisibleForTesting
   static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
       new GenericTransitionOptions<>();
+
   private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
@@ -35,6 +36,7 @@
   private final Engine engine;
   private final boolean isLoggingRequestOriginsEnabled;
   private final int logLevel;
+
   @Nullable
   @GuardedBy("this")
   private RequestOptions defaultRequestOptions;
@@ -117,8 +119,8 @@ public ArrayPool getArrayPool() {
   }
 
   /**
-   * Returns {@code true} if Glide should populate
-   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
+   * Returns {@code true} if Glide should populate {@link
+   * com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests.
    *
    * <p>This is an experimental API that may be removed in the future.
    */
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index f0ce095c2..0be155f21 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -19,10 +19,10 @@
  * the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and
  * cache size.
  *
- * <p> Must be put using
- * {@link AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
+ * <p>Must be put using {@link
+ * AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)}, or have its
  * corresponding methods called from another {@link android.widget.AbsListView.OnScrollListener} to
- * function. </p>
+ * function.
  *
  * @param <T> The type of the model being displayed in the list.
  */
@@ -68,15 +68,15 @@
     List<U> getPreloadItems(int position);
 
     /**
-     * Returns a {@link RequestBuilder} for a given item on which
-     * {@link RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
+     * Returns a {@link RequestBuilder} for a given item on which {@link
+     * RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
      * started.
      *
      * <p>For the preloader to be effective, the {@link RequestBuilder} returned here must use
      * exactly the same size and set of options as the {@link RequestBuilder} used when the ``View``
      * is bound. You may need to specify a size in both places to ensure that the width and height
-     * match exactly. If so, you can use
-     * {@link com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
+     * match exactly. If so, you can use {@link
+     * com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
      *
      * <p>The target and context will be provided by the preloader.
      *
@@ -117,13 +117,15 @@
    * the dimensions of images to preload, the list of models to preload for a given position, and
    * the request to use to load images.
    *
-   * @param preloadModelProvider     Provides models to load and requests capable of loading them.
+   * @param preloadModelProvider Provides models to load and requests capable of loading them.
    * @param preloadDimensionProvider Provides the dimensions of images to load.
-   * @param maxPreload               Maximum number of items to preload.
+   * @param maxPreload Maximum number of items to preload.
    */
-  public ListPreloader(@NonNull RequestManager requestManager,
+  public ListPreloader(
+      @NonNull RequestManager requestManager,
       @NonNull PreloadModelProvider<T> preloadModelProvider,
-      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
+      int maxPreload) {
     this.requestManager = requestManager;
     this.preloadModelProvider = preloadModelProvider;
     this.preloadDimensionProvider = preloadDimensionProvider;
@@ -137,8 +139,8 @@ public void onScrollStateChanged(AbsListView absListView, int scrollState) {
   }
 
   @Override
-  public void onScroll(AbsListView absListView, int firstVisible, int visibleCount,
-      int totalCount) {
+  public void onScroll(
+      AbsListView absListView, int firstVisible, int visibleCount, int totalCount) {
     totalItemCount = totalCount;
     if (firstVisible > lastFirstVisible) {
       preload(firstVisible + visibleCount, true);
@@ -203,8 +205,7 @@ private void preloadItem(@Nullable T item, int position, int perItemPosition) {
     if (item == null) {
       return;
     }
-    int[] dimensions =
-        preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
+    int[] dimensions = preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
     if (dimensions == null) {
       return;
     }
@@ -248,11 +249,10 @@ public PreloadTarget next(int width, int height) {
   private static final class PreloadTarget implements Target<Object> {
     @Synthetic int photoHeight;
     @Synthetic int photoWidth;
-    @Nullable
-    private Request request;
+    @Nullable private Request request;
 
     @Synthetic
-    PreloadTarget() { }
+    PreloadTarget() {}
 
     @Override
     public void onLoadStarted(@Nullable Drawable placeholder) {
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index af84e0454..0e7107205 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -1,16 +1,12 @@
 package com.bumptech.glide;
 
-/**
- * An enum for dynamically modifying the amount of memory Glide is able to use.
- */
+/** An enum for dynamically modifying the amount of memory Glide is able to use. */
 public enum MemoryCategory {
   /**
    * Tells Glide's memory cache and bitmap pool to use at most half of their initial maximum size.
    */
   LOW(0.5f),
-  /**
-   * Tells Glide's memory cache and bitmap pool to use at most their initial maximum size.
-   */
+  /** Tells Glide's memory cache and bitmap pool to use at most their initial maximum size. */
   NORMAL(1f),
   /**
    * Tells Glide's memory cache and bitmap pool to use at most one and a half times their initial
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
index 42a14053e..701722beb 100644
--- a/library/src/main/java/com/bumptech/glide/ModelTypes.java
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -12,8 +12,8 @@
 import java.net.URL;
 
 /**
- * Ensures that the set of explicitly supported model types remains consistent across Glide's
- * API surface.
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's API
+ * surface.
  */
 interface ModelTypes<T> {
   @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index c5903fcf2..f442bf527 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -73,15 +73,15 @@ public Registry() {
    *
    * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
    * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
-   * {@link Encoder} being used for
-   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
-   * {@link java.io.FileInputStream} and any other subclass.
+   * {@link Encoder} being used for {@link
+   * android.content.res.AssetFileDescriptor.AutoCloseInputStream}, {@link java.io.FileInputStream}
+   * and any other subclass.
    *
-   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
-   * {@link Encoder} that is registered first will be used.
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the {@link
+   * Encoder} that is registered first will be used.
    *
    * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
-   * instead.
+   *     instead.
    */
   @NonNull
   @Deprecated
@@ -95,12 +95,12 @@ public Registry() {
    *
    * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
    * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
-   * {@link Encoder} being used for
-   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
-   * {@link java.io.FileInputStream} and any other subclass.
+   * {@link Encoder} being used for {@link
+   * android.content.res.AssetFileDescriptor.AutoCloseInputStream}, {@link java.io.FileInputStream}
+   * and any other subclass.
    *
-   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
-   * {@link Encoder} that is registered first will be used.
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the {@link
+   * Encoder} that is registered first will be used.
    *
    * @see #prepend(Class, Encoder)
    */
@@ -111,13 +111,12 @@ public Registry() {
   }
 
   /**
-   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
-   * so that it is attempted before all later and default {@link Encoder}s for the given
-   * data class.
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s so that it is
+   * attempted before all later and default {@link Encoder}s for the given data class.
    *
-   * <p>This method allows you to replace the default {@link Encoder} because it ensures
-   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
-   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures the
+   * registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for the
+   * same type or super type, the {@link Encoder} that is registered first will be used.
    *
    * @see #append(Class, Encoder)
    */
@@ -128,23 +127,22 @@ public Registry() {
   }
 
   /**
-   * Appends the given {@link ResourceDecoder} onto the list of all available
-   * {@link ResourceDecoder}s allowing it to be used if all earlier and default
-   * {@link ResourceDecoder}s for the given types fail (or there are none).
+   * Appends the given {@link ResourceDecoder} onto the list of all available {@link
+   * ResourceDecoder}s allowing it to be used if all earlier and default {@link ResourceDecoder}s
+   * for the given types fail (or there are none).
    *
    * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
-   * that your {@link ResourceDecoder} gets the chance to run before an existing
-   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
-   * best for new types of resources and data or as a way to add an additional fallback decoder
-   * for an existing type of data.
+   * that your {@link ResourceDecoder} gets the chance to run before an existing {@link
+   * ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is best for
+   * new types of resources and data or as a way to add an additional fallback decoder for an
+   * existing type of data.
    *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #prepend(Class, Class, ResourceDecoder)
-   *
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
   @NonNull
@@ -162,19 +160,18 @@ public Registry() {
    * the given types in this bucket fail (or there are none).
    *
    * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
-   * that your {@link ResourceDecoder} gets the chance to run before an existing
-   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
-   * best for new types of resources and data or as a way to add an additional fallback decoder
-   * for an existing type of data.
+   * that your {@link ResourceDecoder} gets the chance to run before an existing {@link
+   * ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is best for
+   * new types of resources and data or as a way to add an additional fallback decoder for an
+   * existing type of data.
    *
    * @see #prepend(String, Class, Class, ResourceDecoder)
    * @see #setResourceDecoderBucketPriorityList(List)
-   *
    * @param bucket The bucket identifier to add this decoder to.
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
   @NonNull
@@ -188,23 +185,21 @@ public Registry() {
   }
 
   /**
-   * Prepends the given {@link ResourceDecoder} into the list of all available
-   * {@link ResourceDecoder}s so that it is attempted before all later and default
-   * {@link ResourceDecoder}s for the given types.
+   * Prepends the given {@link ResourceDecoder} into the list of all available {@link
+   * ResourceDecoder}s so that it is attempted before all later and default {@link ResourceDecoder}s
+   * for the given types.
    *
-   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures
-   * the registered {@link ResourceDecoder} will run first. You can use the
-   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
-   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
-   * types of data.
+   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures the
+   * registered {@link ResourceDecoder} will run first. You can use the {@link
+   * ResourceDecoder#handles(Object, Options)} to fall back to the default {@link ResourceDecoder}s
+   * if you only want to change the default functionality for certain types of data.
    *
    * @see #prepend(String, Class, Class, ResourceDecoder)
    * @see #append(Class, Class, ResourceDecoder)
-   *
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
   @NonNull
@@ -218,23 +213,22 @@ public Registry() {
 
   /**
    * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s
-   * in the same bucket so that it is attempted before all later and default
-   * {@link ResourceDecoder}s for the given types in that bucket.
+   * in the same bucket so that it is attempted before all later and default {@link
+   * ResourceDecoder}s for the given types in that bucket.
    *
    * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket
    * because it ensures the registered {@link ResourceDecoder} will run first. You can use the
-   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
-   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
-   * types of data.
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default {@link
+   * ResourceDecoder}s if you only want to change the default functionality for certain types of
+   * data.
    *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #setResourceDecoderBucketPriorityList(List)
-   *
    * @param bucket The bucket identifier to add this decoder to.
-   * @param dataClass The data that will be decoded from
-   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param dataClass The data that will be decoded from ({@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor} etc).
    * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   *     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
    * @param decoder The {@link ResourceDecoder} to register.
    */
   @NonNull
@@ -252,14 +246,14 @@ public Registry() {
    * which are identified as a unique string. Glide will attempt to decode using decoders in the
    * highest priority bucket before moving on to the next one.
    *
-   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP},
-   * {@link #BUCKET_BITMAP_DRAWABLE}].
+   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP}, {@link
+   * #BUCKET_BITMAP_DRAWABLE}].
    *
    * <p>When registering decoders, you can use these buckets to specify the ordering relative only
    * to other decoders in that bucket.
+   *
    * @see #append(String, Class, Class, ResourceDecoder)
    * @see #prepend(String, Class, Class, ResourceDecoder)
-   *
    * @param buckets The list of bucket identifiers in order from highest priority to least priority.
    */
   // Final to avoid a PMD error.
@@ -280,10 +274,10 @@ public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String>
    * data type.
    *
    * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
-   * For example, registering an {@link ResourceEncoder} for
-   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
-   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   * For example, registering an {@link ResourceEncoder} for {@link
+   * android.graphics.drawable.Drawable} (not recommended) will result in the {@link
+   * ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
    *
    * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
    * {@link ResourceEncoder} that is registered first will be used.
@@ -303,10 +297,10 @@ public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String>
    * data type.
    *
    * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
-   * For example, registering an {@link ResourceEncoder} for
-   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
-   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   * For example, registering an {@link ResourceEncoder} for {@link
+   * android.graphics.drawable.Drawable} (not recommended) will result in the {@link
+   * ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
    *
    * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
    * {@link ResourceEncoder} that is registered first will be used.
@@ -325,8 +319,8 @@ public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String>
    * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
    * data type.
    *
-   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
-   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures the
+   * registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
    * registered for the same type or super type, the {@link ResourceEncoder} that is registered
    * first will be used.
    *
@@ -353,15 +347,16 @@ public Registry register(@NonNull DataRewinder.Factory<?> factory) {
    * Registers the given {@link ResourceTranscoder} to convert from the given resource {@link Class}
    * to the given transcode {@link Class}.
    *
-   * @param resourceClass The class that will be transcoded from (e.g.
-   * {@link android.graphics.Bitmap}).
-   * @param transcodeClass The class that will be transcoded to (e.g.
-   * {@link android.graphics.drawable.BitmapDrawable}).
+   * @param resourceClass The class that will be transcoded from (e.g. {@link
+   *     android.graphics.Bitmap}).
+   * @param transcodeClass The class that will be transcoded to (e.g. {@link
+   *     android.graphics.drawable.BitmapDrawable}).
    * @param transcoder The {@link ResourceTranscoder} to register.
    */
   @NonNull
   public <TResource, Transcode> Registry register(
-      @NonNull Class<TResource> resourceClass, @NonNull Class<Transcode> transcodeClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass,
       @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
@@ -382,26 +377,25 @@ public Registry register(@NonNull ImageHeaderParser parser) {
    * constructed {@link ModelLoader} will be tried after all default and previously registered
    * {@link ModelLoader}s for the given model and data classes.
    *
-   * <p>If you're attempting to replace an existing {@link ModelLoader}, use
-   * {@link #prepend(Class, Class, ModelLoaderFactory)}. This method is best for new types of models
-   * and/or data or as a way to add an additional fallback loader for an existing type of
-   * model/data.
+   * <p>If you're attempting to replace an existing {@link ModelLoader}, use {@link #prepend(Class,
+   * Class, ModelLoaderFactory)}. This method is best for new types of models and/or data or as a
+   * way to add an additional fallback loader for an existing type of model/data.
    *
    * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
-   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
-   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
-   * entire request fail.
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the {@link
+   * ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the entire
+   * request fail.
    *
    * @see #prepend(Class, Class, ModelLoaderFactory)
    * @see #replace(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
   @NonNull
   public <Model, Data> Registry append(
-      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
       @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.append(modelClass, dataClass, factory);
     return this;
@@ -413,26 +407,26 @@ public Registry register(@NonNull ImageHeaderParser parser) {
    * {@link ModelLoader}s for the given model and data classes.
    *
    * <p>If you're attempting to add additional functionality or add a backup that should run only
-   * after the default {@link ModelLoader}s run, use
-   * {@link #append(Class, Class, ModelLoaderFactory)}. This method is best for adding an additional
-   * case to Glide's existing functionality that should run first. This method will still run
-   * Glide's default {@link ModelLoader}s if the prepended {@link ModelLoader}s fail.
+   * after the default {@link ModelLoader}s run, use {@link #append(Class, Class,
+   * ModelLoaderFactory)}. This method is best for adding an additional case to Glide's existing
+   * functionality that should run first. This method will still run Glide's default {@link
+   * ModelLoader}s if the prepended {@link ModelLoader}s fail.
    *
    * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
-   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
-   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
-   * entire request fail.
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the {@link
+   * ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the entire
+   * request fail.
    *
    * @see #append(Class, Class, ModelLoaderFactory)
    * @see #replace(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
   @NonNull
   public <Model, Data> Registry prepend(
-      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
       @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
@@ -443,23 +437,21 @@ public Registry register(@NonNull ImageHeaderParser parser) {
    * and model class and replaces all of them with the single {@link ModelLoader} provided.
    *
    * <p>If you're attempting to add additional functionality or add a backup that should run only
-   * after the default {@link ModelLoader}s run, use
-   * {@link #append(Class, Class, ModelLoaderFactory)}. This method should be used only when you
-   * want to ensure that Glide's default {@link ModelLoader}s do not run.
+   * after the default {@link ModelLoader}s run, use {@link #append(Class, Class,
+   * ModelLoaderFactory)}. This method should be used only when you want to ensure that Glide's
+   * default {@link ModelLoader}s do not run.
    *
    * <p>One good use case for this method is when you want to replace Glide's default networking
-   * library with your OkHttp, Volley, or your own implementation. Using
-   * {@link #prepend(Class, Class, ModelLoaderFactory)} or
-   * {@link #append(Class, Class, ModelLoaderFactory)} may still allow Glide's default networking
-   * library to run in some cases. Using this method will ensure that only your networking library
-   * will run and that the request will fail otherwise.
+   * library with your OkHttp, Volley, or your own implementation. Using {@link #prepend(Class,
+   * Class, ModelLoaderFactory)} or {@link #append(Class, Class, ModelLoaderFactory)} may still
+   * allow Glide's default networking library to run in some cases. Using this method will ensure
+   * that only your networking library will run and that the request will fail otherwise.
    *
    * @see #prepend(Class, Class, ModelLoaderFactory)
    * @see #append(Class, Class, ModelLoaderFactory)
-   *
    * @param modelClass The model class (e.g. URL, file path).
-   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
-   * {@link java.io.FileDescriptor}).
+   * @param dataClass the data class (e.g. {@link java.io.InputStream}, {@link
+   *     java.io.FileDescriptor}).
    */
   @NonNull
   public <Model, Data> Registry replace(
@@ -472,7 +464,8 @@ public Registry register(@NonNull ImageHeaderParser parser) {
 
   @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
-      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
       @NonNull Class<Transcode> transcodeClass) {
     LoadPath<Data, TResource, Transcode> result =
         loadPathCache.get(dataClass, resourceClass, transcodeClass);
@@ -497,7 +490,8 @@ public Registry register(@NonNull ImageHeaderParser parser) {
 
   @NonNull
   private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
-      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
       @NonNull Class<Transcode> transcodeClass) {
     List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
     List<Class<TResource>> registeredResourceClasses =
@@ -515,8 +509,13 @@ public Registry register(@NonNull ImageHeaderParser parser) {
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
         @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
         DecodePath<Data, TResource, Transcode> path =
-            new DecodePath<>(dataClass, registeredResourceClass, registeredTranscodeClass,
-                decoders, transcoder, throwableListPool);
+            new DecodePath<>(
+                dataClass,
+                registeredResourceClass,
+                registeredTranscodeClass,
+                decoders,
+                transcoder,
+                throwableListPool);
         decodePaths.add(path);
       }
     }
@@ -538,8 +537,8 @@ public Registry register(@NonNull ImageHeaderParser parser) {
         List<? extends Class<?>> registeredResourceClasses =
             decoderRegistry.getResourceClasses(dataClass, resourceClass);
         for (Class<?> registeredResourceClass : registeredResourceClasses) {
-          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
-              .getTranscodeClasses(registeredResourceClass, transcodeClass);
+          List<Class<Transcode>> registeredTranscodeClasses =
+              transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);
           if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
             result.add(registeredResourceClass);
           }
@@ -610,29 +609,27 @@ public NoModelLoaderAvailableException(@NonNull Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(@NonNull Class<?> modelClass,
-        @NonNull Class<?> dataClass) {
+    public NoModelLoaderAvailableException(
+        @NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
 
-  /**
-   * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
-   */
+  /** Thrown when no {@link ResourceEncoder} is registered for a given resource class. */
   // Never serialized by Glide.
   @SuppressWarnings("serial")
   public static class NoResultEncoderAvailableException extends MissingComponentException {
     public NoResultEncoderAvailableException(@NonNull Class<?> resourceClass) {
-      super("Failed to find result encoder for resource class: " + resourceClass
-          + ", you may need to consider registering a new Encoder for the requested type or"
-          + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed resource is"
-          + " unnecessary.");
+      super(
+          "Failed to find result encoder for resource class: "
+              + resourceClass
+              + ", you may need to consider registering a new Encoder for the requested type or"
+              + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed"
+              + " resource is unnecessary.");
     }
   }
 
-  /**
-   * Thrown when no {@link Encoder} is registered for a given data class.
-   */
+  /** Thrown when no {@link Encoder} is registered for a given data class. */
   // Never serialized by Glide.
   @SuppressWarnings("serial")
   public static class NoSourceEncoderAvailableException extends MissingComponentException {
@@ -641,9 +638,7 @@ public NoSourceEncoderAvailableException(@NonNull Class<?> dataClass) {
     }
   }
 
-  /**
-   * Thrown when some necessary component is missing for a load.
-   */
+  /** Thrown when some necessary component is missing for a load. */
   // Never serialized by Glide.
   @SuppressWarnings("serial")
   public static class MissingComponentException extends RuntimeException {
@@ -652,9 +647,7 @@ public MissingComponentException(@NonNull String message) {
     }
   }
 
-  /**
-   * Thrown when no {@link ImageHeaderParser} is registered.
-   */
+  /** Thrown when no {@link ImageHeaderParser} is registered. */
   // Never serialized by Glide.
   @SuppressWarnings("serial")
   public static final class NoImageHeaderParserException extends MissingComponentException {
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 5e89d0815..f75cbf246 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -44,17 +44,18 @@
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
  *
- * @param <TranscodeType> The type of resource that will be delivered to the
- * {@link com.bumptech.glide.request.target.Target}.
+ * @param <TranscodeType> The type of resource that will be delivered to the {@link
+ *     com.bumptech.glide.request.target.Target}.
  */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
 public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
-    implements Cloneable,
-    ModelTypes<RequestBuilder<TranscodeType>> {
+    implements Cloneable, ModelTypes<RequestBuilder<TranscodeType>> {
   // Used in generated subclasses
   protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+      new RequestOptions()
+          .diskCacheStrategy(DiskCacheStrategy.DATA)
+          .priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final Context context;
@@ -176,8 +177,8 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   }
 
   /**
-   * Adds a {@link RequestListener}. If called multiple times, all passed
-   * {@link RequestListener listeners} will be called in order.
+   * Adds a {@link RequestListener}. If called multiple times, all passed {@link RequestListener
+   * listeners} will be called in order.
    *
    * @param requestListener The request listener to use. If {@code null}, this method is a noop.
    * @return This request builder.
@@ -196,24 +197,24 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   }
 
   /**
-   * Sets a {@link RequestBuilder} that is built and run if the load started by this
-   * {@link RequestBuilder} fails.
+   * Sets a {@link RequestBuilder} that is built and run if the load started by this {@link
+   * RequestBuilder} fails.
    *
-   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
-   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error {@link
+   * RequestBuilder} will be started anyway if the non-thumbnail request fails.
    *
-   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and {@link
+   * #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
    *
    * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
    * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
    * Options like priority, override widths and heights and transitions must be applied
    * independently to the error builder.
    *
-   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
-   * if it's set on this {@link RequestBuilder} via
-   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
-   * {@link RequestOptions#fallback(int)}.
+   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable if
+   * it's set on this {@link RequestBuilder} via {@link
+   * RequestOptions#fallback(android.graphics.drawable.Drawable)} or {@link
+   * RequestOptions#fallback(int)}.
    *
    * @return This {@link RequestBuilder}.
    */
@@ -232,12 +233,11 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    *
    * <p>Recursive calls to thumbnail are supported.
    *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder[])}.
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and {@link
+   * #thumbnail(RequestBuilder[])}.
    *
    * @see #thumbnail(float)
    * @see #thumbnail(RequestBuilder[])
-   *
    * @param thumbnailRequest The request to use to load the thumbnail.
    * @return This request builder.
    */
@@ -255,28 +255,26 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
    * loaded as thumbnails in the given priority order.
    *
-   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
-   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
-   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
-   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the {@link
+   * RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied as using its
+   * thumbnail method, the {@link RequestBuilder} at position 1 has the {@link RequestBuilder} at
+   * position 2 applied using its thumbnail method and so on.
    *
-   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
-   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
-   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or an
+   * empty array of {@link RequestBuilder} thumbnails is equivalent to calling {@link
+   * #thumbnail(RequestBuilder)} with {@code null}.
    *
-   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
-   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
-   * chain.
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be {@code
+   * null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive chain.
    *
-   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
-   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous calls
+   * to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
    *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and this method.
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)}, {@link
+   * #thumbnail(float)} and this method.
    *
    * @see #thumbnail(float)
    * @see #thumbnail(RequestBuilder)
-   *
    * @return This request builder.
    */
   @SuppressWarnings({"CheckResult", "unchecked"})
@@ -319,27 +317,25 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    * load, the thumbnail will not be shown.
    *
    * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
-   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}.
+   * {@link ImageView}) must be able to scale the thumbnail appropriately. See {@link
+   * android.widget.ImageView.ScaleType}.
    *
    * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
-   * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load.
+   * and {@link com.bumptech.glide.load.Transformation}s. However, {@link
+   * com.bumptech.glide.request.RequestOptions#placeholder(int)} and {@link
+   * com.bumptech.glide.request.RequestOptions#error(int)}, and {@link #listener(RequestListener)}
+   * will only be used on the full size load and will not be copied for the thumbnail load.
    *
    * <p>Recursive calls to thumbnail are supported.
    *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
-   *  and {@link #thumbnail(RequestBuilder)}.
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])}, and
+   * {@link #thumbnail(RequestBuilder)}.
    *
    * @see #thumbnail(RequestBuilder)
    * @see #thumbnail(RequestBuilder[])
-   *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
-   *                       the thumbnail.
+   *     the thumbnail.
    * @return This request builder.
    */
   @NonNull
@@ -377,16 +373,15 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   /**
    * Returns an object to load the given {@link Bitmap}.
    *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
-   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
-   * not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than pass {@link Bitmap}s
+   * into Glide. If you have a custom way to obtain {@link Bitmap}s that is not supported by Glide
+   * by default, consider registering a custom {@link com.bumptech.glide.load.model.ModelLoader} or
    * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
    *
    * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
    * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than {@link
+   * DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
    *
    * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
    * compared.
@@ -397,23 +392,22 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
-    return loadGeneric(bitmap)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    return loadGeneric(bitmap).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
   }
 
   /**
    * Returns a request builder to load the given {@link Drawable}.
    *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
-   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
-   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass {@link
+   * Bitmap}s into Glide using this method . If you have a custom way to obtain {@link Bitmap}s that
+   * is not supported by Glide by default, consider registering a custom {@link
+   * com.bumptech.glide.load.model.ModelLoader} or {@link com.bumptech.glide.load.ResourceDecoder}
+   * instead of using this method.
    *
    * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
    * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than {@link
+   * DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
    *
    * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
    * compared.
@@ -424,28 +418,24 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
-    return loadGeneric(drawable)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    return loadGeneric(drawable).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
   }
 
   /**
    * Returns a request builder to load the given {@link java.lang.String}.
    *
-   * <p> Note - this method caches data using only the given String as the cache key. If the data is
+   * <p>Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
-   * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create that identifies the data currently at the given String that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
+   * to change without the String identifier changing, Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create that identifies the data currently at the given String that will
+   * invalidate the cache if that data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
    *
    * @see #load(Object)
-   *
-   * @param string A file path, or a uri or url handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
+   * @param string A file path, or a uri or url handled by {@link
+   *     com.bumptech.glide.load.model.UriLoader}.
    */
   @NonNull
   @Override
@@ -457,20 +447,18 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   /**
    * Returns a request builder to load the given {@link Uri}.
    *
-   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+   * <p>Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
-   * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
-   * if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate. </p>
+   * means using this method can lead to displaying stale data. Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create based on the data at the given Uri that will invalidate the cache if that
+   * data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
    *
    * @see #load(Object)
-   *
-   * @param uri The Uri representing the image. Must be of a type handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
+   * @param uri The Uri representing the image. Must be of a type handled by {@link
+   *     com.bumptech.glide.load.model.UriLoader}.
    */
   @NonNull
   @CheckResult
@@ -484,16 +472,14 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    *
    * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
-   * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
-   * to mixin a signature you create that identifies the data currently in the File that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
+   * expect the data in the File to change, Consider using {@link
+   * com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to mixin a
+   * signature you create that identifies the data currently in the File that will invalidate the
+   * cache if that data changes. Alternatively, using {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or {@link
+   * com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be appropriate.
    *
    * @see #load(Object)
-   *
    * @param file The File containing the image
    */
   @NonNull
@@ -504,26 +490,26 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   }
 
   /**
-   * Returns a request builder that uses the
-   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
-   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
-   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+   * Returns a request builder that uses the {@link
+   * com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or {@link Integer} to
+   * load the image represented by the given {@link Integer} resource id. Defaults to {@link
+   * com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
    * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-   * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
-   *
-   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
-   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
-   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
-   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
-   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via {@link
+   * RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)} during
+   * development, and re-enabling the default {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like {@link
+   * android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply {@link
+   * com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting the
+   * underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide is
+   * still not able to transform all types of resources. Animated {@link Drawable}s cannot be
    * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
    * load failures if a {@link Drawable} can't be transformed, use the optional transformation
    * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
@@ -547,9 +533,9 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
    *
    * @param url The URL representing the image.
    * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has
-   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
-   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
+   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
+   *     performance problems</a> and should generally be avoided when possible. Prefer {@link
+   *     #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
   @CheckResult
@@ -572,7 +558,7 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
     RequestBuilder<TranscodeType> result = loadGeneric(model);
     if (!result.isDiskCacheStrategySet()) {
-        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+      result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
     }
     if (!result.isSkipMemoryCacheSet()) {
       result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
@@ -583,15 +569,15 @@ private void initRequestListeners(List<RequestListener<Object>> requestListeners
   /**
    * Returns a copy of this request builder with all of the options put so far on this builder.
    *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * <p>This method returns a "deep" copy in that all non-immutable arguments are copied such that
    * changes to one builder will not affect the other builder. However, in addition to immutable
    * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
+   * builders.
    */
   @SuppressWarnings({
-      "unchecked",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException"
+    "unchecked",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException"
   })
   @CheckResult
   @Override
@@ -674,10 +660,9 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
    * reused.
    *
    * @see RequestManager#clear(Target)
-   *
    * @param view The view to cancel previous loads for and load the new resource into.
-   * @return The
-   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+   * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link
+   *     ImageView}.
    */
   @NonNull
   public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
@@ -723,16 +708,13 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
   /**
    * Returns a future that can be used to do a blocking get on a background thread.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
    * @see RequestManager#clear(Target)
-   *
    * @deprecated Use {@link #submit(int, int)} instead.
    */
   @Deprecated
@@ -760,14 +742,12 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
   /**
    * Returns a future that can be used to do a blocking get on a background thread.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
    */
   @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
@@ -778,19 +758,17 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
   /**
    * Preloads the resource into the cache using the given width and height.
    *
-   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
-   * future are available quickly. </p>
+   * <p>Pre-loading is useful for making sure that resources you are going to to want in the near
+   * future are available quickly.
    *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
+   * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+   *     previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}.
+   *     overridden by {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+   *     previously called).
+   * @return A {@link Target} that can be used to cancel the load via {@link
+   *     RequestManager#clear(Target)}.
    * @see com.bumptech.glide.ListPreloader
    */
   @NonNull
@@ -804,8 +782,8 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
    * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
    * the width and height.
    *
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}
+   * @return A {@link Target} that can be used to cancel the load via {@link
+   *     RequestManager#clear(Target)}
    * @see #preload(int, int)
    */
   @NonNull
@@ -818,9 +796,8 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
    * File.
    *
    * @param target The Target that will receive the cache File when the load completes
-   * @param <Y>    The type of Target.
+   * @param <Y> The type of Target.
    * @return The given Target.
-   *
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
   @Deprecated
@@ -830,15 +807,13 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
   }
 
   /**
-   * Loads the original unmodified data into the cache and returns a
-   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
-   * data.
+   * Loads the original unmodified data into the cache and returns a {@link
+   * java.util.concurrent.Future} that can be used to retrieve the cache File containing the data.
    *
-   * @param width  The width in pixels to use to fetch the data.
+   * @param width The width in pixels to use to fetch the data.
    * @param height The height in pixels to use to fetch the data.
    * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
-   * containing the data.
-   *
+   *     containing the data.
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
    */
   @Deprecated
@@ -921,8 +896,7 @@ private Request buildRequestRecursive(
 
     int errorOverrideWidth = errorBuilder.getOverrideWidth();
     int errorOverrideHeight = errorBuilder.getOverrideHeight();
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)
-        && !errorBuilder.isValidOverride()) {
+    if (Util.isValidDimensions(overrideWidth, overrideHeight) && !errorBuilder.isValidOverride()) {
       errorOverrideWidth = requestOptions.getOverrideWidth();
       errorOverrideHeight = requestOptions.getOverrideHeight();
     }
@@ -955,8 +929,9 @@ private Request buildThumbnailRequestRecursive(
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
-        throw new IllegalStateException("You cannot use a request as both the main request and a "
-            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+        throw new IllegalStateException(
+            "You cannot use a request as both the main request and a "
+                + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
       }
 
       TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
@@ -968,8 +943,10 @@ private Request buildThumbnailRequestRecursive(
         thumbTransitionOptions = transitionOptions;
       }
 
-      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
-          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
+      Priority thumbPriority =
+          thumbnailBuilder.isPrioritySet()
+              ? thumbnailBuilder.getPriority()
+              : getThumbnailPriority(priority);
 
       int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
       int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 2da90583c..0ca07b526 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -54,30 +54,35 @@
  * @see Glide#with(android.support.v4.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener,
-    ModelTypes<RequestBuilder<Drawable>> {
+public class RequestManager implements LifecycleListener, ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
+      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW).skipMemoryCache(true);
 
   protected final Glide glide;
   protected final Context context;
+
   @SuppressWarnings("WeakerAccess")
-  @Synthetic final Lifecycle lifecycle;
+  @Synthetic
+  final Lifecycle lifecycle;
+
   @GuardedBy("this")
   private final RequestTracker requestTracker;
+
   @GuardedBy("this")
   private final RequestManagerTreeNode treeNode;
+
   @GuardedBy("this")
   private final TargetTracker targetTracker = new TargetTracker();
-  private final Runnable addSelfToLifecycle = new Runnable() {
-    @Override
-    public void run() {
-      lifecycle.addListener(RequestManager.this);
-    }
-  };
+
+  private final Runnable addSelfToLifecycle =
+      new Runnable() {
+        @Override
+        public void run() {
+          lifecycle.addListener(RequestManager.this);
+        }
+      };
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
   // Adding default listeners should be much less common than starting new requests. We want
@@ -89,8 +94,10 @@ public void run() {
   private RequestOptions requestOptions;
 
   public RequestManager(
-      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
-      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+      @NonNull Glide glide,
+      @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode,
+      @NonNull Context context) {
     this(
         glide,
         lifecycle,
@@ -161,7 +168,6 @@ private synchronized void updateRequestOptions(@NonNull RequestOptions toUpdate)
    * <p>The modified options will only be applied to loads started after this method is called.
    *
    * @see RequestBuilder#apply(BaseRequestOptions)
-   *
    * @return This request manager.
    */
   @NonNull
@@ -359,17 +365,17 @@ public synchronized void onDestroy() {
   }
 
   /**
-   * Attempts to always load the resource as a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   * Attempts to always load the resource as a {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}.
    *
-   * <p> If the underlying data is not a GIF, this will fail. As a result, this should only be used
+   * <p>If the underlying data is not a GIF, this will fail. As a result, this should only be used
    * if the model represents an animated GIF and the caller wants to interact with the GifDrawable
    * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
    * whether or not the given data represents an animated GIF and return the appropriate {@link
-   * Drawable}, animated or not, automatically. </p>
+   * Drawable}, animated or not, automatically.
    *
-   * @return A new request builder for loading a
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+   * @return A new request builder for loading a {@link
+   *     com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
   @NonNull
   @CheckResult
@@ -381,9 +387,9 @@ public synchronized void onDestroy() {
    * Attempts to always load the resource using any registered {@link
    * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
    *
-   * <p> By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
+   * <p>By default, may return either a {@link android.graphics.drawable.BitmapDrawable} or {@link
    * GifDrawable}, but if additional decoders are registered for other {@link Drawable} subclasses,
-   * any of those subclasses may also be returned. </p>
+   * any of those subclasses may also be returned.
    *
    * @return A new request builder for loading a {@link Drawable}.
    */
@@ -479,7 +485,6 @@ public synchronized void onDestroy() {
     return asDrawable().load(url);
   }
 
-
   /**
    * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
    *
@@ -510,9 +515,8 @@ public synchronized void onDestroy() {
    * cached source data.
    *
    * <p>This method is designed to work for remote data that is or will be cached using {@link
-   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not
-   * recommended.
+   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a {@link
+   * com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not recommended.
    *
    * @return A new request builder for downloading content to cache and returning the cache File.
    */
@@ -536,8 +540,8 @@ public synchronized void onDestroy() {
 
   /**
    * Attempts to always load a {@link File} containing the resource, either using a file path
-   * obtained from the media store (for local images/videos), or using Glide's disk cache
-   * (for remote images/videos).
+   * obtained from the media store (for local images/videos), or using Glide's disk cache (for
+   * remote images/videos).
    *
    * <p>For remote content, prefer {@link #downloadOnly()}.
    *
@@ -550,9 +554,9 @@ public synchronized void onDestroy() {
   }
 
   /**
-   * Attempts to load the resource using any registered
-   * {@link com.bumptech.glide.load.ResourceDecoder}s
-   * that can decode the given resource class or any subclass of the given resource class.
+   * Attempts to load the resource using any registered {@link
+   * com.bumptech.glide.load.ResourceDecoder}s that can decode the given resource class or any
+   * subclass of the given resource class.
    *
    * @param resourceClass The resource to decode.
    * @return A new request builder for loading the given resource class.
@@ -568,12 +572,12 @@ public synchronized void onDestroy() {
    * Cancel any pending loads Glide may have for the view and free any resources that may have been
    * loaded for the view.
    *
-   * <p> Note that this will only work if {@link View#setTag(Object)} is not called on this view
-   * outside of Glide. </p>
+   * <p>Note that this will only work if {@link View#setTag(Object)} is not called on this view
+   * outside of Glide.
    *
    * @param view The view to cancel loads and free resources for.
    * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
-   *                                  tag.
+   *     tag.
    * @see #clear(Target)
    */
   public void clear(@NonNull View view) {
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index ce2cfe469..c81cd90ff 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -11,11 +11,12 @@
 /**
  * A base class for setting a transition to use on a resource when a load completes.
  *
- * @param <CHILD>         The implementation of this class to return to chain methods.
+ * @param <CHILD> The implementation of this class to return to chain methods.
  * @param <TranscodeType> The type of resource that will be animated.
  */
-public abstract class TransitionOptions<CHILD extends TransitionOptions<CHILD, TranscodeType>,
-    TranscodeType> implements Cloneable {
+public abstract class TransitionOptions<
+        CHILD extends TransitionOptions<CHILD, TranscodeType>, TranscodeType>
+    implements Cloneable {
   private TransitionFactory<? super TranscodeType> transitionFactory = NoTransition.getFactory();
 
   /**
@@ -31,11 +32,11 @@ public final CHILD dontTransition() {
 
   /**
    * Sets an {@link android.view.animation.Animation} to run on the wrapped target when an resource
-   * load finishes.
-   * Will only be run if the resource was loaded asynchronously (i.e. was not in the memory cache).
+   * load finishes. Will only be run if the resource was loaded asynchronously (i.e. was not in the
+   * memory cache).
    *
    * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
-   *                        transition.
+   *     transition.
    * @return This request builder.
    */
   @NonNull
@@ -45,11 +46,11 @@ public final CHILD transition(int viewAnimationId) {
 
   /**
    * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
-   * may be wrapping when a resource load finishes.
-   * Will only be run if the load was loaded asynchronously (i.e. was not in the memory cache).
+   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
+   * asynchronously (i.e. was not in the memory cache).
    *
    * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
-   *                 .Animator} to run.
+   *     .Animator} to run.
    * @return This request builder.
    */
   @NonNull
@@ -58,9 +59,9 @@ public final CHILD transition(@NonNull ViewPropertyTransition.Animator animator)
   }
 
   /**
-   * Uses the given {@link TransitionFactory} to build a
-   * {@link com.bumptech.glide.request.transition.Transition} for each request started with these
-   * {@code TransitionOptions}.
+   * Uses the given {@link TransitionFactory} to build a {@link
+   * com.bumptech.glide.request.transition.Transition} for each request started with these {@code
+   * TransitionOptions}.
    *
    * @return This request builder.
    */
@@ -72,12 +73,12 @@ public final CHILD transition(
   }
 
   @SuppressWarnings({
-      // cast to CHILD is safe given the generic argument represents the object's runtime class
-      "unchecked",
-      // CHILD is the correct class name.
-      "PMD.CloneMethodReturnTypeMustMatchClassName",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException"
+    // cast to CHILD is safe given the generic argument represents the object's runtime class
+    "unchecked",
+    // CHILD is the correct class name.
+    "PMD.CloneMethodReturnTypeMustMatchClassName",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException"
   })
   @Override
   public final CHILD clone() {
diff --git a/library/src/main/java/com/bumptech/glide/load/DataSource.java b/library/src/main/java/com/bumptech/glide/load/DataSource.java
index 699a13bfe..d266c7f0a 100644
--- a/library/src/main/java/com/bumptech/glide/load/DataSource.java
+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java
@@ -1,28 +1,18 @@
 package com.bumptech.glide.load;
 
-/**
- * Indicates the origin of some retrieved data.
- */
+/** Indicates the origin of some retrieved data. */
 public enum DataSource {
   /**
    * Indicates data was probably retrieved locally from the device, although it may have been
    * obtained through a content provider that may have obtained the data from a remote source.
    */
   LOCAL,
-  /**
-   * Indicates data was retrieved from a remote source other than the device.
-   */
+  /** Indicates data was retrieved from a remote source other than the device. */
   REMOTE,
-  /**
-   * Indicates data was retrieved unmodified from the on device cache.
-   */
+  /** Indicates data was retrieved unmodified from the on device cache. */
   DATA_DISK_CACHE,
-  /**
-   * Indicates data was retrieved from modified content in the on device cache.
-   */
+  /** Indicates data was retrieved from modified content in the on device cache. */
   RESOURCE_DISK_CACHE,
-  /**
-   * Indicates data was retrieved from the in memory cache.
-   */
+  /** Indicates data was retrieved from the in memory cache. */
   MEMORY_CACHE,
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index 3fac0791c..ad9cb2efc 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -1,26 +1,26 @@
 package com.bumptech.glide.load;
 
 /**
- * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for
- * {@link android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
+ * Options for setting the value of {@link android.graphics.Bitmap#getConfig()} for {@link
+ * android.graphics.Bitmap}s returned by {@link com.bumptech.glide.load.ResourceDecoder}s.
  *
- * <p> Note - In some cases it may not be possible to obey the requested setting, not all
- * {@link com.bumptech.glide.load.resource.bitmap.Downsampler}s support setting formats and certain
- * images may not be able to be loaded as certain configurations. Therefore this class represents a
- * preference rather than a requirement. </p>
+ * <p>Note - In some cases it may not be possible to obey the requested setting, not all {@link
+ * com.bumptech.glide.load.resource.bitmap.Downsampler}s support setting formats and certain images
+ * may not be able to be loaded as certain configurations. Therefore this class represents a
+ * preference rather than a requirement.
  */
 public enum DecodeFormat {
   /**
-   * Bitmaps returned by the {@link com.bumptech.glide.load.ResourceDecoder}.
-   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
-   * {@link android.graphics.Bitmap#getConfig()} when possible.
+   * Bitmaps returned by the {@link com.bumptech.glide.load.ResourceDecoder}. should return {@link
+   * android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()} when
+   * possible.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
-   * {@link android.graphics.Bitmap.Config#HARDWARE}. More information is available about hardware
-   * Bitmaps here: https://goo.gl/tn2A6k. If you need to disable hardware Bitmaps for a particular
-   * request, use {@link com.bumptech.glide.request.RequestOptions#disallowHardwareConfig()}.
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * android.graphics.Bitmap.Config#HARDWARE}. More information is available about hardware Bitmaps
+   * here: https://goo.gl/tn2A6k. If you need to disable hardware Bitmaps for a particular request,
+   * use {@link com.bumptech.glide.request.RequestOptions#disallowHardwareConfig()}.
    *
-   * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
+   * <p>GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
    * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
    * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
    * this setting is a preference, not a promise.
@@ -29,18 +29,16 @@
 
   /**
    * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)
-   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
-   * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
-   * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
-   * {@link android.graphics.Bitmap#getConfig()}.
+   * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for {@link
+   * android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or use
+   * alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for {@link
+   * android.graphics.Bitmap#getConfig()}.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
-   * {@link android.graphics.Bitmap.Config#HARDWARE}.
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
 
-  /**
-   * The default value for DecodeFormat.
-   */
+  /** The default value for DecodeFormat. */
   public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
index 33eed74dc..950ca398b 100644
--- a/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/EncodeStrategy.java
@@ -10,13 +10,9 @@
    */
   SOURCE,
 
-  /**
-   * Writes the decoded, downsampled and transformed data for the resource to disk.
-   */
+  /** Writes the decoded, downsampled and transformed data for the resource to disk. */
   TRANSFORMED,
 
-  /**
-   * Will write no data.
-   */
+  /** Will write no data. */
   NONE,
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index b13edc5d7..79715aab2 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -6,9 +6,9 @@
 /**
  * Thrown when an http request fails.
  *
- * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so
- * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
- * the underlying http library.
+ * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so users may
+ * attempt to retry or otherwise uniformly handle certain types of errors regardless of the
+ * underlying http library.
  */
 // Public API.
 @SuppressWarnings({"WeakerAccess", "unused"})
@@ -36,8 +36,8 @@ public HttpException(String message, int statusCode, @Nullable Throwable cause)
   }
 
   /**
-   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing
-   * a status code.
+   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing a
+   * status code.
    */
   public int getStatusCode() {
     return statusCode;
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
index b188c4df3..114f5984b 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -6,9 +6,7 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
-/**
- * Interface for the ImageHeaderParser.
- */
+/** Interface for the ImageHeaderParser. */
 public interface ImageHeaderParser {
   /**
    * A constant indicating we were unable to parse the orientation from the image either because no
@@ -18,8 +16,7 @@
   int UNKNOWN_ORIENTATION = -1;
 
   /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
+   * The format of the image data including whether or not the image may include transparent pixels.
    */
   enum ImageType {
     GIF(true),
@@ -58,7 +55,7 @@ public boolean hasAlpha() {
    * not an image) it will return a default value rather than throwing an exception.
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
-   * contain an orientation
+   *     contain an orientation
    */
   int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
index 97930be11..5e660905d 100644
--- a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -10,20 +10,21 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 
-/**
- * Utilities for the ImageHeaderParser.
- */
+/** Utilities for the ImageHeaderParser. */
 public final class ImageHeaderParserUtils {
   // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
   // will resize up to this amount if necessary.
   private static final int MARK_POSITION = 5 * 1024 * 1024;
 
-  private ImageHeaderParserUtils() { }
+  private ImageHeaderParserUtils() {}
 
   /** Returns the ImageType for the given InputStream. */
   @NonNull
-  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
-      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
+  public static ImageType getType(
+      @NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is,
+      @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     if (is == null) {
       return ImageType.UNKNOWN;
     }
@@ -51,9 +52,8 @@ public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
 
   /** Returns the ImageType for the given ByteBuffer. */
   @NonNull
-  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
-      @Nullable ByteBuffer buffer)
-      throws IOException {
+  public static ImageType getType(
+      @NonNull List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer) throws IOException {
     if (buffer == null) {
       return ImageType.UNKNOWN;
     }
@@ -70,11 +70,12 @@ public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
     return ImageType.UNKNOWN;
   }
 
-  /**
-   * Returns the orientation for the given InputStream.
-   */
-  public static int getOrientation(@NonNull List<ImageHeaderParser> parsers,
-      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
+  /** Returns the orientation for the given InputStream. */
+  public static int getOrientation(
+      @NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is,
+      @NonNull ArrayPool byteArrayPool)
+      throws IOException {
     if (is == null) {
       return ImageHeaderParser.UNKNOWN_ORIENTATION;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index f78a7b168..b5a81d469 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -19,21 +19,21 @@
   /**
    * Adds all uniquely identifying information to the given digest.
    *
-   * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
-   * in undefined behavior. </p>
+   * <p>Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
+   * in undefined behavior.
    */
   void updateDiskCacheKey(@NonNull MessageDigest messageDigest);
 
   /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #hashCode()}.
+   * For caching to work correctly, implementations <em>must</em> implement this method and {@link
+   * #hashCode()}.
    */
   @Override
   boolean equals(Object o);
 
   /**
-   * For caching to work correctly, implementations <em>must</em> implement this method and
-   * {@link #equals(Object)}.
+   * For caching to work correctly, implementations <em>must</em> implement this method and {@link
+   * #equals(Object)}.
    */
   @Override
   int hashCode();
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index 561264871..76d8259c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -10,28 +10,25 @@
  * default values and the ability to affect the resource disk cache key used by {@link
  * com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE}.
  *
- * <p>
- *   Implementations must either be unique (usually declared as static final variables), or
- *   implement {@link #equals(Object)} and {@link #hashCode()}.
- * </p>
+ * <p>Implementations must either be unique (usually declared as static final variables), or
+ * implement {@link #equals(Object)} and {@link #hashCode()}.
  *
- * <p>
- *   Implementations can implement {@link #update(Object, MessageDigest)} to make sure that
- *   the disk cache key includes the specific option set.
- * </p>
+ * <p>Implementations can implement {@link #update(Object, MessageDigest)} to make sure that the
+ * disk cache key includes the specific option set.
  *
  * @param <T> The type of the option ({@link Integer}, {@link
- * android.graphics.Bitmap.CompressFormat} etc.), must implement {@link #equals(Object)} and
- * {@link #hashCode()}.
+ *     android.graphics.Bitmap.CompressFormat} etc.), must implement {@link #equals(Object)} and
+ *     {@link #hashCode()}.
  */
 public final class Option<T> {
-  private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
-    @Override
-    public void update(@NonNull byte[] keyBytes, @NonNull Object value,
-        @NonNull MessageDigest messageDigest) {
-      // Do nothing.
-    }
-  };
+  private static final CacheKeyUpdater<Object> EMPTY_UPDATER =
+      new CacheKeyUpdater<Object>() {
+        @Override
+        public void update(
+            @NonNull byte[] keyBytes, @NonNull Object value, @NonNull MessageDigest messageDigest) {
+          // Do nothing.
+        }
+      };
 
   private final T defaultValue;
   private final CacheKeyUpdater<T> cacheKeyUpdater;
@@ -42,8 +39,8 @@ public void update(@NonNull byte[] keyBytes, @NonNull Object value,
    * Returns a new {@link Option} that does not affect disk cache keys with a {@code null} default
    * value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
   @NonNull
   public static <T> Option<T> memory(@NonNull String key) {
@@ -54,8 +51,8 @@ public void update(@NonNull byte[] keyBytes, @NonNull Object value,
    * Returns a new {@link Option} that does not affect disk cache keys with the given value as the
    * default value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
   @NonNull
   public static <T> Option<T> memory(@NonNull String key, @NonNull T defaultValue) {
@@ -66,39 +63,37 @@ public void update(@NonNull byte[] keyBytes, @NonNull Object value,
    * Returns a new {@link Option} that uses the given {@link
    * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
   @NonNull
-  public static <T> Option<T> disk(@NonNull String key,
-      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+  public static <T> Option<T> disk(
+      @NonNull String key, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, null, cacheKeyUpdater);
   }
 
   /**
    * Returns a new {@link Option} that uses the given {@link
-   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys and provides
-   * the given value as the default value.
+   * com.bumptech.glide.load.Option.CacheKeyUpdater} to update disk cache keys and provides the
+   * given value as the default value.
    *
-   * @param key A unique package prefixed {@link String} that identifies this option (must be
-   *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
+   * @param key A unique package prefixed {@link String} that identifies this option (must be stable
+   *     across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
   @NonNull
-  public static <T> Option<T> disk(@NonNull String key, @Nullable T defaultValue,
-      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+  public static <T> Option<T> disk(
+      @NonNull String key, @Nullable T defaultValue, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, defaultValue, cacheKeyUpdater);
   }
 
-  private Option(@NonNull String key, @Nullable T defaultValue,
-      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+  private Option(
+      @NonNull String key, @Nullable T defaultValue, @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     this.key = Preconditions.checkNotEmpty(key);
     this.defaultValue = defaultValue;
     this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
   }
 
-  /**
-   * Returns a reasonable default to use if no other value is set, or {@code null}.
-   */
+  /** Returns a reasonable default to use if no other value is set, or {@code null}. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   @Nullable
@@ -107,9 +102,9 @@ public T getDefaultValue() {
   }
 
   /**
-   * Updates the given {@link MessageDigest} used to construct a cache key with the given
-   * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
-   * the constructor.
+   * Updates the given {@link MessageDigest} used to construct a cache key with the given value
+   * using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in the
+   * constructor.
    */
   public void update(@NonNull T value, @NonNull MessageDigest messageDigest) {
     cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
@@ -145,9 +140,7 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "Option{"
-        + "key='" + key + '\''
-        + '}';
+    return "Option{" + "key='" + key + '\'' + '}';
   }
 
   /**
@@ -164,14 +157,13 @@ public String toString() {
      * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this
      * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead.
      *
-     * @param keyBytes The bytes of the {@link String} used as the key for this particular
-     * {@link Option}. Should be added to the {@code messageDigest} using
-     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with
-     * the given {@code value} parameter.
-     *
+     * @param keyBytes The bytes of the {@link String} used as the key for this particular {@link
+     *     Option}. Should be added to the {@code messageDigest} using {@link
+     *     MessageDigest#update(byte[])} by all implementations if the digest is updated with the
+     *     given {@code value} parameter.
      * @param value The value of of this particular option. Typically you should convert the value
-     * to a byte array using some stable mechanism and then call
-     * {@link MessageDigest#update(byte[])} to update the given digest.
+     *     to a byte array using some stable mechanism and then call {@link
+     *     MessageDigest#update(byte[])} to update the given digest.
      */
     void update(@NonNull byte[] keyBytes, @NonNull T value, @NonNull MessageDigest messageDigest);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 6609a080f..df7f9b4bc 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -7,9 +7,7 @@
 import com.bumptech.glide.util.CachedHashCodeArrayMap;
 import java.security.MessageDigest;
 
-/**
- * A set of {@link Option Options} to apply to in memory and disk cache keys.
- */
+/** A set of {@link Option Options} to apply to in memory and disk cache keys. */
 public final class Options implements Key {
   private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();
 
@@ -54,14 +52,12 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
 
   @Override
   public String toString() {
-    return "Options{"
-        + "values=" + values
-        + '}';
+    return "Options{" + "values=" + values + '}';
   }
 
   @SuppressWarnings("unchecked")
-  private static <T> void updateDiskCacheKey(@NonNull Option<T> option, @NonNull Object value,
-      @NonNull MessageDigest md) {
+  private static <T> void updateDiskCacheKey(
+      @NonNull Option<T> option, @NonNull Object value, @NonNull MessageDigest md) {
     option.update((T) value, md);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index 977339e25..b5845c560 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -38,18 +38,17 @@
    * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
    * overly large allocations.
    *
-   * @param source  The data the resource should be decoded from.
-   * @param width   The ideal width in pixels of the decoded resource, or {@link
-   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
-   *                resource width.
-   * @param height  The ideal height in pixels of the decoded resource, or {@link
-   *                com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original
-   *                resource height.
+   * @param source The data the resource should be decoded from.
+   * @param width The ideal width in pixels of the decoded resource, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     width.
+   * @param height The ideal height in pixels of the decoded resource, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     height.
    * @param options A map of string keys to objects that may or may not contain options available to
-   *                this particular implementation. Implementations should not assume that any or
-   *                all of their option keys are present. However, implementations may assume that
-   *                if one of their option keys is present, it's value is non-null and is of the
-   *                expected type.
+   *     this particular implementation. Implementations should not assume that any or all of their
+   *     option keys are present. However, implementations may assume that if one of their option
+   *     keys is present, it's value is non-null and is of the expected type.
    */
   @Nullable
   Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 2e9ab29d9..19a6bed58 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -7,19 +7,19 @@
 import java.security.MessageDigest;
 
 /**
- * A class for performing an arbitrary transformation on a resource that implements
- * {@link #equals(Object)} and {@link #hashCode()}} to identify the transformation in the memory
- * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
- * transformation in disk caches.
+ * A class for performing an arbitrary transformation on a resource that implements {@link
+ * #equals(Object)} and {@link #hashCode()}} to identify the transformation in the memory cache and
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the transformation in disk
+ * caches.
  *
- * <p>Using the fully qualified class name as a static final {@link String} (not
- * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * <p>Using the fully qualified class name as a static final {@link String} (not {@link
+ * Class#getName()} to avoid proguard obfuscation) is an easy way to implement {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
  * required they can be passed in to the constructor of the {@code Transformation} and then used to
- * update the {@link java.security.MessageDigest} passed in to
- * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
- * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
- * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ * update the {@link java.security.MessageDigest} passed in to {@link
+ * #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically easily
+ * be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized with
+ * {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
  *
  * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for
  * memory caching to work correctly.
@@ -31,20 +31,19 @@
   /**
    * Transforms the given resource and returns the transformed resource.
    *
-   * <p>If the original resource object is not returned, the original resource will be
-   * recycled and it's internal resources may be reused. This means it is not safe to rely on the
-   * original resource or any internal state of the original resource in any new resource that is
-   * created. Usually this shouldn't occur, but if absolutely necessary either the original resource
-   * object can be returned with modified internal state, or the data in the original resource can
-   * be copied into the transformed resource.
+   * <p>If the original resource object is not returned, the original resource will be recycled and
+   * it's internal resources may be reused. This means it is not safe to rely on the original
+   * resource or any internal state of the original resource in any new resource that is created.
+   * Usually this shouldn't occur, but if absolutely necessary either the original resource object
+   * can be returned with modified internal state, or the data in the original resource can be
+   * copied into the transformed resource.
    *
-   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and
-   * {@link #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a
-   * simple String key an easy way to do this is to append a version number to your key. Failing to
-   * do so will mean users may see images loaded from cache that had the old version of the
-   * Transformation applied. Changing the return values of those methods will ensure that the cache
-   * key has changed and therefore that any cached resources will be re-generated using the updated
-   * Transformation.
+   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and {@link
+   * #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a simple
+   * String key an easy way to do this is to append a version number to your key. Failing to do so
+   * will mean users may see images loaded from cache that had the old version of the Transformation
+   * applied. Changing the return values of those methods will ensure that the cache key has changed
+   * and therefore that any cached resources will be re-generated using the updated Transformation.
    *
    * <p>During development you may need to either using {@link
    * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} or make sure {@link
@@ -53,16 +52,16 @@
    * Transformation may not be called.
    *
    * @param context The Application context
-   * @param resource  The resource to transform.
-   * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
-   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
-   *                  original resource width.
+   * @param resource The resource to transform.
+   * @param outWidth The width of the view or target the resource will be displayed in, or {@link
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     width.
    * @param outHeight The height of the view or target the resource will be displayed in, or {@link
-   *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
-   *                  original resource height.
+   *     com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the original resource
+   *     height.
    * @return The transformed resource.
    */
   @NonNull
-  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
-      int outWidth, int outHeight);
+  Resource<T> transform(
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
index 66a287823..538f77acf 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -7,9 +7,7 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-/**
- * Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}.
- */
+/** Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}. */
 public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
 
   public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index f21eb6c64..8f47dc05e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -68,7 +68,7 @@ public DataSource getDataSource() {
    * the concrete data type returned by the AssetManager.
    *
    * @param assetManager An AssetManager to use to open the given path.
-   * @param path         A string path pointing to a resource in assets to open.
+   * @param path A string path pointing to a resource in assets to open.
    */
   protected abstract T loadResource(AssetManager assetManager, String path) throws IOException;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
index ce9cd17b1..6af5b88a3 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
@@ -11,8 +11,7 @@
  * provided {@link ArrayPool}.
  */
 public final class BufferedOutputStream extends OutputStream {
-  @NonNull
-  private final OutputStream out;
+  @NonNull private final OutputStream out;
   private byte[] buffer;
   private ArrayPool arrayPool;
   private int index;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 4a1674fd9..ecc1dc9e2 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -8,14 +8,13 @@
 /**
  * Lazily retrieves data that can be used to load a resource.
  *
- * <p> A new instance is
- * created per resource load by {@link com.bumptech.glide.load.model.ModelLoader}. {@link
- * #loadData(com.bumptech.glide.Priority, com.bumptech.glide.load.data.DataFetcher.DataCallback)}
- * may or may not be called for any given load depending on whether or not the corresponding
- * resource is cached. Cancel also may or may not be called. If
- * {@link #loadData(com.bumptech.glide.Priority,
+ * <p>A new instance is created per resource load by {@link
+ * com.bumptech.glide.load.model.ModelLoader}. {@link #loadData(com.bumptech.glide.Priority,
+ * com.bumptech.glide.load.data.DataFetcher.DataCallback)} may or may not be called for any given
+ * load depending on whether or not the corresponding resource is cached. Cancel also may or may not
+ * be called. If {@link #loadData(com.bumptech.glide.Priority,
  * com.bumptech.glide.load.data.DataFetcher.DataCallback)}} is called, then so {@link #cleanup()}
- * will be called. </p>
+ * will be called.
  *
  * @param <T> The type of data to be loaded (InputStream, byte[], File etc).
  */
@@ -45,19 +44,17 @@
   /**
    * Fetch data from which a resource can be decoded.
    *
-   * <p> This will always be called on background thread so it is safe to perform long running tasks
+   * <p>This will always be called on background thread so it is safe to perform long running tasks
    * here. Any third party libraries called must be thread safe (or move the work to another thread)
-   * since this method will be called from a thread in a
-   * {@link java.util.concurrent.ExecutorService}
-   * that may have more than one background thread. </p>
+   * since this method will be called from a thread in a {@link
+   * java.util.concurrent.ExecutorService} that may have more than one background thread. You
+   * <b>MUST</b> use the {@link DataCallback} once the request is complete.
    *
-   * You <b>MUST</b> use the {@link DataCallback} once the request is complete.
+   * <p>You are free to move the fetch work to another thread and call the callback from there.
    *
-   * You are free to move the fetch work to another thread and call the callback from there.
+   * <p>This method will only be called when the corresponding resource is not in the cache.
    *
-   * <p> This method will only be called when the corresponding resource is not in the cache. </p>
-   *
-   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   * <p>Note - this method will be run on a background thread so blocking I/O is safe.
    *
    * @param priority The priority with which the request should be completed.
    * @param callback The callback to use when the request is complete
@@ -68,10 +65,10 @@
   /**
    * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
    * finally block after the data provided by {@link #loadData(com.bumptech.glide.Priority,
-   * com.bumptech.glide.load.data.DataFetcher.DataCallback)} has been decoded by the
-   * {@link com.bumptech.glide.load.ResourceDecoder}.
+   * com.bumptech.glide.load.data.DataFetcher.DataCallback)} has been decoded by the {@link
+   * com.bumptech.glide.load.ResourceDecoder}.
    *
-   * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
+   * <p>Note - this method will be run on a background thread so blocking I/O is safe.
    */
   void cleanup();
 
@@ -80,24 +77,20 @@
    * method does not need to guarantee that any in process loads do not finish. It also may be
    * called before a load starts or after it finishes.
    *
-   * <p> The best way to use this method is to cancel any loads that have not yet started, but allow
+   * <p>The best way to use this method is to cancel any loads that have not yet started, but allow
    * those that are in process to finish since its we typically will want to display the same
-   * resource in a different view in the near future. </p>
+   * resource in a different view in the near future.
    *
-   * <p> Note - this method will be run on the main thread so it should not perform blocking
-   * operations and should finish quickly. </p>
+   * <p>Note - this method will be run on the main thread so it should not perform blocking
+   * operations and should finish quickly.
    */
   void cancel();
 
-  /**
-   * Returns the class of the data this fetcher will attempt to obtain.
-   */
+  /** Returns the class of the data this fetcher will attempt to obtain. */
   @NonNull
   Class<T> getDataClass();
 
-  /**
-   * Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from.
-   */
+  /** Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from. */
   @NonNull
   DataSource getDataSource();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
index 805198ca6..b8400afce 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -11,22 +11,20 @@
 public interface DataRewinder<T> {
 
   /**
-   * A factory interface for producing individual
-   * {@link com.bumptech.glide.load.data.DataRewinder}s.
+   * A factory interface for producing individual {@link
+   * com.bumptech.glide.load.data.DataRewinder}s.
    *
    * @param <T> The type of data that the {@link com.bumptech.glide.load.data.DataRewinder} will
-   *            wrap.
+   *     wrap.
    */
   interface Factory<T> {
-    /**
-     * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
-     */
+    /** Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data. */
     @NonNull
     DataRewinder<T> build(@NonNull T data);
 
     /**
-     * Returns the class of data this factory can produce
-     * {@link com.bumptech.glide.load.data.DataRewinder}s for.
+     * Returns the class of data this factory can produce {@link
+     * com.bumptech.glide.load.data.DataRewinder}s for.
      */
     @NonNull
     Class<T> getDataClass();
@@ -44,7 +42,7 @@
   /**
    * Called when this rewinder is no longer needed and can be cleaned up.
    *
-   * <p> The underlying data may still be in use and should not be closed or invalidated. </p>
+   * <p>The underlying data may still be in use and should not be closed or invalidated.
    */
   void cleanup();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
index 85df91b5f..93ba7237a 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -9,55 +9,57 @@
  * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
  * image data.
  *
- * <p>This class assumes that the wrapped stream contains an image format that can contain
- * exif information and performs no verification. </p>
+ * <p>This class assumes that the wrapped stream contains an image format that can contain exif
+ * information and performs no verification.
  */
 public final class ExifOrientationStream extends FilterInputStream {
   /** Allow two bytes for the file format. */
   private static final int SEGMENT_START_POSITION = 2;
-  private static final byte[] EXIF_SEGMENT = new byte[] {
-      /* segment start id. */
-      (byte) 0xFF,
-      /* segment type. */
-      (byte) 0xE1,
-      /* segmentLength. */
-      0x00,
-      (byte) 0x1C,
-      /* exif identifier. */
-      0x45,
-      0x78,
-      0x69,
-      0x66,
-      0x00,
-      0x00,
-      /* motorola byte order (big endian). */
-      (byte) 0x4D,
-      (byte) 0x4D,
-      /* filler? */
-      0x00,
-      0x00,
-      /* first id offset. */
-      0x00,
-      0x00,
-      0x00,
-      0x08,
-      /* tagCount. */
-      0x00,
-      0x01,
-      /* exif tag type. */
-      0x01,
-      0x12,
-      /* 2 byte format. */
-      0x00,
-      0x02,
-      /* component count. */
-      0x00,
-      0x00,
-      0x00,
-      0x01,
-      /* 2 byte orientation value, the first byte of which is always 0. */
-      0x00,
-  };
+
+  private static final byte[] EXIF_SEGMENT =
+      new byte[] {
+        /* segment start id. */
+        (byte) 0xFF,
+        /* segment type. */
+        (byte) 0xE1,
+        /* segmentLength. */
+        0x00,
+        (byte) 0x1C,
+        /* exif identifier. */
+        0x45,
+        0x78,
+        0x69,
+        0x66,
+        0x00,
+        0x00,
+        /* motorola byte order (big endian). */
+        (byte) 0x4D,
+        (byte) 0x4D,
+        /* filler? */
+        0x00,
+        0x00,
+        /* first id offset. */
+        0x00,
+        0x00,
+        0x00,
+        0x08,
+        /* tagCount. */
+        0x00,
+        0x01,
+        /* exif tag type. */
+        0x01,
+        0x12,
+        /* 2 byte format. */
+        0x00,
+        0x02,
+        /* component count. */
+        0x00,
+        0x00,
+        0x00,
+        0x01,
+        /* 2 byte orientation value, the first byte of which is always 0. */
+        0x00,
+      };
   private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
   private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
   private final byte orientation;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 176f206d9..19ae036d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -5,9 +5,7 @@
 import android.support.annotation.NonNull;
 import java.io.IOException;
 
-/**
- * Fetches an {@link android.os.ParcelFileDescriptor} for an asset path.
- */
+/** Fetches an {@link android.os.ParcelFileDescriptor} for an asset path. */
 public class FileDescriptorAssetPathFetcher extends AssetPathFetcher<ParcelFileDescriptor> {
   public FileDescriptorAssetPathFetcher(AssetManager assetManager, String assetPath) {
     super(assetManager, assetPath);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 2a159b92b..254bd6798 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -8,9 +8,7 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
-/**
- * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
- */
+/** Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}. */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
   public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
     super(contentResolver, uri);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index e8f914b6e..f88f142ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -18,18 +18,15 @@
 import java.net.URL;
 import java.util.Map;
 
-/**
- * A DataFetcher that retrieves an {@link java.io.InputStream} for a Url.
- */
+/** A DataFetcher that retrieves an {@link java.io.InputStream} for a Url. */
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
+
   @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
-  /**
-   * Returned when a connection error prevented us from receiving an http error.
-   */
+  /** Returned when a connection error prevented us from receiving an http error. */
   private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
@@ -52,8 +49,8 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
   }
 
   @Override
-  public void loadData(@NonNull Priority priority,
-      @NonNull DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
     try {
       InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
@@ -70,8 +67,8 @@ public void loadData(@NonNull Priority priority,
     }
   }
 
-  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
-      Map<String, String> headers) throws IOException {
+  private InputStream loadDataWithRedirects(
+      URL url, int redirects, URL lastUrl, Map<String, String> headers) throws IOException {
     if (redirects >= MAXIMUM_REDIRECTS) {
       throw new HttpException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
     } else {
@@ -80,7 +77,6 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       try {
         if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
           throw new HttpException("In re-direct loop");
-
         }
       } catch (URISyntaxException e) {
         // Do nothing, this is best effort.
@@ -192,7 +188,7 @@ public DataSource getDataSource() {
   private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
 
     @Synthetic
-    DefaultHttpUrlConnectionFactory() { }
+    DefaultHttpUrlConnectionFactory() {}
 
     @Override
     public HttpURLConnection build(URL url) throws IOException {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 68ee75305..c784c80d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -14,7 +14,7 @@
  * android.net.Uri} pointing to a local resource.
  *
  * @param <T> The type of data that will obtained for the given uri (For example, {@link
- *            java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
+ *     java.io.InputStream} or {@link android.os.ParcelFileDescriptor}.
  */
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
@@ -26,8 +26,8 @@
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
    * @param contentResolver Any {@link android.content.ContentResolver}.
-   * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
-   *                by {@link ContentResolver#openInputStream(android.net.Uri)}
+   * @param uri A Uri pointing to a local asset. This load will fail if the uri isn't openable by
+   *     {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
   // Public API.
@@ -38,8 +38,8 @@ public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
   }
 
   @Override
-  public final void loadData(@NonNull Priority priority,
-      @NonNull DataCallback<? super T> callback) {
+  public final void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
@@ -84,11 +84,10 @@ protected abstract T loadResource(Uri uri, ContentResolver contentResolver)
   /**
    * Closes the concrete data type if necessary.
    *
-   * <p> Note - We can't rely on the closeable interface because it was added after our min API
-   * level. See issue #157. </p>
+   * <p>Note - We can't rely on the closeable interface because it was added after our min API
+   * level. See issue #157.
    *
    * @param data The data to close.
    */
   protected abstract void close(T data) throws IOException;
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index aaad13214..409da8c12 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -5,9 +5,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Fetches an {@link java.io.InputStream} for an asset path.
- */
+/** Fetches an {@link java.io.InputStream} for an asset path. */
 public class StreamAssetPathFetcher extends AssetPathFetcher<InputStream> {
   public StreamAssetPathFetcher(AssetManager assetManager, String assetPath) {
     super(assetManager, assetPath);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index 758e4a543..65ab500fb 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -9,35 +9,25 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
- */
+/** Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}. */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  /**
-   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
-   */
+  /** A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537) */
   private static final int ID_CONTACTS_LOOKUP = 1;
-  /**
-   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
-   */
+  /** A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo) */
   private static final int ID_CONTACTS_THUMBNAIL = 2;
-  /**
-   * A contact uri (e.g. content://com.android.contacts/contacts/38)
-   */
+  /** A contact uri (e.g. content://com.android.contacts/contacts/38) */
   private static final int ID_CONTACTS_CONTACT = 3;
   /**
-   * A contact display photo (high resolution) uri
-   * (e.g. content://com.android.contacts/5/display_photo)
+   * A contact display photo (high resolution) uri (e.g.
+   * content://com.android.contacts/5/display_photo)
    */
   private static final int ID_CONTACTS_PHOTO = 4;
   /**
-   * Uri for optimized search of phones by number
-   * (e.g. content://com.android.contacts/phone_lookup/232323232
+   * Uri for optimized search of phones by number (e.g.
+   * content://com.android.contacts/phone_lookup/232323232
    */
   private static final int ID_LOOKUP_BY_PHONE = 5;
-  /**
-   * Match the incoming Uri for special cases which we can handle nicely.
-   */
+  /** Match the incoming Uri for special cases which we can handle nicely. */
   private static final UriMatcher URI_MATCHER;
 
   static {
@@ -64,7 +54,6 @@ protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
     return inputStream;
   }
 
-
   private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
     switch (URI_MATCHER.match(uri)) {
@@ -87,8 +76,8 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
   }
 
   private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
-    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
-        true /*preferHighres*/);
+    return ContactsContract.Contacts.openContactPhotoInputStream(
+        contentResolver, contactUri, true /*preferHighres*/);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
index d7f7e44af..bd00853e1 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -5,9 +5,7 @@
 import android.provider.MediaStore;
 import com.bumptech.glide.request.target.Target;
 
-/**
- * Utility classes for interacting with the media store.
- */
+/** Utility classes for interacting with the media store. */
 public final class MediaStoreUtil {
   private static final int MINI_THUMB_WIDTH = 512;
   private static final int MINI_THUMB_HEIGHT = 384;
@@ -17,7 +15,8 @@ private MediaStoreUtil() {
   }
 
   public static boolean isMediaStoreUri(Uri uri) {
-    return uri != null && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
+    return uri != null
+        && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
         && MediaStore.AUTHORITY.equals(uri.getAuthority());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 3b90b0a6b..380d6797d 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -39,9 +39,12 @@ public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
-        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
-        context.getContentResolver());
+    ThumbnailStreamOpener opener =
+        new ThumbnailStreamOpener(
+            Glide.get(context).getRegistry().getImageHeaderParsers(),
+            query,
+            byteArrayPool,
+            context.getContentResolver());
     return new ThumbFetcher(uri, opener);
   }
 
@@ -52,8 +55,8 @@ private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query
   }
 
   @Override
-  public void loadData(@NonNull Priority priority,
-      @NonNull DataCallback<? super InputStream> callback) {
+  public void loadData(
+      @NonNull Priority priority, @NonNull DataCallback<? super InputStream> callback) {
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
@@ -117,12 +120,14 @@ public DataSource getDataSource() {
       this.contentResolver = contentResolver;
     }
 
-    private static final String[] PATH_PROJECTION = {
-        MediaStore.Video.Thumbnails.DATA
-    };
+    private static final String[] PATH_PROJECTION = {MediaStore.Video.Thumbnails.DATA};
     private static final String PATH_SELECTION =
-        MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
-            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+        MediaStore.Video.Thumbnails.KIND
+            + " = "
+            + MediaStore.Video.Thumbnails.MINI_KIND
+            + " AND "
+            + MediaStore.Video.Thumbnails.VIDEO_ID
+            + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
@@ -136,7 +141,6 @@ public Cursor query(Uri uri) {
     }
   }
 
-
   static class ImageThumbnailQuery implements ThumbnailQuery {
 
     private final ContentResolver contentResolver;
@@ -146,11 +150,15 @@ public Cursor query(Uri uri) {
     }
 
     private static final String[] PATH_PROJECTION = {
-        MediaStore.Images.Thumbnails.DATA,
+      MediaStore.Images.Thumbnails.DATA,
     };
     private static final String PATH_SELECTION =
-        MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
-            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+        MediaStore.Images.Thumbnails.KIND
+            + " = "
+            + MediaStore.Images.Thumbnails.MINI_KIND
+            + " AND "
+            + MediaStore.Images.Thumbnails.IMAGE_ID
+            + " = ?";
 
     @Override
     public Cursor query(Uri uri) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index ed01c158d..52dad9b4c 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -27,7 +27,9 @@
   private final List<ImageHeaderParser> parsers;
 
   ThumbnailStreamOpener(
-      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      List<ImageHeaderParser> parsers,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
       ContentResolver contentResolver) {
     this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
@@ -82,7 +84,9 @@ public InputStream open(Uri uri) throws FileNotFoundException {
     try {
       return contentResolver.openInputStream(thumbnailUri);
       // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
-    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+    } catch (
+        @SuppressWarnings("PMD.AvoidCatchingNPE")
+        NullPointerException e) {
       throw (FileNotFoundException)
           new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 16e548732..657e13b65 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -20,15 +20,13 @@
 final class ActiveResources {
   private final boolean isActiveResourceRetentionAllowed;
   private final Executor monitorClearedResourcesExecutor;
-  @VisibleForTesting
-  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  @VisibleForTesting final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
   private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();
 
   private ResourceListener listener;
 
   private volatile boolean isShutdown;
-  @Nullable
-  private volatile DequeuedResourceCallback cb;
+  @Nullable private volatile DequeuedResourceCallback cb;
 
   ActiveResources(boolean isActiveResourceRetentionAllowed) {
     this(
@@ -130,7 +128,8 @@ void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
   }
 
   @SuppressWarnings("WeakerAccess")
-  @Synthetic void cleanReferenceQueue() {
+  @Synthetic
+  void cleanReferenceQueue() {
     while (!isShutdown) {
       try {
         ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
@@ -169,10 +168,18 @@ void shutdown() {
 
   @VisibleForTesting
   static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
-    @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    final Key key;
 
-    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    final boolean isCacheable;
+
+    @Nullable
+    @SuppressWarnings("WeakerAccess")
+    @Synthetic
+    Resource<?> resource;
 
     @Synthetic
     @SuppressWarnings("WeakerAccess")
@@ -185,7 +192,8 @@ void shutdown() {
       this.key = Preconditions.checkNotNull(key);
       this.resource =
           referent.isMemoryCacheable() && isActiveResourceRetentionAllowed
-              ? Preconditions.checkNotNull(referent.getResource()) : null;
+              ? Preconditions.checkNotNull(referent.getResource())
+              : null;
       isCacheable = referent.isMemoryCacheable();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index bc19d18eb..46942a432 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -13,8 +13,7 @@
  * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
  * containing original unmodified source data.
  */
-class DataCacheGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object> {
+class DataCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
 
   private final List<Key> cacheKeys;
   private final DecodeHelper<?> helper;
@@ -68,8 +67,8 @@ public boolean startNext() {
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
       loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+          modelLoader.buildLoadData(
+              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index 5177438a9..54cede7b7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -4,9 +4,7 @@
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
-/**
- * A cache key for original source data + any requested signature.
- */
+/** A cache key for original source data + any requested signature. */
 final class DataCacheKey implements Key {
 
   private final Key sourceKey;
@@ -39,10 +37,7 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "DataCacheKey{"
-        + "sourceKey=" + sourceKey
-        + ", signature=" + signature
-        + '}';
+    return "DataCacheKey{" + "sourceKey=" + sourceKey + ", signature=" + signature + '}';
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index 59f39bd00..2f6476417 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -7,13 +7,12 @@
 import java.io.File;
 
 /**
- * Writes original source data or downsampled/transformed resource data to cache using the
- * provided {@link com.bumptech.glide.load.Encoder} or
- * {@link com.bumptech.glide.load.ResourceEncoder} and the given data or
- * {@link com.bumptech.glide.load.engine.Resource}.
+ * Writes original source data or downsampled/transformed resource data to cache using the provided
+ * {@link com.bumptech.glide.load.Encoder} or {@link com.bumptech.glide.load.ResourceEncoder} and
+ * the given data or {@link com.bumptech.glide.load.engine.Resource}.
  *
  * @param <DataType> The type of data that will be encoded (InputStream, ByteBuffer,
- *                  Resource<Bitmap> etc).
+ *     Resource<Bitmap> etc).
  */
 class DataCacheWriter<DataType> implements DiskCache.Writer {
   private final Encoder<DataType> encoder;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index ae7cddb8d..2049319d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -11,14 +11,12 @@
  */
 interface DataFetcherGenerator {
   /**
-   * Called when the generator has finished loading data from a
-   * {@link com.bumptech.glide.load.data.DataFetcher}.
+   * Called when the generator has finished loading data from a {@link
+   * com.bumptech.glide.load.data.DataFetcher}.
    */
   interface FetcherReadyCallback {
 
-    /**
-     * Requests that we call startNext() again on a Glide owned thread.
-     */
+    /** Requests that we call startNext() again on a Glide owned thread. */
     void reschedule();
 
     /**
@@ -30,8 +28,12 @@
      * @param dataSource The data source we were loading from.
      * @param attemptedKey The key we were loading data from (may be an alternate).
      */
-    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
-        DataSource dataSource, Key attemptedKey);
+    void onDataFetcherReady(
+        Key sourceKey,
+        @Nullable Object data,
+        DataFetcher<?> fetcher,
+        DataSource dataSource,
+        Key attemptedKey);
 
     /**
      * Notifies the callback when the load fails.
@@ -41,20 +43,20 @@ void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fet
      * @param fetcher The fetcher we were loading from.
      * @param dataSource The data source we were loading from.
      */
-    void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
-        DataSource dataSource);
+    void onDataFetcherFailed(
+        Key attemptedKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource);
   }
 
   /**
-   * Attempts to a single new {@link com.bumptech.glide.load.data.DataFetcher} and returns true if
-   * a {@link com.bumptech.glide.load.data.DataFetcher} was started, and false otherwise.
+   * Attempts to a single new {@link com.bumptech.glide.load.data.DataFetcher} and returns true if a
+   * {@link com.bumptech.glide.load.data.DataFetcher} was started, and false otherwise.
    */
   boolean startNext();
 
   /**
    * Attempts to cancel the currently running fetcher.
    *
-   * <p> This will be called on the main thread and should complete quickly. </p>
+   * <p>This will be called on the main thread and should complete quickly.
    */
   void cancel();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 6a4283f1c..b7dbebcc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -72,7 +72,6 @@
     this.transformations = transformations;
     this.isTransformationRequired = isTransformationRequired;
     this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
-
   }
 
   void clear() {
@@ -133,7 +132,8 @@ ArrayPool getArrayPool() {
   }
 
   List<Class<?>> getRegisteredResourceClasses() {
-    return glideContext.getRegistry()
+    return glideContext
+        .getRegistry()
         .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
   }
 
@@ -164,7 +164,9 @@ boolean isScaleOnlyOrNoTransform() {
     if (result == null) {
       if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
-            "Missing transformation for " + resourceClass + ". If you wish to"
+            "Missing transformation for "
+                + resourceClass
+                + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
       } else {
         return UnitTransformation.get();
@@ -206,8 +208,7 @@ boolean isSourceKey(Key key) {
       //noinspection ForLoopReplaceableByForEach to improve perf
       for (int i = 0, size = modelLoaders.size(); i < size; i++) {
         ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
-        LoadData<?> current =
-            modelLoader.buildLoadData(model, width, height, options);
+        LoadData<?> current = modelLoader.buildLoadData(model, width, height, options);
         if (current != null) {
           loadData.add(current);
         }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 0f05483e0..8281061b3 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -33,12 +33,13 @@
  * <p>Note: this class has a natural ordering that is inconsistent with equals.
  *
  * @param <R> The type of resource that will be transcoded from the decoded and transformed
- *            resource.
+ *     resource.
  */
-class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,
-    Runnable,
-    Comparable<DecodeJob<?>>,
-    Poolable {
+class DecodeJob<R>
+    implements DataFetcherGenerator.FetcherReadyCallback,
+        Runnable,
+        Comparable<DecodeJob<?>>,
+        Poolable {
   private static final String TAG = "DecodeJob";
 
   private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
@@ -143,7 +144,7 @@ boolean willDecodeFromCache() {
    * Called when this object is no longer in use externally.
    *
    * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
-   *                           neither in progress nor will ever be called again.
+   *     neither in progress nor will ever be called again.
    */
   void release(boolean isRemovedFromQueue) {
     if (releaseManager.release(isRemovedFromQueue)) {
@@ -161,9 +162,7 @@ private void onEncodeComplete() {
     }
   }
 
-  /**
-   * Called when the load has failed due to a an error or a series of errors.
-   */
+  /** Called when the load has failed due to a an error or a series of errors. */
   private void onLoadFailed() {
     if (releaseManager.onFailed()) {
       releaseInternal();
@@ -245,9 +244,10 @@ public void run() {
       // loads to silently hang forever, a case that's especially bad for users using Futures on
       // background threads.
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "DecodeJob threw unexpectedly"
-            + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, t);
+        Log.d(
+            TAG,
+            "DecodeJob threw unexpectedly" + ", isCancelled: " + isCancelled + ", stage: " + stage,
+            t);
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
@@ -305,7 +305,8 @@ private void runGenerators() {
     currentThread = Thread.currentThread();
     startFetchTime = LogTime.getLogTime();
     boolean isStarted = false;
-    while (!isCancelled && currentGenerator != null
+    while (!isCancelled
+        && currentGenerator != null
         && !(isStarted = currentGenerator.startNext())) {
       stage = getNextStage(stage);
       currentGenerator = getNextGenerator();
@@ -349,10 +350,12 @@ private Stage getNextStage(Stage current) {
     switch (current) {
       case INITIALIZE:
         return diskCacheStrategy.decodeCachedResource()
-            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
+            ? Stage.RESOURCE_CACHE
+            : getNextStage(Stage.RESOURCE_CACHE);
       case RESOURCE_CACHE:
         return diskCacheStrategy.decodeCachedData()
-            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
+            ? Stage.DATA_CACHE
+            : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
         // Skip loading from source if the user opted to only retrieve the resource from cache.
         return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
@@ -371,8 +374,8 @@ public void reschedule() {
   }
 
   @Override
-  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
-      DataSource dataSource, Key attemptedKey) {
+  public void onDataFetcherReady(
+      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
     this.currentSourceKey = sourceKey;
     this.currentData = data;
     this.currentFetcher = fetcher;
@@ -392,8 +395,8 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
   }
 
   @Override
-  public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
-      DataSource dataSource) {
+  public void onDataFetcherFailed(
+      Key attemptedKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource) {
     fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
@@ -408,10 +411,15 @@ public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fe
 
   private void decodeFromRetrievedData() {
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logWithTimeAndKey("Retrieved data", startFetchTime,
-          "data: " + currentData
-              + ", cache key: " + currentSourceKey
-              + ", fetcher: " + currentFetcher);
+      logWithTimeAndKey(
+          "Retrieved data",
+          startFetchTime,
+          "data: "
+              + currentData
+              + ", cache key: "
+              + currentSourceKey
+              + ", fetcher: "
+              + currentFetcher);
     }
     Resource<R> resource = null;
     try {
@@ -456,8 +464,8 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     onEncodeComplete();
   }
 
-  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
-      DataSource dataSource) throws GlideException {
+  private <Data> Resource<R> decodeFromData(
+      DataFetcher<?> fetcher, Data data, DataSource dataSource) throws GlideException {
     try {
       if (data == null) {
         return null;
@@ -506,8 +514,9 @@ private Options getOptionsWithHardwareConfig(DataSource dataSource) {
     return options;
   }
 
-  private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
-      LoadPath<Data, ResourceType, R> path) throws GlideException {
+  private <Data, ResourceType> Resource<R> runLoadPath(
+      Data data, DataSource dataSource, LoadPath<Data, ResourceType, R> path)
+      throws GlideException {
     Options options = getOptionsWithHardwareConfig(dataSource);
     DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
     try {
@@ -524,9 +533,16 @@ private void logWithTimeAndKey(String message, long startTime) {
   }
 
   private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
-    Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
-        + (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
-        + Thread.currentThread().getName());
+    Log.v(
+        TAG,
+        message
+            + " in "
+            + LogTime.getElapsedMillis(startTime)
+            + ", load key: "
+            + loadKey
+            + (extraArgs != null ? ", " + extraArgs : "")
+            + ", thread: "
+            + Thread.currentThread().getName());
   }
 
   @NonNull
@@ -537,8 +553,7 @@ public StateVerifier getVerifier() {
 
   @Synthetic
   @NonNull
-  <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
-      @NonNull Resource<Z> decoded) {
+  <Z> Resource<Z> onResourceDecoded(DataSource dataSource, @NonNull Resource<Z> decoded) {
     @SuppressWarnings("unchecked")
     Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
     Transformation<Z> appliedTransformation = null;
@@ -564,8 +579,8 @@ public StateVerifier getVerifier() {
 
     Resource<Z> result = transformed;
     boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-    if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-        encodeStrategy)) {
+    if (diskCacheStrategy.isResourceCacheable(
+        isFromAlternateCacheKey, dataSource, encodeStrategy)) {
       if (encoder == null) {
         throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
       }
@@ -622,7 +637,7 @@ public StateVerifier getVerifier() {
     private boolean isFailed;
 
     @Synthetic
-    ReleaseManager() { }
+    ReleaseManager() {}
 
     synchronized boolean release(boolean isRemovedFromQueue) {
       isReleased = true;
@@ -660,7 +675,7 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     private LockedResource<Z> toEncode;
 
     @Synthetic
-    DeferredEncodeManager() { }
+    DeferredEncodeManager() {}
 
     // We just need the encoder and resource type to match, which this will enforce.
     @SuppressWarnings("unchecked")
@@ -673,8 +688,9 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     void encode(DiskCacheProvider diskCacheProvider, Options options) {
       GlideTrace.beginSection("DecodeJob.encode");
       try {
-        diskCacheProvider.getDiskCache().put(key,
-            new DataCacheWriter<>(encoder, toEncode, options));
+        diskCacheProvider
+            .getDiskCache()
+            .put(key, new DataCacheWriter<>(encoder, toEncode, options));
       } finally {
         toEncode.unlock();
         GlideTrace.endSection();
@@ -705,15 +721,11 @@ void clear() {
     DiskCache getDiskCache();
   }
 
-  /**
-   * Why we're being executed again.
-   */
+  /** Why we're being executed again. */
   private enum RunReason {
     /** The first time we've been submitted. */
     INITIALIZE,
-    /**
-     * We want to switch from the disk cache service to the source executor.
-     */
+    /** We want to switch from the disk cache service to the source executor. */
     SWITCH_TO_SOURCE_SERVICE,
     /**
      * We retrieved some data on a thread we don't own and want to switch back to our thread to
@@ -722,9 +734,7 @@ void clear() {
     DECODE_DATA,
   }
 
-  /**
-   * Where we're trying to decode data from.
-   */
+  /** Where we're trying to decode data from. */
   private enum Stage {
     /** The initial stage. */
     INITIALIZE,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index 919dc7584..c9c66a537 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -13,12 +13,12 @@
 import java.util.List;
 
 /**
- * Attempts to decode and transcode  resource type from a given data type.
+ * Attempts to decode and transcode resource type from a given data type.
  *
- * @param <DataType>     The type of data ResourceType that will be decoded from.
+ * @param <DataType> The type of data ResourceType that will be decoded from.
  * @param <ResourceType> The type of intermediate resource that will be decoded.
- * @param <Transcode>    The final type of resource that will be transcoded from ResourceType and
- *                       returned to the caller.
+ * @param <Transcode> The final type of resource that will be transcoded from ResourceType and
+ *     returned to the caller.
  */
 public class DecodePath<DataType, ResourceType, Transcode> {
   private static final String TAG = "DecodePath";
@@ -28,28 +28,43 @@
   private final Pool<List<Throwable>> listPool;
   private final String failureMessage;
 
-  public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
+  public DecodePath(
+      Class<DataType> dataClass,
+      Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder,
+      Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
     this.listPool = listPool;
-    failureMessage = "Failed DecodePath{" + dataClass.getSimpleName() + "->"
-        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+    failureMessage =
+        "Failed DecodePath{"
+            + dataClass.getSimpleName()
+            + "->"
+            + resourceClass.getSimpleName()
+            + "->"
+            + transcodeClass.getSimpleName()
+            + "}";
   }
 
-  public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
-      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+  public Resource<Transcode> decode(
+      DataRewinder<DataType> rewinder,
+      int width,
+      int height,
+      @NonNull Options options,
+      DecodeCallback<ResourceType> callback)
+      throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
     return transcoder.transcode(transformed, options);
   }
 
   @NonNull
-  private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
-      int height, @NonNull Options options) throws GlideException {
+  private Resource<ResourceType> decodeResource(
+      DataRewinder<DataType> rewinder, int width, int height, @NonNull Options options)
+      throws GlideException {
     List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
     try {
       return decodeResourceWithList(rewinder, width, height, options, exceptions);
@@ -59,8 +74,13 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
   }
 
   @NonNull
-  private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
-      int height, @NonNull Options options, List<Throwable> exceptions) throws GlideException {
+  private Resource<ResourceType> decodeResourceWithList(
+      DataRewinder<DataType> rewinder,
+      int width,
+      int height,
+      @NonNull Options options,
+      List<Throwable> exceptions)
+      throws GlideException {
     Resource<ResourceType> result = null;
     //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decoders.size(); i < size; i++) {
@@ -93,8 +113,14 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "DecodePath{" + " dataClass=" + dataClass + ", decoders=" + decoders + ", transcoder="
-        + transcoder + '}';
+    return "DecodePath{"
+        + " dataClass="
+        + dataClass
+        + ", decoders="
+        + decoders
+        + ", transcoder="
+        + transcoder
+        + '}';
   }
 
   interface DecodeCallback<ResourceType> {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index b110e3121..b5b1379ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -3,147 +3,145 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.EncodeStrategy;
 
-/**
- * Set of available caching strategies for media.
- */
+/** Set of available caching strategies for media. */
 public abstract class DiskCacheStrategy {
 
   /**
-   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with
-   * {@link #RESOURCE} only.
+   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with {@link
+   * #RESOURCE} only.
    */
-  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource == DataSource.REMOTE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
+  public static final DiskCacheStrategy ALL =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource == DataSource.REMOTE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return dataSource != DataSource.RESOURCE_DISK_CACHE
+              && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
+
+  /** Saves no data to cache. */
+  public static final DiskCacheStrategy NONE =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return false;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return false;
+        }
+      };
+
+  /** Writes retrieved data directly to the disk cache before it's decoded. */
+  public static final DiskCacheStrategy DATA =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return false;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
+
+  /** Writes resources to disk after they've been decoded. */
+  public static final DiskCacheStrategy RESOURCE =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return false;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return dataSource != DataSource.RESOURCE_DISK_CACHE
+              && dataSource != DataSource.MEMORY_CACHE;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return false;
+        }
+      };
 
   /**
-   * Saves no data to cache.
+   * Tries to intelligently choose a strategy based on the data source of the {@link
+   * com.bumptech.glide.load.data.DataFetcher} and the {@link
+   * com.bumptech.glide.load.EncodeStrategy} of the {@link com.bumptech.glide.load.ResourceEncoder}
+   * (if an {@link com.bumptech.glide.load.ResourceEncoder} is available).
    */
-  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return false;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return false;
-    }
-  };
-
-  /**
-   * Writes retrieved data directly to the disk cache before it's decoded.
-   */
-  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource != DataSource.DATA_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return false;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
-
-  /**
-   * Writes resources to disk after they've been decoded.
-   */
-  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return false;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return dataSource != DataSource.RESOURCE_DISK_CACHE && dataSource != DataSource.MEMORY_CACHE;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return false;
-    }
-  };
-
-  /**
-   * Tries to intelligently choose a strategy based on the data source of the
-   * {@link com.bumptech.glide.load.data.DataFetcher} and the
-   * {@link com.bumptech.glide.load.EncodeStrategy} of the
-   * {@link com.bumptech.glide.load.ResourceEncoder} (if an
-   * {@link com.bumptech.glide.load.ResourceEncoder} is available).
-   */
-  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {
-    @Override
-    public boolean isDataCacheable(DataSource dataSource) {
-      return dataSource == DataSource.REMOTE;
-    }
-
-    @Override
-    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,
-        EncodeStrategy encodeStrategy) {
-      return ((isFromAlternateCacheKey && dataSource == DataSource.DATA_DISK_CACHE)
-          || dataSource == DataSource.LOCAL)
-          && encodeStrategy == EncodeStrategy.TRANSFORMED;
-    }
-
-    @Override
-    public boolean decodeCachedResource() {
-      return true;
-    }
-
-    @Override
-    public boolean decodeCachedData() {
-      return true;
-    }
-  };
+  public static final DiskCacheStrategy AUTOMATIC =
+      new DiskCacheStrategy() {
+        @Override
+        public boolean isDataCacheable(DataSource dataSource) {
+          return dataSource == DataSource.REMOTE;
+        }
+
+        @Override
+        public boolean isResourceCacheable(
+            boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) {
+          return ((isFromAlternateCacheKey && dataSource == DataSource.DATA_DISK_CACHE)
+                  || dataSource == DataSource.LOCAL)
+              && encodeStrategy == EncodeStrategy.TRANSFORMED;
+        }
+
+        @Override
+        public boolean decodeCachedResource() {
+          return true;
+        }
+
+        @Override
+        public boolean decodeCachedData() {
+          return true;
+        }
+      };
 
   /**
    * Returns true if this request should cache the original unmodified data.
@@ -156,22 +154,18 @@ public boolean decodeCachedData() {
    * Returns true if this request should cache the final transformed resource.
    *
    * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an
-   *                                alternative, rather than the primary, cache key.
+   *     alternative, rather than the primary, cache key.
    * @param dataSource Indicates where the data used to decode the resource was originally
-   *                   retrieved.
+   *     retrieved.
    * @param encodeStrategy The {@link EncodeStrategy} the {@link
-   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
+   *     com.bumptech.glide.load.ResourceEncoder} will use to encode the resource.
    */
-  public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,
-      DataSource dataSource, EncodeStrategy encodeStrategy);
+  public abstract boolean isResourceCacheable(
+      boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy);
 
-  /**
-   * Returns true if this request should attempt to decode cached resource data.
-   */
+  /** Returns true if this request should attempt to decode cached resource data. */
   public abstract boolean decodeCachedResource();
 
-  /**
-   * Returns true if this request should attempt to decode cached source data.
-   */
+  /** Returns true if this request should attempt to decode cached source data. */
   public abstract boolean decodeCachedData();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 54697616d..3f887fc06 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -25,12 +25,11 @@
 import java.util.Map;
 import java.util.concurrent.Executor;
 
-/**
- * Responsible for starting loads and managing active and cached resources.
- */
-public class Engine implements EngineJobListener,
-    MemoryCache.ResourceRemovedListener,
-    EngineResource.ResourceListener {
+/** Responsible for starting loads and managing active and cached resources. */
+public class Engine
+    implements EngineJobListener,
+        MemoryCache.ResourceRemovedListener,
+        EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
   private static final boolean VERBOSE_IS_LOGGABLE = Log.isLoggable(TAG, Log.VERBOSE);
@@ -68,7 +67,8 @@ public Engine(
   }
 
   @VisibleForTesting
-  Engine(MemoryCache cache,
+  Engine(
+      MemoryCache cache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
@@ -174,8 +174,16 @@ public Engine(
       Executor callbackExecutor) {
     long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;
 
-    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
-        resourceClass, transcodeClass, options);
+    EngineKey key =
+        keyFactory.buildKey(
+            model,
+            signature,
+            width,
+            height,
+            transformations,
+            resourceClass,
+            transcodeClass,
+            options);
 
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
@@ -282,8 +290,9 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(
-          cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
+      result =
+          new EngineResource<>(
+              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
     }
     return result;
   }
@@ -400,14 +409,18 @@ public DiskCache getDiskCache() {
   @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
-        FactoryPools.threadSafe(JOB_POOL_SIZE,
+
+    @Synthetic
+    final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.threadSafe(
+            JOB_POOL_SIZE,
             new FactoryPools.Factory<DecodeJob<?>>() {
-          @Override
-          public DecodeJob<?> create() {
-            return new DecodeJob<>(diskCacheProvider, pool);
-          }
-        });
+              @Override
+              public DecodeJob<?> create() {
+                return new DecodeJob<>(diskCacheProvider, pool);
+              }
+            });
+
     private int creationOrder;
 
     DecodeJobFactory(DecodeJob.DiskCacheProvider diskCacheProvider) {
@@ -415,7 +428,8 @@ public DiskCache getDiskCache() {
     }
 
     @SuppressWarnings("unchecked")
-    <R> DecodeJob<R> build(GlideContext glideContext,
+    <R> DecodeJob<R> build(
+        GlideContext glideContext,
         Object model,
         EngineKey loadKey,
         Key signature,
@@ -461,7 +475,9 @@ public DiskCache getDiskCache() {
     @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener engineJobListener;
     @Synthetic final ResourceListener resourceListener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool =
+
+    @Synthetic
+    final Pools.Pool<EngineJob<?>> pool =
         FactoryPools.threadSafe(
             JOB_POOL_SIZE,
             new FactoryPools.Factory<EngineJob<?>>() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 0a1846c95..1797c3fa4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -23,8 +23,7 @@
  * A class that manages a load by adding and removing callbacks for for the load and notifying
  * callbacks when the load completes.
  */
-class EngineJob<R> implements DecodeJob.Callback<R>,
-    Poolable {
+class EngineJob<R> implements DecodeJob.Callback<R>, Poolable {
   private static final EngineResourceFactory DEFAULT_FACTORY = new EngineResourceFactory();
 
   @SuppressWarnings("WeakerAccess")
@@ -126,9 +125,8 @@
 
   public synchronized void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache()
-        ? diskCacheExecutor
-        : getActiveSourceExecutor();
+    GlideExecutor executor =
+        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
@@ -192,7 +190,8 @@ boolean onlyRetrieveFromCache() {
 
   private GlideExecutor getActiveSourceExecutor() {
     return useUnlimitedSourceGeneratorPool
-        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
+        ? sourceUnlimitedExecutor
+        : (useAnimationPool ? animationExecutor : sourceExecutor);
   }
 
   // Exposed for testing.
@@ -217,8 +216,11 @@ private boolean isDone() {
 
   // We have to post Runnables in a loop. Typically there will be very few callbacks. AccessorMethod
   // seems to be a false positive
-  @SuppressWarnings(
-          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"})
+  @SuppressWarnings({
+    "WeakerAccess",
+    "PMD.AvoidInstantiatingObjectsInLoops",
+    "PMD.AccessorMethodGeneration"
+  })
   @Synthetic
   void notifyCallbacksOfResult() {
     ResourceCallbacksAndExecutors copy;
@@ -327,8 +329,11 @@ public void reschedule(DecodeJob<?> job) {
 
   // We have to post Runnables in a loop. Typically there will be very few callbacks. Acessor method
   // warning seems to be false positive.
-  @SuppressWarnings(
-          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"})
+  @SuppressWarnings({
+    "WeakerAccess",
+    "PMD.AvoidInstantiatingObjectsInLoops",
+    "PMD.AccessorMethodGeneration"
+  })
   @Synthetic
   void notifyCallbacksOfException() {
     ResourceCallbacksAndExecutors copy;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 9f16b6115..dcf580747 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -8,9 +8,7 @@
 import java.security.MessageDigest;
 import java.util.Map;
 
-/**
- * An in memory only cache key used to multiplex loads.
- */
+/** An in memory only cache key used to multiplex loads. */
 class EngineKey implements Key {
   private final Object model;
   private final int width;
@@ -77,15 +75,24 @@ public int hashCode() {
   @Override
   public String toString() {
     return "EngineKey{"
-        + "model=" + model
-        + ", width=" + width
-        + ", height=" + height
-        + ", resourceClass=" + resourceClass
-        + ", transcodeClass=" + transcodeClass
-        + ", signature=" + signature
-        + ", hashCode=" + hashCode
-        + ", transformations=" + transformations
-        + ", options=" + options
+        + "model="
+        + model
+        + ", width="
+        + width
+        + ", height="
+        + height
+        + ", resourceClass="
+        + resourceClass
+        + ", transcodeClass="
+        + transcodeClass
+        + ", signature="
+        + signature
+        + ", hashCode="
+        + hashCode
+        + ", transformations="
+        + transformations
+        + ", options="
+        + options
         + '}';
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index 05e7a55a0..e1f4993b4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -8,10 +8,16 @@
 class EngineKeyFactory {
 
   @SuppressWarnings("rawtypes")
-  EngineKey buildKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
-    return new EngineKey(model, signature, width, height, transformations, resourceClass,
-        transcodeClass, options);
+  EngineKey buildKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
+    return new EngineKey(
+        model, signature, width, height, transformations, resourceClass, transcodeClass, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 4db3a1db7..3c0ee4b75 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -121,12 +121,18 @@ void release() {
   @Override
   public synchronized String toString() {
     return "EngineResource{"
-        + "isMemoryCacheable=" + isMemoryCacheable
-        + ", listener=" + listener
-        + ", key=" + key
-        + ", acquired=" + acquired
-        + ", isRecycled=" + isRecycled
-        + ", resource=" + resource
+        + "isMemoryCacheable="
+        + isMemoryCacheable
+        + ", listener="
+        + listener
+        + ", key="
+        + key
+        + ", acquired="
+        + acquired
+        + ", isRecycled="
+        + isRecycled
+        + ", resource="
+        + resource
         + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index f74488b3e..ec1590afe 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -12,9 +12,7 @@
 import java.util.Collections;
 import java.util.List;
 
-/**
- * An exception with zero or more causes indicating why a load in Glide failed.
- */
+/** An exception with zero or more causes indicating why a load in Glide failed. */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public final class GlideException extends Exception {
@@ -27,8 +25,7 @@
   private DataSource dataSource;
   private Class<?> dataClass;
   private String detailMessage;
-  @Nullable
-  private Exception exception;
+  @Nullable private Exception exception;
 
   public GlideException(String message) {
     this(message, Collections.<Throwable>emptyList());
@@ -64,8 +61,8 @@ public void setOrigin(@Nullable Exception exception) {
   }
 
   /**
-   * Returns an {@link Exception} with a stack trace that includes where the request originated
-   * (if previously set via {@link #setOrigin(Exception)})
+   * Returns an {@link Exception} with a stack trace that includes where the request originated (if
+   * previously set via {@link #setOrigin(Exception)})
    *
    * <p>This is an experimental API that may be removed in the future.
    */
@@ -87,7 +84,7 @@ public Throwable fillInStackTrace() {
    * Returns a list of causes that are immediate children of this exception.
    *
    * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
-   * causes, and in turn my have been caused by other failures.</p>
+   * causes, and in turn my have been caused by other failures.
    *
    * @see #getRootCauses()
    */
@@ -158,11 +155,12 @@ private void printStackTrace(Appendable appendable) {
   @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    StringBuilder result = new StringBuilder(71)
-        .append(detailMessage)
-        .append(dataClass != null ? ", " + dataClass : "")
-        .append(dataSource != null ? ", " + dataSource : "")
-        .append(key != null ? ", " + key : "");
+    StringBuilder result =
+        new StringBuilder(71)
+            .append(detailMessage)
+            .append(dataClass != null ? ", " + dataClass : "")
+            .append(dataSource != null ? ", " + dataSource : "")
+            .append(key != null ? ", " + key : "");
 
     List<Throwable> rootCauses = getRootCauses();
     if (rootCauses.isEmpty()) {
@@ -173,8 +171,12 @@ public String getMessage() {
       result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
     }
     for (Throwable cause : rootCauses) {
-      result.append('\n')
-          .append(cause.getClass().getName()).append('(').append(cause.getMessage()).append(')');
+      result
+          .append('\n')
+          .append(cause.getClass().getName())
+          .append('(')
+          .append(cause.getMessage())
+          .append(')');
     }
     result.append("\n call GlideException#logRootCauses(String) for more detail");
     return result.toString();
@@ -207,7 +209,8 @@ private static void appendCausesWrapped(List<Throwable> causes, Appendable appen
       throws IOException {
     int size = causes.size();
     for (int i = 0; i < size; i++) {
-      appendable.append("Cause (")
+      appendable
+          .append("Cause (")
           .append(String.valueOf(i + 1))
           .append(" of ")
           .append(String.valueOf(size))
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
index 9b34820b1..15091bf2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -6,9 +6,6 @@
  */
 public interface Initializable {
 
-  /**
-   * Called on a background thread so the {@link Resource} can do some eager initialization.
-   */
+  /** Called on a background thread so the {@link Resource} can do some eager initialization. */
   void initialize();
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index dca8f8952..ea567482e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -11,14 +11,14 @@
 
 /**
  * For a given {@link com.bumptech.glide.load.data.DataFetcher} for a given data class, attempts to
- * fetch the data and then run it through one or more
- * {@link com.bumptech.glide.load.engine.DecodePath}s.
+ * fetch the data and then run it through one or more {@link
+ * com.bumptech.glide.load.engine.DecodePath}s.
  *
- * @param <Data>         The type of data that will be fetched.
+ * @param <Data> The type of data that will be fetched.
  * @param <ResourceType> The type of intermediate resource that will be decoded within one of the
- *                       {@link com.bumptech.glide.load.engine.DecodePath}s.
- * @param <Transcode>    The type of resource that will be returned as the result if the load and
- *                       one of the decode paths succeeds.
+ *     {@link com.bumptech.glide.load.engine.DecodePath}s.
+ * @param <Transcode> The type of resource that will be returned as the result if the load and one
+ *     of the decode paths succeeds.
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
@@ -26,18 +26,32 @@
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
-  public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
+  public LoadPath(
+      Class<Data> dataClass,
+      Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Throwable>> listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths,
+      Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
-    failureMessage = "Failed LoadPath{" + dataClass.getSimpleName() + "->"
-        + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
+    failureMessage =
+        "Failed LoadPath{"
+            + dataClass.getSimpleName()
+            + "->"
+            + resourceClass.getSimpleName()
+            + "->"
+            + transcodeClass.getSimpleName()
+            + "}";
   }
 
-  public Resource<Transcode> load(DataRewinder<Data> rewinder, @NonNull Options options, int width,
-      int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
+  public Resource<Transcode> load(
+      DataRewinder<Data> rewinder,
+      @NonNull Options options,
+      int width,
+      int height,
+      DecodePath.DecodeCallback<ResourceType> decodeCallback)
+      throws GlideException {
     List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
     try {
       return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
@@ -46,10 +60,14 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
     }
   }
 
-  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder,
+  private Resource<Transcode> loadWithExceptionList(
+      DataRewinder<Data> rewinder,
       @NonNull Options options,
-      int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
-      List<Throwable> exceptions) throws GlideException {
+      int width,
+      int height,
+      DecodePath.DecodeCallback<ResourceType> decodeCallback,
+      List<Throwable> exceptions)
+      throws GlideException {
     Resource<Transcode> result = null;
     //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decodePaths.size(); i < size; i++) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 594b26441..177b9a842 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -14,15 +14,16 @@
  * <p>If the resource was recycled prior to {@link #unlock()}, then {@link #unlock()} will also
  * recycle the resource.
  */
-final class LockedResource<Z> implements Resource<Z>,
-    FactoryPools.Poolable {
-  private static final Pools.Pool<LockedResource<?>> POOL = FactoryPools.threadSafe(20,
-      new FactoryPools.Factory<LockedResource<?>>() {
-        @Override
-        public LockedResource<?> create() {
-          return new LockedResource<Object>();
-        }
-      });
+final class LockedResource<Z> implements Resource<Z>, FactoryPools.Poolable {
+  private static final Pools.Pool<LockedResource<?>> POOL =
+      FactoryPools.threadSafe(
+          20,
+          new FactoryPools.Factory<LockedResource<?>>() {
+            @Override
+            public LockedResource<?> create() {
+              return new LockedResource<Object>();
+            }
+          });
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private Resource<Z> toWrap;
   private boolean isLocked;
@@ -38,7 +39,7 @@
 
   @SuppressWarnings("WeakerAccess")
   @Synthetic
-  LockedResource() { }
+  LockedResource() {}
 
   private void init(Resource<Z> toWrap) {
     isRecycled = false;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index 6667381ba..78b262a89 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -9,21 +9,19 @@
  */
 public interface Resource<Z> {
 
-  /**
-   * Returns the {@link Class} of the wrapped resource.
-   */
+  /** Returns the {@link Class} of the wrapped resource. */
   @NonNull
   Class<Z> getResourceClass();
 
   /**
    * Returns an instance of the wrapped resource.
    *
-   * <p> Note - This does not have to be the same instance of the wrapped resource class and in fact
-   * it is often appropriate to return a new instance for each call. For example,
-   * {@link android.graphics.drawable.Drawable Drawable}s should only be used by a single
-   * {@link android.view.View View} at a time so each call to this method for Resources that wrap
-   * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
-   * {@link android.graphics.drawable.Drawable Drawable}. </p>
+   * <p>Note - This does not have to be the same instance of the wrapped resource class and in fact
+   * it is often appropriate to return a new instance for each call. For example, {@link
+   * android.graphics.drawable.Drawable Drawable}s should only be used by a single {@link
+   * android.view.View View} at a time so each call to this method for Resources that wrap {@link
+   * android.graphics.drawable.Drawable Drawable}s should always return a new {@link
+   * android.graphics.drawable.Drawable Drawable}.
    */
   @NonNull
   Z get();
@@ -37,18 +35,18 @@
   /**
    * Cleans up and recycles internal resources.
    *
-   * <p> It is only safe to call this method if there are no current resource consumers and if this
+   * <p>It is only safe to call this method if there are no current resource consumers and if this
    * method has not yet been called. Typically this occurs at one of two times:
+   *
    * <ul>
    *   <li>During a resource load when the resource is transformed or transcoded before any consumer
-   *   have ever had access to this resource</li>
+   *       have ever had access to this resource
    *   <li>After all consumers have released this resource and it has been evicted from the cache
-   *   </li>
    * </ul>
    *
    * For most users of this class, the only time this method should ever be called is during
    * transformations or transcoders, the framework will call this method when all consumers have
-   * released this resource and it has been evicted from the cache. </p>
+   * released this resource and it has been evicted from the cache.
    */
   void recycle();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index aee163a33..123817b8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -14,8 +14,7 @@
  * Generates {@link com.bumptech.glide.load.data.DataFetcher DataFetchers} from cache files
  * containing downsampled/transformed resource data.
  */
-class ResourceCacheGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object> {
+class ResourceCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
 
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
@@ -30,6 +29,7 @@
   // multiple calls to startNext.
   @SuppressWarnings("PMD.SingularField")
   private File cacheFile;
+
   private ResourceCacheKey currentKey;
 
   ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
@@ -51,8 +51,10 @@ public boolean startNext() {
         return false;
       }
       throw new IllegalStateException(
-         "Failed to find any load path from " + helper.getModelClass() + " to "
-             + helper.getTranscodeClass());
+          "Failed to find any load path from "
+              + helper.getModelClass()
+              + " to "
+              + helper.getTranscodeClass());
     }
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
@@ -71,7 +73,7 @@ public boolean startNext() {
       // we only run until the first one succeeds, the loop runs for only a limited
       // number of iterations on the order of 10-20 in the worst case.
       currentKey =
-          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
+          new ResourceCacheKey( // NOPMD AvoidInstantiatingObjectsInLoops
               helper.getArrayPool(),
               sourceId,
               helper.getSignature(),
@@ -92,8 +94,9 @@ public boolean startNext() {
     boolean started = false;
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
-      loadData = modelLoader.buildLoadData(cacheFile,
-          helper.getWidth(), helper.getHeight(), helper.getOptions());
+      loadData =
+          modelLoader.buildLoadData(
+              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -117,8 +120,8 @@ public void cancel() {
 
   @Override
   public void onDataReady(Object data) {
-    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE,
-        currentKey);
+    cb.onDataFetcherReady(
+        sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE, currentKey);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index afd18a739..b09645d61 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -10,9 +10,7 @@
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
-/**
- * A cache key for downsampled and transformed resource data + any requested signature.
- */
+/** A cache key for downsampled and transformed resource data + any requested signature. */
 final class ResourceCacheKey implements Key {
   private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
   private final ArrayPool arrayPool;
@@ -47,7 +45,8 @@
   public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
-      return height == other.height && width == other.width
+      return height == other.height
+          && width == other.width
           && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
           && sourceKey.equals(other.sourceKey)
@@ -99,13 +98,21 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
   @Override
   public String toString() {
     return "ResourceCacheKey{"
-        + "sourceKey=" + sourceKey
-        + ", signature=" + signature
-        + ", width=" + width
-        + ", height=" + height
-        + ", decodedResourceClass=" + decodedResourceClass
-        + ", transformation='" + transformation + '\''
-        + ", options=" + options
+        + "sourceKey="
+        + sourceKey
+        + ", signature="
+        + signature
+        + ", width="
+        + width
+        + ", height="
+        + height
+        + ", decodedResourceClass="
+        + decodedResourceClass
+        + ", transformation='"
+        + transformation
+        + '\''
+        + ", options="
+        + options
         + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index 82b36ef98..ac8ade21f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -5,9 +5,7 @@
 import android.os.Message;
 import com.bumptech.glide.util.Synthetic;
 
-/**
- * A class that can safely recycle recursive resources.
- */
+/** A class that can safely recycle recursive resources. */
 class ResourceRecycler {
   private boolean isRecycling;
   private final Handler handler =
@@ -30,7 +28,7 @@ synchronized void recycle(Resource<?> resource) {
     static final int RECYCLE_RESOURCE = 1;
 
     @Synthetic
-    ResourceRecyclerCallback() { }
+    ResourceRecyclerCallback() {}
 
     @Override
     public boolean handleMessage(Message message) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index 5a57b971b..0f7182523 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -16,12 +16,13 @@
  * using registered {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders} and the model
  * provided for the load.
  *
- * <p> Depending on the disk cache strategy, source data may first be written to disk and then
- * loaded from the cache file rather than returned directly. </p>
+ * <p>Depending on the disk cache strategy, source data may first be written to disk and then loaded
+ * from the cache file rather than returned directly.
  */
-class SourceGenerator implements DataFetcherGenerator,
-    DataFetcher.DataCallback<Object>,
-    DataFetcherGenerator.FetcherReadyCallback {
+class SourceGenerator
+    implements DataFetcherGenerator,
+        DataFetcher.DataCallback<Object>,
+        DataFetcherGenerator.FetcherReadyCallback {
   private static final String TAG = "SourceGenerator";
 
   private final DecodeHelper<?> helper;
@@ -57,7 +58,7 @@ public boolean startNext() {
       loadData = helper.getLoadData().get(loadDataListIndex++);
       if (loadData != null
           && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
-          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
+              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
       }
@@ -78,11 +79,17 @@ private void cacheData(Object dataToCache) {
       originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
       helper.getDiskCache().put(originalKey, writer);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Finished encoding source to cache"
-            + ", key: " + originalKey
-            + ", data: " + dataToCache
-            + ", encoder: " + encoder
-            + ", duration: " + LogTime.getElapsedMillis(startTime));
+        Log.v(
+            TAG,
+            "Finished encoding source to cache"
+                + ", key: "
+                + originalKey
+                + ", data: "
+                + dataToCache
+                + ", encoder: "
+                + encoder
+                + ", duration: "
+                + LogTime.getElapsedMillis(startTime));
       }
     } finally {
       loadData.fetcher.cleanup();
@@ -109,8 +116,12 @@ public void onDataReady(Object data) {
       // reschedule to get back onto Glide's thread.
       cb.reschedule();
     } else {
-      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
-          loadData.fetcher.getDataSource(), originalKey);
+      cb.onDataFetcherReady(
+          loadData.sourceKey,
+          data,
+          loadData.fetcher,
+          loadData.fetcher.getDataSource(),
+          originalKey);
     }
   }
 
@@ -128,16 +139,16 @@ public void reschedule() {
 
   // Called from source cache generator.
   @Override
-  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
-      DataSource dataSource, Key attemptedKey) {
+  public void onDataFetcherReady(
+      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
     // This data fetcher will be loading from a File and provide the wrong data source, so override
     // with the data source of the original fetcher
     cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);
   }
 
   @Override
-  public void onDataFetcherFailed(Key sourceKey, Exception e, DataFetcher<?> fetcher,
-      DataSource dataSource) {
+  public void onDataFetcherFailed(
+      Key sourceKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource) {
     cb.onDataFetcherFailed(sourceKey, e, fetcher, loadData.fetcher.getDataSource());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index e53c49de4..655a980f6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -1,27 +1,20 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 /**
  * Interface for handling operations on a primitive array type.
+ *
  * @param <T> Array type (e.g. byte[], int[])
  */
 interface ArrayAdapterInterface<T> {
 
-  /**
-   * TAG for logging.
-   */
+  /** TAG for logging. */
   String getTag();
 
-  /**
-   * Return the length of the given array.
-   */
+  /** Return the length of the given array. */
   int getArrayLength(T array);
 
-  /**
-   * Allocate and return an array of the specified size.
-   */
+  /** Allocate and return an array of the specified size. */
   T newArray(int length);
 
-  /**
-   * Return the size of an element in the array in bytes (e.g. for int return 4).
-   */
+  /** Return the size of an element in the array in bytes (e.g. for int return 4). */
   int getElementSizeInBytes();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 7cb169dbb..b9a6b8dc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -1,20 +1,17 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Interface for an array pool that pools arrays of different types.
- */
+/** Interface for an array pool that pools arrays of different types. */
 public interface ArrayPool {
   /**
-   * A standard size to use to increase hit rates when the required size isn't defined.
-   * Currently 64KB.
+   * A standard size to use to increase hit rates when the required size isn't defined. Currently
+   * 64KB.
    */
   int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
 
   /**
    * Optionally adds the given array of the given type to the pool.
    *
-   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
-   * pool.
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the pool.
    *
    * @deprecated Use {@link #put(Object)}
    */
@@ -24,8 +21,7 @@
   /**
    * Optionally adds the given array of the given type to the pool.
    *
-   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
-   * pool.
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the pool.
    */
   <T> void put(T array);
 
@@ -51,9 +47,7 @@
    */
   <T> T getExact(int size, Class<T> arrayClass);
 
-  /**
-   * Clears all arrays from the pool.
-   */
+  /** Clears all arrays from the pool. */
   void clearMemory();
 
   /**
@@ -62,5 +56,4 @@
    * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index b57a9f3d4..8eceb458a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -3,33 +3,28 @@
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 
-/**
- * An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects.
- */
+/** An interface for a pool that allows users to reuse {@link android.graphics.Bitmap} objects. */
 public interface BitmapPool {
 
-  /**
-   * Returns the current maximum size of the pool in bytes.
-   */
+  /** Returns the current maximum size of the pool in bytes. */
   long getMaxSize();
 
   /**
    * Multiplies the initial size of the pool by the given multiplier to dynamically and
    * synchronously allow users to adjust the size of the pool.
    *
-   * <p> If the current total size of the pool is larger than the max size after the given
-   * multiplier is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new
-   * max size. </p>
+   * <p>If the current total size of the pool is larger than the max size after the given multiplier
+   * is applied, {@link Bitmap}s should be evicted until the pool is smaller than the new max size.
    *
    * @param sizeMultiplier The size multiplier to apply between 0 and 1.
    */
   void setSizeMultiplier(float sizeMultiplier);
 
   /**
-   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool
-   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
+   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool can
+   * fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it.
    *
-   * <p> Callers must <em>not</em> continue to use the Bitmap after calling this method. </p>
+   * <p>Callers must <em>not</em> continue to use the Bitmap after calling this method.
    *
    * @param bitmap The {@link android.graphics.Bitmap} to attempt to add.
    * @see android.graphics.Bitmap#isMutable()
@@ -41,15 +36,15 @@
    * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and
    * configuration, and containing only transparent pixels.
    *
-   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be
-   * allocated. </p>
+   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
+   * allocated.
    *
-   * <p> Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
+   * <p>Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower
    * than {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link
    * android.graphics.Bitmap} is being obtained to be used in {@link android.graphics.BitmapFactory}
    * or in any other case where every pixel in the {@link android.graphics.Bitmap} will always be
    * overwritten or cleared, {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be
-   * faster. When in doubt, use this method to ensure correctness. </p>
+   * faster. When in doubt, use this method to ensure correctness.
    *
    * <pre>
    *     Implementations can should clear out every returned Bitmap using the following:
@@ -59,10 +54,10 @@
    * }
    * </pre>
    *
-   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
    * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
    * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
-   *               android.graphics.Bitmap}.
+   *     android.graphics.Bitmap}.
    * @see #getDirty(int, int, android.graphics.Bitmap.Config)
    */
   @NonNull
@@ -73,34 +68,32 @@
    * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data.
    *
    * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be
-   * allocated. </p>
+   * allocated.
    *
-   * <p> Although this method is slightly more efficient than {@link #get(int, int,
+   * <p>Although this method is slightly more efficient than {@link #get(int, int,
    * android.graphics.Bitmap.Config)} it should be used with caution and only when the caller is
    * sure that they are going to erase the {@link android.graphics.Bitmap} entirely before writing
-   * new data to it. </p>
+   * new data to it.
    *
-   * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
+   * @param width The width in pixels of the desired {@link android.graphics.Bitmap}.
    * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
    * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
-   *               android.graphics.Bitmap}.
+   *     android.graphics.Bitmap}.
    * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config
-   * potentially containing random image data.
+   *     potentially containing random image data.
    * @see #get(int, int, android.graphics.Bitmap.Config)
    */
   @NonNull
   Bitmap getDirty(int width, int height, Bitmap.Config config);
 
-  /**
-   * Removes all {@link android.graphics.Bitmap}s from the pool.
-   */
+  /** Removes all {@link android.graphics.Bitmap}s from the pool. */
   void clearMemory();
 
   /**
    * Reduces the size of the cache by evicting items based on the given level.
    *
    * @param level The level from {@link android.content.ComponentCallbacks2} to use to determine how
-   *              many {@link android.graphics.Bitmap}s to evict.
+   *     many {@link android.graphics.Bitmap}s to evict.
    * @see android.content.ComponentCallbacks2
    */
   void trimMemory(int level);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
index 95f5ff708..d9a4d0f44 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Adapter for handling primitive byte arrays.
- */
+/** Adapter for handling primitive byte arrays. */
 @SuppressWarnings("PMD.UseVarargs")
 public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
   private static final String TAG = "ByteArrayPool";
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index 9060fd825..b502c49a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -13,8 +13,8 @@
  * bitmap size, rather than the LRU bitmap object. We can then remove bitmaps from the least
  * recently used size of bitmap when we need to reduce our cache size.
  *
- * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if
- * no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
+ * <p>For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even
+ * if no bitmaps of that size are present. We do not count addition or removal of bitmaps as an
  * access.
  */
 class GroupedLinkedMap<K extends Poolable, V> {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
index 4fb179c38..f596ce3ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-/**
- * Adapter for handling primitive int arrays.
- */
+/** Adapter for handling primitive int arrays. */
 @SuppressWarnings("PMD.UseVarargs")
 public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
   private static final String TAG = "IntegerArrayPool";
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 596e15574..127072475 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -11,8 +11,8 @@
 import java.util.TreeMap;
 
 /**
- * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
- * the maximum byte size.
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under the
+ * maximum byte size.
  */
 public final class LruArrayPool implements ArrayPool {
   // 4MB.
@@ -22,8 +22,7 @@
    * The maximum number of times larger an int array may be to be than a requested size to eligible
    * to be returned from the pool.
    */
-  @VisibleForTesting
-  static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  @VisibleForTesting static final int MAX_OVER_SIZE_MULTIPLE = 8;
   /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
   private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
 
@@ -110,7 +109,6 @@ public LruArrayPool(int maxSize) {
     return result;
   }
 
-
   // Our cast is safe because the Key is based on the type.
   @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
   @Nullable
@@ -200,8 +198,8 @@ private void decrementArrayOfSize(int size, Class<?> arrayClass) {
       } else if (arrayPoolClass.equals(byte[].class)) {
         adapter = new ByteArrayAdapter();
       } else {
-          throw new IllegalArgumentException("No array pool found for: "
-              + arrayPoolClass.getSimpleName());
+        throw new IllegalArgumentException(
+            "No array pool found for: " + arrayPoolClass.getSimpleName());
       }
       adapters.put(arrayPoolClass, adapter);
     }
@@ -223,7 +221,7 @@ int getCurrentSize() {
   private static final class KeyPool extends BaseKeyPool<Key> {
 
     @Synthetic
-    KeyPool() { }
+    KeyPool() {}
 
     Key get(int size, Class<?> arrayClass) {
       Key result = get();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index d233c9130..b852a5965 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -57,10 +57,9 @@ public LruBitmapPool(long maxSize) {
   /**
    * Constructor for LruBitmapPool.
    *
-   * @param maxSize        The initial maximum size of the pool in bytes.
+   * @param maxSize The initial maximum size of the pool in bytes.
    * @param allowedConfigs A white listed put of {@link android.graphics.Bitmap.Config} that are
-   *                       allowed to be put into the pool. Configs not in the allowed put will be
-   *                       rejected.
+   *     allowed to be put into the pool. Configs not in the allowed put will be rejected.
    */
   // Public API.
   @SuppressWarnings("unused")
@@ -87,13 +86,19 @@ public synchronized void put(Bitmap bitmap) {
     if (bitmap.isRecycled()) {
       throw new IllegalStateException("Cannot pool recycled bitmap");
     }
-    if (!bitmap.isMutable() || strategy.getSize(bitmap) > maxSize
+    if (!bitmap.isMutable()
+        || strategy.getSize(bitmap) > maxSize
         || !allowedConfigs.contains(bitmap.getConfig())) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Reject bitmap from pool"
-                + ", bitmap: " + strategy.logBitmap(bitmap)
-                + ", is mutable: " + bitmap.isMutable()
-                + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));
+        Log.v(
+            TAG,
+            "Reject bitmap from pool"
+                + ", bitmap: "
+                + strategy.logBitmap(bitmap)
+                + ", is mutable: "
+                + bitmap.isMutable()
+                + ", is allowed config: "
+                + allowedConfigs.contains(bitmap.getConfig()));
       }
       bitmap.recycle();
       return;
@@ -157,9 +162,11 @@ private static void assertNotHardwareConfig(Bitmap.Config config) {
     }
 
     if (config == Bitmap.Config.HARDWARE) {
-      throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config
-          + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"
-          + " and/or in GlideBuilder.setDefaultRequestOptions");
+      throw new IllegalArgumentException(
+          "Cannot create a mutable Bitmap with config: "
+              + config
+              + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your"
+              + " RequestOptions and/or in GlideBuilder.setDefaultRequestOptions");
     }
   }
 
@@ -255,8 +262,22 @@ private void dump() {
   }
 
   private void dumpUnchecked() {
-    Log.v(TAG, "Hits=" + hits + ", misses=" + misses + ", puts=" + puts + ", evictions=" + evictions
-        + ", currentSize=" + currentSize + ", maxSize=" + maxSize + "\nStrategy=" + strategy);
+    Log.v(
+        TAG,
+        "Hits="
+            + hits
+            + ", misses="
+            + misses
+            + ", puts="
+            + puts
+            + ", evictions="
+            + evictions
+            + ", currentSize="
+            + currentSize
+            + ", maxSize="
+            + maxSize
+            + "\nStrategy="
+            + strategy);
   }
 
   private static LruPoolStrategy getDefaultStrategy() {
@@ -299,8 +320,13 @@ private static LruPoolStrategy getDefaultStrategy() {
     public void add(Bitmap bitmap) {
       if (bitmaps.contains(bitmap)) {
         throw new IllegalStateException(
-            "Can't add already added bitmap: " + bitmap + " [" + bitmap.getWidth() + "x" + bitmap
-                .getHeight() + "]");
+            "Can't add already added bitmap: "
+                + bitmap
+                + " ["
+                + bitmap.getWidth()
+                + "x"
+                + bitmap.getHeight()
+                + "]");
       }
       bitmaps.add(bitmap);
     }
@@ -317,7 +343,7 @@ public void remove(Bitmap bitmap) {
   private static final class NullBitmapTracker implements BitmapTracker {
 
     @Synthetic
-    NullBitmapTracker() { }
+    NullBitmapTracker() {}
 
     @Override
     public void add(Bitmap bitmap) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index a4b0f46b4..7c8c0002c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -15,27 +15,27 @@
 import java.util.TreeMap;
 
 /**
- * Keys {@link android.graphics.Bitmap Bitmaps} using both
- * {@link android.graphics.Bitmap#getAllocationByteCount()} and the
- * {@link android.graphics.Bitmap.Config} returned from
- * {@link android.graphics.Bitmap#getConfig()}.
+ * Keys {@link android.graphics.Bitmap Bitmaps} using both {@link
+ * android.graphics.Bitmap#getAllocationByteCount()} and the {@link android.graphics.Bitmap.Config}
+ * returned from {@link android.graphics.Bitmap#getConfig()}.
  *
- * <p> Using both the config and the byte size allows us to safely re-use a greater variety of
- * {@link android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore
- * the performance of applications. This class works around #301 by only allowing re-use of
- * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
+ * <p>Using both the config and the byte size allows us to safely re-use a greater variety of {@link
+ * android.graphics.Bitmap Bitmaps}, which increases the hit rate of the pool and therefore the
+ * performance of applications. This class works around #301 by only allowing re-use of {@link
+ * android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel.
  */
 @RequiresApi(Build.VERSION_CODES.KITKAT)
 public class SizeConfigStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
 
   private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+
   static {
     Bitmap.Config[] result =
         new Bitmap.Config[] {
-            Bitmap.Config.ARGB_8888,
-            // The value returned by Bitmaps with the hidden Bitmap config.
-            null,
+          Bitmap.Config.ARGB_8888,
+          // The value returned by Bitmaps with the hidden Bitmap config.
+          null,
         };
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
       result = Arrays.copyOf(result, result.length + 1);
@@ -43,16 +43,17 @@
     }
     ARGB_8888_IN_CONFIGS = result;
   }
+
   private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;
 
   // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
   // deprecated and we'd rather be safe.
   private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.RGB_565 };
+      new Bitmap.Config[] {Bitmap.Config.RGB_565};
   private static final Bitmap.Config[] ARGB_4444_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.ARGB_4444 };
+      new Bitmap.Config[] {Bitmap.Config.ARGB_4444};
   private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS =
-      new Bitmap.Config[] { Bitmap.Config.ALPHA_8 };
+      new Bitmap.Config[] {Bitmap.Config.ALPHA_8};
 
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
@@ -118,10 +119,14 @@ private void decrementBitmapOfSize(Integer size, Bitmap removed) {
     NavigableMap<Integer, Integer> sizes = getSizesForConfig(config);
     Integer current = sizes.get(size);
     if (current == null) {
-      throw new NullPointerException("Tried to decrement empty size"
-          + ", size: " + size
-          + ", removed: " + logBitmap(removed)
-          + ", this: " + this);
+      throw new NullPointerException(
+          "Tried to decrement empty size"
+              + ", size: "
+              + size
+              + ", removed: "
+              + logBitmap(removed)
+              + ", this: "
+              + this);
     }
 
     if (current == 1) {
@@ -224,8 +229,7 @@ public String toString() {
     public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
-        return size == other.size
-            && Util.bothNullOrEqual(config, other.config);
+        return size == other.size && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
@@ -260,7 +264,7 @@ static String getBitmapString(int size, Bitmap.Config config) {
       case ALPHA_8:
         return ALPHA_8_IN_CONFIGS;
       default:
-        return new Bitmap.Config[] { requested };
+        return new Bitmap.Config[] {requested};
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 5536b75db..e4ed3e5ae 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -10,10 +10,10 @@
 import java.util.NavigableMap;
 
 /**
- * A strategy for reusing bitmaps that relies on
- * {@link Bitmap#reconfigure(int, int, Bitmap.Config)}.
+ * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int,
+ * Bitmap.Config)}.
  *
- * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
+ * <p>Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher.
  */
 @RequiresApi(Build.VERSION_CODES.KITKAT)
 final class SizeStrategy implements LruPoolStrategy {
@@ -102,7 +102,8 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  @Synthetic static String getBitmapString(int size) {
+  @Synthetic
+  static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 7bcfd02e4..e098aeb61 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -5,17 +5,14 @@
 import com.bumptech.glide.load.Key;
 import java.io.File;
 
-/**
- * An interface for writing to and reading from a disk cache.
- */
+/** An interface for writing to and reading from a disk cache. */
 public interface DiskCache {
 
-  /**
-   * An interface for lazily creating a disk cache.
-   */
+  /** An interface for lazily creating a disk cache. */
   interface Factory {
     /** 250 MB of cache. */
     int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
+
     String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
     /** Returns a new disk cache, or {@code null} if no disk cache could be created. */
@@ -23,9 +20,7 @@
     DiskCache build();
   }
 
-  /**
-   * An interface to actually write data to a key in the disk cache.
-   */
+  /** An interface to actually write data to a key in the disk cache. */
   interface Writer {
     /**
      * Writes data to the file and returns true if the write was successful and should be committed,
@@ -39,8 +34,8 @@
   /**
    * Get the cache for the value at the given key.
    *
-   * <p> Note - This is potentially dangerous, someone may write a new value to the file at any
-   * point in time and we won't know about it. </p>
+   * <p>Note - This is potentially dangerous, someone may write a new value to the file at any point
+   * in time and we won't know about it.
    *
    * @param key The key in the cache.
    * @return An InputStream representing the data at key at the time get is called.
@@ -52,7 +47,7 @@
    * Write to a key in the cache. {@link Writer} is used so that the cache implementation can
    * perform actions after the write finishes, like commit (via atomic file rename).
    *
-   * @param key    The key to write to.
+   * @param key The key to write to.
    * @param writer An interface that will write data given an OutputStream for the key.
    */
   void put(Key key, Writer writer);
@@ -66,8 +61,6 @@
   @SuppressWarnings("unused")
   void delete(Key key);
 
-  /**
-   * Clear the cache.
-   */
+  /** Clear the cache. */
   void clear();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 8642d5275..573544217 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.load.Key;
 import java.io.File;
 
-/**
- * A simple class that returns null for all gets and ignores all writes.
- */
+/** A simple class that returns null for all gets and ignores all writes. */
 public class DiskCacheAdapter implements DiskCache {
   @Override
   public File get(Key key) {
@@ -25,12 +23,10 @@ public void delete(Key key) {
 
   @Override
   public void clear() {
-      // no op, default for overriders
+    // no op, default for overriders
   }
 
-  /**
-   * Default factory for {@link DiskCacheAdapter}.
-   */
+  /** Default factory for {@link DiskCacheAdapter}. */
   public static final class Factory implements DiskCache.Factory {
     @Override
     public DiskCache build() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index d11f0f02a..960252b2f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -13,9 +13,9 @@
  * Keeps a map of keys to locks that allows locks to be removed from the map when no longer in use
  * so the size of the collection is bounded.
  *
- * <p> This class will be accessed by multiple threads in a thread pool and ensures that the
- *  number of threads interested in each lock is updated atomically so that when the count reaches
- *  0, the lock can safely be removed from the map. </p>
+ * <p>This class will be accessed by multiple threads in a thread pool and ensures that the number
+ * of threads interested in each lock is updated atomically so that when the count reaches 0, the
+ * lock can safely be removed from the map.
  */
 final class DiskCacheWriteLocker {
   private final Map<String, WriteLock> locks = new HashMap<>();
@@ -40,19 +40,26 @@ void release(String safeKey) {
     synchronized (this) {
       writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
-        throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", safeKey: " + safeKey
-            + ", interestedThreads: " + writeLock.interestedThreads);
+        throw new IllegalStateException(
+            "Cannot release a lock that is not held"
+                + ", safeKey: "
+                + safeKey
+                + ", interestedThreads: "
+                + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
         WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
-          throw new IllegalStateException("Removed the wrong lock"
-              + ", expected to remove: " + writeLock
-              + ", but actually removed: " + removed
-              + ", safeKey: " + safeKey);
+          throw new IllegalStateException(
+              "Removed the wrong lock"
+                  + ", expected to remove: "
+                  + writeLock
+                  + ", but actually removed: "
+                  + removed
+                  + ", safeKey: "
+                  + safeKey);
         }
         writeLockPool.offer(removed);
       }
@@ -61,12 +68,12 @@ void release(String safeKey) {
     writeLock.lock.unlock();
   }
 
-  private static class WriteLock  {
+  private static class WriteLock {
     final Lock lock = new ReentrantLock();
     int interestedThreads;
 
     @Synthetic
-    WriteLock() { }
+    WriteLock() {}
   }
 
   private static class WriteLockPool {
@@ -74,7 +81,7 @@ void release(String safeKey) {
     private final Queue<WriteLock> pool = new ArrayDeque<>();
 
     @Synthetic
-    WriteLockPool() { }
+    WriteLockPool() {}
 
     WriteLock obtain() {
       WriteLock result;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index 9518b4c85..03a783481 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -15,30 +15,32 @@
   private final long diskCacheSize;
   private final CacheDirectoryGetter cacheDirectoryGetter;
 
-  /**
-   * Interface called out of UI thread to get the cache folder.
-   */
+  /** Interface called out of UI thread to get the cache folder. */
   public interface CacheDirectoryGetter {
     File getCacheDirectory();
   }
 
   public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {
-    this(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        return new File(diskCacheFolder);
-      }
-    }, diskCacheSize);
+    this(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            return new File(diskCacheFolder);
+          }
+        },
+        diskCacheSize);
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
-                             long diskCacheSize) {
-    this(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        return new File(diskCacheFolder, diskCacheName);
-      }
-    }, diskCacheSize);
+  public DiskLruCacheFactory(
+      final String diskCacheFolder, final String diskCacheName, long diskCacheSize) {
+    this(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            return new File(diskCacheFolder, diskCacheName);
+          }
+        },
+        diskCacheSize);
   }
 
   /**
@@ -46,7 +48,7 @@ public File getCacheDirectory() {
    * of UI thread, allowing to do I/O access without performance impacts.
    *
    * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
-   * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
+   * @param diskCacheSize Desired max bytes size for the LRU disk cache.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 2cedfe0b2..516bee1f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -36,9 +36,8 @@
    * ignored.
    *
    * @param directory The directory for the disk cache
-   * @param maxSize   The max size for the disk cache
+   * @param maxSize The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
-   *
    * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
   @SuppressWarnings("deprecation")
@@ -56,7 +55,7 @@ public static synchronized DiskCache get(File directory, long maxSize) {
    * Create a new DiskCache in the given directory with a specified max size.
    *
    * @param directory The directory for the disk cache
-   * @param maxSize   The max size for the disk cache
+   * @param maxSize The max size for the disk cache
    * @return The new disk cache with the given arguments
    */
   @SuppressWarnings("deprecation")
@@ -64,9 +63,7 @@ public static DiskCache create(File directory, long maxSize) {
     return new DiskLruCacheWrapper(directory, maxSize);
   }
 
-  /**
-   * @deprecated Do not extend this class.
-   */
+  /** @deprecated Do not extend this class. */
   @Deprecated
   // Deprecated public API.
   @SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index 08b8d4dde..606b14857 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -17,7 +17,9 @@
 public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
@@ -25,20 +27,22 @@ public ExternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public ExternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        File cacheDirectory = context.getExternalCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+  public ExternalCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, int diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            File cacheDirectory = context.getExternalCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
index 4f2743b1e..d68573199 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -16,7 +16,9 @@
 public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalPreferredCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
@@ -24,42 +26,44 @@ public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSiz
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,
-                                                final long diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Nullable
-      private File getInternalCacheDirectory() {
-        File cacheDirectory = context.getCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
+  public ExternalPreferredCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, final long diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Nullable
+          private File getInternalCacheDirectory() {
+            File cacheDirectory = context.getCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
 
-      @Override
-      public File getCacheDirectory() {
-        File internalCacheDirectory = getInternalCacheDirectory();
+          @Override
+          public File getCacheDirectory() {
+            File internalCacheDirectory = getInternalCacheDirectory();
 
-        // Already used internal cache, so keep using that one,
-        // thus avoiding using both external and internal with transient errors.
-        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
-          return internalCacheDirectory;
-        }
+            // Already used internal cache, so keep using that one,
+            // thus avoiding using both external and internal with transient errors.
+            if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
+              return internalCacheDirectory;
+            }
 
-        File cacheDirectory = context.getExternalCacheDir();
+            File cacheDirectory = context.getExternalCacheDir();
 
-        // Shared storage is not available.
-        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
-          return internalCacheDirectory;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+            // Shared storage is not available.
+            if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
+              return internalCacheDirectory;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index 18afb52f0..3fec19c99 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -12,7 +12,9 @@
 public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public InternalCacheDiskCacheFactory(Context context) {
-    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+    this(
+        context,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
@@ -20,20 +22,22 @@ public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
-  public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-                                       long diskCacheSize) {
-    super(new CacheDirectoryGetter() {
-      @Override
-      public File getCacheDirectory() {
-        File cacheDirectory = context.getCacheDir();
-        if (cacheDirectory == null) {
-          return null;
-        }
-        if (diskCacheName != null) {
-          return new File(cacheDirectory, diskCacheName);
-        }
-        return cacheDirectory;
-      }
-    }, diskCacheSize);
+  public InternalCacheDiskCacheFactory(
+      final Context context, final String diskCacheName, long diskCacheSize) {
+    super(
+        new CacheDirectoryGetter() {
+          @Override
+          public File getCacheDirectory() {
+            File cacheDirectory = context.getCacheDir();
+            if (cacheDirectory == null) {
+              return null;
+            }
+            if (diskCacheName != null) {
+              return new File(cacheDirectory, diskCacheName);
+            }
+            return cacheDirectory;
+          }
+        },
+        diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 75c5329e1..b5a6444ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -7,9 +7,7 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
 
-/**
- * An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s.
- */
+/** An LRU in memory cache for {@link com.bumptech.glide.load.engine.Resource}s. */
 public class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {
   private ResourceRemovedListener listener;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index 3210e6821..f786e76be 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -5,33 +5,25 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
-/**
- * An interface for adding and removing resources from an in memory cache.
- */
+/** An interface for adding and removing resources from an in memory cache. */
 public interface MemoryCache {
-  /**
-   * An interface that will be called whenever a bitmap is removed from the cache.
-   */
+  /** An interface that will be called whenever a bitmap is removed from the cache. */
   interface ResourceRemovedListener {
     void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
-  /**
-   * Returns the sum of the sizes of all the contents of the cache in bytes.
-   */
+  /** Returns the sum of the sizes of all the contents of the cache in bytes. */
   long getCurrentSize();
 
-  /**
-   * Returns the current maximum size in bytes of the cache.
-   */
+  /** Returns the current maximum size in bytes of the cache. */
   long getMaxSize();
 
   /**
    * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
    * multiplier.
    *
-   * <p> If the size multiplier causes the size of the cache to be decreased, items will be evicted
-   * until the cache is smaller than the new size. </p>
+   * <p>If the size multiplier causes the size of the cache to be decreased, items will be evicted
+   * until the cache is smaller than the new size.
    *
    * @param multiplier A size multiplier >= 0.
    */
@@ -48,7 +40,7 @@
   /**
    * Add bitmap to the cache with the given key.
    *
-   * @param key      The key to retrieve the bitmap.
+   * @param key The key to retrieve the bitmap.
    * @param resource The {@link com.bumptech.glide.load.engine.EngineResource} to store.
    * @return The old value of key (null if key is not in map).
    */
@@ -62,16 +54,14 @@
    */
   void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);
 
-  /**
-   * Evict all items from the memory cache.
-   */
+  /** Evict all items from the memory cache. */
   void clearMemory();
 
   /**
    * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.
    *
    * @param level This integer represents a trim level as specified in {@link
-   *              android.content.ComponentCallbacks2}.
+   *     android.content.ComponentCallbacks2}.
    */
   void trimMemory(int level);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index 70deb5ce6..3fbff06fa 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -5,9 +5,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
-/**
- * A simple class that ignores all puts and returns null for all gets.
- */
+/** A simple class that ignores all puts and returns null for all gets. */
 public class MemoryCacheAdapter implements MemoryCache {
 
   private ResourceRemovedListener listener;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 1418c466b..1b95564b9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -17,8 +17,7 @@
  */
 public final class MemorySizeCalculator {
   private static final String TAG = "MemorySizeCalculator";
-  @VisibleForTesting
-  static final int BYTES_PER_ARGB_8888_PIXEL = 4;
+  @VisibleForTesting static final int BYTES_PER_ARGB_8888_PIXEL = 4;
   private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
 
   private final int bitmapPoolSize;
@@ -28,6 +27,7 @@
 
   interface ScreenDimensions {
     int getWidthPixels();
+
     int getHeightPixels();
   }
 
@@ -82,33 +82,27 @@
     }
   }
 
-  /**
-   * Returns the recommended memory cache size for the device it is run on in bytes.
-   */
+  /** Returns the recommended memory cache size for the device it is run on in bytes. */
   public int getMemoryCacheSize() {
     return memoryCacheSize;
   }
 
-  /**
-   * Returns the recommended bitmap pool size for the device it is run on in bytes.
-   */
+  /** Returns the recommended bitmap pool size for the device it is run on in bytes. */
   public int getBitmapPoolSize() {
     return bitmapPoolSize;
   }
 
-  /**
-   * Returns the recommended array pool size for the device it is run on in bytes.
-   */
+  /** Returns the recommended array pool size for the device it is run on in bytes. */
   public int getArrayPoolSizeInBytes() {
     return arrayPoolSize;
   }
 
-  private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
-      float lowMemoryMaxSizeMultiplier) {
+  private static int getMaxSize(
+      ActivityManager activityManager, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
     final int memoryClassBytes = activityManager.getMemoryClass() * 1024 * 1024;
     final boolean isLowMemoryDevice = isLowMemoryDevice(activityManager);
-    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier
-        : maxSizeMultiplier));
+    return Math.round(
+        memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier : maxSizeMultiplier));
   }
 
   private String toMb(int bytes) {
@@ -116,7 +110,8 @@ private String toMb(int bytes) {
   }
 
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  @Synthetic static boolean isLowMemoryDevice(ActivityManager activityManager) {
+  @Synthetic
+  static boolean isLowMemoryDevice(ActivityManager activityManager) {
     // Explicitly check with an if statement, on some devices both parts of boolean expressions
     // can be evaluated even if we'd normally expect a short circuit.
     //noinspection SimplifiableIfStatement
@@ -134,8 +129,7 @@ private String toMb(int bytes) {
   // Public API.
   @SuppressWarnings({"WeakerAccess", "unused"})
   public static final class Builder {
-    @VisibleForTesting
-    static final int MEMORY_CACHE_TARGET_SCREENS = 2;
+    @VisibleForTesting static final int MEMORY_CACHE_TARGET_SCREENS = 2;
 
     /**
      * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably
@@ -164,8 +158,7 @@ private String toMb(int bytes) {
 
     public Builder(Context context) {
       this.context = context;
-      activityManager =
-          (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+      activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
       screenDimensions =
           new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
 
@@ -179,37 +172,38 @@ public Builder(Context context) {
     }
 
     /**
-     * Sets the number of device screens worth of pixels the
-     * {@link com.bumptech.glide.load.engine.cache.MemoryCache} should be able to hold and
-     * returns this Builder.
+     * Sets the number of device screens worth of pixels the {@link
+     * com.bumptech.glide.load.engine.cache.MemoryCache} should be able to hold and returns this
+     * Builder.
      */
     public Builder setMemoryCacheScreens(float memoryCacheScreens) {
-      Preconditions.checkArgument(memoryCacheScreens >= 0,
-          "Memory cache screens must be greater than or equal to 0");
+      Preconditions.checkArgument(
+          memoryCacheScreens >= 0, "Memory cache screens must be greater than or equal to 0");
       this.memoryCacheScreens = memoryCacheScreens;
       return this;
     }
 
     /**
-     * Sets the number of device screens worth of pixels the
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} should be able to hold and
-     * returns this Builder.
+     * Sets the number of device screens worth of pixels the {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} should be able to hold and returns
+     * this Builder.
      */
     public Builder setBitmapPoolScreens(float bitmapPoolScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
-          "Bitmap pool screens must be greater than or equal to 0");
+      Preconditions.checkArgument(
+          bitmapPoolScreens >= 0, "Bitmap pool screens must be greater than or equal to 0");
       this.bitmapPoolScreens = bitmapPoolScreens;
       return this;
     }
 
     /**
      * Sets the maximum percentage of the device's memory class for standard devices that can be
-     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
-     * this builder.
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns this
+     * builder.
      */
     public Builder setMaxSizeMultiplier(float maxSizeMultiplier) {
-      Preconditions.checkArgument(maxSizeMultiplier >= 0 && maxSizeMultiplier <= 1,
+      Preconditions.checkArgument(
+          maxSizeMultiplier >= 0 && maxSizeMultiplier <= 1,
           "Size multiplier must be between 0 and 1");
       this.maxSizeMultiplier = maxSizeMultiplier;
       return this;
@@ -217,27 +211,26 @@ public Builder setMaxSizeMultiplier(float maxSizeMultiplier) {
 
     /**
      * Sets the maximum percentage of the device's memory class for low ram devices that can be
-     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and
-     * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns
-     * this builder.
+     * taken up by Glide's {@link com.bumptech.glide.load.engine.cache.MemoryCache} and {@link
+     * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} put together, and returns this
+     * builder.
      *
      * @see ActivityManager#isLowRamDevice()
      */
     public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
       Preconditions.checkArgument(
           lowMemoryMaxSizeMultiplier >= 0 && lowMemoryMaxSizeMultiplier <= 1,
-              "Low memory max size multiplier must be between 0 and 1");
+          "Low memory max size multiplier must be between 0 and 1");
       this.lowMemoryMaxSizeMultiplier = lowMemoryMaxSizeMultiplier;
       return this;
     }
 
     /**
-     * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
-     * arrays while decoding data and returns this builder.
+     * Sets the size in bytes of the {@link com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool}
+     * to use to store temporary arrays while decoding data and returns this builder.
      *
-     * <p>This number will be halved on low memory devices that return {@code true} from
-     * {@link ActivityManager#isLowRamDevice()}.
+     * <p>This number will be halved on low memory devices that return {@code true} from {@link
+     * ActivityManager#isLowRamDevice()}.
      */
     public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
       this.arrayPoolSizeBytes = arrayPoolSizeBytes;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index f726ef10e..fbeafa62f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -20,17 +20,19 @@
 @SuppressWarnings("WeakerAccess")
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
-      new FactoryPools.Factory<PoolableDigestContainer>() {
-        @Override
-        public PoolableDigestContainer create() {
-          try {
-            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
-          } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-          }
-        }
-      });
+  private final Pools.Pool<PoolableDigestContainer> digestPool =
+      FactoryPools.threadSafe(
+          10,
+          new FactoryPools.Factory<PoolableDigestContainer>() {
+            @Override
+            public PoolableDigestContainer create() {
+              try {
+                return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+              } catch (NoSuchAlgorithmException e) {
+                throw new RuntimeException(e);
+              }
+            }
+          });
 
   public String getSafeKey(Key key) {
     String safeKey;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index 7f8845534..55d35371e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -19,9 +19,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-/**
- * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
- */
+/** A prioritized {@link ThreadPoolExecutor} for running jobs in Glide. */
 public final class GlideExecutor implements ExecutorService {
   /**
    * The default thread name prefix for executors used to load/decode/transform data not found in
@@ -51,9 +49,7 @@
 
   private static final String ANIMATION_EXECUTOR_NAME = "animation";
 
-  /**
-   * The default keep alive time for threads in our cached thread pools in milliseconds.
-   */
+  /** The default keep alive time for threads in our cached thread pools in milliseconds. */
   private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
 
   // Don't use more than four threads when automatically determining thread count..
@@ -66,10 +62,10 @@
   private final ExecutorService delegate;
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
-   * prefix, and the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
+   * and the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
@@ -82,21 +78,22 @@ public static GlideExecutor newDiskCacheExecutor() {
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
-   * prefix, and a custom
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
-   * uncaught throwable strategy.
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
+   * and a custom {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
+   * throwable strategy.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
+   *
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
   // Public API.
   @SuppressWarnings("unused")
   public static GlideExecutor newDiskCacheExecutor(
-          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
     return newDiskCacheExecutor(
         DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
         DEFAULT_DISK_CACHE_EXECUTOR_NAME,
@@ -104,16 +101,16 @@ public static GlideExecutor newDiskCacheExecutor(
   }
 
   /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix,
-   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
    *
    * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
@@ -130,10 +127,10 @@ public static GlideExecutor newDiskCacheExecutor(
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
-   * prefix, and the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
+   * the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy.
    *
    * <p>Source executors allow network operations on their threads.
@@ -146,39 +143,37 @@ public static GlideExecutor newSourceExecutor() {
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from
-   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
-   * prefix, and a custom
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
-   * uncaught throwable strategy.
+   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
+   * a custom {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
+   * throwable strategy.
    *
    * <p>Source executors allow network operations on their threads.
    *
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
   // Public API.
   @SuppressWarnings("unused")
   public static GlideExecutor newSourceExecutor(
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
     return newSourceExecutor(
-        calculateBestThreadCount(),
-        DEFAULT_SOURCE_EXECUTOR_NAME,
-        uncaughtThrowableStrategy);
+        calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME, uncaughtThrowableStrategy);
   }
 
   /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix,
-   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
    *
    * <p>Source executors allow network operations on their threads.
    *
    * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
    * @param uncaughtThrowableStrategy The {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *                                  handle uncaught exceptions.
+   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *     handle uncaught exceptions.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
@@ -196,29 +191,27 @@ public static GlideExecutor newSourceExecutor(
 
   /**
    * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
-   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
-   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
-   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive time, the {@link
+   * #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
    * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
-   * {@code corePoolSize} threads.
-   * See <a href=
+   * {@code corePoolSize} threads. See <a href=
    * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
    * ThreadPoolExecutor documentation</a>.
    *
    * <p>Source executors allow network operations on their threads.
    */
   public static GlideExecutor newUnlimitedSourceExecutor() {
-    return new GlideExecutor(new ThreadPoolExecutor(
-        0,
-        Integer.MAX_VALUE,
-        KEEP_ALIVE_TIME_MS,
-        TimeUnit.MILLISECONDS,
-        new SynchronousQueue<Runnable>(),
-        new DefaultThreadFactory(
-            SOURCE_UNLIMITED_EXECUTOR_NAME,
-            UncaughtThrowableStrategy.DEFAULT,
-            false)));
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0,
+            Integer.MAX_VALUE,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new SynchronousQueue<Runnable>(),
+            new DefaultThreadFactory(
+                SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, false)));
   }
 
   /**
@@ -238,24 +231,21 @@ public static GlideExecutor newAnimationExecutor() {
   }
 
   /**
-   * Returns a new cached thread pool with the given thread count and
-   * {@link UncaughtThrowableStrategy} to use when loading frames of animations.
+   * Returns a new cached thread pool with the given thread count and {@link
+   * UncaughtThrowableStrategy} to use when loading frames of animations.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static GlideExecutor newAnimationExecutor(
       int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-     return new GlideExecutor(
+    return new GlideExecutor(
         new ThreadPoolExecutor(
             0 /* corePoolSize */,
             threadCount,
             KEEP_ALIVE_TIME_MS,
             TimeUnit.MILLISECONDS,
             new PriorityBlockingQueue<Runnable>(),
-            new DefaultThreadFactory(
-                ANIMATION_EXECUTOR_NAME,
-                uncaughtThrowableStrategy,
-                true)));
+            new DefaultThreadFactory(ANIMATION_EXECUTOR_NAME, uncaughtThrowableStrategy, true)));
   }
 
   @VisibleForTesting
@@ -284,9 +274,8 @@ public void execute(@NonNull Runnable command) {
   @NonNull
   @Override
   public <T> List<Future<T>> invokeAll(
-      @NonNull Collection<? extends Callable<T>> tasks,
-      long timeout,
-      @NonNull TimeUnit unit) throws InterruptedException {
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
     return delegate.invokeAll(tasks, timeout, unit);
   }
 
@@ -299,9 +288,8 @@ public void execute(@NonNull Runnable command) {
 
   @Override
   public <T> T invokeAny(
-      @NonNull Collection<? extends Callable<T>> tasks,
-      long timeout,
-      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+      @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
     return delegate.invokeAny(tasks, timeout, unit);
   }
 
@@ -348,9 +336,7 @@ public String toString() {
     return delegate.toString();
   }
 
-  /**
-   * Determines the number of cores available on the device.
-   */
+  /** Determines the number of cores available on the device. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static int calculateBestThreadCount() {
@@ -366,41 +352,38 @@ public static int calculateBestThreadCount() {
    * pool.
    */
   public interface UncaughtThrowableStrategy {
-    /**
-     * Silently catches and ignores the uncaught {@link Throwable}s.
-     */
+    /** Silently catches and ignores the uncaught {@link Throwable}s. */
     // Public API.
     @SuppressWarnings("unused")
-    UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        //ignore
-      }
-    };
-    /**
-     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
-     */
-    UncaughtThrowableStrategy LOG = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
-          Log.e(TAG, "Request threw uncaught throwable", t);
-        }
-      }
-    };
-    /**
-     * Rethrows the uncaught {@link Throwable}s to crash the app.
-     */
+    UncaughtThrowableStrategy IGNORE =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            // ignore
+          }
+        };
+    /** Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}. */
+    UncaughtThrowableStrategy LOG =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
+              Log.e(TAG, "Request threw uncaught throwable", t);
+            }
+          }
+        };
+    /** Rethrows the uncaught {@link Throwable}s to crash the app. */
     // Public API.
     @SuppressWarnings("unused")
-    UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
-      @Override
-      public void handle(Throwable t) {
-        if (t != null) {
-          throw new RuntimeException("Request threw uncaught throwable", t);
-        }
-      }
-    };
+    UncaughtThrowableStrategy THROW =
+        new UncaughtThrowableStrategy() {
+          @Override
+          public void handle(Throwable t) {
+            if (t != null) {
+              throw new RuntimeException("Request threw uncaught throwable", t);
+            }
+          }
+        };
 
     /** The default strategy, currently {@link #LOG}. */
     UncaughtThrowableStrategy DEFAULT = LOG;
@@ -413,15 +396,18 @@ public void handle(Throwable t) {
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
-    private static final int DEFAULT_PRIORITY = android.os.Process.THREAD_PRIORITY_BACKGROUND
-        + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
+    private static final int DEFAULT_PRIORITY =
+        android.os.Process.THREAD_PRIORITY_BACKGROUND
+            + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
 
     private final String name;
     @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
     @Synthetic final boolean preventNetworkOperations;
     private int threadNum;
 
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+    DefaultThreadFactory(
+        String name,
+        UncaughtThrowableStrategy uncaughtThrowableStrategy,
         boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
@@ -430,25 +416,24 @@ public void handle(Throwable t) {
 
     @Override
     public synchronized Thread newThread(@NonNull Runnable runnable) {
-      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
-        @Override
-        public void run() {
-          // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
-          android.os.Process.setThreadPriority(DEFAULT_PRIORITY); //NOPMD AccessorMethodGeneration
-          if (preventNetworkOperations) {
-            StrictMode.setThreadPolicy(
-                new ThreadPolicy.Builder()
-                    .detectNetwork()
-                    .penaltyDeath()
-                    .build());
-          }
-          try {
-            super.run();
-          } catch (Throwable t) {
-            uncaughtThrowableStrategy.handle(t);
-          }
-        }
-      };
+      final Thread result =
+          new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
+            @Override
+            public void run() {
+              // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
+              android.os.Process.setThreadPriority(
+                  DEFAULT_PRIORITY); // NOPMD AccessorMethodGeneration
+              if (preventNetworkOperations) {
+                StrictMode.setThreadPolicy(
+                    new ThreadPolicy.Builder().detectNetwork().penaltyDeath().build());
+              }
+              try {
+                super.run();
+              } catch (Throwable t) {
+                uncaughtThrowableStrategy.handle(t);
+              }
+            }
+          };
       threadNum++;
       return result;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
index 8dc69bdeb..6261f7dd0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -8,9 +8,7 @@
 import java.io.FilenameFilter;
 import java.util.regex.Pattern;
 
-/**
- * Compatibility methods for {@link java.lang.Runtime}.
- */
+/** Compatibility methods for {@link java.lang.Runtime}. */
 final class RuntimeCompat {
   private static final String TAG = "GlideRuntimeCompat";
   private static final String CPU_NAME_REGEX = "cpu[0-9]+";
@@ -20,9 +18,7 @@ private RuntimeCompat() {
     // Utility class.
   }
 
-  /**
-   * Determines the number of cores available on the device.
-   */
+  /** Determines the number of cores available on the device. */
   static int availableProcessors() {
     int cpus = Runtime.getRuntime().availableProcessors();
     if (Build.VERSION.SDK_INT < 17) {
@@ -50,12 +46,14 @@ private static int getCoreCountPre17() {
     try {
       File cpuInfo = new File(CPU_LOCATION);
       final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-      cpus = cpuInfo.listFiles(new FilenameFilter() {
-        @Override
-        public boolean accept(File file, String s) {
-          return cpuNamePattern.matcher(s).matches();
-        }
-      });
+      cpus =
+          cpuInfo.listFiles(
+              new FilenameFilter() {
+                @Override
+                public boolean accept(File file, String s) {
+                  return cpuNamePattern.matcher(s).matches();
+                }
+              });
     } catch (Throwable t) {
       if (Log.isLoggable(TAG, Log.ERROR)) {
         Log.e(TAG, "Failed to calculate accurate cpu count", t);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index a8c5d641c..6608f00ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -30,8 +30,7 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  @VisibleForTesting
-  static final String TAG = "PreFillRunner";
+  @VisibleForTesting static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -45,14 +44,10 @@
    */
   static final long INITIAL_BACKOFF_MS = 40;
 
-  /**
-   * The amount by which the current backoff time is multiplied each time we detect a GC.
-   */
+  /** The amount by which the current backoff time is multiplied each time we detect a GC. */
   static final int BACKOFF_RATIO = 4;
 
-  /**
-   * The maximum amount of time in ms we wait before continuing to allocate.
-   */
+  /** The maximum amount of time in ms we wait before continuing to allocate. */
   static final long MAX_BACKOFF_MS = TimeUnit.SECONDS.toMillis(1);
 
   private final BitmapPool bitmapPool;
@@ -134,9 +129,16 @@ boolean allocate() {
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
-                + toAllocate.getConfig() + " size: " + bitmapSize);
+        Log.d(
+            TAG,
+            "allocated ["
+                + toAllocate.getWidth()
+                + "x"
+                + toAllocate.getHeight()
+                + "] "
+                + toAllocate.getConfig()
+                + " size: "
+                + bitmapSize);
       }
     }
 
@@ -168,7 +170,7 @@ private long getNextDelay() {
 
     @Synthetic
     @SuppressWarnings("WeakerAccess")
-    UniqueKey() { }
+    UniqueKey() {}
 
     @Override
     public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index 09d00876d..cd7d3d2d1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -12,8 +12,8 @@
 import java.util.Map;
 
 /**
- * A class for pre-filling {@link android.graphics.Bitmap Bitmaps} in a
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
+ * A class for pre-filling {@link android.graphics.Bitmap Bitmaps} in a {@link
+ * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
  */
 public final class BitmapPreFiller {
 
@@ -24,8 +24,8 @@
 
   private BitmapPreFillRunner current;
 
-  public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
-      DecodeFormat defaultFormat) {
+  public BitmapPreFiller(
+      MemoryCache memoryCache, BitmapPool bitmapPool, DecodeFormat defaultFormat) {
     this.memoryCache = memoryCache;
     this.bitmapPool = bitmapPool;
     this.defaultFormat = defaultFormat;
@@ -43,7 +43,8 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
       if (builder.getConfig() == null) {
         builder.setConfig(
             defaultFormat == DecodeFormat.PREFER_ARGB_8888
-            ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+                ? Bitmap.Config.ARGB_8888
+                : Bitmap.Config.RGB_565);
       }
       bitmapAttributes[i] = builder.build();
     }
@@ -80,4 +81,3 @@ private static int getSizeInBytes(PreFillType size) {
     return Util.getBitmapByteSize(size.getWidth(), size.getHeight(), size.getConfig());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index 31a8b529a..3f1975894 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -6,13 +6,12 @@
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * A container for a put of options used to pre-fill a
- * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} with {@link Bitmap Bitmaps} of a
- * single size and configuration.
+ * A container for a put of options used to pre-fill a {@link
+ * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} with {@link Bitmap Bitmaps} of a single
+ * size and configuration.
  */
 public final class PreFillType {
-  @VisibleForTesting
-  static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
+  @VisibleForTesting static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
   private final int width;
   private final int height;
   private final Bitmap.Config config;
@@ -21,13 +20,13 @@
   /**
    * Constructor for a single type of {@link android.graphics.Bitmap}.
    *
-   * @param width  The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param width The width in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
    * @param height The height in pixels of the {@link android.graphics.Bitmap Bitmaps} to pre-fill.
-   * @param config The {@link android.graphics.Bitmap.Config} of the
-   *               {@link android.graphics.Bitmap Bitmaps} to pre-fill.
+   * @param config The {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap
+   *     Bitmaps} to pre-fill.
    * @param weight An integer indicating how to balance pre-filling this size and configuration of
-   *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
-   *               be being pre-filled.
+   *     {@link android.graphics.Bitmap} against any other sizes/configurations that may be being
+   *     pre-filled.
    */
   PreFillType(int width, int height, Bitmap.Config config, int weight) {
     this.config = Preconditions.checkNotNull(config, "Config must not be null");
@@ -36,31 +35,25 @@
     this.weight = weight;
   }
 
-  /**
-   * Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-   */
+  /** Returns the width in pixels of the {@link android.graphics.Bitmap Bitmaps}. */
   int getWidth() {
     return width;
   }
 
-  /**
-   * Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}.
-   */
+  /** Returns the height in pixels of the {@link android.graphics.Bitmap Bitmaps}. */
   int getHeight() {
     return height;
   }
 
   /**
-   * Returns the {@link android.graphics.Bitmap.Config} of the
-   * {@link android.graphics.Bitmap Bitmaps}.
+   * Returns the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap
+   * Bitmaps}.
    */
   Bitmap.Config getConfig() {
     return config;
   }
 
-  /**
-   * Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type.
-   */
+  /** Returns the weight of the {@link android.graphics.Bitmap Bitmaps} of this type. */
   int getWeight() {
     return weight;
   }
@@ -69,7 +62,9 @@ int getWeight() {
   public boolean equals(Object o) {
     if (o instanceof PreFillType) {
       PreFillType other = (PreFillType) o;
-      return height == other.height && width == other.width && weight == other.weight
+      return height == other.height
+          && width == other.width
+          && weight == other.weight
           && config == other.config;
     }
     return false;
@@ -86,13 +81,19 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return "PreFillSize{" + "width=" + width + ", height=" + height + ", config=" + config
-        + ", weight=" + weight + '}';
+    return "PreFillSize{"
+        + "width="
+        + width
+        + ", height="
+        + height
+        + ", config="
+        + config
+        + ", weight="
+        + weight
+        + '}';
   }
 
-  /**
-   * Builder for {@link PreFillType}.
-   */
+  /** Builder for {@link PreFillType}. */
   public static class Builder {
     private final int width;
     private final int height;
@@ -114,7 +115,7 @@ public Builder(int size) {
      * Constructor for a builder that uses the given dimensions as the dimensions of the Bitmaps to
      * prefill.
      *
-     * @param width  The width in pixels of the Bitmaps to prefill.
+     * @param width The width in pixels of the Bitmaps to prefill.
      * @param height The height in pixels of the Bitmaps to prefill.
      */
     public Builder(int width, int height) {
@@ -139,9 +140,7 @@ public Builder setConfig(@Nullable Bitmap.Config config) {
       return this;
     }
 
-    /**
-     * Returns the current {@link android.graphics.Bitmap.Config}.
-     */
+    /** Returns the current {@link android.graphics.Bitmap.Config}. */
     Bitmap.Config getConfig() {
       return config;
     }
@@ -151,8 +150,8 @@ public Builder setConfig(@Nullable Bitmap.Config config) {
      * other requested types.
      *
      * @param weight An integer indicating how to balance pre-filling this size and configuration of
-     *               {@link android.graphics.Bitmap} against any other sizes/configurations that may
-     *               be being pre-filled.
+     *     {@link android.graphics.Bitmap} against any other sizes/configurations that may be being
+     *     pre-filled.
      * @return This builder.
      */
     public Builder setWeight(int weight) {
@@ -163,9 +162,7 @@ public Builder setWeight(int weight) {
       return this;
     }
 
-    /**
-     * Returns a new {@link PreFillType}.
-     */
+    /** Returns a new {@link PreFillType}. */
     PreFillType build() {
       return new PreFillType(width, height, config, weight);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index 9eea06323..c9309ce83 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -34,16 +34,17 @@ public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> facto
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
     return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
   }
 
   @Override
   public boolean handles(@NonNull Uri model) {
-    return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
-        .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
+    return ContentResolver.SCHEME_FILE.equals(model.getScheme())
+        && !model.getPathSegments().isEmpty()
+        && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
   }
 
   /**
@@ -55,11 +56,9 @@ public boolean handles(@NonNull Uri model) {
     DataFetcher<Data> buildFetcher(AssetManager assetManager, String assetPath);
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from asset manager Uris.
-   */
-  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
-      AssetFetcherFactory<InputStream> {
+  /** Factory for loading {@link InputStream}s from asset manager Uris. */
+  public static class StreamFactory
+      implements ModelLoaderFactory<Uri, InputStream>, AssetFetcherFactory<InputStream> {
 
     private final AssetManager assetManager;
 
@@ -84,12 +83,10 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from asset manager Uris.
-   */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
-      AssetFetcherFactory<ParcelFileDescriptor> {
+  /** Factory for loading {@link ParcelFileDescriptor}s from asset manager Uris. */
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
+          AssetFetcherFactory<ParcelFileDescriptor> {
 
     private final AssetManager assetManager;
 
@@ -109,8 +106,8 @@ public void teardown() {
     }
 
     @Override
-    public DataFetcher<ParcelFileDescriptor> buildFetcher(AssetManager assetManager,
-        String assetPath) {
+    public DataFetcher<ParcelFileDescriptor> buildFetcher(
+        AssetManager assetManager, String assetPath) {
       return new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index bb8213fc1..4e1e65198 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -53,8 +53,8 @@ public boolean handles(@NonNull byte[] model) {
 
     /**
      * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
-     *              lead to OOMs. In practice it's unlikely that users would pass an array into
-     *              Glide and then mutate it.
+     *     lead to OOMs. In practice it's unlikely that users would pass an array into Glide and
+     *     then mutate it.
      */
     @SuppressWarnings("PMD.ArrayIsStoredDirectly")
     Fetcher(byte[] model, Converter<Data> converter) {
@@ -92,25 +92,26 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Factory for {@link com.bumptech.glide.load.model.ByteArrayLoader} and
-   * {@link java.nio.ByteBuffer}.
+   * Factory for {@link com.bumptech.glide.load.model.ByteArrayLoader} and {@link
+   * java.nio.ByteBuffer}.
    */
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
     @NonNull
     @Override
     public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
-      return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
-        @Override
-        public ByteBuffer convert(byte[] model) {
-          return ByteBuffer.wrap(model);
-        }
-
-        @Override
-        public Class<ByteBuffer> getDataClass() {
-          return ByteBuffer.class;
-        }
-      });
+      return new ByteArrayLoader<>(
+          new Converter<ByteBuffer>() {
+            @Override
+            public ByteBuffer convert(byte[] model) {
+              return ByteBuffer.wrap(model);
+            }
+
+            @Override
+            public Class<ByteBuffer> getDataClass() {
+              return ByteBuffer.class;
+            }
+          });
     }
 
     @Override
@@ -119,25 +120,24 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for {@link ByteArrayLoader} and {@link java.io.InputStream}.
-   */
+  /** Factory for {@link ByteArrayLoader} and {@link java.io.InputStream}. */
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
     @NonNull
     @Override
     public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
-      return new ByteArrayLoader<>(new Converter<InputStream>() {
-        @Override
-        public InputStream convert(byte[] model) {
-          return new ByteArrayInputStream(model);
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      });
+      return new ByteArrayLoader<>(
+          new Converter<InputStream>() {
+            @Override
+            public InputStream convert(byte[] model) {
+              return new ByteArrayInputStream(model);
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          });
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 9c8b6a121..02732d794 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -9,9 +9,7 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * Writes {@link ByteBuffer ByteBuffers} to {@link File Files}.
- */
+/** Writes {@link ByteBuffer ByteBuffers} to {@link File Files}. */
 public class ByteBufferEncoder implements Encoder<ByteBuffer> {
   private static final String TAG = "ByteBufferEncoder";
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index c56d04b08..4ab423c37 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -13,15 +13,13 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}.
- */
+/** Loads {@link java.nio.ByteBuffer}s using NIO for {@link java.io.File}. */
 public class ByteBufferFileLoader implements ModelLoader<File, ByteBuffer> {
   private static final String TAG = "ByteBufferFileLoader";
 
   @Override
-  public LoadData<ByteBuffer> buildLoadData(@NonNull File file, int width, int height,
-      @NonNull Options options) {
+  public LoadData<ByteBuffer> buildLoadData(
+      @NonNull File file, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
   }
 
@@ -30,9 +28,7 @@ public boolean handles(@NonNull File file) {
     return true;
   }
 
-  /**
-   * Factory for {@link com.bumptech.glide.load.model.ByteBufferFileLoader}.
-   */
+  /** Factory for {@link com.bumptech.glide.load.model.ByteBufferFileLoader}. */
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
     @NonNull
@@ -58,8 +54,8 @@ public void teardown() {
     }
 
     @Override
-    public void loadData(@NonNull Priority priority,
-        @NonNull DataCallback<? super ByteBuffer> callback) {
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super ByteBuffer> callback) {
       ByteBuffer result;
       try {
         result = ByteBufferUtil.fromFile(file);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 646c43907..a47628675 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -14,11 +14,13 @@
 /**
  * A simple model loader for loading data from a Data URL String.
  *
- * Data URIs use the "data" scheme.
+ * <p>Data URIs use the "data" scheme.
  *
- * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt for a complete description of the 'data' URL scheme.
  *
- * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
+ * <p>Briefly, a 'data' URL has the form:
+ *
+ * <pre>data:[mediatype][;base64],some_data</pre>
  *
  * @param <Model> The type of Model that we can retrieve data for, e.g. {@link String}.
  * @param <Data> The type of data that can be opened, e.g. {@link InputStream}.
@@ -36,8 +38,8 @@ public DataUrlLoader(DataDecoder<Data> dataDecoder) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     return new LoadData<>(
         new ObjectKey(model), new DataUriFetcher<>(model.toString(), dataDecoder));
   }
@@ -121,45 +123,45 @@ public DataSource getDataSource() {
     private final DataDecoder<InputStream> opener;
 
     public StreamFactory() {
-      opener = new DataDecoder<InputStream>() {
-        @Override
-        public InputStream decode(String url) {
-          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
-            throw new IllegalArgumentException("Not a valid image data URL.");
-          }
-
-          int commaIndex = url.indexOf(',');
-          if (commaIndex == -1) {
-            throw new IllegalArgumentException("Missing comma in data URL.");
-          }
-
-          String beforeComma = url.substring(0, commaIndex);
-          if (!beforeComma.endsWith(BASE64_TAG)) {
-            throw new IllegalArgumentException("Not a base64 image data URL.");
-          }
-
-          String afterComma = url.substring(commaIndex + 1);
-          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
-
-          return new ByteArrayInputStream(bytes);
-        }
-
-        @Override
-        public void close(InputStream inputStream) throws IOException {
-          inputStream.close();
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      };
+      opener =
+          new DataDecoder<InputStream>() {
+            @Override
+            public InputStream decode(String url) {
+              if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+                throw new IllegalArgumentException("Not a valid image data URL.");
+              }
+
+              int commaIndex = url.indexOf(',');
+              if (commaIndex == -1) {
+                throw new IllegalArgumentException("Missing comma in data URL.");
+              }
+
+              String beforeComma = url.substring(0, commaIndex);
+              if (!beforeComma.endsWith(BASE64_TAG)) {
+                throw new IllegalArgumentException("Not a base64 image data URL.");
+              }
+
+              String afterComma = url.substring(commaIndex + 1);
+              byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+              return new ByteArrayInputStream(bytes);
+            }
+
+            @Override
+            public void close(InputStream inputStream) throws IOException {
+              inputStream.close();
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          };
     }
 
     @NonNull
     @Override
-    public ModelLoader<Model, InputStream> build(
-        @NonNull MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index e4f0d9178..1ea6be3fe 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -18,7 +18,7 @@
  * A simple model loader for loading data from {@link File}s.
  *
  * @param <Data> The type of data loaded from the given {@link java.io.File} ({@link
- *               java.io.InputStream} or {@link java.io.FileDescriptor} etc).
+ *     java.io.InputStream} or {@link java.io.FileDescriptor} etc).
  */
 public class FileLoader<Data> implements ModelLoader<File, Data> {
   private static final String TAG = "FileLoader";
@@ -32,8 +32,8 @@ public FileLoader(FileOpener<Data> fileOpener) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull File model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull File model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
   }
 
@@ -44,11 +44,14 @@ public boolean handles(@NonNull File model) {
 
   /**
    * Allows opening a specific type of data from a {@link java.io.File}.
+   *
    * @param <Data> The type of data that can be opened.
    */
   public interface FileOpener<Data> {
     Data open(File file) throws FileNotFoundException;
+
     void close(Data data) throws IOException;
+
     Class<Data> getDataClass();
   }
 
@@ -107,6 +110,7 @@ public DataSource getDataSource() {
 
   /**
    * Base factory for loading data from {@link java.io.File files}.
+   *
    * @param <Data> The type of data that will be loaded for a given {@link java.io.File}.
    */
   public static class Factory<Data> implements ModelLoaderFactory<File, Data> {
@@ -128,52 +132,50 @@ public final void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from {@link File}s.
-   */
+  /** Factory for loading {@link InputStream}s from {@link File}s. */
   public static class StreamFactory extends Factory<InputStream> {
     public StreamFactory() {
-      super(new FileOpener<InputStream>() {
-        @Override
-        public InputStream open(File file) throws FileNotFoundException {
-          return new FileInputStream(file);
-        }
-
-        @Override
-        public void close(InputStream inputStream) throws IOException {
-          inputStream.close();
-        }
-
-        @Override
-        public Class<InputStream> getDataClass() {
-          return InputStream.class;
-        }
-      });
+      super(
+          new FileOpener<InputStream>() {
+            @Override
+            public InputStream open(File file) throws FileNotFoundException {
+              return new FileInputStream(file);
+            }
+
+            @Override
+            public void close(InputStream inputStream) throws IOException {
+              inputStream.close();
+            }
+
+            @Override
+            public Class<InputStream> getDataClass() {
+              return InputStream.class;
+            }
+          });
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from {@link File}s.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from {@link File}s. */
   public static class FileDescriptorFactory extends Factory<ParcelFileDescriptor> {
 
     public FileDescriptorFactory() {
-      super(new FileOpener<ParcelFileDescriptor>() {
-        @Override
-        public ParcelFileDescriptor open(File file) throws FileNotFoundException {
-          return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
-        }
-
-        @Override
-        public void close(ParcelFileDescriptor parcelFileDescriptor) throws IOException {
-          parcelFileDescriptor.close();
-        }
-
-        @Override
-        public Class<ParcelFileDescriptor> getDataClass() {
-          return ParcelFileDescriptor.class;
-        }
-      });
+      super(
+          new FileOpener<ParcelFileDescriptor>() {
+            @Override
+            public ParcelFileDescriptor open(File file) throws FileNotFoundException {
+              return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+            }
+
+            @Override
+            public void close(ParcelFileDescriptor parcelFileDescriptor) throws IOException {
+              parcelFileDescriptor.close();
+            }
+
+            @Override
+            public Class<ParcelFileDescriptor> getDataClass() {
+              return ParcelFileDescriptor.class;
+            }
+          });
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 4661d3b0d..a64f7fd21 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -16,15 +16,14 @@
  * escaped and avoiding unnecessary URL instantiations for loaders that require only string urls
  * rather than URL objects.
  *
- * <p>  Users wishing to replace the class for handling URLs must register a factory using
- * GlideUrl. </p>
+ * <p>Users wishing to replace the class for handling URLs must register a factory using GlideUrl.
  *
- * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
+ * <p>To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
  * URL, call {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache
- * key, call {@link #getCacheKey()}. </p>
+ * key, call {@link #getCacheKey()}.
  *
- * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
- * convenience. </p>
+ * <p>This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
+ * convenience.
  */
 public class GlideUrl implements Key {
   private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";
@@ -94,9 +93,7 @@ private String getSafeStringUrl() {
     return safeStringUrl;
   }
 
-  /**
-   * Returns a non-null {@link Map} containing headers.
-   */
+  /** Returns a non-null {@link Map} containing headers. */
   public Map<String, String> getHeaders() {
     return headers.getHeaders();
   }
@@ -106,8 +103,7 @@ private String getSafeStringUrl() {
    *
    * <p>This method does not include headers.
    *
-   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
-   * input.
+   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
@@ -136,8 +132,7 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
   public boolean equals(Object o) {
     if (o instanceof GlideUrl) {
       GlideUrl other = (GlideUrl) o;
-      return getCacheKey().equals(other.getCacheKey())
-          && headers.equals(other.headers);
+      return getCacheKey().equals(other.getCacheKey()) && headers.equals(other.headers);
     }
     return false;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Headers.java b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
index f55d16f4e..b6258ad30 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Headers.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java
@@ -6,7 +6,7 @@
 /**
  * An interface for a wrapper for a set of headers to be included in a Glide request.
  *
- * <p> Implementations must implement equals() and hashcode(). </p>
+ * <p>Implementations must implement equals() and hashcode().
  */
 public interface Headers {
 
@@ -16,21 +16,20 @@
    * @deprecated Use {@link #DEFAULT} instead.
    */
   @Deprecated
-  Headers NONE = new Headers() {
-      @Override
-      public Map<String, String> getHeaders() {
+  Headers NONE =
+      new Headers() {
+        @Override
+        public Map<String, String> getHeaders() {
           return Collections.emptyMap();
-      }
-  };
+        }
+      };
 
   /**
-   * A Headers object containing reasonable defaults that should be used when users don't want
-   * to provide their own headers.
+   * A Headers object containing reasonable defaults that should be used when users don't want to
+   * provide their own headers.
    */
   Headers DEFAULT = new LazyHeaders.Builder().build();
 
-  /**
-   * Returns a non-null map containing a set of headers to apply to an http request.
-   */
+  /** Returns a non-null map containing a set of headers to apply to an http request. */
   Map<String, String> getHeaders();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index c00cc434f..114e75e63 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -6,7 +6,7 @@
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
  *
- * <p> Implementations should implement equals() and hashcode() </p> .
+ * <p>Implementations should implement equals() and hashcode() .
  */
 public interface LazyHeaderFactory {
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 3a03d37b1..29a040a32 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -14,10 +14,10 @@
  * A wrapper class for a set of headers to be included in a Glide request, allowing headers to be
  * constructed lazily.
  *
- * <p> Ideally headers are constructed once and then re-used for multiple loads, rather then being
- * constructed individually for each load. </p>
+ * <p>Ideally headers are constructed once and then re-used for multiple loads, rather then being
+ * constructed individually for each load.
  *
- * <p> This class is thread safe. </p>
+ * <p>This class is thread safe.
  */
 public final class LazyHeaders implements Headers {
   private final Map<String, List<LazyHeaderFactory>> headers;
@@ -72,9 +72,7 @@ private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
 
   @Override
   public String toString() {
-    return "LazyHeaders{"
-        + "headers=" + headers
-        + '}';
+    return "LazyHeaders{" + "headers=" + headers + '}';
   }
 
   @Override
@@ -92,15 +90,15 @@ public int hashCode() {
   }
 
   /**
-   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
-   * key* lazily on a background thread.
+   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given key*
+   * lazily on a background thread.
    *
-   * <p> This class is not thread safe. </p>
+   * <p>This class is not thread safe.
    *
-   * <p> This class may include default values for User-Agent and Accept-Encoding headers. These
-   * will be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or
-   * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
-   * would usually append an additional value. </p>
+   * <p>This class may include default values for User-Agent and Accept-Encoding headers. These will
+   * be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or {@link
+   * #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)} would
+   * usually append an additional value.
    */
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
@@ -111,10 +109,10 @@ public int hashCode() {
     // images and also makes it more difficult for us to detect and prevent partial content
     // rendering. See #440.
     static {
-      Map<String, List<LazyHeaderFactory>> temp
-          = new HashMap<>(2);
+      Map<String, List<LazyHeaderFactory>> temp = new HashMap<>(2);
       if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {
-        temp.put(USER_AGENT_HEADER,
+        temp.put(
+            USER_AGENT_HEADER,
             Collections.<LazyHeaderFactory>singletonList(
                 new StringHeaderFactory(DEFAULT_USER_AGENT)));
       }
@@ -128,8 +126,8 @@ public int hashCode() {
     /**
      * Adds a value for the given header and returns this builder.
      *
-     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (i.e. an OAuth token). </p>
+     * <p>Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token).
      *
      * @see #addHeader(String, LazyHeaderFactory)
      */
@@ -138,14 +136,13 @@ public Builder addHeader(@NonNull String key, @NonNull String value) {
     }
 
     /**
-     * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given
-     * key lazily on a background thread.
+     * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given key
+     * lazily on a background thread.
      *
-     * <p> Headers may have multiple values whose order is defined by the order in which
-     * this method is called. </p>
+     * <p>Headers may have multiple values whose order is defined by the order in which this method
+     * is called.
      *
-     * <p> This class does not prevent you from adding the same value to a given key multiple
-     * times </p>
+     * <p>This class does not prevent you from adding the same value to a given key multiple times
      */
     public Builder addHeader(@NonNull String key, @NonNull LazyHeaderFactory factory) {
       if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
@@ -158,13 +155,13 @@ public Builder addHeader(@NonNull String key, @NonNull LazyHeaderFactory factory
     }
 
     /**
-     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
-     * with the given {@link LazyHeaderFactory}.
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key with the
+     * given {@link LazyHeaderFactory}.
      *
-     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     * <p>If the given value is {@code null}, the header at the given key will be removed.
      *
-     * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (i.e. an OAuth token). </p>
+     * <p>Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
+     * (i.e. an OAuth token).
      */
     @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
     public Builder setHeader(@NonNull String key, @Nullable String value) {
@@ -172,10 +169,10 @@ public Builder setHeader(@NonNull String key, @Nullable String value) {
     }
 
     /**
-     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key
-     * with the given {@link LazyHeaderFactory}.
+     * Replaces all existing {@link LazyHeaderFactory LazyHeaderFactorys} for the given key with the
+     * given {@link LazyHeaderFactory}.
      *
-     * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
+     * <p>If the given value is {@code null}, the header at the given key will be removed.
      */
     public Builder setHeader(@NonNull String key, @Nullable LazyHeaderFactory factory) {
       copyIfNecessary();
@@ -210,9 +207,7 @@ private void copyIfNecessary() {
       }
     }
 
-    /**
-     * Returns a new immutable {@link LazyHeaders} object.
-     */
+    /** Returns a new immutable {@link LazyHeaders} object. */
     public LazyHeaders build() {
       copyOnModify = true;
       return new LazyHeaders(headers);
@@ -256,8 +251,7 @@ static String getSanitizedUserAgent() {
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
 
-    @NonNull
-    private final String value;
+    @NonNull private final String value;
 
     StringHeaderFactory(@NonNull String value) {
       this.value = value;
@@ -270,9 +264,7 @@ public String buildHeader() {
 
     @Override
     public String toString() {
-      return "StringHeaderFactory{"
-          + "value='" + value + '\''
-          + '}';
+      return "StringHeaderFactory{" + "value='" + value + '\'' + '}';
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index 6b36fb0ec..2525a41fa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -15,9 +15,7 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 
-/**
- * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
- */
+/** Loads the file path for {@link MediaStore} owned {@link Uri uris}. */
 public final class MediaStoreFileLoader implements ModelLoader<Uri, File> {
 
   private final Context context;
@@ -29,8 +27,8 @@ public MediaStoreFileLoader(Context context) {
   }
 
   @Override
-  public LoadData<File> buildLoadData(@NonNull Uri uri, int width, int height,
-      @NonNull Options options) {
+  public LoadData<File> buildLoadData(
+      @NonNull Uri uri, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
   }
 
@@ -40,9 +38,10 @@ public boolean handles(@NonNull Uri uri) {
   }
 
   private static class FilePathFetcher implements DataFetcher<File> {
-    private static final String[] PROJECTION = new String[] {
-        MediaStore.MediaColumns.DATA,
-    };
+    private static final String[] PROJECTION =
+        new String[] {
+          MediaStore.MediaColumns.DATA,
+        };
 
     private final Context context;
     private final Uri uri;
@@ -54,8 +53,11 @@ public boolean handles(@NonNull Uri uri) {
 
     @Override
     public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super File> callback) {
-      Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
-          null /*selectionArgs*/, null /*sortOrder*/);
+      Cursor cursor =
+          context
+              .getContentResolver()
+              .query(
+                  uri, PROJECTION, null /*selection*/, null /*selectionArgs*/, null /*sortOrder*/);
 
       String filePath = null;
       if (cursor != null) {
@@ -98,9 +100,7 @@ public DataSource getDataSource() {
     }
   }
 
-  /**
-   * {@link ModelLoaderFactory} for {@link MediaStoreFileLoader}s.
-   */
+  /** {@link ModelLoaderFactory} for {@link MediaStoreFileLoader}s. */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
     private final Context context;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
index b82f75f55..7990a05ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/Model.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -2,29 +2,25 @@
 
 import android.support.annotation.Nullable;
 
-/**
- * An optional interface that models can implement to enhance control over Glide behaviors.
- */
+/** An optional interface that models can implement to enhance control over Glide behaviors. */
 public interface Model {
 
   /**
-   * Returns {@code true} if this model produces the same image using the same mechanism
-   * (server, authentication, source etc) as the given model.
-   * <p>
-   * Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
-   * to ensure that caching functions correctly.
-   * If this object returns {@code true} from this method for a given Model,
-   * it must also be equal to and have the same hash code as the given model.
-   * <p>
-   * However, this model may be equal to and have the same hash code as a given model
-   * but still return {@code false} from this method.
-   * This method optionally allows you to differentiate between Models that load the same image
-   * via multiple different means.
-   * For example one Model might load the image from server A and another model might load
-   * the same image from server B.
-   * The models must be equal to each other with the same hash code because they load
-   * the same image. However two requests made with the different models are not exactly the
-   * same because the way the image is loaded will differ.
+   * Returns {@code true} if this model produces the same image using the same mechanism (server,
+   * authentication, source etc) as the given model.
+   *
+   * <p>Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
+   * to ensure that caching functions correctly. If this object returns {@code true} from this
+   * method for a given Model, it must also be equal to and have the same hash code as the given
+   * model.
+   *
+   * <p>However, this model may be equal to and have the same hash code as a given model but still
+   * return {@code false} from this method. This method optionally allows you to differentiate
+   * between Models that load the same image via multiple different means. For example one Model
+   * might load the image from server A and another model might load the same image from server B.
+   * The models must be equal to each other with the same hash code because they load the same
+   * image. However two requests made with the different models are not exactly the same because the
+   * way the image is loaded will differ.
    */
   boolean isEquivalentTo(@Nullable Object other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index c654de2fc..c5465e5ae 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -10,8 +10,7 @@
 /**
  * A simple cache that can be used by {@link ModelLoader} and {@link ModelLoaderFactory} to cache
  * some data for a given model, width and height. For a loader that takes a model and returns a url,
- * the cache could be used to safely memoize url creation based on the width and height of the
- * view.
+ * the cache could be used to safely memoize url creation based on the width and height of the view.
  *
  * @param <A> Some Model type that implements {@link #equals} and {@link #hashCode}.
  * @param <B> Some useful type that may be expensive to create (URL, file path, etc).
@@ -28,19 +27,20 @@ public ModelCache() {
   }
 
   public ModelCache(long size) {
-    cache = new LruCache<ModelKey<A>, B>(size) {
-      @Override
-      protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
-        key.release();
-      }
-    };
+    cache =
+        new LruCache<ModelKey<A>, B>(size) {
+          @Override
+          protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
+            key.release();
+          }
+        };
   }
 
   /**
    * Get a value.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view the image is being loaded into.
    * @param height The height in pixels of the view the image is being loaded into.
    * @return The cached result, or null.
    */
@@ -55,19 +55,17 @@ public B get(A model, int width, int height) {
   /**
    * Add a value.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view the image is being loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view the image is being loaded into.
    * @param height The height in pixels of the view the image is being loaded into.
-   * @param value  The value to store.
+   * @param value The value to store.
    */
   public void put(A model, int width, int height, B value) {
     ModelKey<A> key = ModelKey.get(model, width, height);
     cache.put(key, value);
   }
 
-  /**
-   * Removes all entries from the cache.
-   */
+  /** Removes all entries from the cache. */
   public void clear() {
     cache.clearMemory();
   }
@@ -94,8 +92,7 @@ public void clear() {
       return modelKey;
     }
 
-    private ModelKey() {
-    }
+    private ModelKey() {}
 
     private void init(A model, int width, int height) {
       this.model = model;
@@ -112,7 +109,8 @@ public void release() {
     @Override
     public boolean equals(Object o) {
       if (o instanceof ModelKey) {
-        @SuppressWarnings("unchecked") ModelKey<A> other = (ModelKey<A>) o;
+        @SuppressWarnings("unchecked")
+        ModelKey<A> other = (ModelKey<A>) o;
         return width == other.width && height == other.height && model.equals(other.model);
       }
       return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index 2ef8de0dc..797690cd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -14,31 +14,30 @@
  * that can be used by an {@link DataFetcher} to obtain the data for a resource represented by the
  * model.
  *
- * <p> This interface has two objectives: 1. To translate a specific model into a data type that can
+ * <p>This interface has two objectives: 1. To translate a specific model into a data type that can
  * be decoded into a resource.
  *
- * 2. To allow a model to be combined with the dimensions of the view to fetch a resource of a
+ * <p>2. To allow a model to be combined with the dimensions of the view to fetch a resource of a
  * specific size.
  *
- * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
- * the size of a view on devices with different densities, but also allows you to use layout weights
- * or otherwise programmatically put the dimensions of the view without forcing you to fetch a
- * generic resource size.
+ * <p>This not only avoids having to duplicate dimensions in xml and in your code in order to
+ * determine the size of a view on devices with different densities, but also allows you to use
+ * layout weights or otherwise programmatically put the dimensions of the view without forcing you
+ * to fetch a generic resource size.
  *
- * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
- * your memory footprint per resource. </p>
+ * <p>The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
+ * your memory footprint per resource.
  *
  * @param <Model> The type of the model.
- * @param <Data>  The type of the data that can be used by a
- * {@link com.bumptech.glide.load.ResourceDecoder} to decode a resource.
+ * @param <Data> The type of the data that can be used by a {@link
+ *     com.bumptech.glide.load.ResourceDecoder} to decode a resource.
  */
 public interface ModelLoader<Model, Data> {
 
   /**
    * Contains a set of {@link com.bumptech.glide.load.Key Keys} identifying the source of the load,
-   * alternate cache keys pointing to equivalent data, and a
-   * {@link com.bumptech.glide.load.data.DataFetcher} that can be used to fetch data not found in
-   * cache.
+   * alternate cache keys pointing to equivalent data, and a {@link
+   * com.bumptech.glide.load.data.DataFetcher} that can be used to fetch data not found in cache.
    *
    * @param <Data> The type of data that well be loaded.
    */
@@ -51,7 +50,9 @@ public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher<Data> fetcher) {
       this(sourceKey, Collections.<Key>emptyList(), fetcher);
     }
 
-    public LoadData(@NonNull Key sourceKey, @NonNull List<Key> alternateKeys,
+    public LoadData(
+        @NonNull Key sourceKey,
+        @NonNull List<Key> alternateKeys,
         @NonNull DataFetcher<Data> fetcher) {
       this.sourceKey = Preconditions.checkNotNull(sourceKey);
       this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
@@ -60,37 +61,37 @@ public LoadData(@NonNull Key sourceKey, @NonNull List<Key> alternateKeys,
   }
 
   /**
-   * Returns a {@link com.bumptech.glide.load.model.ModelLoader.LoadData} containing a
-   * {@link com.bumptech.glide.load.data.DataFetcher} required to decode the resource
-   * represented by this model, as well as a set of {@link com.bumptech.glide.load.Key Keys} that
-   * identify the data loaded by the {@link com.bumptech.glide.load.data.DataFetcher} as well as an
-   * optional list of alternate keys from which equivalent data can be loaded. The
-   * {@link DataFetcher} will not be used if the resource is already cached.
+   * Returns a {@link com.bumptech.glide.load.model.ModelLoader.LoadData} containing a {@link
+   * com.bumptech.glide.load.data.DataFetcher} required to decode the resource represented by this
+   * model, as well as a set of {@link com.bumptech.glide.load.Key Keys} that identify the data
+   * loaded by the {@link com.bumptech.glide.load.data.DataFetcher} as well as an optional list of
+   * alternate keys from which equivalent data can be loaded. The {@link DataFetcher} will not be
+   * used if the resource is already cached.
    *
-   * <p> Note - If no valid data fetcher can be returned (for example if a model has a null URL),
-   * then it is acceptable to return a null data fetcher from this method. </p>
+   * <p>Note - If no valid data fetcher can be returned (for example if a model has a null URL),
+   * then it is acceptable to return a null data fetcher from this method.
    *
-   * @param model  The model representing the resource.
-   * @param width  The width in pixels of the view or target the resource will be loaded into, or
-   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
-   *               the resource should be loaded at its original width.
+   * @param model The model representing the resource.
+   * @param width The width in pixels of the view or target the resource will be loaded into, or
+   *     {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the
+   *     resource should be loaded at its original width.
    * @param height The height in pixels of the view or target the resource will be loaded into, or
-   *               {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that
-   *               the resource should be loaded at its original height.
+   *     {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate that the
+   *     resource should be loaded at its original height.
    */
   @Nullable
-  LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
-      @NonNull Options options);
+  LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options);
 
   /**
    * Returns true if the given model is a of a recognized type that this loader can probably load.
    *
-   * <p> For example, you may want multiple Uri -> InputStream loaders. One might handle media
-   * store Uris, another might handle asset Uris, and a third might handle file Uris etc. </p>
+   * <p>For example, you may want multiple Uri -> InputStream loaders. One might handle media store
+   * Uris, another might handle asset Uris, and a third might handle file Uris etc.
    *
-   * <p> This method is generally expected to do no I/O and complete quickly, so best effort
-   * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
-   * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
+   * <p>This method is generally expected to do no I/O and complete quickly, so best effort results
+   * are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may return
+   * {@code null} from {@link #buildLoadData(Object, int, int, Options)}
    */
   boolean handles(@NonNull Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index 921d4c488..3f19a874e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -9,16 +9,15 @@
  * An interface for creating a {@link ModelLoader} for a given model type.
  *
  * <p>The application {@link android.content.Context} can be passed in to the constructor of the
- * factory when necessary. It's unsafe to retain {@link android.app.Activity}
- * {@link android.content.Context}s in factories. The {@link android.content.Context} can be
- * obtained from
+ * factory when necessary. It's unsafe to retain {@link android.app.Activity} {@link
+ * android.content.Context}s in factories. The {@link android.content.Context} can be obtained from
  * {@link com.bumptech.glide.module.LibraryGlideModule#registerComponents(Context, Glide, Registry)}
  * in most cases.
  *
  * @param <T> The type of the model the {@link com.bumptech.glide.load.model.ModelLoader}s built by
- *            this factory can handle
+ *     this factory can handle
  * @param <Y> The type of data the {@link com.bumptech.glide.load.model.ModelLoader}s built by this
- *            factory can load.
+ *     factory can load.
  */
 public interface ModelLoaderFactory<T, Y> {
 
@@ -26,14 +25,12 @@
    * Build a concrete ModelLoader for this model type.
    *
    * @param multiFactory A map of classes to factories that can be used to construct additional
-   *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
+   *     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
   @NonNull
   ModelLoader<T, Y> build(@NonNull MultiModelLoaderFactory multiFactory);
 
-  /**
-   * A lifecycle method that will be called when this factory is about to replaced.
-   */
+  /** A lifecycle method that will be called when this factory is about to replaced. */
   void teardown();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index 1efe114f8..e2a05b4ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -45,8 +45,8 @@ private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFac
     cache.clear();
   }
 
-  public synchronized <Model, Data> void remove(@NonNull Class<Model> modelClass,
-      @NonNull Class<Data> dataClass) {
+  public synchronized <Model, Data> void remove(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
     cache.clear();
   }
@@ -89,8 +89,8 @@ private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFac
     return filteredLoaders;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
-      @NonNull Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     return multiModelLoaderFactory.build(modelClass, dataClass);
   }
 
@@ -120,7 +120,7 @@ private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFac
     private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
 
     @Synthetic
-    ModelLoaderCache() { }
+    ModelLoaderCache() {}
 
     public void clear() {
       cachedModelLoaders.clear();
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index 9d2476d9b..4aa4e5427 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -18,26 +18,27 @@
 /**
  * Allows attempting multiple ModelLoaders registered for a given model and data class.
  *
- * <p> TODO: we should try to find a way to remove this class. It exists to allow individual
+ * <p>TODO: we should try to find a way to remove this class. It exists to allow individual
  * ModelLoaders to delegate to multiple ModelLoaders without having to duplicate this logic
  * everywhere. We have very similar logic in the {@link
  * com.bumptech.glide.load.engine.DataFetcherGenerator} implementations and should try to avoid this
- * duplication. </p>
+ * duplication.
  */
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
   private final Pool<List<Throwable>> exceptionListPool;
 
-  MultiModelLoader(@NonNull List<ModelLoader<Model, Data>> modelLoaders,
+  MultiModelLoader(
+      @NonNull List<ModelLoader<Model, Data>> modelLoaders,
       @NonNull Pool<List<Throwable>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     Key sourceKey = null;
     int size = modelLoaders.size();
     List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
@@ -53,7 +54,8 @@
       }
     }
     return !fetchers.isEmpty() && sourceKey != null
-        ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool)) : null;
+        ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool))
+        : null;
   }
 
   @Override
@@ -78,8 +80,7 @@ public String toString() {
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
-    @Nullable
-    private List<Throwable> exceptions;
+    @Nullable private List<Throwable> exceptions;
     private boolean isCancelled;
 
     MultiFetcher(
@@ -92,8 +93,7 @@ public String toString() {
     }
 
     @Override
-    public void loadData(
-        @NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       this.priority = priority;
       this.callback = callback;
       exceptions = throwableListPool.acquire();
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index a286bc09d..810b9628b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -33,8 +33,8 @@ public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool)
   }
 
   @VisibleForTesting
-  MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool,
-      @NonNull Factory factory) {
+  MultiModelLoaderFactory(
+      @NonNull Pool<List<Throwable>> throwableListPool, @NonNull Factory factory) {
     this.throwableListPool = throwableListPool;
     this.factory = factory;
   }
@@ -75,8 +75,7 @@ public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool)
 
   @NonNull
   synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> remove(
-      @NonNull Class<Model> modelClass,
-      @NonNull Class<Data> dataClass) {
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     List<ModelLoaderFactory<? extends Model, ? extends Data>> factories = new ArrayList<>();
     for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
       Entry<?, ?> entry = iterator.next();
@@ -126,8 +125,8 @@ public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool)
   }
 
   @NonNull
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
-      @NonNull Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass) {
     try {
       List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
       boolean ignoredAnyEntries = false;
@@ -219,12 +218,12 @@ public boolean handles(@NonNull Class<?> modelClass) {
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
     @Synthetic
-    EmptyModelLoader() { }
+    EmptyModelLoader() {}
 
     @Nullable
     @Override
-    public LoadData<Object> buildLoadData(@NonNull Object o, int width, int height,
-        @NonNull Options options) {
+    public LoadData<Object> buildLoadData(
+        @NonNull Object o, int width, int height, @NonNull Options options) {
       return null;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 1abc1fab4..b0fe14c96 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -30,8 +30,8 @@ public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Integer model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Integer model, int width, int height, @NonNull Options options) {
     Uri uri = getResourceUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
@@ -39,10 +39,14 @@ public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
   @Nullable
   private Uri getResourceUri(Integer model) {
     try {
-      return Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://"
-          + resources.getResourcePackageName(model) + '/'
-          + resources.getResourceTypeName(model) + '/'
-          + resources.getResourceEntryName(model));
+      return Uri.parse(
+          ContentResolver.SCHEME_ANDROID_RESOURCE
+              + "://"
+              + resources.getResourcePackageName(model)
+              + '/'
+              + resources.getResourceTypeName(model)
+              + '/'
+              + resources.getResourceEntryName(model));
     } catch (Resources.NotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Received invalid resource id: " + model, e);
@@ -57,9 +61,7 @@ public boolean handles(@NonNull Integer model) {
     return true;
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from Android resource ids.
-   */
+  /** Factory for loading {@link InputStream}s from Android resource ids. */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
     private final Resources resources;
@@ -80,9 +82,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from Android resource ids.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from Android resource ids. */
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
@@ -105,9 +105,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Loads {@link AssetFileDescriptor}s from resource ids.
-   */
+  /** Loads {@link AssetFileDescriptor}s from resource ids. */
   public static final class AssetFileDescriptorFactory
       implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
 
@@ -129,9 +127,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading resource {@link Uri}s from Android resource ids.
-   */
+  /** Factory for loading resource {@link Uri}s from Android resource ids. */
   public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {
 
     private final Resources resources;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 9fa8a0ec7..6c05d3bf9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -12,8 +12,7 @@
 import java.io.OutputStream;
 
 /**
- * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to
- * disk.
+ * An {@link com.bumptech.glide.load.Encoder} that can write an {@link java.io.InputStream} to disk.
  */
 public class StreamEncoder implements Encoder<InputStream> {
   private static final String TAG = "StreamEncoder";
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index c00fac18e..9256c0168 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -26,8 +26,8 @@ public StringLoader(ModelLoader<Uri, Data> uriLoader) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull String model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull String model, int width, int height, @NonNull Options options) {
     Uri uri = parseUri(model);
     if (uri == null || !uriLoader.handles(uri)) {
       return null;
@@ -47,7 +47,7 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+      // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
     } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
@@ -64,15 +64,12 @@ private static Uri toFileUri(String path) {
     return Uri.fromFile(new File(path));
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from Strings.
-   */
+  /** Factory for loading {@link InputStream}s from Strings. */
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @NonNull
     @Override
-    public ModelLoader<String, InputStream> build(
-        @NonNull MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -82,9 +79,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Factory for loading {@link ParcelFileDescriptor}s from Strings.
-   */
+  /** Factory for loading {@link ParcelFileDescriptor}s from Strings. */
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
@@ -101,9 +96,7 @@ public void teardown() {
     }
   }
 
-  /**
-   * Loads {@link AssetFileDescriptor}s from Strings.
-   */
+  /** Loads {@link AssetFileDescriptor}s from Strings. */
   public static final class AssetFileDescriptorFactory
       implements ModelLoaderFactory<String, AssetFileDescriptor> {
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 670e86986..a730c89ae 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -22,9 +22,7 @@
     return (UnitModelLoader<T>) INSTANCE;
   }
 
-  /**
-   * @deprecated Use {@link #getInstance()} instead.
-   */
+  /** @deprecated Use {@link #getInstance()} instead. */
   // Need constructor to document deprecation, will be removed, when constructor is privatized.
   @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
   @Deprecated
@@ -33,8 +31,8 @@ public UnitModelLoader() {
   }
 
   @Override
-  public LoadData<Model> buildLoadData(@NonNull Model model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Model> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
   }
 
@@ -52,8 +50,8 @@ public boolean handles(@NonNull Model model) {
     }
 
     @Override
-    public void loadData(@NonNull Priority priority,
-        @NonNull DataCallback<? super Model> callback) {
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super Model> callback) {
       callback.onDataReady(resource);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 77a316dd4..0afd33f3f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -18,23 +18,21 @@
 import java.util.Set;
 
 /**
- * A ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s
- * directly and routes remote {@link android.net.Uri}s to a wrapped
- * {@link com.bumptech.glide.load.model.ModelLoader} that handles
- * {@link com.bumptech.glide.load.model.GlideUrl}s.
+ * A ModelLoader for {@link android.net.Uri}s that handles local {@link android.net.Uri}s directly
+ * and routes remote {@link android.net.Uri}s to a wrapped {@link
+ * com.bumptech.glide.load.model.ModelLoader} that handles {@link
+ * com.bumptech.glide.load.model.GlideUrl}s.
  *
  * @param <Data> The type of data that will be retrieved for {@link android.net.Uri}s.
  */
 public class UriLoader<Data> implements ModelLoader<Uri, Data> {
-  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
-      new HashSet<>(
-          Arrays.asList(
-              ContentResolver.SCHEME_FILE,
-              ContentResolver.SCHEME_ANDROID_RESOURCE,
-              ContentResolver.SCHEME_CONTENT
-          )
-      )
-  );
+  private static final Set<String> SCHEMES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  ContentResolver.SCHEME_FILE,
+                  ContentResolver.SCHEME_ANDROID_RESOURCE,
+                  ContentResolver.SCHEME_CONTENT)));
 
   private final LocalUriFetcherFactory<Data> factory;
 
@@ -45,8 +43,8 @@ public UriLoader(LocalUriFetcherFactory<Data> factory) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
@@ -64,11 +62,9 @@ public boolean handles(@NonNull Uri model) {
     DataFetcher<Data> build(Uri uri);
   }
 
-  /**
-   * Loads {@link InputStream}s from {@link Uri}s.
-   */
-  public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
-      LocalUriFetcherFactory<InputStream> {
+  /** Loads {@link InputStream}s from {@link Uri}s. */
+  public static class StreamFactory
+      implements ModelLoaderFactory<Uri, InputStream>, LocalUriFetcherFactory<InputStream> {
 
     private final ContentResolver contentResolver;
 
@@ -93,12 +89,10 @@ public void teardown() {
     }
   }
 
-  /**
-   * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
-   */
+  /** Loads {@link ParcelFileDescriptor}s from {@link Uri}s. */
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
-      LocalUriFetcherFactory<ParcelFileDescriptor> {
+          LocalUriFetcherFactory<ParcelFileDescriptor> {
 
     private final ContentResolver contentResolver;
 
@@ -123,12 +117,10 @@ public void teardown() {
     }
   }
 
-  /**
-   * Loads {@link AssetFileDescriptor}s from {@link Uri}s.
-   */
+  /** Loads {@link AssetFileDescriptor}s from {@link Uri}s. */
   public static final class AssetFileDescriptorFactory
       implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
-      LocalUriFetcherFactory<AssetFileDescriptor> {
+          LocalUriFetcherFactory<AssetFileDescriptor> {
 
     private final ContentResolver contentResolver;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f51b8698f..d560e2ee2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -16,14 +16,8 @@
  * @param <Data> The type of data this Loader will obtain for a {@link Uri}.
  */
 public class UrlUriLoader<Data> implements ModelLoader<Uri, Data> {
-  private static final Set<String> SCHEMES = Collections.unmodifiableSet(
-      new HashSet<>(
-          Arrays.asList(
-              "http",
-              "https"
-          )
-      )
-  );
+  private static final Set<String> SCHEMES =
+      Collections.unmodifiableSet(new HashSet<>(Arrays.asList("http", "https")));
   private final ModelLoader<GlideUrl, Data> urlLoader;
 
   // Public API.
@@ -33,8 +27,8 @@ public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(@NonNull Uri uri, int width, int height,
-      @NonNull Options options) {
+  public LoadData<Data> buildLoadData(
+      @NonNull Uri uri, int width, int height, @NonNull Options options) {
     GlideUrl glideUrl = new GlideUrl(uri.toString());
     return urlLoader.buildLoadData(glideUrl, width, height, options);
   }
@@ -45,8 +39,8 @@ public boolean handles(@NonNull Uri uri) {
   }
 
   /**
-   * Loads {@link java.io.InputStream InputStreams} from {@link android.net.Uri Uris} with http
-   * or https schemes.
+   * Loads {@link java.io.InputStream InputStreams} from {@link android.net.Uri Uris} with http or
+   * https schemes.
    */
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index 20c765776..90063bf70 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -29,7 +29,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader)
     this(concreteLoader, null);
   }
 
-  protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+  protected BaseGlideUrlLoader(
+      ModelLoader<GlideUrl, InputStream> concreteLoader,
       @Nullable ModelCache<Model, GlideUrl> modelCache) {
     this.concreteLoader = concreteLoader;
     this.modelCache = modelCache;
@@ -37,8 +38,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(@NonNull Model model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Model model, int width, int height, @NonNull Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
       result = modelCache.get(model, width, height);
@@ -60,12 +61,14 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     // TODO: this is expensive and slow to calculate every time, we should either cache these, or
     // try to come up with a way to avoid finding them when not necessary.
     List<String> alternateUrls = getAlternateUrls(model, width, height, options);
-    LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
-        options);
+    LoadData<InputStream> concreteLoaderData =
+        concreteLoader.buildLoadData(result, width, height, options);
     if (concreteLoaderData == null || alternateUrls.isEmpty()) {
       return concreteLoaderData;
     } else {
-      return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
+      return new LoadData<>(
+          concreteLoaderData.sourceKey,
+          getAlternateKeys(alternateUrls),
           concreteLoaderData.fetcher);
     }
   }
@@ -83,8 +86,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
   /**
    * Returns a valid url http:// or https:// for the given model and dimensions as a string.
    *
-   * @param model  The model.
-   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param model The model.
+   * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
   protected abstract String getUrl(Model model, int width, int height, Options options);
@@ -94,14 +97,13 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * data can be obtained (usually the same image with the same aspect ratio, but in a larger size)
    * as the primary url.
    *
-   * <p> Implementing this method allows Glide to fulfill requests for bucketed images in smaller
-   * bucket sizes using already cached data for larger bucket sizes. </p>
+   * <p>Implementing this method allows Glide to fulfill requests for bucketed images in smaller
+   * bucket sizes using already cached data for larger bucket sizes.
    *
-   * @param width  The width in pixels of the view/target the image will be loaded into.
+   * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
-  protected List<String> getAlternateUrls(Model model, int width, int height,
-      Options options) {
+  protected List<String> getAlternateUrls(Model model, int width, int height, Options options) {
     return Collections.emptyList();
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index e149e1916..8e748d3ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -25,8 +25,8 @@
    *
    * <p>Defaults to 2500ms.
    */
-  public static final Option<Integer> TIMEOUT = Option.memory(
-      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
+  public static final Option<Integer> TIMEOUT =
+      Option.memory("com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
 
   @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
@@ -39,8 +39,8 @@ public HttpGlideUrlLoader(@Nullable ModelCache<GlideUrl, GlideUrl> modelCache) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
     // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
     // spent parsing urls.
     GlideUrl url = model;
@@ -60,9 +60,7 @@ public boolean handles(@NonNull GlideUrl model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link HttpGlideUrlLoader}s.
-   */
+  /** The default factory for {@link HttpGlideUrlLoader}s. */
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index 7ff6639b2..34a1b60bb 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -13,9 +13,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
-/**
- * Loads {@link InputStream}s from http or https {@link Uri}s.
- */
+/** Loads {@link InputStream}s from http or https {@link Uri}s. */
 public class HttpUriLoader implements ModelLoader<Uri, InputStream> {
   private static final Set<String> SCHEMES =
       Collections.unmodifiableSet(new HashSet<>(Arrays.asList("http", "https")));
@@ -29,8 +27,8 @@ public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
   }
 
@@ -39,9 +37,7 @@ public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from http/https {@link Uri}s.
-   */
+  /** Factory for loading {@link InputStream}s from http/https {@link Uri}s. */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index aba0fe3cf..454d49d3a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -26,8 +26,8 @@ public MediaStoreImageThumbLoader(Context context) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
     } else {
@@ -40,9 +40,7 @@ public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreImageUri(model);
   }
 
-  /**
-   * Factory that loads {@link InputStream}s from media store image {@link Uri}s.
-   */
+  /** Factory that loads {@link InputStream}s from media store image {@link Uri}s. */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     private final Context context;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 0685decb1..aa008fb25 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -18,10 +18,10 @@
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
- * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
- * requests for specific frames.
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to {@link
+ * VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media store does
+ * not use a defined frame to generate the thumbnail, so we cannot accurately fulfill requests for
+ * specific frames.
  */
 public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
   private final Context context;
@@ -34,8 +34,8 @@ public MediaStoreVideoThumbLoader(Context context) {
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull Uri model, int width, int height, @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index c3995affa..bbfabd258 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -25,8 +25,8 @@ public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(@NonNull URL model, int width, int height,
-      @NonNull Options options) {
+  public LoadData<InputStream> buildLoadData(
+      @NonNull URL model, int width, int height, @NonNull Options options) {
     return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
   }
 
@@ -35,9 +35,7 @@ public boolean handles(@NonNull URL model) {
     return true;
   }
 
-  /**
-   * Factory for loading {@link InputStream}s from {@link URL}s.
-   */
+  /** Factory for loading {@link InputStream}s from {@link URL}s. */
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
     @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 9602c2564..e37e0bc28 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -31,8 +31,8 @@ private UnitTransformation() {
 
   @NonNull
   @Override
-  public Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
-      int outWidth, int outHeight) {
+  public Resource<T> transform(
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     return resource;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 40a2d4c92..239962228 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -29,8 +29,8 @@ public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap>
   }
 
   /**
-   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool}
-   * is ignored.
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool} is
+   *     ignored.
    */
   @Deprecated
   public BitmapDrawableDecoder(
@@ -52,8 +52,8 @@ public boolean handles(@NonNull DataType source, @NonNull Options options) throw
   }
 
   @Override
-  public Resource<BitmapDrawable> decode(@NonNull DataType source, int width, int height,
-      @NonNull Options options)
+  public Resource<BitmapDrawable> decode(
+      @NonNull DataType source, int width, int height, @NonNull Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
     return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index a955d9d05..87f1bcc72 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -10,9 +10,7 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import java.io.File;
 
-/**
- * Encodes {@link android.graphics.drawable.BitmapDrawable}s.
- */
+/** Encodes {@link android.graphics.drawable.BitmapDrawable}s. */
 public class BitmapDrawableEncoder implements ResourceEncoder<BitmapDrawable> {
 
   private final BitmapPool bitmapPool;
@@ -24,8 +22,8 @@ public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> enco
   }
 
   @Override
-  public boolean encode(@NonNull Resource<BitmapDrawable> data, @NonNull File file,
-      @NonNull Options options) {
+  public boolean encode(
+      @NonNull Resource<BitmapDrawable> data, @NonNull File file, @NonNull Options options) {
     return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 736c02ea6..533e2d651 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -8,14 +8,13 @@
 import com.bumptech.glide.util.Util;
 
 /**
- * A {@link com.bumptech.glide.load.engine.Resource} that wraps an
- * {@link android.graphics.drawable.BitmapDrawable}
+ * A {@link com.bumptech.glide.load.engine.Resource} that wraps an {@link
+ * android.graphics.drawable.BitmapDrawable}
  *
- * <p> This class ensures that every call to {@link #get()}} always returns a new
- * {@link android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple
- * views and is also responsible for returning the underlying {@link android.graphics.Bitmap} to the
- * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
- * recycled. </p>
+ * <p>This class ensures that every call to {@link #get()}} always returns a new {@link
+ * android.graphics.drawable.BitmapDrawable} to avoid rendering issues if used in multiple views and
+ * is also responsible for returning the underlying {@link android.graphics.Bitmap} to the given
+ * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is recycled.
  */
 public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
     implements Initializable {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 2b3bdc574..af9d1cbbb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -30,8 +30,10 @@ public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
   @NonNull
   @Override
   public Resource<BitmapDrawable> transform(
-      @NonNull Context context, @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
-      int outWidth, int outHeight) {
+      @NonNull Context context,
+      @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
+      int outWidth,
+      int outHeight) {
     Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
     Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
     return convertToBitmapDrawableResource(transformed);
@@ -49,8 +51,7 @@ public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
   }
 
   @SuppressWarnings("unchecked")
-  private static Resource<Drawable> convertToDrawableResource(
-      Resource<BitmapDrawable> toConvert) {
+  private static Resource<Drawable> convertToDrawableResource(Resource<BitmapDrawable> toConvert) {
     return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index 8dcd98372..24bc548bf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -23,57 +23,52 @@
  * An {@link com.bumptech.glide.load.ResourceEncoder} that writes {@link android.graphics.Bitmap}s
  * to {@link java.io.OutputStream}s.
  *
- * <p> {@link android.graphics.Bitmap}s that return true from
- * {@link android.graphics.Bitmap#hasAlpha ()}} are written using
- * {@link android.graphics.Bitmap.CompressFormat#PNG}
- * to preserve alpha and all other bitmaps are written using
- * {@link android.graphics.Bitmap.CompressFormat#JPEG}. </p>
+ * <p>{@link android.graphics.Bitmap}s that return true from {@link android.graphics.Bitmap#hasAlpha
+ * ()}} are written using {@link android.graphics.Bitmap.CompressFormat#PNG} to preserve alpha and
+ * all other bitmaps are written using {@link android.graphics.Bitmap.CompressFormat#JPEG}.
  *
  * @see android.graphics.Bitmap#compress(android.graphics.Bitmap.CompressFormat, int,
- * java.io.OutputStream)
+ *     java.io.OutputStream)
  */
 public class BitmapEncoder implements ResourceEncoder<Bitmap> {
   /**
    * An integer option between 0 and 100 that is used as the compression quality.
    *
-   * <p> Defaults to 90. </p>
+   * <p>Defaults to 90.
    */
-  public static final Option<Integer> COMPRESSION_QUALITY = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality", 90);
+  public static final Option<Integer> COMPRESSION_QUALITY =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality", 90);
 
   /**
-   * An {@link android.graphics.Bitmap.CompressFormat} option used as the format to encode
-   * the {@link android.graphics.Bitmap}.
+   * An {@link android.graphics.Bitmap.CompressFormat} option used as the format to encode the
+   * {@link android.graphics.Bitmap}.
    *
-   * <p> Defaults to {@link android.graphics.Bitmap.CompressFormat#JPEG} for images without alpha
-   * and {@link android.graphics.Bitmap.CompressFormat#PNG} for images with alpha. </p>
+   * <p>Defaults to {@link android.graphics.Bitmap.CompressFormat#JPEG} for images without alpha and
+   * {@link android.graphics.Bitmap.CompressFormat#PNG} for images with alpha.
    */
-  public static final Option<Bitmap.CompressFormat> COMPRESSION_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
+  public static final Option<Bitmap.CompressFormat> COMPRESSION_FORMAT =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
   private static final String TAG = "BitmapEncoder";
-  @Nullable
-  private final ArrayPool arrayPool;
+  @Nullable private final ArrayPool arrayPool;
 
   public BitmapEncoder(@NonNull ArrayPool arrayPool) {
     this.arrayPool = arrayPool;
   }
 
-  /**
-   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead.
-   */
+  /** @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead. */
   @Deprecated
   public BitmapEncoder() {
     arrayPool = null;
   }
 
   @Override
-  public boolean encode(@NonNull Resource<Bitmap> resource, @NonNull File file,
-      @NonNull Options options) {
+  public boolean encode(
+      @NonNull Resource<Bitmap> resource, @NonNull File file, @NonNull Options options) {
     final Bitmap bitmap = resource.get();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
-    GlideTrace.
-        beginSectionFormat("encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);
+    GlideTrace.beginSectionFormat(
+        "encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);
     try {
       long start = LogTime.getLogTime();
       int quality = options.get(COMPRESSION_QUALITY);
@@ -103,10 +98,18 @@ public boolean encode(@NonNull Resource<Bitmap> resource, @NonNull File file,
       }
 
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
-            + " in " + LogTime.getElapsedMillis(start)
-            + ", options format: " + options.get(COMPRESSION_FORMAT)
-            + ", hasAlpha: " + bitmap.hasAlpha());
+        Log.v(
+            TAG,
+            "Compressed with type: "
+                + format
+                + " of size "
+                + Util.getBitmapByteSize(bitmap)
+                + " in "
+                + LogTime.getElapsedMillis(start)
+                + ", options format: "
+                + options.get(COMPRESSION_FORMAT)
+                + ", hasAlpha: "
+                + bitmap.hasAlpha());
       }
       return success;
     } finally {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 49e57a956..e8650d891 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -9,11 +9,8 @@
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 
-/**
- * A resource wrapping a {@link android.graphics.Bitmap} object.
- */
-public class BitmapResource implements Resource<Bitmap>,
-    Initializable {
+/** A resource wrapping a {@link android.graphics.Bitmap} object. */
+public class BitmapResource implements Resource<Bitmap>, Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -21,7 +18,7 @@
    * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is
    * non-null or null if the given Bitmap is null.
    *
-   * @param bitmap     A Bitmap.
+   * @param bitmap A Bitmap.
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
   @Nullable
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index 44bc67066..a6e771334 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -13,11 +13,12 @@
 import java.security.MessageDigest;
 
 /**
- * A simple {@link com.bumptech.glide.load.Transformation} for transforming
- * {@link android.graphics.Bitmap}s that abstracts away dealing with
- * {@link com.bumptech.glide.load.engine.Resource} objects for subclasses.
+ * A simple {@link com.bumptech.glide.load.Transformation} for transforming {@link
+ * android.graphics.Bitmap}s that abstracts away dealing with {@link
+ * com.bumptech.glide.load.engine.Resource} objects for subclasses.
+ *
+ * <p>Use cases will look something like this:
  *
- * Use cases will look something like this:
  * <pre>
  * <code>
  * public class FillSpace extends BitmapTransformation {
@@ -51,17 +52,17 @@
  * </code>
  * </pre>
  *
- * <p>Using the fully qualified class name as a static final {@link String} (not
- * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * <p>Using the fully qualified class name as a static final {@link String} (not {@link
+ * Class#getName()} to avoid proguard obfuscation) is an easy way to implement {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
  * required they can be passed in to the constructor of the {@code Transformation} and then used to
- * update the {@link java.security.MessageDigest} passed in to
- * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
- * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
- * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ * update the {@link java.security.MessageDigest} passed in to {@link
+ * #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically easily
+ * be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized with
+ * {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
  *
- * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement
- * {@link #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
+ * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement {@link
+ * #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
@@ -71,7 +72,10 @@
       @NonNull Context context, @NonNull Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
-          "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
+          "Cannot apply transformation on width: "
+              + outWidth
+              + " or height: "
+              + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
@@ -101,21 +105,19 @@
    * example. If the implementation obtains and discards intermediate Bitmaps, they may safely be
    * returned to the BitmapPool and/or recycled.
    *
-   * <p>outWidth and outHeight will never be
-   * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL},
-   * this class converts them to be the size of the Bitmap we're going to transform before calling
-   * this method.
+   * <p>outWidth and outHeight will never be {@link
+   * com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}, this class converts them to be the
+   * size of the Bitmap we're going to transform before calling this method.
    *
-   * @param pool        A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can
-   *                    be used to obtain and return intermediate {@link Bitmap}s used in this
-   *                    transformation. For every {@link android.graphics.Bitmap} obtained from the
-   *                    pool during this transformation, a {@link android.graphics.Bitmap} must also
-   *                    be returned.
+   * @param pool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used
+   *     to obtain and return intermediate {@link Bitmap}s used in this transformation. For every
+   *     {@link android.graphics.Bitmap} obtained from the pool during this transformation, a {@link
+   *     android.graphics.Bitmap} must also be returned.
    * @param toTransform The {@link android.graphics.Bitmap} to transform.
-   * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
-   *                    need to match exactly).
-   * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
-   *                    need to match exactly).
+   * @param outWidth The ideal width of the transformed bitmap (the transformed width does not need
+   *     to match exactly).
+   * @param outHeight The ideal height of the transformed bitmap (the transformed height does not
+   *     need to match exactly).
    */
   protected abstract Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index e5e335bc4..518c392e6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -8,13 +8,11 @@
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
 
-/**
- * Contains {@link Bitmap} specific animation options.
- */
+/** Contains {@link Bitmap} specific animation options. */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
-public final class BitmapTransitionOptions extends
-    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+public final class BitmapTransitionOptions
+    extends TransitionOptions<BitmapTransitionOptions, Bitmap> {
 
   /**
    * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
@@ -59,8 +57,8 @@ public static BitmapTransitionOptions withCrossFade(
   }
 
   /**
-   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
-   * that is possible on drawables.
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation that is possible
+   * on drawables.
    *
    * @see #transitionUsing(TransitionFactory)
    */
@@ -76,8 +74,7 @@ public static BitmapTransitionOptions withWrapped(
    * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
    */
   @NonNull
-  public static BitmapTransitionOptions with(
-      @NonNull TransitionFactory<Bitmap> transitionFactory) {
+  public static BitmapTransitionOptions with(@NonNull TransitionFactory<Bitmap> transitionFactory) {
     return new BitmapTransitionOptions().transition(transitionFactory);
   }
 
@@ -94,8 +91,8 @@ public BitmapTransitionOptions crossFade() {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    *
-   * @param duration The duration of the animation, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @param duration The duration of the animation, see {@code
+   *     DrawableCrossFadeFactory.Builder(int)}.
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
   @NonNull
@@ -113,9 +110,7 @@ public BitmapTransitionOptions crossFade(
     return transitionUsing(drawableCrossFadeFactory);
   }
 
-  /**
-   * Enables a any Drawable based animation to run on Bitmaps as well.
-   */
+  /** Enables a any Drawable based animation to run on Bitmaps as well. */
   @NonNull
   public BitmapTransitionOptions transitionUsing(
       @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
@@ -131,4 +126,3 @@ public BitmapTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Build
     return transitionUsing(builder.build());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index 97084a025..caba47a63 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -10,9 +10,7 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
-/**
- * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}.
- */
+/** Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}. */
 public class ByteBufferBitmapDecoder implements ResourceDecoder<ByteBuffer, Bitmap> {
   private final Downsampler downsampler;
 
@@ -26,8 +24,8 @@ public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(@NonNull ByteBuffer source, int width, int height,
-      @NonNull Options options)
+  public Resource<Bitmap> decode(
+      @NonNull ByteBuffer source, int width, int height, @NonNull Options options)
       throws IOException {
     InputStream is = ByteBufferUtil.toStream(source);
     return downsampler.decode(is, width, height, options);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index da0d1a1ec..ea440bce1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -10,7 +10,7 @@
  * the image is greater than the given height or vice versa, and then crop the larger dimension to
  * match the given dimension.
  *
- * Does not maintain the image's aspect ratio
+ * <p>Does not maintain the image's aspect ratio
  */
 public class CenterCrop extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index b707b0fc8..e75f58a15 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -6,11 +6,11 @@
 import java.security.MessageDigest;
 
 /**
- * Returns the image with its original size if its dimensions match or are smaller
- * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
- * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
- * the image will be equal to the given dimension and the other will be less than the given
- * dimension (maintaining the image's aspect ratio).
+ * Returns the image with its original size if its dimensions match or are smaller than the
+ * target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE} in order to center
+ * it in Target. If not, then it is scaled so that one of the dimensions of the image will be equal
+ * to the given dimension and the other will be less than the given dimension (maintaining the
+ * image's aspect ratio).
  */
 public class CenterInside extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
@@ -37,5 +37,3 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
-
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 7d5d5968b..0695550a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -6,10 +6,10 @@
 import java.security.MessageDigest;
 
 /**
- * A Glide {@link BitmapTransformation} to circle crop an image.  Behaves similar to a
- * {@link FitCenter} transform, but the resulting image is masked to a circle.
+ * A Glide {@link BitmapTransformation} to circle crop an image. Behaves similar to a {@link
+ * FitCenter} transform, but the resulting image is masked to a circle.
  *
- * <p> Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html. </p>
+ * <p>Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html.
  */
 public class CircleCrop extends BitmapTransformation {
   // The version of this transformation, incremented to correct an error in a previous version.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index a6e7c10cb..ebd98dd05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -17,9 +17,7 @@
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 
-/**
- * A class for parsing the exif orientation and other data from an image header.
- */
+/** A class for parsing the exif orientation and other data from an image header. */
 public final class DefaultImageHeaderParser implements ImageHeaderParser {
   // Due to https://code.google.com/p/android/issues/detail?id=97751.
   // TAG needs to be under 23 chars, so "Default" > "Dflt".
@@ -40,7 +38,7 @@
   static final int SEGMENT_START_ID = 0xFF;
   static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
-  private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+  private static final int[] BYTES_PER_FORMAT = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};
   // WebP-related
   // "RIFF"
   private static final int RIFF_HEADER = 0x52494646;
@@ -72,14 +70,16 @@ public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
   @Override
   public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
       throws IOException {
-    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+    return getOrientation(
+        new StreamReader(Preconditions.checkNotNull(is)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
   @Override
   public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
       throws IOException {
-    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+    return getOrientation(
+        new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
         Preconditions.checkNotNull(byteArrayPool));
   }
 
@@ -144,7 +144,7 @@ private ImageType getType(Reader reader) throws IOException {
    * not an image) it will return a default value rather than throwing an exception.
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
-   * contain an orientation
+   *     contain an orientation
    */
   private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
@@ -177,9 +177,13 @@ private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLen
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to read exif segment data"
-            + ", length: " + exifSegmentLength
-            + ", actually read: " + read);
+        Log.d(
+            TAG,
+            "Unable to read exif segment data"
+                + ", length: "
+                + exifSegmentLength
+                + ", actually read: "
+                + read);
       }
       return UNKNOWN_ORIENTATION;
     }
@@ -239,10 +243,15 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
           if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Unable to skip enough data"
-                + ", type: " + segmentType
-                + ", wanted to skip: " + segmentLength
-                + ", but actually skipped: " + skipped);
+            Log.d(
+                TAG,
+                "Unable to skip enough data"
+                    + ", type: "
+                    + segmentType
+                    + ", wanted to skip: "
+                    + segmentLength
+                    + ", but actually skipped: "
+                    + skipped);
           }
           return -1;
         }
@@ -303,8 +312,16 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
-            + " componentCount=" + componentCount);
+        Log.d(
+            TAG,
+            "Got tagIndex="
+                + i
+                + " tagType="
+                + tagType
+                + " formatCode="
+                + formatCode
+                + " componentCount="
+                + componentCount);
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
@@ -330,7 +347,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      //assume componentCount == 1 && fmtCode == 3
+      // assume componentCount == 1 && fmtCode == 3
       return segmentData.getInt16(tagValueOffset);
     }
 
@@ -351,9 +368,7 @@ private static boolean handles(int imageMagicNumber) {
     private final ByteBuffer data;
 
     RandomAccessReader(byte[] data, int length) {
-      this.data = (ByteBuffer) ByteBuffer.wrap(data)
-          .order(ByteOrder.BIG_ENDIAN)
-          .limit(length);
+      this.data = (ByteBuffer) ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN).limit(length);
     }
 
     void order(ByteOrder byteOrder) {
@@ -379,9 +394,13 @@ private boolean isAvailable(int offset, int byteSize) {
 
   private interface Reader {
     int getUInt16() throws IOException;
+
     short getUInt8() throws IOException;
+
     long skip(long total) throws IOException;
+
     int read(byte[] buffer, int byteCount) throws IOException;
+
     int getByte() throws IOException;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index e2fb472d5..deb3488cd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -9,27 +9,27 @@
  * <p>{@code DownsampleStrategy} does not provide any guarantees about output sizes. Behavior will
  * differ depending on the {@link com.bumptech.glide.load.ResourceDecoder} using the strategy and
  * the version of Android the code runs on. Use {@code DownsampleStrategy} as an optimization to
- * improve memory efficiency only. If you need a particular size or shape output, use an
- * {@link com.bumptech.glide.load.Transformation} either instead or in addition to a
- * {@code DownsampleStrategy}.
+ * improve memory efficiency only. If you need a particular size or shape output, use an {@link
+ * com.bumptech.glide.load.Transformation} either instead or in addition to a {@code
+ * DownsampleStrategy}.
  *
- * <p>Some differences between versions of Android and
- * {@link com.bumptech.glide.load.ResourceDecoder}s are listed below, but the list is not
- * comprehensive because {@link DownsampleStrategy} only controls it's output scale value, not
- * how that output value is used.
+ * <p>Some differences between versions of Android and {@link
+ * com.bumptech.glide.load.ResourceDecoder}s are listed below, but the list is not comprehensive
+ * because {@link DownsampleStrategy} only controls it's output scale value, not how that output
+ * value is used.
  */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public abstract class DownsampleStrategy {
 
   /**
-   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
-   * exactly equal to the requested size and the other dimension is less than or equal to the
-   * requested size.
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is exactly
+   * equal to the requested size and the other dimension is less than or equal to the requested
+   * size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
-   * {@link #CENTER_INSIDE}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or {@link
+   * #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to {@link #AT_MOST}
    * because only power of two downsampling can be used.
@@ -37,16 +37,16 @@
   public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
   /**
-   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
-   * exactly equal to the requested size and the other dimension is greater than or equal to
-   * the requested size.
+   * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is exactly
+   * equal to the requested size and the other dimension is greater than or equal to the requested
+   * size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
-   * or {@link #CENTER_INSIDE}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST}, or {@link
+   * #CENTER_INSIDE}.
    *
-   * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to
-   * {@link #AT_LEAST} because only power of two downsampling can be used.
+   * <p>On pre-KitKat devices, {@link Downsampler} treats this as equivalent to {@link #AT_LEAST}
+   * because only power of two downsampling can be used.
    */
   public static final DownsampleStrategy CENTER_OUTSIDE = new CenterOutside();
 
@@ -75,20 +75,16 @@
    */
   public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
 
-  /**
-   * Performs no downsampling or scaling.
-   */
+  /** Performs no downsampling or scaling. */
   public static final DownsampleStrategy NONE = new None();
 
-  /**
-   * Default strategy, currently {@link #CENTER_OUTSIDE}.
-   */
+  /** Default strategy, currently {@link #CENTER_OUTSIDE}. */
   public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
   /**
    * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
-   * will be used to calculate the sample size to use to downsample an image given the original
-   * and target dimensions of the image.
+   * will be used to calculate the sample size to use to downsample an image given the original and
+   * target dimensions of the image.
    */
   // The exact String value here is retained to avoid breaking cache keys for images that were
   // loaded with older versions of Glide.
@@ -97,54 +93,54 @@
           "com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy", DEFAULT);
 
   /**
-   * Returns a float (0, +infinity) indicating a scale factor to apply to the source
-   * width and height when displayed in the requested width and height.
+   * Returns a float (0, +infinity) indicating a scale factor to apply to the source width and
+   * height when displayed in the requested width and height.
    *
-   * <p>The returned scale factor will be split into a power of two sample size applied via
-   * {@link android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied
-   * after downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and
-   * {@link android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale
-   * factor may not be applied precisely.
+   * <p>The returned scale factor will be split into a power of two sample size applied via {@link
+   * android.graphics.BitmapFactory.Options#inSampleSize} and a float scale factor applied after
+   * downsampling via {@link android.graphics.BitmapFactory.Options#inTargetDensity} and {@link
+   * android.graphics.BitmapFactory.Options#inDensity}. Because of rounding errors the scale factor
+   * may not be applied precisely.
    *
-   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power
-   * of two downsampling will be applied.
+   * <p>The float scaling factor will only be applied on KitKat+. Prior to KitKat, only the power of
+   * two downsampling will be applied.
    *
-   * @param sourceWidth   The width in pixels of the image to be downsampled.
-   * @param sourceHeight  The height in pixels of the image to be downsampled.
-   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param sourceWidth The width in pixels of the image to be downsampled.
+   * @param sourceHeight The height in pixels of the image to be downsampled.
+   * @param requestedWidth The width in pixels of the view/target the image will be displayed in.
    * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
    */
-  public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-      int requestedHeight);
+  public abstract float getScaleFactor(
+      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight);
 
   /**
    * Returns a non-null {@link SampleSizeRounding} to use to resolve rounding errors and conflicts
    * between scaling for the width and the height of the image.
    *
-   * @param sourceWidth   The width in pixels of the image to be downsampled.
-   * @param sourceHeight  The height in pixels of the image to be downsampled.
-   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in.
+   * @param sourceWidth The width in pixels of the image to be downsampled.
+   * @param sourceHeight The height in pixels of the image to be downsampled.
+   * @param requestedWidth The width in pixels of the view/target the image will be displayed in.
    * @param requestedHeight The height in pixels of the view/target the image will be displayed in.
    */
-  public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-      int requestedWidth, int requestedHeight);
+  public abstract SampleSizeRounding getSampleSizeRounding(
+      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight);
 
   private static class FitCenter extends DownsampleStrategy {
 
     @Synthetic
-    FitCenter() { }
+    FitCenter() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
       float heightPercentage = requestedHeight / (float) sourceHeight;
       return Math.min(widthPercentage, heightPercentage);
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -152,19 +148,19 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class CenterOutside extends DownsampleStrategy {
 
     @Synthetic
-    CenterOutside() { }
+    CenterOutside() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
       float heightPercentage = requestedHeight / (float) sourceHeight;
       return Math.max(widthPercentage, heightPercentage);
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -172,18 +168,18 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class AtLeast extends DownsampleStrategy {
 
     @Synthetic
-    AtLeast() { }
+    AtLeast() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       int minIntegerFactor = Math.min(sourceHeight / requestedHeight, sourceWidth / requestedWidth);
       return minIntegerFactor == 0 ? 1f : 1f / Integer.highestOneBit(minIntegerFactor);
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -191,13 +187,17 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class AtMost extends DownsampleStrategy {
 
     @Synthetic
-    AtMost() { }
+    AtMost() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
-      int maxIntegerFactor = (int) Math.ceil(Math.max(sourceHeight / (float) requestedHeight,
-              sourceWidth / (float) requestedWidth));
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
+      int maxIntegerFactor =
+          (int)
+              Math.ceil(
+                  Math.max(
+                      sourceHeight / (float) requestedHeight,
+                      sourceWidth / (float) requestedWidth));
       int lesserOrEqualSampleSize = Math.max(1, Integer.highestOneBit(maxIntegerFactor));
       int greaterOrEqualSampleSize =
           lesserOrEqualSampleSize << (lesserOrEqualSampleSize < maxIntegerFactor ? 1 : 0);
@@ -205,8 +205,8 @@ public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidt
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.MEMORY;
     }
   }
@@ -214,17 +214,17 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class None extends DownsampleStrategy {
 
     @Synthetic
-    None() { }
+    None() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return 1f;
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
@@ -232,26 +232,27 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   private static class CenterInside extends DownsampleStrategy {
 
     @Synthetic
-    CenterInside() { }
+    CenterInside() {}
 
     @Override
-    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
-        int requestedHeight) {
+    public float getScaleFactor(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
 
-      return Math.min(1.f,
+      return Math.min(
+          1.f,
           FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
     }
 
     @Override
-    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
-        int requestedWidth, int requestedHeight) {
+    public SampleSizeRounding getSampleSizeRounding(
+        int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) {
       return SampleSizeRounding.QUALITY;
     }
   }
 
   /**
-   * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
-   * or higher quality.
+   * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage or
+   * higher quality.
    */
   public enum SampleSizeRounding {
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 53e7d25f4..817ffc2b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -34,9 +34,7 @@
 import java.util.Queue;
 import java.util.Set;
 
-/**
- * Downsamples, decodes, and rotates images according to their exif orientation.
- */
+/** Downsamples, decodes, and rotates images according to their exif orientation. */
 public final class Downsampler {
   static final String TAG = "Downsampler";
   /**
@@ -44,25 +42,26 @@
    * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
    * {@link android.graphics.BitmapFactory.Options#inPreferredConfig} when decoding the image.
    */
-  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat", DecodeFormat.DEFAULT);
+  public static final Option<DecodeFormat> DECODE_FORMAT =
+      Option.memory(
+          "com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat", DecodeFormat.DEFAULT);
   /**
    * Indicates the {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option that
-   * will be used to calculate the sample size to use to downsample an image given the original
-   * and target dimensions of the image.
+   * will be used to calculate the sample size to use to downsample an image given the original and
+   * target dimensions of the image.
    *
    * @deprecated Use {@link DownsampleStrategy#OPTION} directly instead.
    */
   @Deprecated
   public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY = DownsampleStrategy.OPTION;
   /**
-   * Ensure that the size of the bitmap is fixed to the requested width and height of the
-   * resource from the caller.  The final resource dimensions may differ from the requested
-   * width and height, and thus setting this to true may result in the bitmap size differing
-   * from the resource dimensions.
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the resource
+   * from the caller. The final resource dimensions may differ from the requested width and height,
+   * and thus setting this to true may result in the bitmap size differing from the resource
+   * dimensions.
    *
-   * This can be used as a performance optimization for KitKat and above by fixing the size of the
-   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * <p>This can be used as a performance optimization for KitKat and above by fixing the size of
+   * the bitmap for a collection of requested resources so that the bitmap pool will not need to
    * allocate new bitmaps for images of different sizes.
    */
   // Public API
@@ -71,19 +70,19 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
 
   /**
-   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with
-   * {@link Bitmap.Config#HARDWARE}.
+   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with {@link
+   * Bitmap.Config#HARDWARE}.
    *
    * <p>Callers should almost never set this value to {@code true} manually. Glide will already do
    * so when Glide believes it's safe to do (when no transformations are applied). Instead, callers
-   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide
-   * is unable to detect that hardware bitmaps are unsafe. For example, you should set this to
-   * {@code false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you
-   * plan to inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or
-   * {@link Bitmap#getPixels(int[], int, int, int, int, int, int)}.
+   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide is
+   * unable to detect that hardware bitmaps are unsafe. For example, you should set this to {@code
+   * false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you plan to
+   * inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or {@link
+   * Bitmap#getPixels(int[], int, int, int, int, int, int)}.
    *
-   * <p>Callers can disable hardware {@link Bitmap}s for all loads using
-   * {@link com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   * <p>Callers can disable hardware {@link Bitmap}s for all loads using {@link
+   * com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
    *
    * <p>This option is ignored unless we're on Android O+.
    */
@@ -94,33 +93,25 @@
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
-      Collections.unmodifiableSet(
-          new HashSet<>(
-              Arrays.asList(
-                  WBMP_MIME_TYPE,
-                  ICO_MIME_TYPE
-              )
-          )
-      );
-  private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
-    @Override
-    public void onObtainBounds() {
-      // Do nothing.
-    }
+      Collections.unmodifiableSet(new HashSet<>(Arrays.asList(WBMP_MIME_TYPE, ICO_MIME_TYPE)));
+  private static final DecodeCallbacks EMPTY_CALLBACKS =
+      new DecodeCallbacks() {
+        @Override
+        public void onObtainBounds() {
+          // Do nothing.
+        }
 
-    @Override
-    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
-      // Do nothing.
-    }
-  };
+        @Override
+        public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
+          // Do nothing.
+        }
+      };
   private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL_PRE_KITKAT =
       Collections.unmodifiableSet(
           EnumSet.of(
               ImageHeaderParser.ImageType.JPEG,
               ImageHeaderParser.ImageType.PNG_A,
-              ImageHeaderParser.ImageType.PNG
-          )
-      );
+              ImageHeaderParser.ImageType.PNG));
   private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
   // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
@@ -132,8 +123,11 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
   private final List<ImageHeaderParser> parsers;
   private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
 
-  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
-      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+  public Downsampler(
+      List<ImageHeaderParser> parsers,
+      DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool,
+      ArrayPool byteArrayPool) {
     this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
@@ -153,44 +147,49 @@ public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
   /**
    * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
    * data present in the stream and that is downsampled according to the given dimensions and any
-   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   * provided {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
    *
    * @see #decode(InputStream, int, int, Options, DecodeCallbacks)
    */
-  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight,
-      Options options) throws IOException {
+  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight, Options options)
+      throws IOException {
     return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);
   }
 
   /**
    * Returns a Bitmap decoded from the given {@link InputStream} that is rotated to match any EXIF
    * data present in the stream and that is downsampled according to the given dimensions and any
-   * provided  {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
+   * provided {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy} option.
    *
-   * <p> If a Bitmap is present in the
-   * {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} whose dimensions exactly match
-   * those of the image for the given InputStream is available, the operation is much less expensive
-   * in terms of memory. </p>
+   * <p>If a Bitmap is present in the {@link
+   * com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} whose dimensions exactly match those
+   * of the image for the given InputStream is available, the operation is much less expensive in
+   * terms of memory.
    *
-   * <p> The provided {@link java.io.InputStream} must return <code>true</code> from
-   * {@link java.io.InputStream#markSupported()} and is expected to support a reasonably large
-   * mark limit to accommodate reading large image headers (~5MB). </p>
+   * <p>The provided {@link java.io.InputStream} must return <code>true</code> from {@link
+   * java.io.InputStream#markSupported()} and is expected to support a reasonably large mark limit
+   * to accommodate reading large image headers (~5MB).
    *
-   * @param is        An {@link InputStream} to the data for the image.
-   * @param requestedWidth  The width the final image should be close to.
+   * @param is An {@link InputStream} to the data for the image.
+   * @param requestedWidth The width the final image should be close to.
    * @param requestedHeight The height the final image should be close to.
-   * @param options   A set of options that may contain one or more supported options that influence
-   *                  how a Bitmap will be decoded from the given stream.
+   * @param options A set of options that may contain one or more supported options that influence
+   *     how a Bitmap will be decoded from the given stream.
    * @param callbacks A set of callbacks allowing callers to optionally respond to various
-   *                  significant events during the decode process.
+   *     significant events during the decode process.
    * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
-   * not null.
+   *     not null.
    */
   @SuppressWarnings({"resource", "deprecation"})
-  public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
-      Options options, DecodeCallbacks callbacks) throws IOException {
-    Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
-        + " mark()");
+  public Resource<Bitmap> decode(
+      InputStream is,
+      int requestedWidth,
+      int requestedHeight,
+      Options options,
+      DecodeCallbacks callbacks)
+      throws IOException {
+    Preconditions.checkArgument(
+        is.markSupported(), "You must provide an InputStream that supports" + " mark()");
 
     byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
@@ -200,12 +199,20 @@ public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
     boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
     boolean isHardwareConfigAllowed =
-      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
+        options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
 
     try {
-      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
-          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
+      Bitmap result =
+          decodeFromWrappedStreams(
+              is,
+              bitmapFactoryOptions,
+              downsampleStrategy,
+              decodeFormat,
+              isHardwareConfigAllowed,
+              requestedWidth,
+              requestedHeight,
+              fixBitmapToRequestedDimensions,
+              callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -213,11 +220,17 @@ public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     }
   }
 
-  private Bitmap decodeFromWrappedStreams(InputStream is,
-      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
-      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
-      int requestedHeight, boolean fixBitmapToRequestedDimensions,
-      DecodeCallbacks callbacks) throws IOException {
+  private Bitmap decodeFromWrappedStreams(
+      InputStream is,
+      BitmapFactory.Options options,
+      DownsampleStrategy downsampleStrategy,
+      DecodeFormat decodeFormat,
+      boolean isHardwareConfigAllowed,
+      int requestedWidth,
+      int requestedHeight,
+      boolean fixBitmapToRequestedDimensions,
+      DecodeCallbacks callbacks)
+      throws IOException {
     long startTime = LogTime.getLogTime();
 
     int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
@@ -268,13 +281,15 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
-      if (sourceWidth >= 0 && sourceHeight >= 0
-          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+      if (sourceWidth >= 0
+          && sourceHeight >= 0
+          && fixBitmapToRequestedDimensions
+          && isKitKatOrGreater) {
         expectedWidth = targetWidth;
         expectedHeight = targetHeight;
       } else {
-        float densityMultiplier = isScaling(options)
-            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        float densityMultiplier =
+            isScaling(options) ? (float) options.inTargetDensity / options.inDensity : 1f;
         int sampleSize = options.inSampleSize;
         int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
         int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
@@ -282,12 +297,26 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
         expectedHeight = Math.round(downsampledHeight * densityMultiplier);
 
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-              + " [" + sourceWidth + "x" + sourceHeight + "]"
-              + ", sampleSize: " + sampleSize
-              + ", targetDensity: " + options.inTargetDensity
-              + ", density: " + options.inDensity
-              + ", density multiplier: " + densityMultiplier);
+          Log.v(
+              TAG,
+              "Calculated target ["
+                  + expectedWidth
+                  + "x"
+                  + expectedHeight
+                  + "] for source"
+                  + " ["
+                  + sourceWidth
+                  + "x"
+                  + sourceHeight
+                  + "]"
+                  + ", sampleSize: "
+                  + sampleSize
+                  + ", targetDensity: "
+                  + options.inTargetDensity
+                  + ", density: "
+                  + options.inDensity
+                  + ", density multiplier: "
+                  + densityMultiplier);
         }
       }
       // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
@@ -300,8 +329,15 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight, startTime);
+      logDecode(
+          sourceWidth,
+          sourceHeight,
+          sourceMimeType,
+          options,
+          downsampled,
+          requestedWidth,
+          requestedHeight,
+          startTime);
     }
 
     Bitmap rotated = null;
@@ -330,12 +366,20 @@ private static void calculateScaling(
       int sourceHeight,
       int targetWidth,
       int targetHeight,
-      BitmapFactory.Options options) throws IOException {
+      BitmapFactory.Options options)
+      throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to determine dimensions for: " + imageType
-            + " with target [" + targetWidth + "x" + targetHeight + "]");
+        Log.d(
+            TAG,
+            "Unable to determine dimensions for: "
+                + imageType
+                + " with target ["
+                + targetWidth
+                + "x"
+                + targetHeight
+                + "]");
       }
       return;
     }
@@ -346,21 +390,33 @@ private static void calculateScaling(
       // width is decreased to near our target's height and the image height is decreased to near
       // our target width.
       //noinspection SuspiciousNameCombination
-      exactScaleFactor = downsampleStrategy.getScaleFactor(sourceHeight, sourceWidth,
-          targetWidth, targetHeight);
+      exactScaleFactor =
+          downsampleStrategy.getScaleFactor(sourceHeight, sourceWidth, targetWidth, targetHeight);
     } else {
       exactScaleFactor =
           downsampleStrategy.getScaleFactor(sourceWidth, sourceHeight, targetWidth, targetHeight);
     }
 
     if (exactScaleFactor <= 0f) {
-      throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy
-          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
-          + ", target: [" + targetWidth + "x" + targetHeight + "]");
+      throw new IllegalArgumentException(
+          "Cannot scale with factor: "
+              + exactScaleFactor
+              + " from: "
+              + downsampleStrategy
+              + ", source: ["
+              + sourceWidth
+              + "x"
+              + sourceHeight
+              + "]"
+              + ", target: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]");
     }
-    SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
-        sourceHeight, targetWidth, targetHeight);
+    SampleSizeRounding rounding =
+        downsampleStrategy.getSampleSizeRounding(
+            sourceWidth, sourceHeight, targetWidth, targetHeight);
     if (rounding == null) {
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
@@ -371,9 +427,10 @@ private static void calculateScaling(
     int widthScaleFactor = sourceWidth / outWidth;
     int heightScaleFactor = sourceHeight / outHeight;
 
-    int scaleFactor = rounding == SampleSizeRounding.MEMORY
-        ? Math.max(widthScaleFactor, heightScaleFactor)
-        : Math.min(widthScaleFactor, heightScaleFactor);
+    int scaleFactor =
+        rounding == SampleSizeRounding.MEMORY
+            ? Math.max(widthScaleFactor, heightScaleFactor)
+            : Math.min(widthScaleFactor, heightScaleFactor);
 
     int powerOfTwoSampleSize;
     // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
@@ -419,8 +476,8 @@ private static void calculateScaling(
         powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
         powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
       }
-    } else if (
-        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+    } else if (sourceWidth % powerOfTwoSampleSize != 0
+        || sourceHeight % powerOfTwoSampleSize != 0) {
       // If we're not confident the image is in one of our types, fall back to checking the
       // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
       int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
@@ -435,8 +492,9 @@ private static void calculateScaling(
       powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
     }
 
-    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
-        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+    double adjustedScaleFactor =
+        downsampleStrategy.getScaleFactor(
+            powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
 
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
@@ -451,15 +509,34 @@ private static void calculateScaling(
     }
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Calculate scaling"
-          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
-          + ", target: [" + targetWidth + "x" + targetHeight + "]"
-          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
-          + ", exact scale factor: " + exactScaleFactor
-          + ", power of 2 sample size: " + powerOfTwoSampleSize
-          + ", adjusted scale factor: " + adjustedScaleFactor
-          + ", target density: " + options.inTargetDensity
-          + ", density: " + options.inDensity);
+      Log.v(
+          TAG,
+          "Calculate scaling"
+              + ", source: ["
+              + sourceWidth
+              + "x"
+              + sourceHeight
+              + "]"
+              + ", target: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]"
+              + ", power of two scaled: ["
+              + powerOfTwoWidth
+              + "x"
+              + powerOfTwoHeight
+              + "]"
+              + ", exact scale factor: "
+              + exactScaleFactor
+              + ", power of 2 sample size: "
+              + powerOfTwoSampleSize
+              + ", adjusted scale factor: "
+              + adjustedScaleFactor
+              + ", target density: "
+              + options.inTargetDensity
+              + ", density: "
+              + options.inDensity);
     }
   }
 
@@ -477,9 +554,10 @@ private static int adjustTargetDensityForError(double adjustedScaleFactor) {
   }
 
   private static int getDensityMultiplier(double adjustedScaleFactor) {
-    return (int) Math.round(
-        Integer.MAX_VALUE
-            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
+    return (int)
+        Math.round(
+            Integer.MAX_VALUE
+                * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
   }
 
   // This is weird, but it matches the logic in a bunch of Android views/framework classes for
@@ -532,8 +610,12 @@ private void calculateConfig(
       hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
-            + ", format " + format, e);
+        Log.d(
+            TAG,
+            "Cannot determine whether the image has alpha or not from header"
+                + ", format "
+                + format,
+            e);
       }
     }
 
@@ -547,21 +629,29 @@ private void calculateConfig(
   /**
    * A method for getting the dimensions of an image from the given InputStream.
    *
-   * @param is      The InputStream representing the image.
+   * @param is The InputStream representing the image.
    * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream,
-   *                android.graphics.Rect, android.graphics.BitmapFactory.Options)}.
+   *     android.graphics.Rect, android.graphics.BitmapFactory.Options)}.
    * @return an array containing the dimensions of the image in the form {width, height}.
    */
-  private static int[] getDimensions(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool) throws IOException {
+  private static int[] getDimensions(
+      InputStream is,
+      BitmapFactory.Options options,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool)
+      throws IOException {
     options.inJustDecodeBounds = true;
     decodeStream(is, options, decodeCallbacks, bitmapPool);
     options.inJustDecodeBounds = false;
-    return new int[] { options.outWidth, options.outHeight };
+    return new int[] {options.outWidth, options.outHeight};
   }
 
-  private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException {
+  private static Bitmap decodeStream(
+      InputStream is,
+      BitmapFactory.Options options,
+      DecodeCallbacks callbacks,
+      BitmapPool bitmapPool)
+      throws IOException {
     if (options.inJustDecodeBounds) {
       is.mark(MARK_POSITION);
     } else {
@@ -585,7 +675,9 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       IOException bitmapAssertionException =
           newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Failed to decode with inBitmap, trying again without Bitmap re-use",
+        Log.d(
+            TAG,
+            "Failed to decode with inBitmap, trying again without Bitmap re-use",
             bitmapAssertionException);
       }
       if (options.inBitmap != null) {
@@ -605,28 +697,52 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
 
     if (options.inJustDecodeBounds) {
       is.reset();
-
     }
     return result;
   }
 
   private static boolean isScaling(BitmapFactory.Options options) {
-    return options.inTargetDensity > 0 && options.inDensity > 0
+    return options.inTargetDensity > 0
+        && options.inDensity > 0
         && options.inTargetDensity != options.inDensity;
   }
 
-  private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+  private static void logDecode(
+      int sourceWidth,
+      int sourceHeight,
+      String outMimeType,
+      BitmapFactory.Options options,
+      Bitmap result,
+      int requestedWidth,
+      int requestedHeight,
       long startTime) {
-    Log.v(TAG, "Decoded " + getBitmapString(result)
-        + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
-        + " with inBitmap " + getInBitmapString(options)
-        + " for [" + requestedWidth + "x" + requestedHeight + "]"
-        + ", sample size: " + options.inSampleSize
-        + ", density: " + options.inDensity
-        + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName()
-        + ", duration: " + LogTime.getElapsedMillis(startTime));
+    Log.v(
+        TAG,
+        "Decoded "
+            + getBitmapString(result)
+            + " from ["
+            + sourceWidth
+            + "x"
+            + sourceHeight
+            + "] "
+            + outMimeType
+            + " with inBitmap "
+            + getInBitmapString(options)
+            + " for ["
+            + requestedWidth
+            + "x"
+            + requestedHeight
+            + "]"
+            + ", sample size: "
+            + options.inSampleSize
+            + ", density: "
+            + options.inDensity
+            + ", target density: "
+            + options.inTargetDensity
+            + ", thread: "
+            + Thread.currentThread().getName()
+            + ", duration: "
+            + LogTime.getElapsedMillis(startTime));
   }
 
   private static String getInBitmapString(BitmapFactory.Options options) {
@@ -640,9 +756,16 @@ private static String getBitmapString(Bitmap bitmap) {
       return null;
     }
 
-    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+    String sizeString =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+            ? " (" + bitmap.getAllocationByteCount() + ")"
+            : "";
+    return "["
+        + bitmap.getWidth()
+        + "x"
+        + bitmap.getHeight()
+        + "] "
+        + bitmap.getConfig()
         + sizeString;
   }
 
@@ -650,13 +773,23 @@ private static String getBitmapString(Bitmap bitmap) {
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
-      int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
-    return new IOException("Exception decoding bitmap"
-          + ", outWidth: " + outWidth
-          + ", outHeight: " + outHeight
-          + ", outMimeType: " + outMimeType
-          + ", inBitmap: " + getInBitmapString(options), e);
+  private static IOException newIoExceptionForInBitmapAssertion(
+      IllegalArgumentException e,
+      int outWidth,
+      int outHeight,
+      String outMimeType,
+      BitmapFactory.Options options) {
+    return new IOException(
+        "Exception decoding bitmap"
+            + ", outWidth: "
+            + outWidth
+            + ", outHeight: "
+            + outHeight
+            + ", outMimeType: "
+            + outMimeType
+            + ", inBitmap: "
+            + getInBitmapString(options),
+        e);
   }
 
   @SuppressWarnings("PMD.CollapsibleIfStatements")
@@ -723,11 +856,10 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inMutable = true;
   }
 
-  /**
-   * Callbacks for key points during decodes.
-   */
+  /** Callbacks for key points during decodes. */
   public interface DecodeCallbacks {
     void onObtainBounds();
+
     void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
index 2ed84484d..671fdbc07 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -15,12 +15,14 @@
 
 final class DrawableToBitmapConverter {
   private static final String TAG = "DrawableToBitmap";
-  private static final BitmapPool NO_RECYCLE_BITMAP_POOL = new BitmapPoolAdapter() {
-    @Override
-    public void put(Bitmap bitmap) {
-      // Avoid calling super to avoid recycling the given Bitmap.
-    }
-  };
+  private static final BitmapPool NO_RECYCLE_BITMAP_POOL =
+      new BitmapPoolAdapter() {
+        @Override
+        public void put(Bitmap bitmap) {
+          // Avoid calling super to avoid recycling the given Bitmap.
+        }
+      };
+
   private DrawableToBitmapConverter() {
     // Utility class.
   }
@@ -48,15 +50,23 @@ private static Bitmap drawToBitmap(
       BitmapPool bitmapPool, Drawable drawable, int width, int height) {
     if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
-            + " Drawable has no intrinsic width");
+        Log.w(
+            TAG,
+            "Unable to draw "
+                + drawable
+                + " to Bitmap with Target.SIZE_ORIGINAL because the"
+                + " Drawable has no intrinsic width");
       }
       return null;
     }
     if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
-            + " Drawable has no intrinsic height");
+        Log.w(
+            TAG,
+            "Unable to draw "
+                + drawable
+                + " to Bitmap with Target.SIZE_ORIGINAL because the"
+                + " Drawable has no intrinsic height");
       }
       return null;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
index dee51f7a2..68e22f48d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -13,20 +13,19 @@
 
 /**
  * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
- * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
- * on the converted {@link Bitmap}.
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation} on
+ * the converted {@link Bitmap}.
  *
  * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
  * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
  * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
  * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
- * will fail with an exception. {@link Drawable}s that return <= 0 for
- * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
- * with an exception if the requested size is
- * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
- * intrinsic dimensions are drawn using the dimensions provided in
- * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
- * transformed incorrectly or in unexpected ways.
+ * will fail with an exception. {@link Drawable}s that return <= 0 for {@link
+ * Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail with an
+ * exception if the requested size is {@link
+ * com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without intrinsic
+ * dimensions are drawn using the dimensions provided in {@link Transformation#transform(Context,
+ * Resource, int, int)}. As a result, they may be transformed incorrectly or in unexpected ways.
  */
 public class DrawableTransformation implements Transformation<Drawable> {
 
@@ -45,8 +44,8 @@ public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired
 
   @NonNull
   @Override
-  public Resource<Drawable> transform(@NonNull Context context,
-      @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
+  public Resource<Drawable> transform(
+      @NonNull Context context, @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
     BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Drawable drawable = resource.get();
     Resource<Bitmap> bitmapResourceToTransform =
@@ -71,8 +70,7 @@ public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired
 
   // It's clearer to cast the result in a separate line from obtaining it.
   @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
-  private Resource<Drawable> newDrawableResource(
-      Context context, Resource<Bitmap> transformed) {
+  private Resource<Drawable> newDrawableResource(Context context, Resource<Bitmap> transformed) {
     Resource<? extends Drawable> result =
         LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
     return (Resource<Drawable>) result;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
index 92152d778..3ebd0b9dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java
@@ -15,9 +15,9 @@
  * Uses {@link ExifInterface} to parse orientation data.
  *
  * <p>ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}
- * doesn't currently support HEIF. In the future we should reconcile these two classes, but for
- * now this is a simple way to ensure that HEIF files are oriented correctly on platforms where
- * they're supported.
+ * doesn't currently support HEIF. In the future we should reconcile these two classes, but for now
+ * this is a simple way to ensure that HEIF files are oriented correctly on platforms where they're
+ * supported.
  */
 @RequiresApi(Build.VERSION_CODES.O_MR1)
 public final class ExifInterfaceImageHeaderParser implements ImageHeaderParser {
@@ -38,7 +38,8 @@ public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
   public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
       throws IOException {
     ExifInterface exifInterface = new ExifInterface(is);
-    int result = exifInterface.getAttributeInt(
+    int result =
+        exifInterface.getAttributeInt(
             ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
     if (result == ExifInterface.ORIENTATION_UNDEFINED) {
       return ImageHeaderParser.UNKNOWN_ORIENTATION;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 9c2ae89c1..6f6660508 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -15,8 +15,8 @@
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);
   }
 
@@ -35,5 +35,3 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
-
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
index 5d271dad6..dbbc3eff6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -106,10 +106,13 @@ private synchronized boolean isFdSizeBelowHardwareLimit() {
       isHardwareConfigAllowed = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
 
       if (!isHardwareConfigAllowed && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
-        Log.w(Downsampler.TAG,
+        Log.w(
+            Downsampler.TAG,
             "Excluding HARDWARE bitmap config because we're over the file descriptor limit"
-                + ", file descriptors " + currentFds
-                + ", limit " + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+                + ", file descriptors "
+                + currentFds
+                + ", limit "
+                + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
       }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 92855b5ba..8948bbf11 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -13,37 +13,35 @@
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
- * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
+ * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given {@link
+ * android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
-    Initializable {
+public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>, Initializable {
 
   private final Resources resources;
   private final Resource<Bitmap> bitmapResource;
 
   /**
    * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
-   * {@link Bitmap}s from their wrapped {@link Resource}.
+   *     {@link Bitmap}s from their wrapped {@link Resource}.
    */
   @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return
-        (LazyBitmapDrawableResource)
-            obtain(
-                context.getResources(),
-                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
+    return (LazyBitmapDrawableResource)
+        obtain(
+            context.getResources(),
+            BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
   /**
    * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
-   * {@link Bitmap}s from their wrapped {@link Resource}.
+   *     {@link Bitmap}s from their wrapped {@link Resource}.
    */
   @Deprecated
-  public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
-      Bitmap bitmap) {
-    return
-        (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
+  public static LazyBitmapDrawableResource obtain(
+      Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+    return (LazyBitmapDrawableResource)
+        obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
   }
 
   @Nullable
@@ -53,11 +51,10 @@ public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool
       return null;
     }
     return new LazyBitmapDrawableResource(resources, bitmapResource);
-
   }
 
-  private LazyBitmapDrawableResource(@NonNull Resources resources,
-      @NonNull Resource<Bitmap> bitmapResource) {
+  private LazyBitmapDrawableResource(
+      @NonNull Resources resources, @NonNull Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
     this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 88ecc15a3..167d705f8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -31,26 +31,20 @@
  * and that copying takes place when filling that buffer, but this is usually outweighed by the
  * performance benefits.
  *
- * <p>A typical application pattern for the class looks like this:</p>
+ * <p>A typical application pattern for the class looks like this:
  *
  * <pre>
  * BufferedInputStream buf = new BufferedInputStream(new FileInputStream("file.java"));
  * </pre>
  */
 public class RecyclableBufferedInputStream extends FilterInputStream {
-  /**
-   * The buffer containing the current bytes read from the target InputStream.
-   */
+  /** The buffer containing the current bytes read from the target InputStream. */
   private volatile byte[] buf;
 
-  /**
-   * The total number of bytes inside the byte array {@code buf}.
-   */
+  /** The total number of bytes inside the byte array {@code buf}. */
   private int count;
 
-  /**
-   * The current limit, which when passed, invalidates the current mark.
-   */
+  /** The current limit, which when passed, invalidates the current mark. */
   private int marklimit;
 
   /**
@@ -59,10 +53,9 @@
    */
   private int markpos = -1;
 
-  /**
-   * The current position within the byte array {@code buf}.
-   */
+  /** The current position within the byte array {@code buf}. */
   private int pos;
+
   private final ArrayPool byteArrayPool;
 
   public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool) {
@@ -70,8 +63,8 @@ public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool
   }
 
   @VisibleForTesting
-  RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool,
-      int bufferSize) {
+  RecyclableBufferedInputStream(
+      @NonNull InputStream in, @NonNull ArrayPool byteArrayPool, int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
     buf = byteArrayPool.get(bufferSize, byte[].class);
@@ -264,10 +257,8 @@ public synchronized int read() throws IOException {
    * @param buffer the byte array in which to store the bytes read.
    * @return the number of bytes actually read or -1 if end of stream.
    * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code byteCount < 0}, or if {@code
-   *                                   offset + byteCount} is greater than the size of {@code
-   *                                   buffer}.
-   * @throws IOException               if the stream is already closed or another IOException
-   *                                   occurs.
+   *     offset + byteCount} is greater than the size of {@code buffer}.
+   * @throws IOException if the stream is already closed or another IOException occurs.
    */
   @Override
   public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
@@ -277,7 +268,7 @@ public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
     if (localBuf == null) {
       throw streamClosed();
     }
-    //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
+    // Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
     if (byteCount == 0) {
       return 0;
     }
@@ -341,8 +332,7 @@ public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
    * Resets this stream to the last marked location.
    *
    * @throws IOException if this stream is closed, no mark has been put or the mark is no longer
-   *                     valid because more than {@code readlimit} bytes have been read since
-   *                     setting the mark.
+   *     valid because more than {@code readlimit} bytes have been read since setting the mark.
    * @see #mark(int)
    */
   @Override
@@ -351,8 +341,8 @@ public synchronized void reset() throws IOException {
       throw new IOException("Stream is closed");
     }
     if (-1 == markpos) {
-      throw new InvalidMarkException("Mark has been invalidated, pos: " + pos + " markLimit: "
-          + marklimit);
+      throw new InvalidMarkException(
+          "Mark has been invalidated, pos: " + pos + " markLimit: " + marklimit);
     }
     pos = markpos;
   }
@@ -361,8 +351,8 @@ public synchronized void reset() throws IOException {
    * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
    * these bytes unless {@link #reset} is used.
    *
-   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if
-   *                  {@code byteCount} is less than zero.
+   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if {@code
+   *     byteCount} is less than zero.
    * @return the number of bytes actually skipped.
    * @throws IOException if this stream is closed or another IOException occurs.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
index 3ef5b5b3e..407756e8a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -17,16 +17,15 @@
 /**
  * Decodes {@link Bitmap}s from resource ids.
  *
- * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
- * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
- * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
- * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
- * {@link #decode(Object, int, int, Options)}.
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap {@link
+ * Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those {@link Drawable}s anyway
+ * by drawing the {@link Drawable} to a {@link Canvas}s using the {@link Drawable}'s intrinsic
+ * bounds or the dimensions provided to {@link #decode(Object, int, int, Options)}.
  *
- * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
- * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
- * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
- * are {@link Target#SIZE_ORIGINAL}.
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for {@link
+ * Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this decoder will
+ * fail if the width and height provided to {@link #decode(Object, int, int, Options)} are {@link
+ * Target#SIZE_ORIGINAL}.
  */
 public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
 
@@ -45,8 +44,8 @@ public boolean handles(@NonNull Uri source, @NonNull Options options) {
 
   @Nullable
   @Override
-  public Resource<Bitmap> decode(@NonNull Uri source, int width, int height,
-      @NonNull Options options) {
+  public Resource<Bitmap> decode(
+      @NonNull Uri source, int width, int height, @NonNull Options options) {
     Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
     if (drawableResource == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
index e732f48dc..e104a017a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java
@@ -7,9 +7,7 @@
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
-/**
- * A {@link BitmapTransformation} which rotates the bitmap.
- */
+/** A {@link BitmapTransformation} which rotates the bitmap. */
 public class Rotate extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.Rotate";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
@@ -17,8 +15,8 @@
   private final int degreesToRotate;
 
   /**
-    * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
-    *                        not modified.
+   * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
+   *     not modified.
    */
   public Rotate(int degreesToRotate) {
     this.degreesToRotate = degreesToRotate;
@@ -41,8 +39,7 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    return Util.hashCode(ID.hashCode(),
-            Util.hashCode(degreesToRotate));
+    return Util.hashCode(ID.hashCode(), Util.hashCode(degreesToRotate));
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index ae5552152..54f7cf475 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -8,9 +8,7 @@
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
-/**
- * A {@link BitmapTransformation} which rounds the corners of a bitmap.
- */
+/** A {@link BitmapTransformation} which rounds the corners of a bitmap. */
 public final class RoundedCorners extends BitmapTransformation {
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
@@ -43,8 +41,7 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    return Util.hashCode(ID.hashCode(),
-        Util.hashCode(roundingRadius));
+    return Util.hashCode(ID.hashCode(), Util.hashCode(roundingRadius));
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 00cc6f3c1..b20022203 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -31,8 +31,8 @@ public boolean handles(@NonNull InputStream source, @NonNull Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(@NonNull InputStream source, int width, int height,
-      @NonNull Options options)
+  public Resource<Bitmap> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
       throws IOException {
 
     // Use to fix the mark limit to avoid allocating buffers that fit entire images.
@@ -76,7 +76,8 @@ public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     private final RecyclableBufferedInputStream bufferedStream;
     private final ExceptionCatchingInputStream exceptionStream;
 
-    UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+    UntrustedCallbacks(
+        RecyclableBufferedInputStream bufferedStream,
         ExceptionCatchingInputStream exceptionStream) {
       this.bufferedStream = bufferedStream;
       this.exceptionStream = exceptionStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index ff04a29ae..109f56b0f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -28,9 +28,7 @@
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
-/**
- * A class with methods to efficiently resize Bitmaps.
- */
+/** A class with methods to efficiently resize Bitmaps. */
 // Legacy Public APIs.
 @SuppressWarnings("WeakerAccess")
 public final class TransformationUtils {
@@ -76,19 +74,15 @@
               "XT1072",
               "XT1077",
               "XT1078",
-              "XT1079"
-          )
-      );
+              "XT1079"));
 
   /**
    * https://github.com/bumptech/glide/issues/738 On some devices, bitmap drawing is not thread
-   * safe.
-   * This lock only locks for these specific devices. For other types of devices the lock is always
-   * available and therefore does not impact performance
+   * safe. This lock only locks for these specific devices. For other types of devices the lock is
+   * always available and therefore does not impact performance
    */
   private static final Lock BITMAP_DRAWABLE_LOCK =
-      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
-          ? new ReentrantLock() : new NoLock();
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL) ? new ReentrantLock() : new NoLock();
 
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
@@ -99,7 +93,6 @@ private TransformationUtils() {
     // Utility class.
   }
 
-
   public static Lock getBitmapDrawableLock() {
     return BITMAP_DRAWABLE_LOCK;
   }
@@ -109,14 +102,14 @@ public static Lock getBitmapDrawableLock() {
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
-   * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param inBitmap   The Bitmap to resize.
-   * @param width    The width in pixels of the final Bitmap.
-   * @param height   The height in pixels of the final Bitmap.
+   * @param pool The BitmapPool to obtain a bitmap from.
+   * @param inBitmap The Bitmap to resize.
+   * @param width The width in pixels of the final Bitmap.
+   * @param height The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap centerCrop(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       return inBitmap;
     }
@@ -150,15 +143,15 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
    * An expensive operation to resize the given Bitmap down so that it fits within the given
    * dimensions maintain the original proportions.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to shrink.
-   * @param width  The width in pixels the final image will fit within.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to shrink.
+   * @param width The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
-   * height matches the given dimensions and toFit fits within the given dimensions
+   *     height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap fitCenter(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
@@ -211,15 +204,15 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
    * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
    * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap  The Bitmap to center.
-   * @param width  The width in pixels of the target.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to center.
+   * @param width The width in pixels of the target.
    * @param height The height in pixels of the target.
    * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
-   * height is larger than the given dimensions
+   *     height is larger than the given dimensions
    */
-  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-      int height) {
+  public static Bitmap centerInside(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width, int height) {
     if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size larger or equal to input, returning input");
@@ -239,8 +232,8 @@ public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBi
    * the transformation for transformations that don't add or remove transparent pixels.
    *
    * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
-   * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
-   *                    transformation.
+   * @param outBitmap The {@link android.graphics.Bitmap} that will be returned from the
+   *     transformation.
    */
   public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
     outBitmap.setHasAlpha(inBitmap.hasAlpha());
@@ -250,9 +243,9 @@ public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
    * This is an expensive operation that copies the image in place with the pixels rotated. If
    * possible rather use getOrientationMatrix, and put that as the imageMatrix on an ImageView.
    *
-   * @param imageToOrient   Image Bitmap to orient.
+   * @param imageToOrient Image Bitmap to orient.
    * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is
-   *                        returned unmodified.
+   *     returned unmodified.
    * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
    */
   public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRotate) {
@@ -261,8 +254,15 @@ public static Bitmap rotateImage(@NonNull Bitmap imageToOrient, int degreesToRot
       if (degreesToRotate != 0) {
         Matrix matrix = new Matrix();
         matrix.setRotate(degreesToRotate);
-        result = Bitmap.createBitmap(imageToOrient, 0, 0, imageToOrient.getWidth(),
-            imageToOrient.getHeight(), matrix, true /*filter*/);
+        result =
+            Bitmap.createBitmap(
+                imageToOrient,
+                0,
+                0,
+                imageToOrient.getWidth(),
+                imageToOrient.getHeight(),
+                matrix,
+                true /*filter*/);
       }
     } catch (Exception e) {
       if (Log.isLoggable(TAG, Log.ERROR)) {
@@ -303,14 +303,13 @@ public static int getExifOrientationDegrees(int exifOrientation) {
   /**
    * Rotate and/or flip the image to match the given exif orientation.
    *
-   * @param pool            A pool that may or may not contain an image of the necessary
-   *                        dimensions.
-   * @param inBitmap        The bitmap to rotate/flip.
+   * @param pool A pool that may or may not contain an image of the necessary dimensions.
+   * @param inBitmap The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int exifOrientation) {
+  public static Bitmap rotateImageExif(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int exifOrientation) {
     if (!isExifOrientationRequired(exifOrientation)) {
       return inBitmap;
     }
@@ -356,17 +355,17 @@ public static boolean isExifOrientationRequired(int exifOrientation) {
   }
 
   /**
-   * Crop the image to a circle and resize to the specified width/height.  The circle crop will
-   * have the same width and height equal to the min-edge of the result image.
+   * Crop the image to a circle and resize to the specified width/height. The circle crop will have
+   * the same width and height equal to the min-edge of the result image.
    *
-   * @param pool   The BitmapPool obtain a bitmap from.
-   * @param inBitmap   The Bitmap to resize.
-   * @param destWidth    The width in pixels of the final Bitmap.
-   * @param destHeight   The height in pixels of the final Bitmap.
+   * @param pool The BitmapPool obtain a bitmap from.
+   * @param inBitmap The Bitmap to resize.
+   * @param destWidth The width in pixels of the final Bitmap.
+   * @param destHeight The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int destWidth, int destHeight) {
+  public static Bitmap circleCrop(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int destWidth, int destHeight) {
     int destMinEdge = Math.min(destWidth, destHeight);
     float radius = destMinEdge / 2f;
 
@@ -417,8 +416,7 @@ private static Bitmap getAlphaSafeBitmap(
       return maybeAlphaSafe;
     }
 
-    Bitmap argbBitmap =
-        pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
+    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
     new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
 
     // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
@@ -447,9 +445,8 @@ private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
-   *
-   * @deprecated Width and height are unused and ignored. Use
-   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   * @deprecated Width and height are unused and ignored. Use {@link #roundedCorners(BitmapPool,
+   *     Bitmap, int)} instead.
    */
   @Deprecated
   public static Bitmap roundedCorners(
@@ -465,9 +462,9 @@ public static Bitmap roundedCorners(
    * Creates a bitmap from a source bitmap and rounds the corners.
    *
    * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
-   * To both resize and round the corners of an image, consider
-   * {@link com.bumptech.glide.request.RequestOptions#transform(Transformation[])} and/or
-   * {@link com.bumptech.glide.load.MultiTransformation}.
+   * To both resize and round the corners of an image, consider {@link
+   * com.bumptech.glide.request.RequestOptions#transform(Transformation[])} and/or {@link
+   * com.bumptech.glide.load.MultiTransformation}.
    *
    * @param inBitmap the source bitmap to use as a basis for the created bitmap.
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
@@ -485,8 +482,8 @@ public static Bitmap roundedCorners(
 
     result.setHasAlpha(true);
 
-    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
-        Shader.TileMode.CLAMP);
+    BitmapShader shader =
+        new BitmapShader(toTransform, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
     Paint paint = new Paint();
     paint.setAntiAlias(true);
     paint.setShader(shader);
@@ -518,8 +515,8 @@ private static void clear(Canvas canvas) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
-  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
-      Matrix matrix) {
+  private static void applyMatrix(
+      @NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap, Matrix matrix) {
     BITMAP_DRAWABLE_LOCK.lock();
     try {
       Canvas canvas = new Canvas(targetBitmap);
@@ -565,7 +562,7 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
   private static final class NoLock implements Lock {
 
     @Synthetic
-    NoLock() { }
+    NoLock() {}
 
     @Override
     public void lock() {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
index 63e804bb1..778c5d672 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -19,8 +19,8 @@ public boolean handles(@NonNull Bitmap source, @NonNull Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(@NonNull Bitmap source, int width, int height,
-      @NonNull Options options) {
+  public Resource<Bitmap> decode(
+      @NonNull Bitmap source, int width, int height, @NonNull Options options) {
     return new NonOwnedBitmapResource(source);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 226765e2d..a2207b1f9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -6,14 +6,12 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
 /**
- * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
- * {@link android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a
- * video.
+ * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame {@link
+ * android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a video.
  *
  * @see android.media.MediaMetadataRetriever
- *
  * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
- * {@link VideoDecoder} may become final in a future version of Glide.
+ *     {@link VideoDecoder} may become final in a future version of Glide.
  */
 @Deprecated
 public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
index 19f192417..1311aaca0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -22,11 +22,11 @@
 import java.security.MessageDigest;
 
 /**
- * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and
- * {@link AssetFileDescriptor}s.
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and {@link
+ * AssetFileDescriptor}s.
  *
- * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or
- * {@link AssetFileDescriptor}.
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or {@link
+ *     AssetFileDescriptor}.
  */
 public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
   private static final String TAG = "VideoDecoder";
@@ -43,61 +43,67 @@
 
   /**
    * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to extract
+   * the video frame.
    *
    * <p>When retrieving the frame at the given time position, there is no guarantee that the data
    * source has a frame located at the position. When this happens, a frame nearby will be returned.
    * If the long is negative, time position and option will ignored, and any frame that the
    * implementation considers as representative may be returned.
    */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-
-        @Override
-        public void update(@NonNull byte[] keyBytes, @NonNull Long value,
-            @NonNull MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
+  public static final Option<Long> TARGET_FRAME =
+      Option.disk(
+          "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame",
+          DEFAULT_FRAME,
+          new Option.CacheKeyUpdater<Long>() {
+            private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Long value,
+                @NonNull MessageDigest messageDigest) {
+              messageDigest.update(keyBytes);
+              synchronized (buffer) {
+                buffer.position(0);
+                messageDigest.update(buffer.putLong(value).array());
+              }
+            }
+          });
 
   /**
    * An integer indicating the frame option used to retrieve a target frame.
    *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to {@link
+   * #DEFAULT_FRAME}.
    *
    * @see MediaMetadataRetriever#getFrameAtTime(long, int)
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
-
-        @Override
-        public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
-            @NonNull MessageDigest messageDigest) {
-          //noinspection ConstantConditions public API, people could have been doing it wrong
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
+  public static final Option<Integer> FRAME_OPTION =
+      Option.disk(
+          "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+          /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+          new Option.CacheKeyUpdater<Integer>() {
+            private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+
+            @Override
+            public void update(
+                @NonNull byte[] keyBytes,
+                @NonNull Integer value,
+                @NonNull MessageDigest messageDigest) {
+              //noinspection ConstantConditions public API, people could have been doing it wrong
+              if (value == null) {
+                return;
+              }
+              messageDigest.update(keyBytes);
+              synchronized (buffer) {
+                buffer.position(0);
+                messageDigest.update(buffer.putInt(value).array());
+              }
+            }
+          });
 
   private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
       new MediaMetadataRetrieverFactory();
@@ -114,8 +120,7 @@ public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
     return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 
-  VideoDecoder(
-      BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+  VideoDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
     this(bitmapPool, initializer, DEFAULT_FACTORY);
   }
 
@@ -246,7 +251,7 @@ private static Bitmap decodeScaledFrame(
 
       return mediaMetadataRetriever.getScaledFrameAtTime(
           frameTimeMicros, frameOption, decodeWidth, decodeHeight);
-     } catch (Throwable t) {
+    } catch (Throwable t) {
       // This is aggressive, but we'd rather catch errors caused by reading and/or parsing metadata
       // here and fall back to just decoding the frame whenever possible. If the exception is thrown
       // just from decoding the frame, then it will be thrown and exposed to callers by the method
@@ -260,9 +265,7 @@ private static Bitmap decodeScaledFrame(
   }
 
   private static Bitmap decodeOriginalFrame(
-      MediaMetadataRetriever mediaMetadataRetriever,
-      long frameTimeMicros,
-      int frameOption) {
+      MediaMetadataRetriever mediaMetadataRetriever, long frameTimeMicros, int frameOption) {
     return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index a154faafb..3b8d77d07 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -4,9 +4,7 @@
 import com.bumptech.glide.load.data.DataRewinder;
 import java.nio.ByteBuffer;
 
-/**
- * Rewinds {@link java.nio.ByteBuffer}s.
- */
+/** Rewinds {@link java.nio.ByteBuffer}s. */
 public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
   private final ByteBuffer buffer;
 
@@ -28,9 +26,7 @@ public void cleanup() {
     // Do nothing.
   }
 
-  /**
-   * Factory for {@link com.bumptech.glide.load.resource.bytes.ByteBufferRewinder}.
-   */
+  /** Factory for {@link com.bumptech.glide.load.resource.bytes.ByteBufferRewinder}. */
   public static class Factory implements DataRewinder.Factory<ByteBuffer> {
 
     @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 88068855d..aae522e79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -4,9 +4,7 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
-/**
- * An {@link com.bumptech.glide.load.engine.Resource} wrapping a byte array.
- */
+/** An {@link com.bumptech.glide.load.engine.Resource} wrapping a byte array. */
 public class BytesResource implements Resource<byte[]> {
   private final byte[] bytes;
 
@@ -24,7 +22,7 @@ public BytesResource(byte[] bytes) {
    * In most cases it will only be retrieved once (see linked methods).
    *
    * @return the same array every time, do not mutate the contents. Not a copy returned, because
-   * copying the array can be prohibitively expensive and/or lead to OOMs.
+   *     copying the array can be prohibitively expensive and/or lead to OOMs.
    * @see com.bumptech.glide.load.ResourceEncoder
    * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
    * @see com.bumptech.glide.request.SingleRequest#onResourceReady
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
index 68f81bd84..d551b4ac0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
@@ -17,13 +17,12 @@
  */
 public final class DrawableDecoderCompat {
   private static volatile boolean shouldCallAppCompatResources = true;
+
   private DrawableDecoderCompat() {
     // Utility class.
   }
 
-  /**
-   * See {@code getDrawable(Context, int, Theme)}.
-   */
+  /** See {@code getDrawable(Context, int, Theme)}. */
   public static Drawable getDrawable(
       Context ourContext, Context targetContext, @DrawableRes int id) {
     return getDrawable(ourContext, targetContext, id, /*theme=*/ null);
@@ -34,7 +33,7 @@ public static Drawable getDrawable(
    * otherwise, depending on whether or not the v7 support library is included in the application.
    *
    * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if
-   * non-null when loading the {@link Drawable}.
+   *     non-null when loading the {@link Drawable}.
    */
   public static Drawable getDrawable(
       Context ourContext, @DrawableRes int id, @Nullable Theme theme) {
@@ -64,8 +63,8 @@ private static Drawable getDrawable(
     return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());
   }
 
-  private static Drawable loadDrawableV7(Context context, @DrawableRes int id,
-      @Nullable Theme theme) {
+  private static Drawable loadDrawableV7(
+      Context context, @DrawableRes int id, @Nullable Theme theme) {
     Context resourceContext = theme != null ? new ContextThemeWrapper(context, theme) : context;
     return AppCompatResources.getDrawable(resourceContext, id);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 17b74f2cc..16f48d2c7 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -11,17 +11,16 @@
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a
- * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
- * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a {@link
+ * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
+ * android.graphics.drawable.Drawable.ConstantState state}.
  *
- * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
- * class.</b>
+ * <p><b>Suggested usages only include {@code T}s where the new drawable is of the same or
+ * descendant class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
-    Initializable {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>, Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 8eec67561..44e2a474b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -6,13 +6,11 @@
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
 import com.bumptech.glide.request.transition.TransitionFactory;
 
-/**
- * Contains {@link Drawable} specific animation options.
- */
+/** Contains {@link Drawable} specific animation options. */
 // Public API.
 @SuppressWarnings("WeakerAccess")
-public final class DrawableTransitionOptions extends
-    TransitionOptions<DrawableTransitionOptions, Drawable> {
+public final class DrawableTransitionOptions
+    extends TransitionOptions<DrawableTransitionOptions, Drawable> {
 
   /**
    * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
@@ -80,8 +78,8 @@ public DrawableTransitionOptions crossFade() {
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
    *
-   * @param duration The duration of the animation, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @param duration The duration of the animation, see {@code
+   *     DrawableCrossFadeFactory.Builder(int)}
    * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
    */
   @NonNull
@@ -108,4 +106,3 @@ public DrawableTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Bui
     return crossFade(builder.build());
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
index 2cba88462..51f3d6f5b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -6,8 +6,8 @@
 import com.bumptech.glide.load.engine.Resource;
 
 /**
- * Handles generic {@link Drawable} types where we may be uncertain of their size or type and
- * where we don't know that it's safe for us to recycle or re-use the Drawable.
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and where
+ * we don't know that it's safe for us to recycle or re-use the Drawable.
  */
 final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
index 0923ffceb..ac97397b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -56,8 +56,8 @@ public boolean handles(@NonNull Uri source, @NonNull Options options) {
 
   @Nullable
   @Override
-  public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
-      @NonNull Options options) {
+  public Resource<Drawable> decode(
+      @NonNull Uri source, int width, int height, @NonNull Options options) {
     String packageName = source.getAuthority();
     Context targetContext = findContextForPackage(source, packageName);
     @DrawableRes int resId = findResourceIdFromUri(targetContext, source);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
index 7ac9450c7..5f1736424 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -7,9 +7,7 @@
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 
-/**
- * Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}.
- */
+/** Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}. */
 public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
   @Override
   public boolean handles(@NonNull Drawable source, @NonNull Options options) {
@@ -18,8 +16,8 @@ public boolean handles(@NonNull Drawable source, @NonNull Options options) {
 
   @Nullable
   @Override
-  public Resource<Drawable> decode(@NonNull Drawable source, int width, int height,
-      @NonNull Options options) {
+  public Resource<Drawable> decode(
+      @NonNull Drawable source, int width, int height, @NonNull Options options) {
     return NonOwnedDrawableResource.newInstance(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index a5b3e13dd..da7b9b6ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -18,8 +18,8 @@ public boolean handles(@NonNull File source, @NonNull Options options) {
   }
 
   @Override
-  public Resource<File> decode(@NonNull File source, int width, int height,
-      @NonNull Options options) {
+  public Resource<File> decode(
+      @NonNull File source, int width, int height, @NonNull Options options) {
     return new FileResource(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index 790f33b53..fa944a15f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.load.resource.SimpleResource;
 import java.io.File;
 
-/**
- * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
- */
+/** A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}. */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public class FileResource extends SimpleResource<File> {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index dbab1827c..c0264eb79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -46,12 +46,17 @@
   // Public API.
   @SuppressWarnings("unused")
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
-        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+    this(
+        context,
+        Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(),
+        Glide.get(context).getArrayPool());
   }
 
   public ByteBufferGifDecoder(
-      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      Context context,
+      List<ImageHeaderParser> parsers,
+      BitmapPool bitmapPool,
       ArrayPool arrayPool) {
     this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
@@ -78,8 +83,8 @@ public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) thr
   }
 
   @Override
-  public GifDrawableResource decode(@NonNull ByteBuffer source, int width, int height,
-      @NonNull Options options) {
+  public GifDrawableResource decode(
+      @NonNull ByteBuffer source, int width, int height, @NonNull Options options) {
     final GifHeaderParser parser = parserPool.obtain(source);
     try {
       return decode(source, width, height, parser, options);
@@ -99,8 +104,10 @@ private GifDrawableResource decode(
         return null;
       }
 
-      Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
-          ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
+      Bitmap.Config config =
+          options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+              ? Bitmap.Config.RGB_565
+              : Bitmap.Config.ARGB_8888;
 
       int sampleSize = getSampleSize(header, width, height);
       GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
@@ -125,25 +132,36 @@ private GifDrawableResource decode(
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
-    int exactSampleSize = Math.min(gifHeader.getHeight() / targetHeight,
-        gifHeader.getWidth() / targetWidth);
+    int exactSampleSize =
+        Math.min(gifHeader.getHeight() / targetHeight, gifHeader.getWidth() / targetWidth);
     int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
     if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
-      Log.v(TAG, "Downsampling GIF"
-          + ", sampleSize: " + sampleSize
-          + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
-          + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
+      Log.v(
+          TAG,
+          "Downsampling GIF"
+              + ", sampleSize: "
+              + sampleSize
+              + ", target dimens: ["
+              + targetWidth
+              + "x"
+              + targetHeight
+              + "]"
+              + ", actual dimens: ["
+              + gifHeader.getWidth()
+              + "x"
+              + gifHeader.getHeight()
+              + "]");
     }
     return sampleSize;
   }
 
   @VisibleForTesting
   static class GifDecoderFactory {
-    GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
-        ByteBuffer data, int sampleSize) {
+    GifDecoder build(
+        GifDecoder.BitmapProvider provider, GifHeader header, ByteBuffer data, int sampleSize) {
       return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 400530d79..371d5af39 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.gif;
 
-
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -24,10 +23,7 @@ public GifBitmapProvider(BitmapPool bitmapPool) {
     this(bitmapPool, /*arrayPool=*/ null);
   }
 
-  /**
-   * Constructs an instance with a shared array pool. Arrays will be reused where
-   * possible.
-   */
+  /** Constructs an instance with a shared array pool. Arrays will be reused where possible. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ArrayPool arrayPool) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 8de52d8d1..d0591d1af 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -28,11 +28,9 @@
 /**
  * An animated {@link android.graphics.drawable.Drawable} that plays the frames of an animated GIF.
  */
-public class GifDrawable extends Drawable implements GifFrameLoader.FrameCallback,
-    Animatable, Animatable2Compat {
-  /**
-   * A constant indicating that an animated drawable should loop continuously.
-   */
+public class GifDrawable extends Drawable
+    implements GifFrameLoader.FrameCallback, Animatable, Animatable2Compat {
+  /** A constant indicating that an animated drawable should loop continuously. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static final int LOOP_FOREVER = -1;
@@ -44,20 +42,15 @@
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public static final int LOOP_INTRINSIC = 0;
+
   private static final int GRAVITY = Gravity.FILL;
 
   private final GifState state;
-  /**
-   * True if the drawable is currently animating.
-   */
+  /** True if the drawable is currently animating. */
   private boolean isRunning;
-  /**
-   * True if the drawable should animate while visible.
-   */
+  /** True if the drawable should animate while visible. */
   private boolean isStarted;
-  /**
-   * True if the drawable's resources have been recycled.
-   */
+  /** True if the drawable's resources have been recycled. */
   private boolean isRecycled;
   /**
    * True if the drawable is currently visible. Default to true because on certain platforms (at
@@ -66,43 +59,34 @@
    * See issue #130.
    */
   private boolean isVisible = true;
-  /**
-   * The number of times we've looped over all the frames in the GIF.
-   */
+  /** The number of times we've looped over all the frames in the GIF. */
   private int loopCount;
-  /**
-   * The number of times to loop through the GIF animation.
-   */
+  /** The number of times to loop through the GIF animation. */
   private int maxLoopCount = LOOP_FOREVER;
 
   private boolean applyGravity;
   private Paint paint;
   private Rect destRect;
 
-  /**
-   * Callbacks to notify loop completion of a gif, where the loop count is explicitly specified.
-   */
+  /** Callbacks to notify loop completion of a gif, where the loop count is explicitly specified. */
   private List<AnimationCallback> animationCallbacks;
 
   /**
    * Constructor for GifDrawable.
    *
-   * @param context             A context.
-   * @param bitmapPool          Ignored, see deprecation note.
+   * @param context A context.
+   * @param bitmapPool Ignored, see deprecation note.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
-   *                            applied to each frame.
-   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
-   *                            width of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
-   *                            height of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode GIF data.
-   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   *     applied to each frame.
+   * @param targetFrameWidth The desired width of the frames displayed by this drawable (the width
+   *     of the view or {@link com.bumptech.glide.request.target.Target} this drawable is being
+   *     loaded into).
+   * @param targetFrameHeight The desired height of the frames displayed by this drawable (the
+   *     height of the view or {@link com.bumptech.glide.request.target.Target} this drawable is
+   *     being loaded into).
+   * @param gifDecoder The decoder to use to decode GIF data.
+   * @param firstFrame The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
-   *
    * @deprecated Use {@link #GifDrawable(Context, GifDecoder, Transformation, int, int, Bitmap)}
    */
   @SuppressWarnings("deprecation")
@@ -118,22 +102,20 @@ public GifDrawable(
     this(context, gifDecoder, frameTransformation, targetFrameWidth, targetFrameHeight, firstFrame);
   }
 
-   /**
+  /**
    * Constructor for GifDrawable.
    *
-   * @param context             A context.
+   * @param context A context.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
-   *                            applied to each frame.
-   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
-   *                            width of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
-   *                            height of the view or
-   *                            {@link com.bumptech.glide.request.target.Target}
-   *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode GIF data.
-   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   *     applied to each frame.
+   * @param targetFrameWidth The desired width of the frames displayed by this drawable (the width
+   *     of the view or {@link com.bumptech.glide.request.target.Target} this drawable is being
+   *     loaded into).
+   * @param targetFrameHeight The desired height of the frames displayed by this drawable (the
+   *     height of the view or {@link com.bumptech.glide.request.target.Target} this drawable is
+   *     being loaded into).
+   * @param gifDecoder The decoder to use to decode GIF data.
+   * @param firstFrame The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
   public GifDrawable(
@@ -175,8 +157,8 @@ public Bitmap getFirstFrame() {
 
   // Public API.
   @SuppressWarnings("WeakerAccess")
-  public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
-      Bitmap firstFrame) {
+  public void setFrameTransformation(
+      Transformation<Bitmap> frameTransformation, Bitmap firstFrame) {
     state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
   }
 
@@ -233,8 +215,10 @@ public void stop() {
   }
 
   private void startRunning() {
-    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
-        + "you clear any references to the Drawable when clearing the corresponding request.");
+    Preconditions.checkArgument(
+        !isRecycled,
+        "You cannot start a recycled Drawable. Ensure that"
+            + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -252,9 +236,11 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
-    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
-        + " Ensure that you unset the Drawable from your View before changing the View's"
-        + " visibility.");
+    Preconditions.checkArgument(
+        !isRecycled,
+        "Cannot change the visibility of a recycled resource."
+            + " Ensure that you unset the Drawable from your View before changing the View's"
+            + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -377,9 +363,7 @@ public ConstantState getConstantState() {
     return state;
   }
 
-  /**
-   * Clears any resources for loading frames that are currently held on to by this object.
-   */
+  /** Clears any resources for loading frames that are currently held on to by this object. */
   public void recycle() {
     isRecycled = true;
     state.frameLoader.clear();
@@ -394,8 +378,9 @@ boolean isRecycled() {
   @SuppressWarnings("WeakerAccess")
   public void setLoopCount(int loopCount) {
     if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
-      throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
-          + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
+      throw new IllegalArgumentException(
+          "Loop count must be greater than 0, or equal to "
+              + "GlideDrawable.LOOP_FOREVER, or equal to GlideDrawable.LOOP_INTRINSIC");
     }
 
     if (loopCount == LOOP_INTRINSIC) {
@@ -408,13 +393,13 @@ public void setLoopCount(int loopCount) {
   }
 
   /**
-   * Register callback to listen to GifDrawable animation end event after specific loop count
-   * set by {@link GifDrawable#setLoopCount(int)}.
+   * Register callback to listen to GifDrawable animation end event after specific loop count set by
+   * {@link GifDrawable#setLoopCount(int)}.
    *
-   * Note: This will only be called if the Gif stop because it reaches the loop count. Unregister
+   * <p>Note: This will only be called if the Gif stop because it reaches the loop count. Unregister
    * this in onLoadCleared to avoid potential memory leak.
-   * @see GifDrawable#unregisterAnimationCallback(AnimationCallback).
    *
+   * @see GifDrawable#unregisterAnimationCallback(AnimationCallback).
    * @param animationCallback Animation callback {@link Animatable2Compat.AnimationCallback}.
    */
   @Override
@@ -444,8 +429,7 @@ public void clearAnimationCallbacks() {
   }
 
   static final class GifState extends ConstantState {
-    @VisibleForTesting
-    final GifFrameLoader frameLoader;
+    @VisibleForTesting final GifFrameLoader frameLoader;
 
     GifState(GifFrameLoader frameLoader) {
       this.frameLoader = frameLoader;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index e73f713dc..b27e4ca07 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -24,8 +24,8 @@ public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
   }
 
   @Override
-  public boolean encode(@NonNull Resource<GifDrawable> data, @NonNull File file,
-      @NonNull Options options) {
+  public boolean encode(
+      @NonNull Resource<GifDrawable> data, @NonNull File file, @NonNull Options options) {
     GifDrawable drawable = data.get();
     boolean success = false;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 090f279b8..facf2db24 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -4,11 +4,8 @@
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
-/**
- * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
- */
-public class GifDrawableResource extends DrawableResource<GifDrawable>
-    implements Initializable {
+/** A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}. */
+public class GifDrawableResource extends DrawableResource<GifDrawable> implements Initializable {
   // Public API.
   @SuppressWarnings("WeakerAccess")
   public GifDrawableResource(GifDrawable drawable) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 392661b1b..7174de21d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -12,9 +12,9 @@
 import java.security.MessageDigest;
 
 /**
- * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a
- * {@link Bitmap} and can apply it to every frame of any
- * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
+ * An {@link com.bumptech.glide.load.Transformation} that wraps a transformation for a {@link
+ * Bitmap} and can apply it to every frame of any {@link
+ * com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
@@ -26,8 +26,10 @@ public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
   @NonNull
   @Override
   public Resource<GifDrawable> transform(
-      @NonNull Context context, @NonNull Resource<GifDrawable> resource,
-      int outWidth, int outHeight) {
+      @NonNull Context context,
+      @NonNull Resource<GifDrawable> resource,
+      int outWidth,
+      int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 9e90d9579..305be3dba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -35,7 +35,11 @@
   private final GifDecoder gifDecoder;
   private final Handler handler;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  @SuppressWarnings("WeakerAccess") @Synthetic final RequestManager requestManager;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final RequestManager requestManager;
+
   private final BitmapPool bitmapPool;
 
   private boolean isRunning;
@@ -48,8 +52,7 @@
   private Bitmap firstFrame;
   private Transformation<Bitmap> transformation;
   private DelayTarget pendingTarget;
-  @Nullable
-  private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
+  @Nullable private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
   private int firstFrameSize;
   private int width;
   private int height;
@@ -292,7 +295,7 @@ void onFrameReady(DelayTarget delayTarget) {
     static final int MSG_CLEAR = 2;
 
     @Synthetic
-    FrameLoaderCallback() { }
+    FrameLoaderCallback() {}
 
     @Override
     public boolean handleMessage(Message msg) {
@@ -326,8 +329,8 @@ Bitmap getResource() {
     }
 
     @Override
-    public void onResourceReady(@NonNull Bitmap resource,
-        @Nullable Transition<? super Bitmap> transition) {
+    public void onResourceReady(
+        @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
       this.resource = resource;
       Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
       handler.sendMessageAtTime(msg, targetTime);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 0fa7e28d5..26b22b850 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -26,8 +26,8 @@ public boolean handles(@NonNull GifDecoder source, @NonNull Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(@NonNull GifDecoder source, int width, int height,
-      @NonNull Options options) {
+  public Resource<Bitmap> decode(
+      @NonNull GifDecoder source, int width, int height, @NonNull Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
index cb2f71e5e..bb93374df 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
@@ -5,9 +5,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 
-/**
- * Options related to decoding GIFs.
- */
+/** Options related to decoding GIFs. */
 public final class GifOptions {
 
   /**
@@ -15,16 +13,17 @@
    * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when
    * decoding frames of GIFs.
    */
-  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
-      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
+  public static final Option<DecodeFormat> DECODE_FORMAT =
+      Option.memory(
+          "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
 
   /**
    * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s
    * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to
    * {@code false}.
    */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
+  public static final Option<Boolean> DISABLE_ANIMATION =
+      Option.memory("com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
 
   private GifOptions() {
     // Utility class.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index 2cc3b848b..d97ce9cf9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -17,8 +17,8 @@
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
- * that converts {@link java.io.InputStream}s to {@link java.nio.ByteBuffer}s and then passes
- * the buffer to a wrapped decoder.
+ * that converts {@link java.io.InputStream}s to {@link java.nio.ByteBuffer}s and then passes the
+ * buffer to a wrapped decoder.
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
   private static final String TAG = "StreamGifDecoder";
@@ -27,8 +27,10 @@
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
-      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+  public StreamGifDecoder(
+      List<ImageHeaderParser> parsers,
+      ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
+      ArrayPool byteArrayPool) {
     this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
@@ -41,8 +43,9 @@ public boolean handles(@NonNull InputStream source, @NonNull Options options) th
   }
 
   @Override
-  public Resource<GifDrawable> decode(@NonNull InputStream source, int width, int height,
-      @NonNull Options options) throws IOException {
+  public Resource<GifDrawable> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
+      throws IOException {
     byte[] data = inputStreamToBytes(source);
     if (data == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 9274b56ff..b9d4cfa7a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -11,8 +11,7 @@
 /**
  * An {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} that converts {@link
  * android.graphics.Bitmap}s into byte arrays using {@link android.graphics.Bitmap#compress
- * (android.graphics.Bitmap.CompressFormat,
- * int, java.io.OutputStream)}.
+ * (android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}.
  */
 public class BitmapBytesTranscoder implements ResourceTranscoder<Bitmap, byte[]> {
   private final Bitmap.CompressFormat compressFormat;
@@ -31,8 +30,8 @@ public BitmapBytesTranscoder(@NonNull Bitmap.CompressFormat compressFormat, int
 
   @Nullable
   @Override
-  public Resource<byte[]> transcode(@NonNull Resource<Bitmap> toTranscode,
-      @NonNull Options options) {
+  public Resource<byte[]> transcode(
+      @NonNull Resource<Bitmap> toTranscode, @NonNull Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index b9dc68bb5..7cf56dabe 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -25,9 +25,7 @@ public BitmapDrawableTranscoder(@NonNull Context context) {
     this(context.getResources());
   }
 
-  /**
-   * @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused.
-   */
+  /** @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused. */
   @Deprecated
   public BitmapDrawableTranscoder(
       @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
@@ -40,8 +38,8 @@ public BitmapDrawableTranscoder(@NonNull Resources resources) {
 
   @Nullable
   @Override
-  public Resource<BitmapDrawable> transcode(@NonNull Resource<Bitmap> toTranscode,
-      @NonNull Options options) {
+  public Resource<BitmapDrawable> transcode(
+      @NonNull Resource<Bitmap> toTranscode, @NonNull Options options) {
     return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
index a37e16ff6..ecb502e1e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.transcode;
 
-
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -13,8 +12,8 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 
 /**
- * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a
- * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s.
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a {@link ResourceTranscoder}
+ * for {@link Bitmap}s to {@code byte[]}s.
  */
 public final class DrawableBytesTranscoder implements ResourceTranscoder<Drawable, byte[]> {
   private final BitmapPool bitmapPool;
@@ -32,8 +31,8 @@ public DrawableBytesTranscoder(
 
   @Nullable
   @Override
-  public Resource<byte[]> transcode(@NonNull Resource<Drawable> toTranscode,
-      @NonNull Options options) {
+  public Resource<byte[]> transcode(
+      @NonNull Resource<Drawable> toTranscode, @NonNull Options options) {
     Drawable drawable = toTranscode.get();
     if (drawable instanceof BitmapDrawable) {
       return bitmapBytesTranscoder.transcode(
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 69e82202d..95d418721 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -17,8 +17,8 @@
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
   @Nullable
   @Override
-  public Resource<byte[]> transcode(@NonNull Resource<GifDrawable> toTranscode,
-      @NonNull Options options) {
+  public Resource<byte[]> transcode(
+      @NonNull Resource<GifDrawable> toTranscode, @NonNull Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index 9c907b65f..a7ef862da 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -16,26 +16,27 @@
    * Registers the given {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} using
    * the given classes so it can later be retrieved using the given classes.
    *
-   * @param decodedClass    The class of the resource that the transcoder transcodes from.
+   * @param decodedClass The class of the resource that the transcoder transcodes from.
    * @param transcodedClass The class of the resource that the transcoder transcodes to.
-   * @param transcoder      The transcoder.
-   * @param <Z>             The type of the resource that the transcoder transcodes from.
-   * @param <R>             The type of the resource that the transcoder transcodes to.
+   * @param transcoder The transcoder.
+   * @param <Z> The type of the resource that the transcoder transcodes from.
+   * @param <R> The type of the resource that the transcoder transcodes to.
    */
   public synchronized <Z, R> void register(
-      @NonNull Class<Z> decodedClass, @NonNull Class<R> transcodedClass,
+      @NonNull Class<Z> decodedClass,
+      @NonNull Class<R> transcodedClass,
       @NonNull ResourceTranscoder<Z, R> transcoder) {
     transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
   }
 
   /**
-   * Returns the currently registered
-   * {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the given classes.
+   * Returns the currently registered {@link
+   * com.bumptech.glide.load.resource.transcode.ResourceTranscoder} for the given classes.
    *
-   * @param resourceClass   The class of the resource that the transcoder transcodes from.
+   * @param resourceClass The class of the resource that the transcoder transcodes from.
    * @param transcodedClass The class of the resource that the transcoder transcodes to.
-   * @param <Z>             The type of the resource that the transcoder transcodes from.
-   * @param <R>             The type of the resource that the transcoder transcodes to.
+   * @param <Z> The type of the resource that the transcoder transcodes from.
+   * @param <R> The type of the resource that the transcoder transcodes to.
    */
   @NonNull
   @SuppressWarnings("unchecked")
@@ -82,7 +83,9 @@
     private final Class<R> toClass;
     @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
-    Entry(@NonNull Class<Z> fromClass, @NonNull Class<R> toClass,
+    Entry(
+        @NonNull Class<Z> fromClass,
+        @NonNull Class<R> toClass,
         @NonNull ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
       this.toClass = toClass;
@@ -91,9 +94,9 @@
 
     /**
      * If we convert from a specific Drawable, we must get that specific Drawable class or a
-     * subclass of that Drawable. In contrast, if we we convert <em>to</em> a specific Drawable,
-     * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
-     * check fromClass and toClass in different orders.
+     * subclass of that Drawable. In contrast, if we we convert <em>to</em> a specific Drawable, we
+     * can fulfill requests for a more generic parent class (like Drawable). As a result, we check
+     * fromClass and toClass in different orders.
      */
     public boolean handles(@NonNull Class<?> fromClass, @NonNull Class<?> toClass) {
       return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index 8bb528050..98cfd88df 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -19,13 +19,13 @@
   /**
    * Adds the given listener to the list of listeners to be notified on each lifecycle event.
    *
-   * <p> The latest lifecycle event will be called on the given listener synchronously in this
+   * <p>The latest lifecycle event will be called on the given listener synchronously in this
    * method. If the activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be
-   * called, and same for onStart and onDestroy. </p>
+   * called, and same for onStart and onDestroy.
    *
-   * <p> Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
+   * <p>Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
    * will have their lifecycle methods called more than once. It is the caller's responsibility to
-   * avoid adding listeners multiple times. </p>
+   * avoid adding listeners multiple times.
    */
   @Override
   public void addListener(@NonNull LifecycleListener listener) {
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index 7bf69da7e..2c1b67d5c 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -6,8 +6,8 @@
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Application} lifecycle events.
  *
- * <p> Since there are essentially no {@link android.app.Application} lifecycle events, this class
- * simply defaults to notifying new listeners that they are started. </p>
+ * <p>Since there are essentially no {@link android.app.Application} lifecycle events, this class
+ * simply defaults to notifying new listeners that they are started.
  */
 class ApplicationLifecycle implements Lifecycle {
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
index dc216c871..22153d246 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java
@@ -1,13 +1,9 @@
 package com.bumptech.glide.manager;
 
-/**
- * An interface for monitoring network connectivity events.
- */
+/** An interface for monitoring network connectivity events. */
 public interface ConnectivityMonitor extends LifecycleListener {
 
-  /**
-   * An interface for listening to network connectivity events picked up by the monitor.
-   */
+  /** An interface for listening to network connectivity events picked up by the monitor. */
   interface ConnectivityListener {
     /**
      * Called when the connectivity state changes.
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index b226cd425..00a42aa99 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -4,13 +4,12 @@
 import android.support.annotation.NonNull;
 
 /**
- * A factory class that produces a functional
- * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
+ * A factory class that produces a functional {@link
+ * com.bumptech.glide.manager.ConnectivityMonitor}.
  */
 public interface ConnectivityMonitorFactory {
 
   @NonNull
   ConnectivityMonitor build(
-      @NonNull Context context,
-      @NonNull ConnectivityMonitor.ConnectivityListener listener);
+      @NonNull Context context, @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index bea4b3673..c4571944d 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -12,31 +12,36 @@
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 
-/**
- * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
- */
+/** Uses {@link android.net.ConnectivityManager} to identify connectivity changes. */
 final class DefaultConnectivityMonitor implements ConnectivityMonitor {
   private static final String TAG = "ConnectivityMonitor";
   private final Context context;
-  @SuppressWarnings("WeakerAccess") @Synthetic final ConnectivityListener listener;
 
-  @SuppressWarnings("WeakerAccess") @Synthetic boolean isConnected;
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final ConnectivityListener listener;
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  boolean isConnected;
+
   private boolean isRegistered;
 
-  private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
-    @Override
-    public void onReceive(@NonNull Context context, Intent intent) {
-      boolean wasConnected = isConnected;
-      isConnected = isConnected(context);
-      if (wasConnected != isConnected) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
-        }
+  private final BroadcastReceiver connectivityReceiver =
+      new BroadcastReceiver() {
+        @Override
+        public void onReceive(@NonNull Context context, Intent intent) {
+          boolean wasConnected = isConnected;
+          isConnected = isConnected(context);
+          if (wasConnected != isConnected) {
+            if (Log.isLoggable(TAG, Log.DEBUG)) {
+              Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
+            }
 
-        listener.onConnectivityChanged(isConnected);
-      }
-    }
-  };
+            listener.onConnectivityChanged(isConnected);
+          }
+        }
+      };
 
   DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {
     this.context = context.getApplicationContext();
@@ -52,8 +57,8 @@ private void register() {
     isConnected = isConnected(context);
     try {
       // See #1405
-      context.registerReceiver(connectivityReceiver,
-          new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+      context.registerReceiver(
+          connectivityReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
       isRegistered = true;
     } catch (SecurityException e) {
       // See #1417, registering the receiver can throw SecurityException.
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
index 6858eb370..e994b1b56 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -19,8 +19,7 @@
   @NonNull
   @Override
   public ConnectivityMonitor build(
-      @NonNull Context context,
-      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+      @NonNull Context context, @NonNull ConnectivityMonitor.ConnectivityListener listener) {
     int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
     boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
     if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -31,6 +30,7 @@ public ConnectivityMonitor build(
               : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");
     }
     return hasPermission
-        ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
+        ? new DefaultConnectivityMonitor(context, listener)
+        : new NullConnectivityMonitor();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 7297680cd..0b6a3e9b4 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -5,13 +5,11 @@
 import java.util.Collections;
 import java.util.Set;
 
-/**
- * A {@link RequestManagerTreeNode} that returns no relatives.
- */
+/** A {@link RequestManagerTreeNode} that returns no relatives. */
 final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
-    @NonNull
-    @Override
-    public Set<RequestManager> getDescendants() {
-        return Collections.emptySet();
-    }
+  @NonNull
+  @Override
+  public Set<RequestManager> getDescendants() {
+    return Collections.emptySet();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 434b5dcab..4e7e7703c 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -2,13 +2,9 @@
 
 import android.support.annotation.NonNull;
 
-/**
- * An interface for listening to Activity/Fragment lifecycle events.
- */
+/** An interface for listening to Activity/Fragment lifecycle events. */
 public interface Lifecycle {
-  /**
-   * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
-   */
+  /** Adds the given listener to the set of listeners managed by this Lifecycle implementation. */
   void addListener(@NonNull LifecycleListener listener);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
index b182cb0ab..ba7d0a9e6 100644
--- a/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/NullConnectivityMonitor.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.manager;
 
-/**
- * A no-op {@link com.bumptech.glide.manager.ConnectivityMonitor}.
- */
+/** A no-op {@link com.bumptech.glide.manager.ConnectivityMonitor}. */
 class NullConnectivityMonitor implements ConnectivityMonitor {
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 14215377a..dcac9f8a3 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -32,13 +32,16 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
+
   @SuppressWarnings("deprecation")
   private final Set<RequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private RequestManager requestManager;
+
   @SuppressWarnings("deprecation")
   @Nullable
   private RequestManagerFragment rootRequestManagerFragment;
+
   @Nullable private Fragment parentFragmentHint;
 
   public RequestManagerFragment() {
@@ -65,17 +68,13 @@ ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
-  /**
-   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
-   */
+  /** Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists. */
   @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
 
-  /**
-   * Returns the {@link RequestManagerTreeNode} for this fragment.
-   */
+  /** Returns the {@link RequestManagerTreeNode} for this fragment. */
   @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
@@ -109,8 +108,8 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       return Collections.emptySet();
     } else {
       Set<RequestManagerFragment> descendants = new HashSet<>();
-      for (RequestManagerFragment fragment : rootRequestManagerFragment
-          .getDescendantRequestManagerFragments()) {
+      for (RequestManagerFragment fragment :
+          rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
           descendants.add(fragment);
         }
@@ -142,9 +141,7 @@ private Fragment getParentFragmentUsingHint() {
     return fragment != null ? fragment : parentFragmentHint;
   }
 
-  /**
-   * Returns true if the fragment is a descendant of our parent.
-   */
+  /** Returns true if the fragment is a descendant of our parent. */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   private boolean isDescendant(@NonNull Fragment fragment) {
     Fragment root = getParentFragment();
@@ -222,7 +219,7 @@ public String toString() {
   private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
 
     @Synthetic
-    FragmentRequestManagerTreeNode() { }
+    FragmentRequestManagerTreeNode() {}
 
     @SuppressWarnings("deprecation")
     @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index a8260fa81..c98b145f6 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -34,8 +34,7 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  @VisibleForTesting
-  static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
+  @VisibleForTesting static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
@@ -45,30 +44,23 @@
   // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
   private static final String FRAGMENT_INDEX_KEY = "key";
 
-  /**
-   * The top application level RequestManager.
-   */
+  /** The top application level RequestManager. */
   private volatile RequestManager applicationManager;
 
-  /**
-   * Pending adds for RequestManagerFragments.
-   */
+  /** Pending adds for RequestManagerFragments. */
   @SuppressWarnings("deprecation")
   @VisibleForTesting
   final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
       new HashMap<>();
 
-  /**
-   * Pending adds for SupportRequestManagerFragments.
-   */
+  /** Pending adds for SupportRequestManagerFragments. */
   @VisibleForTesting
   final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
       new HashMap<>();
 
-  /**
-   * Main thread handler to handle cleaning up pending fragment maps.
-   */
+  /** Main thread handler to handle cleaning up pending fragment maps. */
   private final Handler handler;
+
   private final RequestManagerFactory factory;
 
   // Objects used to find Fragments and Activities containing views.
@@ -131,15 +123,15 @@ public RequestManager get(@NonNull FragmentActivity activity) {
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+      return supportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
   @NonNull
   public RequestManager get(@NonNull Fragment fragment) {
-    Preconditions.checkNotNull(fragment.getActivity(),
-          "You cannot start a load on a fragment before it is attached or after it is destroyed");
+    Preconditions.checkNotNull(
+        fragment.getActivity(),
+        "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
@@ -156,8 +148,7 @@ public RequestManager get(@NonNull Activity activity) {
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+      return fragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
     }
   }
 
@@ -169,8 +160,8 @@ public RequestManager get(@NonNull View view) {
     }
 
     Preconditions.checkNotNull(view);
-    Preconditions.checkNotNull(view.getContext(),
-        "Unable to obtain a request manager for a view without a Context");
+    Preconditions.checkNotNull(
+        view.getContext(), "Unable to obtain a request manager for a view without a Context");
     Activity activity = findActivity(view.getContext());
     // The view might be somewhere else, like a service.
     if (activity == null) {
@@ -195,8 +186,7 @@ public RequestManager get(@NonNull View view) {
   }
 
   private static void findAllSupportFragmentsWithViews(
-      @Nullable Collection<Fragment> topLevelFragments,
-      @NonNull Map<View, Fragment> result) {
+      @Nullable Collection<Fragment> topLevelFragments, @NonNull Map<View, Fragment> result) {
     if (topLevelFragments == null) {
       return;
     }
@@ -375,7 +365,8 @@ private RequestManagerFragment getRequestManagerFragment(
   @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
   @Deprecated
   @NonNull
-  private RequestManager fragmentGet(@NonNull Context context,
+  private RequestManager fragmentGet(
+      @NonNull Context context,
       @NonNull android.app.FragmentManager fm,
       @Nullable android.app.Fragment parentHint,
       boolean isParentVisible) {
@@ -471,9 +462,7 @@ public boolean handleMessage(Message message) {
     return handled;
   }
 
-  /**
-   * Used internally to create {@link RequestManager}s.
-   */
+  /** Used internally to create {@link RequestManager}s. */
   public interface RequestManagerFactory {
     @NonNull
     RequestManager build(
@@ -483,12 +472,16 @@ RequestManager build(
         @NonNull Context context);
   }
 
-  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
-    @NonNull
-    @Override
-    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
-        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
-    }
-  };
+  private static final RequestManagerFactory DEFAULT_FACTORY =
+      new RequestManagerFactory() {
+        @NonNull
+        @Override
+        public RequestManager build(
+            @NonNull Glide glide,
+            @NonNull Lifecycle lifecycle,
+            @NonNull RequestManagerTreeNode requestManagerTreeNode,
+            @NonNull Context context) {
+          return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+        }
+      };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 20666d093..e6c59761e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -11,8 +11,8 @@
  */
 public interface RequestManagerTreeNode {
   /**
-   * Returns all descendant {@link RequestManager}s relative to the context of the current
-   * {@link RequestManager}.
+   * Returns all descendant {@link RequestManager}s relative to the context of the current {@link
+   * RequestManager}.
    */
   @NonNull
   Set<RequestManager> getDescendants();
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 97567671b..daef81081 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -33,11 +33,10 @@
   // before they start running or while they are paused. See #346.
   @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
   private final List<Request> pendingRequests = new ArrayList<>();
+
   private boolean isPaused;
 
-  /**
-   * Starts tracking the given request.
-   */
+  /** Starts tracking the given request. */
   public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
@@ -67,9 +66,9 @@ public boolean clearRemoveAndRecycle(@Nullable Request request) {
   }
 
   private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
-     if (request == null) {
-       // If the Request is null, the request is already cleared and we don't need to search further
-       // for its owner.
+    if (request == null) {
+      // If the Request is null, the request is already cleared and we don't need to search further
+      // for its owner.
       return true;
     }
     boolean isOwnedByUs = requests.remove(request);
@@ -84,16 +83,12 @@ private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean is
     return isOwnedByUs;
   }
 
-  /**
-   * Returns {@code true} if requests are currently paused, and {@code false} otherwise.
-   */
+  /** Returns {@code true} if requests are currently paused, and {@code false} otherwise. */
   public boolean isPaused() {
     return isPaused;
   }
 
-  /**
-   * Stops any in progress requests.
-   */
+  /** Stops any in progress requests. */
   public void pauseRequests() {
     isPaused = true;
     for (Request request : Util.getSnapshot(requests)) {
@@ -115,9 +110,7 @@ public void pauseAllRequests() {
     }
   }
 
-  /**
-   * Starts any not yet completed or failed requests.
-   */
+  /** Starts any not yet completed or failed requests. */
   public void resumeRequests() {
     isPaused = false;
     for (Request request : Util.getSnapshot(requests)) {
@@ -145,9 +138,7 @@ public void clearRequests() {
     pendingRequests.clear();
   }
 
-  /**
-   * Restarts failed requests and cancels and restarts in progress requests.
-   */
+  /** Restarts failed requests and cancels and restarts in progress requests. */
   public void restartRequests() {
     for (Request request : Util.getSnapshot(requests)) {
       if (!request.isComplete() && !request.isCleared()) {
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 7c764cbbc..ea414cfbf 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -59,17 +59,14 @@ ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
-  /**
-   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put.
-   */
+  /** Returns the current {@link com.bumptech.glide.RequestManager} or null if none is put. */
   @Nullable
   public RequestManager getRequestManager() {
     return requestManager;
   }
 
   /**
-   * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative
-   * to the
+   * Returns the {@link RequestManagerTreeNode} that provides tree traversal methods relative to the
    * associated {@link RequestManager}.
    */
   @NonNull
@@ -98,8 +95,8 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else {
       Set<SupportRequestManagerFragment> descendants = new HashSet<>();
-      for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
-          .getDescendantRequestManagerFragments()) {
+      for (SupportRequestManagerFragment fragment :
+          rootRequestManagerFragment.getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragmentUsingHint())) {
           descendants.add(fragment);
         }
@@ -125,9 +122,7 @@ private Fragment getParentFragmentUsingHint() {
     return fragment != null ? fragment : parentFragmentHint;
   }
 
-  /**
-   * Returns true if the fragment is a descendant of our parent.
-   */
+  /** Returns true if the fragment is a descendant of our parent. */
   private boolean isDescendant(@NonNull Fragment fragment) {
     Fragment root = getParentFragmentUsingHint();
     Fragment parentFragment;
@@ -203,7 +198,7 @@ public String toString() {
   private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
 
     @Synthetic
-    SupportFragmentRequestManagerTreeNode() { }
+    SupportFragmentRequestManagerTreeNode() {}
 
     @NonNull
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 45ad1252a..1ee84a4fe 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -9,8 +9,8 @@
 import java.util.WeakHashMap;
 
 /**
- * Holds the set of {@link Target}s currently active for a
- * {@link com.bumptech.glide.RequestManager} and forwards on lifecycle events.
+ * Holds the set of {@link Target}s currently active for a {@link com.bumptech.glide.RequestManager}
+ * and forwards on lifecycle events.
  */
 public final class TargetTracker implements LifecycleListener {
   private final Set<Target<?>> targets =
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
index 77f124670..aefef7b7c 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -7,19 +7,19 @@
 /**
  * Defines a set of dependencies and options to use when initializing Glide within an application.
  *
- * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
- * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications can
+ * include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
  *
- * <p>Classes that extend {@link AppGlideModule} must be annotated with
- * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with {@link
+ * com.bumptech.glide.annotation.GlideModule} to be processed correctly.
  *
- * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
- * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
- * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with {@link
+ * com.bumptech.glide.annotation.Excludes} to optionally exclude one or more {@link
+ * LibraryGlideModule} and/or {@link GlideModule} classes.
  *
  * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
- * annotation processor, {@link AppGlideModule} implementations should override
- * {@link #isManifestParsingEnabled()} and return {@code false}.
+ * annotation processor, {@link AppGlideModule} implementations should override {@link
+ * #isManifestParsingEnabled()} and return {@code false}.
  */
 // Used only in javadoc.
 @SuppressWarnings("deprecation")
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
index c92e0da64..91620beda 100644
--- a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -4,16 +4,14 @@
 import android.support.annotation.NonNull;
 import com.bumptech.glide.GlideBuilder;
 
-/**
- * An internal interface, to be removed when {@link GlideModule}s are removed.
- */
+/** An internal interface, to be removed when {@link GlideModule}s are removed. */
 @Deprecated
 interface AppliesOptions {
   /**
    * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
    * singleton is created.
    *
-   * <p> This method will be called once and only once per implementation. </p>
+   * <p>This method will be called once and only once per implementation.
    *
    * @param context An Application {@link android.content.Context}.
    * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index b8e2108e6..7e6327c2c 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -3,15 +3,17 @@
 import com.bumptech.glide.Registry;
 
 /**
- * An interface allowing lazy configuration of Glide including setting options using
- * {@link com.bumptech.glide.GlideBuilder} and registering
- * {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders}.
+ * An interface allowing lazy configuration of Glide including setting options using {@link
+ * com.bumptech.glide.GlideBuilder} and registering {@link com.bumptech.glide.load.model.ModelLoader
+ * ModelLoaders}.
  *
- * <p> To use this interface: <ol> <li> Implement the GlideModule interface in a class with public
- * visibility, calling
- * {@link Registry#prepend(Class, Class, com.bumptech.glide.load.ResourceDecoder)} for each
- * {@link com.bumptech.glide.load.model.ModelLoader} you'd like to register:
- * <pre>
+ * <p>To use this interface:
+ *
+ * <ol>
+ *   <li>Implement the GlideModule interface in a class with public visibility, calling {@link
+ *       Registry#prepend(Class, Class, com.bumptech.glide.load.ResourceDecoder)} for each {@link
+ *       com.bumptech.glide.load.model.ModelLoader} you'd like to register:
+ *       <pre>
  *                  <code>
  *                      public class FlickrGlideModule implements GlideModule {
  *                          {@literal @}Override
@@ -26,33 +28,29 @@
  *                      }
  *                  </code>
  *             </pre>
- * </li> <li> Add your implementation to your list of keeps in your proguard.cfg file:
- * <pre>
- *                  {@code
- *                      -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
- *                  }
- *              </pre>
- * </li> <li> Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's
- * fully qualified classname as the key, and {@code GlideModule} as the value:
- * <pre>
- *                 {@code
- *                      <meta-data
- *                          android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
- *                          android:value="GlideModule" />
- *                 }
- *             </pre>
- * </li> </ol> </p>
+ *   <li>Add your implementation to your list of keeps in your proguard.cfg file:
+ *       <pre>{@code
+ * -keepnames class * com.bumptech.glide.samples.flickr.FlickrGlideModule
+ * }</pre>
+ *   <li>Add a metadata tag to your AndroidManifest.xml with your GlideModule implementation's fully
+ *       qualified classname as the key, and {@code GlideModule} as the value:
+ *       <pre>{@code
+ * <meta-data
+ *     android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
+ *     android:value="GlideModule" />
+ * }</pre>
+ * </ol>
  *
- * <p> All implementations must be publicly visible and contain only an empty constructor so they
- * can be instantiated via reflection when Glide is lazily initialized. </p>
+ * <p>All implementations must be publicly visible and contain only an empty constructor so they can
+ * be instantiated via reflection when Glide is lazily initialized.
  *
- * <p> There is no defined order in which modules are called, so projects should be careful to avoid
+ * <p>There is no defined order in which modules are called, so projects should be careful to avoid
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
- * instead providing their required dependencies in a single application module. </p>
+ * instead providing their required dependencies in a single application module.
  *
- * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
- * {@link AppGlideModule}.
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use {@link
+ *     AppGlideModule}.
  */
 @Deprecated
-public interface GlideModule extends RegistersComponents, AppliesOptions { }
+public interface GlideModule extends RegistersComponents, AppliesOptions {}
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
index 612dc8c13..1d80c4ac2 100644
--- a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -6,21 +6,21 @@
 import com.bumptech.glide.Registry;
 
 /**
- * Registers a set of components to use when initializing Glide within an app when
- * Glide's annotation processor is used.
+ * Registers a set of components to use when initializing Glide within an app when Glide's
+ * annotation processor is used.
  *
  * <p>Any number of LibraryGlideModules can be contained within any library or application.
  *
  * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
- * application conflict, {@link AppGlideModule}s can use the
- * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
- * the conflicting modules.
+ * application conflict, {@link AppGlideModule}s can use the {@link
+ * com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of the
+ * conflicting modules.
  */
 @SuppressWarnings("deprecation")
 public abstract class LibraryGlideModule implements RegistersComponents {
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 6304f179a..af42f709e 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -31,8 +31,10 @@ public ManifestParser(Context context) {
     }
     List<GlideModule> modules = new ArrayList<>();
     try {
-      ApplicationInfo appInfo = context.getPackageManager()
-          .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
+      ApplicationInfo appInfo =
+          context
+              .getPackageManager()
+              .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
       if (appInfo.metaData == null) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got null app info metadata");
@@ -72,7 +74,7 @@ private static GlideModule parseModule(String className) {
     Object module = null;
     try {
       module = clazz.getDeclaredConstructor().newInstance();
-    // These can't be combined until API minimum is 19.
+      // These can't be combined until API minimum is 19.
     } catch (InstantiationException e) {
       throwInstantiateGlideModuleException(clazz, e);
     } catch (IllegalAccessException e) {
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
index 9461ee341..28b7939a3 100644
--- a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -5,9 +5,7 @@
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
-/**
- * An internal interface, to be removed when {@link GlideModule}s are removed.
- */
+/** An internal interface, to be removed when {@link GlideModule}s are removed. */
 // Used only in javadocs.
 @SuppressWarnings("deprecation")
 @Deprecated
@@ -17,12 +15,12 @@
    * Lazily register components immediately after the Glide singleton is created but before any
    * requests can be started.
    *
-   * <p> This method will be called once and only once per implementation. </p>
+   * <p>This method will be called once and only once per implementation.
    *
-   * @param context  An Application {@link android.content.Context}.
+   * @param context An Application {@link android.content.Context}.
    * @param glide The Glide singleton that is in the process of being initialized.
    * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
    */
-  void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry);
+  void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry);
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index ca5148a0f..938e7fecc 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -7,9 +7,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
- */
+/** Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types. */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
   private final List<Entry<?>> encoders = new ArrayList<>();
@@ -35,7 +33,10 @@
 
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    @Synthetic @SuppressWarnings("WeakerAccess") final Encoder<T> encoder;
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    final Encoder<T> encoder;
 
     Entry(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
       this.dataClass = dataClass;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
index 902fc1bd4..82d33b18a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -5,9 +5,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
- */
+/** Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers. */
 public final class ImageHeaderParserRegistry {
   private final List<ImageHeaderParser> parsers = new ArrayList<>();
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index 89d2525af..c5a6cc558 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -11,8 +11,8 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
- * Maintains a cache of data, resource, and transcode classes to available
- * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
+ * Maintains a cache of data, resource, and transcode classes to available {@link
+ * com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
  */
 public class LoadPathCache {
   private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =
@@ -34,9 +34,9 @@
   private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
 
   /**
-   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from
-   * {@link #get(Class, Class, Class)} that indicates that we've previously found that there are
-   * no available paths to load the requested resources and {@code false} otherwise.
+   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from {@link
+   * #get(Class, Class, Class)} that indicates that we've previously found that there are no
+   * available paths to load the requested resources and {@code false} otherwise.
    */
   public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
     return NO_PATHS_SIGNAL.equals(path);
@@ -44,8 +44,8 @@ public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
 
   /**
    * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0
-   * available load paths for the requested types. Callers must check using
-   * {@link #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
+   * available load paths for the requested types. Callers must check using {@link
+   * #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
    */
   @SuppressWarnings("unchecked")
   @Nullable
@@ -54,7 +54,7 @@ public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
     MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
     LoadPath<?, ?, ?> result;
     synchronized (cache) {
-       result = cache.get(key);
+      result = cache.get(key);
     }
     keyRef.set(key);
 
@@ -62,7 +62,8 @@ public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
   }
 
   public void put(
-      Class<?> dataClass, Class<?> resourceClass,
+      Class<?> dataClass,
+      Class<?> resourceClass,
       Class<?> transcodeClass,
       @Nullable LoadPath<?, ?, ?> loadPath) {
     synchronized (cache) {
@@ -72,9 +73,9 @@ public void put(
     }
   }
 
-  private MultiClassKey getKey(Class<?> dataClass, Class<?> resourceClass,
-      Class<?> transcodeClass) {
-     MultiClassKey key = keyRef.getAndSet(null);
+  private MultiClassKey getKey(
+      Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
+    MultiClassKey key = keyRef.getAndSet(null);
     if (key == null) {
       key = new MultiClassKey();
     }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 4740f4b5a..9b7158f82 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -41,8 +41,8 @@ public void put(
       @NonNull Class<?> transcodeClass,
       @NonNull List<Class<?>> resourceClasses) {
     synchronized (registeredResourceClassCache) {
-      registeredResourceClassCache
-          .put(new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);
+      registeredResourceClassCache.put(
+          new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index bc3ce0d93..f00ef612d 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -32,8 +32,8 @@ public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
 
   @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(@NonNull Class<T> dataClass,
-      @NonNull Class<R> resourceClass) {
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -53,8 +53,8 @@ public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
 
   @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<Class<R>> getResourceClasses(@NonNull Class<T> dataClass,
-      @NonNull Class<R> resourceClass) {
+  public synchronized <T, R> List<Class<R>> getResourceClasses(
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
     for (String bucket : bucketPriorityList) {
       List<Entry<?, ?>> entries = decoders.get(bucket);
@@ -71,15 +71,19 @@ public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
     return result;
   }
 
-  public synchronized <T, R> void append(@NonNull String bucket,
+  public synchronized <T, R> void append(
+      @NonNull String bucket,
       @NonNull ResourceDecoder<T, R> decoder,
-      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+      @NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  public synchronized <T, R> void prepend(@NonNull String bucket,
+  public synchronized <T, R> void prepend(
+      @NonNull String bucket,
       @NonNull ResourceDecoder<T, R> decoder,
-      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+      @NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
   }
 
@@ -102,7 +106,9 @@ public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
     @Synthetic final Class<R> resourceClass;
     @Synthetic final ResourceDecoder<T, R> decoder;
 
-    public Entry(@NonNull Class<T> dataClass, @NonNull Class<R> resourceClass,
+    public Entry(
+        @NonNull Class<T> dataClass,
+        @NonNull Class<R> resourceClass,
         ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
       this.resourceClass = resourceClass;
@@ -110,8 +116,8 @@ public Entry(@NonNull Class<T> dataClass, @NonNull Class<R> resourceClass,
     }
 
     public boolean handles(@NonNull Class<?> dataClass, @NonNull Class<?> resourceClass) {
-      return this.dataClass.isAssignableFrom(dataClass) && resourceClass
-          .isAssignableFrom(this.resourceClass);
+      return this.dataClass.isAssignableFrom(dataClass)
+          && resourceClass.isAssignableFrom(this.resourceClass);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index b1bd2977a..8eb7f3264 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -15,13 +15,13 @@
   // TODO: this should probably be a put.
   private final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void append(@NonNull Class<Z> resourceClass,
-      @NonNull ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(
+      @NonNull Class<Z> resourceClass, @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
-  public synchronized <Z> void prepend(@NonNull Class<Z> resourceClass,
-      @NonNull ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void prepend(
+      @NonNull Class<Z> resourceClass, @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(0, new Entry<>(resourceClass, encoder));
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index ea7f66fa4..509a2e861 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -38,8 +38,8 @@
 import java.util.Map;
 
 /**
- * A base object to allow method sharing between {@link RequestOptions} and
- * {@link com.bumptech.glide.RequestBuilder}.
+ * A base object to allow method sharing between {@link RequestOptions} and {@link
+ * com.bumptech.glide.RequestBuilder}.
  *
  * <p>This class is not meant for general use and may change at any time.
  *
@@ -71,42 +71,34 @@
 
   private int fields;
   private float sizeMultiplier = 1f;
-  @NonNull
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  @NonNull
-  private Priority priority = Priority.NORMAL;
-  @Nullable
-  private Drawable errorPlaceholder;
+  @NonNull private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  @NonNull private Priority priority = Priority.NORMAL;
+  @Nullable private Drawable errorPlaceholder;
   private int errorId;
-  @Nullable
-  private Drawable placeholderDrawable;
+  @Nullable private Drawable placeholderDrawable;
   private int placeholderId;
   private boolean isCacheable = true;
   private int overrideHeight = UNSET;
   private int overrideWidth = UNSET;
-  @NonNull
-  private Key signature = EmptySignature.obtain();
+  @NonNull private Key signature = EmptySignature.obtain();
   private boolean isTransformationRequired;
   private boolean isTransformationAllowed = true;
-  @Nullable
-  private Drawable fallbackDrawable;
+  @Nullable private Drawable fallbackDrawable;
   private int fallbackId;
-  @NonNull
-  private Options options = new Options();
+  @NonNull private Options options = new Options();
+
   @NonNull
   private Map<Class<?>, Transformation<?>> transformations = new CachedHashCodeArrayMap<>();
-  @NonNull
-  private Class<?> resourceClass = Object.class;
+
+  @NonNull private Class<?> resourceClass = Object.class;
   private boolean isLocked;
-  @Nullable
-  private Resources.Theme theme;
+  @Nullable private Resources.Theme theme;
   private boolean isAutoCloneEnabled;
   private boolean useUnlimitedSourceGeneratorsPool;
   private boolean onlyRetrieveFromCache;
   private boolean isScaleOnlyOrNoTransform = true;
   private boolean useAnimationPool;
 
-
   private static boolean isSet(int fields, int flag) {
     return (fields & flag) != 0;
   }
@@ -116,9 +108,8 @@ private static boolean isSet(int fields, int flag) {
    * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
    * (particularly {@link Bitmap}s on devices with overly dense screens.
    *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
+   * @param sizeMultiplier The multiplier to apply to the {@link
+   *     com.bumptech.glide.request.target.Target}'s dimensions when loading the resource.
    * @return This request builder.
    */
   @NonNull
@@ -141,9 +132,9 @@ public T sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
    * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
    * the request.
    *
-   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
-   * of Glide's threads as part of another request. Using this method in other scenarios can lead
-   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one of
+   * Glide's threads as part of another request. Using this method in other scenarios can lead to
+   * excessive memory usage and OOMs and/or a significant decrease in performance across an
    * application.
    *
    * <p>If both this method and {@link #useAnimationPool(boolean)} are set, this method will be
@@ -166,14 +157,13 @@ public T useUnlimitedSourceGeneratorsPool(boolean flag) {
    * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
    * exclusively for decoding frames of animated resources, like GIFs.
    *
-   * <p>The animation executor disallows network operations and must not be used for loads that
-   * may load remote data. The animation executor has fewer threads available to it than Glide's
-   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
-   * reads for critical requests like those in an animating GIF.
+   * <p>The animation executor disallows network operations and must not be used for loads that may
+   * load remote data. The animation executor has fewer threads available to it than Glide's normal
+   * executors and is only useful as a way of avoiding blocking on longer and more expensive reads
+   * for critical requests like those in an animating GIF.
    *
-   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set,
-   * {@link #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be
-   * ignored.
+   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set, {@link
+   * #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be ignored.
    */
   @NonNull
   @CheckResult
@@ -189,7 +179,6 @@ public T useAnimationPool(boolean flag) {
   }
 
   /**
-   *
    * If set to true, will only load an item if found in the cache, and will not fetch from source.
    */
   @NonNull
@@ -208,13 +197,12 @@ public T onlyRetrieveFromCache(boolean flag) {
   /**
    * Sets the {@link DiskCacheStrategy} to use for this load.
    *
-   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   * <p>Defaults to {@link DiskCacheStrategy#AUTOMATIC}.
    *
-   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link DiskCacheStrategy#DATA} or
-   * {@link DiskCacheStrategy#ALL}. </p>
+   * <p>For most applications {@link DiskCacheStrategy#RESOURCE} is ideal. Applications that use the
+   * same resource multiple times in multiple sizes and are willing to trade off some speed and disk
+   * space in return for lower bandwidth usage may want to consider using {@link
+   * DiskCacheStrategy#DATA} or {@link DiskCacheStrategy#ALL}.
    *
    * @param strategy The strategy to use.
    * @return This request builder.
@@ -275,8 +263,8 @@ public T placeholder(@Nullable Drawable drawable) {
   }
 
   /**
-   * Sets an Android resource id for a {@link Drawable} resource to
-   * display while a resource is loading.
+   * Sets an Android resource id for a {@link Drawable} resource to display while a resource is
+   * loading.
    *
    * <p>Replaces any previous calls to this method or {@link #placeholder(Drawable)}
    *
@@ -300,17 +288,16 @@ public T placeholder(@DrawableRes int resourceId) {
   }
 
   /**
-   * Sets an {@link Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   * Sets an {@link Drawable} to display if the model provided to {@link
+   * com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
    *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * <p>If a fallback is not set, null models will cause the error drawable to be displayed. If the
    * error drawable is not set, the placeholder will be displayed.
    *
    * <p>Replaces any previous calls to this method or {@link #fallback(int)}.
    *
    * @see #placeholder(Drawable)
    * @see #placeholder(int)
-   *
    * @param drawable The drawable to display as a placeholder.
    * @return This request builder.
    */
@@ -331,17 +318,16 @@ public T fallback(@Nullable Drawable drawable) {
   }
 
   /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   * Sets a resource to display if the model provided to {@link
+   * com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
    *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
+   * <p>If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
    *
    * <p>Replaces any previous calls to this method or {@link #fallback(Drawable)}.
    *
    * @see #placeholder(Drawable)
    * @see #placeholder(int)
-   *
    * @param resourceId The id of the resource to use as a fallback.
    * @return This request builder.
    */
@@ -410,18 +396,18 @@ public T error(@DrawableRes int resourceId) {
 
   /**
    * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and {@link
+   * #fallback(Drawable)}.
    *
    * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
    * resource id model on Glide's background threads. The theme is used exclusively on the main
    * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
    *
-   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or
-   * {@link android.app.Activity} used to start this load has a different
-   * {@link android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme}
-   * provided here will override the {@link android.content.res.Resources.Theme} of the
-   * {@link android.content.Context}.
+   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or {@link
+   * android.app.Activity} used to start this load has a different {@link
+   * android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme} provided
+   * here will override the {@link android.content.res.Resources.Theme} of the {@link
+   * android.content.Context}.
    *
    * @param theme The theme to use when loading Drawables.
    * @return this request builder.
@@ -442,8 +428,8 @@ public T theme(@Nullable Resources.Theme theme) {
   /**
    * Allows the loaded resource to skip the memory cache.
    *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   * <p>Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.
    *
    * @param skip True to allow the resource to skip the memory cache.
    * @return This request builder.
@@ -466,7 +452,7 @@ public T skipMemoryCache(boolean skip) {
    * given values. This is useful for thumbnails, and should only be used for other cases when you
    * need a very specific image size.
    *
-   * @param width  The width in pixels to use to load the resource.
+   * @param width The width in pixels to use to load the resource.
    * @param height The height in pixels to use to load the resource.
    * @return This request builder.
    */
@@ -502,10 +488,10 @@ public T override(int size) {
    * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
    * more control over when cached data is invalidated.
    *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   * <p>Note - The signature does not replace the cache key, it is purely additive.
    *
-   * @param signature A unique non-null {@link Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
+   * @param signature A unique non-null {@link Key} representing the current state of the model that
+   *     will be mixed in to the cache key.
    * @return This request builder.
    * @see com.bumptech.glide.signature.ObjectKey
    */
@@ -524,20 +510,20 @@ public T signature(@NonNull Key signature) {
   /**
    * Returns a copy of this request builder with all of the options put so far on this builder.
    *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * <p>This method returns a "deep" copy in that all non-immutable arguments are copied such that
    * changes to one builder will not affect the other builder. However, in addition to immutable
    * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
+   * builders.
    *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
+   * <p>Even if this object was locked, the cloned object returned from this method will not be
+   * locked.
    */
   @SuppressWarnings({
-      "unchecked",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException",
-      // The types we're using here do this automatically.
-      "PMD.CloneMethodReturnTypeMustMatchClassName"
+    "unchecked",
+    // we don't want to throw to be user friendly
+    "PMD.CloneThrowsCloneNotSupportedException",
+    // The types we're using here do this automatically.
+    "PMD.CloneMethodReturnTypeMustMatchClassName"
   })
   @CheckResult
   @Override
@@ -594,8 +580,8 @@ public final boolean isLocked() {
   }
 
   /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   * Sets the value for key {@link
+   * com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
    */
   @NonNull
   @CheckResult
@@ -603,10 +589,7 @@ public T encodeFormat(@NonNull Bitmap.CompressFormat format) {
     return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
   }
 
-  /**
-   * Sets the value for key
-   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
-   */
+  /** Sets the value for key {@link BitmapEncoder#COMPRESSION_QUALITY}. */
   @NonNull
   @CheckResult
   public T encodeQuality(@IntRange(from = 0, to = 100) int quality) {
@@ -616,12 +599,12 @@ public T encodeQuality(@IntRange(from = 0, to = 100) int quality) {
   /**
    * Sets the time position of the frame to extract from a video.
    *
-   * <p>This is a component option specific to {@link VideoDecoder}. If the default video
-   * decoder is replaced or skipped because of your configuration, this option may be ignored.
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video decoder is
+   * replaced or skipped because of your configuration, this option may be ignored.
    *
    * @see VideoDecoder#TARGET_FRAME
    * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
+   *     Android framework implementation return a representative frame.
    */
   @NonNull
   @CheckResult
@@ -630,23 +613,22 @@ public T frame(@IntRange(from = 0) long frameTimeMicros) {
   }
 
   /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler} and Glide's default GIF decoders.
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using {@link
+   * Downsampler} and Glide's default GIF decoders.
    *
    * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
-   * image has alpha).
+   * decoded using a decoder that cannot control the format ({@link
+   * android.media.MediaMetadataRetriever} for example), or that the decoder may choose to ignore
+   * the requested format if it can't display the image (i.e. RGB_565 is requested, but the image
+   * has alpha).
    *
    * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
    * default Bitmap decoders are replaced or skipped because of your configuration, this option may
    * be ignored.
    *
-   * <p>To set only the format used when decoding {@link Bitmap}s, use
-   * {@link #set(Option, Object)}} and {@link Downsampler#DECODE_FORMAT}. To set only the format
-   * used when decoding GIF frames, use {@link #set(Option, Object)} and
-   * {@link GifOptions#DECODE_FORMAT}.
+   * <p>To set only the format used when decoding {@link Bitmap}s, use {@link #set(Option, Object)}}
+   * and {@link Downsampler#DECODE_FORMAT}. To set only the format used when decoding GIF frames,
+   * use {@link #set(Option, Object)} and {@link GifOptions#DECODE_FORMAT}.
    *
    * @see Downsampler#DECODE_FORMAT
    * @see GifOptions#DECODE_FORMAT
@@ -655,8 +637,7 @@ public T frame(@IntRange(from = 0) long frameTimeMicros) {
   @CheckResult
   public T format(@NonNull DecodeFormat format) {
     Preconditions.checkNotNull(format);
-    return set(Downsampler.DECODE_FORMAT, format)
-        .set(GifOptions.DECODE_FORMAT, format);
+    return set(Downsampler.DECODE_FORMAT, format).set(GifOptions.DECODE_FORMAT, format);
   }
 
   /**
@@ -665,16 +646,16 @@ public T format(@NonNull DecodeFormat format) {
    * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
    *
    * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
-   * we only provide a way to disable hardware configs entirely. If no option is set for
-   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on
-   * whether or not a {@link Transformation} is applied and if one is, the type of
-   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and
-   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use
-   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by
-   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that
-   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because
-   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
-   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
+   * we only provide a way to disable hardware configs entirely. If no option is set for {@link
+   * Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on whether or
+   * not a {@link Transformation} is applied and if one is, the type of {@link Transformation}
+   * applied. Built in transformations like {@link FitCenter} and {@link
+   * com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use {@link
+   * android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by scaling
+   * within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that can't be
+   * replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because {@link
+   * android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to {@link android.graphics.Canvas}s,
+   * which is required by most {@link Transformation}s.
    */
   @NonNull
   @CheckResult
@@ -683,8 +664,8 @@ public T disallowHardwareConfig() {
   }
 
   /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using {@link
+   * Downsampler}.
    *
    * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
    * is replaced or skipped because of your configuration, this option may be ignored.
@@ -698,10 +679,9 @@ public T downsample(@NonNull DownsampleStrategy strategy) {
   /**
    * Sets the read and write timeout for the http requests used to load the image.
    *
-   * <p>This is a component option specific to Glide's default networking library and
-   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
-   * networking library including Glide's Volley or OkHttp integration libraries, this option will
-   * be ignored.
+   * <p>This is a component option specific to Glide's default networking library and {@link
+   * com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other networking
+   * library including Glide's Volley or OkHttp integration libraries, this option will be ignored.
    *
    * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
    * @param timeoutMs The read and write timeout in milliseconds.
@@ -728,8 +708,8 @@ public T optionalCenterCrop() {
   }
 
   /**
-   * Applies {@link CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
+   * Applies {@link CenterCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
    *
    * <p>this will override previous calls to {@link #dontTransform()} ()}.
    *
@@ -743,12 +723,11 @@ public T centerCrop() {
   }
 
   /**
-   *
    * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
    * image types, and ignores unknown types.
    *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
    *
    * @see #optionalTransform(Class, Transformation)
    * @see #fitCenter()
@@ -761,11 +740,10 @@ public T optionalFitCenter() {
 
   /**
    * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
-   * image types, and throws an exception if asked to transform an unknown
-   * type.
+   * image types, and throws an exception if asked to transform an unknown type.
    *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
    *
    * @see #transform(Class, Transformation)
    * @see #optionalFitCenter()
@@ -780,8 +758,8 @@ public T fitCenter() {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
    * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
    *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
    *
    * @see #optionalTransform(Class, Transformation)
    * @see #centerInside()
@@ -796,8 +774,8 @@ public T optionalCenterInside() {
    * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
    * image types and throws an exception if asked to transform an unknown type.
    *
-   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
-   * {@link #downsample(DownsampleStrategy)}.
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to {@link
+   * #downsample(DownsampleStrategy)}.
    *
    * @see #transform(Class, Transformation)
    * @see #optionalCenterInside()
@@ -841,7 +819,8 @@ public T circleCrop() {
   // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings({"WeakerAccess", "CheckResult"})
   @NonNull
-  final T optionalTransform(@NonNull DownsampleStrategy downsampleStrategy,
+  final T optionalTransform(
+      @NonNull DownsampleStrategy downsampleStrategy,
       @NonNull Transformation<Bitmap> transformation) {
     if (isAutoCloneEnabled) {
       return clone().optionalTransform(downsampleStrategy, transformation);
@@ -856,7 +835,8 @@ final T optionalTransform(@NonNull DownsampleStrategy downsampleStrategy,
   @SuppressWarnings({"WeakerAccess", "CheckResult"})
   @NonNull
   @CheckResult
-  final T transform(@NonNull DownsampleStrategy downsampleStrategy,
+  final T transform(
+      @NonNull DownsampleStrategy downsampleStrategy,
       @NonNull Transformation<Bitmap> transformation) {
     if (isAutoCloneEnabled) {
       return clone().transform(downsampleStrategy, transformation);
@@ -885,18 +865,19 @@ private T scaleOnlyTransform(
       @NonNull DownsampleStrategy strategy,
       @NonNull Transformation<Bitmap> transformation,
       boolean isTransformationRequired) {
-    BaseRequestOptions<T> result = isTransformationRequired
-          ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
+    BaseRequestOptions<T> result =
+        isTransformationRequired
+            ? transform(strategy, transformation)
+            : optionalTransform(strategy, transformation);
     result.isScaleOnlyOrNoTransform = true;
     return (T) result;
   }
 
   /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
+   * Applies the given {@link Transformation} for {@link Bitmap Bitmaps} to the default types
+   * ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
@@ -913,11 +894,10 @@ public T transform(@NonNull Transformation<Bitmap> transformation) {
   }
 
   /**
-   * Applies the given {@link Transformation}s in the given order for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
+   * Applies the given {@link Transformation}s in the given order for {@link Bitmap Bitmaps} to the
+   * default types ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
@@ -940,15 +920,13 @@ public T transform(@NonNull Transformation<Bitmap>... transformations) {
   }
 
   /**
-   * Applies the given {@link Transformation}s in the given order for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
+   * Applies the given {@link Transformation}s in the given order for {@link Bitmap Bitmaps} to the
+   * default types ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and throws an exception if asked to
+   * transform an unknown type.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
-   *
    * @deprecated Deprecated due to api update, use {@link #transform(Transformation[])} instead
    * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
    * @see #optionalTransform(Transformation)
@@ -964,10 +942,9 @@ public T transforms(@NonNull Transformation<Bitmap>... transformations) {
   }
 
   /**
-   * Applies the given {@link Transformation} for
-   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   * Applies the given {@link Transformation} for {@link Bitmap Bitmaps} to the default types
+   * ({@link Bitmap}, {@link android.graphics.drawable.BitmapDrawable}, and {@link
+   * com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
@@ -984,8 +961,7 @@ public T optionalTransform(@NonNull Transformation<Bitmap> transformation) {
   }
 
   @NonNull
-  T transform(
-      @NonNull Transformation<Bitmap> transformation, boolean isRequired) {
+  T transform(@NonNull Transformation<Bitmap> transformation, boolean isRequired) {
     if (isAutoCloneEnabled) {
       return clone().transform(transformation, isRequired);
     }
@@ -1004,20 +980,20 @@ T transform(
   }
 
   /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
+   * Applies the given {@link Transformation} for any decoded resource of the given type and allows
+   * unknown resource types to be ignored.
    *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link Transformation} for a resource type that already has a
-   * {@link Transformation} will override the previous call. </p>
+   * <p>Users can apply different transformations for each resource class. Applying a {@link
+   * Transformation} for a resource type that already has a {@link Transformation} will override the
+   * previous call.
    *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
+   * <p>If any calls are made to the non-optional transform methods, then attempting to transform an
+   * unknown resource class will throw an exception. To allow unknown types, users must always call
+   * the optional version of each method.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
-   * @param resourceClass  The type of resource to transform.
+   * @param resourceClass The type of resource to transform.
    * @param transformation The {@link Transformation} to apply.
    */
   @NonNull
@@ -1053,12 +1029,12 @@ T transform(
   }
 
   /**
-   * Applies the given {@link Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
+   * Applies the given {@link Transformation} for any decoded resource of the given type and throws
+   * if asked to transform an unknown resource type.
    *
    * <p>This will override previous calls to {@link #dontTransform()}.
    *
-   * @param resourceClass  The type of resource to transform.
+   * @param resourceClass The type of resource to transform.
    * @param transformation The {@link Transformation} to apply.
    * @see #optionalTransform(Class, Transformation)
    */
@@ -1072,9 +1048,8 @@ T transform(
   }
 
   /**
-   * Removes all applied {@link Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
+   * Removes all applied {@link Transformation Transformations} for all resource classes and allows
+   * unknown resource types to be transformed without throwing an exception.
    */
   @NonNull
   @CheckResult
@@ -1097,8 +1072,8 @@ public T dontTransform() {
    * Disables resource decoders that return animated resources so any resource returned will be
    * static.
    *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   * <p>To disable transitions (fades etc) use {@link
+   * com.bumptech.glide.TransitionOptions#dontTransition()}
    */
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
@@ -1109,19 +1084,18 @@ public T dontAnimate() {
   }
 
   /**
-   * Updates this options set with any options that are explicitly set in the given
-   * {@code T} object and returns this object if {@link #autoClone()} is disabled or
-   * a new {@code T} object if {@link #autoClone()} is enabled.
-   *
-   * <p>{@code #apply} only replaces those values that are explicitly set in the given
-   * {@code T}. If you need to completely reset all previously set options, create a
-   * new {@code T} object instead of using this method.
-   *
-   * <p>The options that will be set to values in the returned {@code T} object is the
-   * intersection of the set of options in this {@code T} object and the given
-   * {@code T} object that were explicitly set. If the values of any of the options
-   * conflict, the values in the returned {@code T} object will be set to those in the
-   * given {@code T} object.
+   * Updates this options set with any options that are explicitly set in the given {@code T} object
+   * and returns this object if {@link #autoClone()} is disabled or a new {@code T} object if {@link
+   * #autoClone()} is enabled.
+   *
+   * <p>{@code #apply} only replaces those values that are explicitly set in the given {@code T}. If
+   * you need to completely reset all previously set options, create a new {@code T} object instead
+   * of using this method.
+   *
+   * <p>The options that will be set to values in the returned {@code T} object is the intersection
+   * of the set of options in this {@code T} object and the given {@code T} object that were
+   * explicitly set. If the values of any of the options conflict, the values in the returned {@code
+   * T} object will be set to those in the given {@code T} object.
    */
   @NonNull
   @CheckResult
@@ -1221,7 +1195,6 @@ public T apply(@NonNull BaseRequestOptions<?> o) {
     return selfOrThrowIfLocked();
   }
 
-
   @Override
   public boolean equals(Object o) {
     if (o instanceof BaseRequestOptions<?>) {
@@ -1280,7 +1253,7 @@ public int hashCode() {
   /**
    * Throws if any further mutations are attempted.
    *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   * <p>Once locked, the only way to unlock is to use {@link #clone()}
    */
   @NonNull
   @SuppressWarnings("unchecked")
@@ -1295,14 +1268,14 @@ public T lock() {
    * before the mutation resulting in all methods returning a new Object and leaving the original
    * locked object unmodified.
    *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects are
+   * mutable and are not locked.
    */
   @NonNull
   public T autoClone() {
     if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
+      throw new IllegalStateException(
+          "You cannot auto lock an already locked options object" + ", try clone() first");
     }
     isAutoCloneEnabled = true;
     return lock();
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index 93b662d8f..e89d6e8d6 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -6,11 +6,9 @@
  * Runs a single primary {@link Request} until it completes and then a fallback error request only
  * if the single primary request fails.
  */
-public final class ErrorRequestCoordinator implements RequestCoordinator,
-    Request {
+public final class ErrorRequestCoordinator implements RequestCoordinator, Request {
 
-  @Nullable
-  private final RequestCoordinator parent;
+  @Nullable private final RequestCoordinator parent;
   private Request primary;
   private Request error;
 
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index 063b96dd8..ace71ad6a 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -6,8 +6,8 @@
 /**
  * An interface for an object that is both a {@link com.bumptech.glide.request.target.Target} and a
  * {@link java.util.concurrent.Future}. For example:
- * <pre>
- * {@code
+ *
+ * <pre>{@code
  * FutureTarget<Bitmap> futureTarget = Glide.with(fragment)
  *                                       .load("http://goo.gl/1asf12")
  *                                       .asBitmap()
@@ -15,13 +15,11 @@
  * Bitmap myBitmap = futureTarget.get();
  * ... // do things with bitmap and then release when finished:
  * futureTarget.cancel(false);
- * }
- * </pre>
+ * }</pre>
  *
- * <p> Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called
- * off of the main thread or they will block forever. </p>
+ * <p>Note - {@link #get()} and {@link #get(long, java.util.concurrent.TimeUnit)} must be called off
+ * of the main thread or they will block forever.
  *
  * @param <R> The type of resource this FutureTarget will retrieve.
  */
-public interface FutureTarget<R> extends Future<R>, Target<R> {
-}
+public interface FutureTarget<R> extends Future<R>, Target<R> {}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index f60198184..ac08ed719 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -1,13 +1,9 @@
 package com.bumptech.glide.request;
 
-/**
- * A request that loads a resource for an {@link com.bumptech.glide.request.target.Target}.
- */
+/** A request that loads a resource for an {@link com.bumptech.glide.request.target.Target}. */
 public interface Request {
 
-  /**
-   * Starts an asynchronous load.
-   */
+  /** Starts an asynchronous load. */
   void begin();
 
   /**
@@ -17,14 +13,10 @@
    */
   void clear();
 
-  /**
-   * Returns true if this request is running and has not completed or failed.
-   */
+  /** Returns true if this request is running and has not completed or failed. */
   boolean isRunning();
 
-  /**
-   * Returns true if the request has completed successfully.
-   */
+  /** Returns true if the request has completed successfully. */
   boolean isComplete();
 
   /**
@@ -33,19 +25,13 @@
    */
   boolean isResourceSet();
 
-  /**
-   * Returns true if the request has been cleared.
-   */
+  /** Returns true if the request has been cleared. */
   boolean isCleared();
 
-  /**
-   * Returns true if the request has failed.
-   */
+  /** Returns true if the request has failed. */
   boolean isFailed();
 
-  /**
-   * Recycles the request object and releases its resources.
-   */
+  /** Recycles the request object and releases its resources. */
   void recycle();
 
   /**
@@ -55,10 +41,10 @@
    * <p>This method is identical to {@link Object#equals(Object)} except that it's specific to
    * {@link Request} subclasses. We do not use {@link Object#equals(Object)} directly because we
    * track {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate
-   * to have two different {@link Request} objects for two different
-   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
-   * method let's us selectively compare {@link Request} objects to each other when it's useful in
-   * specific scenarios.
+   * to have two different {@link Request} objects for two different {@link
+   * com.bumptech.glide.request.target.Target}s (for example). Using a similar but different method
+   * let's us selectively compare {@link Request} objects to each other when it's useful in specific
+   * scenarios.
    */
   boolean isEquivalentTo(Request other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 4aa69b394..8a13b53f9 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -21,8 +21,8 @@
   boolean canNotifyStatusChanged(Request request);
 
   /**
-   * Returns {@code true} if the {@link Request} can clear the
-   * {@link com.bumptech.glide.request.target.Target}.
+   * Returns {@code true} if the {@link Request} can clear the {@link
+   * com.bumptech.glide.request.target.Target}.
    */
   boolean canNotifyCleared(Request request);
 
@@ -33,9 +33,7 @@
    */
   boolean isAnyResourceSet();
 
-  /**
-   * Must be called when a {@link Request} coordinated by this object completes successfully.
-   */
+  /** Must be called when a {@link Request} coordinated by this object completes successfully. */
   void onRequestSuccess(Request request);
 
   /** Must be called when a {@link Request} coordinated by this object fails. */
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 5289da076..93de3f923 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -24,26 +24,24 @@
  * of reusing objects of this class, the pattern should be:
  *
  * <pre>{@code
- *  FutureTarget<File> target = null;
- *  RequestManager requestManager = Glide.with(context);
- *  try {
- *    target = requestManager
- *       .downloadOnly()
- *       .load(model)
- *       .submit();
- *    File downloadedFile = target.get();
- *    // ... do something with the file (usually throws IOException)
- *  } catch (ExecutionException | InterruptedException | IOException e) {
- *    // ... bug reporting or recovery
- *  } finally {
- *    // make sure to cancel pending operations and free resources
- *    if (target != null) {
- *      target.cancel(true); // mayInterruptIfRunning
- *    }
- *  }
+ * FutureTarget<File> target = null;
+ * RequestManager requestManager = Glide.with(context);
+ * try {
+ *   target = requestManager
+ *      .downloadOnly()
+ *      .load(model)
+ *      .submit();
+ *   File downloadedFile = target.get();
+ *   // ... do something with the file (usually throws IOException)
+ * } catch (ExecutionException | InterruptedException | IOException e) {
+ *   // ... bug reporting or recovery
+ * } finally {
+ *   // make sure to cancel pending operations and free resources
+ *   if (target != null) {
+ *     target.cancel(true); // mayInterruptIfRunning
+ *   }
  * }
- *
- * </pre>
+ * }</pre>
  *
  * The {@link #cancel(boolean)} call will cancel pending operations and make sure that any resources
  * used are recycled.
@@ -117,9 +115,7 @@ public R get(long time, @NonNull TimeUnit timeUnit)
     return doGet(timeUnit.toMillis(time));
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
   public void getSize(@NonNull SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
@@ -141,36 +137,28 @@ public synchronized Request getRequest() {
     return request;
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
   public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
   public synchronized void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Ignored, synchronized for backwards compatibility.
   }
 
-  /**
-   * A callback that should never be invoked directly.
-   */
+  /** A callback that should never be invoked directly. */
   @Override
-  public synchronized void onResourceReady(@NonNull R resource,
-      @Nullable Transition<? super R> transition) {
+  public synchronized void onResourceReady(
+      @NonNull R resource, @Nullable Transition<? super R> transition) {
     // Ignored, synchronized for backwards compatibility.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index fa6b4721f..0b602edd1 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -11,24 +11,24 @@
 /**
  * A class for monitoring the status of a request while images load.
  *
- * <p>All methods in this interface will be called from a background thread if the
- * {@code RequestListener} is added to a request that is started with
- * {@link RequestBuilder#submit()}, {@link RequestBuilder#submit(int, int)}, or
- * {@link RequestBuilder#into(int, int)}. Those methods no longer post results back to the main
- * thread to avoid the unnecessary thread interactions and corresponding latency. As a side affect
- * though, listeners added to those requests are no longer called on the main thread.
- * {@code RequestListeners} added to requests started with {@link RequestBuilder#into(Target)} or
- * {@link RequestBuilder#into(ImageView)} will continue to be called back on the main thread.
+ * <p>All methods in this interface will be called from a background thread if the {@code
+ * RequestListener} is added to a request that is started with {@link RequestBuilder#submit()},
+ * {@link RequestBuilder#submit(int, int)}, or {@link RequestBuilder#into(int, int)}. Those methods
+ * no longer post results back to the main thread to avoid the unnecessary thread interactions and
+ * corresponding latency. As a side affect though, listeners added to those requests are no longer
+ * called on the main thread. {@code RequestListeners} added to requests started with {@link
+ * RequestBuilder#into(Target)} or {@link RequestBuilder#into(ImageView)} will continue to be called
+ * back on the main thread.
  *
  * @param <R> The type of resource being loaded.
  */
 public interface RequestListener<R> {
 
   /**
-   * Called when an exception occurs during a load, immediately before
-   * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
-   * image for the given model in the given target. It is recommended to create a single instance
-   * per activity/fragment rather than instantiate a new object for each call to {@code
+   * Called when an exception occurs during a load, immediately before {@link
+   * Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an image
+   * for the given model in the given target. It is recommended to create a single instance per
+   * activity/fragment rather than instantiate a new object for each call to {@code
    * Glide.with(fragment/activity).load()} to avoid object churn.
    *
    * <p>It is not safe to reload this or a different model in this callback. If you need to do so
@@ -40,27 +40,23 @@
    *
    * <p>For threading guarantees, see the class comment.
    *
-   * For example:
-   * <pre>
-   * {@code
+   * <p>For example:
+   *
+   * <pre>{@code
    * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
    *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
    *     return true; // Prevent onLoadFailed from being called on the Target.
    * }
-   * }
-   * </pre>
-   * </p>
-   *
+   * }</pre>
    *
-   * @param e               The maybe {@code null} exception containing information about why the
-   *                        request failed.
-   * @param model           The model we were trying to load when the exception occurred.
-   * @param target          The {@link Target} we were trying to load the image into.
+   * @param e The maybe {@code null} exception containing information about why the request failed.
+   * @param model The model we were trying to load when the exception occurred.
+   * @param target The {@link Target} we were trying to load the image into.
    * @param isFirstResource {@code true} if this exception is for the first resource to load.
    * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
-   * {@code target}, typically because the listener wants to update the {@code target} or the object
-   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
-   * to be called on {@code target}.
+   *     {@code target}, typically because the listener wants to update the {@code target} or the
+   *     object the {@code target} wraps itself or {@code false} to allow {@link
+   *     Target#onLoadFailed(Drawable)} to be called on {@code target}.
    */
   boolean onLoadFailed(
       @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 8a255d412..b9a2c09cb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -25,27 +25,16 @@
 @SuppressWarnings("PMD.UseUtilityClass")
 public class RequestOptions extends BaseRequestOptions<RequestOptions> {
 
-  @Nullable
-  private static RequestOptions skipMemoryCacheTrueOptions;
-  @Nullable
-  private static RequestOptions skipMemoryCacheFalseOptions;
-  @Nullable
-  private static RequestOptions fitCenterOptions;
-  @Nullable
-  private static RequestOptions centerInsideOptions;
-  @Nullable
-  private static RequestOptions centerCropOptions;
-  @Nullable
-  private static RequestOptions circleCropOptions;
-  @Nullable
-  private static RequestOptions noTransformOptions;
-  @Nullable
-  private static RequestOptions noAnimationOptions;
+  @Nullable private static RequestOptions skipMemoryCacheTrueOptions;
+  @Nullable private static RequestOptions skipMemoryCacheFalseOptions;
+  @Nullable private static RequestOptions fitCenterOptions;
+  @Nullable private static RequestOptions centerInsideOptions;
+  @Nullable private static RequestOptions centerCropOptions;
+  @Nullable private static RequestOptions circleCropOptions;
+  @Nullable private static RequestOptions noTransformOptions;
+  @Nullable private static RequestOptions noAnimationOptions;
 
-
-  /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -74,45 +63,35 @@ public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #placeholder(int)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #error(Drawable)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #error(int)}} set. */
   @NonNull
   @CheckResult
   public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
@@ -129,9 +108,7 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     }
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #override(int, int)}} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -150,77 +127,57 @@ public static RequestOptions overrideOf(int size) {
     return overrideOf(size, size);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #signature} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #signature} set. */
   @NonNull
   @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #fitCenter()} set. */
   @NonNull
   @CheckResult
   public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
-      fitCenterOptions = new RequestOptions()
-          .fitCenter()
-          .autoClone();
+      fitCenterOptions = new RequestOptions().fitCenter().autoClone();
     }
     return fitCenterOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #centerInside()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
   public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
-      centerInsideOptions = new RequestOptions()
-              .centerInside()
-              .autoClone();
+      centerInsideOptions = new RequestOptions().centerInside().autoClone();
     }
     return centerInsideOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #centerCrop()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
   public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
-      centerCropOptions = new RequestOptions()
-          .centerCrop()
-          .autoClone();
+      centerCropOptions = new RequestOptions().centerCrop().autoClone();
     }
     return centerCropOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
   public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
-      circleCropOptions = new RequestOptions()
-          .circleCrop()
-          .autoClone();
+      circleCropOptions = new RequestOptions().circleCrop().autoClone();
     }
     return circleCropOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -228,24 +185,20 @@ public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> tra
     return new RequestOptions().transform(transformation);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #dontTransform()} set. */
   @SuppressWarnings("WeakerAccess")
   @NonNull
   @CheckResult
   public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
-      noTransformOptions = new RequestOptions()
-          .dontTransform()
-          .autoClone();
+      noTransformOptions = new RequestOptions().dontTransform().autoClone();
     }
     return noTransformOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with the given {@link Option} set via
-   * {@link #set(Option, Object)}.
+   * Returns a {@link RequestOptions} object with the given {@link Option} set via {@link
+   * #set(Option, Object)}.
    */
   @NonNull
   @CheckResult
@@ -253,18 +206,14 @@ public static RequestOptions noTransformation() {
     return new RequestOptions().set(option, value);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #decode(Class)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -272,9 +221,7 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #frame(long)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -282,9 +229,7 @@ public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set. */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   @CheckResult
@@ -292,9 +237,7 @@ public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy)
     return new RequestOptions().downsample(strategy);
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
-   */
+  /** Returns a {@link RequestOptions} object with {@link #timeout(int)} set. */
   @NonNull
   @CheckResult
   public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
@@ -302,8 +245,8 @@ public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
   }
 
   /**
-   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
-   * #encodeQuality(int)} called with the given quality.
+   * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link #encodeQuality(int)}
+   * called with the given quality.
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
@@ -332,11 +275,8 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
   @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
-      noAnimationOptions = new RequestOptions()
-          .dontAnimate()
-          .autoClone();
+      noAnimationOptions = new RequestOptions().dontAnimate().autoClone();
     }
     return noAnimationOptions;
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 03d3b34cc..4822609f7 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -34,64 +34,51 @@
  *
  * @param <R> The type of the resource that will be transcoded from the loaded resource.
  */
-public final class SingleRequest<R> implements Request,
-    SizeReadyCallback,
-    ResourceCallback,
-    FactoryPools.Poolable {
+public final class SingleRequest<R>
+    implements Request, SizeReadyCallback, ResourceCallback, FactoryPools.Poolable {
   /** Tag for logging internal events, not generally suitable for public use. */
   private static final String TAG = "Request";
   /** Tag for logging externally useful events (request completion, timing etc). */
   private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.threadSafe(150,
-      new FactoryPools.Factory<SingleRequest<?>>() {
-        @Override
-        public SingleRequest<?> create() {
-          return new SingleRequest<Object>();
-        }
-      });
+
+  private static final Pools.Pool<SingleRequest<?>> POOL =
+      FactoryPools.threadSafe(
+          150,
+          new FactoryPools.Factory<SingleRequest<?>>() {
+            @Override
+            public SingleRequest<?> create() {
+              return new SingleRequest<Object>();
+            }
+          });
   private boolean isCallingCallbacks;
 
-  private static final boolean IS_VERBOSE_LOGGABLE =
-      Log.isLoggable(TAG, Log.VERBOSE);
+  private static final boolean IS_VERBOSE_LOGGABLE = Log.isLoggable(TAG, Log.VERBOSE);
 
   private enum Status {
-    /**
-     * Created but not yet running.
-     */
+    /** Created but not yet running. */
     PENDING,
-    /**
-     * In the process of fetching media.
-     */
+    /** In the process of fetching media. */
     RUNNING,
-    /**
-     * Waiting for a callback given to the Target to be called to determine target dimensions.
-     */
+    /** Waiting for a callback given to the Target to be called to determine target dimensions. */
     WAITING_FOR_SIZE,
-    /**
-     * Finished loading media successfully.
-     */
+    /** Finished loading media successfully. */
     COMPLETE,
-    /**
-     * Failed to load media, may be restarted.
-     */
+    /** Failed to load media, may be restarted. */
     FAILED,
-    /**
-     * Cleared by the user with a placeholder set, may be restarted.
-     */
+    /** Cleared by the user with a placeholder set, may be restarted. */
     CLEARED,
   }
 
   @Nullable
   private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
+
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
-  @Nullable
-  private RequestListener<R> targetListener;
+  @Nullable private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
   private Context context;
   private GlideContext glideContext;
-  @Nullable
-  private Object model;
+  @Nullable private Object model;
   private Class<R> transcodeClass;
   private BaseRequestOptions<?> requestOptions;
   private int overrideWidth;
@@ -105,15 +92,16 @@
   private Resource<R> resource;
   private Engine.LoadStatus loadStatus;
   private long startTime;
+
   @GuardedBy("this")
   private Status status;
+
   private Drawable errorDrawable;
   private Drawable placeholderDrawable;
   private Drawable fallbackDrawable;
   private int width;
   private int height;
-  @Nullable
-  private RuntimeException requestOrigin;
+  @Nullable private RuntimeException requestOrigin;
 
   public static <R> SingleRequest<R> obtain(
       Context context,
@@ -131,8 +119,8 @@
       Engine engine,
       TransitionFactory<? super R> animationFactory,
       Executor callbackExecutor) {
-    @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) POOL.acquire();
+    @SuppressWarnings("unchecked")
+    SingleRequest<R> request = (SingleRequest<R>) POOL.acquire();
     if (request == null) {
       request = new SingleRequest<>();
     }
@@ -285,7 +273,7 @@ public synchronized void begin() {
    * Cancels the current load but does not release any resources held by the request and continues
    * to display the loaded resource if the load completed before the call to cancel.
    *
-   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+   * <p>Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
    *
    * @see #clear()
    */
@@ -302,10 +290,11 @@ private void cancel() {
   // Avoids difficult to understand errors like #2413.
   private void assertNotCallingCallbacks() {
     if (isCallingCallbacks) {
-      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
-          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
-          + " clear() calls to the main thread using a Handler instead.");
+      throw new IllegalStateException(
+          "You can't start or clear loads in RequestListener or"
+              + " Target callbacks. If you're trying to start a fallback request when a load fails,"
+              + " use RequestBuilder#error(RequestBuilder). Otherwise consider posting your into()"
+              + " or clear() calls to the main thread using a Handler instead.");
     }
   }
 
@@ -377,7 +366,7 @@ private Drawable getErrorDrawable() {
   }
 
   private Drawable getPlaceholderDrawable() {
-     if (placeholderDrawable == null) {
+    if (placeholderDrawable == null) {
       placeholderDrawable = requestOptions.getPlaceholderDrawable();
       if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
         placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
@@ -397,8 +386,8 @@ private Drawable getFallbackDrawable() {
   }
 
   private Drawable loadDrawable(@DrawableRes int resourceId) {
-    Theme theme = requestOptions.getTheme() != null
-        ? requestOptions.getTheme() : context.getTheme();
+    Theme theme =
+        requestOptions.getTheme() != null ? requestOptions.getTheme() : context.getTheme();
     return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
@@ -422,9 +411,7 @@ private synchronized void setErrorPlaceholder() {
     target.onLoadFailed(error);
   }
 
-  /**
-   * A callback method that should never be invoked directly.
-   */
+  /** A callback method that should never be invoked directly. */
   @Override
   public synchronized void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
@@ -515,8 +502,12 @@ public synchronized void onResourceReady(Resource<?> resource, DataSource dataSo
     stateVerifier.throwIfRecycled();
     loadStatus = null;
     if (resource == null) {
-      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
-          + "object of " + transcodeClass + " inside, but instead got null.");
+      GlideException exception =
+          new GlideException(
+              "Expected to receive a Resource<R> with an "
+                  + "object of "
+                  + transcodeClass
+                  + " inside, but instead got null.");
       onLoadFailed(exception);
       return;
     }
@@ -524,12 +515,25 @@ public synchronized void onResourceReady(Resource<?> resource, DataSource dataSo
     Object received = resource.get();
     if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
       releaseResource(resource);
-      GlideException exception = new GlideException("Expected to receive an object of "
-          + transcodeClass + " but instead" + " got "
-          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
-          + "Resource{" + resource + "}."
-          + (received != null ? "" : " " + "To indicate failure return a null Resource "
-          + "object, rather than a Resource object containing null data."));
+      GlideException exception =
+          new GlideException(
+              "Expected to receive an object of "
+                  + transcodeClass
+                  + " but instead"
+                  + " got "
+                  + (received != null ? received.getClass() : "")
+                  + "{"
+                  + received
+                  + "} inside"
+                  + " "
+                  + "Resource{"
+                  + resource
+                  + "}."
+                  + (received != null
+                      ? ""
+                      : " "
+                          + "To indicate failure return a null Resource "
+                          + "object, rather than a Resource object containing null data."));
       onLoadFailed(exception);
       return;
     }
@@ -558,9 +562,21 @@ private synchronized void onResourceReady(Resource<R> resource, R result, DataSo
     this.resource = resource;
 
     if (glideContext.getLogLevel() <= Log.DEBUG) {
-      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
-          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
-          + LogTime.getElapsedMillis(startTime) + " ms");
+      Log.d(
+          GLIDE_TAG,
+          "Finished loading "
+              + result.getClass().getSimpleName()
+              + " from "
+              + dataSource
+              + " for "
+              + model
+              + " with size ["
+              + width
+              + "x"
+              + height
+              + "] in "
+              + LogTime.getElapsedMillis(startTime)
+              + " ms");
     }
 
     isCallingCallbacks = true;
@@ -577,8 +593,7 @@ private synchronized void onResourceReady(Resource<R> resource, R result, DataSo
               && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
 
       if (!anyListenerHandledUpdatingTarget) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
+        Transition<? super R> animation = animationFactory.build(dataSource, isFirstResource);
         target.onResourceReady(result, animation);
       }
     } finally {
@@ -610,7 +625,7 @@ private synchronized void onLoadFailed(GlideException e, int maxLogLevel) {
 
     isCallingCallbacks = true;
     try {
-      //TODO: what if this is a thumbnail request?
+      // TODO: what if this is a thumbnail request?
       boolean anyListenerHandledUpdatingTarget = false;
       if (requestListeners != null) {
         for (RequestListener<R> listener : requestListeners) {
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index eaa4ba5a0..ca0ddcc6a 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -7,8 +7,7 @@
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
  * version of an image and the full size version of the image at the same time.
  */
-public class ThumbnailRequestCoordinator implements RequestCoordinator,
-    Request {
+public class ThumbnailRequestCoordinator implements RequestCoordinator, Request {
   @Nullable private final RequestCoordinator parent;
 
   private Request full;
@@ -104,9 +103,7 @@ private boolean parentIsAnyResourceSet() {
     return parent != null && parent.isAnyResourceSet();
   }
 
-  /**
-   * Starts first the thumb request and then the full request.
-   */
+  /** Starts first the thumb request and then the full request. */
   @Override
   public void begin() {
     isRunning = true;
@@ -127,17 +124,13 @@ public void clear() {
     full.clear();
   }
 
-  /**
-   * Returns true if the full request is still running.
-   */
+  /** Returns true if the full request is still running. */
   @Override
   public boolean isRunning() {
     return full.isRunning();
   }
 
-  /**
-   * Returns true if the full request is complete.
-   */
+  /** Returns true if the full request is complete. */
   @Override
   public boolean isComplete() {
     return full.isComplete() || thumb.isComplete();
@@ -153,9 +146,7 @@ public boolean isCleared() {
     return full.isCleared();
   }
 
-  /**
-   * Returns true if the full request has failed.
-   */
+  /** Returns true if the full request has failed. */
   @Override
   public boolean isFailed() {
     return full.isFailed();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index f2e6aa91e..34244989c 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -15,8 +15,8 @@
  * This class is used in order to display downloaded Bitmap inside an ImageView of an AppWidget
  * through RemoteViews.
  *
- * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
- * for every subsequent load. </p>
+ * <p>Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load.
  */
 // Public API.
 @SuppressWarnings("WeakerAccess")
@@ -31,17 +31,22 @@
    * Constructor using an int array of widgetIds to get a handle on the Widget in order to update
    * it.
    *
-   * @param context     Context to use in the AppWidgetManager initialization.
-   * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
-   *                    manually put because of RemoteViews limitations.)
-   * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
-   *                    manually put because of RemoteViews limitations.)
-   * @param viewId      The id of the ImageView view that will load the image.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param height Desired height in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
    * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param widgetIds   The int[] that contains the widget ids of an application.
+   * @param widgetIds The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, int width, int height,
-      int viewId, RemoteViews remoteViews, int... widgetIds) {
+  public AppWidgetTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -58,31 +63,34 @@ public AppWidgetTarget(Context context, int width, int height,
    * Constructor using an int array of widgetIds to get a handle on the Widget in order to update it
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
-   * @param context     Context to use in the AppWidgetManager initialization.
-   * @param viewId      The id of the ImageView view that will load the image.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
    * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param widgetIds   The int[] that contains the widget ids of an application.
+   * @param widgetIds The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context,
-      int viewId, RemoteViews remoteViews, int... widgetIds) {
+  public AppWidgetTarget(Context context, int viewId, RemoteViews remoteViews, int... widgetIds) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
-   * @param context       Context to use in the AppWidgetManager initialization.
-   * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
-   *                      manually put because of RemoteViews limitations.)
-   * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
-   *                      manually put because of RemoteViews limitations.)
-   * @param viewId        The id of the ImageView view that will load the image.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param height Desired height in pixels of the bitmap that will be loaded. (Needs to be manually
+   *     put because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, int width, int height,
-      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+  public AppWidgetTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -97,20 +105,17 @@ public AppWidgetTarget(Context context, int width, int height,
    * Constructor using a ComponentName, when override has been put to get a handle on the Widget in
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
-   * @param context       Context to use in the AppWidgetManager initialization.
-   * @param viewId        The id of the ImageView view that will load the image.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context,
-      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+  public AppWidgetTarget(
+      Context context, int viewId, RemoteViews remoteViews, ComponentName componentName) {
     this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
-  /**
-   * Updates the AppWidget after the ImageView has loaded the Bitmap.
-   */
+  /** Updates the AppWidget after the ImageView has loaded the Bitmap. */
   private void update() {
     AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(this.context);
     if (this.componentName != null) {
@@ -121,8 +126,8 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(@NonNull Bitmap resource,
-      @Nullable Transition<? super Bitmap> transition) {
+  public void onResourceReady(
+      @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
     setBitmap(resource);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index 386a6a1cf..03b7b5fb2 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -14,9 +14,7 @@ public BitmapImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} instead.
-   */
+  /** @deprecated Use {@link #waitForLayout()} instead. */
   // Public API.
   @SuppressWarnings({"unused", "deprecation"})
   @Deprecated
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
index 90b03a62f..683367eb5 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -15,9 +15,7 @@ public BitmapThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} instead.
-   */
+  /** @deprecated Use {@link #waitForLayout()} instead. */
   @SuppressWarnings("deprecation")
   @Deprecated
   public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
index 1939bd5aa..d8c87ce9d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java
@@ -14,12 +14,11 @@
  * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}
  * etc) that are used outside of {@link android.view.View}s.
  *
- * <p>If you're loading a resource into a {@link View}, use
- * {@link com.bumptech.glide.RequestBuilder#into(ImageView)}, a subclass of {@link ImageViewTarget},
- * or {@link CustomViewTarget}. Using this class to load resources into {@link View}s can prevent
- * Glide from correctly cancelling any previous loads, which may result in incorrect images
- * appearing in the view, especially in scrolling views like
- * {@link android.support.v7.widget.RecyclerView}.
+ * <p>If you're loading a resource into a {@link View}, use {@link
+ * com.bumptech.glide.RequestBuilder#into(ImageView)}, a subclass of {@link ImageViewTarget}, or
+ * {@link CustomViewTarget}. Using this class to load resources into {@link View}s can prevent Glide
+ * from correctly cancelling any previous loads, which may result in incorrect images appearing in
+ * the view, especially in scrolling views like {@link android.support.v7.widget.RecyclerView}.
  *
  * <p>You <em>MUST</em> implement {@link #onLoadCleared(Drawable)} and ensure that all references to
  * any resource passed into the target in {@link #onResourceReady(Object, Transition)} are removed
@@ -41,8 +40,7 @@
   private final int width;
   private final int height;
 
-  @Nullable
-  private Request request;
+  @Nullable private Request request;
 
   /**
    * Creates a new {@link CustomTarget} that will attempt to load the resource in its original size.
@@ -58,18 +56,21 @@ public CustomTarget() {
 
   /**
    * Creates a new {@code CustomTarget} that will return the given {@code width} and {@code height}
-   * as the requested size (unless overridden by
-   * {@link com.bumptech.glide.request.RequestOptions#override(int)} in the request).
+   * as the requested size (unless overridden by {@link
+   * com.bumptech.glide.request.RequestOptions#override(int)} in the request).
    *
    * @param width The requested width (> 0, or == Target.SIZE_ORIGINAL).
    * @param height The requested height (> 0, or == Target.SIZE_ORIGINAL).
    * @throws IllegalArgumentException if width/height doesn't meet (> 0, or == Target.SIZE_ORIGINAL)
    */
   public CustomTarget(int width, int height) {
-     if (!Util.isValidDimensions(width, height)) {
+    if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
-          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
-              + width + " and height: " + height);
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given"
+              + " width: "
+              + width
+              + " and height: "
+              + height);
     }
 
     this.width = width;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
index 28aa06465..d6f2a3140 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
@@ -28,14 +28,13 @@
  * etc) into {@link View}s that provides default implementations for most methods and can determine
  * the size of views using a {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
- * @param <T> The specific subclass of view wrapped by this target (e.g.
- *          {@link android.widget.ImageView})
+ * @param <T> The specific subclass of view wrapped by this target (e.g. {@link
+ *     android.widget.ImageView})
  * @param <Z> The resource type this target will receive (e.g. {@link android.graphics.Bitmap}).
  */
 public abstract class CustomViewTarget<T extends View, Z> implements Target<Z> {
   private static final String TAG = "CustomViewTarget";
-  @IdRes private static final int VIEW_TAG_ID =
-      R.id.glide_custom_view_target_tag;
+  @IdRes private static final int VIEW_TAG_ID = R.id.glide_custom_view_target_tag;
 
   private final SizeDeterminer sizeDeterminer;
 
@@ -54,10 +53,9 @@ public CustomViewTarget(@NonNull T view) {
   /**
    * A required callback invoked when the resource is no longer valid and must be freed.
    *
-   * <p>You must ensure that any current Drawable received in
-   * {@link #onResourceReady(Object, Transition)} is no longer used before redrawing the container
-   * (usually a View) or changing its visibility. <b>Not doing so will result in crashes in your
-   * app.</b>
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility. <b>Not doing so will result in crashes in your app.</b>
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -139,17 +137,18 @@ public void onDestroy() {
     if (attachStateListener != null) {
       return this;
     }
-    attachStateListener = new OnAttachStateChangeListener() {
-      @Override
-      public void onViewAttachedToWindow(View v) {
-        resumeMyRequest();
-      }
-
-      @Override
-      public void onViewDetachedFromWindow(View v) {
-        pauseMyRequest();
-      }
-    };
+    attachStateListener =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            resumeMyRequest();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            pauseMyRequest();
+          }
+        };
     maybeAddAttachStateListener();
     return this;
   }
@@ -296,9 +295,7 @@ private void maybeRemoveAttachStateListener() {
   static final class SizeDeterminer {
     // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
-    @VisibleForTesting
-    @Nullable
-    static Integer maxDisplayLength;
+    @VisibleForTesting @Nullable static Integer maxDisplayLength;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
     @Synthetic boolean waitForLayout;
@@ -452,12 +449,14 @@ private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
       // layout to complete before using this fallback parameter (ConstraintLayout among others).
       if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
         if (Log.isLoggable(TAG, Log.INFO)) {
-          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
-              + " this device's screen dimensions. If you want to load the original image and are"
-              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
-              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
-              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
-              + " dimensions.");
+          Log.i(
+              TAG,
+              "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+                  + " this device's screen dimensions. If you want to load the original image and"
+                  + " are ok with the corresponding memory cost and OOMs (depending on the input"
+                  + " size), use .override(Target.SIZE_ORIGINAL). Otherwise, use"
+                  + " LayoutParams.MATCH_PARENT, set layout_width and layout_height to fixed"
+                  + " dimension, or use .override() with fixed dimensions.");
         }
         return getMaxDisplayLength(view.getContext());
       }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index ca9c6528d..4b4eddd41 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -4,18 +4,14 @@
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
 
-/**
- * A target for display {@link Drawable} objects in {@link ImageView}s.
- */
+/** A target for display {@link Drawable} objects in {@link ImageView}s. */
 public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {
 
   public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} instead.
-   */
+  /** @deprecated Use {@link #waitForLayout()} instead. */
   // Public API.
   @SuppressWarnings({"unused", "deprecation"})
   @Deprecated
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
index 40ff2dad4..41951dcc9 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -13,9 +13,7 @@ public DrawableThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} instead.
-   */
+  /** @deprecated Use {@link #waitForLayout()} instead. */
   @Deprecated
   @SuppressWarnings("deprecation")
   public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 6f270b9a6..bde6bcede 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -12,23 +12,20 @@
  * android.widget.ImageView}s.
  *
  * @param <Z> The type of resource that this target will display in the wrapped {@link
- *            android.widget.ImageView}.
+ *     android.widget.ImageView}.
  */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
-  @Nullable
-  private Animatable animatable;
+  @Nullable private Animatable animatable;
 
   public ImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} instead.
-   */
+  /** @deprecated Use {@link #waitForLayout()} instead. */
   @SuppressWarnings({"deprecation"})
   @Deprecated
   public ImageViewTarget(ImageView view, boolean waitForLayout) {
@@ -139,4 +136,3 @@ private void maybeUpdateAnimatable(@Nullable Z resource) {
 
   protected abstract void setResource(@Nullable Z resource);
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 2e91ac594..5c4b10526 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -6,14 +6,14 @@
 import android.widget.ImageView;
 
 /**
- * A factory responsible for producing the correct type of
- * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
+ * A factory responsible for producing the correct type of {@link
+ * com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
   @NonNull
   @SuppressWarnings("unchecked")
-  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
-      @NonNull Class<Z> clazz) {
+  public <Z> ViewTarget<ImageView, Z> buildTarget(
+      @NonNull ImageView view, @NonNull Class<Z> clazz) {
     if (Bitmap.class.equals(clazz)) {
       return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
     } else if (Drawable.class.isAssignableFrom(clazz)) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index de968de48..a9686c604 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.request.target;
 
-
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.content.Context;
@@ -16,8 +15,8 @@
  * This class is used to display downloaded Bitmap inside an ImageView of a Notification through
  * RemoteViews.
  *
- * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
- * for every subsequent load. </p>
+ * <p>Note - For cancellation to work correctly, you must pass in the same instance of this class
+ * for every subsequent load.
  */
 // Public API.
 @SuppressWarnings({"WeakerAccess", "unused"})
@@ -34,35 +33,49 @@
    * Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target width and
    * height.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param notification   The Notification object that we want to update.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
    * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context,
-      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+  public NotificationTarget(
+      Context context,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId) {
     this(context, viewId, remoteViews, notification, notificationId, null);
   }
 
   /**
    * Constructor using a Notification object, a notificationId, and a notificationTag to get a
-   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the
-   * target width and height.
+   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the target
+   * width and height.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
-   *                        May be {@code null}.
+   *     May be {@code null}.
    */
-  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
-      Notification notification, int notificationId, String notificationTag) {
-    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
+  public NotificationTarget(
+      Context context,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId,
+      String notificationTag) {
+    this(
+        context,
+        SIZE_ORIGINAL,
+        SIZE_ORIGINAL,
+        viewId,
+        remoteViews,
+        notification,
+        notificationId,
         notificationTag);
   }
 
@@ -70,21 +83,26 @@ public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
    * Constructor using a Notification object, a notificationId, and a notificationTag to get a
    * handle on the Notification in order to update it.
    *
-   * @param context         Context to use in the AppWidgetManager initialization.
-   * @param width           Desired width of the bitmap that will be loaded.(Need to be manually put
-   *                        because of RemoteViews limitations.)
-   * @param height          Desired height of the bitmap that will be loaded. (Need to be manually
-   *                        put because of RemoteViews limitations.)
-   * @param viewId          The id of the ImageView view that will load the image.
-   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
-   *                        bitmap.
-   * @param notification    The Notification object that we want to update.
-   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
-   * @param notificationTag The notificationTag of the Notification that we want to load the
-   *                        Bitmap. May be {@code null}.
+   * @param context Context to use in the AppWidgetManager initialization.
+   * @param width Desired width of the bitmap that will be loaded.(Need to be manually put because
+   *     of RemoteViews limitations.)
+   * @param height Desired height of the bitmap that will be loaded. (Need to be manually put
+   *     because of RemoteViews limitations.)
+   * @param viewId The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
+   * @param notification The Notification object that we want to update.
+   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
+   *     May be {@code null}.
    */
-  public NotificationTarget(Context context, int width, int height, int viewId,
-      RemoteViews remoteViews, Notification notification, int notificationId,
+  public NotificationTarget(
+      Context context,
+      int width,
+      int height,
+      int viewId,
+      RemoteViews remoteViews,
+      Notification notification,
+      int notificationId,
       String notificationTag) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
@@ -97,9 +115,7 @@ public NotificationTarget(Context context, int width, int height, int viewId,
     this.notificationTag = notificationTag;
   }
 
-  /**
-   * Updates the Notification after the Bitmap resource is loaded.
-   */
+  /** Updates the Notification after the Bitmap resource is loaded. */
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
@@ -108,8 +124,8 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(@NonNull Bitmap resource,
-      @Nullable Transition<? super Bitmap> transition) {
+  public void onResourceReady(
+      @NonNull Bitmap resource, @Nullable Transition<? super Bitmap> transition) {
     setBitmap(resource);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index 32d47160b..29973e0a2 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -19,25 +19,28 @@
  */
 public final class PreloadTarget<Z> extends CustomTarget<Z> {
   private static final int MESSAGE_CLEAR = 1;
-  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {
-    @Override
-    public boolean handleMessage(Message message) {
-      if (message.what == MESSAGE_CLEAR) {
-        ((PreloadTarget<?>) message.obj).clear();
-        return true;
-      }
-      return false;
-    }
-  });
+  private static final Handler HANDLER =
+      new Handler(
+          Looper.getMainLooper(),
+          new Callback() {
+            @Override
+            public boolean handleMessage(Message message) {
+              if (message.what == MESSAGE_CLEAR) {
+                ((PreloadTarget<?>) message.obj).clear();
+                return true;
+              }
+              return false;
+            }
+          });
 
   private final RequestManager requestManager;
 
   /**
    * Returns a PreloadTarget.
    *
-   * @param width  The width in pixels of the desired resource.
+   * @param width The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
-   * @param <Z>    The type of the desired resource.
+   * @param <Z> The type of the desired resource.
    */
   public static <Z> PreloadTarget<Z> obtain(RequestManager requestManager, int width, int height) {
     return new PreloadTarget<>(requestManager, width, height);
@@ -59,7 +62,8 @@ public void onLoadCleared(@Nullable Drawable placeholder) {
   }
 
   @SuppressWarnings("WeakerAccess")
-  @Synthetic void clear() {
+  @Synthetic
+  void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 758680bca..c0755d198 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -61,10 +61,10 @@
  * @param <Z> The type of resource that this target will receive.
  * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
  *     in the background
- *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a
- *     {@link CustomTarget} for any specialized use-cases. Using {@link SimpleTarget} or
- *     {@link BaseTarget} is unsafe if the user does not implement {@link #onLoadCleared}, resulting
- *     in recycled bitmaps being referenced from the UI and hard to root-cause crashes.
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a {@link
+ *     CustomTarget} for any specialized use-cases. Using {@link SimpleTarget} or {@link BaseTarget}
+ *     is unsafe if the user does not implement {@link #onLoadCleared}, resulting in recycled
+ *     bitmaps being referenced from the UI and hard to root-cause crashes.
  */
 @Deprecated
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
@@ -85,7 +85,7 @@ public SimpleTarget() {
    * Constructor for the target that takes the desired dimensions of the decoded and/or transformed
    * resource.
    *
-   * @param width  The width in pixels of the desired resource.
+   * @param width The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
    */
   // Public API.
@@ -104,8 +104,12 @@ public SimpleTarget(int width, int height) {
   public final void getSize(@NonNull SizeReadyCallback cb) {
     if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
-          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
-              + width + " and height: " + height + ", either provide dimensions in the constructor"
+          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given"
+              + " width: "
+              + width
+              + " and height: "
+              + height
+              + ", either provide dimensions in the constructor"
               + " or call override()");
     }
     cb.onSizeReady(width, height);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
index 2ff5b19a2..238ea2aa8 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SizeReadyCallback.java
@@ -8,10 +8,10 @@
   /**
    * A callback called on the main thread.
    *
-   * @param width  The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
-   *               that we want the resource at its original width.
+   * @param width The width in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
+   *     that we want the resource at its original width.
    * @param height The height in pixels of the target, or {@link Target#SIZE_ORIGINAL} to indicate
-   *               that we want the resource at its original height.
+   *     that we want the resource at its original height.
    */
   void onSizeReady(int width, int height);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 502234774..f5a506461 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -11,31 +11,35 @@
  * An interface that Glide can load a resource into and notify of relevant lifecycle events during a
  * load.
  *
- * <p> The lifecycle events in this class are as follows: <ul> <li>onLoadStarted</li>
- * <li>onResourceReady</li> <li>onLoadCleared</li> <li>onLoadFailed</li> </ul>
+ * <p>The lifecycle events in this class are as follows:
+ *
+ * <ul>
+ *   <li>onLoadStarted
+ *   <li>onResourceReady
+ *   <li>onLoadCleared
+ *   <li>onLoadFailed
+ * </ul>
  *
  * The typical lifecycle is onLoadStarted -> onResourceReady or onLoadFailed -> onLoadCleared.
  * However, there are no guarantees. onLoadStarted may not be called if the resource is in memory or
  * if the load will fail because of a null model object. onLoadCleared similarly may never be called
- * if the target is never cleared. See the docs for the individual methods for details. </p>
+ * if the target is never cleared. See the docs for the individual methods for details.
  *
  * @param <R> The type of resource the target can display.
  */
 public interface Target<R> extends LifecycleListener {
-  /**
-   * Indicates that we want the resource in its original unmodified width and/or height.
-   */
+  /** Indicates that we want the resource in its original unmodified width and/or height. */
   int SIZE_ORIGINAL = Integer.MIN_VALUE;
 
   /**
    * A lifecycle callback that is called when a load is started.
    *
-   * <p> Note - This may not be called for every load, it is possible for example for loads to fail
+   * <p>Note - This may not be called for every load, it is possible for example for loads to fail
    * before the load starts (when the model object is null).
    *
-   * <p> Note - This method may be called multiple times before any other lifecycle method is
-   * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here.
+   * <p>Note - This method may be called multiple times before any other lifecycle method is called.
+   * Loads can be paused and restarted due to lifecycle or connectivity events and each restart may
+   * cause a call here.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -88,14 +92,10 @@
    */
   void removeCallback(@NonNull SizeReadyCallback cb);
 
-  /**
-   * Sets the current request for this target to retain, should not be called outside of Glide.
-   */
+  /** Sets the current request for this target to retain, should not be called outside of Glide. */
   void setRequest(@Nullable Request request);
 
-  /**
-   * Retrieves the current request for this target, should not be called outside of Glide.
-   */
+  /** Retrieves the current request for this target, should not be called outside of Glide. */
   @Nullable
   Request getRequest();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index 043d31daf..c86dcfd8b 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -6,17 +6,16 @@
 import android.widget.ImageView;
 
 /**
- * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once
- * image into an {@link android.widget.ImageView} with fixed dimensions.
+ * Avoids extra calls to {@link android.view.View#requestLayout} when loading more than once image
+ * into an {@link android.widget.ImageView} with fixed dimensions.
  *
- * <p>Typically it makes sense
- * to use this class when loading multiple images with the {@link
+ * <p>Typically it makes sense to use this class when loading multiple images with the {@link
  * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
  * a scrolling list like ListView, GridView, or RecyclerView.
  *
- * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on
- * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
- * {@link BitmapImageViewTarget} as alternatives.
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on your
+ * images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or {@link
+ * BitmapImageViewTarget} as alternatives.
  *
  * @param <T> The type of resource that will be displayed in the ImageView.
  */
@@ -28,9 +27,7 @@ public ThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
-  /**
-   * @deprecated Use {@link #waitForLayout()} insetad.
-   */
+  /** @deprecated Use {@link #waitForLayout()} insetad. */
   @Deprecated
   @SuppressWarnings({"deprecation"})
   public ThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index e83e1eafa..d6a410b2b 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -53,14 +53,11 @@
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
-  @Nullable
-  private OnAttachStateChangeListener attachStateListener;
+  @Nullable private OnAttachStateChangeListener attachStateListener;
   private boolean isClearedByUs;
   private boolean isAttachStateListenerAdded;
 
-  /**
-   * Constructor that defaults {@code waitForLayout} to {@code false}.
-   */
+  /** Constructor that defaults {@code waitForLayout} to {@code false}. */
   public ViewTarget(@NonNull T view) {
     this.view = Preconditions.checkNotNull(view);
     sizeDeterminer = new SizeDeterminer(view);
@@ -68,14 +65,13 @@ public ViewTarget(@NonNull T view) {
 
   /**
    * @param waitForLayout If set to {@code true}, Glide will always wait for any pending layout pass
-   * before checking for the size a View. If set to {@code false} Glide will only wait for a pending
-   * layout pass if it's unable to resolve the size from layout parameters or an existing View size.
-   * Because setting this parameter to {@code true} forces Glide to wait for the layout pass to
-   * occur before starting the load, setting this parameter to {@code true} can cause flashing in
-   * some cases and should be used sparingly. If layout parameters are set to fixed sizes, they will
-   * still be used instead of the View's dimensions even if this parameter is set to {@code true}.
-   * This parameter is a fallback only.
-   *
+   *     before checking for the size a View. If set to {@code false} Glide will only wait for a
+   *     pending layout pass if it's unable to resolve the size from layout parameters or an
+   *     existing View size. Because setting this parameter to {@code true} forces Glide to wait for
+   *     the layout pass to occur before starting the load, setting this parameter to {@code true}
+   *     can cause flashing in some cases and should be used sparingly. If layout parameters are set
+   *     to fixed sizes, they will still be used instead of the View's dimensions even if this
+   *     parameter is set to {@code true}. This parameter is a fallback only.
    * @deprecated Use {@link #waitForLayout()} instead.
    */
   @SuppressWarnings("WeakerAccess") // Public API
@@ -88,19 +84,19 @@ public ViewTarget(@NonNull T view, boolean waitForLayout) {
   }
 
   /**
-   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its
-   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is
-   * re-attached from its {@link android.view.Window}.
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its {@link
+   * android.view.Window} and restarts the {@link Request} when the {@link View} is re-attached from
+   * its {@link android.view.Window}.
    *
    * <p>This is an experimental API that may be removed in a future version.
    *
    * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
    * transitioning screens or swapping adapters in scrolling views. However it also substantially
    * increases the odds that images will not be in memory if users subsequently return to a screen
-   * where images were previously loaded. Whether or not this happens will depend on the number
-   * of images loaded in the new screen and the size of the memory cache. Increasing the size of
-   * the memory cache can improve this behavior but it largely negates the memory benefits of using
-   * this method.
+   * where images were previously loaded. Whether or not this happens will depend on the number of
+   * images loaded in the new screen and the size of the memory cache. Increasing the size of the
+   * memory cache can improve this behavior but it largely negates the memory benefits of using this
+   * method.
    *
    * <p>Use this method with caution and measure your memory usage to ensure that it's actually
    * improving your memory usage in the cases you care about.
@@ -112,23 +108,25 @@ public ViewTarget(@NonNull T view, boolean waitForLayout) {
     if (attachStateListener != null) {
       return this;
     }
-    attachStateListener = new OnAttachStateChangeListener() {
-      @Override
-      public void onViewAttachedToWindow(View v) {
-        resumeMyRequest();
-      }
-
-      @Override
-      public void onViewDetachedFromWindow(View v) {
-        pauseMyRequest();
-      }
-    };
+    attachStateListener =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            resumeMyRequest();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            pauseMyRequest();
+          }
+        };
     maybeAddAttachStateListener();
     return this;
   }
 
   @SuppressWarnings("WeakerAccess")
-  @Synthetic void resumeMyRequest() {
+  @Synthetic
+  void resumeMyRequest() {
     Request request = getRequest();
     if (request != null && request.isCleared()) {
       request.begin();
@@ -136,7 +134,8 @@ public void onViewDetachedFromWindow(View v) {
   }
 
   @SuppressWarnings("WeakerAccess")
-  @Synthetic void pauseMyRequest() {
+  @Synthetic
+  void pauseMyRequest() {
     Request request = getRequest();
     // If the Request were cleared by the developer, it would be null here. The only way it's
     // present is if the developer hasn't previously cleared this Target.
@@ -148,19 +147,19 @@ public void onViewDetachedFromWindow(View v) {
   }
 
   /**
-   * Indicates that Glide should always wait for any pending layout pass before checking
-   * for the size an {@link View}.
+   * Indicates that Glide should always wait for any pending layout pass before checking for the
+   * size an {@link View}.
    *
    * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
    * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
    * {@link View#getHeight()}.
    *
    * <p>Because calling this method forces Glide to wait for the layout pass to occur before
-   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load
-   * an image even if it's in the memory cache. The load will happen asynchronously because Glide
-   * has to wait for a layout pass to occur, which won't necessarily happen in the same frame as
-   * when the image is requested. As a result, using this method can resulting in flashing in some
-   * cases and should be used sparingly.
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load an
+   * image even if it's in the memory cache. The load will happen asynchronously because Glide has
+   * to wait for a layout pass to occur, which won't necessarily happen in the same frame as when
+   * the image is requested. As a result, using this method can resulting in flashing in some cases
+   * and should be used sparingly.
    *
    * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
    * still be used instead of the {@link View}'s dimensions even if this method is called. This
@@ -198,9 +197,7 @@ private void maybeRemoveAttachStateListener() {
     isAttachStateListenerAdded = false;
   }
 
-  /**
-   * Returns the wrapped {@link android.view.View}.
-   */
+  /** Returns the wrapped {@link android.view.View}. */
   @NonNull
   public T getView() {
     return view;
@@ -251,13 +248,13 @@ public void setRequest(@Nullable Request request) {
   /**
    * Returns any stored request using {@link android.view.View#getTag()}.
    *
-   * <p> For Glide to function correctly, Glide must be the only thing that calls {@link
+   * <p>For Glide to function correctly, Glide must be the only thing that calls {@link
    * View#setTag(Object)}. If the tag is cleared or put to another object type, Glide will not be
    * able to retrieve and cancel previous loads which will not only prevent Glide from reusing
    * resource, but will also result in incorrect images being loaded and lots of flashing of images
    * in lists. As a result, this will throw an {@link java.lang.IllegalArgumentException} if {@link
    * android.view.View#getTag()}} returns a non null object that is not an {@link
-   * com.bumptech.glide.request.Request}. </p>
+   * com.bumptech.glide.request.Request}.
    */
   @Override
   @Nullable
@@ -291,24 +288,19 @@ private Object getTag() {
   }
 
   /**
-   * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)}
-   * to store temporary state allowing loads to be automatically cancelled and resources re-used
-   * in scrolling lists.
+   * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)} to
+   * store temporary state allowing loads to be automatically cancelled and resources re-used in
+   * scrolling lists.
    *
-   * <p>
-   *   If no tag id is set, Glide will use {@link View#setTag(Object)}.
-   * </p>
+   * <p>If no tag id is set, Glide will use {@link View#setTag(Object)}.
    *
-   * <p>
-   *   Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior
-   *   to Android 4.0 may cause memory leaks and isn't recommended. If you do use this method
-   *   on older versions, be sure to call {@link com.bumptech.glide.RequestManager#clear(View)} on
-   *   any view you start a load into to ensure that the static state is removed.
-   * </p>
+   * <p>Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior to
+   * Android 4.0 may cause memory leaks and isn't recommended. If you do use this method on older
+   * versions, be sure to call {@link com.bumptech.glide.RequestManager#clear(View)} on any view you
+   * start a load into to ensure that the static state is removed.
    *
    * @deprecated Glide uses it's own default tag id, so there's no need to specify your own. This
-   * method will be removed in a future version.
-   *
+   *     method will be removed in a future version.
    * @param tagId The android resource to use.
    */
   // Public API.
@@ -316,8 +308,9 @@ private Object getTag() {
   @Deprecated
   public static void setTagId(int tagId) {
     if (isTagUsedAtLeastOnce) {
-      throw new IllegalArgumentException("You cannot set the tag id more than once or change"
-          + " the tag id after the first request has been made");
+      throw new IllegalArgumentException(
+          "You cannot set the tag id more than once or change"
+              + " the tag id after the first request has been made");
     }
     ViewTarget.tagId = tagId;
   }
@@ -326,9 +319,7 @@ public static void setTagId(int tagId) {
   static final class SizeDeterminer {
     // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
-    @VisibleForTesting
-    @Nullable
-    static Integer maxDisplayLength;
+    @VisibleForTesting @Nullable static Integer maxDisplayLength;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
     @Synthetic boolean waitForLayout;
@@ -482,12 +473,14 @@ private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
       // layout to complete before using this fallback parameter (ConstraintLayout among others).
       if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
         if (Log.isLoggable(TAG, Log.INFO)) {
-          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
-              + " this device's screen dimensions. If you want to load the original image and are"
-              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
-              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
-              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
-              + " dimensions.");
+          Log.i(
+              TAG,
+              "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of this"
+                  + " device's screen dimensions. If you want to load the original image and are"
+                  + " ok with the corresponding memory cost and OOMs (depending on the input size),"
+                  + " use override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT,"
+                  + " set layout_width and layout_height to fixed dimension, or use .override()"
+                  + " with fixed dimensions.");
         }
         return getMaxDisplayLength(view.getContext());
       }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
index 8bec74e45..1792789f5 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -8,11 +8,11 @@
 
 /**
  * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
- * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
- * Most commonly used with {@link DrawableCrossFadeFactory}.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}. Most
+ * commonly used with {@link DrawableCrossFadeFactory}.
  *
  * @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
- *            be transitioned.
+ *     be transitioned.
  */
 public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
   private final TransitionFactory<Drawable> realFactory;
@@ -31,8 +31,9 @@ public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory)
 
   /**
    * Retrieve the Bitmap from a composite object.
-   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap
-   * via expensive drawing here, this method is called on the UI thread.</p>
+   *
+   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap via expensive drawing here,
+   * this method is called on the UI thread.
    *
    * @param current composite object containing a Bitmap and some other information
    * @return the Bitmap contained within {@code current}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index 0a8da3056..58cf57d42 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -8,7 +8,7 @@
  * the drawable was loaded from the memory cache and whether or not the drawable is the first image
  * to be put on the target.
  *
- * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
+ * <p>Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
  * the memory cache this factory produces an {@link NoTransition}.
@@ -28,19 +28,18 @@ protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
   @Override
   public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
     return dataSource == DataSource.MEMORY_CACHE
-        ? NoTransition.<Drawable>get() : getResourceTransition();
+        ? NoTransition.<Drawable>get()
+        : getResourceTransition();
   }
 
   private Transition<Drawable> getResourceTransition() {
-      if (resourceTransition == null) {
-        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
-      }
-      return resourceTransition;
+    if (resourceTransition == null) {
+      resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
+    }
+    return resourceTransition;
   }
 
-  /**
-   * A Builder for {@link DrawableCrossFadeFactory}.
-   */
+  /** A Builder for {@link DrawableCrossFadeFactory}. */
   @SuppressWarnings("unused")
   public static class Builder {
     private static final int DEFAULT_DURATION_MS = 300;
@@ -51,9 +50,7 @@ public Builder() {
       this(DEFAULT_DURATION_MS);
     }
 
-    /**
-     * @param durationMillis The duration of the cross fade animation in milliseconds.
-     */
+    /** @param durationMillis The duration of the cross fade animation in milliseconds. */
     public Builder(int durationMillis) {
       this.durationMillis = durationMillis;
     }
@@ -65,10 +62,10 @@ public Builder(int durationMillis) {
      * <p>Defaults to {@code false}.
      *
      * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
-     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
-     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
-     *     alpha will remain at 100 throughout the animation. See
-     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is animated from 0 to 100.
+     *     Otherwise the previous {@link Drawable}'s alpha will remain at 100 throughout the
+     *     animation. See {@link
+     *     android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
      */
     public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
       this.isCrossFadeEnabled = isCrossFadeEnabled;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 730d84f30..0960c4f97 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -18,17 +18,15 @@
 
   /**
    * @param duration The duration that the cross fade animation should run if there is something to
-   *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   *     cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
    * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
-   *                         animating the new resource's alpha to 100. Otherwise, only animates
-   *                         the new resource's alpha to 100 while leaving the previous resource's
-   *                         alpha at 100. See
-   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
+   *     animating the new resource's alpha to 100. Otherwise, only animates the new resource's
+   *     alpha to 100 while leaving the previous resource's alpha at 100. See {@link
+   *     TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
-  public DrawableCrossFadeTransition(int duration,
-      boolean isCrossFadeEnabled) {
+  public DrawableCrossFadeTransition(int duration, boolean isCrossFadeEnabled) {
     this.duration = duration;
     this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
@@ -36,9 +34,11 @@ public DrawableCrossFadeTransition(int duration,
   /**
    * Animates from the previous drawable to the current drawable in one of two ways.
    *
-   * <ol> <li>Using the default animation provided in the constructor if the previous drawable is
-   * null</li> <li>Using the cross fade animation with the duration provided in the constructor if
-   * the previous drawable is non null</li> </ol>
+   * <ol>
+   *   <li>Using the default animation provided in the constructor if the previous drawable is null
+   *   <li>Using the cross fade animation with the duration provided in the constructor if the
+   *       previous drawable is non null
+   * </ol>
    *
    * @param current {@inheritDoc}
    * @param adapter {@inheritDoc}
@@ -51,7 +51,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
       previous = new ColorDrawable(Color.TRANSPARENT);
     }
     TransitionDrawable transitionDrawable =
-        new TransitionDrawable(new Drawable[] { previous, current });
+        new TransitionDrawable(new Drawable[] {previous, current});
     transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
     transitionDrawable.startTransition(duration);
     adapter.setDrawable(transitionDrawable);
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 1ef48eb2b..b0bbbd921 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -6,19 +6,20 @@
 /**
  * A simple {@link Transition} that performs no actions.
  *
- * @param <R> the resource type that will be transitioned into a
- * {@link com.bumptech.glide.request.target.Target}.
+ * @param <R> the resource type that will be transitioned into a {@link
+ *     com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
   @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<>();
+
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
   /**
    * A factory that always returns the same {@link NoTransition}.
    *
-   * @param <R> the resource type that will be transitioned into a
-   * {@link com.bumptech.glide.request.target.Target}.
+   * @param <R> the resource type that will be transitioned into a {@link
+   *     com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
@@ -28,25 +29,19 @@
     }
   }
 
-  /**
-   * Returns an instance of a factory that produces {@link NoTransition}s.
-   */
+  /** Returns an instance of a factory that produces {@link NoTransition}s. */
   @SuppressWarnings("unchecked")
   public static <R> TransitionFactory<R> getFactory() {
     return (TransitionFactory<R>) NO_ANIMATION_FACTORY;
   }
 
-  /**
-   * Returns an instance of {@link NoTransition}.
-   */
+  /** Returns an instance of {@link NoTransition}. */
   @SuppressWarnings("unchecked")
   public static <R> Transition<R> get() {
     return (Transition<R>) NO_ANIMATION;
   }
 
-  /**
-   * Performs no animation and always returns {@code false}.
-   */
+  /** Performs no animation and always returns {@code false}. */
   @Override
   public boolean transition(Object current, ViewAdapter adapter) {
     return false;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
index 50debd7b9..07210e72c 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/Transition.java
@@ -22,9 +22,7 @@
    * animated {@link android.graphics.drawable.Drawable}s).
    */
   interface ViewAdapter {
-    /**
-     * Returns the wrapped {@link android.view.View}.
-     */
+    /** Returns the wrapped {@link android.view.View}. */
     View getView();
 
     /**
@@ -49,9 +47,9 @@
    *
    * @param current The new resource that will be displayed in the view.
    * @param adapter The {@link Transition.ViewAdapter} wrapping a view that can at least return an
-   *                {@link android.view.View} from {@link Transition.ViewAdapter#getView()}.
+   *     {@link android.view.View} from {@link Transition.ViewAdapter#getView()}.
    * @return True if in the process of running the transition, the new resource was put on the view,
-   * false if the caller needs to manually put the current resource on the view.
+   *     false if the caller needs to manually put the current resource on the view.
    */
   boolean transition(R current, ViewAdapter adapter);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
index 727b508a7..e0022df28 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java
@@ -3,8 +3,7 @@
 import com.bumptech.glide.load.DataSource;
 
 /**
- * A factory class that can produce different {@link Transition}s based on the state of the
- * request.
+ * A factory class that can produce different {@link Transition}s based on the state of the request.
  *
  * @param <R> The type of resource that needs to be animated into the target.
  */
@@ -13,8 +12,7 @@
   /**
    * Returns a new {@link Transition}.
    *
-   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded
-   *                        from.
+   * @param dataSource The {@link com.bumptech.glide.load.DataSource} the resource was loaded from.
    * @param isFirstResource True if this is the first resource to be loaded into the target.
    */
   Transition<R> build(DataSource dataSource, boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index e5a2cec05..0942c308c 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -35,7 +35,7 @@ public ViewAnimationFactory(int animationId) {
    * {@link ViewTransition}.
    *
    * @param dataSource {@inheritDoc}
-   * @param isFirstResource   {@inheritDoc}
+   * @param isFirstResource {@inheritDoc}
    */
   @Override
   public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
@@ -50,8 +50,8 @@ public ViewAnimationFactory(int animationId) {
     return transition;
   }
 
-  private static class ConcreteViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private static class ConcreteViewTransitionAnimationFactory
+      implements ViewTransition.ViewTransitionAnimationFactory {
     private final Animation animation;
 
     ConcreteViewTransitionAnimationFactory(Animation animation) {
@@ -64,8 +64,8 @@ public Animation build(Context context) {
     }
   }
 
-  private static class ResourceViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private static class ResourceViewTransitionAnimationFactory
+      implements ViewTransition.ViewTransitionAnimationFactory {
     private final int animationId;
 
     ResourceViewTransitionAnimationFactory(int animationId) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
index 45e75f760..e6b02121b 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -55,5 +55,4 @@ public boolean transition(R current, ViewAdapter adapter) {
      */
     void animate(View view);
   }
-
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
index c8a18cb6c..4c05137a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewTransition.java
@@ -6,8 +6,8 @@
 
 /**
  * A {@link Transition} that can apply a {@link android.view.animation.Animation Animation} to a
- * {@link android.view.View View} using
- * {@link android.view.View#startAnimation(android.view.animation.Animation)}.
+ * {@link android.view.View View} using {@link
+ * android.view.View#startAnimation(android.view.animation.Animation)}.
  *
  * @param <R> The type of the resource that will be transitioned into a view.
  */
@@ -24,11 +24,11 @@
   }
 
   /**
-   * Always clears the current animation on the view using
-   * {@link android.view.View#clearAnimation()}, then starts the
-   * {@link android.view.animation.Animation} given in the constructor using
-   * {@link android.view.View#startAnimation(android.view.animation.Animation)} and then returns
-   * {@code false} because the animation does not actually put the current resource on the view.
+   * Always clears the current animation on the view using {@link
+   * android.view.View#clearAnimation()}, then starts the {@link android.view.animation.Animation}
+   * given in the constructor using {@link
+   * android.view.View#startAnimation(android.view.animation.Animation)} and then returns {@code
+   * false} because the animation does not actually put the current resource on the view.
    *
    * @param current {@inheritDoc}
    * @param adapter {@inheritDoc}
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 2763433aa..ec6ea6dda 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -4,9 +4,7 @@
 import com.bumptech.glide.load.Key;
 import java.security.MessageDigest;
 
-/**
- * An empty key that is always equal to all other empty keys.
- */
+/** An empty key that is always equal to all other empty keys. */
 public final class EmptySignature implements Key {
   private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index bb0e06b6e..e34596641 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -18,14 +18,14 @@
   /**
    * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}.
    *
-   * @param mimeType     The mime type of the media store media. Ok to default to empty string "".
-   *                     See {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or
-   *                     {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
+   * @param mimeType The mime type of the media store media. Ok to default to empty string "". See
+   *     {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or {@link
+   *     android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}.
    * @param dateModified The date modified time of the media store media. Ok to default to 0. See
-   *                     {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or
-   *                     {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
-   * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
-   *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
+   *     {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or {@link
+   *     android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}.
+   * @param orientation The orientation of the media store media. Ok to default to 0. See {@link
+   *     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
    */
   public MediaStoreSignature(@Nullable String mimeType, long dateModified, int orientation) {
     this.mimeType = mimeType == null ? "" : mimeType;
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index ed3ea19e8..603d27dcb 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -8,11 +8,11 @@
 /**
  * Wraps an {@link java.lang.Object}, delegating {@link #equals(Object)} and {@link #hashCode()} to
  * the wrapped Object and providing the bytes of the result of the Object's {@link #toString()}
- * method to the {@link java.security.MessageDigest} in
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
+ * method to the {@link java.security.MessageDigest} in {@link
+ * #updateDiskCacheKey(java.security.MessageDigest)}.
  *
  * <p>The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
- * key.</p>
+ * key.
  */
 public final class ObjectKey implements Key {
   private final Object object;
@@ -23,9 +23,7 @@ public ObjectKey(@NonNull Object object) {
 
   @Override
   public String toString() {
-    return "ObjectKey{"
-        + "object=" + object
-        + '}';
+    return "ObjectKey{" + "object=" + object + '}';
   }
 
   @Override
@@ -47,4 +45,3 @@ public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(object.toString().getBytes(CHARSET));
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index c1e11a194..1f15b14c0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -12,9 +12,7 @@
 import java.nio.channels.FileChannel;
 import java.util.concurrent.atomic.AtomicReference;
 
-/**
- * Utilities for interacting with {@link java.nio.ByteBuffer}s.
- */
+/** Utilities for interacting with {@link java.nio.ByteBuffer}s. */
 @SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
@@ -90,8 +88,8 @@ public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws
     }
   }
 
-  public static void toStream(@NonNull ByteBuffer byteBuffer,
-      @NonNull OutputStream os) throws IOException {
+  public static void toStream(@NonNull ByteBuffer byteBuffer, @NonNull OutputStream os)
+      throws IOException {
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null) {
       os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index 2b0283e03..e372f96e6 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -20,8 +20,8 @@
   private int readSoFar;
 
   @NonNull
-  public static InputStream obtain(@NonNull InputStream other,
-      @Nullable String contentLengthHeader) {
+  public static InputStream obtain(
+      @NonNull InputStream other, @Nullable String contentLengthHeader) {
     return obtain(other, parseContentLength(contentLengthHeader));
   }
 
@@ -52,7 +52,7 @@ private ContentLengthInputStream(@NonNull InputStream in, long contentLength) {
   @Override
   public synchronized int available() throws IOException {
     return (int) Math.max(contentLength - readSoFar, in.available());
- }
+  }
 
   @Override
   public synchronized int read() throws IOException {
@@ -67,8 +67,7 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public synchronized int read(byte[] buffer, int byteOffset, int byteCount)
-      throws IOException {
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
     return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
   }
 
@@ -76,9 +75,12 @@ private int checkReadSoFarOrThrow(int read) throws IOException {
     if (read >= 0) {
       readSoFar += read;
     } else if (contentLength - readSoFar > 0) {
-      throw new IOException("Failed to read all expected data"
-          + ", expected: " + contentLength
-          + ", but read: " + readSoFar);
+      throw new IOException(
+          "Failed to read all expected data"
+              + ", expected: "
+              + contentLength
+              + ", but read: "
+              + readSoFar);
     }
     return read;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index 3f5b05fb0..1aafe51bc 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -12,7 +12,7 @@
  * framework issue where exceptions during reads while decoding bitmaps in {@link
  * android.graphics.BitmapFactory} can return partially decoded bitmaps.
  *
- * See https://github.com/bumptech/glide/issues/126.
+ * <p>See https://github.com/bumptech/glide/issues/126.
  */
 public class ExceptionCatchingInputStream extends InputStream {
 
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index 08b7ed3ba..bdcbbec0d 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -16,11 +16,11 @@
   /**
    * Constructor for a PreloadSizeProvider with a fixed size.
    *
-   * @param width  The width of the preload size in pixels.
+   * @param width The width of the preload size in pixels.
    * @param height The height of the preload size in pixels.
    */
   public FixedPreloadSizeProvider(int width, int height) {
-    this.size = new int[] { width, height };
+    this.size = new int[] {width, height};
   }
 
   @Nullable
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 58ddd6269..401094878 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -4,9 +4,7 @@
 import android.os.Build;
 import android.os.SystemClock;
 
-/**
- * A class for logging elapsed real time in millis.
- */
+/** A class for logging elapsed real time in millis. */
 public final class LogTime {
   private static final double MILLIS_MULTIPLIER =
       Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index a2cd7d822..d64f5dea1 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -24,7 +24,7 @@
    * Constructor for LruCache.
    *
    * @param size The maximum size of the cache, the units must match the units used in {@link
-   *             #getSize(Object)}.
+   *     #getSize(Object)}.
    */
   public LruCache(long size) {
     this.initialMaxSize = size;
@@ -57,9 +57,7 @@ protected int getSize(@Nullable Y item) {
     return 1;
   }
 
-  /**
-   * Returns the number of entries stored in cache.
-   */
+  /** Returns the number of entries stored in cache. */
   protected synchronized int getCount() {
     return cache.size();
   }
@@ -67,23 +65,19 @@ protected synchronized int getCount() {
   /**
    * A callback called whenever an item is evicted from the cache. Subclasses can override.
    *
-   * @param key  The key of the evicted item.
+   * @param key The key of the evicted item.
    * @param item The evicted item.
    */
   protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
-  /**
-   * Returns the current maximum size of the cache in bytes.
-   */
+  /** Returns the current maximum size of the cache in bytes. */
   public synchronized long getMaxSize() {
     return maxSize;
   }
 
-  /**
-   * Returns the sum of the sizes of all items in the cache.
-   */
+  /** Returns the sum of the sizes of all items in the cache. */
   public synchronized long getCurrentSize() {
     return currentSize;
   }
@@ -93,7 +87,6 @@ public synchronized long getCurrentSize() {
    *
    * @param key The key to check.
    */
-
   public synchronized boolean contains(@NonNull T key) {
     return cache.containsKey(key);
   }
@@ -116,7 +109,7 @@ public synchronized Y get(@NonNull T key) {
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
    * the given key and item.
    *
-   * @param key  The key to add the item at.
+   * @param key The key to add the item at.
    * @param item The item to add.
    */
   @Nullable
@@ -157,9 +150,7 @@ public synchronized Y remove(@NonNull T key) {
     return value;
   }
 
-  /**
-   * Clears all items in the cache.
-   */
+  /** Clears all items in the cache. */
   public void clearMemory() {
     trimToSize(0);
   }
@@ -174,7 +165,7 @@ protected synchronized void trimToSize(long size) {
     Map.Entry<T, Y> last;
     Iterator<Map.Entry<T, Y>> cacheIterator;
     while (currentSize > size) {
-      cacheIterator  = cache.entrySet().iterator();
+      cacheIterator = cache.entrySet().iterator();
       last = cacheIterator.next();
       final Y toRemove = last.getValue();
       currentSize -= getSize(toRemove);
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
index d2ce2841d..fd205bc07 100644
--- a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -68,7 +68,8 @@ public long skip(long byteCount) throws IOException {
 
   @Override
   public int available() throws IOException {
-    return availableBytes == UNSET ? super.available()
+    return availableBytes == UNSET
+        ? super.available()
         : Math.min(availableBytes, super.available());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index 54fac7310..c87211510 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -3,9 +3,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
-/**
- * A key of two {@link Class}es to be used in hashed collections.
- */
+/** A key of two {@link Class}es to be used in hashed collections. */
 @SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
@@ -20,8 +18,8 @@ public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second);
   }
 
-  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second,
-      @Nullable Class<?> third) {
+  public MultiClassKey(
+      @NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     set(first, second, third);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 4ca650fc7..278414708 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -5,9 +5,7 @@
 import android.text.TextUtils;
 import java.util.Collection;
 
-/**
- * Contains common assertions.
- */
+/** Contains common assertions. */
 public final class Preconditions {
 
   private Preconditions() {
diff --git a/library/src/main/java/com/bumptech/glide/util/Synthetic.java b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
index 0d1140b04..fea7ff048 100644
--- a/library/src/main/java/com/bumptech/glide/util/Synthetic.java
+++ b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
@@ -5,10 +5,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-/**
- * Indicates that target's visibility can be relaxed to avoid synthetic methods.
- */
+/** Indicates that target's visibility can be relaxed to avoid synthetic methods. */
 @Retention(RetentionPolicy.SOURCE)
 @Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
-public @interface Synthetic {
-}
+public @interface Synthetic {}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index de4b3784b..ef3f5a94d 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -14,9 +14,7 @@
 import java.util.List;
 import java.util.Queue;
 
-/**
- * A collection of assorted utility classes.
- */
+/** A collection of assorted utility classes. */
 public final class Util {
   private static final int HASH_MULTIPLIER = 31;
   private static final int HASH_ACCUMULATOR = 17;
@@ -28,9 +26,7 @@ private Util() {
     // Utility class.
   }
 
-  /**
-   * Returns the hex string of the given byte array representing a SHA256 hash.
-   */
+  /** Returns the hex string of the given byte array representing a SHA256 hash. */
   @NonNull
   public static String sha256BytesToHex(@NonNull byte[] bytes) {
     synchronized (SHA_256_CHARS) {
@@ -58,30 +54,37 @@ private static String bytesToHex(@NonNull byte[] bytes, @NonNull char[] hexChars
    *
    * @see #getBitmapByteSize(android.graphics.Bitmap)
    * @deprecated Use {@link #getBitmapByteSize(android.graphics.Bitmap)} instead. Scheduled to be
-   * removed in Glide 4.0.
+   *     removed in Glide 4.0.
    */
   @Deprecated
   public static int getSize(@NonNull Bitmap bitmap) {
     return getBitmapByteSize(bitmap);
   }
 
-  /**
-   * Returns the in memory size of the given {@link Bitmap} in bytes.
-   */
+  /** Returns the in memory size of the given {@link Bitmap} in bytes. */
   @TargetApi(Build.VERSION_CODES.KITKAT)
   public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
     // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
     // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
     // instead assert here.
     if (bitmap.isRecycled()) {
-      throw new IllegalStateException("Cannot obtain size for recycled Bitmap: " + bitmap
-          + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig());
+      throw new IllegalStateException(
+          "Cannot obtain size for recycled Bitmap: "
+              + bitmap
+              + "["
+              + bitmap.getWidth()
+              + "x"
+              + bitmap.getHeight()
+              + "] "
+              + bitmap.getConfig());
     }
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+      } catch (
+          @SuppressWarnings("PMD.AvoidCatchingNPE")
+          NullPointerException e) {
         // Do nothing.
       }
     }
@@ -122,9 +125,7 @@ private static int getBytesPerPixel(@Nullable Bitmap.Config config) {
     return bytesPerPixel;
   }
 
-  /**
-   * Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}.
-   */
+  /** Returns true if width and height are both > 0 and/or equal to {@link Target#SIZE_ORIGINAL}. */
   public static boolean isValidDimensions(int width, int height) {
     return isValidDimension(width) && isValidDimension(height);
   }
@@ -143,32 +144,24 @@ public static void assertMainThread() {
     }
   }
 
-  /**
-   * Throws an {@link java.lang.IllegalArgumentException} if called on the main thread.
-   */
+  /** Throws an {@link java.lang.IllegalArgumentException} if called on the main thread. */
   public static void assertBackgroundThread() {
     if (!isOnBackgroundThread()) {
       throw new IllegalArgumentException("You must call this method on a background thread");
     }
   }
 
-  /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
-   */
+  /** Returns {@code true} if called on the main thread, {@code false} otherwise. */
   public static boolean isOnMainThread() {
     return Looper.myLooper() == Looper.getMainLooper();
   }
 
-  /**
-   * Returns {@code true} if called on a background thread, {@code false} otherwise.
-   */
+  /** Returns {@code true} if called on a background thread, {@code false} otherwise. */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
   }
 
-  /**
-   * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
-   */
+  /** Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation. */
   @NonNull
   public static <T> Queue<T> createQueue(int size) {
     return new ArrayDeque<>(size);
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index b54f9f127..c14e48419 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -16,8 +16,8 @@
  *
  * @param <T> The type of the model the size should be provided for.
  */
-public class ViewPreloadSizeProvider<T> implements ListPreloader.PreloadSizeProvider<T>,
-    SizeReadyCallback {
+public class ViewPreloadSizeProvider<T>
+    implements ListPreloader.PreloadSizeProvider<T>, SizeReadyCallback {
   private int[] size;
   // We need to keep a strong reference to the Target so that it isn't garbage collected due to a
   // weak reference
@@ -38,7 +38,7 @@ public ViewPreloadSizeProvider() {
    * Constructor that will extract the preload size from a given {@link android.view.View}.
    *
    * @param view A not null View the size will be extracted from async using an {@link
-   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   *     android.view.ViewTreeObserver .OnPreDrawListener}
    */
   // Public API.
   @SuppressWarnings("WeakerAccess")
@@ -59,18 +59,18 @@ public ViewPreloadSizeProvider(@NonNull View view) {
 
   @Override
   public void onSizeReady(int width, int height) {
-    size = new int[]{width, height};
+    size = new int[] {width, height};
     viewTarget = null;
   }
 
   /**
    * Sets the {@link android.view.View} the size will be extracted.
    *
-   * <p> Note - only the first call to this method will be obeyed, subsequent requests will be
-   * ignored. </p>
+   * <p>Note - only the first call to this method will be obeyed, subsequent requests will be
+   * ignored.
    *
    * @param view A not null View the size will be extracted async with an {@link
-   *             android.view.ViewTreeObserver .OnPreDrawListener}
+   *     android.view.ViewTreeObserver .OnPreDrawListener}
    */
   public void setView(@NonNull View view) {
     if (size != null || viewTarget != null) {
@@ -86,19 +86,13 @@ public void setView(@NonNull View view) {
     }
 
     @Override
-    protected void onResourceCleared(@Nullable Drawable placeholder) {
-
-    }
+    protected void onResourceCleared(@Nullable Drawable placeholder) {}
 
     @Override
-    public void onLoadFailed(@Nullable Drawable errorDrawable) {
-
-    }
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {}
 
     @Override
-    public void onResourceReady(@NonNull Object resource,
-        @Nullable Transition<? super Object> transition) {
-
-    }
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {}
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 12e641dc5..d4d00f77d 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -16,19 +16,20 @@
 public final class FactoryPools {
   private static final String TAG = "FactoryPools";
   private static final int DEFAULT_POOL_SIZE = 20;
-  private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
-    @Override
-    public void reset(@NonNull Object object) {
-      // Do nothing.
-    }
-  };
+  private static final Resetter<Object> EMPTY_RESETTER =
+      new Resetter<Object>() {
+        @Override
+        public void reset(@NonNull Object object) {
+          // Do nothing.
+        }
+      };
 
-  private FactoryPools() { }
+  private FactoryPools() {}
 
   /**
-   * Returns a non-thread safe {@link Pool} that never returns {@code null} from
-   * {@link Pool#acquire()} and that contains objects of the type created by the given
-   * {@link Factory} with the given maximum size.
+   * Returns a non-thread safe {@link Pool} that never returns {@code null} from {@link
+   * Pool#acquire()} and that contains objects of the type created by the given {@link Factory} with
+   * the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
    * be used to create a new instance.
@@ -41,9 +42,9 @@ private FactoryPools() { }
   }
 
   /**
-   * Returns a new thread safe {@link Pool} that never returns {@code null} from
-   * {@link Pool#acquire()} and that contains objects of the type created by the given
-   * {@link Factory} with the given maximum size.
+   * Returns a new thread safe {@link Pool} that never returns {@code null} from {@link
+   * Pool#acquire()} and that contains objects of the type created by the given {@link Factory} with
+   * the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, the given {@link Factory} will
    * be used to create a new instance.
@@ -70,8 +71,8 @@ private FactoryPools() { }
   }
 
   /**
-   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains
-   * {@link List Lists} of a specific generic type with the given maximum size.
+   * Returns a new thread safe {@link Pool} that never returns {@code null} and that contains {@link
+   * List Lists} of a specific generic type with the given maximum size.
    *
    * <p>If the pool is empty when {@link Pool#acquire()} is called, a new {@link List} will be
    * created.
@@ -82,29 +83,32 @@ private FactoryPools() { }
   @SuppressWarnings("WeakerAccess")
   @NonNull
   public static <T> Pool<List<T>> threadSafeList(int size) {
-    return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
-      @NonNull
-      @Override
-      public List<T> create() {
-        return new ArrayList<>();
-      }
-    }, new Resetter<List<T>>() {
-      @Override
-      public void reset(@NonNull List<T> object) {
-        object.clear();
-      }
-    });
+    return build(
+        new SynchronizedPool<List<T>>(size),
+        new Factory<List<T>>() {
+          @NonNull
+          @Override
+          public List<T> create() {
+            return new ArrayList<>();
+          }
+        },
+        new Resetter<List<T>>() {
+          @Override
+          public void reset(@NonNull List<T> object) {
+            object.clear();
+          }
+        });
   }
 
   @NonNull
-  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,
-      @NonNull Factory<T> factory) {
+  private static <T extends Poolable> Pool<T> build(
+      @NonNull Pool<T> pool, @NonNull Factory<T> factory) {
     return build(pool, factory, FactoryPools.<T>emptyResetter());
   }
 
   @NonNull
-  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,
-      @NonNull Resetter<T> resetter) {
+  private static <T> Pool<T> build(
+      @NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
     return new FactoryPool<>(pool, factory, resetter);
   }
 
@@ -133,8 +137,8 @@ public void reset(@NonNull List<T> object) {
   }
 
   /**
-   * Allows additional verification to catch errors caused by using objects while they are in
-   * an object pool.
+   * Allows additional verification to catch errors caused by using objects while they are in an
+   * object pool.
    */
   public interface Poolable {
     @NonNull
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
index 78c4f0fa3..9099cf695 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java
@@ -2,9 +2,7 @@
 
 import android.support.v4.os.TraceCompat;
 
-/**
- * Systracing utilities for Glide.
- */
+/** Systracing utilities for Glide. */
 public final class GlideTrace {
 
   // Enable this locally to see tracing statements.
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index 79e0b40aa..3535006db 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -3,15 +3,11 @@
 import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Synthetic;
 
-/**
- * Verifies that the job is not in the recycled state.
- */
+/** Verifies that the job is not in the recycled state. */
 public abstract class StateVerifier {
   private static final boolean DEBUG = false;
 
-  /**
-   * Creates a new {@link StateVerifier} instance.
-   */
+  /** Creates a new {@link StateVerifier} instance. */
   @NonNull
   public static StateVerifier newInstance() {
     if (DEBUG) {
@@ -21,7 +17,7 @@ public static StateVerifier newInstance() {
     }
   }
 
-  private StateVerifier() { }
+  private StateVerifier() {}
 
   /**
    * Throws an exception if we believe our object is recycled and inactive (i.e. is currently in an
@@ -29,16 +25,14 @@ private StateVerifier() { }
    */
   public abstract void throwIfRecycled();
 
-  /**
-   * Sets whether or not our object is recycled.
-   */
+  /** Sets whether or not our object is recycled. */
   abstract void setRecycled(boolean isRecycled);
 
   private static class DefaultStateVerifier extends StateVerifier {
     private volatile boolean isReleased;
 
     @Synthetic
-    DefaultStateVerifier() { }
+    DefaultStateVerifier() {}
 
     @Override
     public void throwIfRecycled() {
@@ -58,7 +52,7 @@ public void setRecycled(boolean isRecycled) {
     private volatile RuntimeException recycledAtStackTraceException;
 
     @Synthetic
-    DebugStateVerifier() { }
+    DebugStateVerifier() {}
 
     @Override
     public void throwIfRecycled() {
diff --git a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
index 13b415500..32ea9c73c 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
@@ -51,9 +51,9 @@
 /**
  * Test for {@link CustomViewTarget}.
  *
- * TODO: This should really be in the tests subproject, but that causes errors because the R class
- * referenced in {@link CustomViewTarget} can't be found. This should be fixable with some gradle
- * changes, but I've so far failed to figure out the right set of commands.
+ * <p>TODO: This should really be in the tests subproject, but that causes errors because the R
+ * class referenced in {@link CustomViewTarget} can't be found. This should be fixable with some
+ * gradle changes, but I've so far failed to figure out the right set of commands.
  */
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 19, manifest = "build/intermediates/manifests/full/debug/AndroidManifest.xml")
@@ -528,9 +528,7 @@ public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
   public void clearOnDetach_moreThanOnce_registersObserverOnce() {
     activity.visible();
     attachStateTarget.setRequest(request);
-    attachStateTarget
-        .clearOnDetach()
-        .clearOnDetach();
+    attachStateTarget.clearOnDetach().clearOnDetach();
     parent.removeView(view);
 
     verify(request).clear();
@@ -539,10 +537,7 @@ public void clearOnDetach_moreThanOnce_registersObserverOnce() {
   @Test
   public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
     activity.visible();
-    attachStateTarget
-        .clearOnDetach()
-        .clearOnDetach()
-        .clearOnDetach();
+    attachStateTarget.clearOnDetach().clearOnDetach().clearOnDetach();
     attachStateTarget.onLoadCleared(/*placeholder=*/ null);
     attachStateTarget.setRequest(request);
     parent.removeView(view);
diff --git a/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
index 118a320e5..a3f9f3321 100644
--- a/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -38,23 +38,24 @@ public void setUp() {
     Application app = RuntimeEnvironment.application;
 
     transitionOptions = new HashMap<>();
-    context = new GlideContext(
-        app,
-        new LruArrayPool(),
-        new Registry(),
-        new ImageViewTargetFactory(),
-        new RequestOptionsFactory() {
-          @NonNull
-          @Override
-          public RequestOptions build() {
-            return new RequestOptions();
-          }
-        },
-        transitionOptions,
-        /*defaultRequestListeners=*/ Collections.<RequestListener<Object>>emptyList(),
-        mock(Engine.class),
-        /*isLoggingRequestOriginsEnabled=*/ false,
-        Log.DEBUG);
+    context =
+        new GlideContext(
+            app,
+            new LruArrayPool(),
+            new Registry(),
+            new ImageViewTargetFactory(),
+            new RequestOptionsFactory() {
+              @NonNull
+              @Override
+              public RequestOptions build() {
+                return new RequestOptions();
+              }
+            },
+            transitionOptions,
+            /*defaultRequestListeners=*/ Collections.<RequestListener<Object>>emptyList(),
+            mock(Engine.class),
+            /*isLoggingRequestOriginsEnabled=*/ false,
+            Log.DEBUG);
   }
 
   @Test
@@ -74,17 +75,14 @@ public void getDefaultTransitionOptions_withNonMatchingOptionRegistered_returnsD
   public void getDefaultTransitionOptions_withMatchingOptionsRegistered_returnsMatchingOptions() {
     GenericTransitionOptions<Object> expected = new GenericTransitionOptions<>();
     transitionOptions.put(Bitmap.class, expected);
-    assertThat(context.getDefaultTransitionOptions(Bitmap.class))
-        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(Bitmap.class)).isEqualTo(expected);
   }
 
   @Test
   public void getDefaultTransitionOptions_withSuperClassRegistered_returnsSuperClassOptions() {
     DrawableTransitionOptions expected = new DrawableTransitionOptions();
     transitionOptions.put(Drawable.class, expected);
-    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class))
-        .isEqualTo(expected);
-    assertThat(context.getDefaultTransitionOptions(GifDrawable.class))
-        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class)).isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(GifDrawable.class)).isEqualTo(expected);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
index e2c42de91..a6bc33f7b 100644
--- a/library/test/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -89,14 +89,17 @@
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
 
-/**
- * Tests for the {@link Glide} interface and singleton.
- */
+/** Tests for the {@link Glide} interface and singleton. */
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    GlideTest.ShadowFileDescriptorContentResolver.class,
-    GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
-    GlideTest.MutableShadowBitmap.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {
+      GlideTest.ShadowFileDescriptorContentResolver.class,
+      GlideTest.ShadowMediaMetadataRetriever.class,
+      GlideShadowLooper.class,
+      GlideTest.MutableShadowBitmap.class
+    })
 @SuppressWarnings("unchecked")
 public class GlideTest {
   // Fixes method overload confusion.
@@ -105,7 +108,9 @@
   @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
   @SuppressWarnings("rawtypes")
-  @Mock private Target target;
+  @Mock
+  private Target target;
+
   @Mock private DiskCache.Factory diskCacheFactory;
   @Mock private DiskCache diskCache;
   @Mock private MemoryCache memoryCache;
@@ -148,14 +153,16 @@ public void setUp() {
     imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
-      @Override
-      public Boolean answer(InvocationOnMock invocation) {
-        Runnable runnable = (Runnable) invocation.getArguments()[0];
-        runnable.run();
-        return true;
-      }
-    });
+    when(bgHandler.post(isA(Runnable.class)))
+        .thenAnswer(
+            new Answer<Boolean>() {
+              @Override
+              public Boolean answer(InvocationOnMock invocation) {
+                Runnable runnable = (Runnable) invocation.getArguments()[0];
+                runnable.run();
+                return true;
+              }
+            });
 
     requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
@@ -165,10 +172,7 @@ public Boolean answer(InvocationOnMock invocation) {
   public void testCanSetMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder()
-            .setBitmapPool(bitmapPool)
-            .setMemoryCache(memoryCache)
-            .build(context);
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -179,10 +183,7 @@ public void testCanSetMemoryCategory() {
   public void testCanIncreaseMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder()
-            .setBitmapPool(bitmapPool)
-            .setMemoryCache(memoryCache)
-            .build(context);
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -201,10 +202,7 @@ public void testCanIncreaseMemoryCategory() {
   public void testCanDecreaseMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder()
-            .setBitmapPool(bitmapPool)
-            .setMemoryCache(memoryCache)
-            .build(context);
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -222,10 +220,7 @@ public void testCanDecreaseMemoryCategory() {
   @Test
   public void testClearMemory() {
     Glide glide =
-        new GlideBuilder()
-            .setBitmapPool(bitmapPool)
-            .setMemoryCache(memoryCache)
-            .build(context);
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
 
     glide.clearMemory();
 
@@ -236,10 +231,7 @@ public void testClearMemory() {
   @Test
   public void testTrimMemory() {
     Glide glide =
-        new GlideBuilder()
-            .setBitmapPool(bitmapPool)
-            .setMemoryCache(memoryCache)
-            .build(context);
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache).build(context);
 
     final int level = 123;
 
@@ -318,9 +310,7 @@ public void testLoadColorDrawable_withUnitBitmapTransformation_returnsColorDrawa
     ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
     requestManager
         .load(colorDrawable)
-        .apply(new RequestOptions()
-            .override(100, 100)
-            .centerCrop())
+        .apply(new RequestOptions().override(100, 100).centerCrop())
         .into(target);
 
     ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
@@ -337,9 +327,7 @@ public void testLoadColorDrawable_withNonUnitBitmapTransformation_returnsBitmapD
     ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
     requestManager
         .load(colorDrawable)
-        .apply(new RequestOptions()
-            .override(100, 100)
-            .circleCrop())
+        .apply(new RequestOptions().override(100, 100).circleCrop())
         .into(target);
 
     ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
@@ -435,19 +423,30 @@ private void runTestUriStringDefaultLoader() {
   }
 
   private void runTestStringDefaultLoader(String string) {
-    requestManager.load(string).listener(new RequestListener<Drawable>() {
-      @Override
-      public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
-          boolean isFirstResource) {
-        throw new RuntimeException("Load failed");
-      }
-
-      @Override
-      public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
-          DataSource dataSource, boolean isFirstResource) {
-        return false;
-      }
-    }).into(target);
+    requestManager
+        .load(string)
+        .listener(
+            new RequestListener<Drawable>() {
+              @Override
+              public boolean onLoadFailed(
+                  GlideException e,
+                  Object model,
+                  Target<Drawable> target,
+                  boolean isFirstResource) {
+                throw new RuntimeException("Load failed");
+              }
+
+              @Override
+              public boolean onResourceReady(
+                  Drawable resource,
+                  Object model,
+                  Target<Drawable> target,
+                  DataSource dataSource,
+                  boolean isFirstResource) {
+                return false;
+              }
+            })
+        .into(target);
     requestManager.load(string).into(imageView);
 
     verify(target).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
@@ -498,7 +497,6 @@ public void testByteArrayDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
-
   @Test(expected = Exception.class)
   public void testUnregisteredModelThrowsException() {
     Float unregistered = 0.5f;
@@ -530,7 +528,10 @@ public void testReceivesGifBytes() {
     InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
-    requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
+    requestManager
+        .as(byte[].class)
+        .apply(decodeTypeOf(GifDrawable.class))
+        .load(fakeUri)
         .into(target);
 
     verify(target).onResourceReady(isA(byte[].class), isA(Transition.class));
@@ -549,27 +550,30 @@ public void testReceivesBitmapBytes() {
   public void testReceivesThumbnails() {
     String full = mockUri("content://full");
     String thumb = mockUri("content://thumb");
-    requestManager
-        .load(full)
-        .thumbnail(requestManager.load(thumb))
-        .into(target);
+    requestManager.load(full).thumbnail(requestManager.load(thumb)).into(target);
 
     verify(target, times(2)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testReceivesRecursiveThumbnails() {
-    requestManager.load(mockUri("content://first")).thumbnail(
-        requestManager.load(mockUri("content://second")).thumbnail(
-            requestManager.load(mockUri("content://third")).thumbnail(
-                requestManager.load(mockUri("content://fourth")))))
+    requestManager
+        .load(mockUri("content://first"))
+        .thumbnail(
+            requestManager
+                .load(mockUri("content://second"))
+                .thumbnail(
+                    requestManager
+                        .load(mockUri("content://third"))
+                        .thumbnail(requestManager.load(mockUri("content://fourth")))))
         .into(target);
     verify(target, times(4)).onResourceReady(isA(Drawable.class), isA(Transition.class));
   }
 
   @Test
   public void testReceivesRecursiveThumbnailWithPercentage() {
-    requestManager.load(mockUri("content://first"))
+    requestManager
+        .load(mockUri("content://first"))
         .thumbnail(requestManager.load(mockUri("content://second")).thumbnail(0.5f))
         .into(target);
     verify(target, times(3)).onResourceReady(isA(Drawable.class), isA(Transition.class));
@@ -593,10 +597,7 @@ public void testNullModelInGenericLoadDoesNotThrow() {
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
-    requestManager
-        .load(NULL)
-        .apply(errorOf(drawable))
-        .into(target);
+    requestManager.load(NULL).apply(errorOf(drawable)).into(target);
 
     verify(target).onLoadFailed(eq(drawable));
   }
@@ -606,11 +607,7 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
     Drawable error = new ColorDrawable(Color.RED);
 
-    requestManager
-        .load(NULL)
-        .apply(placeholderOf(placeholder)
-            .error(error))
-        .into(target);
+    requestManager.load(NULL).apply(placeholderOf(placeholder).error(error)).into(target);
 
     verify(target).onLoadFailed(eq(error));
   }
@@ -618,10 +615,7 @@ public void testNullModelPrefersErrorDrawable() {
   @Test
   public void testLoadBitmap_asBitmap() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    requestManager
-        .asBitmap()
-        .load(bitmap)
-        .into(target);
+    requestManager.asBitmap().load(bitmap).into(target);
 
     verify(target).onResourceReady(eq(bitmap), any(Transition.class));
   }
@@ -629,9 +623,7 @@ public void testLoadBitmap_asBitmap() {
   @Test
   public void testLoadBitmap_asDrawable() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    requestManager
-        .load(bitmap)
-        .into(target);
+    requestManager.load(bitmap).into(target);
 
     ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
     verify(target).onResourceReady(captor.capture(), any(Transition.class));
@@ -642,9 +634,7 @@ public void testLoadBitmap_asDrawable() {
   @Test
   public void testLoadDrawable() {
     Drawable drawable = new ColorDrawable(Color.RED);
-    requestManager
-        .load(drawable)
-        .into(target);
+    requestManager.load(drawable).into(target);
 
     ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
     verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));
@@ -659,9 +649,7 @@ public void testNullModelPrefersFallbackDrawable() {
 
     requestManager
         .load(NULL)
-        .apply(placeholderOf(placeholder)
-            .error(error)
-            .fallback(fallback))
+        .apply(placeholderOf(placeholder).error(error).fallback(fallback))
         .into(target);
 
     verify(target).onLoadFailed(eq(fallback));
@@ -671,17 +659,14 @@ public void testNullModelPrefersFallbackDrawable() {
   public void testNullModelResolvesToUsePlaceholder() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
 
-    requestManager
-        .load(NULL)
-        .apply(placeholderOf(placeholder))
-        .into(target);
+    requestManager.load(NULL).apply(placeholderOf(placeholder)).into(target);
 
     verify(target).onLoadFailed(eq(placeholder));
   }
 
   @Test
   public void testByteData() {
-    byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
+    byte[] data = new byte[] {1, 2, 3, 4, 5, 6};
     requestManager.load(data).into(target);
   }
 
@@ -698,6 +683,7 @@ public void onResourceReady(
                       @Nullable Transition<? super Drawable> transition) {
                     // Do nothing.
                   }
+
                   @Override
                   public void onLoadCleared(@Nullable Drawable placeholder) {
                     // Do nothing, we don't retain a reference to our resource.
@@ -719,14 +705,11 @@ public void testClone() {
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
     Target<Drawable> secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
-    RequestBuilder<Drawable> firstRequest = requestManager
-        .load(mockUri("content://first"));
+    RequestBuilder<Drawable> firstRequest = requestManager.load(mockUri("content://first"));
 
     firstRequest.into(firstTarget);
 
-    firstRequest.clone()
-        .apply(placeholderOf(new ColorDrawable(Color.RED)))
-        .into(secondTarget);
+    firstRequest.clone().apply(placeholderOf(new ColorDrawable(Color.RED))).into(secondTarget);
 
     verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
     verify(secondTarget).onResourceReady(notNull(Drawable.class), isA(Transition.class));
@@ -779,8 +762,7 @@ private String mockUri(Uri uri, InputStream is) {
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
     when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(context).getRegistry()
-        .prepend(modelClass, InputStream.class, modelLoaderFactory);
+    Glide.get(context).getRegistry().prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
   @SuppressWarnings("unchecked")
@@ -788,7 +770,8 @@ private String mockUri(Uri uri, InputStream is) {
     ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
     DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
     try {
-      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0])))
+          .when(fetcher)
           .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     } catch (Exception e) {
       // Do nothing.
@@ -826,8 +809,8 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-      Y loadedData, Registry registry) {
+  private static <X, Y> void registerMockModelLoader(
+      Class<X> modelClass, Class<Y> dataClass, Y loadedData, Registry registry) {
     DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
     when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
     try {
@@ -842,8 +825,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
     when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
     ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
-        .thenReturn(mockUrlLoader);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(mockUrlLoader);
 
     registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
@@ -914,4 +896,3 @@ public Bitmap getFrameAtTime() {
     }
   }
 }
-
diff --git a/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index 92960087a..9876e9ad3 100644
--- a/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -46,18 +46,19 @@ public void testGetItemsIsCalledIncreasing() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
 
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(11 + count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(11 + count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 1, 10, 30);
     assertEquals(10, calledCount.get());
   }
@@ -70,29 +71,30 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       objects.add(i);
     }
 
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition;
-
-      @Override
-      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
-        return new int[] { 10, 10 };
-      }
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects.subList(position - 11, position + 1 - 11);
-      }
-
-      @Nullable
-      @Override
-      @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
-        assertEquals(objects.get(expectedPosition), item);
-        expectedPosition++;
-        return mock(RequestBuilder.class);
-      }
-    };
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition;
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            return new int[] {10, 10};
+          }
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects.subList(position - 11, position + 1 - 11);
+          }
+
+          @Nullable
+          @Override
+          @SuppressWarnings("unchecked")
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            assertEquals(objects.get(expectedPosition), item);
+            expectedPosition++;
+            return mock(RequestBuilder.class);
+          }
+        };
     ListPreloader<Object> preloader =
         new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
     preloader.onScroll(null, 1, 10, 20);
@@ -102,22 +104,23 @@ public void testGetItemsIsCalledInOrderIncreasing() {
   public void testGetItemsIsCalledDecreasing() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        // Ignore the preload caused from us starting at the end
-        if (position >= 40) {
-          return Collections.emptyList();
-        }
-        final int count = calledCount.getAndIncrement();
-        called.set(true);
-        assertEquals(28 - count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            // Ignore the preload caused from us starting at the end
+            if (position >= 40) {
+              return Collections.emptyList();
+            }
+            final int count = calledCount.getAndIncrement();
+            called.set(true);
+            assertEquals(28 - count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 30, 10, 40);
     preloader.onScroll(null, 29, 10, 40);
     assertTrue(called.get());
@@ -131,32 +134,33 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       objects.add(new Object());
     }
 
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = toPreload - 1;
-
-      @Override
-      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
-        return new int[] { 10, 10 };
-      }
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position == 40) {
-          return Collections.emptyList();
-        }
-        return objects.subList(position, position + 1);
-      }
-
-      @Nullable
-      @Override
-      @SuppressWarnings("unchecked")
-      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
-        assertEquals(objects.get(expectedPosition), item);
-        expectedPosition--;
-        return mock(RequestBuilder.class);
-      }
-    };
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = toPreload - 1;
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            return new int[] {10, 10};
+          }
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position == 40) {
+              return Collections.emptyList();
+            }
+            return objects.subList(position, position + 1);
+          }
+
+          @Nullable
+          @Override
+          @SuppressWarnings("unchecked")
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            assertEquals(objects.get(expectedPosition), item);
+            expectedPosition--;
+            return mock(RequestBuilder.class);
+          }
+        };
     ListPreloader<Object> preloader =
         new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);
     preloader.onScroll(null, 30, 10, 10);
@@ -167,18 +171,19 @@ public void testGetItemsIsCalledInOrderDecreasing() {
   public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(26 + count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(26 + count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 16, 10, 30);
     assertTrue(called.get());
   }
@@ -187,22 +192,23 @@ public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
   public void testGetItemsIsNeverCalledWithStartLessThanZero() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position >= 17) {
-          return Collections.emptyList();
-        }
-        called.set(true);
-        final int count = calledCount.getAndIncrement();
-        assertEquals(5 - count, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position >= 17) {
+              return Collections.emptyList();
+            }
+            called.set(true);
+            final int count = calledCount.getAndIncrement();
+            assertEquals(5 - count, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 7, 10, 30);
     preloader.onScroll(null, 6, 10, 30);
     assertTrue(called.get());
@@ -211,18 +217,19 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
   @Test
   public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
     final AtomicInteger called = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        final int current = called.getAndIncrement();
-        assertEquals(11 + current, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            final int current = called.getAndIncrement();
+            assertEquals(11 + current, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 1, 10, 30);
     preloader.onScroll(null, 4, 10, 30);
 
@@ -232,21 +239,22 @@ public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
   @Test
   public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
     final AtomicInteger called = new AtomicInteger();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        if (position >= 20) {
-          return Collections.emptyList();
-        }
-        final int current = called.getAndIncrement();
-        assertEquals(19 - current, position);
-        return super.getPreloadItems(position);
-      }
-    };
-
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            if (position >= 20) {
+              return Collections.emptyList();
+            }
+            final int current = called.getAndIncrement();
+            assertEquals(19 - current, position);
+            return super.getPreloadItems(position);
+          }
+        };
+
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     preloader.onScroll(null, 21, 10, 30);
     preloader.onScroll(null, 20, 10, 30);
     preloader.onScroll(null, 17, 10, 30);
@@ -258,31 +266,32 @@ public void testMultipleItemsForPositionIncreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = (1 + 10) * 2;
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects;
-      }
-
-      @Override
-      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPosition);
-        assertEquals(expectedPosition % 2, itemPosition);
-        expectedPosition++;
-        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
-      }
-
-      @Nullable
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
-        return request;
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = (1 + 10) * 2;
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects;
+          }
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            assertEquals(expectedPosition / 2, adapterPosition);
+            assertEquals(expectedPosition % 2, itemPosition);
+            expectedPosition++;
+            return itemPosition == 0 ? new int[] {10, 11} : new int[] {20, 21};
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            return request;
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     Iterable<Integer> expected = Arrays.asList(10, 11, 20, 21, 10, 11, 20, 21);
 
     preloader.onScroll(null, 1, 10, 1 + 10 + 2);
@@ -296,31 +305,32 @@ public void testMultipleItemsForPositionDecreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      private int expectedPosition = objects.size() * 2 - 1;
-
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects;
-      }
-
-      @Override
-      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPosition);
-        assertEquals(expectedPosition % 2, itemPosition);
-        expectedPosition--;
-        return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
-      }
-
-      @Nullable
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
-        return request;
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          private int expectedPosition = objects.size() * 2 - 1;
+
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects;
+          }
+
+          @Override
+          public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+            assertEquals(expectedPosition / 2, adapterPosition);
+            assertEquals(expectedPosition % 2, itemPosition);
+            expectedPosition--;
+            return itemPosition == 0 ? new int[] {10, 11} : new int[] {20, 21};
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            return request;
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
     Iterable<Integer> expected = Arrays.asList(20, 21, 10, 11, 20, 21, 10, 11);
 
     preloader.onScroll(null, 3, 2, 3 + 2);
@@ -352,32 +362,33 @@ public void testItemsArePreloadedWithGlide() {
     objects.add(new Object());
     objects.add(new Object());
     final HashSet<Object> loadedObjects = new HashSet<>();
-    ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      @NonNull
-      @Override
-      public List<Object> getPreloadItems(int position) {
-        return objects.subList(position - 11, position - 10);
-      }
-
-      @Nullable
-      @Override
-      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
-        loadedObjects.add(item);
-        return super.getPreloadRequestBuilder(item);
-      }
-    };
-    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,
-        preloaderAdapter, preloaderAdapter, 10);
+    ListPreloaderAdapter preloaderAdapter =
+        new ListPreloaderAdapter() {
+          @NonNull
+          @Override
+          public List<Object> getPreloadItems(int position) {
+            return objects.subList(position - 11, position - 10);
+          }
+
+          @Nullable
+          @Override
+          public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
+            loadedObjects.add(item);
+            return super.getPreloadRequestBuilder(item);
+          }
+        };
+    ListPreloader<Object> preloader =
+        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, 10);
 
     preloader.onScroll(null, 1, 10, 13);
     assertThat(loadedObjects).containsAtLeastElementsIn(objects);
   }
 
-  private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,
-      ListPreloader.PreloadSizeProvider<Object> {
+  private static class ListPreloaderAdapter
+      implements ListPreloader.PreloadModelProvider<Object>,
+          ListPreloader.PreloadSizeProvider<Object> {
 
-    public ListPreloaderAdapter() {
-    }
+    public ListPreloaderAdapter() {}
 
     @NonNull
     @Override
@@ -397,7 +408,7 @@ public ListPreloaderAdapter() {
     @Nullable
     @Override
     public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
-      return new int[] { 100, 100 };
+      return new int[] {100, 100};
     }
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 70b7a084c..74faee43d 100644
--- a/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -103,23 +103,25 @@ public void testThrowsIfGivenNullView() {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
     final ImageView imageView = new ImageView(RuntimeEnvironment.application);
-    testInBackground(new BackgroundTester() {
-      @Override
-      public void runTest() {
-       getNullModelRequest().into(imageView);
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            getNullModelRequest().into(imageView);
+          }
+        });
   }
 
   @Test
   public void doesNotThrowIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
     final Target<Object> target = mock(Target.class);
-    testInBackground(new BackgroundTester() {
-      @Override
-      public void runTest() {
-         getNullModelRequest().into(target);
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            getNullModelRequest().into(target);
+          }
+        });
   }
 
   @Test
@@ -129,11 +131,9 @@ public void testMultipleRequestListeners() {
     requestCaptor.getValue().onResourceReady(new SimpleResource<>(new Object()), DataSource.LOCAL);
 
     verify(listener1)
-        .onResourceReady(
-            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
     verify(listener2)
-        .onResourceReady(
-            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
   }
 
   @Test
@@ -144,22 +144,18 @@ public void testListenerApiOverridesListeners() {
 
     // The #listener API removes any previous listeners, so the first listener should not be called.
     verify(listener1, never())
-        .onResourceReady(
-            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
     verify(listener2)
-        .onResourceReady(
-            any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
+        .onResourceReady(any(), any(), isA(Target.class), isA(DataSource.class), anyBoolean());
   }
 
   private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
         .thenReturn(mock(ViewTarget.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
-    when(requestManager.getDefaultRequestOptions())
-        .thenReturn(new RequestOptions());
+    when(requestManager.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultTransitionOptions(any(Class.class)))
         .thenReturn(new GenericTransitionOptions<>());
-    return new RequestBuilder<>(glide, requestManager, Object.class, context)
-        .load((Object) null);
+    return new RequestBuilder<>(glide, requestManager, Object.class, context).load((Object) null);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
index a7b894580..2c43fe99d 100644
--- a/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -64,26 +64,26 @@ public void setUp() {
     connectivityMonitor = mock(ConnectivityMonitor.class);
     ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
     when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
-        .thenAnswer(new Answer<ConnectivityMonitor>() {
+        .thenAnswer(
+            new Answer<ConnectivityMonitor>() {
+              @Override
+              public ConnectivityMonitor answer(InvocationOnMock invocation) {
+                connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
+                return connectivityMonitor;
+              }
+            });
+
+    target =
+        new CustomTarget<Drawable>() {
           @Override
-          public ConnectivityMonitor answer(InvocationOnMock invocation) {
-            connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
-            return connectivityMonitor;
+          public void onResourceReady(
+              @NonNull Drawable resource, @Nullable Transition<? super Drawable> transition) {
+            // Empty.
           }
-        });
-
-    target = new CustomTarget<Drawable>() {
-      @Override
-      public void onResourceReady(@NonNull Drawable resource,
-          @Nullable Transition<? super Drawable> transition) {
-        // Empty.
-      }
 
-      @Override
-      public void onLoadCleared(@Nullable Drawable placeholder) {
-
-      }
-    };
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {}
+        };
 
     requestTracker = mock(RequestTracker.class);
     manager =
@@ -159,23 +159,25 @@ public void testDoesNotRestartRequestsOnDisconnected() {
   @Test
   public void resumeRequests_whenCalledOnBackgroundThread_doesNotThrow()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() {
-        manager.resumeRequests();
-      }
-    });
+    testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            manager.resumeRequests();
+          }
+        });
   }
 
   @Test
   public void pauseRequests_whenCalledOnBackgroundThread_doesNotThrow()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() {
-        manager.pauseRequests();
-      }
-    });
+    testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            manager.pauseRequests();
+          }
+        });
   }
 
   @Test
@@ -188,30 +190,41 @@ public void testDelegatesIsPausedToRequestTracker() {
 
   @Test
   public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
-    final RequestManager child1 = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.emptySet();
-          }
-        }, context);
-    final RequestManager child2 = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.emptySet();
-          }
-        }, context);
-    new RequestManager(Glide.get(context), lifecycle,
+    final RequestManager child1 =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    final RequestManager child2 =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    new RequestManager(
+        Glide.get(context),
+        lifecycle,
         new RequestManagerTreeNode() {
           @NonNull
           @Override
           public Set<RequestManager> getDescendants() {
             return new HashSet<>(java.util.Arrays.asList(child1, child2));
           }
-        }, context);
+        },
+        context);
 
     File file = new File("fake");
     child1.load(file).into(target);
@@ -220,22 +233,30 @@ public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
 
   @Test
   public void clear_withRequestStartedInChildManager_doesNotThrow() {
-    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.emptySet();
-          }
-        }, context);
-    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.singleton(child);
-          }
-        }, context);
+    final RequestManager child =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    RequestManager parent =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.singleton(child);
+              }
+            },
+            context);
 
     File file = new File("fake");
     child.load(file).into(target);
@@ -244,22 +265,30 @@ public void clear_withRequestStartedInChildManager_doesNotThrow() {
 
   @Test
   public void clear_withRequestStartedInParentManager_doesNotThrow() {
-    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.emptySet();
-          }
-        }, context);
-    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
-        new RequestManagerTreeNode() {
-          @NonNull
-          @Override
-          public Set<RequestManager> getDescendants() {
-            return Collections.singleton(child);
-          }
-        }, context);
+    final RequestManager child =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.emptySet();
+              }
+            },
+            context);
+    RequestManager parent =
+        new RequestManager(
+            Glide.get(context),
+            lifecycle,
+            new RequestManagerTreeNode() {
+              @NonNull
+              @Override
+              public Set<RequestManager> getDescendants() {
+                return Collections.singleton(child);
+              }
+            },
+            context);
 
     File file = new File("fake");
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index 6f2fc9d50..5936d466f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -45,9 +45,11 @@ public void setUp() {
 
     context = RuntimeEnvironment.application;
 
-    doAnswer(new Util.WriteDigest("first")).when(first)
+    doAnswer(new Util.WriteDigest("first"))
+        .when(first)
         .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new Util.WriteDigest("second")).when(second)
+    doAnswer(new Util.WriteDigest("second"))
+        .when(second)
         .updateDiskCacheKey(any(MessageDigest.class));
   }
 
@@ -91,7 +93,7 @@ public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformati
 
   @Test
   public void
-  testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
+      testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
     when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
     when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
         .thenReturn(mockResource());
@@ -131,9 +133,7 @@ public void testIntermediateResourcesAreRecycled() {
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
     keyTester
-        .addEquivalenceGroup(
-            new MultiTransformation<>(first),
-            new MultiTransformation<>(first))
+        .addEquivalenceGroup(new MultiTransformation<>(first), new MultiTransformation<>(first))
         .addEquivalenceGroup(new MultiTransformation<>(second))
         .addEquivalenceGroup(new MultiTransformation<>(first, second))
         .addEquivalenceGroup(new MultiTransformation<>(second, first))
@@ -144,6 +144,5 @@ public void testEquals() throws NoSuchAlgorithmException {
             new MultiTransformation<>(first, second),
             "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2")
         .test();
-
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
index 67ee5b193..3dcc19809 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -23,15 +23,17 @@ public void testEquals() {
     Option<Object> secondMemoryOption = Option.memory("secondKey");
     Object secondValue = new Object();
 
-    CacheKeyUpdater<Integer> updater = new CacheKeyUpdater<Integer>() {
-      @Override
-      public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
-          @NonNull MessageDigest messageDigest) {
-        messageDigest.update(keyBytes);
-        messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
-
-      }
-    };
+    CacheKeyUpdater<Integer> updater =
+        new CacheKeyUpdater<Integer>() {
+          @Override
+          public void update(
+              @NonNull byte[] keyBytes,
+              @NonNull Integer value,
+              @NonNull MessageDigest messageDigest) {
+            messageDigest.update(keyBytes);
+            messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
+          }
+        };
     Option<Integer> firstDiskOption = Option.disk("firstDisk", updater);
     Option<Integer> secondDiskOption = Option.disk("secondDisk", updater);
 
@@ -47,20 +49,14 @@ public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
             new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
             new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
             new Options().set(secondMemoryOption, secondValue).set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(new Options().set(firstMemoryOption, secondValue))
+        .addEquivalenceGroup(new Options().set(secondMemoryOption, firstValue))
         .addEquivalenceGroup(
-            new Options().set(firstMemoryOption, secondValue))
-        .addEquivalenceGroup(
-            new Options().set(secondMemoryOption, firstValue))
-        .addEquivalenceGroup(
-            new Options().set(firstDiskOption, 1),
-            new Options().set(firstDiskOption, 1))
-        .addEquivalenceGroup(
-            new Options().set(secondDiskOption, 1),
-            new Options().set(secondDiskOption, 1))
-        .addEquivalenceGroup(
-            new Options().set(firstDiskOption, 2))
+            new Options().set(firstDiskOption, 1), new Options().set(firstDiskOption, 1))
         .addEquivalenceGroup(
-            new Options().set(secondDiskOption, 2))
+            new Options().set(secondDiskOption, 1), new Options().set(secondDiskOption, 1))
+        .addEquivalenceGroup(new Options().set(firstDiskOption, 2))
+        .addEquivalenceGroup(new Options().set(secondDiskOption, 2))
         .addEquivalenceGroup(
             new Options().set(firstDiskOption, 1).set(secondDiskOption, 2),
             new Options().set(secondDiskOption, 2).set(firstDiskOption, 1))
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
index 21e6120a1..cd72f4bf0 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
@@ -40,13 +40,14 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     when(arrayPool.get(anyInt(), eq(byte[].class)))
-        .thenAnswer(new Answer<byte[]>() {
-          @Override
-          public byte[] answer(InvocationOnMock invocation) throws Throwable {
-            int size = (Integer) invocation.getArguments()[0];
-            return new byte[size];
-          }
-        });
+        .thenAnswer(
+            new Answer<byte[]>() {
+              @Override
+              public byte[] answer(InvocationOnMock invocation) throws Throwable {
+                int size = (Integer) invocation.getArguments()[0];
+                return new byte[size];
+              }
+            });
   }
 
   @Test
@@ -84,7 +85,7 @@ private void runTest(Random random) throws IOException {
           bufferedOutputStream.write(write.data, write.offset, write.length);
           break;
         default:
-            throw new IllegalArgumentException();
+          throw new IllegalArgumentException();
       }
     }
 
@@ -96,9 +97,14 @@ private void runTest(Random random) throws IOException {
       for (Write write : writes) {
         writesBuilder.append(write).append("\n");
       }
-      fail("Expected: " + Arrays.toString(fromByteArrayStream) + "\n"
-          + "but got: " + Arrays.toString(fromWrappedStream) + "\n"
-          + writesBuilder.toString());
+      fail(
+          "Expected: "
+              + Arrays.toString(fromByteArrayStream)
+              + "\n"
+              + "but got: "
+              + Arrays.toString(fromWrappedStream)
+              + "\n"
+              + writesBuilder.toString());
     }
   }
 
@@ -149,10 +155,14 @@ private WriteType getType(Random random) {
     @Override
     public String toString() {
       return "Write{"
-          + "data=" + Arrays.toString(data)
-          + ", length=" + length
-          + ", offset=" + offset
-          + ", writeType=" + writeType
+          + "data="
+          + Arrays.toString(data)
+          + ", length="
+          + length
+          + ", offset="
+          + offset
+          + ", writeType="
+          + writeType
           + '}';
     }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
index ab32ce4a5..5299140d1 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.data;
 
-
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
@@ -73,7 +72,7 @@ public void write_withEmptyBuffer_andDataSmallerThanBuffer_doesNotWriteToStream(
 
   @Test
   public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNotWriteToStream()
-    throws IOException {
+      throws IOException {
     int offset = 1;
     int length = bufferSize - offset;
     byte[] data = nextWithOffset(offset, length);
@@ -84,7 +83,7 @@ public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNot
 
   @Test
   public void write_withEmptyBuffer_andDataWithPaddingSizeSmallerThanBuffer_doesNotWriteToStream()
-    throws IOException {
+      throws IOException {
     int padding = 1;
     int length = bufferSize - padding;
     byte[] data = nextWithPadding(length, padding);
@@ -800,53 +799,62 @@ public void flush_withZeroBytesWritten_doesNotWriteToStream() throws IOException
 
   @Test
   public void write_throwsIfOffsetIsLessThanZero() {
-    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
-      }
-    });
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
+          }
+        });
   }
 
   @Test
   public void write_throwsIfLengthIsLessThanZero() {
-    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
-      }
-    });
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
+          }
+        });
   }
 
   @Test
   public void write_throwsIfOffsetIsGreaterThanLength() {
-    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
-      }
-    });
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
+          }
+        });
   }
 
   @Test
   public void write_throwsIfLengthsIsGreaterThanLength() {
-    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
-      }
-    });
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
+          }
+        });
   }
 
-
   @Test
   public void write_throwsIfLengthAndOffsetsIsGreaterThanLength() {
-    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
-      @Override
-      public void run() throws Throwable {
-        os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
-      }
-    });
+    assertThrows(
+        IndexOutOfBoundsException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
+          }
+        });
   }
 
   @Test
@@ -863,7 +871,6 @@ public void write_withZeroLengthBufferAndZeroOffsetAndLength_doesNothing() throw
     assertThat(inner.toByteArray()).hasLength(0);
   }
 
-
   @Test
   public void write_afterWriteWithZeroLengthBuffer_writesExpected() throws IOException {
     os.write(new byte[0]);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index 77c6a93f5..d753c6e95 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -21,8 +21,8 @@
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
-    return TestResourceUtil.openResource(getClass(),
-        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
+    return TestResourceUtil.openResource(
+        getClass(), "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
   }
 
   @Before
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 044bf30e8..a515b740a 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -32,8 +32,8 @@
 
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
- * behavior (connection/disconnection/options) should go in
- * {@link com.bumptech.glide.load.data.HttpUrlFetcherTest}, response handling should go here.
+ * behavior (connection/disconnection/options) should go in {@link
+ * com.bumptech.glide.load.data.HttpUrlFetcherTest}, response handling should go here.
  */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -78,8 +78,10 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   @Test
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -91,8 +93,10 @@ public void testHandlesRedirect301s() throws Exception {
   @Test
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
-    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(302)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -104,8 +108,8 @@ public void testHandlesRedirect302s() throws Exception {
   @Test
   public void testHandlesRelativeRedirects() throws Exception {
     String expected = "fakedata";
-    mockWebServer
-        .enqueue(new MockResponse().setResponseCode(301).setHeader("Location", "/redirect"));
+    mockWebServer.enqueue(
+        new MockResponse().setResponseCode(301).setHeader("Location", "/redirect"));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -124,8 +128,10 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String expected = "redirectedData";
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -145,10 +151,14 @@ public void testHandlesUpToFiveRedirects() throws Exception {
 
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
-    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
+    mockWebServer.enqueue(
+        new MockResponse()
+            .setResponseCode(301)
+            .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -184,8 +194,10 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   @Test
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
-      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
+      mockWebServer.enqueue(
+          new MockResponse()
+              .setResponseCode(301)
+              .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -247,7 +259,7 @@ private HttpUrlFetcher getFetcher() {
 
   private HttpUrlFetcher getFetcher(Headers headers) {
     URL url = mockWebServer.url(DEFAULT_PATH).url();
-    return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
-        HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
+    return new HttpUrlFetcher(
+        new GlideUrl(url, headers), TIMEOUT_TIME_MS, HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 9cd87e418..2b5c68528 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -89,8 +89,7 @@ public void testDoesNotThrowIfCancelCalledBeforeStart() {
   }
 
   @Test
-  public void testCancelDoesNotDisconnectIfAlreadyConnected()
-      throws IOException {
+  public void testCancelDoesNotDisconnectIfAlreadyConnected() throws IOException {
     fetcher.loadData(Priority.HIGH, callback);
     fetcher.cancel();
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index 903ebeea6..77d3f9320 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -58,7 +58,7 @@ public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
-    cursor.addRow(new Object[] { "" });
+    cursor.addRow(new Object[] {""});
     when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
     assertNull(harness.get().open(harness.uri));
   }
@@ -132,7 +132,7 @@ private static ContentResolver getContentResolver() {
     final ArrayPool byteArrayPool = new LruArrayPool();
 
     Harness() {
-      cursor.addRow(new String[] { file.getAbsolutePath() });
+      cursor.addRow(new String[] {file.getAbsolutePath()});
       when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index b4f8e7721..e6cc5deaa 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -27,11 +27,13 @@
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {ContentResolverShadow.class})
 public class FileDescriptorLocalUriFetcherTest {
 
-  @Mock
-  private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   @Before
   public void setUp() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index a1d83a5f6..5826069c9 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -25,10 +25,12 @@
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {ContentResolverShadow.class})
 public class StreamLocalUriFetcherTest {
-  @Mock
-  private DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   @Before
   public void setUp() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
index acc1b6a30..9212dc4f6 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -411,7 +411,7 @@ private void enqueueAndWaitForRef(ResourceWeakReference ref) {
   }
 
   private void waitForLatch(CountDownLatch latch) {
-     try {
+    try {
       latch.await(10, TimeUnit.SECONDS);
     } catch (InterruptedException e) {
       throw new RuntimeException(e);
@@ -421,12 +421,13 @@ private void waitForLatch(CountDownLatch latch) {
 
   private CountDownLatch getLatchForClearedRef() {
     final CountDownLatch toWait = new CountDownLatch(1);
-    resources.setDequeuedResourceCallback(new DequeuedResourceCallback() {
-      @Override
-      public void onResourceDequeued() {
-        toWait.countDown();
-      }
-    });
+    resources.setDequeuedResourceCallback(
+        new DequeuedResourceCallback() {
+          @Override
+          public void onResourceDequeued() {
+            toWait.countDown();
+          }
+        });
     return toWait;
   }
 
@@ -442,7 +443,7 @@ public void onResourceDequeued() {
 
   @SuppressWarnings("unchecked")
   private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
-    return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
-        ArgumentCaptor.forClass(EngineResource.class);
+    return (ArgumentCaptor<EngineResource<?>>)
+        (ArgumentCaptor<?>) ArgumentCaptor.forClass(EngineResource.class);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 2bbc3ad67..acba45e0a 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -29,13 +29,17 @@
   @Before
   public void setUp() throws UnsupportedEncodingException {
     MockitoAnnotations.initMocks(this);
-    doAnswer(new WriteDigest("firstKey")).when(firstKey)
+    doAnswer(new WriteDigest("firstKey"))
+        .when(firstKey)
         .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("firstSignature")).when(firstSignature)
+    doAnswer(new WriteDigest("firstSignature"))
+        .when(firstSignature)
         .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("secondKey")).when(secondKey)
+    doAnswer(new WriteDigest("secondKey"))
+        .when(secondKey)
         .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new WriteDigest("secondSignature")).when(secondSignature)
+    doAnswer(new WriteDigest("secondSignature"))
+        .when(secondSignature)
         .updateDiskCacheKey(any(MessageDigest.class));
   }
 
@@ -43,8 +47,7 @@ public void setUp() throws UnsupportedEncodingException {
   public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
     keyTester
         .addEquivalenceGroup(
-            new DataCacheKey(firstKey, firstSignature),
-            new DataCacheKey(firstKey, firstSignature))
+            new DataCacheKey(firstKey, firstSignature), new DataCacheKey(firstKey, firstSignature))
         .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature))
         .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature))
         .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature))
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 51368f8a7..026f11f88 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -358,7 +358,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
 
   @Test
   public void
-  testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
+      testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
@@ -382,7 +382,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
 
   @Test
   public void
-  testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
+      testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
index b6a469d8b..70ae18033 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -35,15 +35,16 @@ public void setUp() {
   @Test
   public void updateDiskCacheKey_throwsException() throws NoSuchAlgorithmException {
     // If this test fails, update testEqualsAndHashcode to use KeyTester including regression tests.
-    final EngineKey key = new EngineKey(
-        "id",
-        new ObjectKey("signature"),
-        100,
-        100,
-        Collections.<Class<?>, Transformation<?>>emptyMap(),
-        Object.class,
-        Object.class,
-        new Options());
+    final EngineKey key =
+        new EngineKey(
+            "id",
+            new ObjectKey("signature"),
+            100,
+            100,
+            Collections.<Class<?>, Transformation<?>>emptyMap(),
+            Object.class,
+            Object.class,
+            new Options());
     assertThrows(
         UnsupportedOperationException.class,
         new ThrowingRunnable() {
@@ -60,15 +61,20 @@ public void testEqualsAndHashCode() {
     memoryOptions.set(Option.memory("key", new Object()), new Object());
 
     Options diskOptions = new Options();
-    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
-      @Override
-      public void update(@NonNull byte[] keyBytes, @NonNull String value,
-          @NonNull MessageDigest messageDigest) {
-        messageDigest.update(keyBytes);
-        messageDigest.update(value.getBytes(Key.CHARSET));
-
-      }
-    }), "value");
+    diskOptions.set(
+        Option.disk(
+            "key",
+            new CacheKeyUpdater<String>() {
+              @Override
+              public void update(
+                  @NonNull byte[] keyBytes,
+                  @NonNull String value,
+                  @NonNull MessageDigest messageDigest) {
+                messageDigest.update(keyBytes);
+                messageDigest.update(value.getBytes(Key.CHARSET));
+              }
+            }),
+        "value");
 
     new EqualsTester()
         .addEqualityGroup(
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index 954e4f1b7..744749eca 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -101,17 +101,19 @@ public void testThrowsIfAcquiredAfterRecycled() {
 
   @Test
   public void testThrowsIfAcquiredOnBackgroundThread() throws InterruptedException {
-    Thread otherThread = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          engineResource.acquire();
-        } catch (IllegalThreadStateException e) {
-          return;
-        }
-        fail("Failed to receive expected IllegalThreadStateException");
-      }
-    });
+    Thread otherThread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  engineResource.acquire();
+                } catch (IllegalThreadStateException e) {
+                  return;
+                }
+                fail("Failed to receive expected IllegalThreadStateException");
+              }
+            });
     otherThread.start();
     otherThread.join();
   }
@@ -119,17 +121,19 @@ public void run() {
   @Test
   public void testThrowsIfReleasedOnBackgroundThread() throws InterruptedException {
     engineResource.acquire();
-    Thread otherThread = new Thread(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          engineResource.release();
-        } catch (IllegalThreadStateException e) {
-          return;
-        }
-        fail("Failed to receive expected IllegalThreadStateException");
-      }
-    });
+    Thread otherThread =
+        new Thread(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  engineResource.release();
+                } catch (IllegalThreadStateException e) {
+                  return;
+                }
+                fail("Failed to receive expected IllegalThreadStateException");
+              }
+            });
     otherThread.start();
     otherThread.join();
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 172c8b1d7..63449dd8a 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -45,7 +45,10 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {GlideShadowLooper.class})
 @SuppressWarnings("unchecked")
 public class EngineTest {
   private EngineTestHarness harness;
@@ -202,7 +205,8 @@ public void testResourceIsReturnedFromCacheIfPresent() {
   @Test
   public void testHandlesNonEngineResourcesFromCacheIfPresent() {
     final Object expected = new Object();
-    @SuppressWarnings("rawtypes") Resource fromCache = mockResource();
+    @SuppressWarnings("rawtypes")
+    Resource fromCache = mockResource();
     when(fromCache.get()).thenReturn(expected);
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
 
@@ -384,20 +388,28 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
     harness.doLoad();
 
     verify(harness.keyFactory)
-        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),
-            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));
+        .buildKey(
+            eq(harness.model),
+            eq(harness.signature),
+            eq(harness.width),
+            eq(harness.height),
+            eq(harness.transformations),
+            eq(Object.class),
+            eq(Object.class),
+            eq(harness.options));
   }
 
   @Test
   public void testFactoryIsGivenNecessaryArguments() {
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(
-        eq(harness.cacheKey),
-        eq(true) /*isMemoryCacheable*/,
-        eq(false) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false),
-        /*onlyRetrieveFromCache=*/ eq(false));
+    verify(harness.engineJobFactory)
+        .build(
+            eq(harness.cacheKey),
+            eq(true) /*isMemoryCacheable*/,
+            eq(false) /*useUnlimitedSourceGeneratorPool*/,
+            /*useAnimationPool=*/ eq(false),
+            /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -405,12 +417,13 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
     harness.useUnlimitedSourceGeneratorPool = true;
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(
-        eq(harness.cacheKey),
-        eq(true) /*isMemoryCacheable*/,
-        eq(true) /*useUnlimitedSourceGeneratorPool*/,
-        /*useAnimationPool=*/ eq(false),
-        /*onlyRetrieveFromCache=*/ eq(false));
+    verify(harness.engineJobFactory)
+        .build(
+            eq(harness.cacheKey),
+            eq(true) /*isMemoryCacheable*/,
+            eq(true) /*useUnlimitedSourceGeneratorPool*/,
+            /*useAnimationPool=*/ eq(false),
+            /*onlyRetrieveFromCache=*/ eq(false));
   }
 
   @Test
@@ -427,12 +440,13 @@ public void testThrowsIfAskedToReleaseNonEngineResource() {
 
   @Test
   public void load_whenCalledOnBackgroundThread_doesNotThrow() throws InterruptedException {
-    BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() {
-        harness.doLoad();
-      }
-    });
+    BackgroundUtil.testInBackground(
+        new BackgroundUtil.BackgroundTester() {
+          @Override
+          public void runTest() {
+            harness.doLoad();
+          }
+        });
   }
 
   @Test
@@ -579,7 +593,8 @@ public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLo
   @Test
   public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
     harness.doLoad();
-    harness.getEngine()
+    harness
+        .getEngine()
         .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
 
     harness.job = mock(EngineJob.class);
@@ -591,8 +606,7 @@ public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
   @Test
   public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
     harness.doLoad();
-    harness.getEngine()
-        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
     harness.job = mock(EngineJob.class);
     harness.doLoad();
@@ -600,12 +614,12 @@ public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
     verify(harness.job, never()).start(any(DecodeJob.class));
   }
 
-
   @Test
   public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
     harness.onlyRetrieveFromCache = true;
     harness.doLoad();
-    harness.getEngine()
+    harness
+        .getEngine()
         .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
 
     harness.job = mock(EngineJob.class);
@@ -618,8 +632,7 @@ public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNot
   public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
     harness.onlyRetrieveFromCache = true;
     harness.doLoad();
-    harness.getEngine()
-        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
 
     harness.job = mock(EngineJob.class);
     harness.doLoad();
@@ -631,8 +644,10 @@ public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNo
     final EngineKey cacheKey = mock(EngineKey.class);
     final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
+
     @SuppressWarnings("rawtypes")
     final EngineResource resource = mock(EngineResource.class);
+
     final Jobs jobs = new Jobs();
     final ActiveResources activeResources =
         new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
@@ -657,8 +672,16 @@ public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNo
     final boolean isScaleOnlyOrNoTransform = true;
 
     EngineTestHarness() {
-      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
-          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+      when(keyFactory.buildKey(
+              eq(model),
+              eq(signature),
+              anyInt(),
+              anyInt(),
+              eq(transformations),
+              eq(Object.class),
+              eq(Object.class),
+              eq(options)))
+          .thenReturn(cacheKey);
       when(resource.getResource()).thenReturn(mock(Resource.class));
 
       job = mock(EngineJob.class);
@@ -668,10 +691,8 @@ void callOnEngineJobComplete() {
       getEngine().onEngineJobComplete(job, cacheKey, resource);
     }
 
-
     Engine.LoadStatus doLoad() {
-      when(
-          engineJobFactory.build(
+      when(engineJobFactory.build(
               eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
       when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
@@ -719,5 +740,4 @@ Engine getEngine() {
       return engine;
     }
   }
-
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
index bcefcbb1a..d44b9fb1d 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -38,9 +38,11 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     arrayPool = new LruArrayPool();
-    doAnswer(new Util.WriteDigest("transformation1")).when(transformation1)
+    doAnswer(new Util.WriteDigest("transformation1"))
+        .when(transformation1)
         .updateDiskCacheKey(any(MessageDigest.class));
-    doAnswer(new Util.WriteDigest("transformation1")).when(transformation2)
+    doAnswer(new Util.WriteDigest("transformation1"))
+        .when(transformation2)
         .updateDiskCacheKey(any(MessageDigest.class));
   }
 
@@ -50,15 +52,20 @@ public void testEqualsAndHashCode() {
     memoryOptions.set(Option.memory("key", new Object()), new Object());
 
     Options diskOptions = new Options();
-    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
-      @Override
-      public void update(@NonNull byte[] keyBytes, @NonNull String value,
-          @NonNull MessageDigest messageDigest) {
-        messageDigest.update(keyBytes);
-        messageDigest.update(value.getBytes(Key.CHARSET));
-
-      }
-    }), "value");
+    diskOptions.set(
+        Option.disk(
+            "key",
+            new CacheKeyUpdater<String>() {
+              @Override
+              public void update(
+                  @NonNull byte[] keyBytes,
+                  @NonNull String value,
+                  @NonNull MessageDigest messageDigest) {
+                messageDigest.update(keyBytes);
+                messageDigest.update(value.getBytes(Key.CHARSET));
+              }
+            }),
+        "value");
 
     for (int i = 0; i < 20; i++) {
       byte[] array = new byte[9];
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
index 80405ffc9..ac886190a 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -38,13 +38,16 @@ public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
   public void testDoesNotRecycleChildResourceSynchronously() {
     Resource<?> parent = mockResource();
     final Resource<?> child = mockResource();
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        recycler.recycle(child);
-        return null;
-      }
-    }).when(parent).recycle();
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                recycler.recycle(child);
+                return null;
+              }
+            })
+        .when(parent)
+        .recycle();
 
     Shadows.shadowOf(Looper.getMainLooper()).pause();
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
index 5ee47b04b..a1de035ca 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -42,8 +42,12 @@ public void testEquality() {
     Key fifth = new Key(keyPool);
     fifth.init(100, 100, Bitmap.Config.RGB_565);
 
-    new EqualsTester().addEqualityGroup(first, second).addEqualityGroup(third)
-        .addEqualityGroup(fourth).addEqualityGroup(fifth).testEquals();
+    new EqualsTester()
+        .addEqualityGroup(first, second)
+        .addEqualityGroup(third)
+        .addEqualityGroup(fourth)
+        .addEqualityGroup(fifth)
+        .testEquals();
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index fe3f959f1..3824bb94f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -30,8 +30,8 @@ public void testIGetNullIfNoMatchingBitmapExists() {
   public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
-    assertEquals(bitmap,
-        strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
+    assertEquals(
+        bitmap, strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
   }
 
   @Test
@@ -101,6 +101,7 @@ public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
     Bitmap removed = strategy.removeLast();
     assertEquals(
         "Expected=" + strategy.logBitmap(leastRecentlyUsed) + " got=" + strategy.logBitmap(removed),
-        leastRecentlyUsed, removed);
+        leastRecentlyUsed,
+        removed);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
index 3139df1a8..eca224b5d 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -22,7 +22,7 @@ public void setUp() {
 
   @Test
   public void testReturnsNullForGetWithNoBitmap() {
-    Key key =  new Key("key", /*width=*/ 1, /*height=*/ 1);
+    Key key = new Key("key", /*width=*/ 1, /*height=*/ 1);
     assertNull(map.get(key));
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index fda944cd7..3ab1274d2 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -64,12 +64,13 @@ public void testItIsSizeLimited() {
 
   @Test
   public void testBitmapLargerThanPoolIsNotAdded() {
-    strategy = new MockStrategy() {
-      @Override
-      public int getSize(Bitmap bitmap) {
-        return 4;
-      }
-    };
+    strategy =
+        new MockStrategy() {
+          @Override
+          public int getSize(Bitmap bitmap) {
+            return 4;
+          }
+        };
     pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);
     pool.put(createMutableBitmap());
     assertEquals(0, strategy.numRemoves);
@@ -114,7 +115,7 @@ public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull()
 
   @Test
   public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
@@ -215,7 +216,8 @@ public void testBitmapsWithDisallowedConfigsAreIgnored() {
     assertEquals(0, strategy.numPuts);
   }
 
-  @Test @Config(sdk = 19)
+  @Test
+  @Config(sdk = 19)
   public void testBitmapsWithAllowedNullConfigsAreAllowed() {
     pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));
 
@@ -241,7 +243,6 @@ private Bitmap createMutableBitmap(Bitmap.Config config) {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, config);
     Shadows.shadowOf(bitmap).setMutable(true);
     return bitmap;
-
   }
 
   private static class MockStrategy implements LruPoolStrategy {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
index c37b5946a..ddfd6d4ab 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -12,8 +12,7 @@
 @RunWith(JUnit4.class)
 public class SizeConfigStrategyTest {
 
-  @Mock
-  private SizeConfigStrategy.KeyPool pool;
+  @Mock private SizeConfigStrategy.KeyPool pool;
 
   @Before
   public void setUp() {
@@ -25,8 +24,7 @@ public void testKeyEquals() {
     new EqualsTester()
         .addEqualityGroup(
             new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
-            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
-        )
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888))
         .addEqualityGroup(new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888))
         .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565))
         .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, null /*config*/))
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index 24a1098e7..cefa0ad44 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -33,7 +33,7 @@ public void setUp() {
     dir = RuntimeEnvironment.application.getCacheDir();
     cache = DiskLruCacheWrapper.create(dir, 10 * 1024 * 1024);
     key = new ObjectKey("test" + Math.random());
-    data = new byte[] { 1, 2, 3, 4, 5, 6 };
+    data = new byte[] {1, 2, 3, 4, 5, 6};
   }
 
   @After
@@ -63,17 +63,19 @@ private static void deleteRecursive(File file) {
 
   @Test
   public void testCanInsertAndGet() throws IOException {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(@NonNull File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return true;
-      }
-    });
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return true;
+          }
+        });
 
     byte[] received = Util.readFile(cache.get(key), data.length);
 
@@ -82,29 +84,33 @@ public boolean write(@NonNull File file) {
 
   @Test
   public void testDoesNotCommitIfWriterReturnsFalse() {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(@NonNull File file) {
-        return false;
-      }
-    });
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            return false;
+          }
+        });
 
     assertNull(cache.get(key));
   }
 
   @Test
   public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(@NonNull File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return false;
-      }
-    });
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return false;
+          }
+        });
 
     assertNull(cache.get(key));
   }
@@ -112,27 +118,31 @@ public boolean write(@NonNull File file) {
   @Test
   public void testEditIsAbortedIfWriterThrows() throws IOException {
     try {
-      cache.put(key, new DiskCache.Writer() {
-        @Override
-        public boolean write(@NonNull File file) {
-          throw new RuntimeException("test");
-        }
-      });
+      cache.put(
+          key,
+          new DiskCache.Writer() {
+            @Override
+            public boolean write(@NonNull File file) {
+              throw new RuntimeException("test");
+            }
+          });
     } catch (RuntimeException e) {
       // Expected.
     }
 
-    cache.put(key, new DiskCache.Writer() {
-      @Override
-      public boolean write(@NonNull File file) {
-        try {
-          Util.writeFile(file, data);
-        } catch (IOException e) {
-          fail(e.toString());
-        }
-        return true;
-      }
-    });
+    cache.put(
+        key,
+        new DiskCache.Writer() {
+          @Override
+          public boolean write(@NonNull File file) {
+            try {
+              Util.writeFile(file, data);
+            } catch (IOException e) {
+              fail(e.toString());
+            }
+            return true;
+          }
+        });
 
     byte[] received = Util.readFile(cache.get(key), data.length);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 22b76cfc1..cc8d5a6c0 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -163,14 +163,15 @@ public void testPreventEviction() {
     Resource<?> third = getResource(30);
     Key thirdKey = new MockKey();
     cache.put(thirdKey, third);
-    cache.setResourceRemovedListener(new ResourceRemovedListener() {
-      @Override
-      public void onResourceRemoved(@NonNull Resource<?> removed) {
-        if (removed == first) {
-          cache.put(firstKey, first);
-        }
-      }
-    });
+    cache.setResourceRemovedListener(
+        new ResourceRemovedListener() {
+          @Override
+          public void onResourceRemoved(@NonNull Resource<?> removed) {
+            if (removed == first) {
+              cache.put(firstKey, first);
+            }
+          }
+        });
 
     // trims from 100 to 50, having 30+30+30 items, it should trim to 1 item
     cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index ae2eb4bd6..a7d0c8c75 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -68,8 +68,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat(memoryCacheSize)
-        .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
+    assertThat(memoryCacheSize).isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
   @Test
@@ -106,9 +105,11 @@ public void testDefaultBitmapPoolSizeIsLimitedByMemoryClass() {
 
   @Test
   public void testCumulativePoolAndMemoryCacheSizeAreLimitedByMemoryClass() {
-    final int memoryClassBytes = Math.round(
-        harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
-            * harness.sizeMultiplier);
+    final int memoryClassBytes =
+        Math.round(
+            harness.getScreenSize()
+                * (harness.bitmapPoolScreens + harness.memoryCacheScreens)
+                * harness.sizeMultiplier);
     Shadows.shadowOf(harness.activityManager).setMemoryClass(memoryClassBytes / (1024 * 1024));
 
     int memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 7a9e74be1..88f349191 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -21,12 +21,15 @@ public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
     GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
-      executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
-        @Override
-        public void onRun(int priority) {
-          resultPriorities.add(priority);
-        }
-      }));
+      executor.execute(
+          new MockRunnable(
+              i,
+              new MockRunnable.OnRun() {
+                @Override
+                public void onRun(int priority) {
+                  resultPriorities.add(priority);
+                }
+              }));
     }
 
     executor.shutdown();
@@ -37,8 +40,7 @@ public void onRun(int priority) {
     assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
   }
 
-  private static final class MockRunnable implements Runnable,
-      Comparable<MockRunnable> {
+  private static final class MockRunnable implements Runnable, Comparable<MockRunnable> {
     private final int priority;
     private final OnRun onRun;
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
index 94ef1782c..bd47ba690 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -10,9 +10,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 
-/**
- * Creates mock {@link GlideExecutor}s.
- */
+/** Creates mock {@link GlideExecutor}s. */
 @VisibleForTesting
 public final class MockGlideExecutor {
   private MockGlideExecutor() {
@@ -29,9 +27,7 @@ public static GlideExecutor newMainThreadExecutor() {
     return newTestExecutor(new DirectExecutorService());
   }
 
-  /**
-   * @deprecated Use {@link #newMainThreadExecutor} instead.
-   */
+  /** @deprecated Use {@link #newMainThreadExecutor} instead. */
   @Deprecated
   public static GlideExecutor newMainThreadUnlimitedExecutor() {
     return newMainThreadExecutor();
@@ -43,10 +39,7 @@ public static GlideExecutor newMainThreadUnlimitedExecutor() {
    */
   private static final class DirectExecutorService extends ForwardingExecutorService {
     private static final StrictMode.ThreadPolicy THREAD_POLICY =
-        new StrictMode.ThreadPolicy.Builder()
-            .detectNetwork()
-            .penaltyDeath()
-            .build();
+        new StrictMode.ThreadPolicy.Builder().detectNetwork().penaltyDeath().build();
 
     private final ExecutorService delegate;
 
@@ -79,18 +72,19 @@ protected ExecutorService delegate() {
 
     @Override
     public void execute(@NonNull final Runnable command) {
-      delegate.execute(new Runnable() {
-        @Override
-        public void run() {
-          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
-          StrictMode.setThreadPolicy(THREAD_POLICY);
-          try {
-            command.run();
-          } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-          }
-        }
-      });
+      delegate.execute(
+          new Runnable() {
+            @Override
+            public void run() {
+              StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+              StrictMode.setThreadPolicy(THREAD_POLICY);
+              try {
+                command.run();
+              } finally {
+                StrictMode.setThreadPolicy(oldPolicy);
+              }
+            }
+          });
     }
 
     private <T> Future<T> getUninterruptibly(Future<T> future) {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index 7680c43a7..0c81d967b 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -63,8 +63,8 @@ public void setUp() {
   }
 
   private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {
-    return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock,
-        mainHandler);
+    return new BitmapPreFillRunner(
+        pool, cache, new PreFillQueue(allocationOrder), clock, mainHandler);
   }
 
   @Test
@@ -89,7 +89,9 @@ public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {
         new PreFillType.Builder(100, 50).setConfig(Bitmap.Config.RGB_565).build();
 
     PreFillType[] expectedOrder =
-        new PreFillType[] { smallWidth, smallHeight, smallWidth, smallHeight, };
+        new PreFillType[] {
+          smallWidth, smallHeight, smallWidth, smallHeight,
+        };
 
     HashMap<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(smallWidth, 2);
@@ -160,14 +162,18 @@ public void testPreFillHandlerPostsWithBackoffIfHasBitmapsToAllocateAfterRunning
     handler.run();
     verify(mainHandler).postDelayed(eq(handler), eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS));
 
-    when(clock.now()).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS).thenReturn(
-        BitmapPreFillRunner.MAX_DURATION_MS
-            + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
+    when(clock.now())
+        .thenReturn(BitmapPreFillRunner.MAX_DURATION_MS)
+        .thenReturn(
+            BitmapPreFillRunner.MAX_DURATION_MS
+                + BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO);
 
     handler.run();
 
-    verify(mainHandler).postDelayed(eq(handler),
-        eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
+    verify(mainHandler)
+        .postDelayed(
+            eq(handler),
+            eq(BitmapPreFillRunner.INITIAL_BACKOFF_MS * BitmapPreFillRunner.BACKOFF_RATIO));
 
     when(clock.now()).thenReturn(0L).thenReturn(BitmapPreFillRunner.MAX_DURATION_MS);
     handler.run();
@@ -202,7 +208,8 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
     when(cache.getMaxSize()).thenReturn(Long.valueOf(Util.getBitmapByteSize(bitmap)));
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -221,7 +228,8 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
     when(cache.getMaxSize()).thenReturn(0L);
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -240,7 +248,8 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
     when(cache.getMaxSize()).thenReturn((long) Util.getBitmapByteSize(bitmap) / 2);
 
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
     allocationOrder.put(size, 1);
@@ -249,20 +258,22 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
 
     verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
-    //verify(pool).put(eq(bitmap));
-    //assertThat(addedBitmaps).containsExactly(bitmap);
+    // verify(pool).put(eq(bitmap));
+    // assertThat(addedBitmaps).containsExactly(bitmap);
   }
 
   @Test
   public void testDoesAGetFromPoolBeforeAddingForEachSize() {
     Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     PreFillType firstSize =
-        new PreFillType.Builder(first.getWidth(), first.getHeight()).setConfig(first.getConfig())
+        new PreFillType.Builder(first.getWidth(), first.getHeight())
+            .setConfig(first.getConfig())
             .build();
 
     Bitmap second = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     PreFillType secondSize =
-        new PreFillType.Builder(second.getWidth(), second.getHeight()).setConfig(second.getConfig())
+        new PreFillType.Builder(second.getWidth(), second.getHeight())
+            .setConfig(second.getConfig())
             .build();
 
     Map<PreFillType, Integer> allocationOrder = new HashMap<>();
@@ -272,13 +283,15 @@ public void testDoesAGetFromPoolBeforeAddingForEachSize() {
     getHandler(allocationOrder).run();
 
     InOrder firstOrder = inOrder(pool);
-    firstOrder.verify(pool).getDirty(eq(first.getWidth()), eq(first.getHeight()),
-        eq(first.getConfig()));
+    firstOrder
+        .verify(pool)
+        .getDirty(eq(first.getWidth()), eq(first.getHeight()), eq(first.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // firstOrder.verify(pool).put(eq(first));
 
     InOrder secondOrder = inOrder(pool);
-    secondOrder.verify(pool)
+    secondOrder
+        .verify(pool)
         .getDirty(eq(second.getWidth()), eq(second.getHeight()), eq(second.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // secondOrder.verify(pool).put(eq(second));
@@ -288,7 +301,8 @@ public void testDoesAGetFromPoolBeforeAddingForEachSize() {
   public void testDoesNotGetMoreThanOncePerSize() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     PreFillType size =
-        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
+        new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight())
+            .setConfig(bitmap.getConfig())
             .build();
 
     final int numBitmaps = 5;
@@ -298,8 +312,9 @@ public void testDoesNotGetMoreThanOncePerSize() {
     getHandler(allocationOrder).run();
 
     InOrder order = inOrder(pool);
-    order.verify(pool).getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()),
-        eq(bitmap.getConfig()));
+    order
+        .verify(pool)
+        .getDirty(eq(bitmap.getWidth()), eq(bitmap.getHeight()), eq(bitmap.getConfig()));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index d5a777f69..e556f7baf 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -73,13 +73,18 @@ public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
 
   @Test
   public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
-    PreFillType[] sizes = new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build(), };
+    PreFillType[] sizes =
+        new PreFillType[] {
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+          new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+              .setConfig(defaultBitmapConfig)
+              .build(),
+        };
     PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(sizes);
 
     int byteSize = 0;
@@ -103,13 +108,17 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build());
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
@@ -123,13 +132,19 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).setWeight(4).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build(),
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-            .setConfig(defaultBitmapConfig).setWeight(3).build());
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .setWeight(4)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build(),
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
+                .setConfig(defaultBitmapConfig)
+                .setWeight(3)
+                .build());
 
     long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
@@ -161,12 +176,13 @@ public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
   public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillType smallHeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     int numSmallWidth = 0, numSmallHeight = 0;
     while (!allocationOrder.isEmpty()) {
@@ -187,9 +203,12 @@ public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
   public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualWeights() {
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
-    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-        .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
+    PreFillType normal =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, normal);
 
     int numSmallWidth = 0, numNormal = 0;
@@ -211,9 +230,13 @@ public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualW
   public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequalWeights() {
     PreFillType doubleWeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).setWeight(2).build();
-    PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-        .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .setWeight(2)
+            .build();
+    PreFillType normal =
+        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(doubleWeight, normal);
 
     int numDoubleWeight = 0, numNormal = 0;
@@ -237,10 +260,12 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
     when(cache.getMaxSize()).thenReturn(defaultBitmapSize);
     PreFillType smallWidth =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
     PreFillType smallHeight =
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build();
+            .setConfig(defaultBitmapConfig)
+            .build();
 
     PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
@@ -251,10 +276,12 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
 
     // Either width, height, width, height or height, width, height, width.
     try {
-      assertThat(attributes).containsExactly(smallWidth, smallHeight, smallWidth, smallHeight)
+      assertThat(attributes)
+          .containsExactly(smallWidth, smallHeight, smallWidth, smallHeight)
           .inOrder();
     } catch (AssertionError e) {
-      assertThat(attributes).containsExactly(smallHeight, smallWidth, smallHeight, smallWidth)
+      assertThat(attributes)
+          .containsExactly(smallHeight, smallWidth, smallHeight, smallWidth)
           .inOrder();
     }
   }
@@ -269,9 +296,12 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     bitmapPreFiller.preFill(builder);
 
     InOrder order = inOrder(builder);
-    order.verify(builder).setConfig(
-        DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
+    order
+        .verify(builder)
+        .setConfig(
+            DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+                ? Bitmap.Config.ARGB_8888
+                : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
index bd14089f4..45a2ac31b 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -64,11 +64,14 @@ public void testGetWeightReturnsGivenWeight() {
 
   @Test
   public void testEquality() {
-    new EqualsTester().addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
-        new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
+    new EqualsTester()
+        .addEqualityGroup(
+            new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1),
+            new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(200, 100, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(100, 200, Bitmap.Config.ARGB_4444, 1))
         .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_8888, 1))
-        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2)).testEquals();
+        .addEqualityGroup(new PreFillType(100, 100, Bitmap.Config.ARGB_4444, 2))
+        .testEquals();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index d1670029e..b4d28e40f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -43,6 +43,7 @@ public void testHandlesAssetUris() {
     assertEquals(
         fetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options())).fetcher);
+                loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options()))
+            .fetcher);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index 80eb81666..2fe39587a 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -47,7 +47,8 @@ public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
     Object expected = new Object();
     when(converter.convert(eq(data))).thenReturn(expected);
 
-    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options)).fetcher
+    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options))
+        .fetcher
         .loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(eq(expected));
   }
@@ -57,7 +58,8 @@ public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
     assertEquals(
         Object.class,
-        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options)).fetcher
+        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options))
+            .fetcher
             .getDataClass());
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 440516b26..7b8c24899 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -24,29 +24,28 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link DataUrlLoader} class.
- */
+/** Tests for the {@link DataUrlLoader} class. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DataUrlLoaderTest {
 
   // A valid base64-encoded PNG (a small "Google" logo).
   @SuppressWarnings("SpellCheckingInspection")
-  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
-      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
-      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
-      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
-      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
-      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
-      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
-      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
-      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
-      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
-      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
-      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
-      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
-      + "AASUVORK5CYII=";
+  private static final String VALID_PNG =
+      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCAYAAAAeEY8BAAADFElEQVR42mNgAAK5ig+Cii"
+          + "UfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtCmTHkFfO/iCsUfTykUPFeASH6n1Es+3Wj"
+          + "SM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n8Gxv/7pTT+75PQBrFh4iq5b/lk8z"
+          + "+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EWPgpx6n4U4Wx7J8De86aP2blr"
+          + "rgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2GYE57DMCdi6Qs3N+6HIc"
+          + "4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72Gq066K//vZe//v4cD"
+          + "ru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2TKIZb1eIpL1ej"
+          + "co3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LOf98PEhPL"
+          + "ftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1qdFy"
+          + "R+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+          + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtg"
+          + "BxDNABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf"
+          + "7ZRKeyYCjsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbx"
+          + "BBmvLaD+cAAAAASUVORK5CYII=";
 
   private static final String INVALID_URL_WRONG_SCHEME1 = "test";
   private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
@@ -54,8 +53,7 @@
   private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOT_BASE64";
   private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
 
-  @Mock
-  private MultiModelLoaderFactory multiFactory;
+  @Mock private MultiModelLoaderFactory multiFactory;
   private DataUrlLoader<String, InputStream> dataUrlLoader;
   private DataFetcher<InputStream> fetcher;
   private Options options;
@@ -83,8 +81,8 @@ public void testHandleFalseDataUri() {
 
   @Test
   public void testDecode() throws IOException {
-    byte[] expected = Base64
-        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    byte[] expected =
+        Base64.decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 6bc1ddd29..a80c298ed 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -69,11 +69,13 @@ public void testProducesEquivalentStringFromURL() throws MalformedURLException {
   @Test
   public void testIssue133() throws MalformedURLException {
     // u00e0=
-    final String original = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-        + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
+    final String original =
+        "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+            + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";
 
-    final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
-        + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
+    final String escaped =
+        "http://www.commitstrip.com/wp-content/uploads/2014/07/"
+            + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";
 
     GlideUrl glideUrlFromString = new GlideUrl(original);
     assertEquals(escaped, glideUrlFromString.toURL().toString());
@@ -109,19 +111,10 @@ public void testEquals() throws MalformedURLException {
             new GlideUrl(url),
             new GlideUrl(url),
             new GlideUrl(new URL(url)),
-            new GlideUrl(new URL(url))
-        )
-        .addEqualityGroup(
-            new GlideUrl(otherUrl),
-            new GlideUrl(new URL(otherUrl))
-        )
-        .addEqualityGroup(
-            new GlideUrl(url, headers),
-            new GlideUrl(new URL(url), headers)
-        )
-        .addEqualityGroup(
-            new GlideUrl(url, otherHeaders),
-            new GlideUrl(new URL(url), otherHeaders)
-        ).testEquals();
+            new GlideUrl(new URL(url)))
+        .addEqualityGroup(new GlideUrl(otherUrl), new GlideUrl(new URL(otherUrl)))
+        .addEqualityGroup(new GlideUrl(url, headers), new GlideUrl(new URL(url), headers))
+        .addEqualityGroup(new GlideUrl(url, otherHeaders), new GlideUrl(new URL(url), otherHeaders))
+        .testEquals();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index b0e2d1402..af4324cde 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -38,8 +38,7 @@ public void tearDown() {
   // Tests for #2331.
   @Test
   public void getSanitizedUserAgent_withInvalidAgent_returnsAgentWithInvalidCharactersRemoved() {
-    String invalidUserAgent =
-        "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G(A8H8) Build/LRX21M)";
+    String invalidUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G(A8H8) Build/LRX21M)";
     String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G???(A8H8) Build/LRX21M)";
     System.setProperty(DEFAULT_USER_AGENT_PROPERTY, invalidUserAgent);
     assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
@@ -74,10 +73,7 @@ public void getSanitizedUserAgent_withWhitespace_returnsWhitespaceString() {
 
   @Test
   public void testIncludesEagerHeaders() {
-    Map<String, String> headers = new Builder()
-        .addHeader("key", "value")
-        .build()
-        .getHeaders();
+    Map<String, String> headers = new Builder().addHeader("key", "value").build().getHeaders();
     assertThat(headers).containsEntry("key", "value");
   }
 
@@ -85,21 +81,15 @@ public void testIncludesEagerHeaders() {
   public void testIncludesLazyHeaders() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("value");
-    Map<String, String> headers = new Builder()
-        .addHeader("key", factory)
-        .build()
-        .getHeaders();
+    Map<String, String> headers = new Builder().addHeader("key", factory).build().getHeaders();
 
     assertThat(headers).containsEntry("key", "value");
   }
 
   @Test
   public void testMultipleEagerValuesAreSeparatedByCommas() {
-    Map<String, String> headers = new Builder()
-        .addHeader("key", "first")
-        .addHeader("key", "second")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", "first").addHeader("key", "second").build().getHeaders();
 
     assertThat(headers).containsEntry("key", "first,second");
   }
@@ -111,11 +101,8 @@ public void testMultipleLazyValuesAreSeparatedByCommas() {
     LazyHeaderFactory second = mock(LazyHeaderFactory.class);
     when(second.buildHeader()).thenReturn("second");
 
-    Map<String, String> headers = new Builder()
-        .addHeader("key", first)
-        .addHeader("key", second)
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", first).addHeader("key", second).build().getHeaders();
     assertThat(headers).containsEntry("key", "first,second");
   }
 
@@ -123,19 +110,13 @@ public void testMultipleLazyValuesAreSeparatedByCommas() {
   public void testMixedEagerAndLazyValuesAreIncluded() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("first");
-    Map<String, String> headers = new Builder()
-        .addHeader("key", factory)
-        .addHeader("key", "second")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("key", factory).addHeader("key", "second").build().getHeaders();
 
     assertThat(headers).containsEntry("key", "first,second");
 
-    headers = new Builder()
-        .addHeader("key", "second")
-        .addHeader("key", factory)
-        .build()
-        .getHeaders();
+    headers =
+        new Builder().addHeader("key", "second").addHeader("key", factory).build().getHeaders();
 
     assertThat(headers).containsEntry("key", "second,first");
   }
@@ -144,11 +125,8 @@ public void testMixedEagerAndLazyValuesAreIncluded() {
   public void testCanAddMultipleKeys() {
     LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
     when(factory.buildHeader()).thenReturn("lazy");
-    Map<String, String> headers = new Builder()
-        .addHeader("first", factory)
-        .addHeader("second", "eager")
-        .build()
-        .getHeaders();
+    Map<String, String> headers =
+        new Builder().addHeader("first", factory).addHeader("second", "eager").build().getHeaders();
 
     assertThat(headers).containsEntry("first", "lazy");
     assertThat(headers).containsEntry("second", "eager");
@@ -179,9 +157,7 @@ public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
   @Test
   public void testSetHeaderReplacesExistingHeaders() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
-        .addHeader("key", "second")
-        .setHeader("key", "third");
+    builder.addHeader("key", "first").addHeader("key", "second").setHeader("key", "third");
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).containsEntry("key", "third");
   }
@@ -189,9 +165,7 @@ public void testSetHeaderReplacesExistingHeaders() {
   @Test
   public void testSetHeaderWithNullStringRemovesExistingHeader() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
-        .addHeader("key", "second")
-        .setHeader("key", (String) null);
+    builder.addHeader("key", "first").addHeader("key", "second").setHeader("key", (String) null);
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("key");
   }
@@ -199,7 +173,8 @@ public void testSetHeaderWithNullStringRemovesExistingHeader() {
   @Test
   public void testSetHeaderWithNullLazyHeaderFactoryRemovesExistingHeader() {
     Builder builder = new Builder();
-    builder.addHeader("key", "first")
+    builder
+        .addHeader("key", "first")
         .addHeader("key", "second")
         .setHeader("key", (LazyHeaderFactory) null);
     LazyHeaders headers = builder.build();
@@ -267,13 +242,15 @@ public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
   @Test
   public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
     Builder builder = new Builder();
-    builder.setHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return null;
-      }
-    });
+    builder.setHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return null;
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("test");
   }
@@ -281,13 +258,15 @@ public String buildHeader() {
   @Test
   public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
     Builder builder = new Builder();
-    builder.setHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return "";
-      }
-    });
+    builder.setHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return "";
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).doesNotContainKey("test");
   }
@@ -295,20 +274,24 @@ public String buildHeader() {
   @Test
   public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
     Builder builder = new Builder();
-    builder.addHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return null;
-      }
-    });
-    builder.addHeader("test", new LazyHeaderFactory() {
-      @Nullable
-      @Override
-      public String buildHeader() {
-        return "value";
-      }
-    });
+    builder.addHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return null;
+          }
+        });
+    builder.addHeader(
+        "test",
+        new LazyHeaderFactory() {
+          @Nullable
+          @Override
+          public String buildHeader() {
+            return "value";
+          }
+        });
     LazyHeaders headers = builder.build();
     assertThat(headers.getHeaders()).containsEntry("test", "value");
   }
@@ -318,27 +301,19 @@ public void testEquals() {
     LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
     LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
     new EqualsTester()
-        .addEqualityGroup(
-            new Builder().build(),
-            new Builder().build()
-        )
+        .addEqualityGroup(new Builder().build(), new Builder().build())
         .addEqualityGroup(
             new Builder().addHeader("key", "value").build(),
-            new Builder().addHeader("key", "value").build()
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", "value").addHeader("key", "value").build()
-        )
+            new Builder().addHeader("key", "value").build())
+        .addEqualityGroup(new Builder().addHeader("key", "value").addHeader("key", "value").build())
         .addEqualityGroup(
             new Builder().addHeader("key", firstLazyFactory).build(),
-            new Builder().addHeader("key", firstLazyFactory).build()
-        )
+            new Builder().addHeader("key", firstLazyFactory).build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("key", firstLazyFactory)
                 .addHeader("key", firstLazyFactory)
-                .build()
-        )
+                .build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", "value")
@@ -347,20 +322,11 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", firstLazyFactory)
                 .addHeader("firstKey", "value")
-                .build()
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", "secondValue")
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("secondKey", "value")
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("key", secondLazyFactory)
-        )
-        .addEqualityGroup(
-            new Builder().addHeader("secondKey", firstLazyFactory)
-        )
+                .build())
+        .addEqualityGroup(new Builder().addHeader("key", "secondValue"))
+        .addEqualityGroup(new Builder().addHeader("secondKey", "value"))
+        .addEqualityGroup(new Builder().addHeader("key", secondLazyFactory))
+        .addEqualityGroup(new Builder().addHeader("secondKey", firstLazyFactory))
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", "firstValue")
@@ -373,8 +339,7 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", "secondValue")
                 .addHeader("firstKey", "firstValue")
-                .build()
-        )
+                .build())
         .addEqualityGroup(
             new Builder()
                 .addHeader("firstKey", firstLazyFactory)
@@ -387,8 +352,7 @@ public void testEquals() {
             new Builder()
                 .addHeader("secondKey", secondLazyFactory)
                 .addHeader("firstKey", firstLazyFactory)
-                .build()
-        )
+                .build())
         .testEquals();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
index 041f67992..744eba369 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -20,11 +20,13 @@ public void setUp() {
 
   @Test
   public void testModelKeyEquivalence() {
-    new EqualsTester().addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 200),
-        ModelCache.ModelKey.get(14f, 100, 200))
+    new EqualsTester()
+        .addEqualityGroup(
+            ModelCache.ModelKey.get(14f, 100, 200), ModelCache.ModelKey.get(14f, 100, 200))
         .addEqualityGroup(ModelCache.ModelKey.get(13f, 100, 200))
         .addEqualityGroup(ModelCache.ModelKey.get(14f, 200, 200))
-        .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300)).testEquals();
+        .addEqualityGroup(ModelCache.ModelKey.get(14f, 100, 300))
+        .testEquals();
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 36f3f3480..96724f6c5 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -42,8 +42,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     throwableListPool = FactoryPools.threadSafeList();
 
-    multiFactory =
-        new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
+    multiFactory = new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
     when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
     when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
@@ -152,7 +151,7 @@ public void testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelAnd
 
   @Test
   public void
-  testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelClassWithDifferentDataClasses() {
+      testBuild_withModelClass_returnsMultipleModelLoaders_ofGivenModelClassWithDifferentDataClasses() {
     ModelLoader<String, Integer> otherLoader = appendFactoryFor(String.class, Integer.class);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -169,7 +168,7 @@ public void testBuild_withModelClass_excludesModelLoadersForOtherModelClasses()
 
   @Test
   public void
-  testBuild_withModelAndDataClasses_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
+      testBuild_withModelAndDataClasses_returnsMultipleModelLoaders_ofGivenModelAndDataClasses() {
     ModelLoader<String, String> otherLoader = appendFactoryFor(String.class, String.class);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -288,8 +287,8 @@ public void testBuild_respectsPrependOrder() {
     assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
   }
 
-  private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
-      Class<Y> dataClass) {
+  private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(
+      Class<X> modelClass, Class<Y> dataClass) {
     ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
     verify(multiModelLoaderFactory).build(captor.capture(), eq(throwableListPool));
@@ -311,7 +310,8 @@ public void testBuild_respectsPrependOrder() {
   private <X, Y> ModelLoader<X, Y> registerFactoryFor(
       Class<X> modelClass, Class<Y> dataClass, boolean append) {
     ModelLoaderFactory<X, Y> factory = mockFactory();
-    @SuppressWarnings("unchecked") ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    @SuppressWarnings("unchecked")
+    ModelLoader<X, Y> loader = mock(ModelLoader.class);
     when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
@@ -326,4 +326,3 @@ public void testBuild_respectsPrependOrder() {
     return mock(ModelLoaderFactory.class);
   }
 }
-
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index ec2c1831e..0996f3751 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -24,9 +24,7 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class.
- */
+/** Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ResourceLoaderTest {
@@ -59,10 +57,10 @@ public void testCanHandleId() {
         Preconditions.checkNotNull(loader.buildLoadData(id, 100, 100, new Options())).fetcher);
   }
 
-    @Test
-    public void testDoesNotThrowOnInvalidOrMissingId() {
-      assertThat(loader.buildLoadData(1234, 0, 0, options)).isNull();
-      verify(uriLoader, never()).buildLoadData(any(Uri.class), anyInt(), anyInt(),
-          any(Options.class));
-    }
+  @Test
+  public void testDoesNotThrowOnInvalidOrMissingId() {
+    assertThat(loader.buildLoadData(1234, 0, 0, options)).isNull();
+    verify(uriLoader, never())
+        .buildLoadData(any(Uri.class), anyInt(), anyInt(), any(Options.class));
+  }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index b6554eabf..1d447f318 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -24,9 +24,7 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
- */
+/** Tests for the {@link com.bumptech.glide.load.model.StringLoader} class. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StringLoaderTest {
@@ -63,7 +61,8 @@ public void testHandlesPaths() {
     assertEquals(
         fetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+                loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -78,8 +77,8 @@ public void testCanHandleComplexFilePaths() {
     assertTrue(loader.handles(testPath));
     assertEquals(
         fetcher,
-        Preconditions.checkNotNull(
-            loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+        Preconditions.checkNotNull(loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -94,7 +93,8 @@ public void testHandlesFileUris() {
     assertEquals(
         fetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+                loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -108,7 +108,8 @@ public void testHandlesResourceUris() {
     assertEquals(
         fetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+                loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -122,8 +123,8 @@ public void testHandlesHttp() {
     assertTrue(loader.handles(url));
     assertEquals(
         fetcher,
-        Preconditions.checkNotNull(
-            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+        Preconditions.checkNotNull(loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -137,8 +138,8 @@ public void testHandlesHttps() {
     assertTrue(loader.handles(url));
     assertEquals(
         fetcher,
-        Preconditions.checkNotNull(
-            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+        Preconditions.checkNotNull(loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -152,8 +153,8 @@ public void testHandlesContent() {
     assertTrue(loader.handles(content));
     assertEquals(
         fetcher,
-        Preconditions.checkNotNull(
-            loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+        Preconditions.checkNotNull(loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index b7a4f3859..c53260b65 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -19,9 +19,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/**
- * Tests for the {@link UriLoader} class.
- */
+/** Tests for the {@link UriLoader} class. */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class UriLoaderTest {
@@ -49,8 +47,8 @@ public void testHandlesFileUris() throws IOException {
     assertTrue(loader.handles(fileUri));
     assertEquals(
         localUriFetcher,
-        Preconditions.checkNotNull(
-            loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+        Preconditions.checkNotNull(loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -62,7 +60,8 @@ public void testHandlesResourceUris() throws IOException {
     assertEquals(
         localUriFetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+                loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 
   @Test
@@ -74,6 +73,7 @@ public void testHandlesContentUris() {
     assertEquals(
         localUriFetcher,
         Preconditions.checkNotNull(
-            loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
+                loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options))
+            .fetcher);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index e635b01a2..d6388905f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -82,20 +82,20 @@ public void testBuildsNewUrlIfNotPresentInCache() {
 
     urlLoader.resultUrl = "fakeUrl";
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
-        .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
-          @Override
-          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
-            GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
-            assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
-            return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
-
-          }
-        });
+        .thenAnswer(
+            new Answer<ModelLoader.LoadData<InputStream>>() {
+              @Override
+              public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
+                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
+                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
+              }
+            });
     assertEquals(
         fetcher,
         Preconditions.checkNotNull(
-            urlLoader.buildLoadData(
-                new GlideUrl(urlLoader.resultUrl), width, height, options)).fetcher);
+                urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options))
+            .fetcher);
   }
 
   @Test
@@ -105,14 +105,17 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
     int width = 400;
     int height = 500;
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) {
-        GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
-        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
-        return null;
-      }
-    }).when(modelCache).put(eq(model), eq(width), eq(height), any(GlideUrl.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) {
+                GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
+                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
+                return null;
+              }
+            })
+        .when(modelCache)
+        .put(eq(model), eq(width), eq(height), any(GlideUrl.class));
 
     urlLoader.buildLoadData(model, width, height, options);
 
@@ -132,14 +135,15 @@ public void testDoesNotInteractWithModelCacheIfNull() {
 
     assertEquals(
         fetcher,
-        Preconditions.checkNotNull(
-            urlLoader.buildLoadData(new Object(), width, height, options)).fetcher);
+        Preconditions.checkNotNull(urlLoader.buildLoadData(new Object(), width, height, options))
+            .fetcher);
   }
 
   private static final class TestLoader extends BaseGlideUrlLoader<Object> {
     String resultUrl;
 
-    TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+    TestLoader(
+        ModelLoader<GlideUrl, InputStream> concreteLoader,
         ModelCache<Object, GlideUrl> modelCache) {
       super(concreteLoader, modelCache);
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 5abc0b23d..e816a95d8 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -41,8 +41,8 @@ public void testHandlesHttpUris() throws MalformedURLException {
 
     assertTrue(loader.handles(httpUri));
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
-            eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(httpUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(OPTIONS));
   }
 
   @Test
@@ -52,20 +52,25 @@ public void testHandlesHttpsUris() throws MalformedURLException {
 
     assertTrue(loader.handles(httpsUri));
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE),
-            eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(httpsUri.toString())), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(OPTIONS));
   }
 
   // Test for https://github.com/bumptech/glide/issues/71.
   @Test
   public void testHandlesMostlyInvalidHttpUris() {
-    Uri mostlyInvalidHttpUri = Uri.parse(
-        "http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png?size=100");
+    Uri mostlyInvalidHttpUri =
+        Uri.parse(
+            "http://myserver_url.com:80http://myserver_url.com/webapp/images/no_image.png"
+                + "?size=100");
 
     assertTrue(loader.handles(mostlyInvalidHttpUri));
     loader.buildLoadData(mostlyInvalidHttpUri, IMAGE_SIDE, IMAGE_SIDE, OPTIONS);
     verify(urlLoader)
-        .buildLoadData(eq(new GlideUrl(mostlyInvalidHttpUri.toString())), eq(IMAGE_SIDE),
-            eq(IMAGE_SIDE), eq(OPTIONS));
+        .buildLoadData(
+            eq(new GlideUrl(mostlyInvalidHttpUri.toString())),
+            eq(IMAGE_SIDE),
+            eq(IMAGE_SIDE),
+            eq(OPTIONS));
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index 78b851f22..9102937be 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -35,6 +35,5 @@ public void testThrowsIfGivenNullData() {
     new SimpleResource<>(null);
   }
 
-  private static class Anything {
-  }
+  private static class Anything {}
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index 087c606d3..df1f55f12 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -40,14 +40,14 @@ public void testReturnsGivenResource() {
 
   @Test
   public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
-    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    @SuppressWarnings("unchecked")
+    Transformation<Object> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
 
     keyTester
-        .addEquivalenceGroup(
-            UnitTransformation.get(),
-            UnitTransformation.get())
+        .addEquivalenceGroup(UnitTransformation.get(), UnitTransformation.get())
         .addEquivalenceGroup(other)
         .addEmptyDigestRegressionTest(UnitTransformation.get())
         .test();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index 7fdd33f3c..7a0b29dfd 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -42,8 +42,8 @@ public void testReturnsDifferentDrawableEachTime() {
 
   @Test
   public void testReturnsSizeFromGivenBitmap() {
-    assertEquals(harness.bitmap.getHeight() * harness.bitmap.getRowBytes(),
-        harness.create().getSize());
+    assertEquals(
+        harness.bitmap.getHeight() * harness.bitmap.getRowBytes(), harness.create().getSize());
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index 2daa5979b..b779dcd3e 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -71,15 +71,15 @@ public void tearDown() {
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(
-        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Resource<Bitmap>>() {
-          @SuppressWarnings("unchecked")
-          @Override
-          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
-            return (Resource<Bitmap>) invocation.getArguments()[1];
-          }
-        });
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(
+            new Answer<Resource<Bitmap>>() {
+              @SuppressWarnings("unchecked")
+              @Override
+              public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+                return (Resource<Bitmap>) invocation.getArguments()[1];
+              }
+            });
 
     Resource<BitmapDrawable> transformed =
         transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
@@ -124,16 +124,17 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
+    doAnswer(new Util.WriteDigest("wrapped"))
+        .when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    @SuppressWarnings("unchecked")
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
 
     keyTester
-        .addEquivalenceGroup(
-            transformation,
-            new BitmapDrawableTransformation(wrapped))
+        .addEquivalenceGroup(transformation, new BitmapDrawableTransformation(wrapped))
         .addEquivalenceGroup(new BitmapDrawableTransformation(other))
         .addEquivalenceGroup(wrapped)
         .addRegressionTest(
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index 60f360b16..dad0dcd22 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -16,7 +16,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-//TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
+// TODO: add a test for bitmap size using getAllocationByteSize when robolectric supports kitkat.
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapResourceTest {
@@ -42,8 +42,8 @@ public void testCanGetBitmap() {
   @Test
   public void testSizeIsBasedOnDimensPreKitKat() {
     Util.setSdkVersionInt(18);
-    assertEquals(harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4,
-        harness.resource.getSize());
+    assertEquals(
+        harness.bitmap.getWidth() * harness.bitmap.getHeight() * 4, harness.resource.getSize());
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index cb7bd2e99..8e0f86255 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -29,8 +29,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapTransformationTest {
 
-  @Mock
-  private BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
   private Application context;
 
   @Before
@@ -48,16 +47,17 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return toTransform;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            return toTransform;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(100, 100);
     assertEquals(resource, transformation.transform(context, resource, 1, 1));
@@ -66,16 +66,17 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
-          int outHeight) {
-        return transformed;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth, int outHeight) {
+            return transformed;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(1, 2);
     assertNotSame(resource, transformation.transform(context, resource, 100, 100));
@@ -86,70 +87,79 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation() {
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        assertEquals(bitmapPool, pool);
-        assertEquals(resource.get(), toTransform);
-        assertEquals(expectedWidth, outWidth);
-        assertEquals(expectedHeight, outHeight);
-        return resource.get();
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            assertEquals(bitmapPool, pool);
+            assertEquals(resource.get(), toTransform);
+            assertEquals(expectedWidth, outWidth);
+            assertEquals(expectedHeight, outHeight);
+            return resource.get();
+          }
+        };
 
     transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool bitmapPool,
+              @NonNull Bitmap toTransform,
+              int outWidth,
+              int outHeight) {
+            return null;
+          }
+        };
     transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation() {
-
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
-
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-
-    };
+    BitmapTransformation transformation =
+        new BitmapTransformation() {
+
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
+
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool bitmapPool,
+              @NonNull Bitmap toTransform,
+              int outWidth,
+              int outHeight) {
+            return null;
+          }
+        };
     transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation() {
+    BitmapTransformation transform =
+        new BitmapTransformation() {
 
-      @Override
-      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {  }
+          @Override
+          public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
 
-      @Override
-      protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-          int outWidth, int outHeight) {
-        return null;
-      }
-    };
+          @Override
+          protected Bitmap transform(
+              @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+            return null;
+          }
+        };
 
     Resource<Bitmap> resource = mockResource(100, 100);
     assertNull(transform.transform(context, resource, 100, 100));
@@ -189,14 +199,14 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     int givenHeight;
 
     @Override
-    protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-        int outHeight) {
+    protected Bitmap transform(
+        @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
       givenWidth = outWidth;
       givenHeight = outHeight;
       return null;
     }
 
     @Override
-    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {}
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 93cd95ce6..11a8ef1f5 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -80,8 +80,7 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -100,7 +99,8 @@ public void testDoesNotRecycleGivenResource() {
     verify(resource, never()).recycle();
   }
 
-  @Test @Config(sdk = 19)
+  @Test
+  @Config(sdk = 19)
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
     bitmap.setConfig(null);
 
@@ -115,8 +115,8 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
     int expectedWidth = 75;
     int expectedHeight = 74;
 
-    for (int[] dimens : new int[][] { new int[] { 800, 200 }, new int[] { 450, 100 },
-        new int[] { 78, 78 } }) {
+    for (int[] dimens :
+        new int[][] {new int[] {800, 200}, new int[] {450, 100}, new int[] {78, 78}}) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
@@ -133,8 +133,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
     int expectedWidth = 100;
     int expectedHeight = 100;
 
-    for (int[] dimens : new int[][] { new int[] { 50, 90 }, new int[] { 150, 2 },
-        new int[] { 78, 78 } }) {
+    for (int[] dimens : new int[][] {new int[] {50, 90}, new int[] {150, 2}, new int[] {78, 78}}) {
       Bitmap toTransform = Bitmap.createBitmap(dimens[0], dimens[1], Bitmap.Config.ARGB_4444);
       when(resource.get()).thenReturn(toTransform);
 
@@ -148,14 +147,12 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
     keyTester
-        .addEquivalenceGroup(
-            new CenterCrop(),
-            new CenterCrop())
-        .addEquivalenceGroup(
-            transformation)
+        .addEquivalenceGroup(new CenterCrop(), new CenterCrop())
+        .addEquivalenceGroup(transformation)
         .addRegressionTest(
             new CenterCrop(), "68bd5819c42b37efbe7124bb851443a6388ee3e2e9034213da6eaa15381d3457")
         .test();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index ba0f059f1..3de44bf90 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -38,7 +38,10 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {CenterInsideTest.DrawNothingCanvas.class})
 public class CenterInsideTest {
   @Rule public final KeyTester keyTester = new KeyTester();
 
@@ -71,29 +74,25 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testReturnsGivenResourceIfSmallerThanTarget() {
-    Resource<Bitmap> result =
-        centerInside.transform(context, resource, 150, 150);
+    Resource<Bitmap> result = centerInside.transform(context, resource, 150, 150);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testReturnsNewResourceIfLargerThanTarget() {
-    Resource<Bitmap> result =
-        centerInside.transform(context, resource, 50, 50);
+    Resource<Bitmap> result = centerInside.transform(context, resource, 50, 50);
 
     assertNotEquals(resource, result);
   }
 
-
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
     centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
@@ -110,18 +109,16 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
 
     keyTester
-        .addEquivalenceGroup(
-            new CenterInside(),
-            new CenterInside(),
-            centerInside)
+        .addEquivalenceGroup(new CenterInside(), new CenterInside(), centerInside)
         .addEquivalenceGroup(transformation)
         .addRegressionTest(
             new CenterInside(), "acf83850a2e8e9e809c8bfb999e2aede9e932cb897a15367fac9856b96f3ba33")
-    .test();
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
index 4b39cf880..3b7492f9c 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -26,8 +26,34 @@
 public class DefaultImageHeaderParserTest {
 
   private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+      new byte[] {
+        (byte) 0x89,
+        0x50,
+        0x4e,
+        0x47,
+        0xd,
+        0xa,
+        0x1a,
+        0xa,
+        0x0,
+        0x0,
+        0x0,
+        0xd,
+        0x49,
+        0x48,
+        0x44,
+        0x52,
+        0x0,
+        0x0,
+        0x1,
+        (byte) 0x90,
+        0x0,
+        0x0,
+        0x1,
+        0x2c,
+        0x8,
+        0x6
+      };
 
   private ArrayPool byteArrayPool;
 
@@ -39,37 +65,46 @@ public void setUp() {
   @Test
   public void testCanParsePngType() throws IOException {
     // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.PNG, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data = new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.PNG, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+          }
+        });
   }
 
   @Test
   public void testCanParsePngWithAlpha() throws IOException {
     for (int i = 3; i <= 6; i++) {
       byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-            throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType(is));
-        }
-        @Override
-        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-            ArrayPool byteArrayPool) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
-        }
-      });
+      runTest(
+          pngHeaderWithIhdrChunk,
+          new ParserTestCase() {
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG_A, parser.getType(is));
+            }
+
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+            }
+          });
     }
   }
 
@@ -77,108 +112,197 @@ public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
   public void testCanParsePngWithoutAlpha() throws IOException {
     for (int i = 0; i < 3; i++) {
       byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-            throws IOException {
-          assertEquals(ImageType.PNG, parser.getType(is));
-        }
-        @Override
-        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-            ArrayPool byteArrayPool) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
-        }
-      });
+      runTest(
+          pngHeaderWithIhdrChunk,
+          new ParserTestCase() {
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG, parser.getType(is));
+            }
+
+            @Override
+            public void run(
+                DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+                throws IOException {
+              assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+            }
+          });
     }
   }
 
   @Test
   public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data = new byte[] {(byte) 0xFF, (byte) 0xD8};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.JPEG, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+          }
+        });
   }
 
   @Test
   public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.GIF, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data = new byte[] {'G', 'I', 'F'};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.GIF, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+          }
+        });
   }
 
   @Test
   public void testCanParseWebpWithAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
-        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data =
+        new byte[] {
+          0x52,
+          0x49,
+          0x46,
+          0x46,
+          0x3c,
+          0x50,
+          0x00,
+          0x00,
+          0x57,
+          0x45,
+          0x42,
+          0x50,
+          0x56,
+          0x50,
+          0x38,
+          0x4c,
+          0x30,
+          0x50,
+          0x00,
+          0x00,
+          0x2f,
+          (byte) 0xef,
+          (byte) 0x80,
+          0x15,
+          0x10,
+          (byte) 0x8d,
+          0x30,
+          0x68,
+          0x1b,
+          (byte) 0xc9,
+          (byte) 0x91,
+          (byte) 0xb2
+        };
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP_A, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+          }
+        });
   }
 
   @Test
   public void testCanParseWebpWithoutAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
-        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data =
+        new byte[] {
+          0x52,
+          0x49,
+          0x46,
+          0x46,
+          0x72,
+          0x1c,
+          0x00,
+          0x00,
+          0x57,
+          0x45,
+          0x42,
+          0x50,
+          0x56,
+          0x50,
+          0x38,
+          0x20,
+          0x66,
+          0x1c,
+          0x00,
+          0x00,
+          0x30,
+          0x3c,
+          0x01,
+          (byte) 0x9d,
+          0x01,
+          0x2a,
+          0x52,
+          0x02,
+          (byte) 0x94,
+          0x03,
+          0x00,
+          (byte) 0xc7
+        };
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+          }
+        });
   }
 
   @Test
   public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
-      }
-    });
+    byte[] data = new byte[] {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+          }
+        });
   }
 
   // Test for #286.
@@ -186,34 +310,42 @@ public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
   public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
     byte[] data =
         Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
-      }
-    });
+    runTest(
+        data,
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+          }
+        });
   }
 
   @Test
   public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
-          throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(is));
-      }
-      @Override
-      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
-          ArrayPool byteArrayPool) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
-      }
-    });
+    runTest(
+        new byte[0],
+        new ParserTestCase() {
+          @Override
+          public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(is));
+          }
+
+          @Override
+          public void run(
+              DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+              throws IOException {
+            assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+          }
+        });
   }
 
   // Test for #387.
@@ -234,44 +366,50 @@ public void testHandlesPartialSkips() throws IOException {
 
   @Test
   public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    DefaultImageHeaderParser parser =
-        new DefaultImageHeaderParser();
+    InputStream is =
+        new ByteArrayInputStream(
+            new byte[] {(byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a});
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
     assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
   }
 
   @Test
   public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
     ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    byte[] data = new byte[] {
-        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
-        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
-        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
-        // SEGMENT_LENGTH
-        (byte) 0xFF, (byte) 0xFF,
-    };
+    byte[] data =
+        new byte[] {
+          jpegHeaderBytes.get(0),
+          jpegHeaderBytes.get(1),
+          (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+          (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+          // SEGMENT_LENGTH
+          (byte) 0xFF,
+          (byte) 0xFF,
+        };
     ByteBuffer byteBuffer = ByteBuffer.wrap(data);
     DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
-        parser.getOrientation(byteBuffer, byteArrayPool));
+    assertEquals(
+        ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(byteBuffer, byteArrayPool));
   }
 
   @Test
   public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
     ByteBuffer jpegHeaderBytes = getExifMagicNumber();
-    byte[] data = new byte[] {
-        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
-        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
-        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
-        (byte) 0xE5,
-        // SEGMENT_LENGTH
-        (byte) 0xFF, (byte) 0xFF,
-    };
+    byte[] data =
+        new byte[] {
+          jpegHeaderBytes.get(0),
+          jpegHeaderBytes.get(1),
+          (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+          // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+          (byte) 0xE5,
+          // SEGMENT_LENGTH
+          (byte) 0xFF,
+          (byte) 0xFF,
+        };
     ByteBuffer byteBuffer = ByteBuffer.wrap(data);
     DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
-    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
-        parser.getOrientation(byteBuffer, byteArrayPool));
+    assertEquals(
+        ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(byteBuffer, byteArrayPool));
   }
 
   @Test
@@ -328,6 +466,7 @@ private static ByteBuffer getExifMagicNumber() {
   private interface ParserTestCase {
     void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
         throws IOException;
+
     void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
         throws IOException;
   }
@@ -353,7 +492,7 @@ private static void runTest(byte[] data, ParserTestCase test) throws IOException
     boolean returnZeroFlag = true;
 
     SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
+      super(in);
     }
 
     @Override
@@ -372,32 +511,32 @@ public long skip(long byteCount) throws IOException {
   private static class PartialSkipInputStream extends FilterInputStream {
 
     PartialSkipInputStream(InputStream in) {
-        super(in);
+      super(in);
     }
 
     @Override
     public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
+      long toActuallySkip = byteCount / 2;
+      if (byteCount == 1) {
+        toActuallySkip = 1;
+      }
+      return super.skip(toActuallySkip);
     }
   }
 
   private static class PartialReadInputStream extends FilterInputStream {
 
     PartialReadInputStream(InputStream in) {
-        super(in);
+      super(in);
     }
 
     @Override
     public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
+      int toActuallyRead = byteCount / 2;
+      if (byteCount == 1) {
+        toActuallyRead = 1;
+      }
+      return super.read(buffer, byteOffset, toActuallyRead);
     }
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
index b95fee2ba..fe356766f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
@@ -63,10 +63,8 @@ public void tearDown() {
 
   @Test
   public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecycle() {
-    when(
-        bitmapTransformation
-            .transform(
-                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+    when(bitmapTransformation.transform(
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
         .thenAnswer(new ReturnGivenResource());
 
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
@@ -82,14 +80,15 @@ public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecy
   @Test
   public void transform_withBitmapDrawable_andFunctionalBitmapTransformation_doesNotRecycle() {
     when(bitmapTransformation.transform(
-        any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
-        .thenAnswer(new Answer<Resource<Bitmap>>() {
-          @Override
-          public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
-            return BitmapResource.obtain(
-                Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
-          }
-        });
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(
+            new Answer<Resource<Bitmap>>() {
+              @Override
+              public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+                return BitmapResource.obtain(
+                    Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
+              }
+            });
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
     BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
     @SuppressWarnings("unchecked")
@@ -105,34 +104,36 @@ public void transform_withColorDrawable_andUnitBitmapTransformation_recycles() {
     bitmapPool = mock(BitmapPool.class);
     Glide.tearDown();
     Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
-    when(
-        bitmapTransformation
-            .transform(
-                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+    when(bitmapTransformation.transform(
+            any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
         .thenAnswer(new ReturnGivenResource());
 
     ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
     final Resource<Drawable> input = new SimpleResource<Drawable>(colorDrawable);
 
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
-        assertThat(bitmap.getWidth()).isEqualTo(100);
-        assertThat(bitmap.getHeight()).isEqualTo(200);
-        return null;
-      }
-    }).when(bitmapPool).put(any(Bitmap.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+                assertThat(bitmap.getWidth()).isEqualTo(100);
+                assertThat(bitmap.getHeight()).isEqualTo(200);
+                return null;
+              }
+            })
+        .when(bitmapPool)
+        .put(any(Bitmap.class));
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
-        .thenAnswer(new Answer<Bitmap>() {
-          @Override
-          public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
-            int width = (Integer) invocationOnMock.getArguments()[0];
-            int height = (Integer) invocationOnMock.getArguments()[1];
-            Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
-            return Bitmap.createBitmap(width, height, config);
-          }
-        });
+        .thenAnswer(
+            new Answer<Bitmap>() {
+              @Override
+              public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
+                int width = (Integer) invocationOnMock.getArguments()[0];
+                int height = (Integer) invocationOnMock.getArguments()[1];
+                Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
+                return Bitmap.createBitmap(width, height, config);
+              }
+            });
 
     transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
 
@@ -143,9 +144,11 @@ public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
   public void testEquals() {
     BitmapTransformation otherBitmapTransformation = mock(BitmapTransformation.class);
     doAnswer(new Util.WriteDigest("bitmapTransformation"))
-        .when(bitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+        .when(bitmapTransformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
     doAnswer(new Util.WriteDigest("otherBitmapTransformation"))
-        .when(otherBitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+        .when(otherBitmapTransformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
 
     keyTester
         .addEquivalenceGroup(
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 39a7bce42..15889018f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -37,7 +37,10 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {FitCenterTest.DrawNothingCanvas.class})
 public class FitCenterTest {
   @Rule public final KeyTester keyTester = new KeyTester();
 
@@ -60,7 +63,6 @@ public void setUp() {
     context = RuntimeEnvironment.application;
     Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
-
     fitCenter = new FitCenter();
   }
 
@@ -71,8 +73,7 @@ public void tearDown() {
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
-    Resource<Bitmap> result =
-        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
+    Resource<Bitmap> result = fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -93,7 +94,8 @@ public void testDoesNotRecycleGivenResource() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("other")).when(transformation)
+    doAnswer(new Util.WriteDigest("other"))
+        .when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
     keyTester
         .addEquivalenceGroup(fitCenter, new FitCenter(), new FitCenter())
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
index 3f698e8ab..65c3dcc51 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -83,8 +83,7 @@ public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped
     verify(bitmapResource).initialize();
   }
 
-  private interface InitializableBitmapResource extends Initializable,
-      Resource<Bitmap> {
+  private interface InitializableBitmapResource extends Initializable, Resource<Bitmap> {
     // Intentionally empty.
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index dd1a06168..d70e4db2e 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -32,8 +32,10 @@
 import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 28, shadows = {
-    TransformationUtilsTest.AlphaShadowBitmap.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 28,
+    shadows = {TransformationUtilsTest.AlphaShadowBitmap.class})
 public class TransformationUtilsTest {
 
   @Mock private BitmapPool bitmapPool;
@@ -130,8 +132,8 @@ public void testFitCenterUsesFloorInsteadOfRoundingForOutputBitmapSize() {
   @Test
   public void testFitCenterReturnsGivenBitmapIfGivenBitmapMatchesExactly() {
     Bitmap toFit = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_4444);
-    Bitmap transformed = TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(),
-        toFit.getHeight());
+    Bitmap transformed =
+        TransformationUtils.fitCenter(bitmapPool, toFit, toFit.getWidth(), toFit.getHeight());
     assertTrue(toFit == transformed);
   }
 
@@ -154,15 +156,16 @@ public void testFitCenterReturnsGivenBitmapIfGivenBitmapHeightMatchesExactly() {
   @Test
   public void testCenterCropReturnsGivenBitmapIfGivenBitmapExactlyMatchesGivenDimensions() {
     Bitmap toCrop = Bitmap.createBitmap(200, 300, Bitmap.Config.ARGB_8888);
-    Bitmap transformed = TransformationUtils
-        .centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
+    Bitmap transformed =
+        TransformationUtils.centerCrop(bitmapPool, toCrop, toCrop.getWidth(), toCrop.getHeight());
 
     // Robolectric incorrectly implements equals() for Bitmaps, we want the original object not
     // just an equivalent.
     assertTrue(toCrop == transformed);
   }
 
-  @Test @Config(sdk = 19)
+  @Test
+  @Config(sdk = 19)
   public void testFitCenterHandlesBitmapsWithNullConfigs() {
     Bitmap toFit = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     toFit.setConfig(null);
@@ -176,14 +179,14 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
     reset(bitmapPool);
-    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888)))
-        .thenReturn(toReuse);
+    when(bitmapPool.get(eq(50), eq(50), eq(Bitmap.Config.ARGB_8888))).thenReturn(toReuse);
 
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -191,7 +194,7 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
 
   @Test
   public void
-  testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+      testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
@@ -201,8 +204,9 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmap
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -214,13 +218,15 @@ public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
 
-  @Test @Config(sdk = 19)
+  @Test
+  @Config(sdk = 19)
   public void testCenterCropHandlesBitmapsWithNullConfigs() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     toTransform.setConfig(null);
@@ -236,8 +242,9 @@ public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha(
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.centerCrop(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.centerCrop(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -254,8 +261,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     toReuse.setHasAlpha(false);
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertTrue(result.hasAlpha());
@@ -263,7 +271,7 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
 
   @Test
   public void
-  testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
+      testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {
     Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);
@@ -274,8 +282,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapI
     toReuse.setHasAlpha(true);
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform, toReuse.getWidth(),
-        toReuse.getHeight());
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toReuse.getWidth(), toReuse.getHeight());
 
     assertEquals(toReuse, result);
     assertFalse(result.hasAlpha());
@@ -287,8 +296,9 @@ public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {
 
     toTransform.setHasAlpha(true);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertTrue(result.hasAlpha());
   }
@@ -299,8 +309,9 @@ public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha()
 
     toTransform.setHasAlpha(false);
 
-    Bitmap result = TransformationUtils.fitCenter(bitmapPool, toTransform,
-        toTransform.getWidth() / 2, toTransform.getHeight() / 2);
+    Bitmap result =
+        TransformationUtils.fitCenter(
+            bitmapPool, toTransform, toTransform.getWidth() / 2, toTransform.getHeight() / 2);
 
     assertFalse(result.hasAlpha());
   }
@@ -326,20 +337,21 @@ private static void assertBitmapFitsExactlyWithinBounds(int maxSide, Bitmap bitm
 
   @Test
   public void testGetExifOrientationDegrees() {
-    assertEquals(0,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
-    assertEquals(90,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
-    assertEquals(90,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
-    assertEquals(180,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
-    assertEquals(180,
+    assertEquals(
+        0, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_NORMAL));
+    assertEquals(
+        90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSPOSE));
+    assertEquals(
+        90, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_90));
+    assertEquals(
+        180, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_180));
+    assertEquals(
+        180,
         TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_FLIP_VERTICAL));
-    assertEquals(270,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
-    assertEquals(270,
-        TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
+    assertEquals(
+        270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_TRANSVERSE));
+    assertEquals(
+        270, TransformationUtils.getExifOrientationDegrees(ExifInterface.ORIENTATION_ROTATE_270));
   }
 
   @Test
@@ -369,8 +381,9 @@ public void testRotateImageExifReturnsGivenBitmapIfRotationIsUndefined() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     // Use assertTrue because Robolectric incorrectly implements equality for Bitmaps. We want
     // not just an identical Bitmap, but our original Bitmap object back.
-    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
-        ExifInterface.ORIENTATION_UNDEFINED);
+    Bitmap rotated =
+        TransformationUtils.rotateImageExif(
+            bitmapPool, toRotate, ExifInterface.ORIENTATION_UNDEFINED);
     assertTrue(toRotate == rotated);
   }
 
@@ -383,28 +396,30 @@ public void testRotateImageExifReturnsGivenBitmapIfOrientationIsInvalid() {
     assertTrue(toRotate == rotated);
   }
 
-  @Test @Config(sdk = 19)
+  @Test
+  @Config(sdk = 19)
   public void testRotateImageExifHandlesBitmapsWithNullConfigs() {
     Bitmap toRotate = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
     toRotate.setConfig(null);
-    Bitmap rotated = TransformationUtils.rotateImageExif(bitmapPool, toRotate,
-        ExifInterface.ORIENTATION_ROTATE_180);
+    Bitmap rotated =
+        TransformationUtils.rotateImageExif(
+            bitmapPool, toRotate, ExifInterface.ORIENTATION_ROTATE_180);
     assertEquals(Bitmap.Config.ARGB_8888, rotated.getConfig());
   }
 
   @Test
   public void testInitializeMatrixSetsScaleIfFlipHorizontal() {
     Matrix matrix = mock(Matrix.class);
-    TransformationUtils
-        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
+    TransformationUtils.initializeMatrixForRotation(
+        ExifInterface.ORIENTATION_FLIP_HORIZONTAL, matrix);
     verify(matrix).setScale(-1, 1);
   }
 
   @Test
   public void testInitializeMatrixSetsScaleAndRotateIfFlipVertical() {
     Matrix matrix = mock(Matrix.class);
-    TransformationUtils
-        .initializeMatrixForRotation(ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
+    TransformationUtils.initializeMatrixForRotation(
+        ExifInterface.ORIENTATION_FLIP_VERTICAL, matrix);
     verify(matrix).setRotate(180);
     verify(matrix).postScale(-1, 1);
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
index 012e4a8f9..630ffb371 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
@@ -29,5 +29,4 @@ public void testReturnsSizeOfGivenBytes() {
   public void testThrowsIfGivenNullBytes() {
     new BytesResource(null);
   }
-
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index 50af60a7a..276e931fd 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -26,22 +26,22 @@
   @Before
   public void setUp() {
     drawable = mock(TestDrawable.class);
-    resource = new DrawableResource<TestDrawable>(drawable) {
-      @NonNull
-      @Override
-      public Class<TestDrawable> getResourceClass() {
-        return TestDrawable.class;
-      }
-
-      @Override
-      public int getSize() {
-        return 0;
-      }
-
-      @Override
-      public void recycle() {
-      }
-    };
+    resource =
+        new DrawableResource<TestDrawable>(drawable) {
+          @NonNull
+          @Override
+          public Class<TestDrawable> getResourceClass() {
+            return TestDrawable.class;
+          }
+
+          @Override
+          public int getSize() {
+            return 0;
+          }
+
+          @Override
+          public void recycle() {}
+        };
   }
 
   @Test
@@ -85,30 +85,20 @@ public int getSize() {
       }
 
       @Override
-      public void recycle() {
-
-      }
+      public void recycle() {}
     };
   }
 
-  /**
-   * Just to have a type to test with which is not directly Drawable
-   */
+  /** Just to have a type to test with which is not directly Drawable */
   private static class TestDrawable extends Drawable {
     @Override
-    public void draw(@NonNull Canvas canvas) {
-
-    }
+    public void draw(@NonNull Canvas canvas) {}
 
     @Override
-    public void setAlpha(int alpha) {
-
-    }
+    public void setAlpha(int alpha) {}
 
     @Override
-    public void setColorFilter(ColorFilter cf) {
-
-    }
+    public void setColorFilter(ColorFilter cf) {}
 
     @Override
     public int getOpacity() {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index d440630cd..7f56c67ec 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -35,7 +35,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
-  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  private static final byte[] GIF_HEADER = new byte[] {0x47, 0x49, 0x46};
   private static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
@@ -56,8 +56,8 @@ public void setUp() {
     when(parser.parseHeader()).thenReturn(gifHeader);
     when(parserPool.obtain(isA(ByteBuffer.class))).thenReturn(parser);
 
-    when(decoderFactory.build(isA(GifDecoder.BitmapProvider.class),
-        eq(gifHeader), isA(ByteBuffer.class), anyInt()))
+    when(decoderFactory.build(
+            isA(GifDecoder.BitmapProvider.class), eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
     List<ImageHeaderParser> parsers = new ArrayList<>();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
index c83dd1740..2b5cfbba3 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
@@ -40,5 +40,4 @@ public void testStopsAndThenRecyclesDrawableWhenRecycled() {
     inOrder.verify(drawable).stop();
     inOrder.verify(drawable).recycle();
   }
-
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 1e18b6556..b35c8d645 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -54,8 +54,10 @@
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18,
-    shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = {GlideShadowLooper.class, BitmapTrackingShadowCanvas.class})
 public class GifDrawableTest {
   @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
 
@@ -514,7 +516,6 @@ public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsFo
     assertTrue("drawable should be still running", drawable.isRunning());
   }
 
-
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -589,7 +590,7 @@ public void testThrowsIfCreatedWithNullState() {
 
   @Test
   public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops() {
-    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] {drawable});
     drawable.setCallback(topLevel);
     topLevel.setCallback(null);
 
@@ -601,7 +602,7 @@ public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops(
 
   @Test
   public void onFrameReady_whenAttachedtoDrawableCallbackWithViewCallbackParent_doesNotStop() {
-      TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] {drawable});
     drawable.setCallback(topLevel);
     topLevel.setCallback(new View(context));
 
@@ -620,16 +621,15 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
-        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+        assertTrue(
+            "drawable should be started before calling drawable.onFrameReady()",
             drawable.isRunning());
         drawable.onFrameReady();
       }
     }
   }
 
-  /**
-   * Keeps track of the set of Bitmaps drawn to the canvas.
-   */
+  /** Keeps track of the set of Bitmaps drawn to the canvas. */
   @Implements(Canvas.class)
   public static final class BitmapTrackingShadowCanvas extends ShadowCanvas {
     private final Set<Bitmap> drawnBitmaps = new HashSet<>();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index f31857b81..f4c8e72d9 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -86,10 +86,13 @@ public void testSetsTransformationAsFrameTransformation() {
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(wrapped)
+    doAnswer(new Util.WriteDigest("first"))
+        .when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
+    @SuppressWarnings("unchecked")
+    Transformation<Bitmap> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other"))
+        .when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
     keyTester
         .addEquivalenceGroup(
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 9cb5b0e21..84ea6e7ce 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -75,14 +75,15 @@ public void setUp() {
   @NonNull
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
-    GifFrameLoader result = new GifFrameLoader(
-        glide.getBitmapPool(),
-        requestManager,
-        gifDecoder,
-        handler,
-        requestBuilder,
-        transformation,
-        firstFrame);
+    GifFrameLoader result =
+        new GifFrameLoader(
+            glide.getBitmapPool(),
+            requestManager,
+            gifDecoder,
+            handler,
+            requestBuilder,
+            transformation,
+            firstFrame);
     result.subscribe(callback);
     return result;
   }
@@ -209,8 +210,7 @@ public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
     DelayTarget previous = newDelayTarget();
     Request previousRequest = mock(Request.class);
     previous.setRequest(previousRequest);
-    previous.onResourceReady(
-        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null);
+    previous.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null);
 
     DelayTarget current = mock(DelayTarget.class);
     when(current.getResource()).thenReturn(null);
@@ -224,8 +224,9 @@ public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
   public void testDelayTargetSendsMessageWithHandlerDelayed() {
     long targetTime = 1234;
     DelayTarget delayTarget = new DelayTarget(handler, 1, targetTime);
-    delayTarget.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    delayTarget.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
     verify(handler).sendMessageAtTime(isA(Message.class), eq(targetTime));
   }
 
@@ -254,7 +255,7 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
 
   @Test
   public void
-  testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
+      testDoesNotReturnResourceForCompletedFrameInGetCurrentFrameIfLoadCompletesWhileCleared() {
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
@@ -325,8 +326,7 @@ public void onFrameReady_whenNotRunning_callsFrameReadyWithNewFrameOnStart() {
 
     DelayTarget nextFrame = mock(DelayTarget.class);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
-    when(nextFrame.getResource())
-        .thenReturn(expected);
+    when(nextFrame.getResource()).thenReturn(expected);
     loader.onFrameReady(nextFrame);
 
     verify(callback, times(1)).onFrameReady();
@@ -345,8 +345,7 @@ public void startFromFirstFrame_withPendingFrame_clearsPendingFrame() {
 
     DelayTarget nextFrame = mock(DelayTarget.class);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
-    when(nextFrame.getResource())
-        .thenReturn(expected);
+    when(nextFrame.getResource()).thenReturn(expected);
     loader.onFrameReady(nextFrame);
 
     loader.setNextStartFromFirstFrame();
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index f50eaf075..9b5db247f 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -23,7 +23,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamGifDecoderTest {
-  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  private static final byte[] GIF_HEADER = new byte[] {0x47, 0x49, 0x46};
 
   @Mock private ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private StreamGifDecoder decoder;
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index fc1c7777c..e57e32d9d 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -31,7 +31,7 @@ public void setUp() {
 
   @Test
   public void testReturnsBytesOfGivenGifDrawable() {
-    for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
+    for (String fakeData : new String[] {"test", "1235asfklaw3", "@$@#"}) {
       ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes(Charset.defaultCharset()));
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index e78445533..58576f582 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -24,15 +24,17 @@ public void setUp() {
   @Test
   public void testReturnsDefaultConnectivityMonitorWhenHasPermission() {
     ShadowApplication.getInstance().grantPermissions("android.permission.ACCESS_NETWORK_STATE");
-    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
-        mock(ConnectivityMonitor.ConnectivityListener.class));
+    ConnectivityMonitor connectivityMonitor =
+        factory.build(
+            RuntimeEnvironment.application, mock(ConnectivityMonitor.ConnectivityListener.class));
     assertThat(connectivityMonitor).isInstanceOf(DefaultConnectivityMonitor.class);
   }
 
   @Test
   public void testReturnsNullConnectivityMonitorWhenDoesNotHavePermission() {
-    ConnectivityMonitor connectivityMonitor = factory.build(RuntimeEnvironment.application,
-        mock(ConnectivityMonitor.ConnectivityListener.class));
+    ConnectivityMonitor connectivityMonitor =
+        factory.build(
+            RuntimeEnvironment.application, mock(ConnectivityMonitor.ConnectivityListener.class));
     assertThat(connectivityMonitor).isInstanceOf(NullConnectivityMonitor.class);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 386c842de..fb7e44164 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -35,7 +35,6 @@
   private DefaultConnectivityMonitor monitor;
   private ConnectivityHarness harness;
 
-
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
@@ -161,8 +160,9 @@ public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyLis
     private final PermissionConnectivityManager shadowConnectivityManager;
 
     public ConnectivityHarness() {
-      ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
-          .getSystemService(Context.CONNECTIVITY_SERVICE);
+      ConnectivityManager connectivityManager =
+          (ConnectivityManager)
+              RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
       shadowConnectivityManager = Shadow.extract(connectivityManager);
     }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index 60c59027d..4ac0b520c 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -18,9 +18,7 @@
 import android.widget.ImageView;
 import com.bumptech.glide.Glide;
 
-/**
- * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
- */
+/** A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117. */
 @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
@@ -69,4 +67,3 @@ protected void onAttachedToWindow() {
     }
   }
 }
-
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 191f02309..8bd5d5ecc 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -26,96 +26,105 @@
 
   @Before
   public void setUp() {
-    harnesses = new Harness[] { new RequestManagerHarness(), new SupportRequestManagerHarness() };
+    harnesses = new Harness[] {new RequestManagerHarness(), new SupportRequestManagerHarness()};
   }
 
   @Test
   public void testSupportCanSetAndGetRequestManager() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        RequestManager manager = mock(RequestManager.class);
-        harness.setRequestManager(manager);
-        assertEquals(manager, harness.getManager());
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            RequestManager manager = mock(RequestManager.class);
+            harness.setRequestManager(manager);
+            assertEquals(manager, harness.getManager());
+          }
+        });
   }
 
   @Test
   public void testReturnsLifecycle() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            assertEquals(harness.getHarnessLifecycle(), harness.getFragmentLifecycle());
+          }
+        });
   }
 
   @Test
   public void testDoesNotAddNullRequestManagerToLifecycleWhenSet() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.setRequestManager(null);
-        verify(harness.getHarnessLifecycle(), never()).addListener(any(LifecycleListener.class));
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.setRequestManager(null);
+            verify(harness.getHarnessLifecycle(), never())
+                .addListener(any(LifecycleListener.class));
+          }
+        });
   }
 
   @Test
   public void testCallsLifecycleStart() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start();
-
-        verify(harness.getHarnessLifecycle()).onStart();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start();
+
+            verify(harness.getHarnessLifecycle()).onStart();
+          }
+        });
   }
 
   @Test
   public void testCallsRequestManagerStop() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start().resume().pause().stop();
-
-        verify(harness.getHarnessLifecycle()).onStop();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start().resume().pause().stop();
+
+            verify(harness.getHarnessLifecycle()).onStop();
+          }
+        });
   }
 
   @Test
   public void testCallsRequestManagerDestroy() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.getController().start().resume().pause().stop().destroy();
-
-        verify(harness.getHarnessLifecycle()).onDestroy();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.getController().start().resume().pause().stop().destroy();
+
+            verify(harness.getHarnessLifecycle()).onDestroy();
+          }
+        });
   }
 
   @Test
   public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.onLowMemory();
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.onLowMemory();
+          }
+        });
   }
 
   @Test
   public void testOnTrimMemoryCallOnNullRequestManagerDoesNotCrash() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        harness.onTrimMemory(100 /*level*/);
-      }
-    });
+    runTest(
+        new TestCase() {
+          @Override
+          public void runTest(Harness harness) {
+            harness.onTrimMemory(100 /*level*/);
+          }
+        });
   }
 
   private void runTest(TestCase testCase) {
@@ -157,14 +166,8 @@ private void runTest(TestCase testCase) {
     public RequestManagerHarness() {
       fragment = new RequestManagerFragment(lifecycle);
       controller = Robolectric.buildActivity(Activity.class).create();
-      controller.get()
-          .getFragmentManager()
-          .beginTransaction()
-          .add(fragment, TAG)
-          .commit();
-      controller.get()
-          .getFragmentManager()
-          .executePendingTransactions();
+      controller.get().getFragmentManager().beginTransaction().add(fragment, TAG).commit();
+      controller.get().getFragmentManager().executePendingTransactions();
     }
 
     @Override
@@ -217,7 +220,8 @@ public SupportRequestManagerHarness() {
       supportFragment = new SupportRequestManagerFragment(lifecycle);
       supportController = Robolectric.buildActivity(FragmentActivity.class).create();
 
-      supportController.get()
+      supportController
+          .get()
           .getSupportFragmentManager()
           .beginTransaction()
           .add(supportFragment, TAG)
diff --git a/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index dd07da813..a690045f3 100644
--- a/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -50,7 +50,7 @@ public void setUp() {
     retriever = new RequestManagerRetriever(null /*factory*/);
 
     harnesses =
-        new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
+        new RetrieverHarness[] {new DefaultRetrieverHarness(), new SupportRetrieverHarness()};
 
     initialSdkVersion = Build.VERSION.SDK_INT;
     Util.setSdkVersionInt(18);
@@ -115,8 +115,8 @@ public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExisti
 
   @Test
   public void testHasValidTag() {
-    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
-        RequestManagerRetriever.FRAGMENT_TAG);
+    assertEquals(
+        RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
   }
 
   @Test
@@ -173,7 +173,11 @@ public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
   private void helpTestCanGetRequestManagerFromDetachedFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
     android.app.Fragment fragment = new android.app.Fragment();
-    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).detach(fragment)
+    activity
+        .getFragmentManager()
+        .beginTransaction()
+        .add(fragment, PARENT_TAG)
+        .detach(fragment)
         .commit();
     activity.getFragmentManager().executePendingTransactions();
 
@@ -196,8 +200,12 @@ private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
     FragmentActivity activity =
         Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
     Fragment fragment = new Fragment();
-    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG)
-        .detach(fragment).commit();
+    activity
+        .getSupportFragmentManager()
+        .beginTransaction()
+        .add(fragment, PARENT_TAG)
+        .detach(fragment)
+        .commit();
     activity.getSupportFragmentManager().executePendingTransactions();
 
     assertTrue(fragment.isDetached());
@@ -291,12 +299,13 @@ public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
   @Test
   public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
       throws InterruptedException {
-    testInBackground(new BackgroundTester() {
-      @Override
-      public void runTest() {
-        retriever.get(RuntimeEnvironment.application);
-      }
-    });
+    testInBackground(
+        new BackgroundTester() {
+          @Override
+          public void runTest() {
+            retriever.get(RuntimeEnvironment.application);
+          }
+        });
   }
 
   // See Issue #117: https://github.com/bumptech/glide/issues/117.
@@ -356,7 +365,11 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
       this.parent = new android.app.Fragment();
 
       controller.create();
-      controller.get().getFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+      controller
+          .get()
+          .getFragmentManager()
+          .beginTransaction()
+          .add(parent, PARENT_TAG)
           .commitAllowingStateLoss();
       controller.get().getFragmentManager().executePendingTransactions();
       controller.start().resume();
@@ -374,10 +387,11 @@ public RequestManager doGet() {
 
     @Override
     public boolean hasFragmentWithTag(String tag) {
-      return null != controller
-          .get()
-          .getFragmentManager()
-          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
+      return null
+          != controller
+              .get()
+              .getFragmentManager()
+              .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
     }
 
     @SuppressWarnings("deprecation")
@@ -385,8 +399,12 @@ public boolean hasFragmentWithTag(String tag) {
     public void addFragmentWithTag(String tag, RequestManager requestManager) {
       RequestManagerFragment fragment = new RequestManagerFragment();
       fragment.setRequestManager(requestManager);
-      controller.get().getFragmentManager().beginTransaction()
-          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller
+          .get()
+          .getFragmentManager()
+          .beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
+          .commitAllowingStateLoss();
       controller.get().getFragmentManager().executePendingTransactions();
     }
   }
@@ -400,7 +418,11 @@ public SupportRetrieverHarness() {
       this.parent = new Fragment();
 
       controller.create();
-      controller.get().getSupportFragmentManager().beginTransaction().add(parent, PARENT_TAG)
+      controller
+          .get()
+          .getSupportFragmentManager()
+          .beginTransaction()
+          .add(parent, PARENT_TAG)
           .commitAllowingStateLoss();
       controller.get().getSupportFragmentManager().executePendingTransactions();
       controller.start().resume();
@@ -418,16 +440,23 @@ public RequestManager doGet() {
 
     @Override
     public boolean hasFragmentWithTag(String tag) {
-      return controller.get().getSupportFragmentManager()
-          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG) != null;
+      return controller
+              .get()
+              .getSupportFragmentManager()
+              .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
+          != null;
     }
 
     @Override
     public void addFragmentWithTag(String tag, RequestManager manager) {
       SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
       fragment.setRequestManager(manager);
-      controller.get().getSupportFragmentManager().beginTransaction()
-          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
+      controller
+          .get()
+          .getSupportFragmentManager()
+          .beginTransaction()
+          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
+          .commitAllowingStateLoss();
       controller.get().getSupportFragmentManager().executePendingTransactions();
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 698425e22..dcfed5d20 100644
--- a/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -111,16 +111,14 @@ private void addToManifest(String key) {
     applicationInfo.metaData.putString(key, MODULE_VALUE);
   }
 
-  private static class InvalidClass { }
+  private static class InvalidClass {}
 
   public static class TestModule1 implements GlideModule {
     @Override
-    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
-    }
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {}
 
     @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-    }
+    public void registerComponents(Context context, Glide glide, Registry registry) {}
 
     @Override
     public boolean equals(Object o) {
@@ -136,12 +134,10 @@ public int hashCode() {
   public static class TestModule2 implements GlideModule {
 
     @Override
-    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
-    }
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {}
 
     @Override
-    public void registerComponents(Context context, Glide glide, Registry registry) {
-    }
+    public void registerComponents(Context context, Glide glide, Registry registry) {}
 
     @Override
     public boolean equals(Object o) {
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index e45aace85..3feff57b5 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -62,7 +62,7 @@ public void testReturnsTrueFromIsDoneIfDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     assertTrue(future.isDone());
@@ -105,7 +105,7 @@ public void testDoesNotClearRequestIfCancelledAfterDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.cancel(true);
@@ -124,7 +124,7 @@ public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.cancel(true);
@@ -143,7 +143,7 @@ public void testReturnsFalseFromCancelIfDone() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     assertFalse(future.cancel(true));
@@ -156,7 +156,7 @@ public void testReturnsResourceOnGetIfAlreadyDone()
     future.onResourceReady(
         /*resource=*/ expected,
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
 
@@ -170,7 +170,7 @@ public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
     future.onResourceReady(
         /*resource=*/ expected,
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
 
@@ -226,13 +226,12 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
   }
 
   @Test
-  public void testGetSucceedsOnMainThreadIfDone()
-      throws ExecutionException, InterruptedException {
+  public void testGetSucceedsOnMainThreadIfDone() throws ExecutionException, InterruptedException {
     future = new RequestFutureTarget<>(width, height, true, waiter);
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     future.get();
@@ -311,7 +310,7 @@ public void testNotifiesAllWhenResourceReady() {
     future.onResourceReady(
         /*resource=*/ new Object(),
         /*model=*/ null,
-        /*target=*/future,
+        /*target=*/ future,
         DataSource.DATA_DISK_CACHE,
         true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index 48123faeb..d3ec2f9b7 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -259,7 +259,7 @@ public void testApplyMultiTransform() {
     assertThat(options.isTransformationRequired()).isTrue();
     assertThat(options.getTransformations()).containsKey(Bitmap.class);
     assertThat(options.getTransformations().get(Bitmap.class))
-      .isInstanceOf(MultiTransformation.class);
+        .isInstanceOf(MultiTransformation.class);
   }
 
   @Test
@@ -290,17 +290,16 @@ public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
 
   @Test
   public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
-    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet())
-        .isTrue();
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet()).isTrue();
   }
 
   @Test
   public void getPlaceholder_afterSettingPlaceholderId_returnsNul() {
     assertThat(
-        options
-            .placeholder(new ColorDrawable(Color.RED))
-            .placeholder(android.R.drawable.star_on)
-            .getPlaceholderDrawable())
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .placeholder(android.R.drawable.star_on)
+                .getPlaceholderDrawable())
         .isNull();
   }
 
@@ -309,10 +308,10 @@ public void getPlaceholder_afterApplyingOptionsWithPlaceholderId_returnsNull() {
     RequestOptions toApply = new RequestOptions().placeholder(android.R.drawable.star_on);
 
     assertThat(
-        options
-            .placeholder(new ColorDrawable(Color.RED))
-            .apply(toApply)
-            .getPlaceholderDrawable())
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(toApply)
+                .getPlaceholderDrawable())
         .isNull();
   }
 
@@ -322,10 +321,10 @@ public void getPlaceholder_afterApplyingOptionsWithPlaceholderDrawable_returnsNe
     RequestOptions toApply = new RequestOptions().placeholder(expected);
 
     assertThat(
-        options
-          .placeholder(new ColorDrawable(Color.RED))
-          .apply(toApply)
-          .getPlaceholderDrawable())
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(toApply)
+                .getPlaceholderDrawable())
         .isEqualTo(expected);
   }
 
@@ -336,25 +335,22 @@ public void getPlaceholder_afterApplyingOptionsWithPlaceholderDrawable_returnsNe
   @Test
   public void placeholderIdFlag_afterApplyingIdViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .placeholder(new ColorDrawable(Color.RED))
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .placeholder(android.R.drawable.star_on)))
-            .getPlaceholderDrawable())
+            options
+                .placeholder(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().placeholder(android.R.drawable.star_on)))
+                .getPlaceholderDrawable())
         .isNull();
   }
 
-
   @Test
   public void getPlaceholderId_afterSettingPlaceholderDrawable_returnsZero() {
     assertThat(
-        options
-            .placeholder(android.R.drawable.star_on)
-            .placeholder(new ColorDrawable(Color.RED))
-            .getPlaceholderId())
+            options
+                .placeholder(android.R.drawable.star_on)
+                .placeholder(new ColorDrawable(Color.RED))
+                .getPlaceholderId())
         .isEqualTo(0);
   }
 
@@ -362,11 +358,7 @@ public void getPlaceholderId_afterSettingPlaceholderDrawable_returnsZero() {
   public void getPlaceholderId_afterApplyingOptionsWithPlaceholderDrawable_returnsZero() {
     RequestOptions toApply = new RequestOptions().placeholder(new ColorDrawable(Color.RED));
 
-    assertThat(
-        options
-            .placeholder(android.R.drawable.star_on)
-            .apply(toApply)
-            .getPlaceholderId())
+    assertThat(options.placeholder(android.R.drawable.star_on).apply(toApply).getPlaceholderId())
         .isEqualTo(0);
   }
 
@@ -375,11 +367,7 @@ public void getPlaceholderId_afterApplyingOptionsWithId_returnsNewId() {
     int expectedId = android.R.drawable.star_off;
     RequestOptions toApply = new RequestOptions().placeholder(expectedId);
 
-    assertThat(
-        options
-            .placeholder(android.R.drawable.star_on)
-            .apply(toApply)
-            .getPlaceholderId())
+    assertThat(options.placeholder(android.R.drawable.star_on).apply(toApply).getPlaceholderId())
         .isEqualTo(expectedId);
   }
 
@@ -390,24 +378,22 @@ public void getPlaceholderId_afterApplyingOptionsWithId_returnsNewId() {
   @Test
   public void placeholderFlag_afterApplyingViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .placeholder(android.R.drawable.star_on)
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .placeholder(new ColorDrawable(Color.RED))))
-            .getPlaceholderId())
+            options
+                .placeholder(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().placeholder(new ColorDrawable(Color.RED))))
+                .getPlaceholderId())
         .isEqualTo(0);
   }
 
   @Test
   public void getFallback_afterSettingFallbackId_returnsNull() {
     assertThat(
-        options
-            .fallback(new ColorDrawable(Color.RED))
-            .fallback(android.R.drawable.star_on)
-            .getFallbackDrawable())
+            options
+                .fallback(new ColorDrawable(Color.RED))
+                .fallback(android.R.drawable.star_on)
+                .getFallbackDrawable())
         .isNull();
   }
 
@@ -415,11 +401,7 @@ public void getFallback_afterSettingFallbackId_returnsNull() {
   public void getFallback_afterApplyingOptionsWithFallbackId_returnsNull() {
     RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_on);
 
-    assertThat(
-        options
-            .fallback(new ColorDrawable(Color.RED))
-            .apply(toApply)
-            .getFallbackDrawable())
+    assertThat(options.fallback(new ColorDrawable(Color.RED)).apply(toApply).getFallbackDrawable())
         .isNull();
   }
 
@@ -432,30 +414,28 @@ public void getFallback_afterApplyingOptionsWithFallbackDrawable_returnsNewDrawa
   }
 
   /**
-   * Verifies that we set the flags for fallback correctly when applying a fallback via
-   * another RequestOptions.
+   * Verifies that we set the flags for fallback correctly when applying a fallback via another
+   * RequestOptions.
    */
   @Test
   public void fallbackFlag_afterApplyingViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .fallback(android.R.drawable.star_on)
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .fallback(new ColorDrawable(Color.RED))))
-            .getFallbackId())
+            options
+                .fallback(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().fallback(new ColorDrawable(Color.RED))))
+                .getFallbackId())
         .isEqualTo(0);
   }
 
   @Test
   public void getFallbackId_afterSettingFallbackDrawable_returnsZero() {
     assertThat(
-        options
-            .fallback(android.R.drawable.star_on)
-            .fallback(new ColorDrawable(Color.RED))
-            .getFallbackId())
+            options
+                .fallback(android.R.drawable.star_on)
+                .fallback(new ColorDrawable(Color.RED))
+                .getFallbackId())
         .isEqualTo(0);
   }
 
@@ -463,11 +443,7 @@ public void getFallbackId_afterSettingFallbackDrawable_returnsZero() {
   public void getFallbackId_afterApplyingOptionsWithFallbackDrawable_returnsZero() {
     RequestOptions toApply = new RequestOptions().fallback(new ColorDrawable(Color.RED));
 
-    assertThat(
-        options
-            .fallback(android.R.drawable.star_on)
-            .apply(toApply)
-            .getFallbackId())
+    assertThat(options.fallback(android.R.drawable.star_on).apply(toApply).getFallbackId())
         .isEqualTo(0);
   }
 
@@ -475,11 +451,7 @@ public void getFallbackId_afterApplyingOptionsWithFallbackDrawable_returnsZero()
   public void getFallbackId_afterApplyingOptionsWithFallbackId_returnsNewFallbackId() {
     RequestOptions toApply = new RequestOptions().fallback(android.R.drawable.star_off);
 
-    assertThat(
-        options
-          .fallback(android.R.drawable.star_on)
-          .apply(toApply)
-          .getFallbackId())
+    assertThat(options.fallback(android.R.drawable.star_on).apply(toApply).getFallbackId())
         .isEqualTo(android.R.drawable.star_off);
   }
 
@@ -490,24 +462,22 @@ public void getFallbackId_afterApplyingOptionsWithFallbackId_returnsNewFallbackI
   @Test
   public void fallbackIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .fallback(new ColorDrawable(Color.RED))
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .fallback(android.R.drawable.star_on)))
-            .getFallbackDrawable())
+            options
+                .fallback(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().fallback(android.R.drawable.star_on)))
+                .getFallbackDrawable())
         .isNull();
   }
 
   @Test
   public void getError_afterSettingErrorId_returnsNull() {
     assertThat(
-        options
-            .error(new ColorDrawable(Color.RED))
-            .error(android.R.drawable.star_on)
-            .getErrorPlaceholder())
+            options
+                .error(new ColorDrawable(Color.RED))
+                .error(android.R.drawable.star_on)
+                .getErrorPlaceholder())
         .isNull();
   }
 
@@ -515,11 +485,7 @@ public void getError_afterSettingErrorId_returnsNull() {
   public void getError_afterApplyingOptionsWithErrorId_returnsNull() {
     RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_on);
 
-    assertThat(
-        options
-            .error(new ColorDrawable(Color.RED))
-            .apply(toApply)
-            .getErrorPlaceholder())
+    assertThat(options.error(new ColorDrawable(Color.RED)).apply(toApply).getErrorPlaceholder())
         .isNull();
   }
 
@@ -528,39 +494,33 @@ public void getError_afterApplyingOptionsWithErrorDrawable_returnsNewErrorDrawab
     Drawable expected = new ColorDrawable(Color.GREEN);
     RequestOptions toApply = new RequestOptions().error(expected);
 
-    assertThat(
-        options
-          .error(new ColorDrawable(Color.RED))
-          .apply(toApply)
-          .getErrorPlaceholder())
+    assertThat(options.error(new ColorDrawable(Color.RED)).apply(toApply).getErrorPlaceholder())
         .isEqualTo(expected);
   }
 
   /**
-   * Verifies that we set the flags for error correctly when applying an error via
-   * another RequestOptions.
+   * Verifies that we set the flags for error correctly when applying an error via another
+   * RequestOptions.
    */
   @Test
   public void errorFlag_afterApplyingViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .error(android.R.drawable.star_on)
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .error(new ColorDrawable(Color.RED))))
-            .getErrorId())
+            options
+                .error(android.R.drawable.star_on)
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().error(new ColorDrawable(Color.RED))))
+                .getErrorId())
         .isEqualTo(0);
   }
 
   @Test
   public void getErrorId_afterSettingErrorDrawable_returnsZero() {
     assertThat(
-        options
-            .error(android.R.drawable.star_on)
-            .error(new ColorDrawable(Color.RED))
-            .getErrorId())
+            options
+                .error(android.R.drawable.star_on)
+                .error(new ColorDrawable(Color.RED))
+                .getErrorId())
         .isEqualTo(0);
   }
 
@@ -568,39 +528,30 @@ public void getErrorId_afterSettingErrorDrawable_returnsZero() {
   public void getErrorId_afterApplyingOptionsWithErrorDrawable_returnsZero() {
     RequestOptions toApply = new RequestOptions().error(new ColorDrawable(Color.RED));
 
-    assertThat(
-        options.error(android.R.drawable.star_on)
-            .apply(toApply)
-            .getErrorId())
-        .isEqualTo(0);
+    assertThat(options.error(android.R.drawable.star_on).apply(toApply).getErrorId()).isEqualTo(0);
   }
 
   @Test
   public void getErrorId_afterApplyingOptionsWithErrorId_returnsNewErrorId() {
     RequestOptions toApply = new RequestOptions().error(android.R.drawable.star_off);
 
-    assertThat(
-        options.error(android.R.drawable.star_on)
-            .apply(toApply)
-            .getErrorId())
+    assertThat(options.error(android.R.drawable.star_on).apply(toApply).getErrorId())
         .isEqualTo(android.R.drawable.star_off);
   }
 
   /**
-   * Verifies that we set the flags for error id correctly when applying a fallback id via
-   * another RequestOptions.
+   * Verifies that we set the flags for error id correctly when applying a fallback id via another
+   * RequestOptions.
    */
   @Test
   public void errorIdFlag_afterApplyingViaOtherRequestOptions_isSet() {
     assertThat(
-        options
-            .error(new ColorDrawable(Color.RED))
-            .apply(
-                new RequestOptions()
-                    .apply(
-                        new RequestOptions()
-                            .error(android.R.drawable.star_on)))
-            .getErrorPlaceholder())
+            options
+                .error(new ColorDrawable(Color.RED))
+                .apply(
+                    new RequestOptions()
+                        .apply(new RequestOptions().error(android.R.drawable.star_on)))
+                .getErrorPlaceholder())
         .isNull();
   }
 
@@ -612,8 +563,7 @@ public void testEqualsHashCode() {
     assertThat(Util.bothNullOrEqual(first, second)).isFalse();
     new EqualsTester()
         .addEqualityGroup(
-            new RequestOptions().sizeMultiplier(.7f),
-            new RequestOptions().sizeMultiplier(.7f))
+            new RequestOptions().sizeMultiplier(.7f), new RequestOptions().sizeMultiplier(.7f))
         .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
         .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
         .addEqualityGroup(new RequestOptions().error(2))
@@ -622,18 +572,15 @@ public void testEqualsHashCode() {
         .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
         .addEqualityGroup(new RequestOptions().placeholder(2))
         .addEqualityGroup(
-            new RequestOptions().placeholder(first),
-            new RequestOptions().placeholder(first))
+            new RequestOptions().placeholder(first), new RequestOptions().placeholder(first))
         .addEqualityGroup(new RequestOptions().placeholder(second))
         .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
         .addEqualityGroup(new RequestOptions().fallback(2))
         .addEqualityGroup(
-            new RequestOptions().fallback(first),
-            new RequestOptions().fallback(first))
+            new RequestOptions().fallback(first), new RequestOptions().fallback(first))
         .addEqualityGroup(new RequestOptions().fallback(second))
         .addEqualityGroup(
-            new RequestOptions().skipMemoryCache(true),
-            new RequestOptions().skipMemoryCache(true))
+            new RequestOptions().skipMemoryCache(true), new RequestOptions().skipMemoryCache(true))
         .addEqualityGroup(
             new RequestOptions(),
             new RequestOptions().skipMemoryCache(false),
@@ -641,23 +588,16 @@ public void testEqualsHashCode() {
             new RequestOptions().onlyRetrieveFromCache(false),
             new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
         .addEqualityGroup(
-            new RequestOptions().override(100),
-            new RequestOptions().override(100, 100))
+            new RequestOptions().override(100), new RequestOptions().override(100, 100))
         .addEqualityGroup(
-            new RequestOptions().override(200),
-            new RequestOptions().override(200, 200))
+            new RequestOptions().override(200), new RequestOptions().override(200, 200))
         .addEqualityGroup(
-            new RequestOptions().override(100, 200),
-            new RequestOptions().override(100, 200))
+            new RequestOptions().override(100, 200), new RequestOptions().override(100, 200))
         .addEqualityGroup(
-            new RequestOptions().override(200, 100),
-            new RequestOptions().override(200, 100))
+            new RequestOptions().override(200, 100), new RequestOptions().override(200, 100))
+        .addEqualityGroup(new RequestOptions().centerCrop(), new RequestOptions().centerCrop())
         .addEqualityGroup(
-            new RequestOptions().centerCrop(),
-            new RequestOptions().centerCrop())
-        .addEqualityGroup(
-            new RequestOptions().optionalCenterCrop(),
-            new RequestOptions().optionalCenterCrop())
+            new RequestOptions().optionalCenterCrop(), new RequestOptions().optionalCenterCrop())
         .addEqualityGroup(new RequestOptions().fitCenter())
         .addEqualityGroup(new RequestOptions().circleCrop())
         .addEqualityGroup(new RequestOptions().centerInside())
@@ -670,34 +610,25 @@ public void testEqualsHashCode() {
         .addEqualityGroup(
             new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
             new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
-        .addEqualityGroup(
-            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
+        .addEqualityGroup(new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
         .addEqualityGroup(
             new RequestOptions().priority(Priority.HIGH),
             new RequestOptions().priority(Priority.HIGH))
-        .addEqualityGroup(
-            new RequestOptions().priority(Priority.LOW))
+        .addEqualityGroup(new RequestOptions().priority(Priority.LOW))
         .addEqualityGroup(
             new RequestOptions().set(Option.memory("test"), true),
             new RequestOptions().set(Option.memory("test"), true))
+        .addEqualityGroup(new RequestOptions().set(Option.memory("test"), false))
+        .addEqualityGroup(new RequestOptions().set(Option.memory("test2"), true))
         .addEqualityGroup(
-            new RequestOptions().set(Option.memory("test"), false))
-        .addEqualityGroup(
-            new RequestOptions().set(Option.memory("test2"), true))
-        .addEqualityGroup(
-            new RequestOptions().decode(Integer.class),
-            new RequestOptions().decode(Integer.class))
-        .addEqualityGroup(
-            new RequestOptions().decode(Float.class))
+            new RequestOptions().decode(Integer.class), new RequestOptions().decode(Integer.class))
+        .addEqualityGroup(new RequestOptions().decode(Float.class))
         .addEqualityGroup(
             new RequestOptions().signature(new ObjectKey("test")),
             new RequestOptions().signature(new ObjectKey("test")))
+        .addEqualityGroup(new RequestOptions().signature(new ObjectKey("test2")))
         .addEqualityGroup(
-            new RequestOptions().signature(new ObjectKey("test2")))
-        .addEqualityGroup(
-            new RequestOptions().theme(app.getTheme()),
-            new RequestOptions().theme(app.getTheme()))
+            new RequestOptions().theme(app.getTheme()), new RequestOptions().theme(app.getTheme()))
         .testEquals();
   }
-
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index e6f56512d..f46beb9a5 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -84,8 +84,8 @@ public void testCanHandleNullResources() {
     request.onResourceReady(null, DataSource.LOCAL);
 
     assertTrue(request.isFailed());
-    verify(listener1).onLoadFailed(isAGlideException(), isA(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), isA(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
@@ -97,8 +97,8 @@ public void testCanHandleEmptyResources() {
 
     assertTrue(request.isFailed());
     verify(builder.engine).release(eq(builder.resource));
-    verify(listener1).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), any(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
@@ -111,8 +111,8 @@ public void testCanHandleNonConformingResources() {
 
     assertTrue(request.isFailed());
     verify(builder.engine).release(eq(builder.resource));
-    verify(listener1).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean());
+    verify(listener1)
+        .onLoadFailed(isAGlideException(), any(Number.class), eq(builder.target), anyBoolean());
   }
 
   @Test
@@ -190,18 +190,19 @@ public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClea
   @Test
   public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
     RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocation) {
-        Request request = (Request) invocation.getArguments()[0];
-        assertFalse(request.isComplete());
-        return true;
-      }
-    }).when(requestCoordinator).canSetImage(any(Request.class));
-
-    SingleRequest<List> request = builder
-        .setRequestCoordinator(requestCoordinator)
-        .build();
+    doAnswer(
+            new Answer() {
+              @Override
+              public Object answer(InvocationOnMock invocation) {
+                Request request = (Request) invocation.getArguments()[0];
+                assertFalse(request.isComplete());
+                return true;
+              }
+            })
+        .when(requestCoordinator)
+        .canSetImage(any(Request.class));
+
+    SingleRequest<List> request = builder.setRequestCoordinator(requestCoordinator).build();
 
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
@@ -312,10 +313,8 @@ public void testPlaceholderDrawableIsSet() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(expected)
-        .setTarget(target)
-        .build();
+    SingleRequest<List> request =
+        builder.setPlaceholderDrawable(expected).setTarget(target).build();
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(expected);
@@ -327,10 +326,7 @@ public void testErrorDrawableIsSetOnLoadFailed() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setErrorDrawable(expected)
-        .setTarget(target)
-        .build();
+    SingleRequest<List> request = builder.setErrorDrawable(expected).setTarget(target).build();
 
     request.onLoadFailed(new GlideException("test"));
 
@@ -343,11 +339,8 @@ public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setErrorDrawable(placeholder)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder.setErrorDrawable(placeholder).setTarget(target).setModel(null).build();
 
     request.begin();
 
@@ -361,19 +354,19 @@ public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(placeholder)
-        .setErrorDrawable(errorPlaceholder)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder
+            .setPlaceholderDrawable(placeholder)
+            .setErrorDrawable(errorPlaceholder)
+            .setTarget(target)
+            .setModel(null)
+            .build();
 
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(errorPlaceholder);
   }
 
-
   @Test
   public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
     Drawable placeholder = new ColorDrawable(Color.RED);
@@ -381,19 +374,19 @@ public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     MockTarget target = new MockTarget();
-    SingleRequest<List> request = builder
-        .setPlaceholderDrawable(placeholder)
-        .setErrorDrawable(errorPlaceholder)
-        .setFallbackDrawable(fallback)
-        .setTarget(target)
-        .setModel(null)
-        .build();
+    SingleRequest<List> request =
+        builder
+            .setPlaceholderDrawable(placeholder)
+            .setErrorDrawable(errorPlaceholder)
+            .setFallbackDrawable(fallback)
+            .setTarget(target)
+            .setModel(null)
+            .build();
     request.begin();
 
     assertThat(target.currentPlaceholder).isEqualTo(fallback);
   }
 
-
   @Test
   public void testIsNotRunningBeforeRunCalled() {
     assertFalse(builder.build().isRunning());
@@ -446,12 +439,12 @@ public void testCallsTargetOnResourceReadyIfAllRequestListenersReturnFalse() {
     SingleRequest<List> request =
         builder.addRequestListener(listener1).addRequestListener(listener2).build();
 
-    when(listener1
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
-    when(listener2
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
+    when(listener2.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
     request.onResourceReady(builder.resource, DataSource.LOCAL);
 
     verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
@@ -462,12 +455,12 @@ public void testDoesNotCallTargetOnResourceReadyIfAnyRequestListenerReturnsTrue(
     SingleRequest<List> request =
         builder.addRequestListener(listener1).addRequestListener(listener2).build();
 
-    when(listener1
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
-    when(listener1
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean())).thenReturn(true);
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(false);
+    when(listener1.onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean()))
+        .thenReturn(true);
     request.onResourceReady(builder.resource, DataSource.REMOTE);
 
     verify(builder.target, never()).onResourceReady(any(List.class), anyTransition());
@@ -486,11 +479,11 @@ public void testCallsTargetOnExceptionIfAllRequestListenersReturnFalse() {
     SingleRequest<List> request =
         builder.addRequestListener(listener1).addRequestListener(listener2).build();
 
-    when(listener1.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+    when(listener1.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(false);
-    when(listener2.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+    when(listener2.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(false);
     request.onLoadFailed(new GlideException("test"));
 
@@ -502,11 +495,11 @@ public void testDoesNotCallTargetOnExceptionIfAnyRequestListenerReturnsTrue() {
     SingleRequest<List> request =
         builder.addRequestListener(listener1).addRequestListener(listener2).build();
 
-    when(listener1.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+    when(listener1.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(false);
-    when(listener2.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(builder.target), anyBoolean()))
+    when(listener2.onLoadFailed(
+            isAGlideException(), any(Number.class), eq(builder.target), anyBoolean()))
         .thenReturn(true);
 
     request.onLoadFailed(new GlideException("test"));
@@ -520,8 +513,8 @@ public void testRequestListenerIsCalledWithResourceResult() {
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            anyBoolean());
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), anyBoolean());
   }
 
   @Test
@@ -530,8 +523,8 @@ public void testRequestListenerIsCalledWithModel() {
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(any(List.class), eq(builder.model), isAListTarget(), isADataSource(),
-            anyBoolean());
+        .onResourceReady(
+            any(List.class), eq(builder.model), isAListTarget(), isADataSource(), anyBoolean());
   }
 
   @Test
@@ -540,8 +533,8 @@ public void testRequestListenerIsCalledWithTarget() {
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
-            anyBoolean());
+        .onResourceReady(
+            any(List.class), any(Number.class), eq(builder.target), isADataSource(), anyBoolean());
   }
 
   @Test
@@ -580,33 +573,39 @@ public Object answer(InvocationOnMock invocation) {
     request.begin();
     request.onSizeReady(100, 100);
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            eq(DataSource.MEMORY_CACHE), anyBoolean());
+        .onResourceReady(
+            eq(builder.result),
+            any(Number.class),
+            isAListTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
   }
 
   @Test
   public void
-  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+      testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
     SingleRequest<List> request = builder.addRequestListener(listener1).build();
     request.onSizeReady(100, 100);
     request.onResourceReady(builder.resource, DataSource.LOCAL);
 
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            eq(DataSource.LOCAL), anyBoolean());
+        .onResourceReady(
+            eq(builder.result),
+            any(Number.class),
+            isAListTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
   }
 
   @Test
   public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-    SingleRequest<List> request = builder
-        .setRequestCoordinator(null)
-        .addRequestListener(listener1)
-        .build();
+    SingleRequest<List> request =
+        builder.setRequestCoordinator(null).addRequestListener(listener1).build();
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(true));
   }
 
   @Test
@@ -616,20 +615,20 @@ public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturns
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(true));
   }
 
   @Test
   public void
-  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+      testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
     SingleRequest<List> request = builder.addRequestListener(listener1).build();
     when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(true);
     request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
 
     verify(listener1)
-        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
-            isADataSource(), eq(false));
+        .onResourceReady(
+            eq(builder.result), any(Number.class), isAListTarget(), isADataSource(), eq(false));
   }
 
   @Test
@@ -645,10 +644,7 @@ public void testTargetIsCalledWithAnimationFromFactory() {
 
   @Test
   public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(-1)
-        .setOverrideHeight(100)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(-1).setOverrideHeight(100).build();
     request.begin();
 
     verify(builder.target).getSize(any(SizeReadyCallback.class));
@@ -656,10 +652,7 @@ public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
 
   @Test
   public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(100)
-        .setOverrideHeight(-1)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(100).setOverrideHeight(-1).build();
     request.begin();
 
     verify(builder.target).getSize(any(SizeReadyCallback.class));
@@ -667,10 +660,7 @@ public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
 
   @Test
   public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(100)
-        .setOverrideHeight(100)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(100).setOverrideHeight(100).build();
     request.begin();
 
     verify(builder.target, never()).getSize(any(SizeReadyCallback.class));
@@ -678,10 +668,7 @@ public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
 
   @Test
   public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-    SingleRequest<List> request = builder
-        .setOverrideWidth(1)
-        .setOverrideHeight(2)
-        .build();
+    SingleRequest<List> request = builder.setOverrideWidth(1).setOverrideHeight(2).build();
     request.begin();
 
     verify(builder.engine)
@@ -709,9 +696,7 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
 
   @Test
   public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-    SingleRequest<List> request = builder
-        .setErrorDrawable(new ColorDrawable(Color.RED))
-        .build();
+    SingleRequest<List> request = builder.setErrorDrawable(new ColorDrawable(Color.RED)).build();
     when(builder.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
     request.onLoadFailed(new GlideException("test"));
 
@@ -720,7 +705,8 @@ public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
 
   @Test
   public void testCanReRunClearedRequests() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
     when(builder.engine.load(
@@ -790,15 +776,13 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterClear() {
             anyExecutor());
   }
 
-
   @Test
   public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    SingleRequest<List> request = builder
-        .setUseUnlimitedSourceGeneratorsPool(true)
-        .build();
+    SingleRequest<List> request = builder.setUseUnlimitedSourceGeneratorsPool(true).build();
     request.begin();
 
     verify(builder.engine)
@@ -826,12 +810,11 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
 
   @Test
   public void testCallsSourceExecutorEngineIfOptionsIsSet() {
-    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+    doAnswer(new CallSizeReady(100, 100))
+        .when(builder.target)
         .getSize(any(SizeReadyCallback.class));
 
-    SingleRequest<List> request = builder
-        .setUseUnlimitedSourceGeneratorsPool(false)
-        .build();
+    SingleRequest<List> request = builder.setUseUnlimitedSourceGeneratorsPool(false).build();
     request.begin();
 
     verify(builder.engine)
@@ -861,19 +844,20 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
   // Varargs
   @SuppressWarnings("unchecked")
   public void testIsEquivalentTo() {
-    EquivalenceTester<SingleRequestBuilder> tester = EquivalenceTester
-        .of(new Equivalence<SingleRequestBuilder>() {
-          @Override
-          protected boolean doEquivalent(
-              @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
-            return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
-          }
-
-          @Override
-          protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
-            return 0;
-          }
-        });
+    EquivalenceTester<SingleRequestBuilder> tester =
+        EquivalenceTester.of(
+            new Equivalence<SingleRequestBuilder>() {
+              @Override
+              protected boolean doEquivalent(
+                  @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
+                return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
+              }
+
+              @Override
+              protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
+                return 0;
+              }
+            });
     tester
         .addEquivalenceGroup(
             // Non-null request listeners are treated as equivalent, even if they're not equal.
@@ -886,11 +870,9 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
             new SingleRequestBuilder().setOverrideWidth(500),
             new SingleRequestBuilder().setOverrideWidth(500))
         .addEquivalenceGroup(
-            new SingleRequestBuilder().setModel(12345),
-            new SingleRequestBuilder().setModel(12345))
+            new SingleRequestBuilder().setModel(12345), new SingleRequestBuilder().setModel(12345))
         .addEquivalenceGroup(
-            new SingleRequestBuilder().setModel(null),
-            new SingleRequestBuilder().setModel(null))
+            new SingleRequestBuilder().setModel(null), new SingleRequestBuilder().setModel(null))
         .addEquivalenceGroup(
             new SingleRequestBuilder().setPriority(Priority.LOW),
             new SingleRequestBuilder().setPriority(Priority.LOW))
@@ -900,17 +882,22 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
   static final class SingleRequestBuilder {
     private Engine engine = mock(Engine.class);
     private Number model = 123456;
+
     @SuppressWarnings("unchecked")
     private Target<List> target = mock(Target.class);
+
     private Resource<List> resource = mockResource();
     private RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
     private Drawable placeholderDrawable = null;
     private Drawable errorDrawable = null;
     private Drawable fallbackDrawable = null;
+
     @SuppressWarnings("unchecked")
     private List<RequestListener<List>> requestListeners = new ArrayList<>();
+
     @SuppressWarnings("unchecked")
     private final TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+
     private int overrideWidth = -1;
     private int overrideHeight = -1;
     private List<?> result = new ArrayList<>();
@@ -1000,14 +987,15 @@ SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
     }
 
     SingleRequest<List> build() {
-      RequestOptions requestOptions = new RequestOptions()
-          .error(errorDrawable)
-          .placeholder(placeholderDrawable)
-          .fallback(fallbackDrawable)
-          .override(overrideWidth, overrideHeight)
-          .priority(priority)
-          .signature(signature)
-          .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
+      RequestOptions requestOptions =
+          new RequestOptions()
+              .error(errorDrawable)
+              .placeholder(placeholderDrawable)
+              .fallback(fallbackDrawable)
+              .override(overrideWidth, overrideHeight)
+              .priority(priority)
+              .signature(signature)
+              .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest.obtain(
           /*context=*/ glideContext,
           /*glideContext=*/ glideContext,
@@ -1099,25 +1087,21 @@ public void onLoadCleared(@Nullable Drawable placeholder) {
     @Override
     public void onLoadStarted(@Nullable Drawable placeholder) {
       currentPlaceholder = placeholder;
-
     }
 
     @Override
     public void onLoadFailed(@Nullable Drawable errorDrawable) {
       currentPlaceholder = errorDrawable;
-
     }
 
     @Override
-    public void onResourceReady(@NonNull List resource,
-        @Nullable Transition<? super List> transition) {
+    public void onResourceReady(
+        @NonNull List resource, @Nullable Transition<? super List> transition) {
       currentPlaceholder = null;
     }
 
-
     @Override
-    public void getSize(@NonNull SizeReadyCallback cb) {
-    }
+    public void getSize(@NonNull SizeReadyCallback cb) {}
 
     @Override
     public void removeCallback(@NonNull SizeReadyCallback cb) {
@@ -1125,8 +1109,7 @@ public void removeCallback(@NonNull SizeReadyCallback cb) {
     }
 
     @Override
-    public void setRequest(@Nullable Request request) {
-    }
+    public void setRequest(@Nullable Request request) {}
 
     @Nullable
     @Override
@@ -1135,17 +1118,12 @@ public Request getRequest() {
     }
 
     @Override
-    public void onStart() {
-    }
+    public void onStart() {}
 
     @Override
-    public void onStop() {
-
-    }
+    public void onStop() {}
 
     @Override
-    public void onDestroy() {
-
-    }
+    public void onDestroy() {}
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index 5bab9738a..dda24ef98 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -114,14 +114,17 @@ public void begin_whenFullIsComplete_doesNotSetRunning() {
 
   @Test
   public void testDoesNotStartFullIfClearedByThumb() {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        coordinator.clear();
-
-        return null;
-      }
-    }).when(thumb).begin();
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocation) throws Throwable {
+                coordinator.clear();
+
+                return null;
+              }
+            })
+        .when(thumb)
+        .begin();
 
     coordinator.begin();
 
@@ -168,7 +171,7 @@ public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImag
 
   @Test
   public void
-  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
+      testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
     when(full.isResourceSet()).thenReturn(false);
     assertTrue(coordinator.canSetImage(thumb));
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index a9a8ffe6e..f82aa5249 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -22,8 +22,10 @@
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
-    .UpdateShadowAppWidgetManager.class)
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = AppWidgetTargetTest.UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
@@ -54,8 +56,9 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
-    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertEquals(componentName, shadowManager.updatedComponentName);
     assertEquals(views, shadowManager.updatedRemoteViews);
@@ -63,7 +66,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
 
   @Test
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
-    int[] widgetIds = new int[] { 1 };
+    int[] widgetIds = new int[] {1};
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
@@ -75,12 +78,13 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
 
   @Test
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
-    int[] widgetIds = new int[] { 1 };
+    int[] widgetIds = new int[] {1};
     AppWidgetTarget target =
         new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
-    target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertThat(widgetIds).isEqualTo(shadowManager.updatedWidgetIds);
     assertEquals(views, shadowManager.updatedRemoteViews);
@@ -98,14 +102,14 @@ public void testThrowsWhenGivenNullContextWithComponentName() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application,
-        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(
+        RuntimeEnvironment.application, viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application,
-        viewId, null /*remoteViews*/, mock(ComponentName.class));
+    new AppWidgetTarget(
+        RuntimeEnvironment.application, viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index d0967ce08..7c7661112 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -37,8 +37,10 @@ public void testReturnsTargetForBitmaps() {
 
   @Test
   public void testReturnsTargetForBitmapDrawables() {
-    BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
-        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
+    BitmapDrawable drawable =
+        new BitmapDrawable(
+            RuntimeEnvironment.application.getResources(),
+            Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
 
     Target<BitmapDrawable> target = factory.buildTarget(view, BitmapDrawable.class);
     target.onResourceReady(drawable, null);
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index 9fd3f101d..bcd158d50 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -83,7 +83,8 @@ public void testSetsDrawableOnLoadCleared() {
 
   @Test
   public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
     Drawable resource = new ColorDrawable(Color.GRAY);
     target.onResourceReady(resource, animation);
@@ -94,7 +95,8 @@ public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
   @Test
   public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
     Drawable resource = new ColorDrawable(Color.RED);
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(eq(resource), eq(target))).thenReturn(true);
     target.onResourceReady(resource, animation);
 
@@ -106,7 +108,8 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     Drawable placeholder = new ColorDrawable(Color.BLACK);
     view.setImageDrawable(placeholder);
 
-    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked")
+    Transition<Drawable> animation = mock(Transition.class);
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index d1c51da32..8c3aba615 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -22,8 +22,10 @@
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
-    .UpdateShadowNotificationManager.class)
+@Config(
+    manifest = Config.NONE,
+    sdk = 18,
+    shadows = NotificationTargetTest.UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
@@ -46,10 +48,16 @@ public void setUp() {
     notificationId = 456;
     notificationTag = "tag";
 
-
     target =
-        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-            viewId, remoteViews, notification, notificationId, notificationTag);
+        new NotificationTarget(
+            RuntimeEnvironment.application,
+            100 /*width*/,
+            100 /*height*/,
+            viewId,
+            remoteViews,
+            notification,
+            notificationId,
+            notificationTag);
   }
 
   @Test
@@ -61,8 +69,9 @@ public void testSetsBitmapOnRemoteViewsWithGivenImageIdOnResourceReady() {
 
   @Test
   public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourceReady() {
-    target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
-    /*glideAnimation*/);
+    target.onResourceReady(
+        Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
+        /*glideAnimation*/ );
 
     assertEquals(notificationId, shadowManager.updatedNotificationId);
     assertEquals(notificationTag, shadowManager.updatedNotificationTag);
@@ -71,23 +80,40 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,
+    new NotificationTarget(
+        null /*context*/,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        mock(RemoteViews.class),
+        mock(Notification.class),
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
-
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,
+    new NotificationTarget(
+        RuntimeEnvironment.application,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        mock(RemoteViews.class),
+        null /*notification*/,
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
-        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,
+    new NotificationTarget(
+        RuntimeEnvironment.application,
+        100 /*width*/,
+        100 /*height*/,
+        123 /*viewId*/,
+        null /*remoteViews*/,
+        mock(Notification.class),
+        456 /*notificationId*/,
         "tag" /*notificationTag*/);
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 3093df1fb..b297b1e06 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -36,8 +36,8 @@ public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
   public void testCanBeConstructedWithoutDimensions() {
     new SimpleTarget<Object>() {
       @Override
-      public void onResourceReady(@NonNull Object resource,
-          @Nullable Transition<? super Object> transition) {
+      public void onResourceReady(
+          @NonNull Object resource, @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
@@ -56,8 +56,8 @@ public void testGetSizeDoesNotThrowWithSizeOriginal() {
   private SimpleTarget<Object> getTarget(int width, int height) {
     return new SimpleTarget<Object>(width, height) {
       @Override
-      public void onResourceReady(@NonNull Object resource,
-          @Nullable Transition<? super Object> transition) {
+      public void onResourceReady(
+          @NonNull Object resource, @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 54ce83580..d63943714 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -50,8 +50,13 @@
 import org.robolectric.shadows.ShadowView;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
-    ViewTargetTest.PreDrawShadowViewTreeObserver.class })
+@Config(
+    manifest = Config.NONE,
+    sdk = 19,
+    shadows = {
+      ViewTargetTest.SizedShadowView.class,
+      ViewTargetTest.PreDrawShadowViewTreeObserver.class
+    })
 public class ViewTargetTest {
   private View view;
   private ViewTarget<View, Object> target;
@@ -109,10 +114,7 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    shadowView
-        .setWidth(dimens)
-        .setHeight(dimens)
-        .setIsLaidOut(true);
+    shadowView.setWidth(dimens).setHeight(dimens).setIsLaidOut(true);
 
     target.getSize(cb);
 
@@ -185,9 +187,7 @@ public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWid
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int height = 32;
-    shadowView
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setHeight(height).setIsLaidOut(true);
 
     shadowObserver.fireOnPreDrawListeners();
 
@@ -205,11 +205,8 @@ public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplay
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
-
     int width = 32;
-    shadowView
-        .setWidth(width)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(width, 400);
@@ -226,10 +223,7 @@ public void testMatchParentWidthAndHeight() {
 
     int width = 32;
     int height = 45;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -241,10 +235,7 @@ public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
 
     int width = 12;
     int height = 32;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -259,10 +250,7 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
     }
 
     int width = 100, height = 111;
-    shadowView
-        .setWidth(width)
-        .setHeight(height)
-        .setIsLaidOut(true);
+    shadowView.setWidth(width).setHeight(height).setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     InOrder order = inOrder((Object[]) cbs);
@@ -401,10 +389,7 @@ public void testDecreasesDimensionsByViewPadding() {
 
   @Test
   public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .setIsLaidOut(false);
+    shadowView.setWidth(100).setHeight(100).setIsLaidOut(false);
     target.getSize(cb);
 
     verify(cb).onSizeReady(100, 100);
@@ -437,10 +422,7 @@ public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_cal
   @Test
   public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
     Util.setSdkVersionInt(18);
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .requestLayout();
+    shadowView.setWidth(100).setHeight(100).requestLayout();
 
     target.getSize(cb);
 
@@ -449,10 +431,7 @@ public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeRead
 
   @Test
   public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
-    shadowView
-        .setWidth(100)
-        .setHeight(100)
-        .setIsLaidOut(true);
+    shadowView.setWidth(100).setHeight(100).setIsLaidOut(true);
 
     view.setPadding(50, 50, 50, 50);
 
@@ -514,19 +493,14 @@ public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
 
   @Test
   public void clearOnDetach_moreThanOnce_registersObserverOnce() {
-    attachStateTarget
-        .clearOnDetach()
-        .clearOnDetach();
+    attachStateTarget.clearOnDetach().clearOnDetach();
 
     assertThat(shadowView.attachStateListeners).hasSize(1);
   }
 
   @Test
   public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
-    attachStateTarget
-        .clearOnDetach()
-        .clearOnDetach()
-        .clearOnDetach();
+    attachStateTarget.clearOnDetach().clearOnDetach().clearOnDetach();
     attachStateTarget.onLoadCleared(/*placeholder=*/ null);
     attachStateTarget.setRequest(request);
     shadowView.callOnDetachedFromWindow();
@@ -607,15 +581,14 @@ public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
   @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
-    OnAttachStateChangeListener expected = new OnAttachStateChangeListener() {
-      @Override
-      public void onViewAttachedToWindow(View v) {
-      }
-
-      @Override
-      public void onViewDetachedFromWindow(View v) {
-      }
-    };
+    OnAttachStateChangeListener expected =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {}
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {}
+        };
     shadowView.addOnAttachStateChangeListener(expected);
 
     attachStateTarget.onLoadCleared(/*placeholder=*/ null);
@@ -776,8 +749,8 @@ public LayoutParams getLayoutParams() {
     }
 
     @Override
-    public void onResourceReady(@NonNull Object resource,
-        @Nullable Transition<? super Object> transition) { }
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {}
   }
 
   private static final class TestViewTarget extends ViewTarget<View, Object> {
@@ -789,8 +762,8 @@ public void onResourceReady(@NonNull Object resource,
     // We're intentionally avoiding the super call.
     @SuppressWarnings("MissingSuperCall")
     @Override
-    public void onResourceReady(@NonNull Object resource,
-        @Nullable Transition<? super Object> transition) {
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
       // Avoid calling super.
     }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index e02f29e67..3ad6d5f98 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -25,19 +25,22 @@ public void setUp() {
 
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
-    assertEquals(NoTransition.<Drawable>get(),
+    assertEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource() {
-    assertNotEquals(NoTransition.<Drawable>get(),
+    assertNotEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsAnimationIfNotFromMemoryCacheAndNotIsFirstResource() {
-    assertNotEquals(NoTransition.<Drawable>get(),
+    assertNotEquals(
+        NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index e89b6f8bc..8f10a7c39 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -70,4 +70,3 @@ public void transition_withCurrentDrawable_returnsTrue() {
         new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
-
diff --git a/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
index 831a9d047..f0e33d1d8 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -23,19 +23,19 @@ public void setUp() {
 
   @Test
   public void testReturnsNoAnimationIfFromMemoryCache() {
-    assertEquals(NoTransition.get(),
-        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
+    assertEquals(
+        NoTransition.get(), factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsNoAnimationIfNotFirstResource() {
-    assertEquals(NoTransition.get(),
-        factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
+    assertEquals(
+        NoTransition.get(), factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
 
   @Test
   public void testReturnsAnimationIfNotFromMemoryCacheAndFirstResource() {
-    assertNotEquals(NoTransition.get(),
-        factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
+    assertNotEquals(
+        NoTransition.get(), factory.build(DataSource.DATA_DISK_CACHE, true /*isFirstResource*/));
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
index 6f1cb4ec5..6e70c25f2 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -33,8 +33,7 @@ public void setUp() {
 
   @Test
   public void testFactoryReturnsNoAnimationIfFromMemoryCache() {
-    Transition<Object> animation =
-        factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
+    Transition<Object> animation = factory.build(DataSource.MEMORY_CACHE, true /*isFirstResource*/);
     assertEquals(NoTransition.get(), animation);
     verify(viewTransitionAnimationFactory, never()).build(RuntimeEnvironment.application);
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 1efd9b736..13d25d06e 100644
--- a/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -29,8 +29,8 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
-          expectedOrientation);
+      assertEquals(
+          new DefaultImageHeaderParser().getOrientation(is, byteArrayPool), expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
     } finally {
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
index a10b26cd7..6cf1d5ebf 100644
--- a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.signature;
 
-
 import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.load.Key;
@@ -17,9 +16,7 @@
   @Test
   public void testEquals() {
     keyTester
-        .addEquivalenceGroup(
-            EmptySignature.obtain(),
-            EmptySignature.obtain())
+        .addEquivalenceGroup(EmptySignature.obtain(), EmptySignature.obtain())
         .addEquivalenceGroup(mock(Key.class))
         .addEmptyDigestRegressionTest(EmptySignature.obtain())
         .test();
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
index e972c3e2e..e2eb536d2 100644
--- a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -14,8 +14,7 @@
   public void equalsHashCodeAndDigest() {
     keyTester
         .addEquivalenceGroup(
-            new MediaStoreSignature("first", 100, 1),
-            new MediaStoreSignature("first", 100, 1))
+            new MediaStoreSignature("first", 100, 1), new MediaStoreSignature("first", 100, 1))
         .addEquivalenceGroup(new MediaStoreSignature("second", 100, 1))
         .addEquivalenceGroup(new MediaStoreSignature("first", 200, 1))
         .addEquivalenceGroup(new MediaStoreSignature("first", 100, 2))
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index ddd9d06b8..42ba640d0 100644
--- a/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -8,7 +8,7 @@
 /**
  * Exists only to "enable" logging for test coverage.
  *
- * TODO: when we can ignore Log.* via configuration, remove this class.
+ * <p>TODO: when we can ignore Log.* via configuration, remove this class.
  */
 @Implements(Log.class)
 public class GlideShadowLog extends ShadowLog {
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
index 8a064db54..e5ea5413e 100644
--- a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
@@ -35,11 +35,11 @@ public Statement apply(final Statement base, Description description) {
 
       @Override
       public void evaluate() throws Throwable {
-          isUsedAsRule = true;
-          base.evaluate();
-          if (isUsedWithoutCallingTest) {
-            fail("You used KeyTester but failed to call test()!");
-          }
+        isUsedAsRule = true;
+        base.evaluate();
+        if (isUsedWithoutCallingTest) {
+          fail("You used KeyTester but failed to call test()!");
+        }
       }
     };
   }
@@ -62,8 +62,9 @@ public KeyTester addEquivalenceGroup(Key first, Key... rest) {
   public KeyTester addRegressionTest(Key key, String expectedDigest) {
     assertUsedAsRule();
     if (EMPTY_DIGEST_STRING.equals(expectedDigest)) {
-      throw new IllegalArgumentException("Expected digest is empty, if this is intended use "
-          + "addEmptyDigestRegressionTest instead");
+      throw new IllegalArgumentException(
+          "Expected digest is empty, if this is intended use "
+              + "addEmptyDigestRegressionTest instead");
     }
     return addRegressionTestInternal(key, expectedDigest);
   }
@@ -95,7 +96,8 @@ public void test() {
       assert_()
           .withMessage(
               "Unexpected digest for regression test [" + i + "]: with key: " + entry.getKey())
-          .that(sha256.getStringDigest(entry.getKey())).isEqualTo(entry.getValue());
+          .that(sha256.getStringDigest(entry.getKey()))
+          .isEqualTo(entry.getValue());
       i++;
     }
   }
@@ -121,15 +123,12 @@ public void test() {
       }
     }
 
-
     String getStringDigest(Key key) {
       return com.bumptech.glide.util.Util.sha256BytesToHex(getDigest(key));
     }
   }
 
-  /**
-   * Tests equals, hashcode and digest methods of {@link Key}s.
-   */
+  /** Tests equals, hashcode and digest methods of {@link Key}s. */
   private static final class KeyEquivalence extends Equivalence<Key> {
 
     private final Sha256 sha256;
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
index d1814f48f..97af3525b 100644
--- a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -5,9 +5,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
-/**
- * Clears out Glide's disk cache and the Glide singleton after every test method.
- */
+/** Clears out Glide's disk cache and the Glide singleton after every test method. */
 public final class TearDownGlide implements TestRule {
   @Override
   public Statement apply(final Statement base, Description description) {
@@ -18,7 +16,6 @@ public void evaluate() throws Throwable {
           base.evaluate();
         } finally {
           Glide.tearDown();
-
         }
       }
     };
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/Util.java b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
index bcd5d34f4..ba0cf2da8 100644
--- a/library/test/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
@@ -28,9 +28,9 @@
 public class Util {
 
   /**
-   * Gives the proper generic type to the {@link ArgumentCaptor}.
-   * Only useful when the captor's {@code T} is also a generic type.
-   * Without this it's really ugly to have a properly typed captor object.
+   * Gives the proper generic type to the {@link ArgumentCaptor}. Only useful when the captor's
+   * {@code T} is also a generic type. Without this it's really ugly to have a properly typed captor
+   * object.
    */
   @SuppressWarnings("unchecked")
   public static <T> ArgumentCaptor<T> cast(ArgumentCaptor<?> captor) {
@@ -46,8 +46,8 @@ public static Context anyContext() {
   }
 
   /**
-   * Creates a Mockito argument matcher to be used in verify.
-   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   * Creates a Mockito argument matcher to be used in verify. It returns a generic typed {@link
+   * Resource} to prevent unchecked warnings.
    */
   @SuppressWarnings("unchecked")
   public static <T> Resource<T> anyResource() {
@@ -55,8 +55,8 @@ public static Context anyContext() {
   }
 
   /**
-   * Creates a Mockito mock object.
-   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   * Creates a Mockito mock object. It returns a generic typed {@link Resource} to prevent unchecked
+   * warnings.
    */
   @SuppressWarnings("unchecked")
   public static <T> Resource<T> mockResource() {
diff --git a/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
index 007e5a26b..82edfd619 100644
--- a/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -36,9 +36,7 @@ public void testFromStream_massive() throws IOException {
     testFromStream(12 * BUFFER_SIZE + 12345);
   }
 
-  /**
-   * All tests are basically the same thing but with different amounts of data.
-   */
+  /** All tests are basically the same thing but with different amounts of data. */
   private void testFromStream(int dataLength) throws IOException {
     byte[] bytes = createByteData(dataLength);
     InputStream byteStream = new ByteArrayInputStream(bytes);
diff --git a/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index a9a912613..4fbc8d0e1 100644
--- a/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -37,8 +37,7 @@ public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLengt
   }
 
   @Test
-  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
-      throws IOException {
+  public void testAvailable_withNullContentLength_returnsWrappedAvailable() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
     int expected = 1234;
     when(wrapped.available()).thenReturn(expected);
diff --git a/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 5684e3c13..b8ef132d3 100644
--- a/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -54,8 +54,8 @@ public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOE
 
   @Test
   public void
-  testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
 
@@ -66,8 +66,8 @@ public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOE
 
   @Test
   public void
-  testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
     is.mark(MARK_LIMIT);
@@ -118,8 +118,8 @@ public void testResetUnsetsLimit() throws IOException {
 
   @Test
   public void
-  testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
-      throws IOException {
+      testOverridesByteCount_whenSkipCountLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit()
+          throws IOException {
     MarkEnforcingInputStream is =
         new MarkEnforcingInputStream(new ByteArrayInputStream(new byte[DATA_SIZE]));
     is.mark(MARK_LIMIT);
diff --git a/library/test/src/test/java/opengles/GL.java b/library/test/src/test/java/opengles/GL.java
index 40792a85f..d5b6040c8 100644
--- a/library/test/src/test/java/opengles/GL.java
+++ b/library/test/src/test/java/opengles/GL.java
@@ -1,9 +1,7 @@
 package javax.microedition.khronos.opengles;
 
 /**
- * TODO: Figure out why this is necessary and remove it.
- * See: https://github.com/robolectric/robolectric-gradle-plugin/issues/145
+ * TODO: Figure out why this is necessary and remove it. See:
+ * https://github.com/robolectric/robolectric-gradle-plugin/issues/145
  */
-public interface GL {
-}
-
+public interface GL {}
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
index 14dec10a2..c30d489c1 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Ensures that Glide's generated API is created for the Contact Uri sample.
- */
+/** Ensures that Glide's generated API is created for the Contact Uri sample. */
 @GlideModule
 public class ContactUriModule extends AppGlideModule {
   // Intentionally empty.
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index c072483df..020fc41b9 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -20,11 +20,11 @@
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * An activity that demonstrates loading photos using
- * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
- * It works by making the user to choose a contact when presses a button,
- * and after he chooses a contact with photo,
- * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ * An activity that demonstrates loading photos using {@link
+ * com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide. It works by
+ * making the user to choose a contact when presses a button, and after he chooses a contact with
+ * photo, We try to load both a high res image and thumbnail image of that contact with various
+ * Uris.
  */
 public class MainActivity extends Activity {
   private static final int REQUEST_CONTACT = 1;
@@ -47,34 +47,38 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewDisplayPhoto = findViewById(R.id.image_display_photo);
     numberEntry = findViewById(R.id.number_entry);
     // Make sure that user gives application required permissions
-    if (ContextCompat.checkSelfPermission(
-        getApplication(),
-        Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+    if (ContextCompat.checkSelfPermission(getApplication(), Manifest.permission.READ_CONTACTS)
+        != PackageManager.PERMISSION_GRANTED) {
       // No explanation needed, we can request the permission.
-      ActivityCompat.requestPermissions(this,
-      new String[]{Manifest.permission.READ_CONTACTS},
-      READ_CONTACTS);
+      ActivityCompat.requestPermissions(
+          this, new String[] {Manifest.permission.READ_CONTACTS}, READ_CONTACTS);
     }
 
-    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View v) {
-        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
-        startActivityForResult(intent, REQUEST_CONTACT);
-      }
-    });
+    findViewById(R.id.button_pick_contact)
+        .setOnClickListener(
+            new View.OnClickListener() {
+              @Override
+              public void onClick(View v) {
+                Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+                startActivityForResult(intent, REQUEST_CONTACT);
+              }
+            });
 
-    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View v) {
-        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
-                                       Uri.encode(numberEntry.getText().toString()));
-        GlideApp.with(MainActivity.this)
-                .load(uri)
-                .override(Target.SIZE_ORIGINAL)
-                .into(imageViewLookup);
-        }
-    });
+    findViewById(R.id.button_find)
+        .setOnClickListener(
+            new View.OnClickListener() {
+              @Override
+              public void onClick(View v) {
+                Uri uri =
+                    Uri.withAppendedPath(
+                        ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
+                        Uri.encode(numberEntry.getText().toString()));
+                GlideApp.with(MainActivity.this)
+                    .load(uri)
+                    .override(Target.SIZE_ORIGINAL)
+                    .into(imageViewLookup);
+              }
+            });
   }
 
   @Override
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
index 57c9ee173..2251bd8c2 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -6,9 +6,7 @@
 import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.samples.flickr.api.Api;
 
-/**
- * Extension methods for the Flickr sample's generated API.
- */
+/** Extension methods for the Flickr sample's generated API. */
 // Required by Glide's annotation processor.
 @SuppressWarnings({"WeakerAccess", "unused"})
 @GlideExtension
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index c0a1bce18..87b5c7e61 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -12,9 +12,7 @@
 import com.bumptech.glide.samples.flickr.api.Photo;
 import java.io.InputStream;
 
-/**
- * Register {@link FlickrModelLoader} for the Flickr sample app.
- */
+/** Register {@link FlickrModelLoader} for the Flickr sample app. */
 @GlideModule
 public class FlickrGlideModule extends AppGlideModule {
 
@@ -25,8 +23,8 @@ public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder
   }
 
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index a2b3d2f6e..f8395db24 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -20,9 +20,7 @@
  */
 public final class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
-   */
+  /** The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s. */
   public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
     private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<>(500);
 
@@ -34,8 +32,7 @@
     }
 
     @Override
-    public void teardown() {
-    }
+    public void teardown() {}
   }
 
   private FlickrModelLoader(
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 65bc1ceab..476b90a39 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -63,17 +63,12 @@ public View onCreateView(
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = GlideApp.with(this)
-        .asDrawable()
-        .centerCrop();
+    fullRequest = GlideApp.with(this).asDrawable().centerCrop();
 
-    thumbnailRequest = GlideApp.with(this)
-        .asDrawable()
-        .centerCrop()
-        .override(Api.SQUARE_THUMB_SIZE);
+    thumbnailRequest =
+        GlideApp.with(this).asDrawable().centerCrop().override(Api.SQUARE_THUMB_SIZE);
 
-    preloadRequest =
-        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
+    preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
@@ -83,20 +78,22 @@ public View onCreateView(
     layoutManager = new GridLayoutManager(getActivity(), spanCount);
     grid.setLayoutManager(layoutManager);
 
-    grid.addItemDecoration(new RecyclerView.ItemDecoration() {
-      @Override
-      public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
-          RecyclerView.State state) {
-        outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
-      }
-    });
-    grid.setRecyclerListener(new RecyclerView.RecyclerListener() {
-      @Override
-      public void onViewRecycled(RecyclerView.ViewHolder holder) {
-        PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
-        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
-      }
-    });
+    grid.addItemDecoration(
+        new RecyclerView.ItemDecoration() {
+          @Override
+          public void getItemOffsets(
+              Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
+            outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);
+          }
+        });
+    grid.setRecyclerListener(
+        new RecyclerView.RecyclerListener() {
+          @Override
+          public void onViewRecycled(RecyclerView.ViewHolder holder) {
+            PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
+            GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+          }
+        });
 
     int heightCount = getResources().getDisplayMetrics().heightPixels / photoSize;
     grid.getRecycledViewPool().setMaxRecycledViews(0, spanCount * heightCount * 2);
@@ -106,8 +103,9 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
 
     FixedPreloadSizeProvider<Photo> preloadSizeProvider =
         new FixedPreloadSizeProvider<>(photoSize, photoSize);
-    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
-        preloadSizeProvider, args.getInt(PRELOAD_KEY));
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            Glide.with(this), adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
     grid.addOnScrollListener(preloader);
 
     if (currentPhotos != null) {
@@ -139,8 +137,8 @@ public void onPhotosUpdated(List<Photo> photos) {
     }
   }
 
-  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder> implements
-      ListPreloader.PreloadModelProvider<Photo> {
+  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder>
+      implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
@@ -171,17 +169,19 @@ public PhotoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     public void onBindViewHolder(PhotoViewHolder holder, int position) {
       final Photo current = photos.get(position);
 
-      fullRequest.load(current)
+      fullRequest
+          .load(current)
           .thumbnail(thumbnail ? thumbnailRequest.load(current) : null)
           .into(holder.imageView);
 
-      holder.imageView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-          startActivity(intent);
-        }
-      });
+      holder.imageView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+              startActivity(intent);
+            }
+          });
     }
 
     @Override
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index a9423c091..5d100e104 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -77,24 +77,24 @@ public View onCreateView(
     }
 
     final GlideRequests glideRequests = GlideApp.with(this);
-    fullRequest = glideRequests
-        .asDrawable()
-        .centerCrop()
-        .placeholder(new ColorDrawable(Color.GRAY));
-
-    thumbRequest = glideRequests
-        .asDrawable()
-        .diskCacheStrategy(DiskCacheStrategy.DATA)
-        .override(Api.SQUARE_THUMB_SIZE)
-        .transition(withCrossFade());
-
-    list.setRecyclerListener(new RecyclerView.RecyclerListener() {
-      @Override
-      public void onViewRecycled(RecyclerView.ViewHolder holder) {
-        PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
-        glideRequests.clear(vh.imageView);
-      }
-    });
+    fullRequest =
+        glideRequests.asDrawable().centerCrop().placeholder(new ColorDrawable(Color.GRAY));
+
+    thumbRequest =
+        glideRequests
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .override(Api.SQUARE_THUMB_SIZE)
+            .transition(withCrossFade());
+
+    list.setRecyclerListener(
+        new RecyclerView.RecyclerListener() {
+          @Override
+          public void onViewRecycled(RecyclerView.ViewHolder holder) {
+            PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
+            glideRequests.clear(vh.imageView);
+          }
+        });
 
     if (savedInstanceState != null) {
       int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
@@ -142,17 +142,16 @@ public PhotoTitleViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     @Override
     public void onBindViewHolder(PhotoTitleViewHolder holder, int position) {
       final Photo current = photos.get(position);
-      fullRequest.load(current)
-          .thumbnail(thumbRequest.load(current))
-          .into(holder.imageView);
-
-      holder.imageView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          Intent intent = FullscreenActivity.getIntent(getActivity(), current);
-          startActivity(intent);
-        }
-      });
+      fullRequest.load(current).thumbnail(thumbRequest.load(current)).into(holder.imageView);
+
+      holder.imageView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              Intent intent = FullscreenActivity.getIntent(getActivity(), current);
+              startActivity(intent);
+            }
+          });
 
       holder.titleView.setText(current.getTitle());
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index d1b57740e..1ba7cac7f 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -66,6 +66,7 @@
   }
 
   private static final Map<Page, Integer> PAGE_TO_TITLE;
+
   static {
     Map<Page, Integer> temp = new HashMap<>();
     temp.put(Page.SMALL, R.string.small);
@@ -111,16 +112,12 @@ public boolean onQueryTextChange(String newText) {
     return false;
   }
 
-  /**
-   * Called when the activity is first created.
-   */
+  /** Called when the activity is first created. */
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-        .detectAll()
-        .penaltyLog()
-        .build());
+    StrictMode.setThreadPolicy(
+        new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
 
     backgroundThread = new HandlerThread("BackgroundThumbnailHandlerThread");
     backgroundThread.start();
@@ -154,10 +151,11 @@ public void onCreate(Bundle savedInstanceState) {
     if (savedInstanceState == null) {
       // Weight values determined experimentally by measuring the number of incurred GCs while
       // scrolling through the various photo grids/lists.
-      GlideApp.get(this).preFillBitmapPool(
-          new PreFillType.Builder(smallGridSize).setWeight(1),
-          new PreFillType.Builder(mediumGridSize).setWeight(1),
-          new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
+      GlideApp.get(this)
+          .preFillBitmapPool(
+              new PreFillType.Builder(smallGridSize).setWeight(1),
+              new PreFillType.Builder(mediumGridSize).setWeight(1),
+              new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
   }
 
@@ -335,10 +333,11 @@ public void run() {
           return;
         }
 
-        FutureTarget<File> futureTarget = GlideApp.with(context)
-            .downloadOnly()
-            .load(photo)
-            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+        FutureTarget<File> futureTarget =
+            GlideApp.with(context)
+                .downloadOnly()
+                .load(photo)
+                .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index ba3095dc2..355f2b02e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -9,9 +9,7 @@
 import android.widget.ImageView;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
-/**
- * A simple activity for viewing a single photo.
- */
+/** A simple activity for viewing a single photo. */
 public class FullscreenActivity extends FragmentActivity {
   private static final String ARG_PHOTO = "photo";
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index e6cce5ec7..fca5adc02 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -5,9 +5,7 @@
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
-/**
- * An always square {@link ImageView}.
- */
+/** An always square {@link ImageView}. */
 public final class SquareImageView extends AppCompatImageView {
 
   public SquareImageView(Context context) {
@@ -29,4 +27,3 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
   }
 }
-
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index 6fa99de2c..346b1b0b1 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -14,9 +14,7 @@
 import java.util.List;
 import java.util.Set;
 
-/**
- * A class for interfacing with Flickr's http API.
- */
+/** A class for interfacing with Flickr's http API. */
 public final class Api {
   private static Api api;
   private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
@@ -30,20 +28,19 @@
   private static final int MAX_ITEMS_PER_PAGE = 300;
   private static final String PER_PAGE = "&per_page=" + MAX_ITEMS_PER_PAGE;
 
-  private static final SparseArray<String> EDGE_TO_SIZE_KEY = new SparseArray<String>() {
-    {
-      put(75, "s");
-      put(100, "t");
-      put(150, "q");
-      put(240, "m");
-      put(320, "n");
-      put(640, "z");
-      put(1024, "b");
-    }
-  };
-  private static final List<Integer> SORTED_SIZE_KEYS =
-      new ArrayList<>(EDGE_TO_SIZE_KEY.size());
-
+  private static final SparseArray<String> EDGE_TO_SIZE_KEY =
+      new SparseArray<String>() {
+        {
+          put(75, "s");
+          put(100, "t");
+          put(150, "q");
+          put(240, "m");
+          put(320, "n");
+          put(640, "z");
+          put(1024, "b");
+        }
+      };
+  private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<>(EDGE_TO_SIZE_KEY.size());
 
   static {
     for (int i = 0; i < EDGE_TO_SIZE_KEY.size(); i++) {
@@ -84,12 +81,11 @@ private static String getSizeKey(int width, int height) {
       }
     }
     return result;
-
   }
 
   static String getCacheableUrl(Photo photo) {
-    return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
-        photo.getSecret());
+    return String.format(
+        CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(), photo.getSecret());
   }
 
   public static String getPhotoURL(Photo photo, int width, int height) {
@@ -126,14 +122,12 @@ static String getRecentUrl() {
     return getUrlForMethod("flickr.photos.getRecent" + PER_PAGE);
   }
 
-  /**
-   * An interface for listening for search results from the Flickr API.
-   */
+  /** An interface for listening for search results from the Flickr API. */
   public interface QueryListener {
     /**
      * Called when a search completes successfully.
      *
-     * @param query  The query used to obtain the results.
+     * @param query The query used to obtain the results.
      * @param photos A list of images that were found for the given search term.
      */
     void onSearchCompleted(Query query, List<Photo> photos);
@@ -142,7 +136,7 @@ static String getRecentUrl() {
      * Called when a search fails.
      *
      * @param query The query we attempted to obtain results for.
-     * @param e     The exception that caused the search to fail.
+     * @param e The exception that caused the search to fail.
      */
     void onSearchFailed(Query query, Exception e);
   }
@@ -160,17 +154,18 @@ public static Api get(Context context) {
 
   private Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
-    QueryListener queryListener = new QueryListener() {
-      @Override
-      public void onSearchCompleted(Query query, List<Photo> photos) {
-        lastQueryResult = new QueryResult(query, photos);
-      }
-
-      @Override
-      public void onSearchFailed(Query query, Exception e) {
-        lastQueryResult = null;
-      }
-    };
+    QueryListener queryListener =
+        new QueryListener() {
+          @Override
+          public void onSearchCompleted(Query query, List<Photo> photos) {
+            lastQueryResult = new QueryResult(query, photos);
+          }
+
+          @Override
+          public void onSearchFailed(Query query, Exception e) {
+            lastQueryResult = null;
+          }
+        };
     queryListeners.add(queryListener);
   }
 
@@ -190,12 +185,13 @@ public void query(Query query) {
       return;
     }
 
-    FlickrQueryResponseListener responseListener
-        = new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
-    StringRequest request = new StringRequest(Request.Method.GET, query.getUrl(),
-        responseListener, responseListener);
-    request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
-        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    FlickrQueryResponseListener responseListener =
+        new FlickrQueryResponseListener(new PhotoJsonStringParser(), query, queryListeners);
+    StringRequest request =
+        new StringRequest(Request.Method.GET, query.getUrl(), responseListener, responseListener);
+    request.setRetryPolicy(
+        new DefaultRetryPolicy(
+            DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3, DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
     requestQueue.add(request);
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
index 5bd75a67c..214cbefa6 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -6,17 +6,15 @@
 import java.util.List;
 import org.json.JSONException;
 
-/**
- * Handles photo list responses and errors from Flickr API calls.
- */
-final class FlickrQueryResponseListener implements Response.Listener<String>,
-    Response.ErrorListener {
+/** Handles photo list responses and errors from Flickr API calls. */
+final class FlickrQueryResponseListener
+    implements Response.Listener<String>, Response.ErrorListener {
   private final PhotoJsonStringParser parser;
   private final Query query;
   private final Collection<Api.QueryListener> listeners;
 
-  FlickrQueryResponseListener(PhotoJsonStringParser parser, Query query,
-      Collection<Api.QueryListener> listeners) {
+  FlickrQueryResponseListener(
+      PhotoJsonStringParser parser, Query query, Collection<Api.QueryListener> listeners) {
     this.parser = parser;
     this.query = query;
     this.listeners = listeners;
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 8ff5f5b9a..99407d0a0 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -5,21 +5,20 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-/**
- * A POJO representing a JSON object returned from Flickr's api representing a single image.
- */
+/** A POJO representing a JSON object returned from Flickr's api representing a single image. */
 public class Photo implements Parcelable {
-  public static final Creator<Photo> CREATOR = new Creator<Photo>() {
-    @Override
-    public Photo createFromParcel(Parcel parcel) {
-      return new Photo(parcel);
-    }
-
-    @Override
-    public Photo[] newArray(int i) {
-      return new Photo[i];
-    }
-  };
+  public static final Creator<Photo> CREATOR =
+      new Creator<Photo>() {
+        @Override
+        public Photo createFromParcel(Parcel parcel) {
+          return new Photo(parcel);
+        }
+
+        @Override
+        public Photo[] newArray(int i) {
+          return new Photo[i];
+        }
+      };
 
   private final String id;
   private final String owner;
@@ -29,7 +28,6 @@ public Photo createFromParcel(Parcel parcel) {
   private final String secret;
   private String partialUrl = null;
 
-
   public Photo(JSONObject jsonPhoto) throws JSONException {
     this.id = jsonPhoto.getString("id");
     this.owner = jsonPhoto.getString("owner");
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
index 2858df855..d141d72f8 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -4,17 +4,18 @@
 
 /** Query using Flickr's recent API. */
 public final class RecentQuery implements Query {
-  public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
-    @Override
-    public RecentQuery createFromParcel(Parcel source) {
-      return RECENT_QUERY;
-    }
-
-    @Override
-    public RecentQuery[] newArray(int size) {
-      return new RecentQuery[size];
-    }
-  };
+  public static final Creator<RecentQuery> CREATOR =
+      new Creator<RecentQuery>() {
+        @Override
+        public RecentQuery createFromParcel(Parcel source) {
+          return RECENT_QUERY;
+        }
+
+        @Override
+        public RecentQuery[] newArray(int size) {
+          return new RecentQuery[size];
+        }
+      };
   private static final RecentQuery RECENT_QUERY = new RecentQuery();
 
   public static RecentQuery get() {
@@ -41,5 +42,5 @@ public int describeContents() {
   }
 
   @Override
-  public void writeToParcel(Parcel dest, int flags) { }
+  public void writeToParcel(Parcel dest, int flags) {}
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
index 0d36aaf24..16efaa654 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/SearchQuery.java
@@ -4,17 +4,18 @@
 
 /** Wraps a search query string. */
 public final class SearchQuery implements Query {
-  public static final Creator<SearchQuery> CREATOR = new Creator<SearchQuery>() {
-    @Override
-    public SearchQuery createFromParcel(Parcel source) {
-      return new SearchQuery(source);
-    }
-
-    @Override
-    public SearchQuery[] newArray(int size) {
-      return new SearchQuery[size];
-    }
-  };
+  public static final Creator<SearchQuery> CREATOR =
+      new Creator<SearchQuery>() {
+        @Override
+        public SearchQuery createFromParcel(Parcel source) {
+          return new SearchQuery(source);
+        }
+
+        @Override
+        public SearchQuery[] newArray(int size) {
+          return new SearchQuery[size];
+        }
+      };
 
   private final String queryString;
 
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
index e5d4888ab..e3a5743b9 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Ensures that Glide's generated API is created for the Gallery sample.
- */
+/** Ensures that Glide's generated API is created for the Gallery sample. */
 @GlideModule
 public final class GalleryModule extends AppGlideModule {
   // Intentionally empty.
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 46ac3d232..ebffc8424 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -13,9 +13,7 @@
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import java.util.List;
 
-/**
- * Displays media store data in a recycler view.
- */
+/** Displays media store data in a recycler view. */
 public class HorizontalGalleryFragment extends Fragment
     implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {
 
@@ -46,11 +44,10 @@ public View onCreateView(
   }
 
   @Override
-  public void onLoadFinished(Loader<List<MediaStoreData>> loader,
-      List<MediaStoreData> mediaStoreData) {
+  public void onLoadFinished(
+      Loader<List<MediaStoreData>> loader, List<MediaStoreData> mediaStoreData) {
     GlideRequests glideRequests = GlideApp.with(this);
-    RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
+    RecyclerAdapter adapter = new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
     RecyclerViewPreloader<MediaStoreData> preloader =
         new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
     recyclerView.addOnScrollListener(preloader);
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index 1206230ff..d6f897337 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -13,9 +13,7 @@
 import android.widget.Toast;
 import com.bumptech.glide.MemoryCategory;
 
-/**
- * Displays a {@link HorizontalGalleryFragment}.
- */
+/** Displays a {@link HorizontalGalleryFragment}. */
 @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MainActivity extends FragmentActivity {
 
@@ -28,7 +26,7 @@ protected void onCreate(Bundle savedInstanceState) {
     GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
         && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
-        != PackageManager.PERMISSION_GRANTED) {
+            != PackageManager.PERMISSION_GRANTED) {
       requestStoragePermission();
     } else {
       replaceFragment();
@@ -36,9 +34,8 @@ protected void onCreate(Bundle savedInstanceState) {
   }
 
   private void requestStoragePermission() {
-     ActivityCompat.requestPermissions(this,
-        new String[]{permission.READ_EXTERNAL_STORAGE},
-        REQUEST_READ_STORAGE);
+    ActivityCompat.requestPermissions(
+        this, new String[] {permission.READ_EXTERNAL_STORAGE}, REQUEST_READ_STORAGE);
   }
 
   private void replaceFragment() {
@@ -50,21 +47,20 @@ private void replaceFragment() {
   }
 
   @Override
-  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
-      @NonNull int[] grantResults) {
+  public void onRequestPermissionsResult(
+      int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
     super.onRequestPermissionsResult(requestCode, permissions, grantResults);
     switch (requestCode) {
-      case REQUEST_READ_STORAGE: {
-        // If request is cancelled, the result arrays are empty.
-        if (grantResults.length > 0
-            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-          replaceFragment();
-        } else {
-          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
-              .show();
-          requestStoragePermission();
+      case REQUEST_READ_STORAGE:
+        {
+          // If request is cancelled, the result arrays are empty.
+          if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            replaceFragment();
+          } else {
+            Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
+            requestStoragePermission();
+          }
         }
-      }
     }
   }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
index c0c924e15..90d19706d 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -4,21 +4,20 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 
-/**
- * A data model containing data for a single media item.
- */
+/** A data model containing data for a single media item. */
 public class MediaStoreData implements Parcelable {
-  public static final Creator<MediaStoreData> CREATOR = new Creator<MediaStoreData>() {
-    @Override
-    public MediaStoreData createFromParcel(Parcel parcel) {
-      return new MediaStoreData(parcel);
-    }
+  public static final Creator<MediaStoreData> CREATOR =
+      new Creator<MediaStoreData>() {
+        @Override
+        public MediaStoreData createFromParcel(Parcel parcel) {
+          return new MediaStoreData(parcel);
+        }
 
-    @Override
-    public MediaStoreData[] newArray(int i) {
-      return new MediaStoreData[i];
-    }
-  };
+        @Override
+        public MediaStoreData[] newArray(int i) {
+          return new MediaStoreData[i];
+        }
+      };
 
   @Override
   public int describeContents() {
@@ -33,8 +32,14 @@ public int describeContents() {
   private final Type type;
   final long dateTaken;
 
-  MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
-      int orientation, Type type) {
+  MediaStoreData(
+      long rowId,
+      Uri uri,
+      String mimeType,
+      long dateTaken,
+      long dateModified,
+      int orientation,
+      Type type) {
     this.rowId = rowId;
     this.uri = uri;
     this.dateModified = dateModified;
@@ -68,19 +73,25 @@ public void writeToParcel(Parcel parcel, int i) {
   @Override
   public String toString() {
     return "MediaStoreData{"
-        + "rowId=" + rowId
-        + ", uri=" + uri
-        + ", mimeType='" + mimeType + '\''
-        + ", dateModified=" + dateModified
-        + ", orientation=" + orientation
-        + ", type=" + type
-        + ", dateTaken=" + dateTaken
+        + "rowId="
+        + rowId
+        + ", uri="
+        + uri
+        + ", mimeType='"
+        + mimeType
+        + '\''
+        + ", dateModified="
+        + dateModified
+        + ", orientation="
+        + orientation
+        + ", type="
+        + type
+        + ", dateTaken="
+        + dateTaken
         + '}';
   }
 
-  /**
-   * The type of data.
-   */
+  /** The type of data. */
   public enum Type {
     VIDEO,
     IMAGE,
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index 372e9dbe8..632efdd3d 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -11,26 +11,24 @@
 import java.util.Comparator;
 import java.util.List;
 
-/**
- * Loads metadata from the media store for images and videos.
- */
+/** Loads metadata from the media store for images and videos. */
 public class MediaStoreDataLoader extends AsyncTaskLoader<List<MediaStoreData>> {
   private static final String[] IMAGE_PROJECTION =
       new String[] {
-          MediaStore.Images.ImageColumns._ID,
-          MediaStore.Images.ImageColumns.DATE_TAKEN,
-          MediaStore.Images.ImageColumns.DATE_MODIFIED,
-          MediaStore.Images.ImageColumns.MIME_TYPE,
-          MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStore.Images.ImageColumns._ID,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns.DATE_MODIFIED,
+        MediaStore.Images.ImageColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
       };
 
   private static final String[] VIDEO_PROJECTION =
       new String[] {
-          MediaStore.Video.VideoColumns._ID,
-          MediaStore.Video.VideoColumns.DATE_TAKEN,
-          MediaStore.Video.VideoColumns.DATE_MODIFIED,
-          MediaStore.Video.VideoColumns.MIME_TYPE,
-          "0 AS " + MediaStore.Images.ImageColumns.ORIENTATION,
+        MediaStore.Video.VideoColumns._ID,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns.DATE_MODIFIED,
+        MediaStore.Video.VideoColumns.MIME_TYPE,
+        "0 AS " + MediaStore.Images.ImageColumns.ORIENTATION,
       };
 
   private List<MediaStoreData> cached;
@@ -83,37 +81,58 @@ protected void onAbandon() {
   public List<MediaStoreData> loadInBackground() {
     List<MediaStoreData> data = queryImages();
     data.addAll(queryVideos());
-    Collections.sort(data, new Comparator<MediaStoreData>() {
-      @Override
-      public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2) {
-        return Long.valueOf(mediaStoreData2.dateTaken).compareTo(mediaStoreData.dateTaken);
-      }
-    });
+    Collections.sort(
+        data,
+        new Comparator<MediaStoreData>() {
+          @Override
+          public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2) {
+            return Long.valueOf(mediaStoreData2.dateTaken).compareTo(mediaStoreData.dateTaken);
+          }
+        });
     return data;
   }
 
   private List<MediaStoreData> queryImages() {
-    return query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, IMAGE_PROJECTION,
-        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns._ID,
-        MediaStore.Images.ImageColumns.DATE_TAKEN, MediaStore.Images.ImageColumns.DATE_MODIFIED,
-        MediaStore.Images.ImageColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+    return query(
+        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+        IMAGE_PROJECTION,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns._ID,
+        MediaStore.Images.ImageColumns.DATE_TAKEN,
+        MediaStore.Images.ImageColumns.DATE_MODIFIED,
+        MediaStore.Images.ImageColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
         MediaStoreData.Type.IMAGE);
   }
 
   private List<MediaStoreData> queryVideos() {
-    return query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, VIDEO_PROJECTION,
-        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns._ID,
-        MediaStore.Video.VideoColumns.DATE_TAKEN, MediaStore.Video.VideoColumns.DATE_MODIFIED,
-        MediaStore.Video.VideoColumns.MIME_TYPE, MediaStore.Images.ImageColumns.ORIENTATION,
+    return query(
+        MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
+        VIDEO_PROJECTION,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns._ID,
+        MediaStore.Video.VideoColumns.DATE_TAKEN,
+        MediaStore.Video.VideoColumns.DATE_MODIFIED,
+        MediaStore.Video.VideoColumns.MIME_TYPE,
+        MediaStore.Images.ImageColumns.ORIENTATION,
         MediaStoreData.Type.VIDEO);
   }
 
-  private List<MediaStoreData> query(Uri contentUri, String[] projection, String sortByCol,
-      String idCol, String dateTakenCol, String dateModifiedCol, String mimeTypeCol,
-      String orientationCol, MediaStoreData.Type type) {
+  private List<MediaStoreData> query(
+      Uri contentUri,
+      String[] projection,
+      String sortByCol,
+      String idCol,
+      String dateTakenCol,
+      String dateModifiedCol,
+      String mimeTypeCol,
+      String orientationCol,
+      MediaStoreData.Type type) {
     final List<MediaStoreData> data = new ArrayList<MediaStoreData>();
-    Cursor cursor = getContext().getContentResolver()
-        .query(contentUri, projection, null, null, sortByCol + " DESC");
+    Cursor cursor =
+        getContext()
+            .getContentResolver()
+            .query(contentUri, projection, null, null, sortByCol + " DESC");
 
     if (cursor == null) {
       return data;
@@ -133,8 +152,15 @@ public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2
         long dateModified = cursor.getLong(dateModifiedColNum);
         int orientation = cursor.getInt(orientationColNum);
 
-        data.add(new MediaStoreData(id, Uri.withAppendedPath(contentUri, Long.toString(id)),
-            mimeType, dateTaken, dateModified, orientation, type));
+        data.add(
+            new MediaStoreData(
+                id,
+                Uri.withAppendedPath(contentUri, Long.toString(id)),
+                mimeType,
+                dateTaken,
+                dateModified,
+                orientation,
+                type));
       }
     } finally {
       cursor.close();
@@ -146,10 +172,10 @@ public int compare(MediaStoreData mediaStoreData, MediaStoreData mediaStoreData2
   private void registerContentObserver() {
     if (!observerRegistered) {
       ContentResolver cr = getContext().getContentResolver();
-      cr.registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false,
-          forceLoadContentObserver);
-      cr.registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, false,
-          forceLoadContentObserver);
+      cr.registerContentObserver(
+          MediaStore.Images.Media.EXTERNAL_CONTENT_URI, false, forceLoadContentObserver);
+      cr.registerContentObserver(
+          MediaStore.Video.Media.EXTERNAL_CONTENT_URI, false, forceLoadContentObserver);
 
       observerRegistered = true;
     }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 53698d6dd..00616aa1b 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -21,12 +21,10 @@
 import java.util.Collections;
 import java.util.List;
 
-/**
- * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
- */
+/** Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view. */
 class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ListViewHolder>
     implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
-    ListPreloader.PreloadModelProvider<MediaStoreData> {
+        ListPreloader.PreloadModelProvider<MediaStoreData> {
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
@@ -51,16 +49,18 @@ public ListViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewT
     view.getLayoutParams().width = screenWidth;
 
     if (actualDimensions == null) {
-      view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
-        @Override
-        public boolean onPreDraw() {
-          if (actualDimensions == null) {
-            actualDimensions = new int[] { view.getWidth(), view.getHeight() };
-          }
-          view.getViewTreeObserver().removeOnPreDrawListener(this);
-          return true;
-        }
-      });
+      view.getViewTreeObserver()
+          .addOnPreDrawListener(
+              new ViewTreeObserver.OnPreDrawListener() {
+                @Override
+                public boolean onPreDraw() {
+                  if (actualDimensions == null) {
+                    actualDimensions = new int[] {view.getWidth(), view.getHeight()};
+                  }
+                  view.getViewTreeObserver().removeOnPreDrawListener(this);
+                  return true;
+                }
+              });
     }
 
     return new ListViewHolder(view);
@@ -73,11 +73,7 @@ public void onBindViewHolder(@NonNull ListViewHolder viewHolder, int position) {
     Key signature =
         new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
 
-    requestBuilder
-        .clone()
-        .signature(signature)
-        .load(current.uri)
-        .into(viewHolder.image);
+    requestBuilder.clone().signature(signature).load(current.uri).into(viewHolder.image);
   }
 
   @Override
@@ -99,8 +95,8 @@ public int getItemViewType(int position) {
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
     return data.isEmpty()
-            ? Collections.<MediaStoreData>emptyList()
-            : Collections.singletonList(data.get(position));
+        ? Collections.<MediaStoreData>emptyList()
+        : Collections.singletonList(data.get(position));
   }
 
   @Nullable
@@ -108,16 +104,13 @@ public int getItemViewType(int position) {
   public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
-    return requestBuilder
-        .clone()
-        .signature(signature)
-        .load(item.uri);
+    return requestBuilder.clone().signature(signature).load(item.uri);
   }
 
   @Nullable
   @Override
-  public int[] getPreloadSize(@NonNull MediaStoreData item, int adapterPosition,
-      int perItemPosition) {
+  public int[] getPreloadSize(
+      @NonNull MediaStoreData item, int adapterPosition, int perItemPosition) {
     return actualDimensions;
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index 4f78d2d69..ac29f11d9 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -14,9 +14,7 @@
 import java.util.Arrays;
 import java.util.HashSet;
 
-/**
- * A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI.
- */
+/** A java wrapper for Giphy's http api based on https://github.com/Giphy/GiphyAPI. */
 public final class Api {
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
@@ -36,9 +34,7 @@ private static String getTrendingUrl() {
     return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + LIMIT + "&offset=" + OFFSET);
   }
 
-  /**
-   * An interface for listening for search results.
-   */
+  /** An interface for listening for search results. */
   public interface Monitor {
     /**
      * Called when a search completes.
@@ -81,55 +77,55 @@ void getTrending() {
   }
 
   private void query(final String apiUrl) {
-    bgHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        URL url;
-        try {
-          url = new URL(apiUrl);
-        } catch (MalformedURLException e) {
-          throw new RuntimeException(e);
-        }
+    bgHandler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            URL url;
+            try {
+              url = new URL(apiUrl);
+            } catch (MalformedURLException e) {
+              throw new RuntimeException(e);
+            }
 
-        HttpURLConnection urlConnection = null;
-        InputStream is = null;
-        SearchResult result = new SearchResult();
-        try {
-          urlConnection = (HttpURLConnection) url.openConnection();
-          is = urlConnection.getInputStream();
-          InputStreamReader reader = new InputStreamReader(is);
-          result = new Gson().fromJson(reader, SearchResult.class);
-        } catch (IOException e) {
-          e.printStackTrace();
-        } finally {
-          if (is != null) {
+            HttpURLConnection urlConnection = null;
+            InputStream is = null;
+            SearchResult result = new SearchResult();
             try {
-              is.close();
+              urlConnection = (HttpURLConnection) url.openConnection();
+              is = urlConnection.getInputStream();
+              InputStreamReader reader = new InputStreamReader(is);
+              result = new Gson().fromJson(reader, SearchResult.class);
             } catch (IOException e) {
-              // Do nothing.
+              e.printStackTrace();
+            } finally {
+              if (is != null) {
+                try {
+                  is.close();
+                } catch (IOException e) {
+                  // Do nothing.
+                }
+              }
+              if (urlConnection != null) {
+                urlConnection.disconnect();
+              }
             }
-          }
-          if (urlConnection != null) {
-            urlConnection.disconnect();
-          }
-        }
 
-        final SearchResult finalResult = result;
-        mainHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            for (Monitor monitor : monitors) {
-              monitor.onSearchComplete(finalResult);
-            }
+            final SearchResult finalResult = result;
+            mainHandler.post(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    for (Monitor monitor : monitors) {
+                      monitor.onSearchComplete(finalResult);
+                    }
+                  }
+                });
           }
         });
-      }
-    });
   }
 
-  /**
-   * A POJO mirroring the top level result JSON object returned from Giphy's api.
-   */
+  /** A POJO mirroring the top level result JSON object returned from Giphy's api. */
   public static final class SearchResult {
     public GifResult[] data;
 
@@ -160,16 +156,14 @@ public int hashCode() {
     public boolean equals(Object obj) {
       if (obj instanceof GifResult) {
         GifResult other = (GifResult) obj;
-        return Util.bothNullOrEqual(id, other.id)
-            && Util.bothNullOrEqual(images, other.images);
+        return Util.bothNullOrEqual(id, other.id) && Util.bothNullOrEqual(images, other.images);
       }
       return false;
     }
 
     @Override
     public String toString() {
-      return "GifResult{" + "id='" + id + '\'' + ", images=" + images
-          + '}';
+      return "GifResult{" + "id='" + id + '\'' + ", images=" + images + '}';
     }
   }
 
@@ -203,8 +197,13 @@ public boolean equals(Object obj) {
 
     @Override
     public String toString() {
-      return "GifUrlSet{" + "original=" + original + ", fixed_width="
-          + fixed_width + ", fixed_height=" + fixed_height
+      return "GifUrlSet{"
+          + "original="
+          + original
+          + ", fixed_width="
+          + fixed_width
+          + ", fixed_height="
+          + fixed_height
           + '}';
     }
   }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index fd92665ea..05996088b 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -18,9 +18,7 @@
 import com.bumptech.glide.request.target.Target;
 import com.google.gson.Gson;
 
-/**
- * An {@link android.app.Activity} for displaying full size original GIFs.
- */
+/** An {@link android.app.Activity} for displaying full size original GIFs. */
 public class FullscreenActivity extends Activity {
   private static final String EXTRA_RESULT_JSON = "result_json";
   private GifDrawable gifDrawable;
@@ -41,48 +39,57 @@ protected void onCreate(Bundle savedInstanceState) {
 
     ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);
 
-    gifView.setOnClickListener(new View.OnClickListener() {
-      @Override
-      public void onClick(View view) {
-        ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
-        ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
-        clipboard.setPrimaryClip(clip);
+    gifView.setOnClickListener(
+        new View.OnClickListener() {
+          @Override
+          public void onClick(View view) {
+            ClipboardManager clipboard =
+                (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+            ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);
+            clipboard.setPrimaryClip(clip);
 
-        if (gifDrawable != null) {
-          if (gifDrawable.isRunning()) {
-            gifDrawable.stop();
-          } else {
-            gifDrawable.start();
+            if (gifDrawable != null) {
+              if (gifDrawable.isRunning()) {
+                gifDrawable.stop();
+              } else {
+                gifDrawable.start();
+              }
+            }
           }
-        }
-      }
-    });
+        });
 
-    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this)
-        .load(result)
-        .decode(Bitmap.class);
+    RequestBuilder<Drawable> thumbnailRequest =
+        GlideApp.with(this).load(result).decode(Bitmap.class);
 
     GlideApp.with(this)
         .load(result.images.original.url)
         .thumbnail(thumbnailRequest)
-        .listener(new RequestListener<Drawable>() {
-          @Override
-          public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
-              boolean isFirstResource) {
-            return false;
-          }
+        .listener(
+            new RequestListener<Drawable>() {
+              @Override
+              public boolean onLoadFailed(
+                  GlideException e,
+                  Object model,
+                  Target<Drawable> target,
+                  boolean isFirstResource) {
+                return false;
+              }
 
-          @Override
-          public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
-              DataSource dataSource, boolean isFirstResource) {
-            if (resource instanceof GifDrawable) {
-              gifDrawable = (GifDrawable) resource;
-            } else {
-              gifDrawable = null;
-            }
-            return false;
-          }
-        })
+              @Override
+              public boolean onResourceReady(
+                  Drawable resource,
+                  Object model,
+                  Target<Drawable> target,
+                  DataSource dataSource,
+                  boolean isFirstResource) {
+                if (resource instanceof GifDrawable) {
+                  gifDrawable = (GifDrawable) resource;
+                } else {
+                  gifDrawable = null;
+                }
+                return false;
+              }
+            })
         .into(gifView);
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 6fbca3826..76dacd285 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -8,14 +8,12 @@
 import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
-/**
- * Configures Glide for the Giphy sample app.
- */
+/** Configures Glide for the Giphy sample app. */
 @GlideModule
 public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
     registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index a0163074e..f472f2a7d 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -13,8 +13,8 @@
 
 /**
  * A model loader that translates a POJO mirroring a JSON object representing a single image from
- * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
- * {@link android.graphics.drawable.Drawable}.
+ * Giphy's api into an {@link java.io.InputStream} that can be decoded into an {@link
+ * android.graphics.drawable.Drawable}.
  */
 public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
@@ -48,9 +48,7 @@ private static int getDifference(Api.GifImage gifImage, int width, int height) {
     return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
   }
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-   */
+  /** The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s. */
   public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
     @NonNull
     @Override
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 947518cca..b9fab0232 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -38,33 +38,31 @@ protected void onCreate(Bundle savedInstanceState) {
 
     ImageView giphyLogoView = findViewById(R.id.giphy_logo_view);
 
-    GlideApp.with(this)
-        .load(R.raw.large_giphy_logo)
-        .into(giphyLogoView);
+    GlideApp.with(this).load(R.raw.large_giphy_logo).into(giphyLogoView);
 
     RecyclerView gifList = findViewById(R.id.gif_list);
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
-    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this)
-        .asDrawable();
+    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this).asDrawable();
 
-    ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
-        new ViewPreloadSizeProvider<>();
+    ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider = new ViewPreloadSizeProvider<>();
     adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
     gifList.setAdapter(adapter);
     RecyclerViewPreloader<Api.GifResult> preloader =
         new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
-    gifList.setRecyclerListener(new RecyclerListener() {
-      @Override
-      public void onViewRecycled(ViewHolder holder) {
-        // This is an optimization to reduce the memory usage of RecyclerView's recycled view pool
-        // and good practice when using Glide with RecyclerView.
-        GifViewHolder gifViewHolder = (GifViewHolder) holder;
-        GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
-      }
-    });
+    gifList.setRecyclerListener(
+        new RecyclerListener() {
+          @Override
+          public void onViewRecycled(ViewHolder holder) {
+            // This is an optimization to reduce the memory usage of RecyclerView's recycled view
+            // pool
+            // and good practice when using Glide with RecyclerView.
+            GifViewHolder gifViewHolder = (GifViewHolder) holder;
+            GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+          }
+        });
   }
 
   @Override
@@ -97,7 +95,9 @@ public void onSearchComplete(Api.SearchResult result) {
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
-    GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
+    GifAdapter(
+        Activity activity,
+        RequestBuilder<Drawable> requestBuilder,
         ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
       this.activity = activity;
       this.requestBuilder = requestBuilder;
@@ -122,19 +122,19 @@ public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
     @Override
     public void onBindViewHolder(GifViewHolder holder, int position) {
       final Api.GifResult result = results[position];
-      holder.gifView.setOnClickListener(new View.OnClickListener() {
-        @Override
-        public void onClick(View view) {
-          ClipboardManager clipboard =
-              (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
-          ClipData clip =
-              ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
-          Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
-
-          Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
-          activity.startActivity(fullscreenIntent);
-        }
-      });
+      holder.gifView.setOnClickListener(
+          new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+              ClipboardManager clipboard =
+                  (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+              ClipData clip = ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
+              Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
+
+              Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
+              activity.startActivity(fullscreenIntent);
+            }
+          });
 
       // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
       // but that are currently off screen.
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
index f64d72143..6fd5674b2 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -4,9 +4,7 @@
 import dagger.Provides;
 import okhttp3.OkHttpClient;
 
-/**
- * The Application Dagger module for the Imgur sample.
- */
+/** The Application Dagger module for the Imgur sample. */
 @Module
 class ApplicationModule {
   @Provides
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
index c2b788e2b..bbb5f5898 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
@@ -3,9 +3,7 @@
 import dagger.android.AndroidInjector;
 import dagger.android.support.DaggerApplication;
 
-/**
- * Runs Dagger injection in the Imgur sample.
- */
+/** Runs Dagger injection in the Imgur sample. */
 public final class ImgurApplication extends DaggerApplication {
   @Override
   protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
index f621aa47f..67b46f6df 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -16,5 +16,5 @@
       ApiModule.class
     })
 public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
-    // Empty.
+  // Empty.
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
index c673ad244..3daf5319d 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
@@ -3,9 +3,7 @@
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
 
-/**
- * Generates a Glide API for the Imgur sample.
- */
+/** Generates a Glide API for the Imgur sample. */
 @GlideModule(glideName = "ImgurGlide")
 public class ImgurGlideModule extends AppGlideModule {
   // Intentionally Empty.
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
index 384543997..670ed9f18 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
@@ -23,12 +23,13 @@
 import rx.android.schedulers.AndroidSchedulers;
 import rx.schedulers.Schedulers;
 
-/**
- * Displays images and GIFs from Imgur in a scrollable list of cards.
- */
+/** Displays images and GIFs from Imgur in a scrollable list of cards. */
 public final class MainActivity extends AppCompatActivity {
 
-  @Inject @Named("hotViralImages") Observable<List<Image>> fetchImagesObservable;
+  @Inject
+  @Named("hotViralImages")
+  Observable<List<Image>> fetchImagesObservable;
+
   private ImgurImageAdapter adapter;
 
   @Override
@@ -47,18 +48,19 @@ protected void onCreate(Bundle savedInstanceState) {
     fetchImagesObservable
         .subscribeOn(Schedulers.newThread())
         .observeOn(AndroidSchedulers.mainThread())
-        .subscribe(new Observer<List<Image>>() {
-          @Override
-          public void onCompleted() { }
-
-          @Override
-          public void onError(Throwable e) { }
-
-          @Override
-          public void onNext(List<Image> images) {
-            adapter.setData(images);
-          }
-        });
+        .subscribe(
+            new Observer<List<Image>>() {
+              @Override
+              public void onCompleted() {}
+
+              @Override
+              public void onError(Throwable e) {}
+
+              @Override
+              public void onNext(List<Image> images) {
+                adapter.setData(images);
+              }
+            });
   }
 
   @Override
@@ -78,20 +80,17 @@ public void setData(@NonNull List<Image> images) {
 
     @Override
     public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-      return new ViewHolder(LayoutInflater.from(parent.getContext())
-          .inflate(R.layout.image_card, parent, false));
+      return new ViewHolder(
+          LayoutInflater.from(parent.getContext()).inflate(R.layout.image_card, parent, false));
     }
 
     @Override
     public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
       ViewHolder vh = (ViewHolder) holder;
       Image image = images.get(position);
-      vh.title.setText(
-          TextUtils.isEmpty(image.title) ? image.description : image.title);
+      vh.title.setText(TextUtils.isEmpty(image.title) ? image.description : image.title);
 
-      ImgurGlide.with(vh.imageView)
-          .load(image.link)
-          .into(vh.imageView);
+      ImgurGlide.with(vh.imageView).load(image.link).into(vh.imageView);
     }
 
     @Override
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
index 7a70c6dc3..7dde812bb 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -25,27 +25,33 @@
     return imgurObservables.getHotViralImages(5 /*maxPages*/);
   }
 
-  @Provides ImgurObservables imgurObservables(ImgurService imgurService) {
+  @Provides
+  ImgurObservables imgurObservables(ImgurService imgurService) {
     return new ImgurObservables(imgurService);
   }
 
-  @Provides ImgurService getImgurService(Retrofit retrofit) {
+  @Provides
+  ImgurService getImgurService(Retrofit retrofit) {
     return retrofit.create(ImgurService.class);
   }
 
-  @Provides Retrofit retrofit() {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .addInterceptor(new Interceptor() {
-          @Override
-          public Response intercept(Chain chain) throws IOException {
-            return chain.proceed(
-                chain.request()
-                    .newBuilder()
-                    .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
-                    .build());
-          }
-        })
-        .build();
+  @Provides
+  Retrofit retrofit() {
+    OkHttpClient client =
+        new OkHttpClient.Builder()
+            .addInterceptor(
+                new Interceptor() {
+                  @Override
+                  public Response intercept(Chain chain) throws IOException {
+                    return chain.proceed(
+                        chain
+                            .request()
+                            .newBuilder()
+                            .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
+                            .build());
+                  }
+                })
+            .build();
     return new Retrofit.Builder()
         .client(client)
         .addConverterFactory(GsonConverterFactory.create())
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
index 199752239..daa309554 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -12,8 +12,6 @@
 
   @Override
   public String toString() {
-    return "Gallery{"
-        + "data=" + data
-        + '}';
+    return "Gallery{" + "data=" + data + '}';
   }
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
index af157f8cd..28018b4ac 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -15,11 +15,21 @@
   @Override
   public String toString() {
     return "Image{"
-        + "id='" + id + '\''
-        + ", title='" + title + '\''
-        + ", description='" + description + '\''
-        + ", link='" + link + '\''
-        + ", is_album='" + is_album + '\''
+        + "id='"
+        + id
+        + '\''
+        + ", title='"
+        + title
+        + '\''
+        + ", description='"
+        + description
+        + '\''
+        + ", link='"
+        + link
+        + '\''
+        + ", is_album='"
+        + is_album
+        + '\''
         + '}';
   }
 }
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
index 478465160..8b313f050 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -7,9 +7,7 @@
 import rx.functions.Func1;
 import rx.functions.Func2;
 
-/**
- * Observables for retrieving metadata from Imgur's API.
- */
+/** Observables for retrieving metadata from Imgur's API. */
 final class ImgurObservables {
 
   private final ImgurService imgurService;
@@ -20,38 +18,45 @@
 
   Observable<List<Image>> getHotViralImages(@SuppressWarnings("SameParameterValue") int maxPages) {
     return Observable.range(0, maxPages)
-        .flatMap(new Func1<Integer, Observable<List<Image>>>() {
-          @Override
-          public Observable<List<Image>> call(Integer integer) {
-            return imgurService.getHotViral(integer).map(new GetData()).flatMap(
-                new Func1<List<Image>, Observable<List<Image>>>() {
-                  @Override
-                  public Observable<List<Image>> call(List<Image> images) {
-                    for (Iterator<Image> iterator = images.iterator(); iterator.hasNext();) {
-                      if (iterator.next().is_album) {
-                        iterator.remove();
-                      }
-                    }
-                    return Observable.just(images);
-                  }
-                });
-          }
-        })
-        .takeWhile(new Func1<List<Image>, Boolean>() {
-          @Override
-          public Boolean call(List<Image> images) {
-            return !images.isEmpty();
-          }
-        })
-        .scan(new Func2<List<Image>, List<Image>, List<Image>>() {
-          @Override
-          public List<Image> call(List<Image> images, List<Image> images2) {
-            List<Image> result = new ArrayList<>(images.size() + images2.size());
-            result.addAll(images);
-            result.addAll(images2);
-            return result;
-          }
-        })
+        .flatMap(
+            new Func1<Integer, Observable<List<Image>>>() {
+              @Override
+              public Observable<List<Image>> call(Integer integer) {
+                return imgurService
+                    .getHotViral(integer)
+                    .map(new GetData())
+                    .flatMap(
+                        new Func1<List<Image>, Observable<List<Image>>>() {
+                          @Override
+                          public Observable<List<Image>> call(List<Image> images) {
+                            for (Iterator<Image> iterator = images.iterator();
+                                iterator.hasNext(); ) {
+                              if (iterator.next().is_album) {
+                                iterator.remove();
+                              }
+                            }
+                            return Observable.just(images);
+                          }
+                        });
+              }
+            })
+        .takeWhile(
+            new Func1<List<Image>, Boolean>() {
+              @Override
+              public Boolean call(List<Image> images) {
+                return !images.isEmpty();
+              }
+            })
+        .scan(
+            new Func2<List<Image>, List<Image>, List<Image>>() {
+              @Override
+              public List<Image> call(List<Image> images, List<Image> images2) {
+                List<Image> result = new ArrayList<>(images.size() + images2.size());
+                result.addAll(images);
+                result.addAll(images2);
+                return result;
+              }
+            })
         .cache();
   }
 
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
index ddab15062..1cc5261f0 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
@@ -4,9 +4,7 @@
 import retrofit2.http.Path;
 import rx.Observable;
 
-/**
- * Define's Imgur's API for Retrofit.
- */
+/** Define's Imgur's API for Retrofit. */
 public interface ImgurService {
   String CLIENT_ID = "36d1f6bef16370c";
 
@@ -17,21 +15,17 @@
   Observable<Gallery> getHot(@Path("sort") Sort sort, @Path("page") int page);
 
   @GET("gallery/{section}/{sort}/{page}.json")
-  Observable<Gallery> getGallery(@Path("section") Section section,
-      @Path("sort") Sort sort, @Path("page") int page);
+  Observable<Gallery> getGallery(
+      @Path("section") Section section, @Path("sort") Sort sort, @Path("page") int page);
 
-  /**
-   * Sections that Imgur's API allows us to query from.
-   */
+  /** Sections that Imgur's API allows us to query from. */
   enum Section {
     hot,
     top,
     user
   }
 
-  /**
-   * The sort order for content within a particular section.
-   */
+  /** The sort order for content within a particular section. */
   enum Sort {
     viral,
     top,
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index d91a9f665..ce4aab1ff 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -16,9 +16,7 @@
 import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 
-/**
- * Displays an SVG image loaded from an android raw resource.
- */
+/** Displays an SVG image loaded from an android raw resource. */
 public class MainActivity extends Activity {
   private static final String TAG = "SVGActivity";
 
@@ -34,12 +32,13 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = GlideApp.with(this)
-        .as(PictureDrawable.class)
-        .placeholder(R.drawable.image_loading)
-        .error(R.drawable.image_error)
-        .transition(withCrossFade())
-        .listener(new SvgSoftwareLayerSetter());
+    requestBuilder =
+        GlideApp.with(this)
+            .as(PictureDrawable.class)
+            .placeholder(R.drawable.image_loading)
+            .error(R.drawable.image_error)
+            .transition(withCrossFade())
+            .listener(new SvgSoftwareLayerSetter());
   }
 
   @Override
@@ -86,8 +85,13 @@ private void reload() {
   }
 
   private void loadRes() {
-    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
-        + R.raw.android_toy_h);
+    Uri uri =
+        Uri.parse(
+            ContentResolver.SCHEME_ANDROID_RESOURCE
+                + "://"
+                + getPackageName()
+                + "/"
+                + R.raw.android_toy_h);
     requestBuilder.load(uri).into(imageViewRes);
   }
 
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index ad2212227..a47500c20 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -10,9 +10,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Decodes an SVG internal representation from an {@link InputStream}.
- */
+/** Decodes an SVG internal representation from an {@link InputStream}. */
 public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
 
   @Override
@@ -21,8 +19,8 @@ public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     return true;
   }
 
-  public Resource<SVG> decode(@NonNull InputStream source, int width, int height,
-      @NonNull Options options)
+  public Resource<SVG> decode(
+      @NonNull InputStream source, int width, int height, @NonNull Options options)
       throws IOException {
     try {
       SVG svg = SVG.getFromInputStream(source);
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index a3fd80abf..3c3d53bcd 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -11,14 +11,13 @@
 import com.caverock.androidsvg.SVG;
 
 /**
- * Convert the {@link SVG}'s internal representation to an Android-compatible one
- * ({@link Picture}).
+ * Convert the {@link SVG}'s internal representation to an Android-compatible one ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
   @Nullable
   @Override
-  public Resource<PictureDrawable> transcode(@NonNull Resource<SVG> toTranscode,
-      @NonNull Options options) {
+  public Resource<PictureDrawable> transcode(
+      @NonNull Resource<SVG> toTranscode, @NonNull Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index fdd14df98..00df0dcc5 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -10,15 +10,14 @@
 import com.caverock.androidsvg.SVG;
 import java.io.InputStream;
 
-/**
- * Module for the SVG sample app.
- */
+/** Module for the SVG sample app. */
 @GlideModule
 public class SvgModule extends AppGlideModule {
   @Override
-  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
-      @NonNull Registry registry) {
-    registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
+  public void registerComponents(
+      @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {
+    registry
+        .register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
 
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index a28a21b7c..411b50d34 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -9,23 +9,27 @@
 import com.bumptech.glide.request.target.Target;
 
 /**
- * Listener which updates the {@link ImageView} to be software rendered, because
- * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
- * a hardware backed {@link android.graphics.Canvas Canvas}.
+ * Listener which updates the {@link ImageView} to be software rendered, because {@link
+ * com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on a
+ * hardware backed {@link android.graphics.Canvas Canvas}.
  */
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
-  public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
-      boolean isFirstResource) {
+  public boolean onLoadFailed(
+      GlideException e, Object model, Target<PictureDrawable> target, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
     view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
   @Override
-  public boolean onResourceReady(PictureDrawable resource, Object model,
-      Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
+  public boolean onResourceReady(
+      PictureDrawable resource,
+      Object model,
+      Target<PictureDrawable> target,
+      DataSource dataSource,
+      boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
     view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index 54f7cbaf9..2f50bad44 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -2,9 +2,7 @@
 
 import java.io.InputStream;
 
-/**
- * Test only utility for opening resources in androidTest/resources.
- */
+/** Test only utility for opening resources in androidTest/resources. */
 public final class TestResourceUtil {
   private TestResourceUtil() {
     // Utility class
@@ -14,8 +12,8 @@ private TestResourceUtil() {
    * Returns an InputStream for the given test class and sub-path.
    *
    * @param testClass A Junit test class.
-   * @param subPath   The sub-path under androidTest/resources where the desired resource is
-   *                  located. Should not be prefixed with a '/'
+   * @param subPath The sub-path under androidTest/resources where the desired resource is located.
+   *     Should not be prefixed with a '/'
    */
   public static InputStream openResource(Class<?> testClass, String subPath) {
     return testClass.getResourceAsStream("/" + subPath);
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index f39342c94..e34237aa4 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -6,9 +6,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 
-/**
- * Shared utility classes for tests.
- */
+/** Shared utility classes for tests. */
 // Public API.
 @SuppressWarnings("WeakerAccess")
 public final class TestUtil {
