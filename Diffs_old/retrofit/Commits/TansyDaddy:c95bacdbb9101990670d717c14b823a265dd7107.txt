diff --git a/retrofit/src/main/java/retrofit/BaseUrl.java b/retrofit/src/main/java/retrofit/BaseUrl.java
index 7052f5083..b8f832b86 100644
--- a/retrofit/src/main/java/retrofit/BaseUrl.java
+++ b/retrofit/src/main/java/retrofit/BaseUrl.java
@@ -1,3 +1,7 @@
+/*
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
+ */
+
 package retrofit;
 
 import com.squareup.okhttp.HttpUrl;
diff --git a/retrofit/src/main/java/retrofit/BuiltInConverters.java b/retrofit/src/main/java/retrofit/BuiltInConverters.java
index be2f81d5e..9d560e944 100644
--- a/retrofit/src/main/java/retrofit/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit/BuiltInConverters.java
@@ -1,80 +1,73 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
+import retrofit.http.Streaming;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import retrofit.http.Streaming;
 
 import static retrofit.Utils.closeQuietly;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
-    if (ResponseBody.class.equals(type)) {
-      boolean isStreaming = Utils.isAnnotationPresent(annotations, Streaming.class);
-      return new OkHttpResponseBodyConverter(isStreaming);
+    @Override
+    public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+        if (ResponseBody.class.equals(type)) {
+            boolean isStreaming = Utils.isAnnotationPresent(annotations, Streaming.class);
+            return new OkHttpResponseBodyConverter(isStreaming);
+        }
+        if (Void.class.equals(type)) {
+            return new VoidConverter();
+        }
+        return null;
     }
-    if (Void.class.equals(type)) {
-      return new VoidConverter();
-    }
-    return null;
-  }
 
-  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
-    if (type instanceof Class && RequestBody.class.isAssignableFrom((Class<?>) type)) {
-      return new OkHttpRequestBodyConverter();
+    @Override
+    public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+        if (type instanceof Class && RequestBody.class.isAssignableFrom((Class<?>) type)) {
+            return new OkHttpRequestBodyConverter();
+        }
+        return null;
     }
-    return null;
-  }
 
-  static final class VoidConverter implements Converter<ResponseBody, Void> {
-    @Override public Void convert(ResponseBody value) throws IOException {
-      value.close();
-      return null;
+    static final class VoidConverter implements Converter<ResponseBody, Void> {
+        @Override
+        public Void convert(ResponseBody value) throws IOException {
+            value.close();
+            return null;
+        }
     }
-  }
 
-  static final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
-    @Override public RequestBody convert(RequestBody value) throws IOException {
-      return value;
+    static final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
+        @Override
+        public RequestBody convert(RequestBody value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
-    private final boolean isStreaming;
+    static final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
+        private final boolean isStreaming;
 
-    OkHttpResponseBodyConverter(boolean isStreaming) {
-      this.isStreaming = isStreaming;
-    }
+        OkHttpResponseBodyConverter(boolean isStreaming) {
+            this.isStreaming = isStreaming;
+        }
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      if (isStreaming) {
-        return value;
-      }
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            if (isStreaming) {
+                return value;
+            }
 
-      // Buffer the entire body to avoid future I/O.
-      try {
-        return Utils.readBodyToBytesIfNecessary(value);
-      } finally {
-        closeQuietly(value);
-      }
+            // Buffer the entire body to avoid future I/O.
+            try {
+                return Utils.readBodyToBytesIfNecessary(value);
+            } finally {
+                closeQuietly(value);
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index feca6922d..628f66e7f 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -1,20 +1,10 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
+import com.squareup.okhttp.CacheControl;
+
 import java.io.IOException;
 
 /**
@@ -22,7 +12,7 @@
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
- *
+ * <p/>
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
@@ -32,23 +22,31 @@
  * add dynamicBaseUrl and cachePloy param
  */
 public interface Call<T> extends Cloneable {
-  Response<T> execute() throws IOException;
+    Response<T> execute() throws IOException;
+
+    Response<T> execute(String dynamicBaseUrl) throws IOException;
+
+    Response<T> execute(RequestFactory.CachePloy cachePloy) throws IOException;
+
+    Response<T> execute(CacheControl controlPloy) throws IOException;
+
+    Response<T> execute(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) throws IOException;
 
-  Response<T> execute(String dynamicBaseUrl) throws IOException;
+    Response<T> execute(String dynamicBaseUrl, CacheControl controlPloy) throws IOException;
 
-  Response<T> execute(RequestFactory.CachePloy cachePloy) throws IOException;
+    void enqueue(Callback<T> callback);
 
-  Response<T> execute(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) throws IOException;
+    void enqueue(Callback<T> callback, String dynamicBaseUrl);
 
-  void enqueue(Callback<T> callback);
+    void enqueue(Callback<T> callback, RequestFactory.CachePloy cachePloy);
 
-  void enqueue(Callback<T> callback, String dynamicBaseUrl);
+    void enqueue(Callback<T> callback, CacheControl controlPloy);
 
-  void enqueue(Callback<T> callback, RequestFactory.CachePloy cachePloy);
+    void enqueue(Callback<T> callback, String dynamicBaseUrl, RequestFactory.CachePloy cachePloy);
 
-  void enqueue(Callback<T> callback, String dynamicBaseUrl, RequestFactory.CachePloy cachePloy);
+    void enqueue(Callback<T> callback, String dynamicBaseUrl, CacheControl controlPloy);
 
-  void cancel();
+    void cancel();
 
-  Call<T> clone();
+    Call<T> clone();
 }
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
index d8dba7b00..6779abe05 100644
--- a/retrofit/src/main/java/retrofit/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 71ccd0e95..0efbdfe66 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
index d4c2f228e..179191dfd 100644
--- a/retrofit/src/main/java/retrofit/Converter.java
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -1,22 +1,11 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
index 64f9bf913..6fee6d57f 100644
--- a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index 23ffbc13b..aab4fd19e 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -1,20 +1,10 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
+import com.squareup.okhttp.CacheControl;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -68,11 +58,21 @@ public void enqueue(Callback<T> callback, RequestFactory.CachePloy cachePloy) {
       delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback), cachePloy);
     }
 
+    @Override
+    public void enqueue(Callback<T> callback, CacheControl cacheControl) {
+      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback), cacheControl);
+    }
+
     @Override
     public void enqueue(Callback<T> callback, String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) {
       delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback), dynamicBaseUrl, cachePloy);
     }
 
+    @Override
+    public void enqueue(Callback<T> callback, String dynamicBaseUrl, CacheControl cacheControl) {
+      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback), dynamicBaseUrl, cacheControl);
+    }
+
     @Override
     public Response<T> execute() throws IOException {
       return delegate.execute();
@@ -88,11 +88,21 @@ public void enqueue(Callback<T> callback, String dynamicBaseUrl, RequestFactory.
       return delegate.execute(cachePloy);
     }
 
+    @Override
+    public Response<T> execute(CacheControl cacheControl) throws IOException {
+      return delegate.execute(cacheControl);
+    }
+
     @Override
     public Response<T> execute(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) throws IOException {
       return delegate.execute(dynamicBaseUrl, cachePloy);
     }
 
+    @Override
+    public Response<T> execute(String dynamicBaseUrl, CacheControl cacheControl) throws IOException {
+      return delegate.execute(dynamicBaseUrl, cacheControl);
+    }
+
     @Override public void cancel() {
       delegate.cancel();
     }
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
index 4ec92c145..fdec5c1e4 100644
--- a/retrofit/src/main/java/retrofit/MethodHandler.java
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -1,21 +1,10 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
 import com.squareup.okhttp.ResponseBody;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index bb82727c2..f90cb0b50 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -1,24 +1,16 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
+import com.squareup.okhttp.CacheControl;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
@@ -27,310 +19,301 @@
 import static retrofit.Utils.closeQuietly;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final Retrofit retrofit;
-  private final RequestFactory requestFactory;
-  private final Converter<ResponseBody, T> responseConverter;
-  private final Object[] args;
-
-  private volatile com.squareup.okhttp.Call rawCall;
-  private boolean executed; // Guarded by this.
-  private volatile boolean canceled;
-
-  OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,
-      Converter<ResponseBody, T> responseConverter, Object[] args) {
-    this.retrofit = retrofit;
-    this.requestFactory = requestFactory;
-    this.responseConverter = responseConverter;
-    this.args = args;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(retrofit, requestFactory, responseConverter, args);
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    private final Retrofit retrofit;
+    private final RequestFactory requestFactory;
+    private final Converter<ResponseBody, T> responseConverter;
+    private final Object[] args;
+
+    private volatile com.squareup.okhttp.Call rawCall;
+    private boolean executed; // Guarded by this.
+    private volatile boolean canceled;
+
+    OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,
+               Converter<ResponseBody, T> responseConverter, Object[] args) {
+        this.retrofit = retrofit;
+        this.requestFactory = requestFactory;
+        this.responseConverter = responseConverter;
+        this.args = args;
     }
 
-    com.squareup.okhttp.Call rawCall;
-    try {
-      rawCall = createRawCall();
-    } catch (Throwable t) {
-      callback.onFailure(t);
-      return;
+    @SuppressWarnings("CloneDoesntCallSuperClone")
+    // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(retrofit, requestFactory, responseConverter, args);
     }
-    if (canceled) {
-      rawCall.cancel();
-    }
-    this.rawCall = rawCall;
-
-    rawCall.enqueue(new com.squareup.okhttp.Callback() {
-      private void callFailure(Throwable e) {
-        try {
-          callback.onFailure(e);
-        } catch (Throwable t) {
-          t.printStackTrace();
-        }
-      }
 
-      private void callSuccess(Response<T> response) {
-        try {
-          callback.onResponse(response, retrofit);
-        } catch (Throwable t) {
-          t.printStackTrace();
-        }
-      }
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        enqueue(callback, null, RequestFactory.CachePloy.FORCE_NETWORK);
+    }
 
-      @Override public void onFailure(Request request, IOException e) {
-        callFailure(e);
-      }
+    @Override
+    public void enqueue(Callback<T> callback, String dynamicBaseUrl) {
+        enqueue(callback, dynamicBaseUrl, RequestFactory.CachePloy.FORCE_NETWORK);
+    }
 
-      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
-        }
-        callSuccess(response);
-      }
-    });
-  }
-
-  @Override
-  public void enqueue(Callback<T> callback, String dynamicBaseUrl) {
-    enqueue(callback,dynamicBaseUrl, RequestFactory.CachePloy.FORCE_NETWORK);
-  }
-
-  @Override
-  public void enqueue(Callback<T> callback, RequestFactory.CachePloy cachePloy) {
-    enqueue(callback,null, cachePloy);
-  }
-
-  @Override
-  public void enqueue(final Callback<T> callBack, String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    @Override
+    public void enqueue(Callback<T> callback, RequestFactory.CachePloy cachePloy) {
+        enqueue(callback, null, cachePloy);
     }
 
-    com.squareup.okhttp.Call rawCall;
-    try {
-      rawCall = createRawCall(dynamicBaseUrl,cachePloy);
-    } catch (Throwable t) {
-      callBack.onFailure(t);
-      return;
+    @Override
+    public void enqueue(Callback<T> callback, CacheControl controlPloy) {
+        enqueue(callback, null, controlPloy);
     }
-    if (canceled) {
-      rawCall.cancel();
+
+    @Override
+    public void enqueue(final Callback<T> callBack, String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) {
+        enqueue(callBack, dynamicBaseUrl, convertCache(cachePloy));
     }
-    this.rawCall = rawCall;
 
-    rawCall.enqueue(new com.squareup.okhttp.Callback() {
-      private void callFailure(Throwable e) {
-        try {
-          callBack.onFailure(e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+    @Override
+    public void enqueue(final Callback<T> cBack, String dynamicBaseUrl, CacheControl cacheControl) {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed");
+            executed = true;
         }
-      }
 
-      private void callSuccess(Response<T> response) {
+        com.squareup.okhttp.Call rawCall;
         try {
-          callBack.onResponse(response, retrofit);
+            rawCall = createRawCall(dynamicBaseUrl, cacheControl);
         } catch (Throwable t) {
-          t.printStackTrace();
+            cBack.onFailure(t);
+            return;
         }
-      }
-
-      @Override
-      public void onFailure(Request request, IOException e) {
-        callFailure(e);
-      }
-
-      @Override
-      public void onResponse(com.squareup.okhttp.Response rawResponse) {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+        if (canceled) {
+            rawCall.cancel();
         }
-        callSuccess(response);
-      }
-    });
-  }
-
-  public Response<T> execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+        this.rawCall = rawCall;
+
+        rawCall.enqueue(new com.squareup.okhttp.Callback() {
+            private void callFailure(Throwable e) {
+                try {
+                    cBack.onFailure(e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callSuccess(Response<T> response) {
+                try {
+                    cBack.onResponse(response, retrofit);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            @Override
+            public void onFailure(Request request, IOException e) {
+                callFailure(e);
+            }
+
+            @Override
+            public void onResponse(com.squareup.okhttp.Response rawResponse) {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    callFailure(e);
+                    return;
+                }
+                callSuccess(response);
+            }
+        });
     }
 
-    com.squareup.okhttp.Call rawCall = createRawCall();
-    if (canceled) {
-      rawCall.cancel();
+    public Response<T> execute() throws IOException {
+        return execute(null, RequestFactory.CachePloy.FORCE_NETWORK);
     }
-    this.rawCall = rawCall;
 
-    return parseResponse(rawCall.execute());
-  }
+    @Override
+    public Response<T> execute(String dynamicBaseUrl) throws IOException {
+        return execute(dynamicBaseUrl, RequestFactory.CachePloy.FORCE_NETWORK);
+    }
 
-  @Override
-  public Response<T> execute(String dynamicBaseUrl) throws IOException {
-    return execute(dynamicBaseUrl, RequestFactory.CachePloy.FORCE_NETWORK);
-  }
+    @Override
+    public Response<T> execute(RequestFactory.CachePloy cachePloy) throws IOException {
+        return execute(null, cachePloy);
+    }
 
-  @Override
-  public Response<T> execute(RequestFactory.CachePloy cachePloy) throws IOException {
-    return execute(null, cachePloy);
-  }
+    @Override
+    public Response<T> execute(CacheControl cacheControl) throws IOException {
+        return execute(null, cacheControl);
+    }
 
 
-  @Override
-  public Response<T> execute(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    @Override
+    public Response<T> execute(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) throws IOException {
+        return execute(dynamicBaseUrl, convertCache(cachePloy));
     }
 
-    com.squareup.okhttp.Call rawCall = createRawCall(dynamicBaseUrl,cachePloy);
-    if (canceled) {
-      rawCall.cancel();
-    }
-    this.rawCall = rawCall;
-
-    return parseResponse(rawCall.execute());
-  }
-
-  private com.squareup.okhttp.Call createRawCall() {
-    return retrofit.client().newCall(requestFactory.create(args));
-  }
-
-  private com.squareup.okhttp.Call createRawCall(String dynamicBaseUrl, RequestFactory.CachePloy cachePloy) {
-    return retrofit.client().newCall(requestFactory.create(dynamicBaseUrl, cachePloy, args));
-  }
-
-  private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        closeQuietly(rawBody);
-      }
-    }
+    @Override
+    public Response<T> execute(String dynamicBaseUrl, CacheControl cacheControl) throws IOException {
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed");
+            executed = true;
+        }
 
-    if (code == 204 || code == 205) {
-      return Response.success(null, rawResponse);
-    }
+        com.squareup.okhttp.Call rawCall = createRawCall(dynamicBaseUrl, cacheControl);
+        if (canceled) {
+            rawCall.cancel();
+        }
+        this.rawCall = rawCall;
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
-    try {
-      T body = responseConverter.convert(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+        return parseResponse(rawCall.execute());
     }
-  }
 
-  public void cancel() {
-    canceled = true;
-    com.squareup.okhttp.Call rawCall = this.rawCall;
-    if (rawCall != null) {
-      rawCall.cancel();
+    private com.squareup.okhttp.Call createRawCall(String dynamicBaseUrl, CacheControl controlPloy) {
+        return retrofit.client().newCall(requestFactory.create(dynamicBaseUrl, controlPloy, args));
     }
-  }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
-    private final long contentLength;
+    private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                closeQuietly(rawBody);
+            }
+        }
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-    }
+        if (code == 204 || code == 205) {
+            return Response.success(null, rawResponse);
+        }
 
-    @Override public MediaType contentType() {
-      return contentType;
+        ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+        try {
+            T body = responseConverter.convert(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
     }
 
-    @Override public long contentLength() throws IOException {
-      return contentLength;
+    public void cancel() {
+        canceled = true;
+        com.squareup.okhttp.Call rawCall = this.rawCall;
+        if (rawCall != null) {
+            rawCall.cancel();
+        }
     }
 
-    @Override public BufferedSource source() throws IOException {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final MediaType contentType;
+        private final long contentLength;
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
-    private final ResponseBody delegate;
-    private IOException thrownException;
+        NoContentResponseBody(MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
-    }
+        @Override
+        public long contentLength() throws IOException {
+            return contentLength;
+        }
 
-    @Override public long contentLength() throws IOException {
-      try {
-        return delegate.contentLength();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
+        @Override
+        public BufferedSource source() throws IOException {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public BufferedSource source() throws IOException {
-      BufferedSource delegateSource;
-      try {
-        delegateSource = delegate.source();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-      return Okio.buffer(new ForwardingSource(delegateSource) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+    static final class ExceptionCatchingRequestBody extends ResponseBody {
+        private final ResponseBody delegate;
+        private IOException thrownException;
+
+        ExceptionCatchingRequestBody(ResponseBody delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            try {
+                return delegate.contentLength();
+            } catch (IOException e) {
+                thrownException = e;
+                throw e;
+            }
         }
-      });
-    }
 
-    @Override public void close() throws IOException {
-      delegate.close();
+        @Override
+        public BufferedSource source() throws IOException {
+            BufferedSource delegateSource;
+            try {
+                delegateSource = delegate.source();
+            } catch (IOException e) {
+                thrownException = e;
+                throw e;
+            }
+            return Okio.buffer(new ForwardingSource(delegateSource) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() throws IOException {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+    private CacheControl convertCache(RequestFactory.CachePloy cachePloy) {
+        CacheControl cacheControl = CacheControl.FORCE_NETWORK;
+        switch (cachePloy) {
+            case FORCE_CACHE:
+                cacheControl = CacheControl.FORCE_CACHE;
+                break;
+            case FORCE_NETWORK:
+                cacheControl = CacheControl.FORCE_NETWORK;
+                break;
+            case MAX_AGE_0:
+                cacheControl = new CacheControl.Builder()
+                        .maxAge(0, TimeUnit.SECONDS)
+                        .build();
+                break;
+            case MAX_STALE:
+                cacheControl = new CacheControl.Builder()
+                        .maxStale(60, TimeUnit.MINUTES)
+                        .build();
+                break;
+        }
+        return cacheControl;
     }
-  }
 
 }
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index b28337158..f5d60a4b7 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -1,27 +1,14 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import java.lang.invoke.MethodHandles;
+
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -38,11 +25,12 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
+    /**
     try {
       Class.forName("java.util.Optional");
       return new Java8();
     } catch (ClassNotFoundException ignored) {
-    }
+    }*/
     return new Platform();
   }
 
@@ -62,6 +50,7 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
     throw new UnsupportedOperationException();
   }
 
+  /**
   @IgnoreJRERequirement // Only classloaded and used on Java 8.
   static class Java8 extends Platform {
     @Override boolean isDefaultMethod(Method method) {
@@ -76,7 +65,7 @@ Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object
           .bindTo(object)
           .invokeWithArguments(args);
     }
-  }
+  }*/
 
   static class Android extends Platform {
     @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 294df18ca..0755a8ec0 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
@@ -22,7 +10,9 @@
 import com.squareup.okhttp.MultipartBuilder;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
+
 import java.io.IOException;
+
 import okio.Buffer;
 import okio.BufferedSink;
 
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
index a59234e47..1799f1dfc 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilderAction.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -1,22 +1,11 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.RequestBody;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
@@ -25,257 +14,267 @@
 import static retrofit.Utils.checkNotNull;
 
 abstract class RequestBuilderAction {
-  abstract void perform(RequestBuilder builder, Object value);
-
-  static final class Url extends RequestBuilderAction {
-    @Override void perform(RequestBuilder builder, Object value) {
-      builder.setRelativeUrl((String) value);
-    }
-  }
+    abstract void perform(RequestBuilder builder, Object value);
 
-  static final class Header extends RequestBuilderAction {
-    private final String name;
-
-    Header(String name) {
-      this.name = checkNotNull(name, "name == null");
+    static final class Url extends RequestBuilderAction {
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            builder.setRelativeUrl((String) value);
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class Header extends RequestBuilderAction {
+        private final String name;
 
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addHeader(name, iterableValue.toString());
-          }
+        Header(String name) {
+            this.name = checkNotNull(name, "name == null");
         }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addHeader(name, arrayValue.toString());
-          }
-        }
-      } else {
-        builder.addHeader(name, value.toString());
-      }
-    }
-  }
 
-  static final class Path extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Path(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            if (value instanceof Iterable) {
+                for (Object iterableValue : (Iterable<?>) value) {
+                    if (iterableValue != null) { // Skip null values.
+                        builder.addHeader(name, iterableValue.toString());
+                    }
+                }
+            } else if (value.getClass().isArray()) {
+                for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                    Object arrayValue = Array.get(value, x);
+                    if (arrayValue != null) { // Skip null values.
+                        builder.addHeader(name, arrayValue.toString());
+                    }
+                }
+            } else {
+                builder.addHeader(name, value.toString());
+            }
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, value.toString(), encoded);
-    }
-  }
+    static final class Path extends RequestBuilderAction {
+        private final String name;
+        private final boolean encoded;
 
-  static final class Query extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
+        Path(String name, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.encoded = encoded;
+        }
 
-    Query(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) {
+                throw new IllegalArgumentException(
+                        "Path parameter \"" + name + "\" value must not be null.");
+            }
+            builder.addPathParam(name, value.toString(), encoded);
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class Query extends RequestBuilderAction {
+        private final String name;
+        private final boolean encoded;
 
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addQueryParam(name, iterableValue.toString(), encoded);
-          }
+        Query(String name, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.encoded = encoded;
         }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addQueryParam(name, arrayValue.toString(), encoded);
-          }
-        }
-      } else {
-        builder.addQueryParam(name, value.toString(), encoded);
-      }
-    }
-  }
 
-  static final class QueryMap extends RequestBuilderAction {
-    private final boolean encoded;
-
-    QueryMap(boolean encoded) {
-      this.encoded = encoded;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            if (value instanceof Iterable) {
+                for (Object iterableValue : (Iterable<?>) value) {
+                    if (iterableValue != null) { // Skip null values.
+                        builder.addQueryParam(name, iterableValue.toString(), encoded);
+                    }
+                }
+            } else if (value.getClass().isArray()) {
+                for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                    Object arrayValue = Array.get(value, x);
+                    if (arrayValue != null) { // Skip null values.
+                        builder.addQueryParam(name, arrayValue.toString(), encoded);
+                    }
+                }
+            } else {
+                builder.addQueryParam(name, value.toString(), encoded);
+            }
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class QueryMap extends RequestBuilderAction {
+        private final boolean encoded;
 
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
+        QueryMap(boolean encoded) {
+            this.encoded = encoded;
         }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
-        }
-      }
-    }
-  }
 
-  static final class Field extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Field(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            Map<?, ?> map = (Map<?, ?>) value;
+            for (Map.Entry<?, ?> entry : map.entrySet()) {
+                Object entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Query map contained null key.");
+                }
+                Object entryValue = entry.getValue();
+                if (entryValue != null) { // Skip null values.
+                    builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+                }
+            }
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class Field extends RequestBuilderAction {
+        private final String name;
+        private final boolean encoded;
 
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addFormField(name, iterableValue.toString(), encoded);
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addFormField(name, arrayValue.toString(), encoded);
-          }
+        Field(String name, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.encoded = encoded;
         }
-      } else {
-        builder.addFormField(name, value.toString(), encoded);
-      }
-    }
-  }
-
-  static final class FieldMap extends RequestBuilderAction {
-    private final boolean encoded;
 
-    FieldMap(boolean encoded) {
-      this.encoded = encoded;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            if (value instanceof Iterable) {
+                for (Object iterableValue : (Iterable<?>) value) {
+                    if (iterableValue != null) { // Skip null values.
+                        builder.addFormField(name, iterableValue.toString(), encoded);
+                    }
+                }
+            } else if (value.getClass().isArray()) {
+                for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+                    Object arrayValue = Array.get(value, x);
+                    if (arrayValue != null) { // Skip null values.
+                        builder.addFormField(name, arrayValue.toString(), encoded);
+                    }
+                }
+            } else {
+                builder.addFormField(name, value.toString(), encoded);
+            }
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class FieldMap extends RequestBuilderAction {
+        private final boolean encoded;
 
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
+        FieldMap(boolean encoded) {
+            this.encoded = encoded;
         }
-      }
-    }
-  }
-
-  static final class Part<T> extends RequestBuilderAction {
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
-      this.headers = headers;
-      this.converter = converter;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            Map<?, ?> map = (Map<?, ?>) value;
+            for (Map.Entry<?, ?> entry : map.entrySet()) {
+                Object entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Field map contained null key.");
+                }
+                Object entryValue = entry.getValue();
+                if (entryValue != null) { // Skip null values.
+                    builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
+                }
+            }
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      RequestBody body;
-      try {
-        //noinspection unchecked
-        body = converter.convert((T) value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
-    }
-  }
+    static final class Part<T> extends RequestBuilderAction {
+        private final Headers headers;
+        private final Converter<T, RequestBody> converter;
 
-  static final class PartMap extends RequestBuilderAction {
-    private final Retrofit retrofit;
-    private final String transferEncoding;
-    private final Annotation[] annotations;
+        Part(Headers headers, Converter<T, RequestBody> converter) {
+            this.headers = headers;
+            this.converter = converter;
+        }
 
-    PartMap(Retrofit retrofit, String transferEncoding, Annotation[] annotations) {
-      this.retrofit = retrofit;
-      this.transferEncoding = transferEncoding;
-      this.annotations = annotations;
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            RequestBody body;
+            try {
+                //noinspection unchecked
+                body = converter.convert((T) value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.addPart(headers, body);
+        }
     }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
+    static final class PartMap extends RequestBuilderAction {
+        private final Retrofit retrofit;
+        private final String transferEncoding;
+        private final Annotation[] annotations;
 
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue == null) {
-          continue; // Skip null values.
+        PartMap(Retrofit retrofit, String transferEncoding, Annotation[] annotations) {
+            this.retrofit = retrofit;
+            this.transferEncoding = transferEncoding;
+            this.annotations = annotations;
         }
 
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        Class<?> entryClass = entryValue.getClass();
-        //noinspection unchecked
-        Converter<Object, RequestBody> converter =
-            (Converter<Object, RequestBody>) retrofit.requestConverter(entryClass, annotations);
-        RequestBody body;
-        try {
-          body = converter.convert(entryValue);
-        } catch (IOException e) {
-          throw new RuntimeException("Unable to convert " + entryValue + " to RequestBody", e);
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) return; // Skip null values.
+
+            Map<?, ?> map = (Map<?, ?>) value;
+            for (Map.Entry<?, ?> entry : map.entrySet()) {
+                Object entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Part map contained null key.");
+                }
+                Object entryValue = entry.getValue();
+                if (entryValue == null) {
+                    continue; // Skip null values.
+                }
+
+                Headers headers = Headers.of(
+                        "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+                        "Content-Transfer-Encoding", transferEncoding);
+
+                Class<?> entryClass = entryValue.getClass();
+                //noinspection unchecked
+                Converter<Object, RequestBody> converter =
+                        (Converter<Object, RequestBody>) retrofit.requestConverter(entryClass, annotations);
+                RequestBody body;
+                try {
+                    body = converter.convert(entryValue);
+                } catch (IOException e) {
+                    throw new RuntimeException("Unable to convert " + entryValue + " to RequestBody", e);
+                }
+                builder.addPart(headers, body);
+            }
         }
-        builder.addPart(headers, body);
-      }
     }
-  }
 
-  static final class Body<T> extends RequestBuilderAction {
-    private final Converter<T, RequestBody> converter;
+    static final class Body<T> extends RequestBuilderAction {
+        private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
-      this.converter = converter;
-    }
+        Body(Converter<T, RequestBody> converter) {
+            this.converter = converter;
+        }
 
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        //noinspection unchecked
-        body = converter.convert((T) value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.setBody(body);
+        @Override
+        void perform(RequestBuilder builder, Object value) {
+            if (value == null) {
+                throw new IllegalArgumentException("Body parameter value must not be null.");
+            }
+            RequestBody body;
+            try {
+                //noinspection unchecked
+                body = converter.convert((T) value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.setBody(body);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
index bbbac7c72..75d26ccf6 100644
--- a/retrofit/src/main/java/retrofit/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
@@ -23,8 +11,6 @@
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 
-import java.util.concurrent.TimeUnit;
-
 public final class RequestFactory {
   private final String method;
   private final BaseUrl baseUrl;
@@ -54,96 +40,20 @@
     this.requestBuilderActions = requestBuilderActions;
   }
 
-  Request create(Object... args) {
-    RequestBuilder requestBuilder =
-        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
-            isFormEncoded, isMultipart);
-
-    if (args != null) {
-      RequestBuilderAction[] actions = requestBuilderActions;
-      if (actions.length != args.length) {
-        throw new IllegalArgumentException("Argument count ("
-            + args.length
-            + ") doesn't match action count ("
-            + actions.length
-            + ")");
-      }
-      for (int i = 0, count = args.length; i < count; i++) {
-        actions[i].perform(requestBuilder, args[i]);
-      }
-    }
-
-    return requestBuilder.build();
-  }
-
-    /**
-     * 
-     * @add by FanLei
-     */
-    Request create(CachePloy cachePloy, Object... args) {
-        Request.Builder reqBuilder = null;
-
-        if (cachePloy == CachePloy.FORCE_NETWORK) {// 
-            reqBuilder = new Request.Builder().cacheControl(CacheControl.FORCE_NETWORK);
-        } else if (cachePloy == CachePloy.FORCE_CACHE) {// onIfCached+maxStale=MAX.VALUE
-            reqBuilder = new Request.Builder().cacheControl(CacheControl.FORCE_CACHE);
-        } else if (cachePloy == CachePloy.MAX_AGE_0) {// 
-            reqBuilder = new Request.Builder().cacheControl(new CacheControl.Builder()
-                    .maxAge(0, TimeUnit.SECONDS)
-                    .build());
-        } else if (cachePloy == CachePloy.MAX_STALE) {// (30)
-            reqBuilder = new Request.Builder().cacheControl(new CacheControl.Builder()
-                    .maxStale(30, TimeUnit.DAYS)
-                    .build());
-        }
-
-        RequestBuilder requestBuilder =
-                new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
-                        isFormEncoded, isMultipart, reqBuilder);
-
-        if (args != null) {
-            RequestBuilderAction[] actions = requestBuilderActions;
-            if (actions.length != args.length) {
-                throw new IllegalArgumentException("Argument count ("
-                        + args.length
-                        + ") doesn't match action count ("
-                        + actions.length
-                        + ")");
-            }
-            for (int i = 0, count = args.length; i < count; i++) {
-                actions[i].perform(requestBuilder, args[i]);
-            }
-        }
-
-        return requestBuilder.build();
-    }
-
     /**
      * baseURL
+     *
      * @add by FanLei
      */
-    Request create(String dymicBaseUrl, CachePloy cachePloy, Object... args) {
-        Request.Builder reqBuilder = null;
-
-        if (cachePloy == CachePloy.FORCE_NETWORK) {// 
-            reqBuilder = new Request.Builder().cacheControl(CacheControl.FORCE_NETWORK);
-        } else if (cachePloy == CachePloy.FORCE_CACHE) {// onIfCached+maxStale=MAX.VALUE
-            reqBuilder = new Request.Builder().cacheControl(CacheControl.FORCE_CACHE);
-        } else if (cachePloy == CachePloy.MAX_AGE_0) {// 
-            reqBuilder = new Request.Builder().cacheControl(new CacheControl.Builder()
-                    .maxAge(0, TimeUnit.SECONDS)
-                    .build());
-        } else if (cachePloy == CachePloy.MAX_STALE) {// (30)
-            reqBuilder = new Request.Builder().cacheControl(new CacheControl.Builder()
-                    .maxStale(30, TimeUnit.DAYS)
-                    .build());
-        }
-
+    Request create(String dynamicBaseUrl, CacheControl controlPloy, Object... args) {
         HttpUrl baseHttpUrl = baseUrl.url();
-        if (!TextUtils.isEmpty(dymicBaseUrl)) {
-            baseHttpUrl = HttpUrl.parse(dymicBaseUrl);
+        if (!TextUtils.isEmpty(dynamicBaseUrl)) {
+            baseHttpUrl = HttpUrl.parse(dynamicBaseUrl);
         }
 
+        Request.Builder reqBuilder = reqBuilder = new Request.Builder().cacheControl(controlPloy);
+        ;
+
         RequestBuilder requestBuilder =
                 new RequestBuilder(method, baseHttpUrl, relativeUrl, headers, contentType, hasBody,
                         isFormEncoded, isMultipart, reqBuilder);
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
index 4d807ded0..bae7fbebf 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -1,30 +1,8 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import retrofit.http.Body;
 import retrofit.http.DELETE;
 import retrofit.http.Field;
@@ -45,350 +23,361 @@
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
 import retrofit.http.Url;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import static retrofit.Utils.methodError;
 
 final class RequestFactoryParser {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
-    RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations(responseType);
-    parser.parseParameters(retrofit);
-    return parser.toRequestFactory(retrofit.baseUrl());
-  }
-
-  private final Method method;
-
-  private String httpMethod;
-  private boolean hasBody;
-  private boolean isFormEncoded;
-  private boolean isMultipart;
-  private String relativeUrl;
-  private com.squareup.okhttp.Headers headers;
-  private MediaType contentType;
-  private RequestBuilderAction[] requestBuilderActions;
-
-  private Set<String> relativeUrlParamNames;
-
-  private RequestFactoryParser(Method method) {
-    this.method = method;
-  }
-
-  private RequestFactory toRequestFactory(BaseUrl baseUrl) {
-    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
-        isFormEncoded, isMultipart, requestBuilderActions);
-  }
-
-  private RuntimeException parameterError(Throwable cause, int index, String message,
-      Object... args) {
-    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  private void parseMethodAnnotations(Type responseType) {
-    for (Annotation annotation : method.getAnnotations()) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError(method, "HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof Headers) {
-        String[] headersToParse = ((Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+    private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+
+    static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
+        RequestFactoryParser parser = new RequestFactoryParser(method);
+        parser.parseMethodAnnotations(responseType);
+        parser.parseParameters(retrofit);
+        return parser.toRequestFactory(retrofit.baseUrl());
     }
 
-    if (httpMethod == null) {
-      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-    if (!hasBody) {
-      if (isMultipart) {
-        throw methodError(method,
-            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-      }
-      if (isFormEncoded) {
-        throw methodError(method,
-            "FormUrlEncoded can only be specified on HTTP methods with request body "
-                + "(e.g., @POST).");
-      }
-    }
-  }
+    private final Method method;
+
+    private String httpMethod;
+    private boolean hasBody;
+    private boolean isFormEncoded;
+    private boolean isMultipart;
+    private String relativeUrl;
+    private com.squareup.okhttp.Headers headers;
+    private MediaType contentType;
+    private RequestBuilderAction[] requestBuilderActions;
 
-  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-    if (this.httpMethod != null) {
-      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-          this.httpMethod, httpMethod);
+    private Set<String> relativeUrlParamNames;
+
+    private RequestFactoryParser(Method method) {
+        this.method = method;
     }
-    this.httpMethod = httpMethod;
-    this.hasBody = hasBody;
 
-    if (value.isEmpty()) {
-      return;
+    private RequestFactory toRequestFactory(BaseUrl baseUrl) {
+        return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
+                isFormEncoded, isMultipart, requestBuilderActions);
     }
 
-    // Get the relative URL path and existing query string, if present.
-    int question = value.indexOf('?');
-    if (question != -1 && question < value.length() - 1) {
-      // Ensure the query string does not have any named parameters.
-      String queryParams = value.substring(question + 1);
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-      if (queryParamMatcher.find()) {
-        throw methodError(method, "URL query string \"%s\" must not have replace block. "
-            + "For dynamic query parameters use @Query.", queryParams);
-      }
+    private RuntimeException parameterError(Throwable cause, int index, String message,
+                                            Object... args) {
+        return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
     }
 
-    this.relativeUrl = value;
-    this.relativeUrlParamNames = parsePathParameters(value);
-  }
-
-  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError(method,
-            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-      }
-      String headerName = header.substring(0, colon);
-      String headerValue = header.substring(colon + 1).trim();
-      if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentType = MediaType.parse(headerValue);
-      } else {
-        builder.add(headerName, headerValue);
-      }
+    private RuntimeException parameterError(int index, String message, Object... args) {
+        return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
     }
-    return builder.build();
-  }
-
-  private void parseParameters(Retrofit retrofit) {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-    boolean gotPath = false;
-    boolean gotQuery = false;
-    boolean gotUrl = false;
-
-    int count = methodParameterAnnotationArrays.length;
-    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
-    for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          RequestBuilderAction action = null;
-          if (methodParameterAnnotation instanceof Url) {
-            if (gotUrl) {
-              throw parameterError(i, "Multiple @Url method annotations found.");
-            }
-            if (gotPath) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
-            }
-            if (gotQuery) {
-              throw parameterError(i, "A @Url parameter must not come after a @Query");
-            }
-            if (methodParameterType != String.class) {
-              throw parameterError(i, "@Url must be String type.");
-            }
-            if (relativeUrl != null) {
-              throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
-            }
-            gotUrl = true;
-            action = new RequestBuilderAction.Url();
 
-          } else if (methodParameterAnnotation instanceof Path) {
-            if (gotQuery) {
-              throw parameterError(i, "A @Path parameter must not come after a @Query.");
+    private void parseMethodAnnotations(Type responseType) {
+        for (Annotation annotation : method.getAnnotations()) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            } else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            } else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+                if (!Void.class.equals(responseType)) {
+                    throw methodError(method, "HEAD method must use Void as response type.");
+                }
+            } else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            } else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            } else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            } else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            } else if (annotation instanceof Headers) {
+                String[] headersToParse = ((Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError(method, "@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            } else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            } else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError(method, "Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
             }
-            if (gotUrl) {
-              throw parameterError(i, "@Path parameters may not be used with @Url.");
+        }
+
+        if (httpMethod == null) {
+            throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+        }
+        if (!hasBody) {
+            if (isMultipart) {
+                throw methodError(method,
+                        "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
             }
-            if (relativeUrl == null) {
-              throw parameterError(i, "@Path can only be used with relative url on @%s",
-                  httpMethod);
+            if (isFormEncoded) {
+                throw methodError(method,
+                        "FormUrlEncoded can only be specified on HTTP methods with request body "
+                                + "(e.g., @POST).");
             }
-            gotPath = true;
+        }
+    }
 
-            Path path = (Path) methodParameterAnnotation;
-            String name = path.value();
-            validatePathName(i, name);
-            action = new RequestBuilderAction.Path(name, path.encoded());
+    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+        if (this.httpMethod != null) {
+            throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+                    this.httpMethod, httpMethod);
+        }
+        this.httpMethod = httpMethod;
+        this.hasBody = hasBody;
 
-          } else if (methodParameterAnnotation instanceof Query) {
-            Query query = (Query) methodParameterAnnotation;
-            action = new RequestBuilderAction.Query(query.value(), query.encoded());
-            gotQuery = true;
+        if (value.isEmpty()) {
+            return;
+        }
 
-          } else if (methodParameterAnnotation instanceof QueryMap) {
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
+        // Get the relative URL path and existing query string, if present.
+        int question = value.indexOf('?');
+        if (question != -1 && question < value.length() - 1) {
+            // Ensure the query string does not have any named parameters.
+            String queryParams = value.substring(question + 1);
+            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+            if (queryParamMatcher.find()) {
+                throw methodError(method, "URL query string \"%s\" must not have replace block. "
+                        + "For dynamic query parameters use @Query.", queryParams);
             }
-            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.QueryMap(queryMap.encoded());
-
-          } else if (methodParameterAnnotation instanceof Header) {
-            Header header = (Header) methodParameterAnnotation;
-            action = new RequestBuilderAction.Header(header.value());
+        }
 
-          } else if (methodParameterAnnotation instanceof Field) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
-            }
-            Field field = (Field) methodParameterAnnotation;
-            action = new RequestBuilderAction.Field(field.value(), field.encoded());
-            gotField = true;
+        this.relativeUrl = value;
+        this.relativeUrlParamNames = parsePathParameters(value);
+    }
 
-          } else if (methodParameterAnnotation instanceof FieldMap) {
-            if (!isFormEncoded) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+    private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+        com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
+        for (String header : headers) {
+            int colon = header.indexOf(':');
+            if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                throw methodError(method,
+                        "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
             }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
+            String headerName = header.substring(0, colon);
+            String headerValue = header.substring(colon + 1).trim();
+            if ("Content-Type".equalsIgnoreCase(headerName)) {
+                contentType = MediaType.parse(headerValue);
+            } else {
+                builder.add(headerName, headerValue);
             }
-            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.FieldMap(fieldMap.encoded());
-            gotField = true;
+        }
+        return builder.build();
+    }
 
-          } else if (methodParameterAnnotation instanceof Part) {
-            if (!isMultipart) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+    private void parseParameters(Retrofit retrofit) {
+        Type[] methodParameterTypes = method.getGenericParameterTypes();
+        Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+
+        boolean gotField = false;
+        boolean gotPart = false;
+        boolean gotBody = false;
+        boolean gotPath = false;
+        boolean gotQuery = false;
+        boolean gotUrl = false;
+
+        int count = methodParameterAnnotationArrays.length;
+        RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
+        for (int i = 0; i < count; i++) {
+            Type methodParameterType = methodParameterTypes[i];
+            Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
+            if (methodParameterAnnotations != null) {
+                for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+                    RequestBuilderAction action = null;
+                    if (methodParameterAnnotation instanceof Url) {
+                        if (gotUrl) {
+                            throw parameterError(i, "Multiple @Url method annotations found.");
+                        }
+                        if (gotPath) {
+                            throw parameterError(i, "@Path parameters may not be used with @Url.");
+                        }
+                        if (gotQuery) {
+                            throw parameterError(i, "A @Url parameter must not come after a @Query");
+                        }
+                        if (methodParameterType != String.class) {
+                            throw parameterError(i, "@Url must be String type.");
+                        }
+                        if (relativeUrl != null) {
+                            throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
+                        }
+                        gotUrl = true;
+                        action = new RequestBuilderAction.Url();
+
+                    } else if (methodParameterAnnotation instanceof Path) {
+                        if (gotQuery) {
+                            throw parameterError(i, "A @Path parameter must not come after a @Query.");
+                        }
+                        if (gotUrl) {
+                            throw parameterError(i, "@Path parameters may not be used with @Url.");
+                        }
+                        if (relativeUrl == null) {
+                            throw parameterError(i, "@Path can only be used with relative url on @%s",
+                                    httpMethod);
+                        }
+                        gotPath = true;
+
+                        Path path = (Path) methodParameterAnnotation;
+                        String name = path.value();
+                        validatePathName(i, name);
+                        action = new RequestBuilderAction.Path(name, path.encoded());
+
+                    } else if (methodParameterAnnotation instanceof Query) {
+                        Query query = (Query) methodParameterAnnotation;
+                        action = new RequestBuilderAction.Query(query.value(), query.encoded());
+                        gotQuery = true;
+
+                    } else if (methodParameterAnnotation instanceof QueryMap) {
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@QueryMap parameter type must be Map.");
+                        }
+                        QueryMap queryMap = (QueryMap) methodParameterAnnotation;
+                        action = new RequestBuilderAction.QueryMap(queryMap.encoded());
+
+                    } else if (methodParameterAnnotation instanceof Header) {
+                        Header header = (Header) methodParameterAnnotation;
+                        action = new RequestBuilderAction.Header(header.value());
+
+                    } else if (methodParameterAnnotation instanceof Field) {
+                        if (!isFormEncoded) {
+                            throw parameterError(i, "@Field parameters can only be used with form encoding.");
+                        }
+                        Field field = (Field) methodParameterAnnotation;
+                        action = new RequestBuilderAction.Field(field.value(), field.encoded());
+                        gotField = true;
+
+                    } else if (methodParameterAnnotation instanceof FieldMap) {
+                        if (!isFormEncoded) {
+                            throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+                        }
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@FieldMap parameter type must be Map.");
+                        }
+                        FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
+                        action = new RequestBuilderAction.FieldMap(fieldMap.encoded());
+                        gotField = true;
+
+                    } else if (methodParameterAnnotation instanceof Part) {
+                        if (!isMultipart) {
+                            throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+                        }
+                        Part part = (Part) methodParameterAnnotation;
+                        com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
+                                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
+                                "Content-Transfer-Encoding", part.encoding());
+                        Converter<?, RequestBody> converter;
+                        try {
+                            converter =
+                                    retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
+                        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                            throw parameterError(e, i, "Unable to create @Part converter for %s",
+                                    methodParameterType);
+                        }
+                        action = new RequestBuilderAction.Part<>(headers, converter);
+                        gotPart = true;
+
+                    } else if (methodParameterAnnotation instanceof PartMap) {
+                        if (!isMultipart) {
+                            throw parameterError(i,
+                                    "@PartMap parameters can only be used with multipart encoding.");
+                        }
+                        if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+                            throw parameterError(i, "@PartMap parameter type must be Map.");
+                        }
+                        PartMap partMap = (PartMap) methodParameterAnnotation;
+                        action = new RequestBuilderAction.PartMap(retrofit, partMap.encoding(),
+                                methodParameterAnnotations);
+                        gotPart = true;
+
+                    } else if (methodParameterAnnotation instanceof Body) {
+                        if (isFormEncoded || isMultipart) {
+                            throw parameterError(i,
+                                    "@Body parameters cannot be used with form or multi-part encoding.");
+                        }
+                        if (gotBody) {
+                            throw parameterError(i, "Multiple @Body method annotations found.");
+                        }
+
+                        Converter<?, RequestBody> converter;
+                        try {
+                            converter =
+                                    retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
+                        } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                            throw parameterError(e, i, "Unable to create @Body converter for %s",
+                                    methodParameterType);
+                        }
+                        action = new RequestBuilderAction.Body<>(converter);
+                        gotBody = true;
+                    }
+
+                    if (action != null) {
+                        if (requestBuilderActions[i] != null) {
+                            throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
+                        }
+                        requestBuilderActions[i] = action;
+                    }
+                }
             }
-            Part part = (Part) methodParameterAnnotation;
-            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "form-data; name=\"" + part.value() + "\"",
-                "Content-Transfer-Encoding", part.encoding());
-            Converter<?, RequestBody> converter;
-            try {
-              converter =
-                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
-            } catch (RuntimeException e) { // Wide exception range because factories are user code.
-              throw parameterError(e, i, "Unable to create @Part converter for %s",
-                  methodParameterType);
-            }
-            action = new RequestBuilderAction.Part<>(headers, converter);
-            gotPart = true;
 
-          } else if (methodParameterAnnotation instanceof PartMap) {
-            if (!isMultipart) {
-              throw parameterError(i,
-                  "@PartMap parameters can only be used with multipart encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
-            }
-            PartMap partMap = (PartMap) methodParameterAnnotation;
-            action = new RequestBuilderAction.PartMap(retrofit, partMap.encoding(),
-                methodParameterAnnotations);
-            gotPart = true;
-
-          } else if (methodParameterAnnotation instanceof Body) {
-            if (isFormEncoded || isMultipart) {
-              throw parameterError(i,
-                  "@Body parameters cannot be used with form or multi-part encoding.");
-            }
-            if (gotBody) {
-              throw parameterError(i, "Multiple @Body method annotations found.");
+            if (requestBuilderActions[i] == null) {
+                throw parameterError(i, "No Retrofit annotation found.");
             }
+        }
 
-            Converter<?, RequestBody> converter;
-            try {
-              converter =
-                  retrofit.requestConverter(methodParameterType, methodParameterAnnotations);
-            } catch (RuntimeException e) { // Wide exception range because factories are user code.
-              throw parameterError(e, i, "Unable to create @Body converter for %s",
-                  methodParameterType);
-            }
-            action = new RequestBuilderAction.Body<>(converter);
-            gotBody = true;
-          }
-
-          if (action != null) {
-            if (requestBuilderActions[i] != null) {
-              throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
-            }
-            requestBuilderActions[i] = action;
-          }
+        if (relativeUrl == null && !gotUrl) {
+            throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+        }
+        if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+            throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+        }
+        if (isFormEncoded && !gotField) {
+            throw methodError(method, "Form-encoded method must contain at least one @Field.");
+        }
+        if (isMultipart && !gotPart) {
+            throw methodError(method, "Multipart method must contain at least one @Part.");
         }
-      }
 
-      if (requestBuilderActions[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
-      }
+        this.requestBuilderActions = requestBuilderActions;
     }
 
-    if (relativeUrl == null && !gotUrl) {
-      throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
-    }
-    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
-    }
-    if (isFormEncoded && !gotField) {
-      throw methodError(method, "Form-encoded method must contain at least one @Field.");
-    }
-    if (isMultipart && !gotPart) {
-      throw methodError(method, "Multipart method must contain at least one @Part.");
+    private void validatePathName(int index, String name) {
+        if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+            throw parameterError(index, "@Path parameter name must match %s. Found: %s",
+                    PARAM_URL_REGEX.pattern(), name);
+        }
+        // Verify URL replacement name is actually present in the URL path.
+        if (!relativeUrlParamNames.contains(name)) {
+            throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+        }
     }
 
-    this.requestBuilderActions = requestBuilderActions;
-  }
-
-  private void validatePathName(int index, String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
-          PARAM_URL_REGEX.pattern(), name);
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!relativeUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
     }
-    return patterns;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index f653ca5d1..5a730b017 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
@@ -26,85 +14,97 @@
  * TODO
  */
 public final class Response<T> {
-  /**
-   * TODO
-   */
-  public static <T> Response<T> success(T body) {
-    return success(body, new com.squareup.okhttp.Response.Builder() //
-        .code(200)
-        .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
-            .build())
-        .build());
-  }
+    /**
+     * TODO
+     */
+    public static <T> Response<T> success(T body) {
+        return success(body, new com.squareup.okhttp.Response.Builder() //
+                .code(200)
+                .protocol(Protocol.HTTP_1_1)
+                .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+                        .build())
+                .build());
+    }
 
-  /**
-   * TODO
-   */
-  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
-    return new Response<>(rawResponse, body, null);
-  }
+    /**
+     * TODO
+     */
+    public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
+        return new Response<>(rawResponse, body, null);
+    }
 
-  /**
-   * TODO
-   */
-  public static <T> Response<T> error(int code, ResponseBody body) {
-    return error(body, new com.squareup.okhttp.Response.Builder() //
-        .code(code)
-        .protocol(Protocol.HTTP_1_1)
-        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
-            .build())
-        .build());
-  }
+    /**
+     * TODO
+     */
+    public static <T> Response<T> error(int code, ResponseBody body) {
+        return error(body, new com.squareup.okhttp.Response.Builder() //
+                .code(code)
+                .protocol(Protocol.HTTP_1_1)
+                .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+                        .build())
+                .build());
+    }
 
-  /**
-   * TODO
-   */
-  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
-    return new Response<>(rawResponse, null, body);
-  }
+    /**
+     * TODO
+     */
+    public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+        return new Response<>(rawResponse, null, body);
+    }
 
-  private final com.squareup.okhttp.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
+    private final com.squareup.okhttp.Response rawResponse;
+    private final T body;
+    private final ResponseBody errorBody;
 
-  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
-    this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
-    this.body = body;
-    this.errorBody = errorBody;
-  }
+    private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+        this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
+        this.body = body;
+        this.errorBody = errorBody;
+    }
 
-  /** The raw response from the HTTP client. */
-  public com.squareup.okhttp.Response raw() {
-    return rawResponse;
-  }
+    /**
+     * The raw response from the HTTP client.
+     */
+    public com.squareup.okhttp.Response raw() {
+        return rawResponse;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return rawResponse.code();
-  }
+    /**
+     * HTTP status code.
+     */
+    public int code() {
+        return rawResponse.code();
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return rawResponse.message();
-  }
+    /**
+     * HTTP status message.
+     */
+    public String message() {
+        return rawResponse.message();
+    }
 
-  public Headers headers() {
-    return rawResponse.headers();
-  }
+    public Headers headers() {
+        return rawResponse.headers();
+    }
 
-  /** {@code true} if {@link #code()} is in the range [200..300). */
-  public boolean isSuccess() {
-    return rawResponse.isSuccessful();
-  }
+    /**
+     * {@code true} if {@link #code()} is in the range [200..300).
+     */
+    public boolean isSuccess() {
+        return rawResponse.isSuccessful();
+    }
 
-  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
-  public T body() {
-    return body;
-  }
+    /**
+     * The deserialized response body of a {@linkplain #isSuccess() successful} response.
+     */
+    public T body() {
+        return body;
+    }
 
-  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
-  public ResponseBody errorBody() {
-    return errorBody;
-  }
+    /**
+     * The raw response body of an {@linkplain #isSuccess() unsuccessful} response.
+     */
+    public ResponseBody errorBody() {
+        return errorBody;
+    }
 }
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index f6355ce89..136712034 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
@@ -19,6 +7,7 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -30,32 +19,30 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Executor;
-import retrofit.http.HTTP;
-import retrofit.http.Header;
 
 import static retrofit.Utils.checkNotNull;
 
 /**
  * Adapts a Java interface to a REST API.
- * <p>
+ * <p/>
  * API endpoints are defined as methods on an interface with annotations providing metadata about
  * the form in which the HTTP call should be made.
- * <p>
+ * <p/>
  * The relative path for a given method is obtained from an annotation on the method describing
  * the request type. The built-in methods are {@link retrofit.http.GET GET},
  * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.PATCH
  * PATCH}, {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a
  * custom HTTP method with {@link HTTP @HTTP}.
- * <p>
+ * <p/>
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
  * {@link retrofit.http.Query @Query}.
- * <p>
+ * <p/>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by one of the {@link Converter.Factory} instances.
  * A {@link RequestBody} can also be used for a raw representation.
- * <p>
+ * <p/>
  * Alternative request body formats are supported by method annotations and corresponding parameter
  * annotations:
  * <ul>
@@ -64,16 +51,16 @@
  * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with parts
  * specified by the {@link retrofit.http.Part @Part} parameter annotation.
  * </ul>
- * <p>
+ * <p/>
  * Additional static headers can be added for an endpoint using the
  * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
  * annotate a parameter with {@link Header @Header}.
- * <p>
+ * <p/>
  * By default, methods return a {@link Call} which represents the HTTP request. The generic
  * parameter of the call is the response body type and will be converted by one of the
  * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
  * representation. {@link Void} can be used if you do not care about the body contents.
- * <p>
+ * <p/>
  * For example:
  * <pre>
  * public interface CategoryService {
@@ -81,7 +68,7 @@
  *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
  * }
  * </pre>
- * <p>
+ * <p/>
  * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
  * annotations and create a new implementation of the service definition.
  *
@@ -89,291 +76,307 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
-
-  private final OkHttpClient client;
-  private final BaseUrl baseUrl;
-  private final List<Converter.Factory> converterFactories;
-  private final List<CallAdapter.Factory> adapterFactories;
-  private final Executor callbackExecutor;
-  private final boolean validateEagerly;
-
-  private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
-      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
-      boolean validateEagerly) {
-    this.client = client;
-    this.baseUrl = baseUrl;
-    this.converterFactories = converterFactories;
-    this.adapterFactories = adapterFactories;
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /** Create an implementation of the API defined by the {@code service} interface. */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-
-          @Override public Object invoke(Object proxy, Method method, Object... args)
-              throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
-            }
-            return loadMethodHandler(method).invoke(args);
-          }
-        });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
-        loadMethodHandler(method);
-      }
-    }
-  }
-
-  MethodHandler<?> loadMethodHandler(Method method) {
-    MethodHandler<?> handler;
-    synchronized (methodHandlerCache) {
-      handler = methodHandlerCache.get(method);
-      if (handler == null) {
-        handler = MethodHandler.create(this, method);
-        methodHandlerCache.put(method, handler);
-      }
-    }
-    return handler;
-  }
-
-  public OkHttpClient client() {
-    return client;
-  }
-
-  public BaseUrl baseUrl() {
-    return baseUrl;
-  }
-
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return Collections.unmodifiableList(adapterFactories);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   */
-  public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   */
-  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
+    private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
+
+    private final OkHttpClient client;
+    private final BaseUrl baseUrl;
+    private final List<Converter.Factory> converterFactories;
+    private final List<CallAdapter.Factory> adapterFactories;
+    private final Executor callbackExecutor;
+    private final boolean validateEagerly;
+
+    private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
+                     List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor,
+                     boolean validateEagerly) {
+        this.client = client;
+        this.baseUrl = baseUrl;
+        this.converterFactories = converterFactories;
+        this.adapterFactories = adapterFactories;
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(". Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
-    }
-    if (skipPast != null) {
-      builder.append("\nSkipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
-      }
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * TODO
-   */
-  public List<Converter.Factory> converterFactories() {
-    return Collections.unmodifiableList(converterFactories);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, RequestBody> requestConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, RequestBody> converter =
-          converterFactories.get(i).toRequestBody(type, annotations);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    /**
+     * Create an implementation of the API defined by the {@code service} interface.
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        Utils.validateServiceInterface(service);
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+                new InvocationHandler() {
+                    private final Platform platform = Platform.get();
+
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object... args)
+                            throws Throwable {
+                        // If the method is a method from Object then defer to normal invocation.
+                        if (method.getDeclaringClass() == Object.class) {
+                            return method.invoke(this, args);
+                        }
+                        if (platform.isDefaultMethod(method)) {
+                            return platform.invokeDefaultMethod(method, service, proxy, args);
+                        }
+                        return loadMethodHandler(method).invoke(args);
+                    }
+                });
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(". Tried:");
-    for (Converter.Factory converterFactory : converterFactories) {
-      builder.append("\n * ").append(converterFactory.getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<ResponseBody, T> responseConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).fromResponseBody(type, annotations);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        for (Method method : service.getDeclaredMethods()) {
+            if (!platform.isDefaultMethod(method)) {
+                loadMethodHandler(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(". Tried:");
-    for (Converter.Factory converterFactory : converterFactories) {
-      builder.append("\n * ").append(converterFactory.getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  public Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private OkHttpClient client;
-    private BaseUrl baseUrl;
-    private List<Converter.Factory> converterFactories = new ArrayList<>();
-    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    public Builder() {
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+    MethodHandler<?> loadMethodHandler(Method method) {
+        MethodHandler<?> handler;
+        synchronized (methodHandlerCache) {
+            handler = methodHandlerCache.get(method);
+            if (handler == null) {
+                handler = MethodHandler.create(this, method);
+                methodHandlerCache.put(method, handler);
+            }
+        }
+        return handler;
     }
 
-    /** The HTTP client used for requests. */
-    public Builder client(OkHttpClient client) {
-      this.client = checkNotNull(client, "client == null");
-      return this;
+    public OkHttpClient client() {
+        return client;
     }
 
-    /** API base URL. */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+    public BaseUrl baseUrl() {
+        return baseUrl;
     }
 
-    /** API base URL. */
-    public Builder baseUrl(final HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      return baseUrl(new BaseUrl() {
-        @Override public HttpUrl url() {
-          return baseUrl;
-        }
-      });
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return Collections.unmodifiableList(adapterFactories);
     }
 
-    /** API base URL. */
-    public Builder baseUrl(BaseUrl baseUrl) {
-      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
-      return this;
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     */
+    public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory converterFactory) {
-      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
-      return this;
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     */
+    public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+                                          Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = adapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(". Tried:");
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+        }
+        if (skipPast != null) {
+            builder.append("\nSkipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n * ").append(adapterFactories.get(i).getClass().getName());
+            }
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
      * TODO
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return Collections.unmodifiableList(converterFactories);
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder callbackExecutor(Executor callbackExecutor) {
-      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
-      return this;
+    public <T> Converter<T, RequestBody> requestConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, RequestBody> converter =
+                    converterFactories.get(i).toRequestBody(type, annotations);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(". Tried:");
+        for (Converter.Factory converterFactory : converterFactories) {
+            builder.append("\n * ").append(converterFactory.getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public <T> Converter<ResponseBody, T> responseConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).fromResponseBody(type, annotations);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(". Tried:");
+        for (Converter.Factory converterFactory : converterFactories) {
+            builder.append("\n * ").append(converterFactory.getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
+    }
+
+    public Executor callbackExecutor() {
+        return callbackExecutor;
     }
 
-    /** Create the {@link Retrofit} instances. */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
+    /**
+     * Build a new {@link Retrofit}.
+     * <p/>
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
+     */
+    public static final class Builder {
+        private OkHttpClient client;
+        private BaseUrl baseUrl;
+        private List<Converter.Factory> converterFactories = new ArrayList<>();
+        private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+        private Executor callbackExecutor;
+        private boolean validateEagerly;
+
+        public Builder() {
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+        }
+
+        /**
+         * The HTTP client used for requests.
+         */
+        public Builder client(OkHttpClient client) {
+            this.client = checkNotNull(client, "client == null");
+            return this;
+        }
+
+        /**
+         * API base URL.
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+            if (httpUrl == null) {
+                throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+            }
+            return baseUrl(httpUrl);
+        }
+
+        /**
+         * API base URL.
+         */
+        public Builder baseUrl(final HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            return baseUrl(new BaseUrl() {
+                @Override
+                public HttpUrl url() {
+                    return baseUrl;
+                }
+            });
+        }
+
+        /**
+         * API base URL.
+         */
+        public Builder baseUrl(BaseUrl baseUrl) {
+            this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
+            return this;
+        }
+
+        /**
+         * Add converter factory for serialization and deserialization of objects.
+         */
+        public Builder addConverterFactory(Converter.Factory converterFactory) {
+            converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
+            return this;
+        }
+
+        /**
+         * TODO
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            adapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         */
+        public Builder callbackExecutor(Executor callbackExecutor) {
+            this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
+            return this;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instances.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
 
-      OkHttpClient client = this.client;
-      if (client == null) {
-        client = new OkHttpClient();
-      }
+            OkHttpClient client = this.client;
+            if (client == null) {
+                client = new OkHttpClient();
+            }
 
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+            adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
 
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
 
-      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
-          validateEagerly);
+            return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
+                    validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index ee8912bbe..6db10bf7c 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -1,23 +1,11 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2007 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit;
 
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
@@ -29,6 +17,7 @@
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
+
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Source;
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 782559502..4ef8c76b0 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -1,25 +1,11 @@
 /*
- * Copyright (C) 2011 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Converter;
-import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -30,7 +16,7 @@
  * body). The object will be serialized using the {@link Retrofit Retrofit} instance
  * {@link Converter Converter} and the result will be set directly as the
  * request body.
- * <p>
+ * <p/>
  * Body parameters may not be {@code null}.
  *
  * @author Eric Denman (edenman@squareup.com)
diff --git a/retrofit/src/main/java/retrofit/http/CdnHeaders.java b/retrofit/src/main/java/retrofit/http/CdnHeaders.java
new file mode 100644
index 000000000..fe99b22bf
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/CdnHeaders.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
+ */
+
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Make a HEAD request to a REST path relative to base URL.
+ * <p/>
+ * Note: HEAD requests must use {@link Void} as the response type since there is no body content.
+ */
+@Documented
+@Target(TYPE)
+@Retention(RUNTIME)
+public @interface CdnHeaders {
+    String value() default "";
+}
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 1f7dbdc5b..21400a7a3 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
@@ -22,10 +10,12 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Make a DELETE request to a REST path relative to base URL. */
+/**
+ * Make a DELETE request to a REST path relative to base URL.
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  String value() default "";
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index bfe020ec0..fdfb2674f 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
@@ -24,11 +12,11 @@
 
 /**
  * Named pair for a form-encoded request.
- * <p>
+ * <p/>
  * Values are converted to strings using {@link String#valueOf(Object)} and then form URL encoded.
  * {@code null} values are ignored. Passing a {@link java.util.List List} or array will result in a
  * field pair for each non-{@code null} item.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre>
  * &#64;FormUrlEncoded
@@ -38,7 +26,7 @@
  * </pre>
  * Calling with {@code foo.example("Bob Smith", "President")} yields a request body of
  * {@code name=Bob+Smith&occupation=President}.
- * <p>
+ * <p/>
  * Array Example:
  * <pre>
  * &#64;FormUrlEncoded
@@ -55,8 +43,10 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Field {
-  String value();
+    String value();
 
-  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/FieldMap.java b/retrofit/src/main/java/retrofit/http/FieldMap.java
index 97c5684a2..2d8ede821 100644
--- a/retrofit/src/main/java/retrofit/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit/http/FieldMap.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
@@ -24,9 +12,9 @@
 
 /**
  * Named key/value pairs for a form-encoded request.
- * <p>
+ * <p/>
  * Field values may be {@code null} which will omit them from the request body.
- * <p>
+ * <p/>
  * Simple Example:
  * <pre>
  * &#64;FormUrlEncoded
@@ -44,6 +32,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether the names and values are already URL encoded. */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the names and values are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
index 74c34ea3b..c23d36e7b 100644
--- a/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
+++ b/retrofit/src/main/java/retrofit/http/FormUrlEncoded.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
@@ -25,7 +13,7 @@
 /**
  * Denotes that the request body will use form URL encoding. Fields should be declared as
  * parameters and annotated with {@link Field @Field}.
- * <p>
+ * <p/>
  * Requests made with this annotation will have {@code application/x-www-form-urlencoded} MIME
  * type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to
  * <a href="http://tools.ietf.org/html/rfc3986">RFC-3986</a>.
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index b2dd2a4cf..b308d2e19 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index ab7176d99..d6e4026a3 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/HTTP.java b/retrofit/src/main/java/retrofit/http/HTTP.java
index 5d54952ec..27873442c 100644
--- a/retrofit/src/main/java/retrofit/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
index 4ce2cf166..56e8920b1 100644
--- a/retrofit/src/main/java/retrofit/http/Header.java
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Headers.java b/retrofit/src/main/java/retrofit/http/Headers.java
index 36b9ff438..6976750fb 100644
--- a/retrofit/src/main/java/retrofit/http/Headers.java
+++ b/retrofit/src/main/java/retrofit/http/Headers.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Multipart.java b/retrofit/src/main/java/retrofit/http/Multipart.java
index 79467217e..68c4d76ed 100644
--- a/retrofit/src/main/java/retrofit/http/Multipart.java
+++ b/retrofit/src/main/java/retrofit/http/Multipart.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index 2788ee8f0..433e6e44f 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index 0d39b2d1a..03b74d676 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index 5c382e33d..6302c8650 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index b06cad953..0a9dc6634 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -1,31 +1,18 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Denotes a single part of a multi-part request.
- * <p>
+ * <p/>
  * The parameter type on which this annotation exists will be processed in one of two ways:
  * <ul>
  * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
@@ -33,9 +20,9 @@
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
- * <p>
+ * <p/>
  * Values may be {@code null} which will omit them from the request body.
- * <p>
+ * <p/>
  * <pre>
  * &#64;Multipart
  * &#64;POST("/")
@@ -43,14 +30,17 @@
  *     &#64;Part("description") String description,
  *     &#64;Part(value = "image", encoding = "8-bit") RequestBody image);
  * </pre>
- * <p>
+ * <p/>
  * Part parameters may not be {@code null}.
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  String value();
-  /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default "binary";
+    String value();
+
+    /**
+     * The {@code Content-Transfer-Encoding} of this part.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index a3026ce30..09fa6eafa 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -1,31 +1,18 @@
 /*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Denotes name and value parts of a multi-part request.
- * <p>
+ * <p/>
  * Values of the map on which this annotation exists will be processed in one of two ways:
  * <ul>
  * <li>If the type is {@link com.squareup.okhttp.RequestBody RequestBody} the value will be used
@@ -33,7 +20,7 @@
  * <li>Other object types will be converted to an appropriate representation by using
  * {@linkplain Converter a converter}.</li>
  * </ul>
- * <p>
+ * <p/>
  * <pre>
  * &#64;Multipart
  * &#64;POST("/upload")
@@ -49,6 +36,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of the parts. */
-  String encoding() default "binary";
+    /**
+     * The {@code Content-Transfer-Encoding} of the parts.
+     */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index 0a3afa4e8..259f18ba7 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index 8e53a9c6a..50a50e1bd 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/QueryMap.java b/retrofit/src/main/java/retrofit/http/QueryMap.java
index 6aaaab78f..ae45f592f 100644
--- a/retrofit/src/main/java/retrofit/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit/http/QueryMap.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Streaming.java b/retrofit/src/main/java/retrofit/http/Streaming.java
index 28cd9b794..1a95532b1 100644
--- a/retrofit/src/main/java/retrofit/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit/http/Streaming.java
@@ -1,17 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
diff --git a/retrofit/src/main/java/retrofit/http/Url.java b/retrofit/src/main/java/retrofit/http/Url.java
index b953a3060..33642233e 100644
--- a/retrofit/src/main/java/retrofit/http/Url.java
+++ b/retrofit/src/main/java/retrofit/http/Url.java
@@ -1,24 +1,11 @@
 /*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
  */
 package retrofit.http;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
-import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
diff --git a/retrofit/src/main/java/retrofit/http/package-info.java b/retrofit/src/main/java/retrofit/http/package-info.java
index 2dae09c79..e14ce1794 100644
--- a/retrofit/src/main/java/retrofit/http/package-info.java
+++ b/retrofit/src/main/java/retrofit/http/package-info.java
@@ -1,4 +1,6 @@
-// Copyright 2014 Square, Inc.
+/*
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
+ */
 
 /** Annotations for interface methods to control the HTTP request behavior. */
 package retrofit.http;
diff --git a/retrofit/src/main/java/retrofit/package-info.java b/retrofit/src/main/java/retrofit/package-info.java
index 0c6596b3e..09ff14f96 100644
--- a/retrofit/src/main/java/retrofit/package-info.java
+++ b/retrofit/src/main/java/retrofit/package-info.java
@@ -1,4 +1,6 @@
-// Copyright 2014 Square, Inc.
+/*
+ * Copyright (c) &amp;#36;today.year, House365. All rights reserved.
+ */
 
 /**
  * Retrofit turns your REST API into a Java interface.
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index 21765b13f..ae97b7c48 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -22,7 +22,6 @@
 import java.lang.annotation.Annotation;
 import retrofit.Call;
 import retrofit.Converter;
-import retrofit.GsonConverterFactory;
 import retrofit.Response;
 import retrofit.Retrofit;
 import retrofit.http.GET;
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index 1fe28dc2a..c521eb3f3 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.util.List;
 import retrofit.Call;
-import retrofit.GsonConverterFactory;
 import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
