diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 000000000..fd12a9838
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/retrofit"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 000000000..91f444b22
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.travis.yml b/.travis.yml
index 3ba5e9a65..e6a844e22 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,8 +1,26 @@
 language: java
 
+jdk:
+  - oraclejdk7
+  - oraclejdk8
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "M0bjPTMwinz0uXN6qjXcpyfvhz/YX9W7ty4RdV90jMU8ZJxSdGdKXRy1N0TsMO8ciOQ2fryE/FpiX+arrphnVvqUmGBh386lGvj1rhgrVqXNqlGE23cQpzHsQ0nNqTGIxnoE4dmJF3PjWoYG+B4WbFsSb3PB7sEjpLq7klqGeHk="
+    - secure: "iL5BdYAmMaEDRKxNx1d9Zxn0tfJhCzXBGUvn+p7QGeQDUSVCdCc8cXS4ePbRj0401pK20nK1OouIi0lLP+z0QpZY6RrKIEncGOZeSFPQbS/vnZ7niCYJQdXCZ/GOlYUkAW2AsQl5bzzHYbHKX/TVgTuO3iFlbyeoZZuIjD3VaiM="
+
 branches:
   except:
     - gh-pages
 
 notifications:
   email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e71406cf7..80c420272 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,62 @@
 Change Log
 ==========
 
+Version 1.9.0 *(2015-01-07)*
+----------------------------
+
+ * Update to OkHttp 2.x's native API. If you are using OkHttp you must use version 2.0 or newer (the latest
+   is 2.2 at time of writing) and you no longer need to use the `okhttp-urlconnection` shim.
+ * New: Allow disabling Simple XML Framework's strict parsing.
+ * New: `@Header` now accepts a `List` or array for a type.
+ * New: `@Field` and `@FieldMap` now have options for enabling or disabling URL encoding of names and values.
+ * Fix: Remove query parameters from thread name when running background requests for asynchronous use.
+
+
+Version 1.8.0 *(2014-11-18)*
+----------------------------
+
+ * Update to RxJava 1.0. This comes with the project's 'groupId' change from `com.netflix.rxjava` to
+   `io.reactivex` which is why the minor version was bumped.
+
+
+Version 1.7.1 *(2014-10-23)*
+----------------------------
+
+ * Fix: Correctly log `null` request arguments for `HEADERS_AND_ARGS` log level.
+
+
+Version 1.7.0 *(2014-10-08)*
+----------------------------
+
+ * New: `RetrofitError`'s `getKind()` now disambiguates the type of error represented.
+ * New: `HEADERS_AND_ARGS` log level displays parameters passed to method invocation along with normal
+   header list.
+ * New: `@Part` and `@PartMap` now support specifying the `Content-Transfer-Encoding` of their respective
+   values.
+ * New: `@Path`, `@Query`, and `@QueryMap` now have options for enabling or disabling URL encoding on
+   names (where appropriate) and values.
+ * `@Header` now accepts all object types, invoking `String.valueOf` when neccesary.
+ * Attempting to use a `@Path` replacement block (`{name}`) in a query parameter now suggested `@Query` in
+   the exception message.
+ * Fix: Correct NPE when `Content-Type` override is specified on requests without a body.
+ * Fix: `WireConverter` now correctly throws `ConversionException` on incorrect MIME types for parity with
+   `ProtoConverter`.
+ * Fix: Include `Content-Type` on AppEngine requests.
+ * Fix: Account for NPE on AppEngine when the response URL was not automatically populated in certain cases.
+ * Fix: `MockRestAdapter`'s RxJava support now correctly schedules work on the HTTP executor, specifically
+   when chaining multiple requests together.
+ * Experimental RxJava support updated for v0.20.
+
+
+Version 1.6.1 *(2014-07-02)*
+----------------------------
+
+ * Fix: Add any explicitly-specified 'Content-Type' header (via annotation or param) to the request even
+   if there is no request body (e.g., DELETE).
+ * Fix: Include trailing CRLF in multi-part uploads to work around a bug in .NET MVC 4 parsing.
+ * Fix: Allow `null` mock exception bodies and use the success type from the declared service interface.
+
+
 Version 1.6.0 *(2014-06-06)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 21f30f4de..c101a0078 100644
--- a/README.md
+++ b/README.md
@@ -14,14 +14,18 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>1.6.0</version>
+  <version>1.9.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:1.6.0'
+compile 'com.squareup.retrofit:retrofit:1.9.0'
 ```
 
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
+Retrofit requires at minimum Java 6 or Android 2.3.
+
 
 
 License
@@ -43,4 +47,5 @@ License
 
 
  [1]: http://square.github.io/retrofit/
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [2]: https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index 4727a6aeb..693c0db7f 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -43,7 +43,9 @@
         <module name="AvoidStarImport"/>
         <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
         <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
+        <module name="UnusedImports">
+          <property name="processJavadoc" value="true"/>
+        </module>
 
 
         <!-- Checks for Size Violations.                    -->
diff --git a/deploy_website.sh b/deploy_website.sh
index 3d007cd5b..134675d3a 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -27,7 +27,7 @@ rm -rf *
 cp -R ../website/* .
 
 # Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
 mkdir javadoc
 unzip javadoc.zip -d javadoc
 rm javadoc.zip
diff --git a/pom.xml b/pom.xml
index f2650ecdb..5f43662a0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>parent</artifactId>
-  <version>1.6.1-SNAPSHOT</version>
+  <version>2.0.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -36,7 +36,7 @@
     <module>retrofit</module>
     <module>retrofit-converters</module>
     <module>retrofit-mock</module>
-    <module>retrofit-samples</module>
+    <module>samples</module>
   </modules>
 
   <properties>
@@ -49,22 +49,21 @@
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.2.4</gson.version>
-    <okhttp.version>1.6.0</okhttp.version>
-    <rxjava.version>0.19.0</rxjava.version>
-    <appengine.version>1.8.9</appengine.version>
+    <gson.version>2.3.1</gson.version>
+    <okhttp.version>2.2.0</okhttp.version>
+    <rxjava.version>1.0.0</rxjava.version>
 
     <!-- Converter Dependencies -->
     <protobuf.version>2.5.0</protobuf.version>
-    <jackson.version>2.3.1</jackson.version>
-    <wire.version>1.2.0</wire.version>
+    <jackson.version>2.4.3</jackson.version>
+    <wire.version>1.5.2</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
-    <assertj.version>1.5.0</assertj.version>
+    <junit.version>4.11</junit.version>
+    <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>16.0</guava.version>
+    <guava.version>18.0</guava.version>
   </properties>
 
   <scm>
@@ -103,26 +102,16 @@
         <artifactId>okhttp</artifactId>
         <version>${okhttp.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp</groupId>
-        <artifactId>okhttp-urlconnection</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.code.gson</groupId>
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
       <dependency>
-        <groupId>com.netflix.rxjava</groupId>
-        <artifactId>rxjava-core</artifactId>
+        <groupId>io.reactivex</groupId>
+        <artifactId>rxjava</artifactId>
         <version>${rxjava.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.appengine</groupId>
-        <artifactId>appengine-api-1.0-sdk</artifactId>
-        <version>${appengine.version}</version>
-      </dependency>
 
       <dependency>
         <groupId>com.google.protobuf</groupId>
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 0bcf44657..06c5a2992 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
index d481128b5..1b41a536e 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
@@ -1,16 +1,14 @@
 package retrofit.converter;
 
-import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
+import java.io.InputStream;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * A {@link Converter} which uses Jackson for reading and writing entities.
@@ -18,7 +16,7 @@
  * @author Kai Waldron (kaiwaldron@gmail.com)
  */
 public class JacksonConverter implements Converter {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final ObjectMapper objectMapper;
 
@@ -27,30 +25,30 @@ public JacksonConverter() {
   }
 
   public JacksonConverter(ObjectMapper objectMapper) {
+    if (objectMapper == null) throw new NullPointerException("objectMapper == null");
     this.objectMapper = objectMapper;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
       JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(body.in(), javaType);
-    } catch (JsonParseException e) {
-      throw new ConversionException(e);
-    } catch (JsonMappingException e) {
-      throw new ConversionException(e);
-    } catch (IOException e) {
-      throw new ConversionException(e);
+      return objectMapper.readValue(is, javaType);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
+  @Override public RequestBody toBody(Object object, Type type) {
     try {
-      String json = objectMapper.writeValueAsString(object);
-      return new TypedByteArray(MIME_TYPE, json.getBytes("UTF-8"));
+      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
+      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
+      return RequestBody.create(MEDIA_TYPE, json);
     } catch (JsonProcessingException e) {
-      throw new AssertionError(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+      throw new RuntimeException(e);
     }
   }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
index 3396ccf01..4114ba075 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
@@ -1,49 +1,57 @@
 package retrofit.converter;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
-import java.io.ByteArrayOutputStream;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterTest {
-  private static final String MIME_TYPE = "application/json; charset=UTF-8";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final MyObject OBJECT = new MyObject("hello world", 10);
   private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
 
   private final JacksonConverter converter = new JacksonConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput typedOutput = converter.toBody(OBJECT);
-    assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-    assertThat(asString(typedOutput)).isEqualTo(JSON);
+    RequestBody body = converter.toBody(OBJECT, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(JSON);
   }
 
   @Test public void deserialize() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());
-    MyObject result = (MyObject) converter.fromBody(input, MyObject.class);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
     assertThat(result).isEqualTo(OBJECT);
   }
 
-  @Test(expected = ConversionException.class)
-  public void deserializeWrongValue() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, "{\"foo\":\"bar\"}".getBytes());
-    converter.fromBody(input, MyObject.class);
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
+    try {
+      converter.fromBody(body, MyObject.class);
+    } catch (UnrecognizedPropertyException ignored) {
+    }
   }
 
-  @Test(expected = ConversionException.class)
-  public void deserializeWrongClass() throws Exception {
-    TypedInput input = new TypedByteArray(MIME_TYPE, JSON.getBytes());
-    converter.fromBody(input, String.class);
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    try {
+      converter.fromBody(body, String.class);
+    } catch (JsonMappingException ignored) {
+    }
   }
 
-  private String asString(TypedOutput typedOutput) throws Exception {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    typedOutput.writeTo(bytes);
-    return new String(bytes.toByteArray());
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 
   static class MyObject {
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 1c540cb80..9fa974fc9 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 419a3271b..d2808b7ea 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
index f4c0b6778..b9270c44e 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
@@ -2,20 +2,20 @@
 package retrofit.converter;
 
 import com.google.protobuf.AbstractMessageLite;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers. */
 public class ProtoConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -24,32 +24,31 @@
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     }
 
-    String mimeType = body.mimeType();
-    if (!MIME_TYPE.equals(mimeType)) {
-      throw new ConversionException("Response content type was not a proto: " + mimeType);
-    }
-
+    InputStream is = body.byteStream();
     try {
       Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, body.in());
+      return parseFrom.invoke(null, is);
     } catch (InvocationTargetException e) {
-      throw new ConversionException(c.getName() + ".parseFrom() failed", e.getCause());
+      throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     } catch (IllegalAccessException e) {
       throw new AssertionError();
-    } catch (IOException e) {
-      throw new ConversionException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof AbstractMessageLite)) {
       throw new IllegalArgumentException(
           "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
index 90cc78a67..99bcc58f5 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
@@ -1,15 +1,16 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
 import com.google.protobuf.InvalidProtocolBufferException;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -19,22 +20,22 @@
   private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
   private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
 
-  private final ProtoConverter protoConverter = new ProtoConverter();
+  private final ProtoConverter converter = new ProtoConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = protoConverter.toBody(PROTO);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(ENCODED_PROTO)));
+    RequestBody body = converter.toBody(PROTO, Phone.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = protoConverter.fromBody(decodeBase64(ENCODED_PROTO), Phone.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
@@ -43,7 +44,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
+      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
@@ -52,33 +53,21 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64("////"), Phone.class);
+      converter.fromBody(protoResponse("////"), Phone.class);
       fail();
-    } catch (ConversionException expected) {
+    } catch (RuntimeException expected) {
       assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
     }
   }
 
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      protoConverter.fromBody(decodeBase64("////", "yummy/bytes"), Phone.class);
-      fail();
-    } catch (ConversionException e) {
-      assertThat(e).hasMessage("Response content type was not a proto: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
+        encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index a8165625b..4a83d0a78 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
index 359ab0adb..4d757a555 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
@@ -1,16 +1,15 @@
 package retrofit.converter;
 
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStreamWriter;
 import java.lang.reflect.Type;
-
-import org.simpleframework.xml.core.Persister;
+import okio.Buffer;
 import org.simpleframework.xml.Serializer;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import org.simpleframework.xml.core.Persister;
 
 /**
  * A {@link Converter} which uses SimpleXML for reading and writing entities.
@@ -18,46 +17,63 @@
  * @author Fabien Ric (fabien.ric@gmail.com)
  */
 public class SimpleXMLConverter implements Converter {
+  private static final boolean DEFAULT_STRICT = true;
   private static final String CHARSET = "UTF-8";
-  private static final String MIME_TYPE = "application/xml; charset=" + CHARSET;
+  private static final MediaType MEDIA_TYPE =
+      MediaType.parse("application/xml; charset=" + CHARSET);
 
   private final Serializer serializer;
 
+  private final boolean strict;
+
   public SimpleXMLConverter() {
-    this(new Persister());
+    this(DEFAULT_STRICT);
+  }
+
+  public SimpleXMLConverter(boolean strict) {
+    this(new Persister(), strict);
   }
 
   public SimpleXMLConverter(Serializer serializer) {
+    this(serializer, DEFAULT_STRICT);
+  }
+
+  public SimpleXMLConverter(Serializer serializer, boolean strict) {
     this.serializer = serializer;
+    this.strict = strict;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
-      return serializer.read((Class<?>) type, body.in());
+      return serializer.read((Class<?>) type, is, strict);
+    } catch (IOException e) {
+      throw e;
     } catch (Exception e) {
-      throw new ConversionException(e);
+      throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object source) {
-    OutputStreamWriter osw = null;
-
+  @Override public RequestBody toBody(Object source, Type type) {
+    byte[] bytes;
     try {
-      ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      osw = new OutputStreamWriter(bos, CHARSET);
+      Buffer buffer = new Buffer();
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
       serializer.write(source, osw);
       osw.flush();
-      return new TypedByteArray(MIME_TYPE, bos.toByteArray());
+      bytes = buffer.readByteArray();
     } catch (Exception e) {
       throw new AssertionError(e);
-    } finally {
-      try {
-        if (osw != null) {
-          osw.close();
-        }
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
     }
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+
+  public boolean isStrict() {
+    return strict;
   }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
index ab9819d72..3c34b55f4 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
@@ -1,9 +1,12 @@
 package retrofit.converter;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-import java.io.ByteArrayOutputStream;
-
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
 import org.junit.Test;
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
@@ -13,127 +16,113 @@
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
 
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class SimpleXMLConverterTest {
-	private static final String MIME_TYPE = "application/xml; charset=UTF-8";
-
-	private final MyObject obj = new MyObject("hello world", 10);
-	private final String objAsXML = String.format(
-			"<my-object><message>%s</message><count>%d</count></my-object>",
-			obj.getMessage(), obj.getCount());
-	private final Converter converter = initConverter();
-
-	private static Converter initConverter() {
-		Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-		Persister persister = new Persister(format);
-		return new SimpleXMLConverter(persister);
-	}
-
-	@Test
-	public void serialize() throws Exception {
-		final TypedOutput typedOutput = converter.toBody(obj);
-		assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
-		assertThat(asString(typedOutput)).isEqualTo(objAsXML);
-	}
-
-	@Test
-	public void deserialize() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		final MyObject result = (MyObject) converter.fromBody(input,
-				MyObject.class);
-		assertThat(result).isEqualTo(obj);
-	}
-
-	@Test(expected = ConversionException.class)
-	public void deserializeWrongValue() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				"<myObject><foo/><bar/></myObject>".getBytes());
-		converter.fromBody(input, MyObject.class);
-
-	}
-
-	@Test
-	public void deserializeWrongClass() throws Exception {
-		final TypedInput input = new TypedByteArray(MIME_TYPE,
-				objAsXML.getBytes());
-		Object result = converter.fromBody(input, String.class);
-		assertThat(result).isNull();
-	}
-
-	private String asString(TypedOutput typedOutput) throws Exception {
-		final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-		typedOutput.writeTo(bytes);
-		return new String(bytes.toByteArray());
-	}
-
-	@Default(value = DefaultType.FIELD)
-	static class MyObject {
-		@Element
-		private String message;
-		@Element
-		private int count;
-
-		public MyObject() {
-		}
-
-		public MyObject(String message, int count) {
-			this.message = message;
-			this.count = count;
-		}
-
-		public void setMessage(String message) {
-			this.message = message;
-		}
-
-		public String getMessage() {
-			return message;
-		}
-
-		public void setCount(int count) {
-			this.count = count;
-		}
-
-		public int getCount() {
-			return count;
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + count;
-			result = prime * result
-					+ ((message == null) ? 0 : message.hashCode());
-			return result;
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			if (this == obj) {
-				return true;
-			}
-			if (obj == null) {
-				return false;
-			}
-			if (getClass() != obj.getClass()) {
-				return false;
-			}
-			MyObject other = (MyObject) obj;
-			if (count != other.count) {
-				return false;
-			}
-			if (message == null) {
-				if (other.message != null) {
-					return false;
-				}
-			} else if (!message.equals(other.message)) {
-				return false;
-			}
-			return true;
-		}
-	}
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MyObject OBJ = new MyObject("hello world", 10);
+  private static final String XML =
+      "<my-object><message>hello world</message><count>10</count></my-object>";
+
+  private Converter converter;
+
+  @Before public void setUp() {
+    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+    Persister persister = new Persister(format);
+    converter = new SimpleXMLConverter(persister);
+  }
+
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(OBJ, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(XML);
+  }
+
+  @Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+    assertThat(result).isEqualTo(OBJ);
+  }
+
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
+    try {
+      converter.fromBody(body, MyObject.class);
+    } catch (RuntimeException ignored) {
+    }
+  }
+
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    Object result = converter.fromBody(body, String.class);
+    assertThat(result).isNull();
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
+      throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
+
+  @Default(value = DefaultType.FIELD) static class MyObject {
+    @Element private String message;
+    @Element private int count;
+
+    public MyObject() {
+    }
+
+    public MyObject(String message, int count) {
+      this.message = message;
+      this.count = count;
+    }
+
+    public void setMessage(String message) {
+      this.message = message;
+    }
+
+    public String getMessage() {
+      return message;
+    }
+
+    public void setCount(int count) {
+      this.count = count;
+    }
+
+    public int getCount() {
+      return count;
+    }
+
+    @Override public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + count;
+      result = prime * result + ((message == null) ? 0 : message.hashCode());
+      return result;
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null) {
+        return false;
+      }
+      if (getClass() != obj.getClass()) {
+        return false;
+      }
+      MyObject other = (MyObject) obj;
+      if (count != other.count) {
+        return false;
+      }
+      if (message == null) {
+        if (other.message != null) {
+          return false;
+        }
+      } else if (!message.equals(other.message)) {
+        return false;
+      }
+      return true;
+    }
+  }
 }
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 5d8fd9fb4..f56ef5fcb 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
index 046769642..e44c50615 100644
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
@@ -1,18 +1,18 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers using Wire. */
 public class WireConverter implements Converter {
-  private static final String MIME_TYPE = "application/x-protobuf";
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
   private final Wire wire;
 
@@ -23,11 +23,12 @@ public WireConverter() {
 
   /** Create a converter using the supplied {@link Wire} instance. */
   public WireConverter(Wire wire) {
+    if (wire == null) throw new NullPointerException("wire == null");
     this.wire = wire;
   }
 
   @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -36,33 +37,24 @@ public WireConverter(Wire wire) {
       throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
     }
 
-    if (!MIME_TYPE.equalsIgnoreCase(body.mimeType())) {
-      throw new IllegalArgumentException("Expected a proto but was: " + body.mimeType());
-    }
-
-    InputStream in = null;
+    InputStream in = body.byteStream();
     try {
-      in = body.in();
       return wire.parseFrom(in, (Class<Message>) c);
-    } catch (IOException e) {
-      throw new ConversionException(e);
     } finally {
-      if (in != null) {
-        try {
-          in.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        in.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof Message)) {
       throw new IllegalArgumentException(
           "Expected a proto message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((Message) object).toByteArray();
-    return new TypedByteArray(MIME_TYPE, bytes);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java b/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
index 3c18499df..efffba3cb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
@@ -1,5 +1,3 @@
-// Copyright 2013 Square, Inc.
-
 // Code generated by Wire protocol buffer compiler, do not edit.
 // Source file: ../wire-runtime/src/test/proto/person.proto
 package retrofit.converter;
@@ -42,21 +40,26 @@
   public final String email;
 
   /**
-   * A list of the user's phone numbers.
+   * A list of the customer's phone numbers.
    */
   @ProtoField(tag = 4, label = REPEATED)
   public final List<PhoneNumber> phone;
 
+  public Person(String name, Integer id, String email, List<PhoneNumber> phone) {
+    this.name = name;
+    this.id = id;
+    this.email = email;
+    this.phone = immutableCopyOf(phone);
+  }
+
   private Person(Builder builder) {
-    super(builder);
-    this.name = builder.name;
-    this.id = builder.id;
-    this.email = builder.email;
-    this.phone = immutableCopyOf(builder.phone);
+    this(builder.name, builder.id, builder.email, builder.phone);
+    setBuilder(builder);
   }
 
   @Override
   public boolean equals(Object other) {
+    if (other == this) return true;
     if (!(other instanceof Person)) return false;
     Person o = (Person) other;
     return equals(name, o.name)
@@ -72,7 +75,7 @@ public int hashCode() {
       result = name != null ? name.hashCode() : 0;
       result = result * 37 + (id != null ? id.hashCode() : 0);
       result = result * 37 + (email != null ? email.hashCode() : 0);
-      result = result * 37 + (phone != null ? phone.hashCode() : 0);
+      result = result * 37 + (phone != null ? phone.hashCode() : 1);
       hashCode = result;
     }
     return result;
@@ -97,23 +100,35 @@ public Builder(Person message) {
       this.phone = copyOf(message.phone);
     }
 
+    /**
+     * The customer's full name.
+     */
     public Builder name(String name) {
       this.name = name;
       return this;
     }
 
+    /**
+     * The customer's ID number.
+     */
     public Builder id(Integer id) {
       this.id = id;
       return this;
     }
 
+    /**
+     * Email address for the customer.
+     */
     public Builder email(String email) {
       this.email = email;
       return this;
     }
 
+    /**
+     * A list of the customer's phone numbers.
+     */
     public Builder phone(List<PhoneNumber> phone) {
-      this.phone = phone;
+      this.phone = checkForNulls(phone);
       return this;
     }
 
@@ -124,13 +139,25 @@ public Person build() {
     }
   }
 
-  public enum PhoneType {
-    @ProtoEnum(0)
-    MOBILE,
-    @ProtoEnum(1)
-    HOME,
-    @ProtoEnum(2)
-    WORK,
+  public enum PhoneType
+      implements ProtoEnum {
+    MOBILE(0),
+    HOME(1),
+    /**
+     * Could be phone or fax.
+     */
+    WORK(2);
+
+    private final int value;
+
+    private PhoneType(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
   }
 
   public static final class PhoneNumber extends Message {
@@ -139,7 +166,7 @@ public Person build() {
     public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
 
     /**
-     * The user's phone number.
+     * The customer's phone number.
      */
     @ProtoField(tag = 1, type = STRING, label = REQUIRED)
     public final String number;
@@ -150,14 +177,19 @@ public Person build() {
     @ProtoField(tag = 2, type = ENUM)
     public final PhoneType type;
 
+    public PhoneNumber(String number, PhoneType type) {
+      this.number = number;
+      this.type = type;
+    }
+
     private PhoneNumber(Builder builder) {
-      super(builder);
-      this.number = builder.number;
-      this.type = builder.type;
+      this(builder.number, builder.type);
+      setBuilder(builder);
     }
 
     @Override
     public boolean equals(Object other) {
+      if (other == this) return true;
       if (!(other instanceof PhoneNumber)) return false;
       PhoneNumber o = (PhoneNumber) other;
       return equals(number, o.number)
@@ -190,11 +222,17 @@ public Builder(PhoneNumber message) {
         this.type = message.type;
       }
 
+      /**
+       * The customer's phone number.
+       */
       public Builder number(String number) {
         this.number = number;
         return this;
       }
 
+      /**
+       * The type of phone stored here.
+       */
       public Builder type(PhoneType type) {
         this.type = type;
         return this;
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
index 6756dd8c4..cc719fcbb 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
@@ -1,15 +1,15 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
-import com.squareup.wire.Wire;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -17,24 +17,24 @@
 public final class WireConverterTest {
   private static final Person PROTO =
       new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String PROTO_ENCODED = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
+  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
 
-  private WireConverter converter = new WireConverter(new Wire());
+  private final WireConverter converter = new WireConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = converter.toBody(PROTO);
-    assertThat(protoBytes.mimeType()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(PROTO_ENCODED)));
+    RequestBody body = converter.toBody(PROTO, Person.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(decodeBase64(PROTO_ENCODED), Person.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
@@ -43,7 +43,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED),
+      converter.fromBody(protoResponse(ENCODED_PROTO),
           ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
@@ -53,33 +53,20 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      converter.fromBody(decodeBase64("////"), Person.class);
+      converter.fromBody(protoResponse("////"), Person.class);
       fail();
-    } catch (ConversionException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IOException.class);
+    } catch (IOException ignored) {
     }
   }
 
-  @Test public void deserializeWrongMime() throws Exception {
-    try {
-      converter.fromBody(decodeBase64("////", "yummy/bytes"), Person.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto but was: yummy/bytes");
-    }
-  }
-
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
-  }
-
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, "application/x-protobuf");
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
+        ByteString.decodeBase64(encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64, String mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(mime, BaseEncoding.base64().decode(base64));
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 9e03aea82..d7f00edc5 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -27,8 +27,8 @@
     </dependency>
 
     <dependency>
-      <groupId>com.netflix.rxjava</groupId>
-      <artifactId>rxjava-core</artifactId>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
       <optional>true</optional>
     </dependency>
 
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
index 908cd562d..390bb9b01 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
@@ -1,10 +1,10 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.util.ArrayList;
-import java.util.List;
-import retrofit.client.Header;
-import retrofit.client.Response;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import retrofit.converter.Converter;
 
 import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
@@ -67,7 +67,7 @@ public static MockHttpException newInternalError(Object responseBody) {
   final int code;
   final String reason;
   final Object responseBody;
-  final List<Header> headers = new ArrayList<Header>(2);
+  final Headers.Builder headers = new Headers.Builder();
 
   /**
    * Create a new HTTP exception.
@@ -97,11 +97,18 @@ public MockHttpException withHeader(String name, String value) {
     if (value == null || "".equals(value.trim())) {
       throw new IllegalArgumentException("Header value must not be blank.");
     }
-    headers.add(new Header(name, value));
+    headers.add(name, value);
     return this;
   }
 
-  Response toResponse(Converter converter) {
-    return new Response("", code, reason, headers, new MockTypedInput(converter, responseBody));
+  Response toResponse(Request request, Converter converter) {
+    return new Response.Builder()
+        .code(code)
+        .message(reason)
+        .headers(headers.build())
+        .body(new MockResponseBody(converter, responseBody))
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .build();
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
index 7c2809fd6..93112f6d1 100644
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
@@ -1,14 +1,15 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.lang.reflect.Type;
-import retrofit.client.Response;
 
 class MockHttpRetrofitError extends RetrofitError {
   private final Object body;
 
-  MockHttpRetrofitError(String message, String url, Response response, Object body) {
-    super(message, url, response, null, body.getClass(), false, null);
+  MockHttpRetrofitError(String message, String url, Response response, Object body,
+      Type responseType) {
+    super(message, url, response, null, responseType, Kind.HTTP, null);
     this.body = body;
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
new file mode 100644
index 000000000..03f1194e9
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
@@ -0,0 +1,46 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import retrofit.converter.Converter;
+
+class MockResponseBody extends ResponseBody {
+  private final Converter converter;
+  private final Object body;
+
+  private byte[] bytes;
+
+  MockResponseBody(Converter converter, Object body) {
+    this.converter = converter;
+    this.body = body;
+  }
+
+  @Override public MediaType contentType() {
+    return MediaType.parse("application/unknown");
+  }
+
+  @Override public long contentLength() {
+    try {
+      initBytes();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return bytes.length;
+  }
+
+  @Override public BufferedSource source() {
+    return new Buffer().write(bytes);
+  }
+
+  private synchronized void initBytes() throws IOException {
+    if (bytes == null) {
+      Buffer buffer = new Buffer();
+      converter.toBody(body, body.getClass()).writeTo(buffer);
+      bytes = buffer.readByteArray();
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
index 2cec5cc0b..a5bbb9fa4 100644
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -1,6 +1,8 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -10,12 +12,11 @@
 import java.util.Random;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import rx.Observable;
-import rx.Subscriber;
+import rx.Scheduler;
+import rx.functions.Func1;
+import rx.schedulers.Schedulers;
 
-import static retrofit.RestAdapter.LogLevel;
 import static retrofit.RetrofitError.unexpectedError;
 
 /**
@@ -69,8 +70,8 @@
    * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
    * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
    */
-  public static MockRestAdapter from(RestAdapter restAdapter) {
-    return new MockRestAdapter(restAdapter);
+  public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
+    return new MockRestAdapter(restAdapter, executor);
   }
 
   /** A listener invoked when the network behavior values for a {@link MockRestAdapter} change. */
@@ -84,6 +85,7 @@ public static MockRestAdapter from(RestAdapter restAdapter) {
   }
 
   private final RestAdapter restAdapter;
+  private final Executor executor;
   private MockRxSupport mockRxSupport;
   final Random random = new Random();
 
@@ -92,8 +94,9 @@ public static MockRestAdapter from(RestAdapter restAdapter) {
   private int variancePct = DEFAULT_VARIANCE_PCT;
   private int errorPct = DEFAULT_ERROR_PCT;
 
-  private MockRestAdapter(RestAdapter restAdapter) {
+  private MockRestAdapter(RestAdapter restAdapter, Executor executor) {
     this.restAdapter = restAdapter;
+    this.executor = executor;
   }
 
   /** Set a listener to be notified when any mock value changes. */
@@ -215,9 +218,9 @@ public int calculateDelayForCall() {
 
   private class MockHandler implements InvocationHandler {
     private final Object mockService;
-    private final Map<Method, RestMethodInfo> methodInfoCache;
+    private final Map<Method, MethodInfo> methodInfoCache;
 
-    public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCache) {
+    public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache) {
       this.mockService = mockService;
       this.methodInfoCache = methodInfoCache;
     }
@@ -230,11 +233,12 @@ public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCac
       }
 
       // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
+      final MethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
+      final Request request = buildRequest(methodInfo, restAdapter.requestInterceptor, args);
 
-      if (methodInfo.isSynchronous) {
+      if (methodInfo.executionType == MethodInfo.ExecutionType.SYNC) {
         try {
-          return invokeSync(methodInfo, restAdapter.requestInterceptor, args);
+          return invokeSync(methodInfo, args, request);
         } catch (RetrofitError error) {
           Throwable newError = restAdapter.errorHandler.handleError(error);
           if (newError == null) {
@@ -245,71 +249,48 @@ public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCac
         }
       }
 
-      if (restAdapter.httpExecutor == null || restAdapter.callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
-      }
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      restAdapter.requestInterceptor.intercept(interceptorTape);
-
-      if (methodInfo.isObservable) {
+      if (methodInfo.executionType == MethodInfo.ExecutionType.RX) {
         if (mockRxSupport == null) {
           if (Platform.HAS_RX_JAVA) {
-            mockRxSupport = new MockRxSupport(restAdapter);
+            mockRxSupport = new MockRxSupport(restAdapter, executor);
           } else {
             throw new IllegalStateException("Observable method found but no RxJava on classpath");
           }
         }
-        return mockRxSupport.createMockObservable(this, methodInfo, interceptorTape, args);
+        return mockRxSupport.createMockObservable(this, methodInfo, args, request);
       }
 
-      restAdapter.httpExecutor.execute(new Runnable() {
+      executor.execute(new Runnable() {
         @Override public void run() {
-          invokeAsync(methodInfo, interceptorTape, args);
+          invokeAsync(methodInfo, args, request);
         }
       });
       return null; // Asynchronous methods should have return type of void.
     }
 
-    private Request buildRequest(RestMethodInfo methodInfo, RequestInterceptor interceptor,
+    private Request buildRequest(MethodInfo methodInfo, RequestInterceptor interceptor,
         Object[] args) throws Throwable {
-      methodInfo.init();
-
       // Begin building a normal request.
-      String apiUrl = restAdapter.server.getUrl();
+      String apiUrl = restAdapter.endpoint.url();
       RequestBuilder requestBuilder = new RequestBuilder(apiUrl, methodInfo, restAdapter.converter);
       requestBuilder.setArguments(args);
 
       // Run it through the interceptor.
       interceptor.intercept(requestBuilder);
 
-      Request request = requestBuilder.build();
-
-      if (restAdapter.logLevel.log()) {
-        request = restAdapter.logAndReplaceRequest("MOCK", request);
-      }
-
-      return request;
+      return requestBuilder.build();
     }
 
-    private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor interceptor,
-        Object[] args) throws Throwable {
-      Request request = buildRequest(methodInfo, interceptor, args);
-      String url = request.getUrl();
+    private Object invokeSync(MethodInfo methodInfo, Object[] args, Request request)
+        throws Throwable {
+      String url = request.urlString();
 
       if (calculateIsFailure()) {
         sleep(calculateDelayForError());
         IOException exception = new IOException("Mock network error!");
-        if (restAdapter.logLevel.log()) {
-          restAdapter.logException(exception, url);
-        }
-        throw RetrofitError.networkError(url, exception);
+        throw RetrofitError.networkFailure(url, exception);
       }
 
-      LogLevel logLevel = restAdapter.logLevel;
-      RestAdapter.Log log = restAdapter.log;
-
       int callDelay = calculateDelayForCall();
       long beforeNanos = System.nanoTime();
       try {
@@ -319,14 +300,6 @@ private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor intercep
         long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
         sleep(callDelay - tookMs);
 
-        if (logLevel.log()) {
-          log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(returnValue + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
-          }
-        }
-
         return returnValue;
       } catch (InvocationTargetException e) {
         Throwable innerEx = e.getCause();
@@ -334,48 +307,26 @@ private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor intercep
           throw innerEx;
         }
         MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(restAdapter.converter);
+        Response response = httpEx.toResponse(request, restAdapter.converter);
 
         // Sleep for whatever amount of time is left to satisfy the network delay, if any.
         long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
         sleep(callDelay - tookMs);
 
-        if (logLevel.log()) {
-          log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
-          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-            log.log(httpEx.responseBody + ""); // Hack to convert toString while supporting null.
-            log.log("<--- END MOCK");
-          }
-        }
-
-        throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody);
+        throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody,
+            methodInfo.responseObjectType);
       }
     }
 
-    private void invokeAsync(final RestMethodInfo methodInfo, RequestInterceptor interceptorTape,
-        final Object[] args) {
-      Request request;
-      try {
-        request = buildRequest(methodInfo, interceptorTape, args);
-      } catch (final Throwable throwable) {
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            throw new RuntimeException(throwable);
-          }
-        });
-        return;
-      }
-
-      final String url = request.getUrl();
+    private void invokeAsync(final MethodInfo methodInfo, final Object[] args,
+        final Request request) {
+      final String url = request.urlString();
       final Callback callback = (Callback) args[args.length - 1];
 
       if (calculateIsFailure()) {
         sleep(calculateDelayForError());
         IOException exception = new IOException("Mock network error!");
-        if (restAdapter.logLevel.log()) {
-          restAdapter.logException(exception, url);
-        }
-        RetrofitError error = RetrofitError.networkError(url, exception);
+        RetrofitError error = RetrofitError.networkFailure(url, exception);
         Throwable cause = restAdapter.errorHandler.handleError(error);
         final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
         restAdapter.callbackExecutor.execute(new Runnable() {
@@ -391,14 +342,8 @@ private void invokeAsync(final RestMethodInfo methodInfo, RequestInterceptor int
 
       restAdapter.callbackExecutor.execute(new Runnable() {
         @Override public void run() {
-          LogLevel logLevel = restAdapter.logLevel;
-          RestAdapter.Log log = restAdapter.log;
-
           try {
             methodInfo.method.invoke(mockService, args);
-            if (logLevel.log()) {
-              log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
-            }
           } catch (Throwable throwable) {
             final Throwable innerEx = throwable.getCause();
             if (!(innerEx instanceof MockHttpException)) {
@@ -409,18 +354,10 @@ private void invokeAsync(final RestMethodInfo methodInfo, RequestInterceptor int
             }
 
             MockHttpException httpEx = (MockHttpException) innerEx;
-            Response response = httpEx.toResponse(restAdapter.converter);
-
-            if (logLevel.log()) {
-              log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
-              if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-                log.log(String.valueOf(httpEx.responseBody));
-                log.log("<--- END MOCK");
-              }
-            }
+            Response response = httpEx.toResponse(request, restAdapter.converter);
 
             RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
-                httpEx.responseBody);
+                httpEx.responseBody, methodInfo.responseObjectType);
             Throwable cause = restAdapter.errorHandler.handleError(error);
             final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
             callback.failure(e);
@@ -467,36 +404,28 @@ private static long uptimeMillis() {
 
   /** Indirection to avoid VerifyError if RxJava isn't present. */
   private static class MockRxSupport {
-    private final Executor httpExecutor;
+    private final Scheduler httpScheduler;
     private final ErrorHandler errorHandler;
 
-    MockRxSupport(RestAdapter restAdapter) {
-      httpExecutor = restAdapter.httpExecutor;
+    MockRxSupport(RestAdapter restAdapter, Executor executor) {
+      httpScheduler = Schedulers.from(executor);
       errorHandler = restAdapter.errorHandler;
     }
 
-    Observable createMockObservable(final MockHandler mockHandler, final RestMethodInfo methodInfo,
-        final RequestInterceptor interceptor, final Object[] args) {
-      return Observable.create(new Observable.OnSubscribe<Object>() {
-        @Override public void call(final Subscriber<? super Object> subscriber) {
-          if (subscriber.isUnsubscribed()) return;
-          httpExecutor.execute(new Runnable() {
-            @Override public void run() {
+    Observable createMockObservable(final MockHandler mockHandler, final MethodInfo methodInfo,
+        final Object[] args, final Request request) {
+      return Observable.just("nothing") //
+          .flatMap(new Func1<String, Observable<?>>() {
+            @Override public Observable<?> call(String s) {
               try {
-                if (subscriber.isUnsubscribed()) return;
-                Observable observable =
-                        (Observable) mockHandler.invokeSync(methodInfo, interceptor, args);
-                //noinspection unchecked
-                observable.subscribe(subscriber);
+                return (Observable) mockHandler.invokeSync(methodInfo, args, request);
               } catch (RetrofitError e) {
-                subscriber.onError(errorHandler.handleError(e));
-              } catch (Throwable e) {
-                subscriber.onError(e);
+                return Observable.error(errorHandler.handleError(e));
+              } catch (Throwable throwable) {
+                return Observable.error(throwable);
               }
             }
-          });
-        }
-      });
+          }).subscribeOn(httpScheduler);
     }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java b/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
deleted file mode 100644
index 278aebc02..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
-
-class MockTypedInput implements TypedInput {
-  private final Converter converter;
-  private final Object body;
-
-  private byte[] bytes;
-
-  MockTypedInput(Converter converter, Object body) {
-    this.converter = converter;
-    this.body = body;
-  }
-
-  @Override public String mimeType() {
-    return "application/unknown";
-  }
-
-  @Override public long length() {
-    try {
-      initBytes();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-    return bytes.length;
-  }
-
-  @Override public InputStream in() throws IOException {
-    initBytes();
-    return new ByteArrayInputStream(bytes);
-  }
-
-  private synchronized void initBytes() throws IOException {
-    if (bytes == null) {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      converter.toBody(body).writeTo(out);
-      bytes = out.toByteArray();
-    }
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
index 2eb1225bb..d187b7895 100644
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -1,6 +1,7 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -10,19 +11,15 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.GET;
 import rx.Observable;
 import rx.functions.Action1;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
@@ -57,17 +54,12 @@
   private Throwable nextError;
 
   @Before public void setUp() throws IOException {
-    Client client = mock(Client.class);
-    doThrow(new AssertionError()).when(client).execute(any(Request.class));
-
     httpExecutor = spy(new SynchronousExecutor());
     callbackExecutor = spy(new SynchronousExecutor());
 
     RestAdapter restAdapter = new RestAdapter.Builder() //
-        .setClient(client)
-        .setExecutors(httpExecutor, callbackExecutor)
-        .setEndpoint("http://example.com")
-        .setLogLevel(RestAdapter.LogLevel.NONE)
+        .setCallbackExecutor(callbackExecutor)
+        .setEndpoint("none")
         .setErrorHandler(new ErrorHandler() {
           @Override public Throwable handleError(RetrofitError cause) {
             if (nextError != null) {
@@ -82,7 +74,7 @@
 
     valueChangeListener = mock(ValueChangeListener.class);
 
-    mockRestAdapter = MockRestAdapter.from(restAdapter);
+    mockRestAdapter = MockRestAdapter.from(restAdapter, httpExecutor);
     mockRestAdapter.setValueChangeListener(valueChangeListener);
 
     // Seed the random with a value so the tests are deterministic.
@@ -232,7 +224,7 @@
       mockService.doStuff();
       fail();
     } catch (RetrofitError e) {
-      assertThat(e.isNetworkError()).isTrue();
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
       assertThat(e.getCause()).hasMessage("Mock network error!");
     }
   }
@@ -264,7 +256,7 @@
     verify(callbackExecutor).execute(any(Runnable.class));
 
     RetrofitError error = errorRef.get();
-    assertThat(error.isNetworkError()).isTrue();
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
     assertThat(error.getCause()).hasMessage("Mock network error!");
   }
 
@@ -340,7 +332,7 @@
 
     class MockObservableExample implements ObservableExample {
       @Override public Observable<String> doStuff() {
-        return Observable.from(expected);
+        return Observable.just(expected);
       }
     }
 
@@ -395,11 +387,11 @@
     } catch (RetrofitError e) {
       long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
       assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e.isNetworkError()).isFalse();
-      assertThat(e.getResponse().getStatus()).isEqualTo(404);
-      assertThat(e.getResponse().getReason()).isEqualTo("Not Found");
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+      assertThat(e.getResponse().code()).isEqualTo(404);
+      assertThat(e.getResponse().message()).isEqualTo("Not Found");
       assertThat(e.getBody()).isSameAs(expected);
-      assertThat(e.getSuccessType()).isEqualTo(String.class);
+      assertThat(e.getSuccessType()).isEqualTo(Object.class);
     }
   }
 
@@ -438,9 +430,9 @@
 
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.isNetworkError()).isFalse();
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
     assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
@@ -477,18 +469,59 @@
       }
     });
 
-    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
+    verify(httpExecutor).execute(any(Runnable.class));
     verifyZeroInteractions(callbackExecutor);
 
     RetrofitError error = errorRef.get();
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.isNetworkError()).isFalse();
-    assertThat(error.getResponse().getStatus()).isEqualTo(404);
-    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(404);
+    assertThat(error.getResponse().message()).isEqualTo("Not Found");
     assertThat(error.getBody()).isSameAs(expected);
     assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 
+  @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    class MockObservableExample implements ObservableExample {
+      @Override public Observable<String> doStuff() {
+        throw MockHttpException.newBadRequest(null);
+      }
+    }
+
+    ObservableExample mockService =
+        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    mockService.doStuff().subscribe(new Action1<Object>() {
+      @Override public void call(Object o) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable error) {
+        assertThat(error).isInstanceOf(RetrofitError.class);
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        errorRef.set((RetrofitError) error);
+      }
+    });
+
+    verify(httpExecutor).execute(any(Runnable.class));
+    verifyZeroInteractions(callbackExecutor);
+
+    RetrofitError error = errorRef.get();
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+    assertThat(error.getResponse().code()).isEqualTo(400);
+    assertThat(error.getResponse().message()).isEqualTo("Bad Request");
+    assertThat(error.getBody()).isNull();
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
+  }
+
   @Test public void syncErrorUsesErrorHandler() {
     mockRestAdapter.setDelay(100);
     mockRestAdapter.setVariancePercentage(0);
@@ -536,7 +569,7 @@
         latch.countDown();
       }
     });
-    latch.await(5, SECONDS);
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
   }
 
   @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
@@ -555,7 +588,6 @@
     nextError = new IllegalArgumentException("Test");
 
     final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicBoolean called = new AtomicBoolean();
     mockService.doStuff().subscribe(new Action1<Object>() {
       @Override public void call(Object o) {
         throw new AssertionError();
@@ -563,12 +595,10 @@
     }, new Action1<Throwable>() {
       @Override public void call(Throwable error) {
         assertThat(error).hasMessage("Test");
-        called.set(true);
         latch.countDown();
       }
     });
-    latch.await(5, SECONDS);
-    assertThat(called.get()).isTrue();
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
   }
 
   @Test public void asyncCanUseCallbackSubtype() {
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 27139f479..6871fcc9e 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -27,21 +27,10 @@
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>okhttp</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>com.netflix.rxjava</groupId>
-      <artifactId>rxjava-core</artifactId>
-      <optional>true</optional>
     </dependency>
     <dependency>
-      <groupId>com.google.appengine</groupId>
-      <artifactId>appengine-api-1.0-sdk</artifactId>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
       <optional>true</optional>
     </dependency>
 
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index d05acdb63..65f1bc5ed 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,7 +15,7 @@
  */
 package retrofit;
 
-import retrofit.client.Response;
+import com.squareup.okhttp.Response;
 
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
@@ -29,7 +29,7 @@
  * </ul>
  *
  * @param <T> expected response type
- * @see RestAdapter.Builder#setExecutors
+ * @see RestAdapter.Builder#setCallbackExecutor
  */
 public interface Callback<T> {
 
diff --git a/retrofit/src/main/java/retrofit/CallbackRunnable.java b/retrofit/src/main/java/retrofit/CallbackRunnable.java
deleted file mode 100644
index afd663602..000000000
--- a/retrofit/src/main/java/retrofit/CallbackRunnable.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.util.concurrent.Executor;
-
-import static retrofit.RetrofitError.unexpectedError;
-
-/**
- * A {@link Runnable} executed on a background thread to invoke {@link #obtainResponse()} which
- * performs an HTTP request. The response of the request, whether it be an object or exception, is
- * then marshaled to the supplied {@link Executor} in the form of a method call on a
- * {@link Callback}.
- */
-abstract class CallbackRunnable<T> implements Runnable {
-  private final Callback<T> callback;
-  private final Executor callbackExecutor;
-  private final ErrorHandler errorHandler;
-
-  CallbackRunnable(Callback<T> callback, Executor callbackExecutor, ErrorHandler errorHandler) {
-    this.callback = callback;
-    this.callbackExecutor = callbackExecutor;
-    this.errorHandler = errorHandler;
-  }
-
-  @SuppressWarnings("unchecked")
-  @Override public final void run() {
-    try {
-      final ResponseWrapper wrapper = obtainResponse();
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.success((T) wrapper.responseBody, wrapper.response);
-        }
-      });
-    } catch (RetrofitError e) {
-      Throwable cause = errorHandler.handleError(e);
-      final RetrofitError handled = cause == e ? e : unexpectedError(e.getUrl(), cause);
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.failure(handled);
-        }
-      });
-    }
-  }
-
-  public abstract ResponseWrapper obtainResponse();
-}
diff --git a/retrofit/src/main/java/retrofit/Endpoint.java b/retrofit/src/main/java/retrofit/Endpoint.java
index 59a35646b..771013c22 100644
--- a/retrofit/src/main/java/retrofit/Endpoint.java
+++ b/retrofit/src/main/java/retrofit/Endpoint.java
@@ -1,17 +1,24 @@
 package retrofit;
 
-/**
- * Represents an API endpoint URL and associated name. Callers should always consult the instance
- * for the latest values rather than caching the returned values.
- *
- * @author Matt Hickman (mhickman@palantir.com)
- */
-public interface Endpoint {
+import static retrofit.Utils.checkNotNull;
 
-  /** The base API URL. */
-  String getUrl();
-
-  /** A name for differentiating between multiple API URLs. */
-  String getName();
+/** An API endpoint. */
+public abstract class Endpoint {
+  /** Create an endpoint with the provided {@code url}. */
+  public static Endpoint createFixed(final String url) {
+    checkNotNull(url, "url == null");
+    return new Endpoint() {
+      @Override public String url() {
+        return url;
+      }
+    };
+  }
 
+  /**
+   * The base URL.
+   * <p>
+   * Consumers will call this method every time they need to create a request allowing values
+   * to change over time.
+   */
+  public abstract String url();
 }
diff --git a/retrofit/src/main/java/retrofit/Endpoints.java b/retrofit/src/main/java/retrofit/Endpoints.java
deleted file mode 100644
index 62a062b5e..000000000
--- a/retrofit/src/main/java/retrofit/Endpoints.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package retrofit;
-
-/**
- * Static factory methods for creating {@link Endpoint} instances.
- *
- * @author Matt Hickman (mhickman@palantir.com)
- */
-public final class Endpoints {
-  private static final String DEFAULT_NAME = "default";
-
-  private Endpoints() {
-  }
-
-  /** Create a server with the provided URL. */
-  public static Endpoint newFixedEndpoint(String url) {
-    return new FixedEndpoint(url, DEFAULT_NAME);
-  }
-
-  /** Create an endpoint with the provided URL and name. */
-  public static Endpoint newFixedEndpoint(String url, String name) {
-    return new FixedEndpoint(url, name);
-  }
-
-  private static class FixedEndpoint implements Endpoint {
-    private final String apiUrl;
-    private final String name;
-
-    FixedEndpoint(String apiUrl, String name) {
-      this.apiUrl = apiUrl;
-      this.name = name;
-    }
-
-    @Override public String getUrl() {
-      return apiUrl;
-    }
-
-    @Override public String getName() {
-      return name;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/ErrorHandler.java b/retrofit/src/main/java/retrofit/ErrorHandler.java
index 9934528ce..83c05a36d 100644
--- a/retrofit/src/main/java/retrofit/ErrorHandler.java
+++ b/retrofit/src/main/java/retrofit/ErrorHandler.java
@@ -16,7 +16,7 @@
 package retrofit;
 
 /**
- * A hook allowing clients to customize {@link retrofit.client.Response response} exceptions.
+ * A hook allowing clients to customize {@link RetrofitError RetrofitError}.
  *
  * @author Sam Beran sberan@gmail.com
  */
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
new file mode 100644
index 000000000..db7c14d63
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -0,0 +1,47 @@
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+class ExceptionCatchingRequestBody extends ResponseBody {
+  private final ResponseBody delegate;
+  private IOException thrownException;
+
+  ExceptionCatchingRequestBody(ResponseBody delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() {
+    return delegate.contentLength();
+  }
+
+  @Override public BufferedSource source() {
+    return Okio.buffer(new ForwardingSource(delegate.source()) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        try {
+          return super.read(sink, byteCount);
+        } catch (IOException e) {
+          thrownException = e;
+          throw e;
+        }
+      }
+    });
+  }
+
+  IOException getThrownException() {
+    return thrownException;
+  }
+
+  boolean threwException() {
+    return thrownException != null;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java b/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
deleted file mode 100644
index 40e222b15..000000000
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingTypedInput.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package retrofit;
-
-import java.io.IOException;
-import java.io.InputStream;
-import retrofit.mime.TypedInput;
-
-class ExceptionCatchingTypedInput implements TypedInput {
-  private final TypedInput delegate;
-  private final ExceptionCatchingInputStream delegateStream;
-
-  ExceptionCatchingTypedInput(TypedInput delegate) throws IOException {
-    this.delegate = delegate;
-    this.delegateStream = new ExceptionCatchingInputStream(delegate.in());
-  }
-
-  @Override public String mimeType() {
-    return delegate.mimeType();
-  }
-
-  @Override public long length() {
-    return delegate.length();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return delegateStream;
-  }
-
-  IOException getThrownException() {
-    return delegateStream.thrownException;
-  }
-
-  boolean threwException() {
-    return delegateStream.thrownException != null;
-  }
-
-  private static class ExceptionCatchingInputStream extends InputStream {
-    private final InputStream delegate;
-    private IOException thrownException;
-
-    ExceptionCatchingInputStream(InputStream delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public int read() throws IOException {
-      try {
-        return delegate.read();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer) throws IOException {
-      try {
-        return delegate.read(buffer);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      try {
-        return delegate.read(buffer, offset, length);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public long skip(long byteCount) throws IOException {
-      try {
-        return delegate.skip(byteCount);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int available() throws IOException {
-      try {
-        return delegate.available();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      try {
-        delegate.close();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public synchronized void mark(int readLimit) {
-      delegate.mark(readLimit);
-    }
-
-    @Override public synchronized void reset() throws IOException {
-      try {
-        delegate.reset();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public boolean markSupported() {
-      return delegate.markSupported();
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
similarity index 66%
rename from retrofit/src/main/java/retrofit/RestMethodInfo.java
rename to retrofit/src/main/java/retrofit/MethodInfo.java
index cf73f9491..40c0bd59a 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -15,45 +15,45 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Response;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
-import java.util.ArrayList;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import retrofit.client.Response;
 import retrofit.http.Body;
-import retrofit.http.EncodedPath;
-import retrofit.http.EncodedQuery;
-import retrofit.http.EncodedQueryMap;
+import retrofit.http.DELETE;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
 import retrofit.http.FormUrlEncoded;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
 import retrofit.http.Header;
 import retrofit.http.Headers;
 import retrofit.http.Multipart;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
 import retrofit.http.Part;
 import retrofit.http.PartMap;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
+import retrofit.http.HTTP;
 import retrofit.http.Streaming;
-import retrofit.http.RestMethod;
 import rx.Observable;
 
 /** Request metadata about a service interface declaration. */
-final class RestMethodInfo {
-
-  private enum ResponseType {
-    VOID,
-    OBSERVABLE,
-    OBJECT
+final class MethodInfo {
+  enum ExecutionType {
+    ASYNC,
+    RX,
+    SYNC
   }
 
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
@@ -61,21 +61,6 @@
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  enum ParamUsage {
-    PATH,
-    ENCODED_PATH,
-    QUERY,
-    ENCODED_QUERY,
-    QUERY_MAP,
-    ENCODED_QUERY_MAP,
-    FIELD,
-    FIELD_MAP,
-    PART,
-    PART_MAP,
-    BODY,
-    HEADER
-  }
-
   enum RequestType {
     /** No content-specific logic required. */
     SIMPLE,
@@ -87,32 +72,29 @@
 
   final Method method;
 
-  boolean loaded = false;
-
   // Method-level details
-  final ResponseType responseType;
-  final boolean isSynchronous;
-  final boolean isObservable;
+  final ExecutionType executionType;
   Type responseObjectType;
+  Type requestObjectType;
   RequestType requestType = RequestType.SIMPLE;
   String requestMethod;
   boolean requestHasBody;
   String requestUrl;
   Set<String> requestUrlParamNames;
   String requestQuery;
-  List<retrofit.client.Header> headers;
+  com.squareup.okhttp.Headers headers;
   String contentTypeHeader;
   boolean isStreaming;
 
   // Parameter-level details
-  String[] requestParamNames;
-  ParamUsage[] requestParamUsage;
+  Annotation[] requestParamAnnotations;
 
-  RestMethodInfo(Method method) {
+  MethodInfo(Method method) {
     this.method = method;
-    responseType = parseResponseType();
-    isSynchronous = (responseType == ResponseType.OBJECT);
-    isObservable = (responseType == ResponseType.OBSERVABLE);
+    executionType = parseResponseType();
+
+    parseMethodAnnotations();
+    parseParameters();
   }
 
   private RuntimeException methodError(String message, Object... args) {
@@ -127,44 +109,25 @@ private RuntimeException parameterError(int index, String message, Object... arg
     return methodError(message + " (parameter #" + (index + 1) + ")", args);
   }
 
-  synchronized void init() {
-    if (loaded) return;
-
-    parseMethodAnnotations();
-    parseParameters();
-
-    loaded = true;
-  }
-
   /** Loads {@link #requestMethod} and {@link #requestType}. */
   private void parseMethodAnnotations() {
     for (Annotation methodAnnotation : method.getAnnotations()) {
       Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
-      RestMethod methodInfo = null;
-
-      // Look for a @RestMethod annotation on the parameter annotation indicating request method.
-      for (Annotation innerAnnotation : annotationType.getAnnotations()) {
-        if (RestMethod.class == innerAnnotation.annotationType()) {
-          methodInfo = (RestMethod) innerAnnotation;
-          break;
-        }
-      }
-
-      if (methodInfo != null) {
-        if (requestMethod != null) {
-          throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
-              methodInfo.value());
-        }
-        String path;
-        try {
-          path = (String) annotationType.getMethod("value").invoke(methodAnnotation);
-        } catch (Exception e) {
-          throw methodError("Failed to extract String 'value' from @%s annotation.",
-              annotationType.getSimpleName());
-        }
-        parsePath(path);
-        requestMethod = methodInfo.value();
-        requestHasBody = methodInfo.hasBody();
+      if (annotationType == DELETE.class) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) methodAnnotation).value(), false);
+      } else if (annotationType == GET.class) {
+        parseHttpMethodAndPath("GET", ((GET) methodAnnotation).value(), false);
+      } else if (annotationType == HEAD.class) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) methodAnnotation).value(), false);
+      } else if (annotationType == PATCH.class) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) methodAnnotation).value(), true);
+      } else if (annotationType == POST.class) {
+        parseHttpMethodAndPath("POST", ((POST) methodAnnotation).value(), true);
+      } else if (annotationType == PUT.class) {
+        parseHttpMethodAndPath("PUT", ((PUT) methodAnnotation).value(), true);
+      } else if (annotationType == HTTP.class) {
+        HTTP http = (HTTP) methodAnnotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
       } else if (annotationType == Headers.class) {
         String[] headersToParse = ((Headers) methodAnnotation).value();
         if (headersToParse.length == 0) {
@@ -175,12 +138,14 @@ private void parseMethodAnnotations() {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.MULTIPART;
+        throw new UnsupportedOperationException("Multipart shall return!");
+        //requestType = RequestType.MULTIPART;
       } else if (annotationType == FormUrlEncoded.class) {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.FORM_URL_ENCODED;
+        throw new UnsupportedOperationException("Form URL encoding shall return!");
+        //requestType = RequestType.FORM_URL_ENCODED;
       } else if (annotationType == Streaming.class) {
         if (responseObjectType != Response.class) {
           throw methodError(
@@ -207,7 +172,11 @@ private void parseMethodAnnotations() {
   }
 
   /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
-  private void parsePath(String path) {
+  private void parseHttpMethodAndPath(String method, String path, boolean hasBody) {
+    if (requestMethod != null) {
+      throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
+          method);
+    }
     if (path == null || path.length() == 0 || path.charAt(0) != '/') {
       throw methodError("URL path \"%s\" must start with '/'.", path);
     }
@@ -223,19 +192,22 @@ private void parsePath(String path) {
       // Ensure the query string does not have any named parameters.
       Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
       if (queryParamMatcher.find()) {
-        throw methodError("URL query string \"%s\" must not have replace block.", query);
+        throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
+            + " parameters use @Query.", query);
       }
     }
 
     Set<String> urlParams = parsePathParameters(path);
 
+    requestMethod = method;
+    requestHasBody = hasBody;
     requestUrl = url;
     requestUrlParamNames = urlParams;
     requestQuery = query;
   }
 
-  List<retrofit.client.Header> parseHeaders(String[] headers) {
-    List<retrofit.client.Header> headerList = new ArrayList<retrofit.client.Header>();
+  com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
     for (String header : headers) {
       int colon = header.indexOf(':');
       if (colon == -1 || colon == 0 || colon == header.length() - 1) {
@@ -247,14 +219,14 @@ private void parsePath(String path) {
       if ("Content-Type".equalsIgnoreCase(headerName)) {
         contentTypeHeader = headerValue;
       } else {
-        headerList.add(new retrofit.client.Header(headerName, headerValue));
+        builder.add(headerName, headerValue);
       }
     }
-    return headerList;
+    return builder.build();
   }
 
-  /** Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous. */
-  private ResponseType parseResponseType() {
+  /** Loads {@link #responseObjectType}. */
+  private ExecutionType parseResponseType() {
     // Synchronous methods have a non-void return type.
     // Observable methods have a return type of Observable.
     Type returnType = method.getGenericReturnType();
@@ -291,17 +263,17 @@ private ResponseType parseResponseType() {
         if (RxSupport.isObservable(rawReturnType)) {
           returnType = RxSupport.getObservableType(returnType, rawReturnType);
           responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-          return ResponseType.OBSERVABLE;
+          return ExecutionType.RX;
         }
       }
       responseObjectType = returnType;
-      return ResponseType.OBJECT;
+      return ExecutionType.SYNC;
     }
 
     lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
     if (lastArgType instanceof ParameterizedType) {
       responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
-      return ResponseType.VOID;
+      return ExecutionType.ASYNC;
     }
 
     throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");
@@ -319,119 +291,74 @@ private static Type getParameterUpperBound(ParameterizedType type) {
   }
 
   /**
-   * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
-   * {@link #parseMethodAnnotations()}.
+   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
-    Class<?>[] parameterTypes = method.getParameterTypes();
+    Type[] methodParameterTypes = method.getGenericParameterTypes();
 
-    Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
-    int count = parameterAnnotationArrays.length;
-    if (!isSynchronous && !isObservable) {
+    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+    int count = methodParameterAnnotationArrays.length;
+    if (executionType == ExecutionType.ASYNC) {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
-    String[] paramNames = new String[count];
-    requestParamNames = paramNames;
-    ParamUsage[] paramUsage = new ParamUsage[count];
-    requestParamUsage = paramUsage;
+    Annotation[] requestParamAnnotations = new Annotation[count];
 
     boolean gotField = false;
     boolean gotPart = false;
     boolean gotBody = false;
 
     for (int i = 0; i < count; i++) {
-      Class<?> parameterType = parameterTypes[i];
-      Annotation[] parameterAnnotations = parameterAnnotationArrays[i];
-      if (parameterAnnotations != null) {
-        for (Annotation parameterAnnotation : parameterAnnotations) {
-          Class<? extends Annotation> annotationType = parameterAnnotation.annotationType();
-
-          if (annotationType == Path.class) {
-            String name = ((Path) parameterAnnotation).value();
+      Type methodParameterType = methodParameterTypes[i];
+      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
+      if (methodParameterAnnotations != null) {
+        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+          Class<? extends Annotation> methodAnnotationType =
+              methodParameterAnnotation.annotationType();
+
+          if (methodAnnotationType == Path.class) {
+            String name = ((Path) methodParameterAnnotation).value();
             validatePathName(i, name);
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.PATH;
-          } else if (annotationType == EncodedPath.class) {
-            String name = ((EncodedPath) parameterAnnotation).value();
-            validatePathName(i, name);
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.ENCODED_PATH;
-          } else if (annotationType == Query.class) {
-            String name = ((Query) parameterAnnotation).value();
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.QUERY;
-          } else if (annotationType == EncodedQuery.class) {
-            String name = ((EncodedQuery) parameterAnnotation).value();
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.ENCODED_QUERY;
-          } else if (annotationType == QueryMap.class) {
-            if (!Map.class.isAssignableFrom(parameterType)) {
+          } else if (methodAnnotationType == Query.class) {
+            // Nothing to do.
+          } else if (methodAnnotationType == QueryMap.class) {
+            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
-
-            paramUsage[i] = ParamUsage.QUERY_MAP;
-          } else if (annotationType == EncodedQueryMap.class) {
-            if (!Map.class.isAssignableFrom(parameterType)) {
-              throw parameterError(i, "@EncodedQueryMap parameter type must be Map.");
-            }
-
-            paramUsage[i] = ParamUsage.ENCODED_QUERY_MAP;
-          } else if (annotationType == Header.class) {
-            String name = ((Header) parameterAnnotation).value();
-            if (parameterType != String.class) {
-              throw parameterError(i, "@Header parameter type must be String. Found: %s.",
-                  parameterType.getSimpleName());
-            }
-
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.HEADER;
-          } else if (annotationType == Field.class) {
+          } else if (methodAnnotationType == Header.class) {
+            // Nothing to do.
+          } else if (methodAnnotationType == Field.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
 
-            String name = ((Field) parameterAnnotation).value();
-
             gotField = true;
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.FIELD;
-          } else if (annotationType == FieldMap.class) {
+          } else if (methodAnnotationType == FieldMap.class) {
             if (requestType != RequestType.FORM_URL_ENCODED) {
               throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
-            if (!Map.class.isAssignableFrom(parameterType)) {
+            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
 
             gotField = true;
-            paramUsage[i] = ParamUsage.FIELD_MAP;
-          } else if (annotationType == Part.class) {
+          } else if (methodAnnotationType == Part.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
 
-            String name = ((Part) parameterAnnotation).value();
-
             gotPart = true;
-            paramNames[i] = name;
-            paramUsage[i] = ParamUsage.PART;
-          } else if (annotationType == PartMap.class) {
+          } else if (methodAnnotationType == PartMap.class) {
             if (requestType != RequestType.MULTIPART) {
               throw parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
             }
-            if (!Map.class.isAssignableFrom(parameterType)) {
+            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
 
             gotPart = true;
-            paramUsage[i] = ParamUsage.PART_MAP;
-          } else if (annotationType == Body.class) {
+          } else if (methodAnnotationType == Body.class) {
             if (requestType != RequestType.SIMPLE) {
               throw parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
@@ -440,13 +367,24 @@ private void parseParameters() {
               throw methodError("Multiple @Body method annotations found.");
             }
 
+            requestObjectType = methodParameterType;
             gotBody = true;
-            paramUsage[i] = ParamUsage.BODY;
+          } else {
+            // This is a non-Retrofit annotation. Skip to the next one.
+            continue;
+          }
+
+          if (requestParamAnnotations[i] != null) {
+            throw parameterError(i,
+                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
+                requestParamAnnotations[i].annotationType().getSimpleName(),
+                methodAnnotationType.getSimpleName());
           }
+          requestParamAnnotations[i] = methodParameterAnnotation;
         }
       }
 
-      if (paramUsage[i] == null) {
+      if (requestParamAnnotations[i] == null) {
         throw parameterError(i, "No Retrofit annotation found.");
       }
     }
@@ -460,6 +398,8 @@ private void parseParameters() {
     if (requestType == RequestType.MULTIPART && !gotPart) {
       throw methodError("Multipart method must contain at least one @Part.");
     }
+
+    this.requestParamAnnotations = requestParamAnnotations;
   }
 
   private void validatePathName(int index, String name) {
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 5a394746f..928fd1ae8 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -16,25 +16,15 @@
 package retrofit;
 
 import android.os.Build;
-import android.os.Process;
-import com.google.gson.Gson;
+import android.os.Handler;
+import android.os.Looper;
+import com.squareup.okhttp.OkHttpClient;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-import retrofit.android.AndroidApacheClient;
-import retrofit.android.AndroidLog;
-import retrofit.android.MainThreadExecutor;
-import retrofit.appengine.UrlFetchClient;
-import retrofit.client.Client;
-import retrofit.client.OkClient;
-import retrofit.client.UrlConnectionClient;
+import java.util.concurrent.TimeUnit;
 import retrofit.converter.Converter;
 import retrofit.converter.GsonConverter;
 
-import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
-import static java.lang.Thread.MIN_PRIORITY;
-
-abstract class Platform {
+class Platform {
   private static final Platform PLATFORM = findPlatform();
 
   static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
@@ -52,158 +42,38 @@ private static Platform findPlatform() {
     } catch (ClassNotFoundException ignored) {
     }
 
-    if (System.getProperty("com.google.appengine.runtime.version") != null) {
-      return new AppEngine();
-    }
-
-    return new Base();
+    return new Platform();
   }
 
-  abstract Converter defaultConverter();
-  abstract Client.Provider defaultClient();
-  abstract Executor defaultHttpExecutor();
-  abstract Executor defaultCallbackExecutor();
-  abstract RestAdapter.Log defaultLog();
-
-  /** Provides sane defaults for operation on the JVM. */
-  private static class Base extends Platform {
-    @Override Converter defaultConverter() {
-      return new GsonConverter(new Gson());
-    }
-
-    @Override Client.Provider defaultClient() {
-      final Client client;
-      if (hasOkHttpOnClasspath()) {
-        client = OkClientInstantiator.instantiate();
-      } else {
-        client = new UrlConnectionClient();
-      }
-      return new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      };
-    }
-
-    @Override Executor defaultHttpExecutor() {
-      return Executors.newCachedThreadPool(new ThreadFactory() {
-        @Override public Thread newThread(final Runnable r) {
-          return new Thread(new Runnable() {
-            @Override public void run() {
-              Thread.currentThread().setPriority(MIN_PRIORITY);
-              r.run();
-            }
-          }, RestAdapter.IDLE_THREAD_NAME);
-        }
-      });
-    }
+  Converter defaultConverter() {
+    return new GsonConverter();
+  }
 
-    @Override Executor defaultCallbackExecutor() {
-      return new Utils.SynchronousExecutor();
-    }
+  Executor defaultCallbackExecutor() {
+    return new Utils.SynchronousExecutor();
+  }
 
-    @Override RestAdapter.Log defaultLog() {
-      return new RestAdapter.Log() {
-        @Override public void log(String message) {
-          System.out.println(message);
-        }
-      };
-    }
+  OkHttpClient defaultClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setConnectTimeout(15, TimeUnit.SECONDS);
+    client.setReadTimeout(15, TimeUnit.SECONDS);
+    client.setWriteTimeout(15, TimeUnit.SECONDS);
+    return client;
   }
 
   /** Provides sane defaults for operation on Android. */
   private static class Android extends Platform {
-    @Override Converter defaultConverter() {
-      return new GsonConverter(new Gson());
-    }
-
-    @Override Client.Provider defaultClient() {
-      final Client client;
-      if (hasOkHttpOnClasspath()) {
-        client = OkClientInstantiator.instantiate();
-      } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
-        client = new AndroidApacheClient();
-      } else {
-        client = new UrlConnectionClient();
-      }
-      return new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      };
-    }
-
-    @Override Executor defaultHttpExecutor() {
-      return Executors.newCachedThreadPool(new ThreadFactory() {
-        @Override public Thread newThread(final Runnable r) {
-          return new Thread(new Runnable() {
-            @Override public void run() {
-              Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);
-              r.run();
-            }
-          }, RestAdapter.IDLE_THREAD_NAME);
-        }
-      });
-    }
-
     @Override Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
-    }
-
-    @Override RestAdapter.Log defaultLog() {
-      return new AndroidLog("Retrofit");
-    }
-  }
+      return new Executor() {
+        private final Handler handler = new Handler(Looper.getMainLooper());
 
-  private static class AppEngine extends Base {
-    @Override Client.Provider defaultClient() {
-      final UrlFetchClient client = new UrlFetchClient();
-      return new Client.Provider() {
-        @Override public Client get() {
-          return client;
+        @Override public void execute(Runnable r) {
+          handler.post(r);
         }
       };
     }
   }
 
-  /** Determine whether or not OkHttp 1.6 or newer is present on the runtime classpath. */
-  private static boolean hasOkHttpOnClasspath() {
-    boolean okUrlFactory = false;
-    try {
-      Class.forName("com.squareup.okhttp.OkUrlFactory");
-      okUrlFactory = true;
-    } catch (ClassNotFoundException e) {
-    }
-
-    boolean okHttpClient = false;
-    try {
-      Class.forName("com.squareup.okhttp.OkHttpClient");
-      okHttpClient = true;
-    } catch (ClassNotFoundException e) {
-    }
-
-    if (okHttpClient != okUrlFactory) {
-      throw new RuntimeException(""
-          + "Retrofit detected an unsupported OkHttp on the classpath.\n"
-          + "To use OkHttp with this version of Retrofit, you'll need:\n"
-          + "1. com.squareup.okhttp:okhttp:1.6.0 (or newer)\n"
-          + "2. com.squareup.okhttp:okhttp-urlconnection:1.6.0 (or newer)\n"
-          + "Note that OkHttp 2.0.0+ is supported!");
-    }
-
-    return okHttpClient;
-  }
-
-  /**
-   * Indirection for OkHttp class to prevent VerifyErrors on Android 2.0 and earlier when the
-   * dependency is not present.
-   */
-  private static class OkClientInstantiator {
-    static Client instantiate() {
-      return new OkClient();
-    }
-  }
-
   private static boolean hasRxJavaOnClasspath() {
     try {
       Class.forName("rx.Observable");
diff --git a/retrofit/src/main/java/retrofit/Profiler.java b/retrofit/src/main/java/retrofit/Profiler.java
deleted file mode 100644
index 842d4504d..000000000
--- a/retrofit/src/main/java/retrofit/Profiler.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * A hook allowing clients to log HTTP method times and response status codes.
- *
- * @author Eric Burke (eric@squareup.com)
- */
-public interface Profiler<T> {
-
-  /**
-   * Invoked before an HTTP method call. The object returned by this method will be
-   * passed to {@link #afterCall} when the call returns.
-   * <p>
-   * This method gives implementers the opportunity to include information that may
-   * change during the server call in {@code afterCall} logic.
-   */
-  T beforeCall();
-
-  /**
-   * Invoked after an HTTP method completes. This is called from the
-   * RestAdapter's background thread.
-   *
-   * @param requestInfo information about the originating HTTP request.
-   * @param elapsedTime time in milliseconds it took the HTTP request to complete.
-   * @param statusCode response status code.
-   * @param beforeCallData the data returned by the corresponding {@link #beforeCall()}.
-   */
-  void afterCall(RequestInformation requestInfo, long elapsedTime, int statusCode,
-      T beforeCallData);
-
-  /** Information about the HTTP request. */
-  public static final class RequestInformation {
-    private final String method;
-    private final String baseUrl;
-    private final String relativePath;
-    private final long contentLength;
-    private final String contentType;
-
-    public RequestInformation(String method, String baseUrl, String relativePath,
-        long contentLength, String contentType) {
-      this.method = method;
-      this.baseUrl = baseUrl;
-      this.relativePath = relativePath;
-      this.contentLength = contentLength;
-      this.contentType = contentType;
-    }
-
-    /** Returns the HTTP method of the originating request. */
-    public String getMethod() {
-      return method;
-    }
-
-    /** Returns the URL to which the originating request was sent. */
-    public String getBaseUrl() {
-      return baseUrl;
-    }
-
-    /** Returns the path relative to the base URL to which the originating request was sent. */
-    public String getRelativePath() {
-      return relativePath;
-    }
-
-    /** Returns the number of bytes in the originating request. */
-    public long getContentLength() {
-      return contentLength;
-    }
-
-    /** Returns the content type header value of the originating request. */
-    public String getContentType() {
-      return contentType;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 5fa5127b3..d87332bec 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -15,55 +15,50 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.net.URLEncoder;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
-import retrofit.client.Header;
-import retrofit.client.Request;
+import okio.BufferedSink;
 import retrofit.converter.Converter;
-import retrofit.mime.FormUrlEncodedTypedOutput;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
+import retrofit.http.Body;
+import retrofit.http.Header;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
+  private static final Headers NO_HEADERS = Headers.of();
+
   private final Converter converter;
-  private final String[] paramNames;
-  private final RestMethodInfo.ParamUsage[] paramUsages;
+  private final Annotation[] paramAnnotations;
   private final String requestMethod;
-  private final boolean isSynchronous;
-  private final boolean isObservable;
+  private final boolean async;
   private final String apiUrl;
 
-  private final FormUrlEncodedTypedOutput formBody;
-  private final MultipartTypedOutput multipartBody;
-  private TypedOutput body;
+  private RequestBody body;
 
   private String relativeUrl;
   private StringBuilder queryParams;
-  private List<Header> headers;
+  private Headers.Builder headers;
   private String contentTypeHeader;
 
-  RequestBuilder(String apiUrl, RestMethodInfo methodInfo, Converter converter) {
+  RequestBuilder(String apiUrl, MethodInfo methodInfo, Converter converter) {
     this.apiUrl = apiUrl;
     this.converter = converter;
 
-    paramNames = methodInfo.requestParamNames;
-    paramUsages = methodInfo.requestParamUsage;
+    paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
-    isSynchronous = methodInfo.isSynchronous;
-    isObservable = methodInfo.isObservable;
+    async = methodInfo.executionType == MethodInfo.ExecutionType.ASYNC;
 
     if (methodInfo.headers != null) {
-      headers = new ArrayList<Header>(methodInfo.headers);
+      headers = methodInfo.headers.newBuilder();
     }
     contentTypeHeader = methodInfo.contentTypeHeader;
 
@@ -73,26 +68,6 @@
     if (requestQuery != null) {
       queryParams = new StringBuilder().append('?').append(requestQuery);
     }
-
-    switch (methodInfo.requestType) {
-      case FORM_URL_ENCODED:
-        formBody = new FormUrlEncodedTypedOutput();
-        multipartBody = null;
-        body = formBody;
-        break;
-      case MULTIPART:
-        formBody = null;
-        multipartBody = new MultipartTypedOutput();
-        body = multipartBody;
-        break;
-      case SIMPLE:
-        formBody = null;
-        multipartBody = null;
-        // If present, 'body' will be set in 'setArguments' call.
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
-    }
   }
 
   @Override public void addHeader(String name, String value) {
@@ -104,11 +79,11 @@
       return;
     }
 
-    List<Header> headers = this.headers;
+    Headers.Builder headers = this.headers;
     if (headers == null) {
-      this.headers = headers = new ArrayList<Header>(2);
+      this.headers = headers = new Headers.Builder();
     }
-    headers.add(new Header(name, value));
+    headers.add(name, value);
   }
 
   @Override public void addPathParam(String name, String value) {
@@ -145,14 +120,33 @@ private void addPathParam(String name, String value, boolean urlEncodeValue) {
   }
 
   @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, true);
+    addQueryParam(name, value, false, true);
   }
 
   @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false);
+    addQueryParam(name, value, false, false);
+  }
+
+  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
+    if (value instanceof Iterable) {
+      for (Object iterableValue : (Iterable<?>) value) {
+        if (iterableValue != null) { // Skip null values
+          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else if (value.getClass().isArray()) {
+      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+        Object arrayValue = Array.get(value, x);
+        if (arrayValue != null) { // Skip null values
+          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
+        }
+      }
+    } else {
+      addQueryParam(name, value.toString(), encodeName, encodeValue);
+    }
   }
 
-  private void addQueryParam(String name, String value, boolean urlEncodeValue) {
+  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
     if (name == null) {
       throw new IllegalArgumentException("Query param name must not be null.");
     }
@@ -160,15 +154,19 @@ private void addQueryParam(String name, String value, boolean urlEncodeValue) {
       throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
     }
     try {
-      if (urlEncodeValue) {
-        value = URLEncoder.encode(String.valueOf(value), "UTF-8");
-      }
       StringBuilder queryParams = this.queryParams;
       if (queryParams == null) {
         this.queryParams = queryParams = new StringBuilder();
       }
 
       queryParams.append(queryParams.length() > 0 ? '&' : '?');
+
+      if (encodeName) {
+        name = URLEncoder.encode(name, "UTF-8");
+      }
+      if (encodeValue) {
+        value = URLEncoder.encode(value, "UTF-8");
+      }
       queryParams.append(name).append('=').append(value);
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException(
@@ -176,150 +174,173 @@ private void addQueryParam(String name, String value, boolean urlEncodeValue) {
     }
   }
 
+  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
+      boolean encodeValues) {
+    for (Map.Entry<?, ?> entry : map.entrySet()) {
+      Object entryKey = entry.getKey();
+      if (entryKey == null) {
+        throw new IllegalArgumentException(
+            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
+      }
+      Object entryValue = entry.getValue();
+      if (entryValue != null) { // Skip null values.
+        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
+      }
+    }
+  }
+
   void setArguments(Object[] args) {
     if (args == null) {
       return;
     }
     int count = args.length;
-    if (!isSynchronous && !isObservable) {
+    if (async) {
       count -= 1;
     }
     for (int i = 0; i < count; i++) {
-      String name = paramNames[i];
       Object value = args[i];
-      RestMethodInfo.ParamUsage paramUsage = paramUsages[i];
-      switch (paramUsage) {
-        case PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                "Path parameter \"" + name + "\" value must not be null.");
-          }
-          addPathParam(name, value.toString());
-          break;
-        case ENCODED_PATH:
-          if (value == null) {
-            throw new IllegalArgumentException(
-                "Path parameter \"" + name + "\" value must not be null.");
-          }
-          addEncodedPathParam(name, value.toString());
-          break;
-        case QUERY:
-        case ENCODED_QUERY:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY;
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values
-                  addQueryParam(name, iterableValue.toString(), urlEncodeValue);
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values
-                  addQueryParam(name, arrayValue.toString(), urlEncodeValue);
-                }
-              }
-            } else {
-              addQueryParam(name, value.toString(), urlEncodeValue);
-            }
-          }
-          break;
-        case QUERY_MAP:
-        case ENCODED_QUERY_MAP:
-          if (value != null) { // Skip null values.
-            boolean urlEncodeValue = paramUsage == QUERY_MAP;
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                addQueryParam(entry.getKey().toString(), entryValue.toString(), urlEncodeValue);
-              }
-            }
-          }
-          break;
-        case HEADER:
-          if (value != null) { // Skip null values.
-            addHeader(name, value.toString());
-          }
-          break;
-        case FIELD:
-          if (value != null) { // Skip null values.
-            if (value instanceof Iterable) {
-              for (Object iterableValue : (Iterable<?>) value) {
-                if (iterableValue != null) { // Skip null values.
-                  formBody.addField(name, iterableValue.toString());
-                }
-              }
-            } else if (value.getClass().isArray()) {
-              for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-                Object arrayValue = Array.get(value, x);
-                if (arrayValue != null) { // Skip null values.
-                  formBody.addField(name, arrayValue.toString());
-                }
-              }
-            } else {
-              formBody.addField(name, value.toString());
-            }
-          }
-          break;
-        case FIELD_MAP:
-          if (value != null) { // Skip null values.
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                formBody.addField(entry.getKey().toString(), entryValue.toString());
+
+      Annotation annotation = paramAnnotations[i];
+      Class<? extends Annotation> annotationType = annotation.annotationType();
+      if (annotationType == Path.class) {
+        Path path = (Path) annotation;
+        String name = path.value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              "Path parameter \"" + name + "\" value must not be null.");
+        }
+        addPathParam(name, value.toString(), path.encode());
+      } else if (annotationType == Query.class) {
+        if (value != null) { // Skip null values.
+          Query query = (Query) annotation;
+          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
+        }
+      } else if (annotationType == QueryMap.class) {
+        if (value != null) { // Skip null values.
+          QueryMap queryMap = (QueryMap) annotation;
+          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
+        }
+      } else if (annotationType == Header.class) {
+        if (value != null) { // Skip null values.
+          String name = ((Header) annotation).value();
+          if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+              if (iterableValue != null) { // Skip null values.
+                addHeader(name, iterableValue.toString());
               }
             }
-          }
-          break;
-        case PART:
-          if (value != null) { // Skip null values.
-            if (value instanceof TypedOutput) {
-              multipartBody.addPart(name, (TypedOutput) value);
-            } else if (value instanceof String) {
-              multipartBody.addPart(name, new TypedString((String) value));
-            } else {
-              multipartBody.addPart(name, converter.toBody(value));
-            }
-          }
-          break;
-        case PART_MAP:
-          if (value != null) { // Skip null values.
-            for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-              String entryName = entry.getKey().toString();
-              Object entryValue = entry.getValue();
-              if (entryValue != null) { // Skip null values.
-                if (entryValue instanceof TypedOutput) {
-                  multipartBody.addPart(entryName, (TypedOutput) entryValue);
-                } else if (entryValue instanceof String) {
-                  multipartBody.addPart(entryName, new TypedString((String) entryValue));
-                } else {
-                  multipartBody.addPart(entryName, converter.toBody(entryValue));
-                }
+          } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+              Object arrayValue = Array.get(value, x);
+              if (arrayValue != null) { // Skip null values.
+                addHeader(name, arrayValue.toString());
               }
             }
-          }
-          break;
-        case BODY:
-          if (value == null) {
-            throw new IllegalArgumentException("Body parameter value must not be null.");
-          }
-          if (value instanceof TypedOutput) {
-            body = (TypedOutput) value;
           } else {
-            body = converter.toBody(value);
+            addHeader(name, value.toString());
           }
-          break;
-        default:
-          throw new IllegalArgumentException("Unknown parameter usage: " + paramUsage);
+        }
+      // TODO bring back form url encoding!
+      //} else if (annotationType == Field.class) {
+      //  if (value != null) { // Skip null values.
+      //    Field field = (Field) annotation;
+      //    String name = field.value();
+      //    boolean encodeName = field.encodeName();
+      //    boolean encodeValue = field.encodeValue();
+      //    if (value instanceof Iterable) {
+      //      for (Object iterableValue : (Iterable<?>) value) {
+      //        if (iterableValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else if (value.getClass().isArray()) {
+      //      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+      //        Object arrayValue = Array.get(value, x);
+      //        if (arrayValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else {
+      //      formBody.addField(name, encodeName, value.toString(), encodeValue);
+      //    }
+      //  }
+      //} else if (annotationType == FieldMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    FieldMap fieldMap = (FieldMap) annotation;
+      //    boolean encodeNames = fieldMap.encodeNames();
+      //    boolean encodeValues = fieldMap.encodeValues();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " field map contained null key.");
+      //      }
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
+      //            encodeValues);
+      //      }
+      //    }
+      //  }
+      // TODO bring back multipart!
+      //} else if (annotationType == Part.class) {
+      //  if (value != null) { // Skip null values.
+      //    String name = ((Part) annotation).value();
+      //    String transferEncoding = ((Part) annotation).encoding();
+      //    if (value instanceof RequestBody) {
+      //      multipartBody.addPart((RequestBody) value);
+      //      multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+      //    } else if (value instanceof String) {
+      //      multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+      //    } else {
+      //      multipartBody.addPart(name, transferEncoding,
+      //          converter.toBody(value, value.getClass()));
+      //    }
+      //  }
+      //} else if (annotationType == PartMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    String transferEncoding = ((PartMap) annotation).encoding();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " part map contained null key.");
+      //      }
+      //      String entryName = entryKey.toString();
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        if (entryValue instanceof TypedOutput) {
+      //          multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+      //        } else if (entryValue instanceof String) {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              new TypedString((String) entryValue));
+      //        } else {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              converter.toBody(entryValue, entryValue.getClass()));
+      //        }
+      //      }
+      //    }
+      //  }
+      } else if (annotationType == Body.class) {
+        if (value == null) {
+          throw new IllegalArgumentException("Body parameter value must not be null.");
+        }
+        if (value instanceof RequestBody) {
+          body = (RequestBody) value;
+        } else {
+          body = converter.toBody(value, value.getClass());
+        }
+      } else {
+        throw new IllegalArgumentException(
+            "Unknown annotation: " + annotationType.getCanonicalName());
       }
     }
   }
 
-  Request build() throws UnsupportedEncodingException {
-    if (multipartBody != null && multipartBody.getPartCount() == 0) {
-      throw new IllegalStateException("Multipart requests must contain at least one part.");
-    }
+  Request build() {
+    //if (multipartBody != null && multipartBody.getPartCount() == 0) {
+    //  throw new IllegalStateException("Multipart requests must contain at least one part.");
+    //}
 
     String apiUrl = this.apiUrl;
     StringBuilder url = new StringBuilder(apiUrl);
@@ -335,37 +356,47 @@ Request build() throws UnsupportedEncodingException {
       url.append(queryParams);
     }
 
-    TypedOutput body = this.body;
-    if (body != null && contentTypeHeader != null) {
-      body = new MimeOverridingTypedOutput(body, contentTypeHeader);
+    RequestBody body = this.body;
+    Headers.Builder headerBuilder = this.headers;
+    if (contentTypeHeader != null) {
+      if (body != null) {
+        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
+      } else {
+        if (headerBuilder == null) {
+          headerBuilder = new Headers.Builder();
+        }
+        headerBuilder.add("Content-Type", contentTypeHeader);
+      }
     }
 
-    return new Request(requestMethod, url.toString(), headers, body);
+    Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
+
+    return new Request.Builder()
+        .url(url.toString())
+        .method(requestMethod, body)
+        .headers(headers)
+        .build();
   }
 
-  private static class MimeOverridingTypedOutput implements TypedOutput {
-    private final TypedOutput delegate;
-    private final String mimeType;
+  private static class MediaTypeOverridingRequestBody extends RequestBody {
+    private final RequestBody delegate;
+    private final MediaType mediaType;
 
-    MimeOverridingTypedOutput(TypedOutput delegate, String mimeType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
       this.delegate = delegate;
-      this.mimeType = mimeType;
-    }
-
-    @Override public String fileName() {
-      return delegate.fileName();
+      this.mediaType = MediaType.parse(mediaType);
     }
 
-    @Override public String mimeType() {
-      return mimeType;
+    @Override public MediaType contentType() {
+      return mediaType;
     }
 
-    @Override public long length() {
-      return delegate.length();
+    @Override public long contentLength() throws IOException {
+      return delegate.contentLength();
     }
 
-    @Override public void writeTo(OutputStream out) throws IOException {
-      delegate.writeTo(out);
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      delegate.writeTo(sink);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptor.java b/retrofit/src/main/java/retrofit/RequestInterceptor.java
index 5fa484b35..406014a99 100644
--- a/retrofit/src/main/java/retrofit/RequestInterceptor.java
+++ b/retrofit/src/main/java/retrofit/RequestInterceptor.java
@@ -17,7 +17,7 @@
 
     /**
      * Add a path parameter replacement without first URI encoding. This works exactly like a
-     * {@link retrofit.http.EncodedPath &#64;EncodedPath}-annotated method argument.
+     * {@link retrofit.http.Path &#64;Path}-annotated method argument with {@code encode=false}.
      */
     void addEncodedPathParam(String name, String value);
 
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptorTape.java b/retrofit/src/main/java/retrofit/RequestInterceptorTape.java
deleted file mode 100644
index d53d8f4ff..000000000
--- a/retrofit/src/main/java/retrofit/RequestInterceptorTape.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package retrofit;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Records methods called against it as a RequestFacade and replays them when called as a
- * RequestInterceptor.
- */
-final class RequestInterceptorTape implements RequestInterceptor.RequestFacade, RequestInterceptor {
-
-  private final List<CommandWithParams> tape = new ArrayList<CommandWithParams>();
-
-  @Override public void addHeader(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_HEADER, name, value));
-  }
-
-  @Override public void addPathParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_PATH_PARAM, name, value));
-  }
-
-  @Override public void addEncodedPathParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_ENCODED_PATH_PARAM, name, value));
-  }
-
-  @Override public void addQueryParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_QUERY_PARAM, name, value));
-  }
-
-  @Override public void addEncodedQueryParam(String name, String value) {
-    tape.add(new CommandWithParams(Command.ADD_ENCODED_QUERY_PARAM, name, value));
-  }
-
-  @Override public void intercept(RequestFacade request) {
-    for (CommandWithParams cwp : tape) {
-      cwp.command.intercept(request, cwp.name, cwp.value);
-    }
-  }
-
-  private enum Command {
-    ADD_HEADER {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addHeader(name, value);
-      }
-    },
-    ADD_PATH_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addPathParam(name, value);
-      }
-    },
-    ADD_ENCODED_PATH_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addEncodedPathParam(name, value);
-      }
-    },
-    ADD_QUERY_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addQueryParam(name, value);
-      }
-    },
-    ADD_ENCODED_QUERY_PARAM {
-      @Override
-      public void intercept(RequestFacade facade, String name, String value) {
-        facade.addEncodedQueryParam(name, value);
-      }
-    };
-
-    abstract void intercept(RequestFacade facade, String name, String value);
-  }
-
-  private static final class CommandWithParams {
-    final Command command;
-    final String name;
-    final String value;
-
-    CommandWithParams(Command command, String name, String value) {
-      this.command = command;
-      this.name = name;
-      this.value = value;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/ResponseCallback.java b/retrofit/src/main/java/retrofit/ResponseCallback.java
deleted file mode 100644
index 9f0aa08b0..000000000
--- a/retrofit/src/main/java/retrofit/ResponseCallback.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import retrofit.client.Response;
-
-/**
- * An extension of {@link Callback} which returns only {@link Response} object
- * in {@link Callback#success(Object, retrofit.client.Response)} method.
- */
-public abstract class ResponseCallback implements Callback<Response> {
-
-  @Override public void success(Response response, Response response2) {
-    success(response);
-  }
-
-  /** Successful HTTP response. */
-  public abstract void success(Response response);
-}
diff --git a/retrofit/src/main/java/retrofit/ResponseWrapper.java b/retrofit/src/main/java/retrofit/ResponseWrapper.java
deleted file mode 100644
index 65b881367..000000000
--- a/retrofit/src/main/java/retrofit/ResponseWrapper.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import retrofit.client.Response;
-
-/**
- * A wrapper that holds the {@link Response} and {@link retrofit.converter.Converter} response to
- * be used by the {@link CallbackRunnable} for success method calls on {@link Callback}.
- *
- * @author JJ Ford (jj.n.ford@gmail.com)
- */
-final class ResponseWrapper {
-  final Response response;
-  final Object responseBody;
-
-  ResponseWrapper(Response response, Object responseBody) {
-    this.response = response;
-    this.responseBody = responseBody;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 19e05298d..afd1ff400 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -15,9 +15,12 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
@@ -25,18 +28,9 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import retrofit.Profiler.RequestInformation;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
 import retrofit.converter.Converter;
-import retrofit.mime.MimeUtil;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -46,17 +40,14 @@
  * <p>
  * The relative path for a given method is obtained from an annotation on the method describing
  * the request type. The built-in methods are {@link retrofit.http.GET GET},
- * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.HEAD HEAD},
- * and {@link retrofit.http.DELETE DELETE}. You can define your own HTTP method by creating an
- * annotation that takes a {code String} value and itself is annotated with
- * {@link retrofit.http.RestMethod @RestMethod}.
+ * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.POST PATCH},
+ * {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a custom
+ * HTTP method with {@link HTTP @HTTP}.
  * <p>
  * Method parameters can be used to replace parts of the URL by annotating them with
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
- * use {@link retrofit.http.EncodedPath @EncodedPath} or
- * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
+ * {@link retrofit.http.Query @Query}.
  * <p>
  * HTTP requests happen in one of two ways:
  * <ul>
@@ -72,9 +63,8 @@
  * <p>
  * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
  * will be converted to request representation by a call to
- * {@link retrofit.converter.Converter#toBody(Object) toBody} on the supplied
- * {@link retrofit.converter.Converter Converter} for this instance. The body can also be a
- * {@link TypedOutput} where it will be used directly.
+ * {@link retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type) toBody}
+ * on the supplied {@link retrofit.converter.Converter Converter} for this instance.
  * <p>
  * Alternative request body formats are supported by method annotations and corresponding parameter
  * annotations:
@@ -107,84 +97,26 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public class RestAdapter {
-  static final String THREAD_PREFIX = "Retrofit-";
-  static final String IDLE_THREAD_NAME = THREAD_PREFIX + "Idle";
+  private final Map<Class<?>, Map<Method, MethodInfo>> serviceMethodInfoCache =
+      new LinkedHashMap<Class<?>, Map<Method, MethodInfo>>();
 
-  /** Simple logging abstraction for debug messages. */
-  public interface Log {
-    /** Log a debug message to the appropriate console. */
-    void log(String message);
-
-    /** A {@link Log} implementation which does not log anything. */
-    Log NONE = new Log() {
-      @Override public void log(String message) {
-      }
-    };
-  }
-
-  /** Controls the level of logging. */
-  public enum LogLevel {
-    /** No logging. */
-    NONE,
-    /** Log only the request method and URL and the response status code and execution time. */
-    BASIC,
-    /** Log the basic information along with request and response headers. */
-    HEADERS,
-    /**
-     * Log the headers, body, and metadata for both requests and responses.
-     * <p>
-     * Note: This requires that the entire request and response body be buffered in memory!
-     */
-    FULL;
-
-    public boolean log() {
-      return this != NONE;
-    }
-  }
-
-  private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
-
-  final Endpoint server;
-  final Executor httpExecutor;
+  final Endpoint endpoint;
   final Executor callbackExecutor;
   final RequestInterceptor requestInterceptor;
   final Converter converter;
-  final Log log;
   final ErrorHandler errorHandler;
 
-  private final Client.Provider clientProvider;
-  private final Profiler profiler;
+  private final OkHttpClient client;
   private RxSupport rxSupport;
 
-  volatile LogLevel logLevel;
-
-  private RestAdapter(Endpoint server, Client.Provider clientProvider, Executor httpExecutor,
-      Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
-      Profiler profiler, ErrorHandler errorHandler, Log log, LogLevel logLevel) {
-    this.server = server;
-    this.clientProvider = clientProvider;
-    this.httpExecutor = httpExecutor;
+  private RestAdapter(Endpoint endpoint, OkHttpClient client, Executor callbackExecutor,
+      RequestInterceptor requestInterceptor, Converter converter, ErrorHandler errorHandler) {
+    this.endpoint = endpoint;
+    this.client = client;
     this.callbackExecutor = callbackExecutor;
     this.requestInterceptor = requestInterceptor;
     this.converter = converter;
-    this.profiler = profiler;
     this.errorHandler = errorHandler;
-    this.log = log;
-    this.logLevel = logLevel;
-  }
-
-  /** Change the level of logging. */
-  public void setLogLevel(LogLevel loglevel) {
-    if (logLevel == null) {
-      throw new NullPointerException("Log level may not be null.");
-    }
-    this.logLevel = loglevel;
-  }
-
-  /** The current logging level. */
-  public LogLevel getLogLevel() {
-    return logLevel;
   }
 
   /** Create an implementation of the API defined by the specified {@code service} interface. */
@@ -195,22 +127,22 @@ public LogLevel getLogLevel() {
         new RestHandler(getMethodInfoCache(service)));
   }
 
-  Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
+  Map<Method, MethodInfo> getMethodInfoCache(Class<?> service) {
     synchronized (serviceMethodInfoCache) {
-      Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
+      Map<Method, MethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
       if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
+        methodInfoCache = new LinkedHashMap<Method, MethodInfo>();
         serviceMethodInfoCache.put(service, methodInfoCache);
       }
       return methodInfoCache;
     }
   }
 
-  static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
+  static MethodInfo getMethodInfo(Map<Method, MethodInfo> cache, Method method) {
     synchronized (cache) {
-      RestMethodInfo methodInfo = cache.get(method);
+      MethodInfo methodInfo = cache.get(method);
       if (methodInfo == null) {
-        methodInfo = new RestMethodInfo(method);
+        methodInfo = new MethodInfo(method);
         cache.put(method, methodInfo);
       }
       return methodInfo;
@@ -218,9 +150,9 @@ static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method me
   }
 
   private class RestHandler implements InvocationHandler {
-    private final Map<Method, RestMethodInfo> methodDetailsCache;
+    private final Map<Method, MethodInfo> methodDetailsCache;
 
-    RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
+    RestHandler(Map<Method, MethodInfo> methodDetailsCache) {
       this.methodDetailsCache = methodDetailsCache;
     }
 
@@ -232,318 +164,205 @@ static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method me
         return method.invoke(this, args);
       }
 
-      // Load or create the details cache for the current method.
-      final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-
-      if (methodInfo.isSynchronous) {
-        try {
-          return invokeRequest(requestInterceptor, methodInfo, args);
-        } catch (RetrofitError error) {
-          Throwable newError = errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
+      MethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
+      Request request = createRequest(methodInfo, args);
+      switch (methodInfo.executionType) {
+        case SYNC:
+          return invokeSync(methodInfo, request);
+        case ASYNC:
+          invokeAsync(methodInfo, request, (Callback) args[args.length - 1]);
+          return null; // Async has void return type.
+        case RX:
+          return invokeRx(methodInfo, request);
+        default:
+          throw new IllegalStateException("Unknown response type: " + methodInfo.executionType);
       }
+    }
 
-      if (httpExecutor == null || callbackExecutor == null) {
-        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
+    private Object invokeSync(MethodInfo methodInfo, Request request) throws Throwable {
+      try {
+        Response response = client.newCall(request).execute();
+        return createResult(methodInfo, response);
+      } catch (IOException e) {
+        throw handleError(RetrofitError.networkFailure(request.urlString(), e));
+      } catch (RetrofitError error) {
+        throw handleError(error);
       }
+    }
 
-      if (methodInfo.isObservable) {
-        if (rxSupport == null) {
-          if (Platform.HAS_RX_JAVA) {
-            rxSupport = new RxSupport(httpExecutor, errorHandler, requestInterceptor);
-          } else {
-            throw new IllegalStateException("Observable method found but no RxJava on classpath.");
-          }
-        }
-        return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-          @Override public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
-            return (ResponseWrapper) invokeRequest(requestInterceptor, methodInfo, args);
-          }
-        });
+    private Throwable handleError(RetrofitError error) {
+      Throwable throwable = errorHandler.handleError(error);
+      if (throwable == null) {
+        return new IllegalStateException("Error handler returned null for wrapped exception.",
+            error);
       }
-
-      // Apply the interceptor synchronously, recording the interception so we can replay it later.
-      // This way we still defer argument serialization to the background thread.
-      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-      requestInterceptor.intercept(interceptorTape);
-
-      Callback<?> callback = (Callback<?>) args[args.length - 1];
-      httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor, errorHandler) {
-        @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
+      return throwable;
     }
 
-    /**
-     * Execute an HTTP request.
-     *
-     * @return HTTP response object of specified {@code type} or {@code null}.
-     * @throws RetrofitError if any error occurs during the HTTP request.
-     */
-    private Object invokeRequest(RequestInterceptor requestInterceptor, RestMethodInfo methodInfo,
-        Object[] args) {
-      String url = null;
-      try {
-        methodInfo.init(); // Ensure all relevant method information has been loaded.
-
-        String serverUrl = server.getUrl();
-        RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
-        requestBuilder.setArguments(args);
-
-        requestInterceptor.intercept(requestBuilder);
-
-        Request request = requestBuilder.build();
-        url = request.getUrl();
-
-        if (!methodInfo.isSynchronous) {
-          // If we are executing asynchronously then update the current thread with a useful name.
-          Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
-        }
-
-        if (logLevel.log()) {
-          // Log the request data.
-          request = logAndReplaceRequest("HTTP", request);
-        }
-
-        Object profilerObject = null;
-        if (profiler != null) {
-          profilerObject = profiler.beforeCall();
+    private void invokeAsync(final MethodInfo methodInfo, final Request request,
+        final Callback callback) {
+      Call call = client.newCall(request);
+      call.enqueue(new com.squareup.okhttp.Callback() {
+        @Override public void onFailure(Request request, IOException e) {
+          callFailure(callback, RetrofitError.networkFailure(request.urlString(), e));
         }
 
-        long start = System.nanoTime();
-        Response response = clientProvider.get().execute(request);
-        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
-
-        int statusCode = response.getStatus();
-        if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(serverUrl, methodInfo, request);
-          //noinspection unchecked
-          profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
+        @Override public void onResponse(Response response) {
+          try {
+            Object result = createResult(methodInfo, response);
+            callResponse(callback, result, response);
+          } catch (RetrofitError error) {
+            callFailure(callback, error);
+          }
         }
+      });
+    }
 
-        if (logLevel.log()) {
-          // Log the response data.
-          response = logAndReplaceResponse(url, response, elapsedTime);
+    private Object invokeRx(final MethodInfo methodInfo, final Request request) {
+      if (rxSupport == null) {
+        if (Platform.HAS_RX_JAVA) {
+          rxSupport = new RxSupport();
+        } else {
+          throw new IllegalStateException("Found Observable return type but RxJava not present.");
         }
-
-        Type type = methodInfo.responseObjectType;
-
-        if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
-          // Caller requested the raw Response object directly.
-          if (type.equals(Response.class)) {
-            if (!methodInfo.isStreaming) {
-              // Read the entire stream and replace with one backed by a byte[].
-              response = Utils.readBodyToBytesIfNecessary(response);
-            }
-
-            if (methodInfo.isSynchronous) {
-              return response;
-            }
-            return new ResponseWrapper(response, response);
-          }
-
-          TypedInput body = response.getBody();
-          if (body == null) {
-            if (methodInfo.isSynchronous) {
-              return null;
+      }
+      return rxSupport.createRequestObservable(new RxSupport.Invoker() {
+        @Override public void invoke(final Callback callback) {
+          Call call = client.newCall(request);
+          call.enqueue(new com.squareup.okhttp.Callback() {
+            @Override public void onFailure(Request request, IOException e) {
+              callback.next(RetrofitError.networkFailure(request.urlString(), e));
             }
-            return new ResponseWrapper(response, null);
-          }
 
-          ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
-          try {
-            Object convert = converter.fromBody(wrapped, type);
-            if (methodInfo.isSynchronous) {
-              return convert;
+            @Override public void onResponse(Response response) {
+              try {
+                Object result = createResult(methodInfo, response);
+                callback.next(result);
+              } catch (RetrofitError error) {
+                callback.error(handleError(error));
+              }
             }
-            return new ResponseWrapper(response, convert);
-          } catch (ConversionException e) {
-            // If the underlying input stream threw an exception, propagate that rather than
-            // indicating that it was a conversion exception.
-            if (wrapped.threwException()) {
-              throw wrapped.getThrownException();
-            }
-
-            // The response body was partially read by the converter. Replace it with null.
-            response = Utils.replaceResponseBody(response, null);
+          });
 
-            throw RetrofitError.conversionError(url, response, converter, type, e);
-          }
         }
+      });
+    }
 
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(url, response, converter, type);
-      } catch (RetrofitError e) {
-        throw e; // Pass through our own errors.
+    /**
+     * Create the object to return to the caller for a response.
+     *
+     * @throws RetrofitError if any HTTP, network, or unexpected errors occurred.
+     */
+    private Object createResult(MethodInfo methodInfo, Response response) {
+      try {
+        return parseResult(methodInfo, response);
+      } catch (RetrofitError error) {
+        throw error; // Let our own errors pass through.
       } catch (IOException e) {
-        if (logLevel.log()) {
-          logException(e, url);
-        }
-        throw RetrofitError.networkError(url, e);
+        throw RetrofitError.networkError(response, e);
       } catch (Throwable t) {
-        if (logLevel.log()) {
-          logException(t, url);
-        }
-        throw RetrofitError.unexpectedError(url, t);
-      } finally {
-        if (!methodInfo.isSynchronous) {
-          Thread.currentThread().setName(IDLE_THREAD_NAME);
-        }
+        throw RetrofitError.unexpectedError(response, t);
       }
     }
-  }
 
-  /** Log request headers and body. Consumes request body and returns identical replacement. */
-  Request logAndReplaceRequest(String name, Request request) throws IOException {
-    log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
+    /**
+     * Parse the object to return to the caller from a response.
+     *
+     * @throws RetrofitError on non-2xx response codes (kind = HTTP).
+     * @throws IOException on network problems reading the response data.
+     * @throws RuntimeException on malformed response data.
+     */
+    private Object parseResult(MethodInfo methodInfo, Response response)
+        throws IOException {
+      Type type = methodInfo.responseObjectType;
 
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : request.getHeaders()) {
-        log.log(header.toString());
+      int statusCode = response.code();
+      if (statusCode < 200 || statusCode >= 300) {
+        response = Utils.readBodyToBytesIfNecessary(response);
+        throw RetrofitError.httpError(response, converter, type);
       }
 
-      String bodySize = "no";
-      TypedOutput body = request.getBody();
-      if (body != null) {
-        String bodyMime = body.mimeType();
-        if (bodyMime != null) {
-          log.log("Content-Type: " + bodyMime);
-        }
-
-        long bodyLength = body.length();
-        bodySize = bodyLength + "-byte";
-        if (bodyLength != -1) {
-          log.log("Content-Length: " + bodyLength);
+      if (type.equals(Response.class)) {
+        if (!methodInfo.isStreaming) {
+          // Read the entire stream and replace with one backed by a byte[].
+          response = Utils.readBodyToBytesIfNecessary(response);
         }
+        return response;
+      }
 
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!request.getHeaders().isEmpty()) {
-            log.log("");
-          }
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body to we can log it and replace the original response
-            request = Utils.readBodyToBytesIfNecessary(request);
-            body = request.getBody();
-          }
+      ResponseBody body = response.body();
+      if (body == null) {
+        return null;
+      }
 
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          String bodyCharset = MimeUtil.parseCharset(body.mimeType());
-          log.log(new String(bodyBytes, bodyCharset));
+      ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(body);
+      try {
+        return converter.fromBody(wrapped, type);
+      } catch (RuntimeException e) {
+        // If the underlying input stream threw an exception, propagate that rather than
+        // indicating that it was a conversion exception.
+        if (wrapped.threwException()) {
+          throw wrapped.getThrownException();
         }
+        throw e;
       }
-
-      log.log(String.format("---> END %s (%s body)", name, bodySize));
     }
 
-    return request;
-  }
-
-  /** Log response headers and body. Consumes response body and returns identical replacement. */
-  private Response logAndReplaceResponse(String url, Response response, long elapsedTime)
-      throws IOException {
-    log.log(String.format("<--- HTTP %s %s (%sms)", response.getStatus(), url, elapsedTime));
-
-    if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
-      for (Header header : response.getHeaders()) {
-        log.log(header.toString());
-      }
-
-      long bodySize = 0;
-      TypedInput body = response.getBody();
-      if (body != null) {
-        bodySize = body.length();
-
-        if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
-          if (!response.getHeaders().isEmpty()) {
-            log.log("");
-          }
-
-          if (!(body instanceof TypedByteArray)) {
-            // Read the entire response body so we can log it and replace the original response
-            response = Utils.readBodyToBytesIfNecessary(response);
-            body = response.getBody();
-          }
+    private void callResponse(final Callback callback, final Object result,
+        final Response response) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          callback.success(result, response);
+        }
+      });
+    }
 
-          byte[] bodyBytes = ((TypedByteArray) body).getBytes();
-          bodySize = bodyBytes.length;
-          String bodyMime = body.mimeType();
-          String bodyCharset = MimeUtil.parseCharset(bodyMime);
-          log.log(new String(bodyBytes, bodyCharset));
+    private void callFailure(final Callback callback, RetrofitError error) {
+      Throwable throwable = handleError(error);
+      if (throwable != error) {
+        Response response = error.getResponse();
+        if (response != null) {
+          error = RetrofitError.unexpectedError(response, throwable);
+        } else {
+          error = RetrofitError.unexpectedError(error.getUrl(), throwable);
         }
       }
-
-      log.log(String.format("<--- END HTTP (%s-byte body)", bodySize));
+      final RetrofitError finalError = error;
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          callback.failure(finalError);
+        }
+      });
     }
 
-    return response;
-  }
-
-  /** Log an exception that occurred during the processing of a request or response. */
-  void logException(Throwable t, String url) {
-    log.log(String.format("---- ERROR %s", url != null ? url : ""));
-    StringWriter sw = new StringWriter();
-    t.printStackTrace(new PrintWriter(sw));
-    log.log(sw.toString());
-    log.log("---- END ERROR");
-  }
+    private Request createRequest(MethodInfo methodInfo, Object[] args) {
+      String serverUrl = endpoint.url();
+      RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
+      requestBuilder.setArguments(args);
 
-  private static Profiler.RequestInformation getRequestInfo(String serverUrl,
-      RestMethodInfo methodDetails, Request request) {
-    long contentLength = 0;
-    String contentType = null;
+      requestInterceptor.intercept(requestBuilder);
 
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      contentLength = body.length();
-      contentType = body.mimeType();
+      return requestBuilder.build();
     }
-
-    return new Profiler.RequestInformation(methodDetails.requestMethod, serverUrl,
-        methodDetails.requestUrl, contentLength, contentType);
   }
 
   /**
    * Build a new {@link RestAdapter}.
    * <p>
-   * Calling the following methods is required before calling {@link #build()}:
-   * <ul>
-   * <li>{@link #setEndpoint(Endpoint)}</li>
-   * <li>{@link #setClient(Client.Provider)}</li>
-   * <li>{@link #setConverter(Converter)}</li>
-   * </ul>
-   * <p>
-   * If you are using asynchronous execution (i.e., with {@link Callback Callbacks}) the following
-   * is also required:
-   * <ul>
-   * <li>{@link #setExecutors(java.util.concurrent.Executor, java.util.concurrent.Executor)}</li>
-   * </ul>
+   * Calling {@link #setEndpoint} is required before calling {@link #build()}. All other methods
+   * are optional.
    */
   public static class Builder {
     private Endpoint endpoint;
-    private Client.Provider clientProvider;
-    private Executor httpExecutor;
+    private OkHttpClient client;
     private Executor callbackExecutor;
     private RequestInterceptor requestInterceptor;
     private Converter converter;
-    private Profiler profiler;
     private ErrorHandler errorHandler;
-    private Log log;
-    private LogLevel logLevel = LogLevel.NONE;
 
     /** API endpoint URL. */
-    public Builder setEndpoint(String endpoint) {
-      if (endpoint == null || endpoint.trim().length() == 0) {
-        throw new NullPointerException("Endpoint may not be blank.");
-      }
-      this.endpoint = Endpoints.newFixedEndpoint(endpoint);
-      return this;
+    public Builder setEndpoint(String url) {
+       return setEndpoint(Endpoint.createFixed(url));
     }
 
     /** API endpoint. */
@@ -556,42 +375,22 @@ public Builder setEndpoint(Endpoint endpoint) {
     }
 
     /** The HTTP client used for requests. */
-    public Builder setClient(final Client client) {
+    public Builder setClient(OkHttpClient client) {
       if (client == null) {
         throw new NullPointerException("Client may not be null.");
       }
-      return setClient(new Client.Provider() {
-        @Override public Client get() {
-          return client;
-        }
-      });
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(Client.Provider clientProvider) {
-      if (clientProvider == null) {
-        throw new NullPointerException("Client provider may not be null.");
-      }
-      this.clientProvider = clientProvider;
+      this.client = client;
       return this;
     }
 
     /**
-     * Executors used for asynchronous HTTP client downloads and callbacks.
-     *
-     * @param httpExecutor Executor on which HTTP client calls will be made.
-     * @param callbackExecutor Executor on which any {@link Callback} methods will be invoked. If
-     * this argument is {@code null} then callback methods will be run on the same thread as the
-     * HTTP client.
+     * Executor on which any {@link Callback} methods will be invoked. If this argument is
+     * {@code null} then callback methods will be run on the same thread as the HTTP client.
      */
-    public Builder setExecutors(Executor httpExecutor, Executor callbackExecutor) {
-      if (httpExecutor == null) {
-        throw new NullPointerException("HTTP executor may not be null.");
-      }
+    public Builder setCallbackExecutor(Executor callbackExecutor) {
       if (callbackExecutor == null) {
         callbackExecutor = new Utils.SynchronousExecutor();
       }
-      this.httpExecutor = httpExecutor;
       this.callbackExecutor = callbackExecutor;
       return this;
     }
@@ -614,15 +413,6 @@ public Builder setConverter(Converter converter) {
       return this;
     }
 
-    /** Set the profiler used to measure requests. */
-    public Builder setProfiler(Profiler profiler) {
-      if (profiler == null) {
-        throw new NullPointerException("Profiler may not be null.");
-      }
-      this.profiler = profiler;
-      return this;
-    }
-
     /**
      * The error handler allows you to customize the type of exception thrown for errors on
      * synchronous requests.
@@ -634,44 +424,22 @@ public Builder setErrorHandler(ErrorHandler errorHandler) {
       this.errorHandler = errorHandler;
       return this;
     }
-
-    /** Configure debug logging mechanism. */
-    public Builder setLog(Log log) {
-      if (log == null) {
-        throw new NullPointerException("Log may not be null.");
-      }
-      this.log = log;
-      return this;
-    }
-
-    /** Change the level of logging. */
-    public Builder setLogLevel(LogLevel logLevel) {
-      if (logLevel == null) {
-        throw new NullPointerException("Log level may not be null.");
-      }
-      this.logLevel = logLevel;
-      return this;
-    }
-
     /** Create the {@link RestAdapter} instances. */
     public RestAdapter build() {
       if (endpoint == null) {
         throw new IllegalArgumentException("Endpoint may not be null.");
       }
       ensureSaneDefaults();
-      return new RestAdapter(endpoint, clientProvider, httpExecutor, callbackExecutor,
-          requestInterceptor, converter, profiler, errorHandler, log, logLevel);
+      return new RestAdapter(endpoint, client, callbackExecutor, requestInterceptor, converter,
+          errorHandler);
     }
 
     private void ensureSaneDefaults() {
       if (converter == null) {
         converter = Platform.get().defaultConverter();
       }
-      if (clientProvider == null) {
-        clientProvider = Platform.get().defaultClient();
-      }
-      if (httpExecutor == null) {
-        httpExecutor = Platform.get().defaultHttpExecutor();
+      if (client == null) {
+        client = Platform.get().defaultClient();
       }
       if (callbackExecutor == null) {
         callbackExecutor = Platform.get().defaultCallbackExecutor();
@@ -679,9 +447,6 @@ private void ensureSaneDefaults() {
       if (errorHandler == null) {
         errorHandler = ErrorHandler.DEFAULT;
       }
-      if (log == null) {
-        log = Platform.get().defaultLog();
-      }
       if (requestInterceptor == null) {
         requestInterceptor = RequestInterceptor.NONE;
       }
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index 7b923e8f3..f604ac583 100644
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -15,48 +15,68 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
 import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
 
 public class RetrofitError extends RuntimeException {
-  public static RetrofitError networkError(String url, IOException exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, true, exception);
+  public static RetrofitError networkFailure(String url, IOException exception) {
+    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.NETWORK,
+        exception);
   }
 
-  public static RetrofitError conversionError(String url, Response response, Converter converter,
-      Type successType, ConversionException exception) {
-    return new RetrofitError(exception.getMessage(), url, response, converter, successType, false,
-        exception);
+  public static RetrofitError networkError(Response response, IOException exception) {
+    response = response.newBuilder().body(null).build(); // Remove any body.
+    return new RetrofitError(exception.getMessage(), response.request().urlString(), null, null,
+        null, Kind.NETWORK, exception);
+  }
+
+  public static RetrofitError httpError(Response response, Converter converter, Type successType) {
+    String message = response.code() + " " + response.message();
+    return new RetrofitError(message, response.request().urlString(), response, converter,
+        successType, Kind.HTTP, null);
   }
 
-  public static RetrofitError httpError(String url, Response response, Converter converter,
-      Type successType) {
-    String message = response.getStatus() + " " + response.getReason();
-    return new RetrofitError(message, url, response, converter, successType, false, null);
+  public static RetrofitError unexpectedError(Response response, Throwable exception) {
+    response = response.newBuilder().body(null).build(); // Remove any body.
+    return new RetrofitError(exception.getMessage(), response.request().urlString(), response,
+        null, null, Kind.UNEXPECTED, exception);
   }
 
   public static RetrofitError unexpectedError(String url, Throwable exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, false, exception);
+    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.UNEXPECTED,
+        exception);
+  }
+
+  /** Identifies the event kind which triggered a {@link RetrofitError}. */
+  public enum Kind {
+    /** An {@link IOException} occurred while communicating to the server. */
+    NETWORK,
+    /** A non-200 HTTP status code was received from the server. */
+    HTTP,
+    /**
+     * An internal error occurred while attempting to execute a request. It is best practice to
+     * re-throw this exception so your application crashes.
+     */
+    UNEXPECTED
   }
 
   private final String url;
   private final Response response;
   private final Converter converter;
   private final Type successType;
-  private final boolean networkError;
+  private final Kind kind;
 
   RetrofitError(String message, String url, Response response, Converter converter,
-      Type successType, boolean networkError, Throwable exception) {
+      Type successType, Kind kind, Throwable exception) {
     super(message, exception);
     this.url = url;
     this.response = response;
     this.converter = converter;
     this.successType = successType;
-    this.networkError = networkError;
+    this.kind = kind;
   }
 
   /** The request URL which produced the error. */
@@ -69,15 +89,18 @@ public Response getResponse() {
     return response;
   }
 
-  /** Whether or not this error was the result of a network error. */
-  public boolean isNetworkError() {
-    return networkError;
+  /** The event kind which triggered this error. */
+  public Kind getKind() {
+    return kind;
   }
 
   /**
-   * HTTP response body converted to the type declared by either the interface method return type or
-   * the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
+   * HTTP response body converted to the type declared by either the interface method return type
+   * or the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
    * response.
+   *
+   * @throws RuntimeException if unable to convert the body to the {@link #getSuccessType() success
+   * type}.
    */
   public Object getBody() {
     return getBodyAs(successType);
@@ -93,19 +116,21 @@ public Type getSuccessType() {
 
   /**
    * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
+   *
+   * @throws RuntimeException if unable to convert the body to the specified {@code type}.
    */
   public Object getBodyAs(Type type) {
     if (response == null) {
       return null;
     }
-    TypedInput body = response.getBody();
+    ResponseBody body = response.body();
     if (body == null) {
       return null;
     }
     try {
       return converter.fromBody(body, type);
-    } catch (ConversionException e) {
-      throw new RuntimeException(e);
+    } catch (IOException e) {
+      throw new RuntimeException(e); // Body is a Buffer, can't be a real IO exception.
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
index 9f1c61415..80295b8c3 100644
--- a/retrofit/src/main/java/retrofit/RxSupport.java
+++ b/retrofit/src/main/java/retrofit/RxSupport.java
@@ -1,10 +1,7 @@
 package retrofit;
 
-import java.util.concurrent.Executor;
-import java.util.concurrent.FutureTask;
 import rx.Observable;
 import rx.Subscriber;
-import rx.subscriptions.Subscriptions;
 
 /**
  * Utilities for supporting RxJava Observables.
@@ -12,53 +9,36 @@
  * RxJava might not be on the available to use. Check {@link Platform#HAS_RX_JAVA} before calling.
  */
 final class RxSupport {
-  /** A callback into {@link RestAdapter} to actually invoke the request. */
   interface Invoker {
-    /** Invoke the request. The interceptor will be "tape" from the time of subscription. */
-    ResponseWrapper invoke(RequestInterceptor requestInterceptor);
-  }
+    void invoke(Callback callback);
 
-  private final Executor executor;
-  private final ErrorHandler errorHandler;
-  private final RequestInterceptor requestInterceptor;
+    interface Callback {
+      void next(Object o);
+      void error(Throwable t);
+    }
+  }
 
-  RxSupport(Executor executor, ErrorHandler errorHandler, RequestInterceptor requestInterceptor) {
-    this.executor = executor;
-    this.errorHandler = errorHandler;
-    this.requestInterceptor = requestInterceptor;
+  RxSupport() {
   }
 
   Observable createRequestObservable(final Invoker invoker) {
     return Observable.create(new Observable.OnSubscribe<Object>() {
-      @Override public void call(Subscriber<? super Object> subscriber) {
-        RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
-        requestInterceptor.intercept(interceptorTape);
-
-        Runnable runnable = getRunnable(subscriber, invoker, interceptorTape);
-        FutureTask<Void> task = new FutureTask<Void>(runnable, null);
-
-        // Subscribe to the future task of the network call allowing unsubscription.
-        subscriber.add(Subscriptions.from(task));
-        executor.execute(task);
-      }
-    });
-  }
+      @Override public void call(final Subscriber<? super Object> subscriber) {
+        invoker.invoke(new Invoker.Callback() {
+          @Override public void next(Object o) {
+            if (!subscriber.isUnsubscribed()) {
+              subscriber.onNext(o);
+              subscriber.onCompleted();
+            }
+          }
 
-  private Runnable getRunnable(final Subscriber<? super Object> subscriber, final Invoker invoker,
-      final RequestInterceptorTape interceptorTape) {
-    return new Runnable() {
-      @Override public void run() {
-        try {
-          if (subscriber.isUnsubscribed()) {
-            return;
+          @Override public void error(Throwable t) {
+            if (!subscriber.isUnsubscribed()) {
+              subscriber.onError(t);
+            }
           }
-          ResponseWrapper wrapper = invoker.invoke(interceptorTape);
-          subscriber.onNext(wrapper.responseBody);
-          subscriber.onCompleted();
-        } catch (RetrofitError e) {
-          subscriber.onError(errorHandler.handleError(e));
-        }
+        });
       }
-    };
+    });
   }
 }
diff --git a/retrofit/src/main/java/retrofit/Types.java b/retrofit/src/main/java/retrofit/Types.java
index 0ad4e5518..da28b1197 100644
--- a/retrofit/src/main/java/retrofit/Types.java
+++ b/retrofit/src/main/java/retrofit/Types.java
@@ -304,15 +304,15 @@ public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments
       }
     }
 
-    public Type[] getActualTypeArguments() {
+    @Override public Type[] getActualTypeArguments() {
       return typeArguments.clone();
     }
 
-    public Type getRawType() {
+    @Override public Type getRawType() {
       return rawType;
     }
 
-    public Type getOwnerType() {
+    @Override public Type getOwnerType() {
       return ownerType;
     }
 
@@ -343,7 +343,7 @@ public GenericArrayTypeImpl(Type componentType) {
       this.componentType = componentType;
     }
 
-    public Type getGenericComponentType() {
+    @Override public Type getGenericComponentType() {
       return componentType;
     }
 
@@ -388,11 +388,11 @@ public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
       }
     }
 
-    public Type[] getUpperBounds() {
+    @Override public Type[] getUpperBounds() {
       return new Type[] { upperBound };
     }
 
-    public Type[] getLowerBounds() {
+    @Override public Type[] getLowerBounds() {
       return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
     }
 
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 49c0cbe75..abe79ab44 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,85 +16,53 @@
  */
 package retrofit;
 
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.concurrent.Executor;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Source;
 
 final class Utils {
-  private static final int BUFFER_SIZE = 0x1000;
-
-  /**
-   * Creates a {@code byte[]} from reading the entirety of an {@link InputStream}. May return an
-   * empty array but never {@code null}.
-   * <p>
-   * Copied from Guava's {@code ByteStreams} class.
-   */
-  static byte[] streamToBytes(InputStream stream) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    if (stream != null) {
-      byte[] buf = new byte[BUFFER_SIZE];
-      int r;
-      while ((r = stream.read(buf)) != -1) {
-        baos.write(buf, 0, r);
-      }
+  static <T> T checkNotNull(T object, String message, Object... args) {
+    if (object == null) {
+      throw new NullPointerException(String.format(message, args));
     }
-    return baos.toByteArray();
+    return object;
   }
 
   /**
-   * Conditionally replace a {@link Request} with an identical copy whose body is backed by a
-   * byte[] rather than an input stream.
-   */
-  static Request readBodyToBytesIfNecessary(Request request) throws IOException {
-    TypedOutput body = request.getBody();
-    if (body == null || body instanceof TypedByteArray) {
-      return request;
-    }
-
-    String bodyMime = body.mimeType();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    body.writeTo(baos);
-    body = new TypedByteArray(bodyMime, baos.toByteArray());
-
-    return new Request(request.getMethod(), request.getUrl(), request.getHeaders(), body);
-  }
-
-  /**
-   * Conditionally replace a {@link Response} with an identical copy whose body is backed by a
-   * byte[] rather than an input stream.
+   * Replace a {@link Response} with an identical copy whose body is backed by a
+   * {@link Buffer} rather than a {@link Source}.
    */
   static Response readBodyToBytesIfNecessary(Response response) throws IOException {
-    TypedInput body = response.getBody();
-    if (body == null || body instanceof TypedByteArray) {
+    final ResponseBody body = response.body();
+    if (body == null) {
       return response;
     }
 
-    String bodyMime = body.mimeType();
-    InputStream is = body.in();
-    try {
-      byte[] bodyBytes = Utils.streamToBytes(is);
-      body = new TypedByteArray(bodyMime, bodyBytes);
+    BufferedSource source = body.source();
+    final Buffer buffer = new Buffer();
+    buffer.writeAll(source);
+    source.close();
 
-      return replaceResponseBody(response, body);
-    } finally {
-      if (is != null) {
-        try {
-          is.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
+    return response.newBuilder()
+        .body(new ResponseBody() {
+          @Override public MediaType contentType() {
+            return body.contentType();
+          }
+
+          @Override public long contentLength() {
+            return buffer.size();
+          }
 
-  static Response replaceResponseBody(Response response, TypedInput body) {
-    return new Response(response.getUrl(), response.getStatus(), response.getReason(),
-        response.getHeaders(), body);
+          @Override public BufferedSource source() {
+            return buffer.clone();
+          }
+        })
+        .build();
   }
 
   static <T> void validateServiceClass(Class<T> service) {
diff --git a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java b/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
deleted file mode 100644
index d5ae3dc8a..000000000
--- a/retrofit/src/main/java/retrofit/android/AndroidApacheClient.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.android;
-
-import android.net.http.AndroidHttpClient;
-import retrofit.client.ApacheClient;
-
-/**
- * Provides a {@link retrofit.client.Client} which uses the Android-specific version of
- * {@link org.apache.http.client.HttpClient}, {@link AndroidHttpClient}.
- * <p>
- * If you need to provide a customized version of the {@link AndroidHttpClient} or a different
- * {@link org.apache.http.client.HttpClient} on Android use {@link ApacheClient} directly.
- */
-public final class AndroidApacheClient extends ApacheClient {
-  public AndroidApacheClient() {
-    super(AndroidHttpClient.newInstance("Retrofit"));
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/android/AndroidLog.java b/retrofit/src/main/java/retrofit/android/AndroidLog.java
deleted file mode 100644
index a5ac5d084..000000000
--- a/retrofit/src/main/java/retrofit/android/AndroidLog.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package retrofit.android;
-
-import android.util.Log;
-import retrofit.RestAdapter;
-
-/** A {@link RestAdapter.Log logger} for Android. */
-public class AndroidLog implements RestAdapter.Log {
-  private static final int LOG_CHUNK_SIZE = 4000;
-
-  private final String tag;
-
-  public AndroidLog(String tag) {
-    this.tag = tag;
-  }
-
-  @Override public final void log(String message) {
-    for (int i = 0, len = message.length(); i < len; i += LOG_CHUNK_SIZE) {
-      int end = Math.min(len, i + LOG_CHUNK_SIZE);
-      logChunk(message.substring(i, end));
-    }
-  }
-
-  /**
-   * Called one or more times for each call to {@link #log(String)}. The length of {@code chunk}
-   * will be no more than 4000 characters to support Android's {@link Log} class.
-   */
-  public void logChunk(String chunk) {
-    Log.d(getTag(), chunk);
-  }
-
-  public String getTag() {
-    return tag;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java b/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
deleted file mode 100644
index 81440d041..000000000
--- a/retrofit/src/main/java/retrofit/android/MainThreadExecutor.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.android;
-
-import android.os.Handler;
-import android.os.Looper;
-
-import java.util.concurrent.Executor;
-
-/** Executor that runs tasks on Android's main thread. */
-public final class MainThreadExecutor implements Executor {
-  private final Handler handler = new Handler(Looper.getMainLooper());
-
-  @Override public void execute(Runnable r) {
-    handler.post(r);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/appengine/UrlFetchClient.java b/retrofit/src/main/java/retrofit/appengine/UrlFetchClient.java
deleted file mode 100644
index 5bc229861..000000000
--- a/retrofit/src/main/java/retrofit/appengine/UrlFetchClient.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package retrofit.appengine;
-
-import com.google.appengine.api.urlfetch.HTTPHeader;
-import com.google.appengine.api.urlfetch.HTTPMethod;
-import com.google.appengine.api.urlfetch.HTTPRequest;
-import com.google.appengine.api.urlfetch.HTTPResponse;
-import com.google.appengine.api.urlfetch.URLFetchService;
-import com.google.appengine.api.urlfetch.URLFetchServiceFactory;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
-
-/** A {@link Client} for Google AppEngine's which uses its {@link URLFetchService}. */
-public class UrlFetchClient implements Client {
-  private static HTTPMethod getHttpMethod(String method) {
-    if ("GET".equals(method)) {
-      return HTTPMethod.GET;
-    } else if ("POST".equals(method)) {
-      return HTTPMethod.POST;
-    } else if ("PATCH".equals(method)) {
-      return HTTPMethod.PATCH;
-    } else if ("PUT".equals(method)) {
-      return HTTPMethod.PUT;
-    } else if ("DELETE".equals(method)) {
-      return HTTPMethod.DELETE;
-    } else if ("HEAD".equals(method)) {
-      return HTTPMethod.HEAD;
-    } else {
-      throw new IllegalStateException("Illegal HTTP method: " + method);
-    }
-  }
-
-  private final URLFetchService urlFetchService;
-
-  public UrlFetchClient() {
-    this(URLFetchServiceFactory.getURLFetchService());
-  }
-
-  public UrlFetchClient(URLFetchService urlFetchService) {
-    this.urlFetchService = urlFetchService;
-  }
-
-  @Override public Response execute(Request request) throws IOException {
-    HTTPRequest fetchRequest = createRequest(request);
-    HTTPResponse fetchResponse = execute(urlFetchService, fetchRequest);
-    return parseResponse(fetchResponse);
-  }
-
-  /** Execute the specified {@code request} using the provided {@code urlFetchService}. */
-  protected HTTPResponse execute(URLFetchService urlFetchService, HTTPRequest request)
-      throws IOException {
-    return urlFetchService.fetch(request);
-  }
-
-  static HTTPRequest createRequest(Request request) throws IOException {
-    HTTPMethod httpMethod = getHttpMethod(request.getMethod());
-    URL url = new URL(request.getUrl());
-    HTTPRequest fetchRequest = new HTTPRequest(url, httpMethod);
-
-    for (Header header : request.getHeaders()) {
-      fetchRequest.addHeader(new HTTPHeader(header.getName(), header.getValue()));
-    }
-
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      body.writeTo(baos);
-      fetchRequest.setPayload(baos.toByteArray());
-    }
-
-    return fetchRequest;
-  }
-
-  static Response parseResponse(HTTPResponse response) {
-    String url = response.getFinalUrl().toString();
-    int status = response.getResponseCode();
-
-    List<HTTPHeader> fetchHeaders = response.getHeaders();
-    List<Header> headers = new ArrayList<Header>(fetchHeaders.size());
-    String contentType = "application/octet-stream";
-    for (HTTPHeader fetchHeader : fetchHeaders) {
-      String name = fetchHeader.getName();
-      String value = fetchHeader.getValue();
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        contentType = value;
-      }
-      headers.add(new Header(name, value));
-    }
-
-    TypedByteArray body = null;
-    byte[] fetchBody = response.getContent();
-    if (fetchBody != null) {
-      body = new TypedByteArray(contentType, fetchBody);
-    }
-
-    return new Response(url, status, "", headers, body);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/ApacheClient.java b/retrofit/src/main/java/retrofit/client/ApacheClient.java
deleted file mode 100644
index ac85d7838..000000000
--- a/retrofit/src/main/java/retrofit/client/ApacheClient.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.List;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.StatusLine;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
-import org.apache.http.client.methods.HttpRequestBase;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.entity.AbstractHttpEntity;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.message.BasicHeader;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.util.EntityUtils;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
-
-/** A {@link Client} which uses an implementation of Apache's {@link HttpClient}. */
-public class ApacheClient implements Client {
-  private static HttpClient createDefaultClient() {
-    HttpParams params = new BasicHttpParams();
-    HttpConnectionParams.setConnectionTimeout(params, Defaults.CONNECT_TIMEOUT_MILLIS);
-    HttpConnectionParams.setSoTimeout(params, Defaults.READ_TIMEOUT_MILLIS);
-    return new DefaultHttpClient(params);
-  }
-
-  private final HttpClient client;
-
-  /** Creates an instance backed by {@link DefaultHttpClient}. */
-  public ApacheClient() {
-    this(createDefaultClient());
-  }
-
-  public ApacheClient(HttpClient client) {
-    this.client = client;
-  }
-
-  @Override public Response execute(Request request) throws IOException {
-    HttpUriRequest apacheRequest = createRequest(request);
-    HttpResponse apacheResponse = execute(client, apacheRequest);
-    return parseResponse(request.getUrl(), apacheResponse);
-  }
-
-  /** Execute the specified {@code request} using the provided {@code client}. */
-  protected HttpResponse execute(HttpClient client, HttpUriRequest request) throws IOException {
-    return client.execute(request);
-  }
-
-  static HttpUriRequest createRequest(Request request) {
-    if (request.getBody() != null) {
-      return new GenericEntityHttpRequest(request);
-    }
-    return new GenericHttpRequest(request);
-  }
-
-  static Response parseResponse(String url, HttpResponse response) throws IOException {
-    StatusLine statusLine = response.getStatusLine();
-    int status = statusLine.getStatusCode();
-    String reason = statusLine.getReasonPhrase();
-
-    List<Header> headers = new ArrayList<Header>();
-    String contentType = "application/octet-stream";
-    for (org.apache.http.Header header : response.getAllHeaders()) {
-      String name = header.getName();
-      String value = header.getValue();
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        contentType = value;
-      }
-      headers.add(new Header(name, value));
-    }
-
-    TypedByteArray body = null;
-    HttpEntity entity = response.getEntity();
-    if (entity != null) {
-      byte[] bytes = EntityUtils.toByteArray(entity);
-      body = new TypedByteArray(contentType, bytes);
-    }
-
-    return new Response(url, status, reason, headers, body);
-  }
-
-  private static class GenericHttpRequest extends HttpRequestBase {
-    private final String method;
-
-    public GenericHttpRequest(Request request) {
-      method = request.getMethod();
-      setURI(URI.create(request.getUrl()));
-
-      // Add all headers.
-      for (Header header : request.getHeaders()) {
-        addHeader(new BasicHeader(header.getName(), header.getValue()));
-      }
-    }
-
-    @Override public String getMethod() {
-      return method;
-    }
-  }
-
-  private static class GenericEntityHttpRequest extends HttpEntityEnclosingRequestBase {
-    private final String method;
-
-    GenericEntityHttpRequest(Request request) {
-      super();
-      method = request.getMethod();
-      setURI(URI.create(request.getUrl()));
-
-      // Add all headers.
-      for (Header header : request.getHeaders()) {
-        addHeader(new BasicHeader(header.getName(), header.getValue()));
-      }
-
-      // Add the content body.
-      setEntity(new TypedOutputEntity(request.getBody()));
-    }
-
-    @Override public String getMethod() {
-      return method;
-    }
-  }
-
-  /** Container class for passing an entire {@link TypedOutput} as an {@link HttpEntity}. */
-  static class TypedOutputEntity extends AbstractHttpEntity {
-    final TypedOutput typedOutput;
-
-    TypedOutputEntity(TypedOutput typedOutput) {
-      this.typedOutput = typedOutput;
-      setContentType(typedOutput.mimeType());
-    }
-
-    @Override public boolean isRepeatable() {
-      return true;
-    }
-
-    @Override public long getContentLength() {
-      return typedOutput.length();
-    }
-
-    @Override public InputStream getContent() throws IOException {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      typedOutput.writeTo(out);
-      return new ByteArrayInputStream(out.toByteArray());
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      typedOutput.writeTo(out);
-    }
-
-    @Override public boolean isStreaming() {
-      return false;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Client.java b/retrofit/src/main/java/retrofit/client/Client.java
deleted file mode 100644
index 53a75b2eb..000000000
--- a/retrofit/src/main/java/retrofit/client/Client.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.IOException;
-
-/**
- * Abstraction of an HTTP client which can execute {@link Request Requests}. This class must be
- * thread-safe as invocation may happen from multiple threads simultaneously.
- */
-public interface Client {
-  /**
-   * Synchronously execute an HTTP represented by {@code request} and encapsulate all response data
-   * into a {@link Response} instance.
-   * <p>
-   * Note: If the request has a body, its length and mime type will have already been added to the
-   * header list as {@code Content-Length} and {@code Content-Type}, respectively. Do NOT alter
-   * these values as they might have been set as a result of an application-level configuration.
-   */
-  Response execute(Request request) throws IOException;
-
-  /**
-   * Deferred means of obtaining a {@link Client}. For asynchronous requests this will always be
-   * called on a background thread.
-   */
-  interface Provider {
-    /** Obtain an HTTP client. Called once for each request. */
-    Client get();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Defaults.java b/retrofit/src/main/java/retrofit/client/Defaults.java
deleted file mode 100644
index 09d1876ab..000000000
--- a/retrofit/src/main/java/retrofit/client/Defaults.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package retrofit.client;
-
-final class Defaults {
-  static final int CONNECT_TIMEOUT_MILLIS = 15 * 1000; // 15s
-  static final int READ_TIMEOUT_MILLIS = 20 * 1000; // 20s
-
-  private Defaults() {
-    // No instances.
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Header.java b/retrofit/src/main/java/retrofit/client/Header.java
deleted file mode 100644
index 41daf5b22..000000000
--- a/retrofit/src/main/java/retrofit/client/Header.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-/** Represents an HTTP header name/value pair. */
-public final class Header {
-  private final String name;
-  private final String value;
-
-  public Header(String name, String value) {
-    this.name = name;
-    this.value = value;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public String getValue() {
-    return value;
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    Header header = (Header) o;
-
-    if (name != null ? !name.equals(header.name) : header.name != null) return false;
-    if (value != null ? !value.equals(header.value) : header.value != null) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = name != null ? name.hashCode() : 0;
-    result = 31 * result + (value != null ? value.hashCode() : 0);
-    return result;
-  }
-
-  @Override public String toString() {
-    return (name != null ? name : "") + ": " + (value != null ? value : "");
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/OkClient.java b/retrofit/src/main/java/retrofit/client/OkClient.java
deleted file mode 100644
index 09c7874f8..000000000
--- a/retrofit/src/main/java/retrofit/client/OkClient.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.concurrent.TimeUnit;
-
-/** Retrofit client that uses OkHttp for communication. */
-public class OkClient extends UrlConnectionClient {
-  private static OkHttpClient generateDefaultOkHttp() {
-    OkHttpClient client = new OkHttpClient();
-    client.setConnectTimeout(Defaults.CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-    client.setReadTimeout(Defaults.READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-    return client;
-  }
-
-  private final OkUrlFactory okUrlFactory;
-
-  public OkClient() {
-    this(generateDefaultOkHttp());
-  }
-
-  public OkClient(OkHttpClient client) {
-    this.okUrlFactory = new OkUrlFactory(client);
-  }
-
-  @Override protected HttpURLConnection openConnection(Request request) throws IOException {
-    return okUrlFactory.open(new URL(request.getUrl()));
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Request.java b/retrofit/src/main/java/retrofit/client/Request.java
deleted file mode 100644
index 8d2199def..000000000
--- a/retrofit/src/main/java/retrofit/client/Request.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import retrofit.mime.TypedOutput;
-
-/** Encapsulates all of the information necessary to make an HTTP request. */
-public final class Request {
-  private final String method;
-  private final String url;
-  private final List<Header> headers;
-  private final TypedOutput body;
-
-  public Request(String method, String url, List<Header> headers, TypedOutput body) {
-    if (method == null) {
-      throw new NullPointerException("Method must not be null.");
-    }
-    if (url == null) {
-      throw new NullPointerException("URL must not be null.");
-    }
-    this.method = method;
-    this.url = url;
-
-    if (headers == null) {
-      this.headers = Collections.emptyList();
-    } else {
-      this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
-    }
-
-    this.body = body;
-  }
-
-  /** HTTP method verb. */
-  public String getMethod() {
-    return method;
-  }
-
-  /** Target URL. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Returns an unmodifiable list of headers, never {@code null}. */
-  public List<Header> getHeaders() {
-    return headers;
-  }
-
-  /** Returns the request body or {@code null}. */
-  public TypedOutput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/Response.java b/retrofit/src/main/java/retrofit/client/Response.java
deleted file mode 100644
index 64dd88bf9..000000000
--- a/retrofit/src/main/java/retrofit/client/Response.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import retrofit.mime.TypedInput;
-
-/**
- * An HTTP response.
- * <p>
- * When used directly as a data type for an interface method, the response body is buffered to a
- * {@code byte[]}. Annotate the method with {@link retrofit.http.Streaming @Streaming} for an
- * unbuffered stream from the network.
- */
-public final class Response {
-  private final String url;
-  private final int status;
-  private final String reason;
-  private final List<Header> headers;
-  private final TypedInput body;
-
-  public Response(String url, int status, String reason, List<Header> headers, TypedInput body) {
-    if (url == null) {
-      throw new IllegalArgumentException("url == null");
-    }
-    if (status < 200) {
-      throw new IllegalArgumentException("Invalid status code: " + status);
-    }
-    if (reason == null) {
-      throw new IllegalArgumentException("reason == null");
-    }
-    if (headers == null) {
-      throw new IllegalArgumentException("headers == null");
-    }
-
-    this.url = url;
-    this.status = status;
-    this.reason = reason;
-    this.headers = Collections.unmodifiableList(new ArrayList<Header>(headers));
-    this.body = body;
-  }
-
-  /** Request URL. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Status line code. */
-  public int getStatus() {
-    return status;
-  }
-
-  /** Status line reason phrase. */
-  public String getReason() {
-    return reason;
-  }
-
-  /** An unmodifiable collection of headers. */
-  public List<Header> getHeaders() {
-    return headers;
-  }
-
-  /** Response body. May be {@code null}. */
-  public TypedInput getBody() {
-    return body;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
deleted file mode 100644
index cd7872e67..000000000
--- a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.client;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-
-/** Retrofit client that uses {@link HttpURLConnection} for communication. */
-public class UrlConnectionClient implements Client {
-  private static final int CHUNK_SIZE = 4096;
-
-  public UrlConnectionClient() {
-  }
-
-  @Override public Response execute(Request request) throws IOException {
-    HttpURLConnection connection = openConnection(request);
-    prepareRequest(connection, request);
-    return readResponse(connection);
-  }
-
-  protected HttpURLConnection openConnection(Request request) throws IOException {
-    HttpURLConnection connection =
-        (HttpURLConnection) new URL(request.getUrl()).openConnection();
-    connection.setConnectTimeout(Defaults.CONNECT_TIMEOUT_MILLIS);
-    connection.setReadTimeout(Defaults.READ_TIMEOUT_MILLIS);
-    return connection;
-  }
-
-  void prepareRequest(HttpURLConnection connection, Request request) throws IOException {
-    connection.setRequestMethod(request.getMethod());
-    connection.setDoInput(true);
-
-    for (Header header : request.getHeaders()) {
-      connection.addRequestProperty(header.getName(), header.getValue());
-    }
-
-    TypedOutput body = request.getBody();
-    if (body != null) {
-      connection.setDoOutput(true);
-      connection.addRequestProperty("Content-Type", body.mimeType());
-      long length = body.length();
-      if (length != -1) {
-        connection.setFixedLengthStreamingMode((int) length);
-        connection.addRequestProperty("Content-Length", String.valueOf(length));
-      } else {
-        connection.setChunkedStreamingMode(CHUNK_SIZE);
-      }
-      body.writeTo(connection.getOutputStream());
-    }
-  }
-
-  Response readResponse(HttpURLConnection connection) throws IOException {
-    int status = connection.getResponseCode();
-    String reason = connection.getResponseMessage();
-    if (reason == null) reason = ""; // HttpURLConnection treats empty reason as null.
-
-    List<Header> headers = new ArrayList<Header>();
-    for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet()) {
-      String name = field.getKey();
-      for (String value : field.getValue()) {
-        headers.add(new Header(name, value));
-      }
-    }
-
-    String mimeType = connection.getContentType();
-    int length = connection.getContentLength();
-    InputStream stream;
-    if (status >= 400) {
-      stream = connection.getErrorStream();
-    } else {
-      stream = connection.getInputStream();
-    }
-    TypedInput responseBody = new TypedInputStream(mimeType, length, stream);
-    return new Response(connection.getURL().toString(), status, reason, headers, responseBody);
-  }
-
-  private static class TypedInputStream implements TypedInput {
-    private final String mimeType;
-    private final long length;
-    private final InputStream stream;
-
-    private TypedInputStream(String mimeType, long length, InputStream stream) {
-      this.mimeType = mimeType;
-      this.length = length;
-      this.stream = stream;
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return length;
-    }
-
-    @Override public InputStream in() throws IOException {
-      return stream;
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/ConversionException.java b/retrofit/src/main/java/retrofit/converter/ConversionException.java
deleted file mode 100644
index 6673efc0b..000000000
--- a/retrofit/src/main/java/retrofit/converter/ConversionException.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-/** Indicate that conversion was unable to complete successfully. */
-@SuppressWarnings("UnusedDeclaration")
-public class ConversionException extends Exception {
-  public ConversionException(String message) {
-    super(message);
-  }
-
-  public ConversionException(String message, Throwable throwable) {
-    super(message, throwable);
-  }
-
-  public ConversionException(Throwable throwable) {
-    super(throwable);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/converter/Converter.java
index 6ac5b6fa8..8c93f9934 100644
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/converter/Converter.java
@@ -15,14 +15,13 @@
  */
 package retrofit.converter;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
- *
- * @author Jake Wharton (jw@squareup.com)
  */
 public interface Converter {
   /**
@@ -31,18 +30,14 @@
    * @param body HTTP response body.
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
-   * @throws ConversionException if conversion was unable to complete. This will trigger a call to
-   * {@link retrofit.Callback#failure(retrofit.RetrofitError)} or throw a
-   * {@link retrofit.RetrofitError}. The exception message should report all necessary information
-   * about its cause as the response body will be set to {@code null}.
    */
-  Object fromBody(TypedInput body, Type type) throws ConversionException;
+  Object fromBody(ResponseBody body, Type type) throws IOException;
 
   /**
-   * Convert and object to an appropriate representation for HTTP transport.
+   * Convert an object to an appropriate representation for HTTP transport.
    *
    * @param object Object instance to convert.
    * @return Representation of the specified object as bytes.
    */
-  TypedOutput toBody(Object object);
+  RequestBody toBody(Object object, Type type);
 }
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index 6aa1d7d41..7240dc15e 100644
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -16,96 +16,70 @@
 package retrofit.converter;
 
 import com.google.gson.Gson;
-import com.google.gson.JsonParseException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
-import retrofit.mime.MimeUtil;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import java.nio.charset.Charset;
 
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- *
- * @author Jake Wharton (jw@squareup.com)
  */
 public class GsonConverter implements Converter {
   private final Gson gson;
-  private String encoding;
+  private final Charset charset;
+  private final MediaType mediaType;
+
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public GsonConverter() {
+    this(new Gson());
+  }
 
   /**
    * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
    * decoding from JSON (when no charset is specified by a header) will use UTF-8.
    */
   public GsonConverter(Gson gson) {
-    this(gson, "UTF-8");
+    this(gson, Charset.forName("UTF-8"));
   }
 
   /**
    * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified encoding.
+   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
    */
-  public GsonConverter(Gson gson, String encoding) {
+  public GsonConverter(Gson gson, Charset charset) {
+    if (gson == null) throw new NullPointerException("gson == null");
+    if (charset == null) throw new NullPointerException("charset == null");
     this.gson = gson;
-    this.encoding = encoding;
+    this.charset = charset;
+    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws ConversionException {
-    String charset = "UTF-8";
-    if (body.mimeType() != null) {
-      charset = MimeUtil.parseCharset(body.mimeType());
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    Charset charset = this.charset;
+    if (body.contentType() != null) {
+      charset = body.contentType().charset(charset);
     }
-    InputStreamReader isr = null;
+
+    InputStream is = body.byteStream();
     try {
-      isr = new InputStreamReader(body.in(), charset);
-      return gson.fromJson(isr, type);
-    } catch (IOException e) {
-      throw new ConversionException(e);
-    } catch (JsonParseException e) {
-      throw new ConversionException(e);
+      return gson.fromJson(new InputStreamReader(is, charset), type);
     } finally {
-      if (isr != null) {
-        try {
-          isr.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        is.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object) {
-    try {
-      return new JsonTypedOutput(gson.toJson(object).getBytes(encoding), encoding);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static class JsonTypedOutput implements TypedOutput {
-    private final byte[] jsonBytes;
-    private final String mimeType;
-
-    JsonTypedOutput(byte[] jsonBytes, String encode) {
-      this.jsonBytes = jsonBytes;
-      this.mimeType = "application/json; charset=" + encode;
-    }
-
-    @Override public String fileName() {
-      return null;
-    }
-
-    @Override public String mimeType() {
-      return mimeType;
-    }
-
-    @Override public long length() {
-      return jsonBytes.length;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      out.write(jsonBytes);
-    }
+  @Override public RequestBody toBody(Object object, Type type) {
+    String json = gson.toJson(object, type);
+    return RequestBody.create(mediaType, json);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 95368be0c..393a5e14f 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -25,10 +25,7 @@
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). If the value of the parameter implements {@link retrofit.mime.TypedOutput TypedOutput},
- * the request body will be written exactly as specified by
- * {@link retrofit.mime.TypedOutput#writeTo(java.io.OutputStream)}. If the value does not implement
- * TypedOutput, the object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
+ * body). The object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
  * {@link retrofit.converter.Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 82968958b..6f13b99fe 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("DELETE")
 public @interface DELETE {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/EncodedPath.java b/retrofit/src/main/java/retrofit/http/EncodedPath.java
deleted file mode 100644
index 142aca057..000000000
--- a/retrofit/src/main/java/retrofit/http/EncodedPath.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.http;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Values are used literally without URL encoding. See
- * {@link retrofit.http.Path @Path} for URL encoding equivalent.
- * <p>
- * <pre>
- * &#64;GET("/image/{id}")
- * void example(@EncodedPath("id") int id, ..);
- * </pre>
- * <p>
- * Path parameters may not be {@code null}.
- */
-@Documented
-@Retention(RUNTIME)
-@Target(PARAMETER)
-public @interface EncodedPath {
-  String value();
-}
diff --git a/retrofit/src/main/java/retrofit/http/EncodedQuery.java b/retrofit/src/main/java/retrofit/http/EncodedQuery.java
deleted file mode 100644
index 4ca0828cb..000000000
--- a/retrofit/src/main/java/retrofit/http/EncodedQuery.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.http;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Encoded query parameter appended to the URL.
- * <p>
- * Values are converted to strings using {@link String#valueOf(Object)}. Values are not URL
- * encoded. {@code null} values will not include the query parameter in the URL. See
- * {@link Query @Query} for URL-encoding equivalent.
- *
- * @see Query
- * @see QueryMap
- * @see EncodedQueryMap
- */
-@Documented
-@Target(PARAMETER)
-@Retention(RUNTIME)
-public @interface EncodedQuery {
-  String value();
-}
diff --git a/retrofit/src/main/java/retrofit/http/EncodedQueryMap.java b/retrofit/src/main/java/retrofit/http/EncodedQueryMap.java
deleted file mode 100644
index 0148e95a7..000000000
--- a/retrofit/src/main/java/retrofit/http/EncodedQueryMap.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.http;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Query keys and values appended to the URL.
- * <p>
- * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * not URL encoded. {@code null} values will not include the query parameter in the URL. See
- * {@link QueryMap @QueryMap} for URL-encoding equivalent.
- *
- * @see Query
- * @see QueryMap
- * @see EncodedQuery
- */
-@Documented
-@Target(PARAMETER)
-@Retention(RUNTIME)
-public @interface EncodedQueryMap {
-}
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index cdceca1a6..fce09d9c0 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -56,4 +56,10 @@
 @Retention(RUNTIME)
 public @interface Field {
   String value();
+
+  /** Specifies whether {@link #value()} is URL encoded. */
+  boolean encodeName() default true;
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encodeValue() default true;
 }
diff --git a/retrofit/src/main/java/retrofit/http/FieldMap.java b/retrofit/src/main/java/retrofit/http/FieldMap.java
index df1b925e8..09b6f4c0d 100644
--- a/retrofit/src/main/java/retrofit/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit/http/FieldMap.java
@@ -44,4 +44,9 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
+  /** Specifies whether parameter names (keys in the map) are URL encoded. */
+  boolean encodeNames() default true;
+
+  /** Specifies whether parameter values (values in the map) are URL encoded. */
+  boolean encodeValues() default true;
 }
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index 3cc64990b..de81a111c 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("GET")
 public @interface GET {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index 9f5f9e718..b73685295 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod("HEAD")
 public @interface HEAD {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/RestMethod.java b/retrofit/src/main/java/retrofit/http/HTTP.java
similarity index 86%
rename from retrofit/src/main/java/retrofit/http/RestMethod.java
rename to retrofit/src/main/java/retrofit/http/HTTP.java
index dec22637b..759c5939f 100644
--- a/retrofit/src/main/java/retrofit/http/RestMethod.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -19,13 +19,14 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 @Documented
-@Target(ANNOTATION_TYPE)
+@Target(METHOD)
 @Retention(RUNTIME)
-public @interface RestMethod {
-  String value();
+public @interface HTTP {
+  String method();
+  String path();
   boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Header.java b/retrofit/src/main/java/retrofit/http/Header.java
index 501b40b81..4ce2cf166 100644
--- a/retrofit/src/main/java/retrofit/http/Header.java
+++ b/retrofit/src/main/java/retrofit/http/Header.java
@@ -30,7 +30,8 @@
  * void foo(@Header("Accept-Language") String lang, Callback&lt;Response&gt; cb);
  * </pre>
  * <p>
- * Header parameters may be {@code null} which will omit them from the request.
+ * Header parameters may be {@code null} which will omit them from the request. Passing a
+ * {@link java.util.List List} or array will result in a header for each non-{@code null} item.
  * <p>
  * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
  * be included in the request.
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index c978a2877..83b061978 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "PATCH", hasBody = true)
 public @interface PATCH {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index c85f62daf..b1f7b1088 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "POST", hasBody = true)
 public @interface POST {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index e8e006fca..915df56d7 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -26,7 +26,6 @@
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@RestMethod(value = "PUT", hasBody = true)
 public @interface PUT {
   String value();
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 6466bafd9..573a46d04 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -27,12 +27,10 @@
  * <p>
  * The parameter type on which this annotation exists will be processed in one of three ways:
  * <ul>
- * <li>If the type implements {@link retrofit.mime.TypedOutput TypedOutput} the headers and
- * body will be used directly.</li>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
  * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object)}.</li>
+ * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
@@ -53,4 +51,6 @@
 @Retention(RUNTIME)
 public @interface Part {
   String value();
+  /** The {@code Content-Transfer-Encoding} of this part. */
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index 40da835b6..0e9a292f3 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -27,12 +27,10 @@
  * <p>
  * Values of the map on which this annotation exists will be processed in one of three ways:
  * <ul>
- * <li>If the type implements {@link retrofit.mime.TypedOutput TypedOutput} the headers and
- * body will be used directly.</li>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
  * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object)}.</li>
+ * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
  * </ul>
  * <p>
  * <pre>
@@ -40,7 +38,6 @@
  * &#64;POST("/upload")
  * void upload(&#64;Part("file") TypedFile file, &#64;PartMap Map&lt;String, String&gt; params);
  * </pre>
- * <p>
  *
  * @see Multipart
  * @see Part
@@ -49,4 +46,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
+  /** The {@code Content-Transfer-Encoding} of this part. */
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index cd0ae4115..6a9deecf3 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -24,12 +24,25 @@
 
 /**
  * Named replacement in the URL path. Values are converted to string using
- * {@link String#valueOf(Object)}. Replaced values will be URL encoded.
+ * {@link String#valueOf(Object)} and URL encoded.
  * <p>
+ * Simple example:
  * <pre>
  * &#64;GET("/image/{id}")
- * void example(@Path("id") int id, ..);
+ * void example(@Path("id") int id);
  * </pre>
+ * Calling with {@code foo.example(1)} yields {@code /image/1}.
+ * <p>
+ * Values are URL encoded by default. Disable with {@code encode=false}.
+ * <pre>
+ * &#64;GET("/user/{name}")
+ * void encoded(@Path("name") String name);
+ *
+ * &#64;GET("/user/{name}")
+ * void notEncoded(@Path(value="name", encode=false) String name);
+ * </pre>
+ * Calling {@code foo.encoded("John+Doe")} yields {@code /user/John%2BDoe} whereas
+ * {@code foo.notEncoded("John+Doe")} yields {@code /user/John+Doe}.
  * <p>
  * Path parameters may not be {@code null}.
  */
@@ -38,4 +51,7 @@
 @Target(PARAMETER)
 public @interface Path {
   String value();
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encode() default true;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index ad83ec160..f4cd0fd46 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -50,14 +50,35 @@
  * </pre>
  * Calling with {@code foo.list("bar", "baz")} yields
  * {@code /list?category=foo&category=bar}.
+ * <p>
+ * Parameter names are not URL encoded. Specify {@link #encodeName() encodeName=true} to change
+ * this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@Query(value="foo+bar", encodeName=true) String foobar);
+ * </pre>
+ * Calling with {@code foo.list("baz")} yields {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Parameter values are URL encoded by default. Specify {@link #encodeValue() encodeValue=false} to
+ * change this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@Query(value="foo", encodeValue=false) String foo);
+ * </pre>
+ * Calling with {@code foo.list("foo+foo"))} yields {@code /search?foo=foo+bar}.
  *
- * @see EncodedQuery
  * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
+  /** The query parameter name. */
   String value();
+
+  /** Specifies whether {@link #value()} is URL encoded. */
+  boolean encodeName() default false;
+
+  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
+  boolean encodeValue() default true;
 }
diff --git a/retrofit/src/main/java/retrofit/http/QueryMap.java b/retrofit/src/main/java/retrofit/http/QueryMap.java
index 46a9c5e09..a6a5e3c28 100644
--- a/retrofit/src/main/java/retrofit/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit/http/QueryMap.java
@@ -26,7 +26,8 @@
  * Query parameter keys and values appended to the URL.
  * <p>
  * Both keys and values are converted to strings using {@link String#valueOf(Object)}. Values are
- * URL encoded and {@code null} will not include the query parameter in the URL.
+ * URL encoded and {@code null} will not include the query parameter in the URL. {@code null} keys
+ * are not allowed.
  * <p>
  * Simple Example:
  * <pre>
@@ -35,13 +36,34 @@
  * </pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
  * {@code /search?foo=bar&kit=kat}.
+ * <p>
+ * Map keys representing the parameter names are not URL encoded. Specify
+ * {@link #encodeNames() encodeNames=true} to change this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@QueryMap(encodeNames=true) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of("foo+bar", "foo+bar"))} yields
+ * {@code /search?foo%2Bbar=foo}.
+ * <p>
+ * Map values representing parameter values are URL encoded by default. Specify
+ * {@link #encodeValues() encodeValues=false} to change this behavior.
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@QueryMap(encodeValues=false) Map&lt;String, String&gt; filters);
+ * </pre>
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
+ * {@code /search?foo=foo%2Bbar}.
  *
  * @see Query
- * @see QueryMap
- * @see EncodedQueryMap
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
+  /** Specifies whether parameter names (keys in the map) are URL encoded. */
+  boolean encodeNames() default false;
+
+  /** Specifies whether parameter values (values in the map) are URL encoded. */
+  boolean encodeValues() default true;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Streaming.java b/retrofit/src/main/java/retrofit/http/Streaming.java
index 2c7e1830f..28cd9b794 100644
--- a/retrofit/src/main/java/retrofit/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit/http/Streaming.java
@@ -23,8 +23,8 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link retrofit.client.Response Response} as is,
- * i.e. without converting {@link retrofit.client.Response#getBody() getBody()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link com.squareup.okhttp.Response Response} as is,
+ * i.e. without converting {@link com.squareup.okhttp.Response#body() body()} to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java b/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
deleted file mode 100644
index d807195a2..000000000
--- a/retrofit/src/main/java/retrofit/mime/FormUrlEncodedTypedOutput.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URLEncoder;
-
-public final class FormUrlEncodedTypedOutput implements TypedOutput {
-  final ByteArrayOutputStream content = new ByteArrayOutputStream();
-
-  public void addField(String name, String value) {
-    if (name == null) {
-      throw new NullPointerException("name");
-    }
-    if (value == null) {
-      throw new NullPointerException("value");
-    }
-    if (content.size() > 0) {
-      content.write('&');
-    }
-    try {
-      name = URLEncoder.encode(name, "UTF-8");
-      value = URLEncoder.encode(value, "UTF-8");
-
-      content.write(name.getBytes("UTF-8"));
-      content.write('=');
-      content.write(value.getBytes("UTF-8"));
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "application/x-www-form-urlencoded; charset=UTF-8";
-  }
-
-  @Override public long length() {
-    return content.size();
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(content.toByteArray());
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MimeUtil.java b/retrofit/src/main/java/retrofit/mime/MimeUtil.java
deleted file mode 100644
index 7307703d5..000000000
--- a/retrofit/src/main/java/retrofit/mime/MimeUtil.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static java.util.regex.Pattern.CASE_INSENSITIVE;
-
-public final class MimeUtil {
-  private static final Pattern CHARSET = Pattern.compile("\\Wcharset=([^\\s;]+)", CASE_INSENSITIVE);
-
-  /** Parse the MIME type from a {@code Content-Type} header value. */
-  public static String parseCharset(String mimeType) {
-    Matcher match = CHARSET.matcher(mimeType);
-    if (match.find()) {
-      return match.group(1).replaceAll("[\"\\\\]", "");
-    }
-    return "UTF-8";
-  }
-
-  private MimeUtil() {
-    // No instances.
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
deleted file mode 100644
index f6dfcff18..000000000
--- a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.UUID;
-
-public final class MultipartTypedOutput implements TypedOutput {
-
-  private static final class MimePart {
-    private final TypedOutput body;
-    private final String name;
-    private final boolean isFirst;
-    private final String boundary;
-
-    private byte[] partBoundary;
-    private byte[] partHeader;
-    private boolean isBuilt;
-
-    public MimePart(String name, TypedOutput body, String boundary, boolean isFirst) {
-      this.name = name;
-      this.body = body;
-      this.isFirst = isFirst;
-      this.boundary = boundary;
-    }
-
-    public void writeTo(OutputStream out) throws IOException {
-      build();
-      out.write(partBoundary);
-      out.write(partHeader);
-      body.writeTo(out);
-    }
-
-    public long size() {
-      build();
-      if (body.length() > -1) {
-        return body.length() + partBoundary.length + partHeader.length;
-      } else {
-        return -1;
-      }
-    }
-
-    private void build() {
-      if (isBuilt) return;
-      partBoundary = buildBoundary(boundary, isFirst, false);
-      partHeader = buildHeader(name, body);
-      isBuilt = true;
-    }
-  }
-
-  private final List<MimePart> mimeParts = new LinkedList<MimePart>();
-
-  private final byte[] footer;
-  private final String boundary;
-  private long length;
-
-  public MultipartTypedOutput() {
-    this(UUID.randomUUID().toString());
-  }
-
-  MultipartTypedOutput(String boundary) {
-    this.boundary = boundary;
-    footer = buildBoundary(boundary, false, true);
-    length = footer.length;
-  }
-
-  List<byte[]> getParts() throws IOException {
-    List<byte[]> parts = new ArrayList<byte[]>(mimeParts.size());
-    for (MimePart part : mimeParts) {
-      ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      part.writeTo(bos);
-      parts.add(bos.toByteArray());
-    }
-    return parts;
-  }
-
-  public void addPart(String name, TypedOutput body) {
-    if (name == null) {
-      throw new NullPointerException("Part name must not be null.");
-    }
-    if (body == null) {
-      throw new NullPointerException("Part body must not be null.");
-    }
-
-    MimePart part = new MimePart(name, body, boundary, mimeParts.isEmpty());
-    mimeParts.add(part);
-
-    long size = part.size();
-    if (size == -1) {
-      length = -1;
-    } else if (length != -1) {
-      length += size;
-    }
-  }
-
-  public int getPartCount() {
-    return mimeParts.size();
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return "multipart/form-data; boundary=" + boundary;
-  }
-
-  @Override public long length() {
-    return length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    for (MimePart part : mimeParts) {
-      part.writeTo(out);
-    }
-    out.write(footer);
-  }
-
-  private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
-    try {
-      StringBuilder sb = new StringBuilder();
-      if (!first) {
-        sb.append("\r\n");
-      }
-      sb.append("--");
-      sb.append(boundary);
-      if (last) {
-        sb.append("--");
-      } else {
-        sb.append("\r\n");
-      }
-      return sb.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart boundary", ex);
-    }
-  }
-
-  private static byte[] buildHeader(String name, TypedOutput value) {
-    try {
-      StringBuilder headers = new StringBuilder();
-      headers.append("Content-Disposition: form-data; name=\"");
-      headers.append(name);
-      if (value.fileName() != null) {
-        headers.append("\"; filename=\"");
-        headers.append(value.fileName());
-      }
-      headers.append("\"\r\nContent-Type: ");
-      headers.append(value.mimeType());
-      if (value.length() != -1) {
-        headers.append("\r\nContent-Length: ").append(value.length());
-      }
-      headers.append("\r\nContent-Transfer-Encoding: binary\r\n\r\n");
-      return headers.toString().getBytes("UTF-8");
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart header", ex);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java b/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
deleted file mode 100644
index a167ae9c9..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedByteArray.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-/**
- * Byte array and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedByteArray implements TypedInput, TypedOutput {
-  private final String mimeType;
-  private final byte[] bytes;
-
-  /**
-   * Constructs a new typed byte array.  Sets mimeType to {@code application/unknown} if absent.
-   *
-   * @throws NullPointerException if bytes are null
-   */
-  public TypedByteArray(String mimeType, byte[] bytes) {
-    if (mimeType == null) {
-      mimeType = "application/unknown";
-    }
-    if (bytes == null) {
-      throw new NullPointerException("bytes");
-    }
-    this.mimeType = mimeType;
-    this.bytes = bytes;
-  }
-
-  public byte[] getBytes() {
-    return bytes;
-  }
-
-  @Override public String fileName() {
-    return null;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return bytes.length;
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    out.write(bytes);
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new ByteArrayInputStream(bytes);
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    TypedByteArray that = (TypedByteArray) o;
-
-    if (!Arrays.equals(bytes, that.bytes)) return false;
-    if (!mimeType.equals(that.mimeType)) return false;
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = mimeType.hashCode();
-    result = 31 * result + Arrays.hashCode(bytes);
-    return result;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedFile.java b/retrofit/src/main/java/retrofit/mime/TypedFile.java
deleted file mode 100644
index 43fcd3a07..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedFile.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2010 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- * File and its mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public class TypedFile implements TypedInput, TypedOutput {
-  private static final int BUFFER_SIZE = 4096;
-
-  private final String mimeType;
-  private final File file;
-
-  /**
-   * Constructs a new typed file.
-   *
-   * @throws NullPointerException if file or mimeType is null
-   */
-  public TypedFile(String mimeType, File file) {
-    if (mimeType == null) {
-      throw new NullPointerException("mimeType");
-    }
-    if (file == null) {
-      throw new NullPointerException("file");
-    }
-    this.mimeType = mimeType;
-    this.file = file;
-  }
-
-  /** Returns the file. */
-  public File file() {
-    return file;
-  }
-
-  @Override public String mimeType() {
-    return mimeType;
-  }
-
-  @Override public long length() {
-    return file.length();
-  }
-
-  @Override public String fileName() {
-    return file.getName();
-  }
-
-  @Override public InputStream in() throws IOException {
-    return new FileInputStream(file);
-  }
-
-  @Override public void writeTo(OutputStream out) throws IOException {
-    byte[] buffer = new byte[BUFFER_SIZE];
-    FileInputStream in = new FileInputStream(file);
-    try {
-      int read;
-      while ((read = in.read(buffer)) != -1) {
-        out.write(buffer, 0, read);
-      }
-    } finally {
-      in.close();
-    }
-  }
-
-  /**
-   * Atomically moves the contents of this file to a new location.
-   *
-   * @param destination file
-   * @throws java.io.IOException if the move fails
-   */
-  public void moveTo(TypedFile destination) throws IOException {
-    if (!mimeType().equals(destination.mimeType())) {
-      throw new IOException("Type mismatch.");
-    }
-    if (!file.renameTo(destination.file())) {
-      throw new IOException("Rename failed!");
-    }
-  }
-
-  @Override public String toString() {
-    return file.getAbsolutePath() + " (" + mimeType() + ")";
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o instanceof TypedFile) {
-      TypedFile rhs = (TypedFile) o;
-      return file.equals(rhs.file);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    return file.hashCode();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedInput.java b/retrofit/src/main/java/retrofit/mime/TypedInput.java
deleted file mode 100644
index f05afb84d..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedInput.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Jake Wharton (jw@squareup.com)
- */
-public interface TypedInput {
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes. Returns {@code -1} if length is unknown. */
-  long length();
-
-  /**
-   * Read bytes as stream. Unless otherwise specified, this method may only be called once. It is
-   * the responsibility of the caller to close the stream.
-   */
-  InputStream in() throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedOutput.java b/retrofit/src/main/java/retrofit/mime/TypedOutput.java
deleted file mode 100644
index f15055f8f..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedOutput.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Binary data with an associated mime type.
- *
- * @author Bob Lee (bob@squareup.com)
- */
-public interface TypedOutput {
-  /** Original filename.
-   *
-   * Used only for multipart requests, may be null. */
-  String fileName();
-
-  /** Returns the mime type. */
-  String mimeType();
-
-  /** Length in bytes or -1 if unknown. */
-  long length();
-
-  /** Writes these bytes to the given output stream. */
-  void writeTo(OutputStream out) throws IOException;
-}
diff --git a/retrofit/src/main/java/retrofit/mime/TypedString.java b/retrofit/src/main/java/retrofit/mime/TypedString.java
deleted file mode 100644
index 9c83230ff..000000000
--- a/retrofit/src/main/java/retrofit/mime/TypedString.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mime;
-
-import java.io.UnsupportedEncodingException;
-
-public class TypedString extends TypedByteArray {
-  public TypedString(String string) {
-    super("text/plain; charset=UTF-8", convertToBytes(string));
-  }
-
-  private static byte[] convertToBytes(String string) {
-    try {
-      return string.getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/CallbackRunnableTest.java b/retrofit/src/test/java/retrofit/CallbackRunnableTest.java
deleted file mode 100644
index 57cf710b3..000000000
--- a/retrofit/src/test/java/retrofit/CallbackRunnableTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import java.util.concurrent.Executor;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class CallbackRunnableTest {
-  private Executor executor = spy(new SynchronousExecutor());
-  private CallbackRunnable<Object> callbackRunnable;
-  private Callback<Object> callback;
-  private ErrorHandler errorHandler = ErrorHandler.DEFAULT;
-
-  @Before public void setUp() {
-    callback = mock(Callback.class);
-    callbackRunnable = spy(new CallbackRunnable<Object>(callback, executor, errorHandler) {
-      @Override public ResponseWrapper obtainResponse() {
-        return null; // Must be mocked.
-      }
-    });
-  }
-
-  @Test public void responsePassedToSuccess() {
-    ResponseWrapper wrapper = new ResponseWrapper(null, new Object());
-    when(callbackRunnable.obtainResponse()).thenReturn(wrapper);
-
-    callbackRunnable.run();
-
-    verify(executor).execute(any(Runnable.class));
-    verify(callback).success(same(wrapper.responseBody), same(wrapper.response));
-  }
-
-  @Test public void errorPassedToFailure() {
-    RetrofitError exception = RetrofitError.unexpectedError("", new RuntimeException());
-    when(callbackRunnable.obtainResponse()).thenThrow(exception);
-
-    callbackRunnable.run();
-
-    verify(executor).execute(any(Runnable.class));
-    verify(callback).failure(same(exception));
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/EndpointsTest.java b/retrofit/src/test/java/retrofit/EndpointsTest.java
index 79069e84d..50c41dcf3 100644
--- a/retrofit/src/test/java/retrofit/EndpointsTest.java
+++ b/retrofit/src/test/java/retrofit/EndpointsTest.java
@@ -6,14 +6,8 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class EndpointsTest {
-  @Test public void endpointOnly() {
-    Endpoint endpoint = Endpoints.newFixedEndpoint("http://example.com");
-    assertThat(endpoint.getUrl()).isEqualTo("http://example.com");
-  }
-
-  @Test public void endpointAndName() {
-    Endpoint endpoint = Endpoints.newFixedEndpoint("http://example.com", "production");
-    assertThat(endpoint.getUrl()).isEqualTo("http://example.com");
-    assertThat(endpoint.getName()).isEqualTo("production");
+  @Test public void endpoint() {
+    Endpoint endpoint = Endpoint.createFixed("http://example.com");
+    assertThat(endpoint.url()).isEqualTo("http://example.com");
   }
 }
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
index b42265c59..6de8d00f4 100644
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
@@ -1,20 +1,22 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.util.Collections;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
 import retrofit.http.GET;
 import rx.Observable;
 import rx.Observer;
 
+import static com.squareup.okhttp.Protocol.HTTP_1_1;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doReturn;
@@ -36,24 +38,29 @@
   static class TestException extends Exception {
   }
 
-  /* An HTTP client which always returns a 400 response */
-  static class MockInvalidResponseClient implements Client {
-    @Override public Response execute(Request request) throws IOException {
-      return new Response("", 400, "invalid request", Collections.<Header>emptyList(), null);
-    }
-  }
-
-  ExampleClient client;
+  ExampleClient example;
   ErrorHandler errorHandler;
 
   @Before public void setup() {
     errorHandler = mock(ErrorHandler.class);
 
-    client = new RestAdapter.Builder() //
+    OkHttpClient client = new OkHttpClient();
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return new Response.Builder()
+            .code(400)
+            .message("Invalid")
+            .request(chain.request())
+            .protocol(HTTP_1_1)
+            .build();
+      }
+    });
+
+    example = new RestAdapter.Builder() //
         .setEndpoint("http://example.com")
-        .setClient(new MockInvalidResponseClient())
+        .setClient(client)
         .setErrorHandler(errorHandler)
-        .setExecutors(new Utils.SynchronousExecutor(), new Utils.SynchronousExecutor())
+        .setCallbackExecutor(new Utils.SynchronousExecutor())
         .build()
         .create(ExampleClient.class);
   }
@@ -63,7 +70,7 @@
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
     try {
-      client.throwsCustomException();
+      example.throwsCustomException();
       failBecauseExceptionWasNotThrown(TestException.class);
     } catch (TestException e) {
       assertThat(e).isSameAs(exception);
@@ -74,7 +81,7 @@
     final TestException exception = new TestException();
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
-    client.onErrorWrappedCustomException(new Callback<Response>() {
+    example.onErrorWrappedCustomException(new Callback<Response>() {
 
       @Override public void success(Response response, Response response2) {
         failBecauseExceptionWasNotThrown(TestException.class);
@@ -90,26 +97,29 @@
     final TestException exception = new TestException();
     doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
 
-    client.onErrorCustomException().subscribe(new Observer<Response>() {
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.onErrorCustomException().subscribe(new Observer<Response>() {
       @Override public void onCompleted() {
         failBecauseExceptionWasNotThrown(TestException.class);
       }
 
       @Override public void onError(Throwable e) {
         assertThat(e).isSameAs(exception);
+        latch.countDown();
       }
 
       @Override public void onNext(Response response) {
         failBecauseExceptionWasNotThrown(TestException.class);
       }
     });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
   }
 
   @Test public void returningNullThrowsException() throws Exception {
     doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
 
     try {
-      client.throwsCustomException();
+      example.throwsCustomException();
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
diff --git a/retrofit/src/test/java/retrofit/MethodInfoTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
new file mode 100644
index 000000000..cffec1afc
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/MethodInfoTest.java
@@ -0,0 +1,220 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.google.gson.reflect.TypeToken;
+import com.squareup.okhttp.Response;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+import retrofit.http.Streaming;
+import rx.Observable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+@SuppressWarnings("unused") // Lots of unused parameters for example code.
+public class MethodInfoTest {
+  @Test public void pathParameterParsing() throws Exception {
+    expectParams("/");
+    expectParams("/foo");
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+  }
+
+  private static void expectParams(String path, String... expected) {
+    Set<String> calculated = MethodInfo.parsePathParameters(path);
+    assertThat(calculated).hasSize(expected.length);
+    if (expected.length > 0) {
+      assertThat(calculated).containsExactly(expected);
+    }
+  }
+
+  static class Dummy {
+  }
+
+  @Test public void concreteBodyType() {
+    class Example {
+      @POST("/foo") Response a(@Body Dummy body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.requestObjectType).isEqualTo(Dummy.class);
+  }
+
+  @Test public void genericBodyType() {
+    class Example {
+      @POST("/foo") Response a(@Body List<String> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    Type expected = new TypeToken<List<String>>() {}.getType();
+    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
+  }
+
+  @Test public void wildcardBodyType() {
+    class Example {
+      @POST("/foo") Response a(@Body List<? super String> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    Type expected = new TypeToken<List<? super String>>() {}.getType();
+    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
+  }
+
+  @Test public void concreteCallbackTypes() {
+    class Example {
+      @GET("/foo") void a(ResponseCallback cb) {
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void genericCallbackTypes() {
+    class Example {
+      @GET("/foo") void a(Callback<Response> cb) {
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void wildcardGenericCallbackTypes() {
+    class Example {
+      @GET("/foo") void a(Callback<? extends Response> c) {
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void genericCallbackWithGenericType() {
+    class Example {
+      @GET("/foo") void a(Callback<List<String>> c) {
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+
+    Type expected = new TypeToken<List<String>>() {}.getType();
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
+  }
+
+  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
+  // a little of everything: a parameterized type, a generic array, and a wildcard.
+  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
+
+  @Test public void extendingGenericCallback() throws Exception {
+    class Example {
+      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(
+        MethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
+  }
+
+  @Test public void synchronousResponse() {
+    class Example {
+      @GET("/foo") Response a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void synchronousGenericResponse() {
+    class Example {
+      @GET("/foo") List<String> a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+
+    Type expected = new TypeToken<List<String>>() {}.getType();
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
+  }
+
+  @Test public void streamingResponse() {
+    class Example {
+      @GET("/foo") @Streaming Response a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void observableResponse() {
+    class Example {
+      @GET("/foo") Observable<Response> a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void observableGenericResponse() {
+    class Example {
+      @GET("/foo") Observable<List<String>> a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method);
+    Type expected = new TypeToken<List<String>>() {}.getType();
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
+  }
+
+  private static interface ResponseCallback extends Callback<Response> {
+  }
+
+  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/MockClient.java b/retrofit/src/test/java/retrofit/MockClient.java
new file mode 100644
index 000000000..1fea6c0cc
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/MockClient.java
@@ -0,0 +1,50 @@
+// Copyright 2015 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+
+import static com.squareup.okhttp.Protocol.HTTP_1_1;
+
+final class MockClient implements Interceptor {
+  private Deque<Object> events = new ArrayDeque<Object>();
+  private Deque<Request> requests = new ArrayDeque<Request>();
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Request request = chain.request();
+    requests.addLast(request);
+
+    Object event = events.removeFirst();
+    if (event instanceof IOException) {
+      throw (IOException) event;
+    }
+    if (event instanceof RuntimeException) {
+      throw (RuntimeException) event;
+    }
+    if (event instanceof Response.Builder) {
+      Response.Builder response = (Response.Builder) event;
+      return response.request(request).protocol(HTTP_1_1).build();
+    }
+    throw new IllegalStateException("Unknown event " + event.getClass());
+  }
+
+  public void enqueueResponse(Response.Builder response) {
+    events.addLast(response);
+  }
+
+  public void enqueueUnexpectedException(RuntimeException exception) {
+    events.addLast(exception);
+  }
+
+  public void enqueueIOException(IOException exception) {
+    events.addLast(exception);
+  }
+
+  public Request takeRequest() {
+    return requests.removeFirst();
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index ad2c5aac9..3585600be 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -2,975 +2,1822 @@
 package retrofit;
 
 import com.google.gson.Gson;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.Method;
-import java.util.ArrayList;
+import java.math.BigInteger;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okio.Buffer;
+import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.client.Header;
-import retrofit.client.Request;
 import retrofit.converter.Converter;
 import retrofit.converter.GsonConverter;
-import retrofit.mime.MimeHelper;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
+import retrofit.http.Body;
+import retrofit.http.DELETE;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+import retrofit.http.Headers;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+import retrofit.http.Streaming;
+import rx.Observable;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static retrofit.RestMethodInfo.ParamUsage;
-import static retrofit.RestMethodInfo.ParamUsage.BODY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_PATH;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY_MAP;
-import static retrofit.RestMethodInfo.ParamUsage.FIELD;
-import static retrofit.RestMethodInfo.ParamUsage.FIELD_MAP;
-import static retrofit.RestMethodInfo.ParamUsage.HEADER;
-import static retrofit.RestMethodInfo.ParamUsage.PART;
-import static retrofit.RestMethodInfo.ParamUsage.PART_MAP;
-import static retrofit.RestMethodInfo.ParamUsage.PATH;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
-import static retrofit.RestMethodInfo.RequestType;
+import static org.junit.Assert.fail;
 
+@SuppressWarnings("UnusedParameters") // Parameters inspected reflectively.
 public class RequestBuilderTest {
-  @Test public void normalGet() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addEncodedPathParam("ping", "po%20ng") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addInterceptorPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorPathParam("kit", "kat")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addInterceptorQueryParam("butter", "finger") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorQueryParam("butter", "finger")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addInterceptorPathParam("ping", "pong") //
-        .addInterceptorQueryParam("butter", "finger") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .addInterceptorPathParam("kit", "kat")
-        .addInterceptorQueryParam("butter", "finger")
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void pathParamRequired() throws Exception {
+  private RequestInterceptor interceptor;
+
+  @Test public void custom1Method() {
+    class Example {
+      @HTTP(method = "CUSTOM1", path = "/foo")
+      Response method() {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("CUSTOM1");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertThat(request.body()).isNull();
+  }
+
+  @Ignore // TODO https://github.com/square/okhttp/issues/229
+  @Test public void custom2Method() {
+    class Example {
+      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+      Response method(@Body RequestBody body) {
+        return null;
+      }
+    }
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("CUSTOM2");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo");
+    assertBody(request.body(), "hi");
+  }
+
+  //@Test public void onlyOneEncodingIsAllowedMultipartFirst() {
+  //  class Example {
+  //    @Multipart //
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
+  //
+  //@Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
+
+  @Test public void invalidPathParam() throws Exception {
+    class Example {
+      @GET("/") //
+      Response method(@Path("hey!") String thing) {
+        return null;
+      }
+    }
+
     try {
-      new Helper() //
-          .setMethod("GET") //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/{ping}/") //
-          .addPathParam("ping", null) //
-          .build();
-      fail("Null path parameters not allowed.");
+      buildRequest(Example.class);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+      assertThat(e).hasMessage(
+          "Example.method: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)");
     }
   }
 
-  @Test public void getWithQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addEncodedQueryParam("ping", "p+o+n+g") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void queryParamOptional() throws Exception {
-    Request request1 = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("ping", null) //
-        .build();
-    assertThat(request1.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    Request request2 = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("foo", "bar") //
-        .addQueryParam("ping", null) //
-        .addQueryParam("kit", "kat") //
-        .build();
-    assertThat(request2.getUrl()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setQuery("hi=mom") //
-        .addQueryParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithQuery() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setQuery("hi=mom") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .addQueryParam("kit", "kat") //
-        .addQueryParam("riff", "raff") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong?") //
-        .addQueryParam("kit", "kat?") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong&") //
-        .addQueryParam("kit", "kat&") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong#") //
-        .addQueryParam("kit", "kat#") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() throws Exception {
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+  @Test public void pathParamNotAllowedInQuery() throws Exception {
+    class Example {
+      @GET("/foo?bar={bar}") //
+      Response method(@Path("bar") String thing) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.");
+    }
+  }
 
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("key", values) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.getBody()).isNull();
+  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
+    class Example {
+      @GET("/") //
+      Response method(@Body @Query("nope") Object o) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Multiple Retrofit annotations found, only one allowed:"
+              + " @Body, @Query. (parameter #1)");
+    }
   }
 
-  @Test public void getWithQueryParamArray() throws Exception {
-    Object[] values = { 1, 2, null, "three" };
+  @Test public void twoMethodsFail() {
+    class Example {
+      @PATCH("/foo") //
+      @POST("/foo") //
+      Response method() {
+        return null;
+      }
+    }
 
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("key", values) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.getBody()).isNull();
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Only one HTTP method is allowed. Found: PATCH and POST.");
+    }
   }
 
-  @Test public void getWithQueryParamPrimitiveArray() throws Exception {
-    int[] values = { 1, 2, 3 };
+  @Test public void pathMustBePrefixedWithSlash() {
+    class Example {
+      @GET("foo/bar") //
+      Response method() {
+        return null;
+      }
+    }
 
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryParam("key", values) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.getBody()).isNull();
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: URL path \"foo/bar\" must start with '/'.");
+    }
   }
 
-  @Test public void getWithQueryParamMap() throws Exception {
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("kit", "kat");
-    params.put("foo", null);
-    params.put("ping", "pong");
+  @Test public void streamingResponseNotAllowed() {
+    class Example {
+      @GET("/foo") //
+      @Streaming //
+      String method() {
+        return null;
+      }
+    }
 
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addQueryMapParams("options", params) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.getBody()).isNull();
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
+    }
   }
 
-  @Test public void getWithEncodedQueryParamMap() throws Exception {
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("kit", "k%20t");
-    params.put("foo", null);
-    params.put("ping", "p%20g");
+  @Test public void streamingResponseWithCallbackNotAllowed() {
+    class Example {
+      @GET("/foo") //
+      @Streaming //
+      void method(Callback<String> callback) {
+      }
+    }
 
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addEncodedQueryMapParams("options", params) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void normalPost() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void normalPostWithPathParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/") //
-        .addPathParam("ping", "pong") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void body() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setBody(Arrays.asList("quick", "brown", "fox")) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-
-  @Test public void bodyRequired() throws Exception {
     try {
-      new Helper() //
-          .setMethod("POST") //
-          .setHasBody() //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/") //
-          .setBody(null) //
-          .build();
-      fail("Null body not allowed.");
+      buildRequest(Example.class);
+      fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+      assertThat(e).hasMessage(
+          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
     }
   }
 
-  @Test public void bodyWithPathParams() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/{ping}/{kit}/") //
-        .addPathParam("ping", "pong") //
-        .setBody(Arrays.asList("quick", "brown", "fox")) //
-        .addPathParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertTypedBytes(request.getBody(), "[\"quick\",\"brown\",\"fox\"]");
+  @Test public void observableWithCallback() {
+    class Example {
+      @GET("/foo") //
+      Observable<Response> method(Callback<Response> callback) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Must have return type or Callback as last argument, not both.");
+    }
   }
 
-  @Test public void simpleMultipart() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setMultipart() //
-        .addPart("ping", "pong") //
-        .addPart("kit", new TypedString("kat")) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
+  @Test public void missingCallbackTypes() {
+    class Example {
+      @GET("/foo") //
+      void method(@Query("id") String id) {
+      }
+    }
 
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Must have either a return type or Callback as last argument.");
+    }
+  }
 
-    Iterator<byte[]> iterator = bodyParts.iterator();
+  @Test public void nonParameterizedCallbackFails() {
+    class Example {
+      @GET("/foo") //
+      void method(Callback cb) {
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Last parameter must be of type Callback<X> or Callback<? super X>.");
+    }
+  }
 
-    String one = new String(iterator.next(), "UTF-8");
-    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+  @Test public void synchronousWithAsyncCallback() {
+    class Example {
+      @GET("/foo") //
+      Response method(Callback<Response> callback) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Must have return type or Callback as last argument, not both.");
+    }
+  }
 
-    String two = new String(iterator.next(), "UTF-8");
-    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  @Test public void lackingMethod() {
+    class Example {
+      Response method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    }
   }
 
-  @Test public void multipartPartMap() throws Exception {
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("ping", "pong");
-    params.put("kit", new TypedString("kat"));
-
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setMultipart() //
-        .addPartMap("params", params) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(2);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), "UTF-8");
-    assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-
-    String two = new String(iterator.next(), "UTF-8");
-    assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  }
-
-  @Test public void multipartNullRemovesPart() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .setMultipart() //
-        .addPart("ping", "pong") //
-        .addPart("fizz", null) //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("POST");
-    assertThat(request.getHeaders()).isEmpty();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-
-    MultipartTypedOutput body = (MultipartTypedOutput) request.getBody();
-    List<byte[]> bodyParts = MimeHelper.getParts(body);
-    assertThat(bodyParts).hasSize(1);
-
-    Iterator<byte[]> iterator = bodyParts.iterator();
-
-    String one = new String(iterator.next(), "UTF-8");
-    assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
-  }
-
-  @Test public void multipartPartOptional() throws Exception {
+  @Test public void implicitMultipartForbidden() {
+    class Example {
+      @POST("/") //
+      Response method(@Part("a") int a) {
+        return null;
+      }
+    }
     try {
-      new Helper() //
-          .setMethod("POST") //
-          .setHasBody() //
-          .setUrl("http://example.com") //
-          .setPath("/foo/bar/") //
-          .setMultipart() //
-          .addPart("ping", null) //
-          .build();
-      fail("Empty multipart request is not allowed.");
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", "bar") //
-        .addField("ping", "pong") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedFieldOptional() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", "bar") //
-        .addField("ping", null) //
-        .addField("kit", "kat") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() throws Exception {
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", values) //
-        .addField("kit", "kat") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() throws Exception {
-    Object[] values = { 1, 2, null, "three" };
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Part parameters can only be used with multipart encoding. (parameter #1)");
+    }
+  }
 
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", values) //
-        .addField("kit", "kat") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=1&foo=2&foo=three&kit=kat");
+  @Test public void implicitMultipartWithPartMapForbidden() {
+    class Example {
+      @POST("/") //
+      Response method(@PartMap Map<String, String> params) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
+    }
   }
 
-  @Test public void formEncodedFieldPrimitiveArray() throws Exception {
-    int[] values = { 1, 2, 3 };
+  //@Test public void multipartFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @Multipart //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void multipartFailsWithNoParts() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
+  //  }
+  //}
+
+  @Test public void implicitFormEncodingByFieldForbidden() {
+    class Example {
+      @POST("/") //
+      Response method(@Field("a") int a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Field parameters can only be used with form encoding. (parameter #1)");
+    }
+  }
 
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addField("foo", values) //
-        .addField("kit", "kat") //
-        .build();
-    assertTypedBytes(request.getBody(), "foo=1&foo=2&foo=3&kit=kat");
+  @Test public void implicitFormEncodingByFieldMapForbidden() {
+    class Example {
+      @POST("/") //
+      Response method(@FieldMap Map<String, String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @FieldMap parameters can only be used with form encoding. (parameter #1)");
+    }
   }
 
-  @Test public void formEncodedFieldMap() throws Exception {
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("kit", "kat");
-    params.put("foo", null);
-    params.put("ping", "pong");
+  //@Test public void formEncodingFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void formEncodingFailsWithNoParts() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
+  //  }
+  //}
+
+  @Test public void headersFailWhenEmptyOnMethod() {
+    class Example {
+      @GET("/") //
+      @Headers({}) //
+      Response method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: @Headers annotation is empty.");
+    }
+  }
 
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setHasBody() //
-        .setUrl("http://example.com") //
-        .setPath("/foo") //
-        .setFormEncoded() //
-        .addFieldMap("options", params) //
-        .build();
-    assertTypedBytes(request.getBody(), "kit=kat&ping=pong");
-  }
-
-  @Test public void simpleHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeaders("ping: pong", "kit: kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void simpleInterceptorHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addInterceptorHeader("ping", "pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void headersAndInterceptorHeaders() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeaders("ping: pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void allThreeHeaderTypes() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeaders("ping: pong") //
-        .addInterceptorHeader("kit", "kat") //
-        .addHeaderParam("fizz", "buzz") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()).containsExactly(new Header("ping", "pong"),
-        new Header("kit", "kat"), new Header("fizz", "buzz"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void methodHeader() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeaders("ping: pong") //
-        .addHeaderParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void headerParam() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com") //
-        .setPath("/foo/bar/") //
-        .addHeaders("ping: pong") //
-        .addHeaderParam("kit", "kat") //
-        .build();
-    assertThat(request.getMethod()).isEqualTo("GET");
-    assertThat(request.getHeaders()) //
-        .containsExactly(new Header("ping", "pong"), new Header("kit", "kat"));
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.getBody()).isNull();
-  }
-
-  @Test public void noDuplicateSlashes() throws Exception {
-    Request request = new Helper() //
-        .setMethod("GET") //
-        .setUrl("http://example.com/") //
-        .setPath("/foo/bar/") //
-        .build();
-    assertThat(request.getUrl()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setUrl("http://example.com") //
-        .setPath("/") //
-        .addHeaders("Content-Type: text/not-plain") //
-        .setBody(new TypedString("Plain")) //
-        .build();
-    assertThat(request.getBody().mimeType()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() throws Exception {
-    Request request = new Helper() //
-        .setMethod("POST") //
-        .setUrl("http://example.com") //
-        .setPath("/") //
-        .addHeaderParam("Content-Type", "text/not-plain") //
-        .setBody(new TypedString("Plain")) //
-        .build();
-    assertThat(request.getBody().mimeType()).isEqualTo("text/not-plain");
-  }
-
-  private static void assertTypedBytes(TypedOutput bytes, String expected) throws IOException {
-    assertThat(bytes).isNotNull();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    bytes.writeTo(baos);
-    assertThat(new String(baos.toByteArray(), "UTF-8")).isEqualTo(expected);
-  }
-
-  private static class Helper {
-    private static final Converter GSON = new GsonConverter(new Gson());
-
-    private RequestType requestType = RequestType.SIMPLE;
-    private String method;
-    private boolean hasBody = false;
-    private String path;
-    private String query;
-    private final List<String> paramNames = new ArrayList<String>();
-    private final List<ParamUsage> paramUsages = new ArrayList<ParamUsage>();
-    private final List<Object> args = new ArrayList<Object>();
-    private final List<String> headers = new ArrayList<String>();
-    private final List<Header> interceptorHeaders = new ArrayList<Header>();
-    private final Map<String, String> interceptorPathParams = new LinkedHashMap<String, String>();
-    private final Map<String, String> interceptorQueryParams = new LinkedHashMap<String, String>();
-    private String url;
-
-    Helper setMethod(String method) {
-      this.method = method;
-      return this;
-    }
-
-    Helper setHasBody() {
-      hasBody = true;
-      return this;
+  @Test public void headersFailWhenMalformed() {
+    class Example {
+      @GET("/") //
+      @Headers("Malformed") //
+      Response method() {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
     }
+  }
 
-    Helper setUrl(String url) {
-      this.url = url;
-      return this;
+  @Test public void pathParamNonPathParamAndTypedBytes() {
+    class Example {
+      @PUT("/{a}") //
+      Response method(@Path("a") int a, @Path("b") int b, @Body int c) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
     }
+  }
 
-    Helper setPath(String path) {
-      this.path = path;
-      return this;
+  @Test public void parameterWithoutAnnotation() {
+    class Example {
+      @GET("/") //
+      Response method(String a) {
+        return null;
+      }
     }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: No Retrofit annotation found. (parameter #1)");
+    }
+  }
 
-    Helper setQuery(String query) {
-      this.query = query;
-      return this;
+  @Test public void nonBodyHttpMethodWithSingleEntity() {
+    class Example {
+      @GET("/") //
+      Response method(@Body Object o) {
+        return null;
+      }
     }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Example.method: Non-body HTTP method cannot contain @Body or @TypedOutput.");
+    }
+  }
 
-    Helper addPathParam(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(PATH);
-      args.add(value);
-      return this;
+  @Test public void queryMapMustBeAMap() {
+    class Example {
+      @GET("/") //
+      Response method(@QueryMap List<String> a) {
+        return null;
+      }
     }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: @QueryMap parameter type must be Map. (parameter #1)");
+    }
+  }
 
-    Helper addEncodedPathParam(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(ENCODED_PATH);
-      args.add(value);
-      return this;
+  @Test public void queryMapRejectsNullKeys() {
+    class Example {
+      @GET("/") //
+      Response method(@QueryMap Map<String, String> a) {
+        return null;
+      }
     }
 
-    Helper addQueryParam(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(QUERY);
-      args.add(value);
-      return this;
+    Map<String, String> queryParams = new LinkedHashMap<String, String>();
+    queryParams.put("ping", "pong");
+    queryParams.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, queryParams);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Parameter #1 query map contained null key.");
     }
+  }
 
-    Helper addEncodedQueryParam(String name, String value) {
-      paramNames.add(name);
-      paramUsages.add(ENCODED_QUERY);
-      args.add(value);
-      return this;
+  @Test public void twoBodies() {
+    class Example {
+      @PUT("/") //
+      Response method(@Body int o1, @Body int o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Example.method: Multiple @Body method annotations found.");
     }
+  }
 
-    Helper addQueryMapParams(String name, Map<String, Object> values) {
-      paramNames.add(name);
-      paramUsages.add(QUERY_MAP);
-      args.add(values);
-      return this;
+  //@Test public void bodyInNonBodyRequest() {
+  //  class Example {
+  //    @Multipart //
+  //    @PUT("/") //
+  //    Response method(@Part("one") int o1, @Body int o2) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
+  //  }
+  //}
+
+  @Test public void get() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method() {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addEncodedQueryMapParams(String name, Map<String, Object> values) {
-      paramNames.add(name);
-      paramUsages.add(ENCODED_QUERY_MAP);
-      args.add(values);
-      return this;
+  @Test public void delete() {
+    class Example {
+      @DELETE("/foo/bar/") //
+      Response method() {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("DELETE");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "");
+  }
 
-    Helper addField(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(FIELD);
-      args.add(value);
-      return this;
+  @Test public void head() {
+    class Example {
+      @HEAD("/foo/bar/") //
+      Response method() {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("HEAD");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addFieldMap(String name, Map<String, Object> values) {
-      paramNames.add(name);
-      paramUsages.add(FIELD_MAP);
-      args.add(values);
-      return this;
+  @Test public void post() {
+    class Example {
+      @POST("/foo/bar/") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
     }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
 
-    Helper addPart(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(PART);
-      args.add(value);
-      return this;
+  @Test public void put() {
+    class Example {
+      @PUT("/foo/bar/") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
     }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
 
-    Helper addPartMap(String name, Map<String, Object> values) {
-      paramNames.add(name);
-      paramUsages.add(PART_MAP);
-      args.add(values);
-      return this;
+  @Test public void patch() {
+    class Example {
+      @PATCH("/foo/bar/") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
     }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("PATCH");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
 
-    Helper setBody(Object value) {
-      paramNames.add(null);
-      paramUsages.add(BODY);
-      args.add(value);
-      return this;
+  @Test public void getWithPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "po ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addHeaderParam(String name, Object value) {
-      paramNames.add(name);
-      paramUsages.add(HEADER);
-      args.add(value);
-      return this;
+  @Test public void getWithEncodedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path(value = "ping", encode = false) String ping) {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class, "po%20ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addHeaders(String... headers) {
-      Collections.addAll(this.headers, headers);
-      return this;
+  @Test public void getWithInterceptorPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method() {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addPathParam("ping", "po ng");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addInterceptorHeader(String name, String value) {
-      interceptorHeaders.add(new Header(name, value));
-      return this;
+  @Test public void getWithInterceptorEncodedPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method() {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addEncodedPathParam("ping", "po%20ng");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addInterceptorPathParam(String name, String value) {
-      interceptorPathParams.put(name, value);
-      return this;
+  @Test public void getWithPathParamAndInterceptorPathParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/{kit}/") //
+      Response method(@Path("ping") String ping) {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addPathParam("kit", "kat");
+      }
+    };
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper addInterceptorQueryParam(String name, String value) {
-      interceptorQueryParams.put(name, value);
-      return this;
+  @Test public void getWithInterceptorQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method() {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addQueryParam("ping", "po ng");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=po+ng");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper setMultipart() {
-      requestType = RequestType.MULTIPART;
-      return this;
+  @Test public void getWithPathParamAndInterceptorQueryParam() {
+    class Example {
+      @GET("/foo/bar/{kit}/") //
+      Response method(@Path("kit") String kit) {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addQueryParam("ping", "pong");
+      }
+    };
+    Request request = buildRequest(Example.class, "kat");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/kat/?ping=pong");
+    assertThat(request.body()).isNull();
+  }
 
-    Helper setFormEncoded() {
-      requestType = RequestType.FORM_URL_ENCODED;
-      return this;
+  @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method() {
+        return null;
+      }
     }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addPathParam("ping", "pong");
+        request.addQueryParam("butter", "finger");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
+    assertThat(request.body()).isNull();
+  }
 
-    Request build() throws Exception {
-      if (method == null) {
-        throw new IllegalStateException("Method must be set.");
+  @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/{kit}/") //
+      Response method(@Path("ping") String ping) {
+        return null;
       }
-      if (path == null) {
-        throw new IllegalStateException("Path must be set.");
+    }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addPathParam("kit", "kat");
+        request.addQueryParam("butter", "finger");
       }
+    };
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
+    assertThat(request.body()).isNull();
+  }
 
-      Method method = getClass().getDeclaredMethod("dummySync");
+  @Test public void pathParamRequired() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+    }
+  }
 
-      RestMethodInfo methodInfo = new RestMethodInfo(method);
-      methodInfo.requestMethod = this.method;
-      methodInfo.requestHasBody = hasBody;
-      methodInfo.requestType = requestType;
-      methodInfo.requestUrl = path;
-      methodInfo.requestUrlParamNames = RestMethodInfo.parsePathParameters(path);
-      methodInfo.requestQuery = query;
-      methodInfo.requestParamNames = paramNames.toArray(new String[paramNames.size()]);
-      methodInfo.requestParamUsage = paramUsages.toArray(new ParamUsage[paramUsages.size()]);
-      methodInfo.headers = methodInfo.parseHeaders(headers.toArray(new String[headers.size()]));
-      methodInfo.loaded = true;
+  @Test public void getWithQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+    assertThat(request.body()).isNull();
+  }
 
-      RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, GSON);
+  @Test public void getWithEncodedQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query(value = "ping", encodeValue = false) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p+o+n+g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
+    assertThat(request.body()).isNull();
+  }
 
-      // Simulate request interceptor invocation.
-      for (Header header : interceptorHeaders) {
-        requestBuilder.addHeader(header.getName(), header.getValue());
+  @Test public void getWithEncodeNameQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query(value = "pi ng", encodeName = true) String ping) {
+        return null;
       }
-      for (Map.Entry<String, String> entry : interceptorPathParams.entrySet()) {
-        requestBuilder.addPathParam(entry.getKey(), entry.getValue());
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query(value = "pi ng", encodeName = true, encodeValue = false) String ping) {
+        return null;
       }
-      for (Map.Entry<String, String> entry : interceptorQueryParams.entrySet()) {
-        requestBuilder.addQueryParam(entry.getKey(), entry.getValue());
+    }
+    Request request = buildRequest(Example.class, "po+ng");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=po+ng");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("ping") String ping) {
+        return null;
       }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  }
 
-      requestBuilder.setArguments(args.toArray(new Object[args.size()]));
+  @Test public void queryParamOptional() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("foo") String foo, @Query("ping") String ping,
+          @Query("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+  }
+
+  @Test public void getWithQueryUrlAndParam() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Response method(@Query("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+    assertThat(request.body()).isNull();
+  }
 
-      return requestBuilder.build();
+  @Test public void getWithQuery() {
+    class Example {
+      @GET("/foo/bar/?hi=mom") //
+      Response method() {
+        return null;
+      }
     }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+    assertThat(request.body()).isNull();
+  }
 
-    @SuppressWarnings("UnusedDeclaration") // Accessed via reflection.
-    private Object dummySync() {
-      return null;
+  @Test public void getWithPathAndQueryParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping, @Query("kit") String kit,
+          @Query("riff") String riff) {
+        return null;
+      }
     }
+
+    Request request = buildRequest(Example.class, "pong", "kat", "raff");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryQuestionMarkParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong?", "kat?");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryAmpersandParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong&", "kat&");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%26/?kit=kat%26");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithPathAndQueryHashParam() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong#", "kat#");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("key") List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("key") Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Query("key") int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@QueryMap Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put("kit", "kat");
+    params.put("foo", null);
+    params.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put("kit", "k%20t");
+    params.put("foo", null);
+    params.put("ping", "p%20g");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodeNameQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put("k it", "k t");
+    params.put("fo o", null);
+    params.put("pi ng", "p g");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(
+          @QueryMap(encodeNames = true, encodeValues = false) Map<String, Object> query) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    params.put("k it", "k%20t");
+    params.put("fo o", null);
+    params.put("pi ng", "p%20g");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void normalPostWithPathParam() {
+    class Example {
+      @POST("/foo/bar/{ping}/") //
+      Response method(@Path("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "");
+  }
+
+  @Test public void bodyGson() {
+    class Example {
+      @POST("/foo/bar/") //
+      Response method(@Body Object body) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, Arrays.asList("quick", "brown", "fox"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
+  }
+
+  @Test public void bodyTypedInput() {
+    class Example {
+      @POST("/foo/bar/") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void bodyRequired() {
+    class Example {
+      @POST("/foo/bar/") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+    }
+  }
+
+  @Test public void bodyWithPathParams() {
+    class Example {
+      @POST("/foo/bar/{ping}/{kit}/") //
+      Response method(@Path("ping") String ping, @Body Object body, @Path("kit") String kit) {
+        return null;
+      }
+    }
+    Request request =
+        buildRequest(Example.class, "pong", Arrays.asList("quick", "brown", "fox"), "kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
+  }
+  //
+  //@Test public void simpleMultipart() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") String ping, @Part("kit") TypedInput kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartWithEncoding() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part(value = "ping", encoding = "8-bit") String ping,
+  //        @Part(value = "kit", encoding = "7-bit") TypedInput kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"")
+  //      .contains("Content-Transfer-Encoding: 7-bit")
+  //      .endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMap() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put("kit", new TypedString("kat"));
+  //
+  //  Request request = buildRequest(Example.class, params);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMapWithEncoding() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put("kit", new TypedString("kat"));
+  //
+  //  Request request = buildRequest(Example.class, params);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(2);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"\r\n")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\npong");
+  //
+  //  String two = new String(iterator.next(), UTF_8);
+  //  assertThat(two).contains("name=\"kit\"")
+  //      .contains("Content-Transfer-Encoding: 8-bit")
+  //      .endsWith("\r\nkat");
+  //}
+  //
+  //@Test public void multipartPartMapRejectsNullKeys() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put(null, "kat");
+  //
+  //  try {
+  //    buildRequest(Example.class, params);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 part map contained null key.");
+  //  }
+  //}
+  //
+  //@Test public void multipartNullRemovesPart() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") String ping, @Part("fizz") String fizz) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "pong", null);
+  //  assertThat(request.method()).isEqualTo("POST");
+  //  assertThat(request.headers().size()).isZero();
+  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+  //
+  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
+  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
+  //  assertThat(bodyParts).hasSize(1);
+  //
+  //  Iterator<byte[]> iterator = bodyParts.iterator();
+  //
+  //  String one = new String(iterator.next(), UTF_8);
+  //  assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
+  //}
+  //
+  //@Test public void multipartPartOptional() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") RequestBody ping) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class, new Object[] { null });
+  //    fail();
+  //  } catch (IllegalStateException e) {
+  //    assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
+  //  }
+  //}
+  //
+  //@Test public void simpleFormEncoded() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", "pong");
+  //  assertBody(request.body(), "foo=bar&ping=pong");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na+me", encodeName = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na me", encodeValue = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba+r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedFieldOptional() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping,
+  //        @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", null, "kat");
+  //  assertBody(request.body(), "foo=bar&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldList() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Object[] values = { 1, 2, null, "three" };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldPrimitiveArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  int[] values = { 1, 2, 3 };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k+it", "k at");
+  //  fieldMap.put("pin+g", "po ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k it", "k+at");
+  //  fieldMap.put("pin g", "po+ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedFieldMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put("ping", "pong");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "kit=kat&ping=pong");
+  //}
+  //
+  //@Test public void fieldMapRejectsNullKeys() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap Map<String, Object> a) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put(null, "pong");
+  //
+  //  try {
+  //    buildRequest(Example.class, fieldMap);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 field map contained null key.");
+  //  }
+  //}
+  //
+  //@Test public void fieldMapMustBeAMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap List<String> a) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
+  //  }
+  //}
+
+  @Test public void simpleHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat"
+      })
+      Response method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void simpleInterceptorHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      Response method() {
+        return null;
+      }
+    }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addHeader("ping", "pong");
+        request.addHeader("kit", "kat");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headersAndInterceptorHeaders() {
+    class Example {
+      @GET("/foo/bar/") //
+      @Headers("ping: pong") //
+      Response method() {
+        return null;
+      }
+    }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addHeader("kit", "kat");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void allThreeHeaderTypes() {
+    class Example {
+      @GET("/foo/bar/") //
+      @Headers("ping: pong") //
+      Response method(@Header("fizz") String fizz) {
+        return null;
+      }
+    }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addHeader("kit", "kat");
+      }
+    };
+    Request request = buildRequest(Example.class, "buzz");
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(3);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(headers.get("fizz")).isEqualTo("buzz");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamToString() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Header("kit") BigInteger kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new BigInteger("1234"));
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(1);
+    assertThat(headers.get("kit")).isEqualTo("1234");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      @Headers("ping: pong") //
+      Response method(@Header("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "kat");
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.get("ping")).isEqualTo("pong");
+    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Header("foo") List<String> kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void headerParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Response method(@Header("foo") String[] kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
+    assertThat(request.method()).isEqualTo("GET");
+    com.squareup.okhttp.Headers headers = request.headers();
+    assertThat(headers.size()).isEqualTo(2);
+    assertThat(headers.values("foo")).containsExactly("bar", "baz");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void contentTypeAnnotationHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Response method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+    class Example {
+      @DELETE("/") //
+      @Headers("Content-Type: text/not-plain") //
+      Response method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeInterceptorHeaderAddsHeaderWithNoBody() {
+    class Example {
+      @DELETE("/") //
+      Response method() {
+        return null;
+      }
+    }
+    interceptor = new RequestInterceptor() {
+      @Override public void intercept(RequestFacade request) {
+        request.addHeader("Content-Type", "text/not-plain");
+      }
+    };
+    Request request = buildRequest(Example.class);
+    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+  }
+
+  @Test public void contentTypeParameterHeaderOverrides() {
+    class Example {
+      @POST("/") //
+      Response method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    Request request = buildRequest(Example.class, "text/not-plain", body);
+    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+  }
+
+  private static void assertBody(RequestBody body, String expected) {
+    assertThat(body).isNotNull();
+    Buffer buffer = new Buffer();
+    try {
+      body.writeTo(buffer);
+      assertThat(buffer.readUtf8()).isEqualTo(expected);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private static final Converter GSON = new GsonConverter(new Gson());
+
+  private Request buildRequest(Class<?> cls, Object... args) {
+    Method method = TestingUtils.onlyMethod(cls);
+    MethodInfo methodInfo = new MethodInfo(method);
+
+    RequestBuilder builder = new RequestBuilder("http://example.com/", methodInfo, GSON);
+    if (interceptor != null) {
+      interceptor.intercept(builder);
+    }
+    builder.setArguments(args);
+
+    return builder.build();
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 545261f0d..d435fd514 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -1,109 +1,56 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.Executor;
+import com.google.gson.JsonParseException;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import retrofit.client.Client;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.converter.ConversionException;
 import retrofit.http.Body;
 import retrofit.http.GET;
 import retrofit.http.Headers;
 import retrofit.http.POST;
-import retrofit.http.Path;
 import retrofit.http.Streaming;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 import rx.Observable;
 import rx.functions.Action1;
 
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-import static retrofit.Profiler.RequestInformation;
-import static retrofit.RestAdapter.LogLevel.BASIC;
-import static retrofit.RestAdapter.LogLevel.FULL;
-import static retrofit.RestAdapter.LogLevel.HEADERS;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 import static retrofit.Utils.SynchronousExecutor;
 
 public class RestAdapterTest {
-  private static final List<Header> NO_HEADERS = Collections.emptyList();
-  private static final List<Header> TWO_HEADERS =
-      Arrays.asList(new Header("Content-Type", "application/json"),
-          new Header("Content-Length", "42"));
-
-  /** Not all servers play nice and add content-type headers to responses. */
-  private static final TypedInput NO_MIME_BODY = new TypedInput() {
-    @Override public String mimeType() {
-      return null;
-    }
-
-    @Override public long length() {
-      return 2;
-    }
-
-    @Override public InputStream in() throws IOException {
-      return new ByteArrayInputStream("Hi".getBytes("UTF-8"));
-    }
-  };
-
   private interface Example {
     @Headers("Foo: Bar")
     @GET("/") String something();
     @Headers("Foo: Bar")
-    @POST("/") Object something(@Body TypedOutput body);
     @GET("/") void something(Callback<String> callback);
     @GET("/") Response direct();
     @GET("/") void direct(Callback<Response> callback);
     @GET("/") @Streaming Response streaming();
     @POST("/") Observable<String> observable(@Body String body);
-    @POST("/{x}/{y}") Observable<Response> observable(@Path("x") String x, @Path("y") String y);
   }
   private interface InvalidExample extends Example {
   }
 
-  private Client mockClient;
-  private Executor mockRequestExecutor;
-  private Executor mockCallbackExecutor;
-  private Profiler<Object> mockProfiler;
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
   private Example example;
 
-  @SuppressWarnings("unchecked") // Mock profiler type erasure.
-  @Before public void setUp() throws Exception{
-    mockClient = mock(Client.class);
-    mockRequestExecutor = spy(new SynchronousExecutor());
-    mockCallbackExecutor = spy(new SynchronousExecutor());
-    mockProfiler = mock(Profiler.class);
+  @Before public void setUp() {
+    OkHttpClient client = new OkHttpClient();
 
     example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
+        .setClient(client)
+        .setCallbackExecutor(new SynchronousExecutor())
+        .setEndpoint(server.getUrl("/").toString())
         .build()
         .create(Example.class);
   }
@@ -117,517 +64,169 @@
   @Test public void interfaceWithExtendIsNotSupported() {
     try {
       new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
-      fail("Interface inheritance should not be supported.");
+      fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
     }
   }
 
-  @Test public void profilerObjectPassThrough() throws Exception {
-    Object data = new Object();
-    when(mockProfiler.beforeCall()).thenReturn(data);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey")));
-
-    example.something();
-
-    verify(mockProfiler).beforeCall();
-    verify(mockClient).execute(any(Request.class));
-    verify(mockProfiler).afterCall(any(RequestInformation.class), anyInt(), eq(200), same(data));
-  }
-
-  @Test public void logRequestResponseBasic() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(BASIC)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("Hi")));
-
-    example.something();
-    assertThat(logMessages).hasSize(2);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-  }
-
-  @Test public void logRequestResponseHeaders() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(HEADERS)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("Hi")));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyPresent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, new TypedString("{}")));
-
-    example.something(new TypedString("Hi"));
-    assertThat(logMessages).hasSize(13);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP POST http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("Content-Type: text/plain; charset=UTF-8");
-    assertThat(logMessages.get(3)).isEqualTo("Content-Length: 2");
-    assertThat(logMessages.get(4)).isEqualTo("");
-    assertThat(logMessages.get(5)).isEqualTo("Hi");
-    assertThat(logMessages.get(6)).isEqualTo("---> END HTTP (2-byte body)");
-    assertThat(logMessages.get(7)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(8)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(9)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(10)).isEqualTo("");
-    assertThat(logMessages.get(11)).isEqualTo("{}");
-    assertThat(logMessages.get(12)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, null));
-
-    example.something();
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
   @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-  }
-
-  @Test public void logSuccessfulRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", TWO_HEADERS, NO_MIME_BODY));
-
-    example.something();
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 200 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("Hi");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void synchronousDoesNotUseExecutors() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hi")));
-
-    example.something();
-
-    verifyZeroInteractions(mockRequestExecutor);
-    verifyZeroInteractions(mockCallbackExecutor);
-  }
-
-  @Test public void asynchronousUsesExecutors() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
-    Callback<String> callback = mock(Callback.class);
-
-    example.something(callback);
-
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq("Hey"), same(response));
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+    String string = example.something();
+    assertThat(string).isEqualTo("Hi");
   }
 
   @Test public void malformedResponseThrowsConversionException() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("{")));
-
+    server.enqueue(new MockResponse().setBody("{"));
     try {
       example.something();
-      fail("RetrofitError expected on malformed response body.");
+      fail();
     } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(200);
-      assertThat(e.getCause()).isInstanceOf(ConversionException.class);
-      assertThat(e.getResponse().getBody()).isNull();
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.UNEXPECTED);
+      assertThat(e.getResponse().code()).isEqualTo(200);
+      assertThat(e.getCause()).isInstanceOf(JsonParseException.class);
+      assertThat(e.getResponse().body()).isNull();
     }
   }
 
   @Test public void errorResponseThrowsHttpError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 500, "Internal Server Error", NO_HEADERS, null));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken"));
 
     try {
       example.something();
-      fail("RetrofitError expected on non-2XX response code.");
+      fail();
     } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
+      assertThat(e.getResponse().code()).isEqualTo(500);
       assertThat(e.getSuccessType()).isEqualTo(String.class);
     }
   }
 
-  @Test public void logErrorRequestResponseFullWhenMimeTypeMissing() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    Response responseMissingMimeType = //
-        new Response("http://example.com/", 403, "Forbidden", TWO_HEADERS, NO_MIME_BODY);
-
-    when(mockClient.execute(any(Request.class))).thenReturn(responseMissingMimeType);
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(403);
-    }
-
-    assertThat(logMessages).hasSize(9);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 403 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("");
-    assertThat(logMessages.get(7)).isEqualTo("Hi");
-    assertThat(logMessages.get(8)).isEqualTo("<--- END HTTP (2-byte body)");
-  }
-
-  @Test public void logErrorRequestResponseFullWhenResponseBodyAbsent() throws Exception {
-    final List<String> logMessages = new ArrayList<String>();
-    RestAdapter.Log log = new RestAdapter.Log() {
-      public void log(String message) {
-        logMessages.add(message);
-      }
-    };
-
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(log)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 500, "Internal Server Error", TWO_HEADERS, null));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on non-2XX response code.");
-    } catch (RetrofitError e) {
-      assertThat(e.getResponse().getStatus()).isEqualTo(500);
-    }
-
-    assertThat(logMessages).hasSize(7);
-    assertThat(logMessages.get(0)).isEqualTo("---> HTTP GET http://example.com/");
-    assertThat(logMessages.get(1)).isEqualTo("Foo: Bar");
-    assertThat(logMessages.get(2)).isEqualTo("---> END HTTP (no body)");
-    assertThat(logMessages.get(3)).matches("<--- HTTP 500 http://example.com/ \\([0-9]+ms\\)");
-    assertThat(logMessages.get(4)).isEqualTo("Content-Type: application/json");
-    assertThat(logMessages.get(5)).isEqualTo("Content-Length: 42");
-    assertThat(logMessages.get(6)).isEqualTo("<--- END HTTP (0-byte body)");
-  }
-
   @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    IOException exception = new IOException("I'm broken!");
-    when(mockClient.execute(any(Request.class))).thenThrow(exception);
+    server.enqueue(new MockResponse().setBody("Hi").setSocketPolicy(DISCONNECT_AT_START));
 
     try {
       example.something();
-      fail("RetrofitError expected when client throws exception.");
+      fail();
     } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
-    }
-  }
-
-  @Test public void bodyTypedInputExceptionThrowsNetworkError() throws Exception {
-    TypedInput body = spy(new TypedString("{}"));
-    InputStream bodyStream = mock(InputStream.class, new Answer() {
-      @Override public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new IOException("I'm broken!");
-      }
-    });
-    doReturn(bodyStream).when(body).in();
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, body));
-
-    try {
-      example.something();
-      fail("RetrofitError expected on malformed response body.");
-    } catch (RetrofitError e) {
-      assertThat(e.isNetworkError());
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-      assertThat(e.getCause()).hasMessage("I'm broken!");
-    }
-  }
-
-  @Test public void unexpectedExceptionThrows() {
-    RuntimeException exception = new RuntimeException("More breakage.");
-    when(mockProfiler.beforeCall()).thenThrow(exception);
-
-    try {
-      example.something();
-      fail("RetrofitError expected when unexpected exception thrown.");
-    } catch (RetrofitError e) {
-      assertThat(e.getCause()).isSameAs(exception);
+      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
     }
   }
 
   @Test public void getResponseDirectly() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, null);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    assertThat(example.direct()).isSameAs(response);
+    server.enqueue(new MockResponse().setBody("Hey"));
+    Response response = example.direct();
+    assertThat(response.body().string()).isEqualTo("Hey");
   }
 
   @Test public void streamingResponse() throws Exception {
-    final InputStream is = new ByteArrayInputStream("Hey".getBytes("UTF-8"));
-    TypedInput in = new TypedInput() {
-      @Override public String mimeType() {
-        return "text/string";
-      }
-
-      @Override public long length() {
-        return 3;
-      }
-
-      @Override public InputStream in() throws IOException {
-        return is;
-      }
-    };
-
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, in));
-
+    server.enqueue(new MockResponse().setBody("Hey").setBodyDelayTimeMs(500));
     Response response = example.streaming();
-    assertThat(response.getBody().in()).isSameAs(is);
-  }
-
-  @Test public void closeInputStream() throws IOException {
-    // Set logger and profiler on example to make sure we exercise all the code paths.
-    Example example = new RestAdapter.Builder() //
-        .setClient(mockClient)
-        .setExecutors(mockRequestExecutor, mockCallbackExecutor)
-        .setEndpoint("http://example.com")
-        .setProfiler(mockProfiler)
-        .setLog(RestAdapter.Log.NONE)
-        .setLogLevel(FULL)
-        .build()
-        .create(Example.class);
-
-    ByteArrayInputStream is = spy(new ByteArrayInputStream("hello".getBytes()));
-    TypedInput typedInput = mock(TypedInput.class);
-    when(typedInput.in()).thenReturn(is);
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, typedInput);
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    example.something();
-    verify(is).close();
+    long startNs = System.nanoTime();
+    response.body().string();
+    long tookNs = System.nanoTime() - startNs;
+    assertThat(tookNs).isGreaterThanOrEqualTo(500);
   }
 
   @Test public void getResponseDirectlyAsync() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    Callback<Response> callback = mock(Callback.class);
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    final AtomicReference<Response> responseRef = new AtomicReference<Response>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.direct(new Callback<Response>() {
+      @Override public void success(Response response, Response response2) {
+        responseRef.set(response);
+        latch.countDown();
+      }
 
-    example.direct(callback);
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
 
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
-    verify(callback).success(eq(response), same(response));
+    assertThat(responseRef.get().body().string()).isEqualTo("Hey");
   }
 
   @Test public void getAsync() throws Exception {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("Hey"));
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    Callback<String> callback = mock(Callback.class);
-
-    example.something(callback);
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.something(new Callback<String>() {
+      @Override public void success(String body, Response response) {
+        bodyRef.set(body);
+        latch.countDown();
+      }
 
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
 
-    ArgumentCaptor<String> responseCaptor = ArgumentCaptor.forClass(String.class);
-    verify(callback).success(responseCaptor.capture(), same(response));
-    assertThat(responseCaptor.getValue()).isEqualTo("Hey");
+    assertThat(bodyRef.get()).isEqualTo("Hey");
   }
 
-
   @Test public void errorAsync() throws Exception {
-    Response response = new Response("http://example.com/", 500, "Broken!", NO_HEADERS, new TypedString("Hey"));
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(response);
-    Callback<String> callback = mock(Callback.class);
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken!").setBody("Hey"));
 
-    example.something(callback);
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.something(new Callback<String>() {
+      @Override public void success(String s, Response response) {
+        throw new AssertionError();
+      }
 
-    verify(mockRequestExecutor).execute(any(CallbackRunnable.class));
-    verify(mockCallbackExecutor).execute(any(Runnable.class));
+      @Override public void failure(RetrofitError error) {
+        errorRef.set(error);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
 
-    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
-    verify(callback).failure(errorCaptor.capture());
-    RetrofitError error = errorCaptor.getValue();
-    assertThat(error.getResponse().getStatus()).isEqualTo(500);
-    assertThat(error.getResponse().getReason()).isEqualTo("Broken!");
+    RetrofitError error = errorRef.get();
+    assertThat(error.getResponse().code()).isEqualTo(500);
+    assertThat(error.getResponse().message()).isEqualTo("Broken!");
     assertThat(error.getSuccessType()).isEqualTo(String.class);
     assertThat(error.getBody()).isEqualTo("Hey");
   }
 
   @Test public void observableCallsOnNext() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    Action1<String> action = mock(Action1.class);
-    example.observable("Howdy").subscribe(action);
-    verify(action).call(eq("hello"));
-  }
-
-  @Test public void observableCallsOnError() throws Exception {
-    when(mockClient.execute(any(Request.class))) //
-        .thenReturn(new Response("http://example.com/", 300, "FAIL", NO_HEADERS, new TypedString("bummer")));
-    Action1<String> onSuccess = mock(Action1.class);
-    Action1<Throwable> onError = mock(Action1.class);
-    example.observable("Howdy").subscribe(onSuccess, onError);
-    verifyZeroInteractions(onSuccess);
-
-    ArgumentCaptor<RetrofitError> errorCaptor = ArgumentCaptor.forClass(RetrofitError.class);
-    verify(onError).call(errorCaptor.capture());
-    RetrofitError value = errorCaptor.getValue();
-    assertThat(value.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void observableHandlesParams() throws Exception {
-    ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
-    when(mockClient.execute(requestCaptor.capture())) //
-        .thenReturn(new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello")));
-    ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
-    Action1<Response> action = mock(Action1.class);
-    example.observable("X", "Y").subscribe(action);
-
-    Request request = requestCaptor.getValue();
-    assertThat(request.getUrl()).contains("/X/Y");
+    server.enqueue(new MockResponse().setBody("hello"));
+
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.observable("Howdy").subscribe(new Action1<String>() {
+      @Override public void call(String body) {
+        bodyRef.set(body);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
 
-    verify(action).call(responseCaptor.capture());
-    Response response = responseCaptor.getValue();
-    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(bodyRef.get()).isEqualTo("hello");
   }
 
-  @Test public void observableUsesHttpExecutor() throws IOException {
-    Response response = new Response("http://example.com/", 200, "OK", NO_HEADERS, new TypedString("hello"));
-    when(mockClient.execute(any(Request.class))).thenReturn(response);
+  @Test public void observableCallsOnError() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
 
-    example.observable("Howdy").subscribe(mock(Action1.class));
+    final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.observable("Howdy").subscribe(new Action1<String>() {
+      @Override public void call(String s) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable throwable) {
+        errorRef.set(throwable);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, TimeUnit.SECONDS));
 
-    verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
-    verifyZeroInteractions(mockCallbackExecutor);
+    RetrofitError error = (RetrofitError) errorRef.get();
+    assertThat(error.getResponse().code()).isEqualTo(500);
+    assertThat(error.getSuccessType()).isEqualTo(String.class);
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
deleted file mode 100644
index fcf67096f..000000000
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ /dev/null
@@ -1,1322 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.reflect.TypeToken;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-import retrofit.client.Response;
-import retrofit.http.Body;
-import retrofit.http.DELETE;
-import retrofit.http.EncodedPath;
-import retrofit.http.EncodedQuery;
-import retrofit.http.EncodedQueryMap;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.FormUrlEncoded;
-import retrofit.http.GET;
-import retrofit.http.HEAD;
-import retrofit.http.Header;
-import retrofit.http.Headers;
-import retrofit.http.Multipart;
-import retrofit.http.PATCH;
-import retrofit.http.POST;
-import retrofit.http.PUT;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
-import retrofit.http.RestMethod;
-import retrofit.http.Streaming;
-import retrofit.mime.TypedOutput;
-import rx.Observable;
-
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit.RestMethodInfo.ParamUsage.BODY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_PATH;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.ENCODED_QUERY_MAP;
-import static retrofit.RestMethodInfo.ParamUsage.FIELD;
-import static retrofit.RestMethodInfo.ParamUsage.FIELD_MAP;
-import static retrofit.RestMethodInfo.ParamUsage.HEADER;
-import static retrofit.RestMethodInfo.ParamUsage.PATH;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY;
-import static retrofit.RestMethodInfo.ParamUsage.QUERY_MAP;
-import static retrofit.RestMethodInfo.RequestType.FORM_URL_ENCODED;
-import static retrofit.RestMethodInfo.RequestType.MULTIPART;
-import static retrofit.RestMethodInfo.RequestType.SIMPLE;
-
-@SuppressWarnings("unused") // Lots of unused parameters for example code.
-public class RestMethodInfoTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = RestMethodInfo.parsePathParameters(path);
-    assertThat(calculated).hasSize(expected.length);
-    if (expected.length > 0) {
-      assertThat(calculated).containsExactly(expected);
-    }
-  }
-
-  @Test public void pathMustBePrefixedWithSlash() {
-    class Example {
-      @GET("foo/bar") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: URL path \"foo/bar\" must start with '/'.");
-    }
-  }
-
-  @Test public void concreteCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void concreteCallbackTypesWithParams() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id, ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<Response> cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypesWithParams() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id, Callback<Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void wildcardGenericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<? extends Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackWithGenericType() {
-    class Example {
-      @GET("/foo") void a(Callback<List<String>> c) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
-  // a little of everything: a parameterized type, a generic array, and a wildcard.
-  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
-
-  @Test public void extendingGenericCallback() throws Exception {
-    class Example {
-      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.responseObjectType).isEqualTo(
-        RestMethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
-  }
-
-  @Test public void synchronousResponse() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void synchronousGenericResponse() {
-    class Example {
-      @GET("/foo") List<String> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isTrue();
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test public void streamingResponse() {
-    class Example {
-      @GET("/foo") @Streaming Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.isStreaming).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void streamingResponseWithCallback() {
-    class Example {
-      @GET("/foo") @Streaming void a(Callback<Response> callback) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.isStreaming).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void streamingResponseNotAllowed() {
-    class Example {
-      @GET("/foo") @Streaming String a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Only methods having Response as data type are allowed to have @Streaming annotation.");
-    }
-  }
-
-  @Test public void streamingResponseWithCallbackNotAllowed() {
-    class Example {
-      @GET("/foo") @Streaming void a(Callback<String> callback) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Only methods having Response as data type are allowed to have @Streaming annotation.");
-    }
-  }
-
-  @Test public void observableResponse() {
-    class Example {
-      @GET("/foo") Observable<Response> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.isObservable).isTrue();
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableGenericResponse() {
-    class Example {
-      @GET("/foo") Observable<List<String>> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    assertThat(methodInfo.isSynchronous).isFalse();
-    assertThat(methodInfo.isObservable).isTrue();
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test public void observableWithCallback() {
-    class Example {
-      @GET("/foo") Observable<Response> a(Callback<Response> callback) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    try {
-      new RestMethodInfo(method);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Must have return type or Callback as last argument, not both.");
-    }
-  }
-
-  @Test public void missingCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(@Query("id") String id) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    try {
-      new RestMethodInfo(method);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Must have either a return type or Callback as last argument.");
-    }
-  }
-
-  @Test public void nonParameterizedCallbackFails() {
-    class Example {
-      @GET("/foo") void a(Callback cb) {
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    try {
-      new RestMethodInfo(method);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Last parameter must be of type Callback<X> or Callback<? super X>.");
-    }
-  }
-
-  @Test public void synchronousWithAsyncCallback() {
-    class Example {
-      @GET("/foo") Response a(Callback<Response> callback) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    try {
-      new RestMethodInfo(method);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Must have return type or Callback as last argument, not both.");
-    }
-  }
-
-  @Test
-  public void lackingMethod() {
-    class Example {
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-  }
-
-  @Test public void deleteMethod() {
-    class Example {
-      @DELETE("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("DELETE");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void getMethod() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("GET");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void headMethod() {
-    class Example {
-      @HEAD("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("HEAD");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void postMethod() {
-    class Example {
-      @POST("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("POST");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void putMethod() {
-    class Example {
-      @PUT("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("PUT");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void patchMethod() {
-    class Example {
-      @PATCH("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("PATCH");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") @POST("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Only one HTTP method is allowed. Found: PATCH and POST.");
-    }
-  }
-
-  @RestMethod("BAD")
-  @Target(METHOD) @Retention(RUNTIME)
-  private @interface BAD_CUSTOM {
-    int value();
-  }
-
-  @Test public void customWithoutRestMethod() {
-    class Example {
-      @BAD_CUSTOM(12) Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Failed to extract String 'value' from @BAD_CUSTOM annotation.");
-    }
-  }
-
-  @RestMethod("CUSTOM1")
-  @Target(METHOD) @Retention(RUNTIME)
-  private @interface CUSTOM1 {
-    String value();
-  }
-
-  @Test public void custom1Method() {
-    class Example {
-      @CUSTOM1("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM1");
-    assertThat(methodInfo.requestHasBody).isFalse();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @RestMethod(value = "CUSTOM2", hasBody = true)
-  @Target(METHOD) @Retention(RUNTIME)
-  private @interface CUSTOM2 {
-    String value();
-  }
-
-  @Test public void custom2Method() {
-    class Example {
-      @CUSTOM2("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestMethod).isEqualTo("CUSTOM2");
-    assertThat(methodInfo.requestHasBody).isTrue();
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-  }
-
-  @Test public void singlePathQueryParam() {
-    class Example {
-      @GET("/foo?a=b")
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestUrl).isEqualTo("/foo");
-    assertThat(methodInfo.requestQuery).isEqualTo("a=b");
-  }
-
-  @Test public void emptyParams() {
-    class Example {
-      @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).isEmpty();
-    assertThat(methodInfo.requestParamUsage).isEmpty();
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singlePathParam() {
-    class Example {
-      @GET("/{a}") Response a(@Path("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleEncodedPathParam() {
-    class Example {
-      @GET("/{a}") Response a(@EncodedPath("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleQueryParam() {
-    class Example {
-      @GET("/") Response a(@Query("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void singleEncodedQueryParam() {
-    class Example {
-      @GET("/") Response a(@EncodedQuery("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly("a");
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void multipleQueryParams() {
-    class Example {
-      @GET("/") Response a(@Query("a") String a, @Query("b") String b, @Query("c") String c) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(3).containsExactly("a", "b", "c");
-    assertThat(methodInfo.requestParamUsage).hasSize(3).containsExactly(QUERY, QUERY, QUERY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void queryMap() {
-    class Example {
-      @GET("/") Response a(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsNull();
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(QUERY_MAP);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") Response a(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: @QueryMap parameter type must be Map. (parameter #1)");
-    }
-  }
-
-  @Test public void encodedQueryMap() {
-    class Example {
-      @GET("/") Response a(@EncodedQueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsNull();
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(ENCODED_QUERY_MAP);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void encodedQueryMapMustBeAMap() {
-    class Example {
-      @GET("/") Response a(@EncodedQueryMap List<String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @EncodedQueryMap parameter type must be Map. (parameter #1)");
-    }
-  }
-
-  @Test public void fieldMap() {
-    class Example {
-      @FormUrlEncoded @POST("/") Response a(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsNull();
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(FIELD_MAP);
-    assertThat(methodInfo.requestType).isEqualTo(FORM_URL_ENCODED);
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded @POST("/") Response a(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: @FieldMap parameter type must be Map. (parameter #1)");
-    }
-  }
-
-  @Test public void bodyObject() {
-    class Example {
-      @PUT("/") Response a(@Body Object o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void bodyTypedBytes() {
-    class Example {
-      @PUT("/") Response a(@Body TypedOutput o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).hasSize(1).containsExactly(new String[] { null });
-    assertThat(methodInfo.requestParamUsage).hasSize(1).containsExactly(BODY);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") Response a(@Body int o1, @Body int o2) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: Multiple @Body method annotations found.");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart
-      @PUT("/") Response a(@Part("one") int o1, @Body int o2) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
-    }
-  }
-
-  @Test public void bodyWithOtherParams() {
-    class Example {
-      @PUT("/{a}/{c}") Response a(@Path("a") int a, @Body int b, @Path("c") int c) {
-        return null;
-      }
-    }
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).containsExactly("a", null, "c");
-    assertThat(methodInfo.requestParamUsage).containsExactly(PATH, BODY, PATH);
-    assertThat(methodInfo.requestType).isEqualTo(SIMPLE);
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") Response a(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") Response a(String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: No Retrofit annotation found. (parameter #1)");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") Response a(@Body Object o) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Non-body HTTP method cannot contain @Body or @TypedOutput.");
-    }
-  }
-
-  @Test public void simpleMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void twoTypedBytesMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a, @Part("b") TypedOutput b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void twoTypesMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a, @Part("b") int b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void partMapMultipart() {
-    class Example {
-      @Multipart @PUT("/")
-      Response a(@Part("a") TypedOutput a, @PartMap Map<String, String> b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(MULTIPART);
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") Response a(@Part("a") int a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Part parameters can only be used with multipart encoding. (parameter #1)");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") Response a(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart @POST("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: Multipart method must contain at least one @Part.");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") Response a(@Field("a") int a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Field parameters can only be used with form encoding. (parameter #1)");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") Response a(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @FieldMap parameters can only be used with form encoding. (parameter #1)");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded @GET("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded @POST("/") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: Form-encoded method must contain at least one @Field.");
-    }
-  }
-
-  @Test public void simpleFormEncoding() {
-    class Example {
-      @FormUrlEncoded @PUT("/")
-      Response a(@Field("a") String a) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestType).isEqualTo(FORM_URL_ENCODED);
-    assertThat(methodInfo.requestParamUsage).containsExactly(FIELD);
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") @Headers({}) Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: @Headers annotation is empty.");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") @Headers("Malformed") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
-    }
-  }
-
-  @Test public void twoMethodHeaders() {
-
-    class Example {
-      @GET("/") @Headers({
-        "X-Foo: Bar",
-        "X-Ping: Pong"
-      }) Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.headers).isEqualTo(
-        Arrays.asList(new retrofit.client.Header("X-Foo", "Bar"),
-            new retrofit.client.Header("X-Ping", "Pong")));
-  }
-
-  @Test public void twoHeaderParams() {
-    class Example {
-      @GET("/")
-      Response a(@Header("a") String a, @Header("b") String b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    methodInfo.init();
-
-    assertThat(methodInfo.requestParamNames).containsExactly("a", "b");
-    assertThat(methodInfo.requestParamUsage).containsExactly(HEADER, HEADER);
-  }
-
-  @Test public void headerParamMustBeString() {
-    class Example {
-      @GET("/")
-      Response a(@Header("a") TypedOutput a, @Header("b") int b) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Header parameter type must be String. Found: TypedOutput. (parameter #1)");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart
-      @FormUrlEncoded
-      @POST("/")
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: Only one encoding annotation is allowed.");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded
-      @Multipart
-      @POST("/")
-      Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.a: Only one encoding annotation is allowed.");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") Response a(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}. Found: hey! (parameter #1)");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") Response a(@Path("bar") String thing) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.getMethod(Example.class, "a");
-    RestMethodInfo methodInfo = new RestMethodInfo(method);
-    try {
-      methodInfo.init();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.a: URL query string \"bar={bar}\" must not have replace block.");
-    }
-  }
-
-  private static interface ResponseCallback extends Callback<Response> {
-  }
-
-  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RxSupportTest.java b/retrofit/src/test/java/retrofit/RxSupportTest.java
deleted file mode 100644
index 287d7e3fe..000000000
--- a/retrofit/src/test/java/retrofit/RxSupportTest.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package retrofit;
-
-import java.util.ArrayDeque;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import retrofit.client.Header;
-import retrofit.client.Response;
-import retrofit.mime.TypedInput;
-import rx.Observer;
-import rx.Subscription;
-import rx.schedulers.Schedulers;
-import rx.schedulers.TestScheduler;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static retrofit.RequestInterceptor.RequestFacade;
-import static retrofit.RxSupport.Invoker;
-
-public class RxSupportTest {
-
-  private Object response;
-  private ResponseWrapper responseWrapper;
-  private Invoker invoker = spy(new Invoker() {
-    @Override public ResponseWrapper invoke(RequestInterceptor requestInterceptor) {
-      return responseWrapper;
-    }
-  });
-  private RequestInterceptor requestInterceptor = spy(new RequestInterceptor() {
-    @Override public void intercept(RequestFacade request) {
-    }
-  });
-
-  private QueuedSynchronousExecutor executor;
-  private RxSupport rxSupport;
-
-  @Mock Observer<Object> subscriber;
-
-  @Before public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    response = new Object();
-    responseWrapper = new ResponseWrapper(
-            new Response(
-                    "http://example.com", 200, "Success",
-                    Collections.<Header>emptyList(), mock(TypedInput.class)
-            ), response
-    );
-    executor = spy(new QueuedSynchronousExecutor());
-    rxSupport = new RxSupport(executor, ErrorHandler.DEFAULT, requestInterceptor);
-  }
-
-  @Test public void observableCallsOnNextOnHttpExecutor() {
-    rxSupport.createRequestObservable(invoker).subscribe(subscriber);
-    executor.executeNextInQueue();
-    verify(subscriber, times(1)).onNext(response);
-  }
-
-  @Test public void observableCallsOnNextOnHttpExecutorWithSubscriber() {
-    TestScheduler test = Schedulers.test();
-    rxSupport.createRequestObservable(invoker).subscribeOn(test).subscribe(subscriber);
-    // Subscription is handled via the Scheduler.
-    test.triggerActions();
-    // This will only execute up to the executor in OnSubscribe.
-    verify(subscriber, never()).onNext(any());
-    // Upon continuing the executor we then run the retrofit request.
-    executor.executeNextInQueue();
-    verify(subscriber, times(1)).onNext(response);
-  }
-
-  @Test public void observableUnSubscribesDoesNotExecuteCallable() throws Exception {
-    Subscription subscription = rxSupport.createRequestObservable(invoker).subscribe(subscriber);
-    verify(subscriber, never()).onNext(any());
-
-    // UnSubscribe here should cancel the queued runnable.
-    subscription.unsubscribe();
-
-    executor.executeNextInQueue();
-    verify(invoker, never()).invoke(any(RequestInterceptor.class));
-    verify(subscriber, never()).onNext(response);
-  }
-
-  @Test public void observableCallsOperatorsOffHttpExecutor() {
-    TestScheduler test = Schedulers.test();
-    rxSupport.createRequestObservable(invoker)
-            .delaySubscription(1000, TimeUnit.MILLISECONDS, test)
-            .subscribe(subscriber);
-
-    verify(subscriber, never()).onNext(any());
-    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
-    // Upon continuing the executor we then run the retrofit request.
-    executor.executeNextInQueue();
-    verify(subscriber, times(1)).onNext(response);
-  }
-
-  @Test public void observableDoesNotLockExecutor() {
-    TestScheduler test = Schedulers.test();
-    rxSupport.createRequestObservable(invoker)
-            .delay(1000, TimeUnit.MILLISECONDS, test)
-            .subscribe(subscriber);
-
-    rxSupport.createRequestObservable(invoker)
-            .delay(2000, TimeUnit.MILLISECONDS, test)
-            .subscribe(subscriber);
-
-    // Nothing fired yet
-    verify(subscriber, never()).onNext(any());
-    // Subscriptions should of been queued up and executed even tho we delayed on the Subscriber.
-    executor.executeNextInQueue();
-    executor.executeNextInQueue();
-
-    verify(subscriber, never()).onNext(response);
-
-    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
-    verify(subscriber, times(1)).onNext(response);
-
-    test.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
-    verify(subscriber, times(2)).onNext(response);
-  }
-
-  @Test public void observableRespectsObserveOn() throws Exception {
-    TestScheduler observe = Schedulers.test();
-    rxSupport.createRequestObservable(invoker)
-            .observeOn(observe)
-            .subscribe(subscriber);
-
-    verify(subscriber, never()).onNext(any());
-    executor.executeNextInQueue();
-
-    // Should have no response yet, but callback should of been executed.
-    verify(subscriber, never()).onNext(any());
-    verify(invoker, times(1)).invoke(any(RequestInterceptor.class));
-
-    // Forward the Observable Scheduler
-    observe.triggerActions();
-    verify(subscriber, times(1)).onNext(response);
-  }
-
-  @Test public void observableCallsInterceptorForEverySubscription() throws Exception {
-    rxSupport.createRequestObservable(invoker).subscribe(subscriber);
-    rxSupport.createRequestObservable(invoker).subscribe(subscriber);
-
-    // The interceptor should have been called for each request upon subscription.
-    verify(requestInterceptor, times(2)).intercept(any(RequestFacade.class));
-
-    // Background execution of the requests should not touch the interceptor.
-    executor.executeAll();
-    verifyNoMoreInteractions(requestInterceptor);
-  }
-
-  /**
-   * Test Executor to iterate through Executions to aid in checking
-   * that the Observable implementation is correct.
-   */
-  static class QueuedSynchronousExecutor implements Executor {
-    Deque<Runnable> runnableQueue = new ArrayDeque<Runnable>();
-
-    @Override public void execute(Runnable runnable) {
-      runnableQueue.add(runnable);
-    }
-
-    /**
-     * Will throw exception if you are expecting something to be added to the Executor
-     * and it hasn't.
-     */
-    void executeNextInQueue() {
-      runnableQueue.removeFirst().run();
-    }
-
-    /**
-     * Executes any queued executions on the executor.
-     */
-    void executeAll() {
-      Iterator<Runnable> iterator = runnableQueue.iterator();
-      while (iterator.hasNext()) {
-        Runnable next = iterator.next();
-        next.run();
-        iterator.remove();
-      }
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/TestingUtils.java b/retrofit/src/test/java/retrofit/TestingUtils.java
index ea9ca09a3..cc65e72f6 100644
--- a/retrofit/src/test/java/retrofit/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/TestingUtils.java
@@ -1,33 +1,14 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.io.IOException;
 import java.lang.reflect.Method;
-import java.util.Map;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-public abstract class TestingUtils {
-  public static Method getMethod(Class c, String name) {
-    for (Method method : c.getDeclaredMethods()) {
-      if (method.getName().equals(name)) {
-        return method;
-      }
-    }
-    throw new IllegalArgumentException("Unknown method '" + name + "' on " + c);
-  }
-
-  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
-    MultipartTypedOutput typedOutput = new MultipartTypedOutput();
-    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
-      typedOutput.addPart(part.getKey(), part.getValue());
+public final class TestingUtils {
+  public static Method onlyMethod(Class c) {
+    Method[] declaredMethods = c.getDeclaredMethods();
+    if (declaredMethods.length == 1) {
+      return declaredMethods[0];
     }
-    return typedOutput;
-  }
-
-  public static void assertBytes(byte[] bytes, String expected) throws IOException {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
+    throw new IllegalArgumentException("More than one method declared.");
   }
 }
diff --git a/retrofit/src/test/java/retrofit/appengine/UrlFetchClientTest.java b/retrofit/src/test/java/retrofit/appengine/UrlFetchClientTest.java
deleted file mode 100644
index 35455fb65..000000000
--- a/retrofit/src/test/java/retrofit/appengine/UrlFetchClientTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-// Copyright 2014 Square, Inc.
-package retrofit.appengine;
-
-import com.google.appengine.api.urlfetch.HTTPHeader;
-import com.google.appengine.api.urlfetch.HTTPRequest;
-import com.google.appengine.api.urlfetch.HTTPResponse;
-import com.google.common.io.ByteStreams;
-import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-import retrofit.TestingUtils;
-import retrofit.client.Header;
-import retrofit.client.Request;
-import retrofit.client.Response;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static com.google.appengine.api.urlfetch.HTTPMethod.GET;
-import static com.google.appengine.api.urlfetch.HTTPMethod.POST;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static retrofit.TestingUtils.assertBytes;
-
-public class UrlFetchClientTest {
-  private static final String HOST = "http://example.com";
-
-  @Test public void get() throws IOException {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
-    HTTPRequest fetchRequest = UrlFetchClient.createRequest(request);
-
-    assertThat(fetchRequest.getMethod()).isEqualTo(GET);
-    assertThat(fetchRequest.getURL().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(fetchRequest.getHeaders()).isEmpty();
-    assertThat(fetchRequest.getPayload()).isNull();
-  }
-
-  @Test public void post() throws IOException {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
-    HTTPRequest fetchRequest = UrlFetchClient.createRequest(request);
-
-    assertThat(fetchRequest.getMethod()).isEqualTo(POST);
-    assertThat(fetchRequest.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
-    List<HTTPHeader> fetchHeaders = fetchRequest.getHeaders();
-    assertThat(fetchHeaders).hasSize(0);
-    assertBytes(fetchRequest.getPayload(), "hi");
-  }
-
-  @Test public void multipart() throws IOException {
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
-    bodyParams.put("foo", new TypedString("bar"));
-    bodyParams.put("ping", new TypedString("pong"));
-    TypedOutput body = TestingUtils.createMultipart(bodyParams);
-    Request request = new Request("POST", HOST + "/that/", null, body);
-    HTTPRequest fetchRequest = UrlFetchClient.createRequest(request);
-
-    assertThat(fetchRequest.getMethod()).isEqualTo(POST);
-    assertThat(fetchRequest.getURL().toString()).isEqualTo(HOST + "/that/");
-    List<HTTPHeader> fetchHeaders = fetchRequest.getHeaders();
-    assertThat(fetchHeaders).hasSize(0);
-    assertThat(fetchRequest.getPayload()).isNotEmpty();
-  }
-
-  @Test public void headers() throws IOException {
-    List<Header> headers = new ArrayList<Header>();
-    headers.add(new Header("kit", "kat"));
-    headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-    HTTPRequest fetchRequest = UrlFetchClient.createRequest(request);
-
-    List<HTTPHeader> fetchHeaders = fetchRequest.getHeaders();
-    assertThat(fetchHeaders).hasSize(2);
-    assertHeader(fetchHeaders.get(0), "kit", "kat");
-    assertHeader(fetchHeaders.get(1), "foo", "bar");
-  }
-
-  @Test public void response() throws Exception {
-    HTTPResponse fetchResponse = mock(HTTPResponse.class);
-    when(fetchResponse.getHeaders()).thenReturn(
-        asList(new HTTPHeader("foo", "bar"), new HTTPHeader("kit", "kat"),
-            new HTTPHeader("Content-Type", "text/plain")));
-    when(fetchResponse.getContent()).thenReturn("hello".getBytes("UTF-8"));
-    when(fetchResponse.getFinalUrl()).thenReturn(new URL(HOST + "/foo/bar/"));
-    when(fetchResponse.getResponseCode()).thenReturn(200);
-
-    Response response = UrlFetchClient.parseResponse(fetchResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void emptyResponse() throws Exception {
-    HTTPResponse fetchResponse = mock(HTTPResponse.class);
-    when(fetchResponse.getHeaders()).thenReturn(
-        asList(new HTTPHeader("foo", "bar"), new HTTPHeader("kit", "kat")));
-    when(fetchResponse.getContent()).thenReturn(null);
-    when(fetchResponse.getFinalUrl()).thenReturn(new URL(HOST + "/foo/bar/"));
-    when(fetchResponse.getResponseCode()).thenReturn(200);
-
-    Response response = UrlFetchClient.parseResponse(fetchResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-    assertThat(response.getBody()).isNull();
-  }
-
-  private static void assertHeader(HTTPHeader header, String name, String value) {
-    assertThat(header.getName()).isEqualTo(name);
-    assertThat(header.getValue()).isEqualTo(value);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/ApacheClientTest.java b/retrofit/src/test/java/retrofit/client/ApacheClientTest.java
deleted file mode 100644
index 4cb15bbb8..000000000
--- a/retrofit/src/test/java/retrofit/client/ApacheClientTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import com.google.common.io.ByteStreams;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpEntityEnclosingRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpVersion;
-import org.apache.http.StatusLine;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.message.BasicHttpResponse;
-import org.apache.http.message.BasicStatusLine;
-import org.junit.Test;
-import retrofit.TestingUtils;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit.TestingUtils.assertBytes;
-import static retrofit.client.ApacheClient.TypedOutputEntity;
-
-public class ApacheClientTest {
-  private static final String HOST = "http://example.com";
-
-  @Test public void get() {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("GET");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(apacheRequest.getAllHeaders()).isEmpty();
-
-    if (apacheRequest instanceof HttpEntityEnclosingRequest) {
-      HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-      assertThat(entityRequest.getEntity()).isNull();
-    }
-  }
-
-  @Test public void post() throws IOException {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("POST");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(apacheRequest.getAllHeaders()).isEmpty();
-
-    assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
-    HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    HttpEntity entity = entityRequest.getEntity();
-    assertThat(entity).isNotNull();
-    assertBytes(ByteStreams.toByteArray(entity.getContent()), "hi");
-  }
-
-  @Test public void multipart() {
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
-    bodyParams.put("foo", new TypedString("bar"));
-    bodyParams.put("ping", new TypedString("pong"));
-    TypedOutput body = TestingUtils.createMultipart(bodyParams);
-    Request request = new Request("POST", HOST + "/that/", null, body);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getMethod()).isEqualTo("POST");
-    assertThat(apacheRequest.getURI().toString()).isEqualTo(HOST + "/that/");
-    assertThat(apacheRequest.getAllHeaders()).isEmpty();
-
-    assertThat(apacheRequest).isInstanceOf(HttpEntityEnclosingRequest.class);
-    HttpEntityEnclosingRequest entityRequest = (HttpEntityEnclosingRequest) apacheRequest;
-    TypedOutputEntity entity = (TypedOutputEntity) entityRequest.getEntity();
-    assertThat(entity.typedOutput).isInstanceOf(MultipartTypedOutput.class);
-    // TODO test more?
-  }
-
-  @Test public void headers() {
-    List<Header> headers = new ArrayList<Header>();
-    headers.add(new Header("kit", "kat"));
-    headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-    HttpUriRequest apacheRequest = ApacheClient.createRequest(request);
-
-    assertThat(apacheRequest.getAllHeaders()).hasSize(2);
-    org.apache.http.Header kit = apacheRequest.getFirstHeader("kit");
-    assertThat(kit).isNotNull();
-    assertThat(kit.getValue()).isEqualTo("kat");
-    org.apache.http.Header foo = apacheRequest.getFirstHeader("foo");
-    assertThat(foo).isNotNull();
-    assertThat(foo.getValue()).isEqualTo("bar");
-  }
-
-  @Test public void response() throws IOException {
-    StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
-    HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.setEntity(new TypedOutputEntity(new TypedString("hello")));
-    apacheResponse.addHeader("Content-Type", "text/plain");
-    apacheResponse.addHeader("foo", "bar");
-    apacheResponse.addHeader("kit", "kat");
-    Response response = ApacheClient.parseResponse(HOST + "/foo/bar/", apacheResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    StatusLine statusLine = new BasicStatusLine(HttpVersion.HTTP_1_1, 200, "OK");
-    HttpResponse apacheResponse = new BasicHttpResponse(statusLine);
-    apacheResponse.addHeader("foo", "bar");
-    apacheResponse.addHeader("kit", "kat");
-    Response response = ApacheClient.parseResponse(HOST + "/foo/bar/", apacheResponse);
-
-    assertThat(response.getUrl()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-    assertThat(response.getBody()).isNull();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/ClientIntegrationTest.java b/retrofit/src/test/java/retrofit/client/ClientIntegrationTest.java
deleted file mode 100644
index 6739bc784..000000000
--- a/retrofit/src/test/java/retrofit/client/ClientIntegrationTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-//// Copyright 2014 Square, Inc.
-//package retrofit.client;
-//
-//import com.squareup.okhttp.mockwebserver.MockResponse;
-//import com.squareup.okhttp.mockwebserver.MockWebServer;
-//import com.squareup.okhttp.mockwebserver.RecordedRequest;
-//import java.io.IOException;
-//import java.util.Arrays;
-//import java.util.List;
-//import org.junit.After;
-//import org.junit.Before;
-//import org.junit.Test;
-//import org.junit.runner.RunWith;
-//import org.junit.runners.Parameterized;
-//import retrofit.RestAdapter;
-//import retrofit.http.Body;
-//import retrofit.http.GET;
-//import retrofit.http.POST;
-//
-//import static org.assertj.core.api.Assertions.assertThat;
-//
-//@RunWith(Parameterized.class)
-//public class ClientIntegrationTest {
-//  @Parameterized.Parameters
-//  public static List<Object[]> clients() {
-//    return Arrays.asList(new Object[][] {
-//        { new OkClient() },
-//        { new UrlConnectionClient() },
-//        { new ApacheClient() }
-//    });
-//  }
-//
-//  private final Client client;
-//
-//  private MockWebServer server;
-//  private Service service;
-//
-//  public ClientIntegrationTest(Client client) {
-//    this.client = client;
-//  }
-//
-//  @Before public void setUp() throws Exception {
-//    server = new MockWebServer();
-//    server.play();
-//
-//    RestAdapter restAdapter = new RestAdapter.Builder()
-//        .setEndpoint("http://" + server.getHostName() + ":" + server.getPort())
-//        .setClient(client)
-//        .build();
-//    service = restAdapter.create(Service.class);
-//  }
-//
-//  @After public void tearDown() throws IOException {
-//    server.shutdown();
-//  }
-//
-//  private interface Service {
-//    @GET("/get")
-//    Response get();
-//
-//    @POST("/post")
-//    Response post(@Body List<String> body);
-//  }
-//
-//  @Test public void get() throws InterruptedException {
-//    server.enqueue(new MockResponse().setBody("{}"));
-//    service.get();
-//
-//    RecordedRequest request = server.takeRequest();
-//    assertThat(request.getPath()).isEqualTo("/get");
-//    assertThat(request.getBody()).isEmpty();
-//  }
-//
-//  @Test public void post() throws InterruptedException {
-//    server.enqueue(new MockResponse().setBody("{}"));
-//    service.post(Arrays.asList("Hello", "World!"));
-//
-//    RecordedRequest request = server.takeRequest();
-//    assertThat(request.getPath()).isEqualTo("/post");
-//    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-//    assertThat(request.getHeader("Content-Length")).isEqualTo("18");
-//    assertThat(request.getUtf8Body()).isEqualTo("[\"Hello\",\"World!\"]");
-//  }
-//}
diff --git a/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java b/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java
deleted file mode 100644
index 926e4b042..000000000
--- a/retrofit/src/test/java/retrofit/client/DummyHttpUrlConnection.java
+++ /dev/null
@@ -1,115 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Provides POJO behavior for all of the APIs {@link retrofit.client.UrlConnectionClient}
- * interacts with.
- */
-public class DummyHttpUrlConnection extends HttpURLConnection {
-  private final Map<String, List<String>> responseHeaders =
-      new LinkedHashMap<String, List<String>>();
-  private final Map<String, List<String>> requestHeaders =
-      new LinkedHashMap<String, List<String>>();
-  private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-  private int responseCode;
-  private String responseMessage;
-  private InputStream inputStream;
-  private InputStream errorStream;
-
-  protected DummyHttpUrlConnection(String url) throws MalformedURLException {
-    super(new URL(url));
-  }
-
-  public void setResponseCode(int responseCode) {
-    this.responseCode = responseCode;
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return responseCode;
-  }
-
-  public void setResponseMessage(String responseMessage) {
-    this.responseMessage = responseMessage;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return responseMessage;
-  }
-
-  @Override public ByteArrayOutputStream getOutputStream() throws IOException {
-    return outputStream;
-  }
-
-  public void setInputStream(InputStream inputStream) {
-    this.inputStream = inputStream;
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return inputStream;
-  }
-
-  public void setErrorStream(InputStream errorStream) {
-    this.errorStream = errorStream;
-  }
-
-  @Override public InputStream getErrorStream() {
-    return errorStream;
-  }
-
-  public void addResponseHeader(String name, String value) {
-    List<String> values = responseHeaders.get(name);
-    if (values == null) {
-      values = new ArrayList<String>();
-      responseHeaders.put(name, values);
-    }
-    values.add(value);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return responseHeaders;
-  }
-
-  @Override public void addRequestProperty(String name, String value) {
-    List<String> values = requestHeaders.get(name);
-    if (values == null) {
-      values = new ArrayList<String>();
-      requestHeaders.put(name, values);
-    }
-    values.add(value);
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return requestHeaders;
-  }
-
-  @Override public String getRequestProperty(String name) {
-    List<String> values = requestHeaders.get(name);
-    if (values == null || values.isEmpty()) {
-      return null;
-    }
-    return values.get(0);
-  }
-
-  @Override public void disconnect() {
-    throw new AssertionError("Not implemented.");
-  }
-
-  @Override public boolean usingProxy() {
-    return false;
-  }
-
-  @Override public void connect() throws IOException {
-    throw new AssertionError("Not implemented.");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java b/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java
deleted file mode 100644
index 3539ef0a3..000000000
--- a/retrofit/src/test/java/retrofit/client/UrlConnectionClientTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.client;
-
-import com.google.common.io.ByteStreams;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.Test;
-import retrofit.TestingUtils;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit.TestingUtils.assertBytes;
-
-public class UrlConnectionClientTest {
-  private static final String HOST = "http://example.com";
-
-  private UrlConnectionClient client = new UrlConnectionClient() {
-    @Override protected HttpURLConnection openConnection(Request request) throws IOException {
-      return new DummyHttpUrlConnection(request.getUrl());
-    }
-  };
-
-  @Test public void get() throws Exception {
-    Request request = new Request("GET", HOST + "/foo/bar/?kit=kat", null, null);
-
-    HttpURLConnection connection = client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestMethod()).isEqualTo("GET");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/?kit=kat");
-    assertThat(connection.getHeaderFields()).isEmpty();
-  }
-
-  @Test public void post() throws Exception {
-    TypedString body = new TypedString("hi");
-    Request request = new Request("POST", HOST + "/foo/bar/", null, body);
-
-    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestMethod()).isEqualTo("POST");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/foo/bar/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("Content-Type")) //
-        .isEqualTo("text/plain; charset=UTF-8");
-    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo("2");
-    assertBytes(connection.getOutputStream().toByteArray(), "hi");
-  }
-
-  @Test public void multipart() throws Exception {
-    Map<String, TypedOutput> bodyParams = new LinkedHashMap<String, TypedOutput>();
-    bodyParams.put("foo", new TypedString("bar"));
-    bodyParams.put("ping", new TypedString("pong"));
-    TypedOutput body = TestingUtils.createMultipart(bodyParams);
-    Request request = new Request("POST", HOST + "/that/", null, body);
-
-    DummyHttpUrlConnection connection = (DummyHttpUrlConnection) client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    byte[] output = connection.getOutputStream().toByteArray();
-
-    assertThat(connection.getRequestMethod()).isEqualTo("POST");
-    assertThat(connection.getURL().toString()).isEqualTo(HOST + "/that/");
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("Content-Type")).startsWith("multipart/form-data;");
-    assertThat(connection.getRequestProperty("Content-Length")).isEqualTo(String.valueOf(output.length));
-    assertThat(output.length).isGreaterThan(0);
-  }
-
-  @Test public void headers() throws Exception {
-    List<Header> headers = new ArrayList<Header>();
-    headers.add(new Header("kit", "kat"));
-    headers.add(new Header("foo", "bar"));
-    Request request = new Request("GET", HOST + "/this/", headers, null);
-
-    HttpURLConnection connection = client.openConnection(request);
-    client.prepareRequest(connection, request);
-
-    assertThat(connection.getRequestProperties()).hasSize(2);
-    assertThat(connection.getRequestProperty("kit")).isEqualTo("kat");
-    assertThat(connection.getRequestProperty("foo")).isEqualTo("bar");
-  }
-
-  @Test public void response() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(200);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getUrl()).isEqualTo(HOST);
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void createdResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(201);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    connection.setInputStream(new ByteArrayInputStream("hello".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getUrl()).isEqualTo(HOST);
-    assertThat(response.getStatus()).isEqualTo(201);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(3) //
-        .containsOnly(new Header("foo", "bar"), new Header("kit", "kat"),
-            new Header("Content-Type", "text/plain"));
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "hello");
-  }
-
-  @Test public void errorResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(401);
-    connection.setResponseMessage("Not Authorized");
-    connection.addResponseHeader("Content-Type", "text/plain");
-    connection.setInputStream(new ByteArrayInputStream("input".getBytes("UTF-8")));
-    connection.setErrorStream(new ByteArrayInputStream("error".getBytes("UTF-8")));
-    Response response = client.readResponse(connection);
-
-    assertBytes(ByteStreams.toByteArray(response.getBody().in()), "error");
-  }
-
-  @Test public void emptyResponse() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(200);
-    connection.setResponseMessage("OK");
-    connection.addResponseHeader("foo", "bar");
-    connection.addResponseHeader("kit", "kat");
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getUrl()).isEqualTo(HOST);
-    assertThat(response.getStatus()).isEqualTo(200);
-    assertThat(response.getReason()).isEqualTo("OK");
-    assertThat(response.getHeaders()).hasSize(2) //
-        .containsExactly(new Header("foo", "bar"), new Header("kit", "kat"));
-  }
-
-  @Test public void noReasonMessage() throws Exception {
-    DummyHttpUrlConnection connection = new DummyHttpUrlConnection(HOST);
-    connection.setResponseCode(504);
-    connection.setResponseMessage(null);
-    Response response = client.readResponse(connection);
-
-    assertThat(response.getUrl()).isEqualTo(HOST);
-    assertThat(response.getStatus()).isEqualTo(504);
-    assertThat(response.getReason()).isEmpty();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
new file mode 100644
index 000000000..98c10c93b
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
@@ -0,0 +1,78 @@
+// Copyright 2015 Square, Inc.
+package retrofit.converter;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.reflect.Type;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+
+public final class GsonConverterTest {
+  private Converter converter;
+
+  interface Example {
+    String getName();
+  }
+
+  class Impl implements Example {
+    private final String theName;
+
+    Impl(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  @Before public void setUp() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(Example.class, new JsonSerializer<Example>() {
+          @Override public JsonElement serialize(Example example, Type type,
+              JsonSerializationContext json) {
+            JsonObject object = new JsonObject();
+            object.addProperty("name", example.getName());
+            return object;
+          }
+        })
+        .create();
+    converter = new GsonConverter(gson);
+  }
+
+  @Test public void serialization() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
+  }
+
+  @Test public void serializationTypeUsed() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
+  }
+
+  @Test public void deserialization() throws IOException {
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
+    assertEquals("value", impl.getName());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
deleted file mode 100644
index 0e3f79df4..000000000
--- a/retrofit/src/test/java/retrofit/mime/FormUrlEncodingTypedOutputTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class FormUrlEncodingTypedOutputTest {
-  @Test public void urlEncoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("a&b", "c=d");
-    fe.addField("space, the", "final frontier");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("a%26b=c%3Dd&space%2C+the=final+frontier");
-  }
-
-  @Test public void utf8encoding() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("oo", "q");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    fe.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo("oo%C9%9F=%C9%B9%C9%90q");
-  }
-
-  @Test public void encodedPairs() throws Exception {
-    FormUrlEncodedTypedOutput fe = new FormUrlEncodedTypedOutput();
-    fe.addField("sim", "ple");
-
-    ByteArrayOutputStream out1 = new ByteArrayOutputStream();
-    fe.writeTo(out1);
-    String actual1 = new String(out1.toByteArray(), "UTF-8");
-    assertThat(actual1).isEqualTo("sim=ple");
-
-    fe.addField("hey", "there");
-    fe.addField("help", "me");
-
-    ByteArrayOutputStream out2 = new ByteArrayOutputStream();
-    fe.writeTo(out2);
-    String actual2 = new String(out2.toByteArray(), "UTF-8");
-    assertThat(actual2).isEqualTo("sim=ple&hey=there&help=me");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MimeHelper.java b/retrofit/src/test/java/retrofit/mime/MimeHelper.java
deleted file mode 100644
index f7d438a8f..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeHelper.java
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.util.List;
-
-public class MimeHelper {
-  public static List<byte[]> getParts(MultipartTypedOutput output) {
-    try {
-      return output.getParts();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java b/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
deleted file mode 100644
index eb0765fef..000000000
--- a/retrofit/src/test/java/retrofit/mime/MimeUtilTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2012 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static retrofit.mime.MimeUtil.parseCharset;
-
-public class MimeUtilTest {
-  @Test public void charsetParsing() {
-    assertThat(parseCharset("text/plain;charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;  charset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; \r\n\tcharset=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; CHARSET=utf-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=UTF-8")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"\\u\\tf-\\8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; charset=\"utf-8\"")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain;charset=utf-8;other=thing")).isEqualToIgnoringCase("UTF-8");
-    assertThat(parseCharset("text/plain; notthecharset=utf-16;")).isEqualToIgnoringCase("UTF-8");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java b/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
deleted file mode 100644
index 0fad627da..000000000
--- a/retrofit/src/test/java/retrofit/mime/MultipartTypedOutputTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.mime;
-
-import java.io.ByteArrayOutputStream;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class MultipartTypedOutputTest {
-  @Test public void singlePart() throws Exception {
-    String expected = "" //
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"greet\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 13\r\n"
-        + "Content-Transfer-Encoding: binary\r\n" //
-        + "\r\n" //
-        + "Hello, World!\r\n" //
-        + "--123--";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("greet", new TypedString("Hello, World!"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void threeParts() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"quick\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "brown\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"fox\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 5\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "jumps\r\n"
-        + "--123\r\n"
-        + "Content-Disposition: form-data; name=\"lazy\"\r\n"
-        + "Content-Type: text/plain; charset=UTF-8\r\n"
-        + "Content-Length: 3\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "\r\n"
-        + "dog\r\n"
-        + "--123--";
-
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-    mto.addPart("quick", new TypedString("brown"));
-    mto.addPart("fox", new TypedString("jumps"));
-    mto.addPart("lazy", new TypedString("dog"));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    mto.writeTo(out);
-    String actual = new String(out.toByteArray(), "UTF-8");
-    assertThat(actual).isEqualTo(expected);
-    assertThat(mto.mimeType()).isEqualTo("multipart/form-data; boundary=123");
-  }
-
-  @Test public void withPartOfUnknownLength() throws Exception {
-    MultipartTypedOutput mto = new MultipartTypedOutput("123");
-
-    mto.addPart("first", new TypedString("value"));
-    mto.addPart("second", new TypedString("unknown size") {
-      @Override public long length() {
-        return -1;
-      }
-    });
-
-    assertThat(mto.length()).isEqualTo(-1);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java b/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
deleted file mode 100644
index b076a0328..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedByteArrayTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class TypedByteArrayTest {
-  private static final String GIF = "image/gif";
-
-  @Test public void objectEquals() {
-    TypedByteArray a1 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray a2 = new TypedByteArray(GIF, new byte[] { 10, 20 });
-    TypedByteArray b = new TypedByteArray(GIF, new byte[] { 8, 12 });
-
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java b/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
deleted file mode 100644
index 4d1cc69c2..000000000
--- a/retrofit/src/test/java/retrofit/mime/TypedFileTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright 2010 Square, Inc.
-package retrofit.mime;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class TypedFileTest {
-  private static final String PNG = "image/png";
-
-  @Test public void objectEquals() {
-    TypedFile a1 = new TypedFile(PNG, new File("a.png"));
-    TypedFile a2 = new TypedFile(PNG, new File("a.png"));
-    TypedFile b = new TypedFile(PNG, new File("b.png"));
-
-    assertThat(a1).isNotEqualTo(b);
-    assertThat(a1.hashCode()).isNotEqualTo(b.hashCode());
-    assertThat(a1).isEqualTo(a2);
-    assertThat(a1.hashCode()).isEqualTo(a2.hashCode());
-  }
-
-  @Test public void objectToString() {
-    File file = new File("/path/to/file.png");
-
-    assertThat(new TypedFile(PNG, file).toString()) //
-        .isEqualTo(file.getAbsolutePath() + " (image/png)");
-  }
-
-  @Test public void length() throws IOException {
-    File tempFile = File.createTempFile("foo", ".tmp");
-    try {
-      TypedFile typedFile = new TypedFile(PNG, tempFile);
-      assertThat(typedFile.length()).isZero();
-
-      writeToFile(tempFile, new byte[] { 0, 1, 2, 3, 4 });
-
-      assertThat(tempFile.length()).isEqualTo(5);
-      assertThat(typedFile.length()).isEqualTo(5);
-    } finally {
-      tempFile.delete();
-    }
-  }
-
-  private static void writeToFile(File file, byte[] data) throws IOException {
-    FileOutputStream fos = new FileOutputStream(file);
-    try {
-      fos.write(data);
-    } finally {
-      fos.close();
-    }
-  }
-}
diff --git a/retrofit-samples/github-client/pom.xml b/samples/github-client/pom.xml
similarity index 95%
rename from retrofit-samples/github-client/pom.xml
rename to samples/github-client/pom.xml
index 4b0ecacca..123f2ddd9 100644
--- a/retrofit-samples/github-client/pom.xml
+++ b/samples/github-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit.samples</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
similarity index 100%
rename from retrofit-samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
diff --git a/retrofit-samples/mock-github-client/pom.xml b/samples/mock-github-client/pom.xml
similarity index 96%
rename from retrofit-samples/mock-github-client/pom.xml
rename to samples/mock-github-client/pom.xml
index 4554db5ca..11327d99b 100644
--- a/retrofit-samples/mock-github-client/pom.xml
+++ b/samples/mock-github-client/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit.samples</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
similarity index 96%
rename from retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
index 9d2df6c5c..27563c9a7 100644
--- a/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
@@ -6,6 +6,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executors;
 import retrofit.MockRestAdapter;
 import retrofit.RestAdapter;
 import retrofit.http.GET;
@@ -78,7 +79,8 @@ public static void main(String... args) {
         .build();
 
     // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+    MockRestAdapter mockRestAdapter =
+        MockRestAdapter.from(restAdapter, Executors.newSingleThreadExecutor());
 
     // Instantiate a mock object so we can interact with it later.
     MockGitHub mockGitHub = new MockGitHub();
diff --git a/retrofit-samples/pom.xml b/samples/pom.xml
similarity index 94%
rename from retrofit-samples/pom.xml
rename to samples/pom.xml
index a79813583..272a39608 100644
--- a/retrofit-samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
-    <version>1.6.1-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/website/index.html b/website/index.html
index b24b1a170..cfd04f78b 100644
--- a/website/index.html
+++ b/website/index.html
@@ -114,7 +114,7 @@ <h4>Header Manipulation</h4>
 @GET("/users/{username}")
 User getUser(@Path("username") String username);</pre>
             <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding String parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted.</p>
+            <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
             <pre class="prettyprint">@GET("/user")
 void getUser(@Header("Authorization") String authorization, Callback&lt;User> callback)</pre>
             <p>Headers that need to be added to every request can be specified using a <code>RequestInterceptor</code>. The following code creates a <code>RequestInterceptor</code> that will add a <code>User-Agent</code> header to every request.</p>
@@ -140,7 +140,7 @@ <h4>Synchronous vs. Asynchronous vs. Observable</h4>
 void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
             <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
 
-            <p>Retrofit also integrates <a href="https://github.com/Netflix/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
+            <p>Retrofit also integrates <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
             <pre class="prettyprint">@GET("/user/{id}/photo")
 Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
             <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
@@ -226,7 +226,7 @@ <h4>Logging</h4>
             <p>This logging can be added or changed at any point in the <code>RestAdapter</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
 
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
             <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -234,7 +234,31 @@ <h4>Maven</h4>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
+            <h4>Gradle</h4>
+            <pre class="prettyprint">
+compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
+</pre>
+            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
 
+            <h4>Integration with OkHttp</h4>
+            <p>When using Retrofit together with OkHttp, OkHttp (version 1.6.0 or newer) and OkHttp-UrlConnection are now required.</p>
+            <h4>Maven</h4>
+            <pre class="prettyprint">&lt;dependency>
+  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;artifactId>okhttp&lt;/artifactId>
+  &lt;version>2.0.0&lt;/version>
+&lt;/dependency>
+&lt;dependency>
+  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;artifactId>okhttp-urlconnection&lt;/artifactId>
+  &lt;version>2.0.0&lt;/version>
+&lt;/dependency>
+</pre>
+            <h4>Gradle</h4>
+<pre class="prettyprint">
+compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.0'
+compile 'com.squareup.okhttp:okhttp:2.0.0'
+</pre>
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
