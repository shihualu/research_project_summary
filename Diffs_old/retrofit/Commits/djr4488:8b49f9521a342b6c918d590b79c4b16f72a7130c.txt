diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index 64dd0f5ad..046bf3450 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -21,6 +21,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -56,8 +57,8 @@ public static GuavaCallAdapterFactory create() {
   private GuavaCallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != ListenableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
index 7943d1191..1866bbf30 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.guava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 31f98f7fd..4ed30ae2f 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -4,6 +4,10 @@ Java8 Adapter
 An `Adapter` for adapting [Java8][1] `CompletableFuture`.
 
 
+Deprecated – Included by default in Retrofit
+---------------------------------------
+
+
 Usage
 -----
 
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index 35b79f1a3..8b1695eb8 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -27,6 +28,9 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for CompletableFuture. This no longer needs to be added to
+ * the Retrofit instance explicitly.
+ * <p>
  * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
  * <p>
  * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
@@ -47,6 +51,7 @@
  * errors</li>
  * </ul>
  */
+@Deprecated
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
   public static Java8CallAdapterFactory create() {
     return new Java8CallAdapterFactory();
@@ -55,8 +60,8 @@ public static Java8CallAdapterFactory create() {
   private Java8CallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != CompletableFuture.class) {
       return null;
     }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
index 7e36b199e..a45aba2ed 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.java8;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 51804b76f..abec3e745 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -92,8 +92,8 @@ private RxJavaCallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync)
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
     boolean isSingle = rawType == Single.class;
     boolean isCompletable = rawType == Completable.class;
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
index 255728495..e3d8acb68 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.rxjava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index 3d84b39f2..27603602a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -71,4 +71,19 @@
     service.completable().unsafeSubscribe(subscriber);
     subscriber.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 500c3c539..07b56dc36 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -191,4 +191,19 @@ public void call(Response<String> response) {
     subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index babd05c73..dae833a40 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -171,4 +171,19 @@
 
     subscriber.assertError(e);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSubscriber<String> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertCompleted();
+
+    RecordingSubscriber<String> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertCompleted();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 8af54c505..0870af1f1 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -90,8 +90,8 @@ private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync
     this.isAsync = isAsync;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     Class<?> rawType = getRawType(returnType);
 
     if (rawType == Completable.class) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
index c5fc01992..e778f0fb9 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.adapter.rxjava2;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
index 999cf31bd..4f00f7112 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -70,4 +70,19 @@
     service.completable().subscribe(observer);
     observer.assertError(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Completable observable = service.completable();
+
+    RecordingCompletableObserver observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertComplete();
+
+    RecordingCompletableObserver observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
index 22efcee2b..6347fa674 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -184,4 +184,19 @@
     subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
     assertThat(server.getRequestCount()).isEqualTo(1);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Flowable<String> observable = service.body();
+
+    RecordingSubscriber<Object> subscriber1 = subscriberRule.create();
+    observable.subscribe(subscriber1);
+    subscriber1.assertValue("Hi").assertComplete();
+
+    RecordingSubscriber<Object> subscriber2 = subscriberRule.create();
+    observable.subscribe(subscriber2);
+    subscriber2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
index 21f69c68a..73295bf02 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -16,6 +16,7 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Maybe;
+import java.io.IOException;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
@@ -25,8 +26,6 @@
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
-import java.io.IOException;
-
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -130,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Maybe<String> observable = service.body();
+
+    RecordingMaybeObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingMaybeObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index 23c20f77e..1afe1eaa3 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -149,4 +149,19 @@
       RxJavaPlugins.reset();
     }
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Observable<String> observable = service.body();
+
+    RecordingObserver<String> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi").assertComplete();
+
+    RecordingObserver<String> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey").assertComplete();
+  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
index dba2dd62a..2181e4eed 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -129,4 +129,19 @@
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
+
+  @Test public void subscribeTwice() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hey"));
+
+    Single<String> observable = service.body();
+
+    RecordingSingleObserver<Object> observer1 = observerRule.create();
+    observable.subscribe(observer1);
+    observer1.assertValue("Hi");
+
+    RecordingSingleObserver<Object> observer2 = observerRule.create();
+    observable.subscribe(observer2);
+    observer2.assertValue("Hey");
+  }
 }
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
index 432068f86..500f07808 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/BodyCallAdapter.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.scala;
 
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -36,11 +35,11 @@
     return responseType;
   }
 
-  @Override public Future<T> adapt(@Nonnull Call<T> call) {
+  @Override public Future<T> adapt(Call<T> call) {
     Promise<T> promise = Promise.apply();
 
     call.enqueue(new Callback<T>() {
-      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         if (response.isSuccessful()) {
           promise.success(response.body());
         } else {
@@ -48,7 +47,7 @@
         }
       }
 
-      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         promise.failure(t);
       }
     });
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
index 75d75f99d..e9462dd61 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ResponseCallAdapter.java
@@ -16,7 +16,6 @@
 package retrofit2.adapter.scala;
 
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -35,15 +34,15 @@
     return responseType;
   }
 
-  @Override public Future<Response<T>> adapt(@Nonnull Call<T> call) {
+  @Override public Future<Response<T>> adapt(Call<T> call) {
     Promise<Response<T>> promise = Promise.apply();
 
     call.enqueue(new Callback<T>() {
-      @Override public void onResponse(@Nonnull Call<T> call, @Nonnull Response<T> response) {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
         promise.success(response);
       }
 
-      @Override public void onFailure(@Nonnull Call<T> call, @Nonnull Throwable t) {
+      @Override public void onFailure(Call<T> call, Throwable t) {
         promise.failure(t);
       }
     });
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
index afe2e7fe7..7737b8b0b 100644
--- a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/ScalaCallAdapterFactory.java
@@ -19,7 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -54,9 +54,8 @@ public static ScalaCallAdapterFactory create() {
   private ScalaCallAdapterFactory() {
   }
 
-  @Override
-  public CallAdapter<?, ?> get(@Nonnull Type returnType, @Nonnull Annotation[] annotations,
-      @Nonnull Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Future.class) {
       return null;
     }
diff --git a/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
new file mode 100644
index 000000000..882801bd2
--- /dev/null
+++ b/retrofit-adapters/scala/src/main/java/retrofit2/adapter/scala/package-info.java
@@ -0,0 +1,2 @@
+@retrofit2.internal.EverythingIsNonNull
+package retrofit2.adapter.scala;
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
index b8ad27810..677188914 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.gson;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
index bfa033614..42b2c2745 100644
--- a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/GuavaOptionalConverterFactory.java
@@ -36,16 +36,15 @@ public static GuavaOptionalConverterFactory create() {
   private GuavaOptionalConverterFactory() {
   }
 
-  @Nullable @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(type) != Optional.class) {
       return null;
     }
 
     Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
     Converter<ResponseBody, Object> delegate =
-        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+        retrofit.responseBodyConverter(innerType, annotations);
     return new OptionalConverter<>(delegate);
   }
 }
diff --git a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
index bd25d1fe4..04152af9c 100644
--- a/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
+++ b/retrofit-converters/guava/src/main/java/retrofit/converter/guava/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit.converter.guava;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
index 27680150e..c5411112a 100644
--- a/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
+++ b/retrofit-converters/guava/src/test/java/retrofit/converter/guava/GuavaOptionalConverterFactoryTest.java
@@ -17,12 +17,17 @@
 
 import com.google.common.base.Optional;
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.Call;
+import retrofit2.Converter;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
@@ -61,4 +66,31 @@
     Object body = service.object().execute().body();
     assertThat(body).isNull();
   }
+
+  @Test public void delegates() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return new Converter<ResponseBody, Object>() {
+              @Override public Object convert(ResponseBody value) {
+                return null;
+              }
+            };
+          }
+        })
+        .addConverterFactory(GuavaOptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
index f747a1d6d..567bad26a 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.jackson;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/README.md b/retrofit-converters/java8/README.md
index 6aa640209..fe6743ca8 100644
--- a/retrofit-converters/java8/README.md
+++ b/retrofit-converters/java8/README.md
@@ -5,6 +5,10 @@ A `Converter` which supports Java 8's `Optional<T>` by delegating to other conve
 and then wrapping it into `Optional`.
 
 
+Deprecated – Included by default in Retrofit
+---------------------------------------
+
+
 Download
 --------
 
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
index 7b55ca965..512d73cb3 100644
--- a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/Java8OptionalConverterFactory.java
@@ -25,9 +25,13 @@
 import retrofit2.Retrofit;
 
 /**
+ * @deprecated Retrofit includes support for Optional. This no longer needs to be added to the
+ * Retrofit instance explicitly.
+ * <p>
  * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
  * converter to deserialize {@code T} and then wraps it into {@link Optional}.
  */
+@Deprecated
 public final class Java8OptionalConverterFactory extends Converter.Factory {
   public static Java8OptionalConverterFactory create() {
     return new Java8OptionalConverterFactory();
@@ -36,16 +40,15 @@ public static Java8OptionalConverterFactory create() {
   private Java8OptionalConverterFactory() {
   }
 
-  @Nullable @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(type) != Optional.class) {
       return null;
     }
 
     Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
     Converter<ResponseBody, Object> delegate =
-        retrofit.nextResponseBodyConverter(this, innerType, annotations);
+        retrofit.responseBodyConverter(innerType, annotations);
     return new OptionalConverter<>(delegate);
   }
 }
diff --git a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
index e883be032..fdd62e2d4 100644
--- a/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
+++ b/retrofit-converters/java8/src/main/java/retrofit/converter/java8/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit.converter.java8;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
index 73027907b..3a08de980 100644
--- a/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
+++ b/retrofit-converters/java8/src/test/java/retrofit/converter/java8/Java8OptionalConverterFactoryTest.java
@@ -16,13 +16,18 @@
 package retrofit.converter.java8;
 
 import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
 import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import retrofit2.Call;
+import retrofit2.Converter;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
@@ -61,4 +66,31 @@
     Object body = service.object().execute().body();
     assertThat(body).isNull();
   }
+
+  @Test public void delegates() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {
+          @Nullable @Override public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+              Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(type) != Object.class) {
+              return null;
+            }
+            return new Converter<ResponseBody, Object>() {
+              @Override public Object convert(ResponseBody value) {
+                return null;
+              }
+            };
+          }
+        })
+        .addConverterFactory(Java8OptionalConverterFactory.create())
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Service service = retrofit.create(Service.class);
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
 }
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
index 8e140aff6..b1317f838 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/JaxbConverterFactory.java
@@ -53,7 +53,7 @@ private JaxbConverterFactory(@Nullable JAXBContext context) {
     this.context = context;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
       return new JaxbRequestConverter<>(contextForType((Class<?>) type), (Class<?>) type);
@@ -61,7 +61,7 @@ private JaxbConverterFactory(@Nullable JAXBContext context) {
     return null;
   }
 
-  @Override public Converter<ResponseBody, ?> responseBodyConverter(
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
       Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type instanceof Class && ((Class<?>) type).isAnnotationPresent(XmlRootElement.class)) {
       return new JaxbResponseConverter<>(contextForType((Class<?>) type), (Class<?>) type);
diff --git a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
index 7aebe7e7b..c14c5d1ff 100644
--- a/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
+++ b/retrofit-converters/jaxb/src/main/java/retrofit2/converter/jaxb/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.jaxb;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
index 2d5a38a51..38bee8e2f 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.moshi;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index 6fb529429..d41ebd2f8 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -51,9 +51,8 @@ private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     this.registry = registry;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -84,8 +83,7 @@ private ProtoConverterFactory(@Nullable ExtensionRegistryLite registry) {
     return new ProtoResponseBodyConverter<>(parser, registry);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
index c976ca568..84ed323c0 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.protobuf;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 5a585b21f..6f4cdf28e 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -119,7 +119,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -138,7 +139,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+          + "   * retrofit2.converter.protobuf.ProtoConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 5bf838fe9..73189634d 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -43,7 +44,7 @@ public static ScalarsConverterFactory create() {
   private ScalarsConverterFactory() {
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (type == String.class
         || type == boolean.class
@@ -67,9 +68,8 @@ private ScalarsConverterFactory() {
     return null;
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == String.class) {
       return StringResponseBodyConverter.INSTANCE;
     }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
index 0ea2f7740..ffb138825 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.scalars;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index cc19d4fbc..6e39dd537 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -26,7 +26,6 @@
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
-import retrofit2.converter.scalars.ScalarsConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
 import retrofit2.http.POST;
@@ -93,7 +92,8 @@
           + "Could not locate RequestBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -232,7 +232,8 @@
           + "Could not locate ResponseBody converter for class java.lang.Object.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+          + "   * retrofit2.converter.scalars.ScalarsConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index 793806d1d..a961721ca 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import org.simpleframework.xml.Serializer;
@@ -78,8 +79,7 @@ public boolean isStrict() {
     return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class)) {
       return null;
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
index 69507b872..b12e7e178 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.simplexml;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index fbaaeac4a..b97ce1011 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -19,6 +19,7 @@
 import com.squareup.wire.ProtoAdapter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -37,9 +38,8 @@ public static WireConverterFactory create() {
   private WireConverterFactory() {
   }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
     }
@@ -52,8 +52,7 @@ private WireConverterFactory() {
     return new WireResponseBodyConverter<>(adapter);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (!(type instanceof Class<?>)) {
       return null;
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
index 483b65c81..fb1bd79c6 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.converter.wire;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index e972d5287..486de11f5 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -94,7 +94,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -113,7 +114,8 @@
           + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+          + "   * retrofit2.converter.wire.WireConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index f0e9affbe..74a78e863 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -132,7 +132,9 @@ private Calls() {
       if (response != null) {
         return response.raw().request();
       }
-      return new Request.Builder().url("http://localhost").build();
+      return new Request.Builder()
+          .url("http://localhost")
+          .build();
     }
   }
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
index cb99df00c..f2e13328e 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/package-info.java
@@ -1,4 +1,2 @@
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2.mock;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
index bf67cad9a..8b044175a 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -15,7 +15,6 @@
  */
 package retrofit2.mock;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.concurrent.Callable;
@@ -24,7 +23,6 @@
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
-import retrofit2.Retrofit;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index d103d715f..d5ee8e5a4 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -75,6 +75,26 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>process-sources</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
@@ -86,6 +106,14 @@
           </archive>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>retrofit2.internal</excludePackageNames>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index f5e636214..df0f1073d 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import kotlin.Unit;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -27,9 +28,8 @@
   /** Not volatile because we don't mind multiple threads discovering this. */
   private boolean checkForKotlinUnit = true;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (type == ResponseBody.class) {
       return Utils.isAnnotationPresent(annotations, Streaming.class)
           ? StreamingResponseBodyConverter.INSTANCE
@@ -50,8 +50,7 @@
     return null;
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
       return RequestBodyConverter.INSTANCE;
diff --git a/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
new file mode 100644
index 000000000..f0d82849b
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/CompletableFutureCallAdapterFactory.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.CompletableFuture;
+import javax.annotation.Nullable;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+/**
+ * A {@linkplain CallAdapter.Factory call adapter} which creates Java 8 futures.
+ * <p>
+ * Adding this class to {@link Retrofit} allows you to return {@link CompletableFuture} from
+ * service methods.
+ * <pre><code>
+ * interface MyService {
+ *   &#64;GET("user/me")
+ *   CompletableFuture&lt;User&gt; getUser()
+ * }
+ * </code></pre>
+ * There are two configurations supported for the {@code CompletableFuture} type parameter:
+ * <ul>
+ * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
+ * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
+ * {@link Response} object for all HTTP responses and sets {@link IOException} for network
+ * errors</li>
+ * </ul>
+ */
+@IgnoreJRERequirement
+final class CompletableFutureCallAdapterFactory extends CallAdapter.Factory {
+  static final CallAdapter.Factory INSTANCE = new CompletableFutureCallAdapterFactory();
+
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(returnType) != CompletableFuture.class) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalStateException("CompletableFuture return type must be parameterized"
+          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
+
+    if (getRawType(innerType) != Response.class) {
+      // Generic type is not Response<T>. Use it for body-only adapter.
+      return new BodyCallAdapter<>(innerType);
+    }
+
+    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+    if (!(innerType instanceof ParameterizedType)) {
+      throw new IllegalStateException("Response must be parameterized"
+          + " as Response<Foo> or Response<? extends Foo>");
+    }
+    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+    return new ResponseCallAdapter<>(responseType);
+  }
+
+  @IgnoreJRERequirement
+  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+    private final Type responseType;
+
+    BodyCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<R> adapt(final Call<R> call) {
+      final CompletableFuture<R> future = new CompletableFuture<R>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          if (response.isSuccessful()) {
+            future.complete(response.body());
+          } else {
+            future.completeExceptionally(new HttpException(response));
+          }
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+
+  @IgnoreJRERequirement
+  private static final class ResponseCallAdapter<R>
+      implements CallAdapter<R, CompletableFuture<Response<R>>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+        @Override public boolean cancel(boolean mayInterruptIfRunning) {
+          if (mayInterruptIfRunning) {
+            call.cancel();
+          }
+          return super.cancel(mayInterruptIfRunning);
+        }
+      };
+
+      call.enqueue(new Callback<R>() {
+        @Override public void onResponse(Call<R> call, Response<R> response) {
+          future.complete(response);
+        }
+
+        @Override public void onFailure(Call<R> call, Throwable t) {
+          future.completeExceptionally(t);
+        }
+      });
+
+      return future;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..a5ea033b0 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 
 /**
  * Creates call adapters for that uses the same thread for both I/O and application-level
@@ -26,8 +27,8 @@
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
   static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index f819c7863..dedfb0e74 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import okhttp3.Request;
 
 import static retrofit2.Utils.checkNotNull;
@@ -30,8 +31,8 @@
     this.callbackExecutor = callbackExecutor;
   }
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     if (getRawType(returnType) != Call.class) {
       return null;
     }
diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index bece5ef92..d149df56a 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -18,7 +18,6 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 import okhttp3.ResponseBody;
 
 import static retrofit2.Utils.methodError;
@@ -86,7 +85,7 @@ private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory ca
     this.responseConverter = responseConverter;
   }
 
-  @Override ReturnT invoke(@Nullable Object[] args) {
+  @Override ReturnT invoke(Object[] args) {
     return callAdapter.adapt(
         new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
   }
diff --git a/retrofit/src/main/java/retrofit2/Invocation.java b/retrofit/src/main/java/retrofit2/Invocation.java
new file mode 100644
index 000000000..6f1ca5fb4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/Invocation.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static retrofit2.Utils.checkNotNull;
+
+/**
+ * A single invocation of a Retrofit service interface method. This class captures both the method
+ * that was called and the arguments to the method.
+ *
+ * <p>Retrofit automatically adds an invocation to each OkHttp request as a tag. You can retrieve
+ * the invocation in an OkHttp interceptor for metrics and monitoring.
+ *
+ * <pre><code>
+ * class InvocationLogger implements Interceptor {
+ *   &#64;Override public Response intercept(Chain chain) throws IOException {
+ *     Request request = chain.request();
+ *     Invocation invocation = request.tag(Invocation.class);
+ *     if (invocation != null) {
+ *       System.out.printf("%s.%s %s%n",
+ *           invocation.method().getDeclaringClass().getSimpleName(),
+ *           invocation.method().getName(), invocation.arguments());
+ *     }
+ *     return chain.proceed(request);
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <strong>Note:</strong> use caution when examining an invocation's arguments. Although the
+ * arguments list is unmodifiable, the arguments themselves may be mutable. They may also be unsafe
+ * for concurrent access. For best results declare Retrofit service interfaces using only immutable
+ * types for parameters!
+ */
+public final class Invocation {
+  public static Invocation of(Method method, List<?> arguments) {
+    checkNotNull(method, "method == null");
+    checkNotNull(arguments, "arguments == null");
+    return new Invocation(method, new ArrayList<>(arguments)); // Defensive copy.
+  }
+
+  private final Method method;
+  private final List<?> arguments;
+
+  /** Trusted constructor assumes ownership of {@code arguments}. */
+  Invocation(Method method, List<?> arguments) {
+    this.method = method;
+    this.arguments = Collections.unmodifiableList(arguments);
+  }
+
+  public Method method() {
+    return method;
+  }
+
+  public List<?> arguments() {
+    return arguments;
+  }
+
+  @Override public String toString() {
+    return String.format("%s.%s() %s",
+        method.getDeclaringClass().getName(), method.getName(), arguments);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
new file mode 100644
index 000000000..8b599cfb3
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Hide the class from Java consumers.
+@file:JvmName("-KotlinExtensions")
+
+package retrofit2
+
+inline fun <reified T> Retrofit.create(): T = create(T::class.java)
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index 3a4d0562d..050def5da 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -31,7 +31,7 @@
 
 final class OkHttpCall<T> implements Call<T> {
   private final RequestFactory requestFactory;
-  private final @Nullable Object[] args;
+  private final Object[] args;
   private final okhttp3.Call.Factory callFactory;
   private final Converter<ResponseBody, T> responseConverter;
 
@@ -44,7 +44,7 @@
   @GuardedBy("this")
   private boolean executed;
 
-  OkHttpCall(RequestFactory requestFactory, @Nullable Object[] args,
+  OkHttpCall(RequestFactory requestFactory, Object[] args,
       okhttp3.Call.Factory callFactory, Converter<ResponseBody, T> responseConverter) {
     this.requestFactory = requestFactory;
     this.args = args;
diff --git a/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
new file mode 100644
index 000000000..7174e3ad8
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/OptionalConverterFactory.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+/**
+ * A {@linkplain Converter.Factory converter} for {@code Optional<T>} which delegates to another
+ * converter to deserialize {@code T} and then wraps it into {@link Optional}.
+ */
+@IgnoreJRERequirement
+final class OptionalConverterFactory extends Converter.Factory {
+  static final Converter.Factory INSTANCE = new OptionalConverterFactory();
+
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
+    if (getRawType(type) != Optional.class) {
+      return null;
+    }
+
+    Type innerType = getParameterUpperBound(0, (ParameterizedType) type);
+    Converter<ResponseBody, Object> delegate =
+        retrofit.responseBodyConverter(innerType, annotations);
+    return new OptionalConverter<>(delegate);
+  }
+
+  @IgnoreJRERequirement
+  static final class OptionalConverter<T> implements Converter<ResponseBody, Optional<T>> {
+    final Converter<ResponseBody, T> delegate;
+
+    OptionalConverter(Converter<ResponseBody, T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public Optional<T> convert(ResponseBody value) throws IOException {
+      return Optional.ofNullable(delegate.convert(value));
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index 092c95f8f..270a8040a 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -21,10 +21,16 @@
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
+import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
+
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
@@ -52,11 +58,24 @@ private static Platform findPlatform() {
     return null;
   }
 
-  CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+  List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+      @Nullable Executor callbackExecutor) {
     if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+      return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
     }
-    return DefaultCallAdapterFactory.INSTANCE;
+    return singletonList(DefaultCallAdapterFactory.INSTANCE);
+  }
+
+  int defaultCallAdapterFactoriesSize() {
+    return 1;
+  }
+
+  List<? extends Converter.Factory> defaultConverterFactories() {
+    return emptyList();
+  }
+
+  int defaultConverterFactoriesSize() {
+    return 0;
   }
 
   boolean isDefaultMethod(Method method) {
@@ -85,6 +104,30 @@ boolean isDefaultMethod(Method method) {
           .bindTo(object)
           .invokeWithArguments(args);
     }
+
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
+      List<CallAdapter.Factory> factories = new ArrayList<>(2);
+      factories.add(CompletableFutureCallAdapterFactory.INSTANCE);
+      if (callbackExecutor != null) {
+        factories.add(new ExecutorCallAdapterFactory(callbackExecutor));
+      } else {
+        factories.add(DefaultCallAdapterFactory.INSTANCE);
+      }
+      return unmodifiableList(factories);
+    }
+
+    @Override int defaultCallAdapterFactoriesSize() {
+      return 2;
+    }
+
+    @Override List<? extends Converter.Factory> defaultConverterFactories() {
+      return singletonList(OptionalConverterFactory.INSTANCE);
+    }
+
+    @Override int defaultConverterFactoriesSize() {
+      return 1;
+    }
   }
 
   static class Android extends Platform {
@@ -100,9 +143,10 @@ boolean isDefaultMethod(Method method) {
       return new MainThreadExecutor();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
+    @Override List<? extends CallAdapter.Factory> defaultCallAdapterFactories(
+        @Nullable Executor callbackExecutor) {
       if (callbackExecutor == null) throw new AssertionError();
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+      return singletonList(new ExecutorCallAdapterFactory(callbackExecutor));
     }
 
     static class MainThreadExecutor implements Executor {
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 436240cc4..98dd66690 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -46,9 +46,9 @@
   private @Nullable FormBody.Builder formBuilder;
   private @Nullable RequestBody body;
 
-  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,
-      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,
-      boolean isFormEncoded, boolean isMultipart) {
+  RequestBuilder(String method, HttpUrl baseUrl,
+      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,
+      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
     this.method = method;
     this.baseUrl = baseUrl;
     this.relativeUrl = relativeUrl;
@@ -186,7 +186,7 @@ void setBody(RequestBody body) {
     this.body = body;
   }
 
-  Request build() {
+  Request.Builder get() {
     HttpUrl url;
     HttpUrl.Builder urlBuilder = this.urlBuilder;
     if (urlBuilder != null) {
@@ -225,8 +225,7 @@ Request build() {
 
     return requestBuilder
         .url(url)
-        .method(method, body)
-        .build();
+        .method(method, body);
   }
 
   private static class ContentTypeOverridingRequestBody extends RequestBody {
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index ee7cdba41..ee1ab0265 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -21,7 +21,9 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URI;
+import java.util.ArrayList;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -63,6 +65,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     return new Builder(retrofit, method).build();
   }
 
+  private final Method method;
   private final HttpUrl baseUrl;
   final String httpMethod;
   private final String relativeUrl;
@@ -74,6 +77,7 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
   private final ParameterHandler<?>[] parameterHandlers;
 
   RequestFactory(Builder builder) {
+    method = builder.method;
     baseUrl = builder.retrofit.baseUrl;
     httpMethod = builder.httpMethod;
     relativeUrl = builder.relativeUrl;
@@ -85,24 +89,28 @@ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
     parameterHandlers = builder.parameterHandlers;
   }
 
-  okhttp3.Request create(@Nullable Object[] args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
+  okhttp3.Request create(Object[] args) throws IOException {
     @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
     ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    int argumentCount = args != null ? args.length : 0;
+    int argumentCount = args.length;
     if (argumentCount != handlers.length) {
       throw new IllegalArgumentException("Argument count (" + argumentCount
           + ") doesn't match expected count (" + handlers.length + ")");
     }
 
+    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
+        headers, contentType, hasBody, isFormEncoded, isMultipart);
+
+    List<Object> argumentList = new ArrayList<>(argumentCount);
     for (int p = 0; p < argumentCount; p++) {
+      argumentList.add(args[p]);
       handlers[p].apply(requestBuilder, args[p]);
     }
 
-    return requestBuilder.build();
+    return requestBuilder.get()
+        .tag(Invocation.class, new Invocation(method, argumentList))
+        .build();
   }
 
   /**
@@ -171,18 +179,7 @@ RequestFactory build() {
       int parameterCount = parameterAnnotationsArray.length;
       parameterHandlers = new ParameterHandler<?>[parameterCount];
       for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(method, p,
-              "Parameter type must not include a type variable or wildcard: %s", parameterType);
-        }
-
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(method, p, "No Retrofit annotation found.");
-        }
-
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+        parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]);
       }
 
       if (relativeUrl == null && !gotUrl) {
@@ -290,21 +287,24 @@ private Headers parseHeaders(String[] headers) {
     }
 
     private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
+        int p, Type parameterType, @Nullable Annotation[] annotations) {
       ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+      if (annotations != null) {
+        for (Annotation annotation : annotations) {
+          ParameterHandler<?> annotationAction =
+              parseParameterAnnotation(p, parameterType, annotations, annotation);
 
-        if (annotationAction == null) {
-          continue;
-        }
+          if (annotationAction == null) {
+            continue;
+          }
 
-        if (result != null) {
-          throw parameterError(method, p, "Multiple Retrofit annotations found, only one allowed.");
-        }
+          if (result != null) {
+            throw parameterError(method, p,
+                "Multiple Retrofit annotations found, only one allowed.");
+          }
 
-        result = annotationAction;
+          result = annotationAction;
+        }
       }
 
       if (result == null) {
@@ -317,6 +317,7 @@ private Headers parseHeaders(String[] headers) {
     private ParameterHandler<?> parseParameterAnnotation(
         int p, Type type, Annotation[] annotations, Annotation annotation) {
       if (annotation instanceof Url) {
+        validateResolvableType(p, type);
         if (gotUrl) {
           throw parameterError(method, p, "Multiple @Url method annotations found.");
         }
@@ -349,6 +350,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof Path) {
+        validateResolvableType(p, type);
         if (gotQuery) {
           throw parameterError(method, p, "A @Path parameter must not come after a @Query.");
         }
@@ -375,6 +377,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
+        validateResolvableType(p, type);
         Query query = (Query) annotation;
         String name = query.value();
         boolean encoded = query.encoded();
@@ -405,6 +408,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryName) {
+        validateResolvableType(p, type);
         QueryName query = (QueryName) annotation;
         boolean encoded = query.encoded();
 
@@ -434,6 +438,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof QueryMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         gotQueryMap = true;
         if (!Map.class.isAssignableFrom(rawParameterType)) {
@@ -456,6 +461,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
+        validateResolvableType(p, type);
         Header header = (Header) annotation;
         String name = header.value();
 
@@ -484,6 +490,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof HeaderMap) {
+        validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
           throw parameterError(method, p, "@HeaderMap parameter type must be Map.");
@@ -505,6 +512,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p, "@Field parameters can only be used with form encoding.");
         }
@@ -539,6 +547,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof FieldMap) {
+        validateResolvableType(p, type);
         if (!isFormEncoded) {
           throw parameterError(method, p,
               "@FieldMap parameters can only be used with form encoding.");
@@ -565,6 +574,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@Part parameters can only be used with multipart encoding.");
@@ -646,6 +656,7 @@ private Headers parseHeaders(String[] headers) {
         }
 
       } else if (annotation instanceof PartMap) {
+        validateResolvableType(p, type);
         if (!isMultipart) {
           throw parameterError(method, p,
               "@PartMap parameters can only be used with multipart encoding.");
@@ -680,6 +691,7 @@ private Headers parseHeaders(String[] headers) {
         return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
+        validateResolvableType(p, type);
         if (isFormEncoded || isMultipart) {
           throw parameterError(method, p,
               "@Body parameters cannot be used with form or multi-part encoding.");
@@ -702,6 +714,13 @@ private Headers parseHeaders(String[] headers) {
       return null; // Not a Retrofit annotation.
     }
 
+    private void validateResolvableType(int p, Type type) {
+      if (Utils.hasUnresolvableType(type)) {
+        throw parameterError(method, p,
+            "Parameter type must not include a type variable or wildcard: %s", type);
+      }
+    }
+
     private void validatePathName(int p, String name) {
       if (!PARAM_NAME_REGEX.matcher(name).matches()) {
         throw parameterError(method, p, "@Path parameter name must match %s. Found: %s",
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 498d006eb..9373fe8e2 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -133,6 +133,7 @@
     return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
         new InvocationHandler() {
           private final Platform platform = Platform.get();
+          private final Object[] emptyArgs = new Object[0];
 
           @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
               throws Throwable {
@@ -143,7 +144,7 @@
             if (platform.isDefaultMethod(method)) {
               return platform.invokeDefaultMethod(method, service, proxy, args);
             }
-            return loadServiceMethod(method).invoke(args);
+            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
           }
         });
   }
@@ -410,13 +411,19 @@ public Builder() {
       callFactory = retrofit.callFactory;
       baseUrl = retrofit.baseUrl;
 
-      converterFactories.addAll(retrofit.converterFactories);
-      // Remove the default BuiltInConverters instance added by build().
-      converterFactories.remove(0);
+      // Do not add the default BuiltIntConverters and platform-aware converters added by build().
+      for (int i = 1,
+          size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();
+          i < size; i++) {
+        converterFactories.add(retrofit.converterFactories.get(i));
+      }
 
-      callAdapterFactories.addAll(retrofit.callAdapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      callAdapterFactories.remove(callAdapterFactories.size() - 1);
+      // Do not add the default, platform-aware call adapters added by build().
+      for (int i = 0,
+          size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
+          i < size; i++) {
+        callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
+      }
 
       callbackExecutor = retrofit.callbackExecutor;
       validateEagerly = retrofit.validateEagerly;
@@ -580,16 +587,17 @@ public Retrofit build() {
 
       // Make a defensive copy of the adapters and add the default Call adapter.
       List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
-      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
 
       // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories =
-          new ArrayList<>(1 + this.converterFactories.size());
+      List<Converter.Factory> converterFactories = new ArrayList<>(
+          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());
 
       // Add the built-in converter factory first. This prevents overriding its behavior but also
       // ensures correct behavior when using converters that consume all types.
       converterFactories.add(new BuiltInConverters());
       converterFactories.addAll(this.converterFactories);
+      converterFactories.addAll(platform.defaultConverterFactories());
 
       return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
           unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 377762b8a..8ddd42254 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -17,7 +17,6 @@
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import javax.annotation.Nullable;
 
 import static retrofit2.Utils.methodError;
 
@@ -37,5 +36,5 @@
     return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
   }
 
-  abstract T invoke(@Nullable Object[] args);
+  abstract T invoke(Object[] args);
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Streaming.java b/retrofit/src/main/java/retrofit2/http/Streaming.java
index 4a87591df..23fc0e290 100644
--- a/retrofit/src/main/java/retrofit2/http/Streaming.java
+++ b/retrofit/src/main/java/retrofit2/http/Streaming.java
@@ -18,13 +18,14 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import okhttp3.ResponseBody;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
- * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
+ * Treat the response body on methods returning {@link ResponseBody ResponseBody} as is,
+ * i.e. without converting the body to {@code byte[]}.
  */
 @Documented
 @Target(METHOD)
diff --git a/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
new file mode 100644
index 000000000..e3da90636
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/internal/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull {
+}
diff --git a/retrofit/src/main/java/retrofit2/package-info.java b/retrofit/src/main/java/retrofit2/package-info.java
index 135079424..2638c2e96 100644
--- a/retrofit/src/main/java/retrofit2/package-info.java
+++ b/retrofit/src/main/java/retrofit2/package-info.java
@@ -9,7 +9,5 @@
  * }
  * </pre>
  */
-@ParametersAreNonnullByDefault
+@retrofit2.internal.EverythingIsNonNull
 package retrofit2;
-
-import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
index 2a7e06bed..afb74da23 100644
--- a/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
+++ b/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro
@@ -1,5 +1,6 @@
-# Retrofit does reflection on generic parameters and InnerClass is required to use Signature.
--keepattributes Signature, InnerClasses
+# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and
+# EnclosingMethod is required to use InnerClasses.
+-keepattributes Signature, InnerClasses, EnclosingMethod
 
 # Retain service method parameters when optimizing.
 -keepclassmembers,allowshrinking,allowobfuscation interface * {
@@ -14,3 +15,6 @@
 
 # Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.
 -dontwarn kotlin.Unit
+
+# Top-level functions that can only be used by Kotlin.
+-dontwarn retrofit2.-KotlinExtensions
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
new file mode 100644
index 000000000..feaacc929
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureCallAdapterFactoryTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import com.google.common.reflect.TypeToken;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final CallAdapter.Factory factory = CompletableFutureCallAdapterFactory.INSTANCE;
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+  }
+
+  @Test public void responseType() {
+    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
+    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
+    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
+    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void nonListenableFutureReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/CompletableFutureTest.java b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
new file mode 100644
index 000000000..bf44dfd55
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/CompletableFutureTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.helpers.ToStringConverterFactory;
+import retrofit2.http.GET;
+
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CompletableFutureTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") CompletableFuture<String> body();
+    @GET("/") CompletableFuture<Response<String>> response();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<String> future = service.body();
+    assertThat(future.get()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(HttpException.class)
+          .hasMessage("HTTP 404 Client Error");
+    }
+  }
+
+  @Test public void bodyFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<String> future = service.body();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    CompletableFuture<Response<String>> future = service.response();
+    Response<String> response = future.get();
+    assertThat(response.isSuccessful()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    CompletableFuture<Response<String>> future = service.response();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/InvocationTest.java b/retrofit/src/test/java/retrofit2/InvocationTest.java
new file mode 100644
index 000000000..0dda742ba
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/InvocationTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import org.junit.Test;
+import retrofit2.http.Body;
+import retrofit2.http.POST;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class InvocationTest {
+  interface Example {
+    @POST("/{p1}") //
+    Call<ResponseBody> postMethod(
+        @Path("p1") String p1, @Query("p2") String p2, @Body RequestBody body);
+  }
+
+  @Test public void invocationObjectOnCallAndRequestTag() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callFactory(new OkHttpClient())
+        .build();
+
+    Example example = retrofit.create(Example.class);
+    RequestBody requestBody = RequestBody.create(MediaType.get("text/plain"), "three");
+    Call<ResponseBody> call = example.postMethod("one", "two", requestBody);
+
+    Invocation invocation = call.request().tag(Invocation.class);
+    Method method = invocation.method();
+    assertThat(method.getName()).isEqualTo("postMethod");
+    assertThat(method.getDeclaringClass()).isEqualTo(Example.class);
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two", requestBody));
+  }
+
+  @Test public void nullMethod() {
+    try {
+      Invocation.of(null, Arrays.asList("one", "two"));
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("method == null");
+    }
+  }
+
+  @Test public void nullArguments() {
+    try {
+      Invocation.of(Example.class.getDeclaredMethods()[0], null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("arguments == null");
+    }
+  }
+
+  @Test public void argumentsAreImmutable() {
+    List<String> mutableList = new ArrayList<>(Arrays.asList("one", "two"));
+    Invocation invocation = Invocation.of(Example.class.getDeclaredMethods()[0], mutableList);
+    mutableList.add("three");
+    assertThat(invocation.arguments()).isEqualTo(Arrays.asList("one", "two"));
+    try {
+      invocation.arguments().clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
new file mode 100644
index 000000000..b8196c7e6
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/KotlinExtensionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import okhttp3.mockwebserver.MockWebServer
+import org.junit.Assert.assertNotNull
+import org.junit.Rule
+import org.junit.Test
+
+class KotlinExtensionsTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Empty
+
+  @Test fun reifiedCreate() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build()
+
+    assertNotNull(retrofit.create<Empty>())
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
new file mode 100644
index 000000000..2bd4d9451
--- /dev/null
+++ b/retrofit/src/test/java/retrofit2/OptionalConverterFactoryTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Optional;
+import javax.annotation.Nullable;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class OptionalConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Optional<Object>> optional();
+    @GET("/") Call<Object> object();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ObjectToNullConverterFactory())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void optional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Optional<Object> optional = service.optional().execute().body();
+    assertThat(optional).isNotNull();
+    assertThat(optional.isPresent()).isFalse();
+  }
+
+  @Test public void onlyMatchesOptional() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Object body = service.object().execute().body();
+    assertThat(body).isNull();
+  }
+
+  static final class ObjectToNullConverterFactory extends Converter.Factory {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
+      if (type != Object.class) {
+        return null;
+      }
+      return new Converter<ResponseBody, Object>() {
+        @Override public Object convert(ResponseBody value) {
+          return null;
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 05e4cf928..a1ec09dc7 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nullable;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -271,8 +272,8 @@
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     final AtomicBoolean adapterCalled = new AtomicBoolean();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          final Type returnType, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         if (getRawType(returnType) != Call.class) {
           return null;
@@ -302,8 +303,8 @@
 
   @Test public void customCallAdapter() {
     class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<Object, String> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         if (getRawType(returnType) != String.class) {
           return null;
         }
@@ -331,8 +332,8 @@
   @Test public void methodAnnotationsPassedToCallAdapter() {
     final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
     class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable CallAdapter<?, ?> get(
+          Type returnType, Annotation[] annotations, Retrofit retrofit) {
         annotationsRef.set(annotations);
         return null;
       }
@@ -364,6 +365,7 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
           + "  Tried:\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
   }
@@ -442,8 +444,8 @@
   @Test public void stringConverterCalledForString() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -461,8 +463,8 @@
   @Test public void stringConverterReturningNullResultsInDefault() {
     final AtomicBoolean factoryCalled = new AtomicBoolean();
     class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
+      @Override public @Nullable Converter<?, String> stringConverter(
+          Type type, Annotation[] annotations, Retrofit retrofit) {
         factoryCalled.set(true);
         return null;
       }
@@ -492,7 +494,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -514,7 +517,8 @@
       assertThat(e.getCause()).hasMessage(""
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
+          + "   * retrofit2.BuiltInConverters\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
   }
 
@@ -843,7 +847,7 @@
         .baseUrl("http://example.com/")
         .build();
     List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories).hasSize(2);
     assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
   }
 
@@ -907,7 +911,8 @@
           + "Could not locate RequestBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -936,7 +941,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -983,7 +989,8 @@
           + "Could not locate ResponseBody converter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory.called).isTrue();
@@ -1012,7 +1019,8 @@
           + "   * retrofit2.BuiltInConverters\n"
           + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
           + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
+          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+          + "   * retrofit2.OptionalConverterFactory");
     }
 
     assertThat(nonMatchingFactory1.called).isFalse();
@@ -1183,6 +1191,7 @@
           + "Could not locate call adapter for class java.lang.String.\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
@@ -1215,6 +1224,7 @@
           + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
           + "  Tried:\n"
           + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+          + "   * retrofit2.CompletableFutureCallAdapterFactory\n"
           + "   * retrofit2.DefaultCallAdapterFactory");
     }
 
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 3f44ddff8..76dfbf51f 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,14 +17,15 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
   public boolean called;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+  @Override public @Nullable CallAdapter<?, ?> get(
+      Type returnType, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..28c4dfb77 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -25,21 +26,20 @@
 public final class NonMatchingConverterFactory extends Converter.Factory {
   public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     called = true;
     return null;
   }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<?, String> stringConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     called = true;
     return null;
   }
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index bcafe282c..c267d3356 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -27,9 +28,8 @@
 public class ToStringConverterFactory extends Converter.Factory {
   static final MediaType MEDIA_TYPE = MediaType.get("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
+  @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+      Type type, Annotation[] annotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<ResponseBody, String>() {
         @Override public String convert(ResponseBody value) throws IOException {
@@ -40,7 +40,7 @@
     return null;
   }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     if (String.class.equals(type)) {
       return new Converter<String, RequestBody>() {
diff --git a/samples/pom.xml b/samples/pom.xml
index 10ce5624b..97a0715da 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -52,6 +52,11 @@
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.jsoup</groupId>
       <artifactId>jsoup</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
index 0664d3482..d4b86d56b 100644
--- a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -22,6 +22,7 @@
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -67,9 +68,8 @@ public AnnotatedConverterFactory build() {
       this.factories = new LinkedHashMap<>(factories);
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
         if (factory != null) {
@@ -79,7 +79,7 @@ public AnnotatedConverterFactory build() {
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         Converter.Factory factory = factories.get(annotation.annotationType());
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..1a2bde63a 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -48,8 +49,7 @@
    * present on {@code @Body} params.
    */
   static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       boolean isBody = false;
       boolean isChunked = false;
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 2fd7e350f..d2e1da916 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import javax.annotation.Nullable;
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
@@ -127,7 +128,7 @@ public static void main(String... args) throws Exception {
 
   static final class PageAdapter implements Converter<ResponseBody, Page> {
     static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
+      @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
           Type type, Annotation[] annotations, Retrofit retrofit) {
         if (type == Page.class) return new PageAdapter();
         return null;
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index fd05c044d..03dc55029 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -59,8 +60,8 @@
   }
 
   public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != MyCall.class) {
         return null;
       }
diff --git a/samples/src/main/java/com/example/retrofit/InvocationMetrics.java b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
new file mode 100644
index 000000000..49ac30481
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/InvocationMetrics.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Invocation;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import retrofit2.http.Url;
+
+/**
+ * This example prints HTTP call metrics with the initiating method names and arguments.
+ */
+public final class InvocationMetrics {
+  public interface Browse {
+    @GET("/robots.txt")
+    Call<ResponseBody> robots();
+
+    @GET("/favicon.ico")
+    Call<ResponseBody> favicon();
+
+    @GET("/")
+    Call<ResponseBody> home();
+
+    @GET
+    Call<ResponseBody> page(@Url String path);
+  }
+
+  static final class InvocationLogger implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      long startNanos = System.nanoTime();
+      Response response = chain.proceed(request);
+      long elapsedNanos = System.nanoTime() - startNanos;
+
+      Invocation invocation = request.tag(Invocation.class);
+      if (invocation != null) {
+        System.out.printf("%s.%s %s HTTP %s (%.0f ms)%n",
+            invocation.method().getDeclaringClass().getSimpleName(),
+            invocation.method().getName(),
+            invocation.arguments(),
+            response.code(),
+            elapsedNanos / 1_000_000.0);
+      }
+
+      return response;
+    }
+  }
+
+  public static void main(String... args) throws IOException {
+    InvocationLogger invocationLogger = new InvocationLogger();
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .addInterceptor(invocationLogger)
+        .build();
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("https://square.com/")
+        .callFactory(okHttpClient)
+        .build();
+
+    Browse browse = retrofit.create(Browse.class);
+
+    browse.robots().execute();
+    browse.favicon().execute();
+    browse.home().execute();
+    browse.page("sitemap.xml").execute();
+    browse.page("notfound").execute();
+  }
+}
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..354e901c3 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -60,9 +61,8 @@
       this.xmlFactory = xmlFactory;
     }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           return jsonFactory.responseBodyConverter(type, annotations, retrofit);
@@ -74,7 +74,7 @@
       return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+    @Override public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,
         Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
       for (Annotation annotation : parameterAnnotations) {
         if (annotation instanceof Json) {
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index 724c75fb2..35489272a 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -47,8 +48,8 @@
       this.delegateFactory = delegateFactory;
     }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
+    @Override public @Nullable Converter<?, String> stringConverter(
+        Type type, Annotation[] annotations, Retrofit retrofit) {
       for (Annotation annotation : annotations) {
         if (annotation instanceof Json) {
           // NOTE: If you also have a JSON converter factory installed in addition to this factory,
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
index 6c4fec40d..4e7a2d636 100644
--- a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import javax.annotation.Nullable;
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -48,8 +49,8 @@ public static void main(String... args) {
       this.scheduler = scheduler;
     }
 
-    @Override
-    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+    @Override public @Nullable CallAdapter<?, ?> get(
+        Type returnType, Annotation[] annotations, Retrofit retrofit) {
       if (getRawType(returnType) != Observable.class) {
         return null; // Ignore non-Observable types.
       }
diff --git a/samples/src/main/java/com/example/retrofit/package-info.java b/samples/src/main/java/com/example/retrofit/package-info.java
new file mode 100644
index 000000000..5ec8c5bac
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/package-info.java
@@ -0,0 +1,2 @@
+@javax.annotation.ParametersAreNonnullByDefault
+package com.example.retrofit;
