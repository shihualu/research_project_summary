diff --git a/pom.xml b/pom.xml
index f273bfa0f..1f039d2c4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -35,6 +35,7 @@
   <modules>
     <module>retrofit</module>
     <module>retrofit-converters</module>
+    <module>retrofit-mock</module>
     <module>retrofit-samples</module>
   </modules>
 
@@ -50,17 +51,19 @@
     <android.platform>16</android.platform>
     <gson.version>2.2.4</gson.version>
     <okhttp.version>1.2.1</okhttp.version>
+    <rxjava.version>0.14.9</rxjava.version>
 
     <!-- Converter Dependencies -->
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.2.2</jackson.version>
-    <wire.version>1.0.1</wire.version>
+    <wire.version>1.2.0</wire.version>
+    <simplexml.version>2.7.1</simplexml.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
     <fest.version>2.0M10</fest.version>
     <mockito.version>1.9.5</mockito.version>
-    <guava.version>14.0.1</guava.version>
+    <guava.version>15.0</guava.version>
   </properties>
 
   <scm>
@@ -103,6 +106,11 @@
         <artifactId>gson</artifactId>
         <version>${gson.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.netflix.rxjava</groupId>
+        <artifactId>rxjava-core</artifactId>
+        <version>${rxjava.version}</version>
+      </dependency>
 
       <dependency>
         <groupId>com.google.protobuf</groupId>
@@ -119,6 +127,11 @@
         <artifactId>wire-runtime</artifactId>
         <version>${wire.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.simpleframework</groupId>
+        <artifactId>simple-xml</artifactId>
+        <version>${simplexml.version}</version>
+      </dependency>
 
       <dependency>
         <groupId>junit</groupId>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
index 82f306101..49cd8aee8 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
@@ -13,7 +13,6 @@
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.type.TypeFactory;
 
 /**
  * A {@link Converter} which uses Jackson for reading and writing entities.
@@ -31,7 +30,7 @@ public JacksonConverter(ObjectMapper objectMapper) {
 
   @Override public Object fromBody(TypedInput body, final Type type) throws ConversionException {
     try {
-      final JavaType javaType = TypeFactory.defaultInstance().constructType(type);
+      final JavaType javaType = objectMapper.getTypeFactory().constructType(type);
       return objectMapper.readValue(body.in(), javaType);
     } catch (final JsonParseException e) {
       throw new ConversionException(e);
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 2c4159400..468b7072e 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -18,5 +18,6 @@
     <module>protobuf</module>
     <module>jackson</module>
     <module>wire</module>
+    <module>simplexml</module>
   </modules>
 </project>
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
new file mode 100644
index 000000000..9c21926d7
--- /dev/null
+++ b/retrofit-converters/simplexml/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>1.2.3-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-simplexml</artifactId>
+  <name>Converter: SimpleXML</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.simpleframework</groupId>
+      <artifactId>simple-xml</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easytesting</groupId>
+      <artifactId>fest-assert-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
new file mode 100644
index 000000000..98d36887f
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
@@ -0,0 +1,60 @@
+package retrofit.converter;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.lang.reflect.Type;
+
+import org.simpleframework.xml.Serializer;
+
+import retrofit.mime.TypedByteArray;
+import retrofit.mime.TypedInput;
+import retrofit.mime.TypedOutput;
+
+/**
+ * A {@link Converter} which uses SimpleXML for reading and writing entities.
+ *
+ * @author Fabien Ric (fabien.ric@gmail.com)
+ */
+public class SimpleXMLConverter implements Converter {
+  private static final String CHARSET = "UTF-8";
+  private static final String MIME_TYPE = "application/xml; charset=" + CHARSET;
+
+  private final Serializer serializer;
+
+  public SimpleXMLConverter(Serializer serializer) {
+    this.serializer = serializer;
+  }
+
+  @Override
+  public Object fromBody(TypedInput body, Type type) throws ConversionException {
+    try {
+      return serializer.read((Class<?>) type, body.in());
+    } catch (Exception e) {
+      throw new ConversionException(e);
+    }
+  }
+
+  @Override
+  public TypedOutput toBody(Object source) {
+    OutputStreamWriter osw = null;
+
+    try {
+      ByteArrayOutputStream bos = new ByteArrayOutputStream();
+      osw = new OutputStreamWriter(bos, CHARSET);
+      serializer.write(source, osw);
+      osw.flush();
+      return new TypedByteArray(MIME_TYPE, bos.toByteArray());
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    } finally {
+      try {
+        if (osw != null) {
+          osw.close();
+        }
+      } catch (IOException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
new file mode 100644
index 000000000..8eaa53b69
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
@@ -0,0 +1,139 @@
+package retrofit.converter;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+import java.io.ByteArrayOutputStream;
+
+import org.junit.Test;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import org.simpleframework.xml.Element;
+import org.simpleframework.xml.core.Persister;
+import org.simpleframework.xml.stream.Format;
+import org.simpleframework.xml.stream.HyphenStyle;
+import org.simpleframework.xml.stream.Verbosity;
+
+import retrofit.mime.TypedByteArray;
+import retrofit.mime.TypedInput;
+import retrofit.mime.TypedOutput;
+
+public class SimpleXMLConverterTest {
+	private static final String MIME_TYPE = "application/xml; charset=UTF-8";
+
+	private final MyObject obj = new MyObject("hello world", 10);
+	private final String objAsXML = String.format(
+			"<my-object><message>%s</message><count>%d</count></my-object>",
+			obj.getMessage(), obj.getCount());
+	private final Converter converter = initConverter();
+
+	private static Converter initConverter() {
+		Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+		Persister persister = new Persister(format);
+		return new SimpleXMLConverter(persister);
+	}
+
+	@Test
+	public void serialize() throws Exception {
+		final TypedOutput typedOutput = converter.toBody(obj);
+		assertThat(typedOutput.mimeType()).isEqualTo(MIME_TYPE);
+		assertThat(asString(typedOutput)).isEqualTo(objAsXML);
+	}
+
+	@Test
+	public void deserialize() throws Exception {
+		final TypedInput input = new TypedByteArray(MIME_TYPE,
+				objAsXML.getBytes());
+		final MyObject result = (MyObject) converter.fromBody(input,
+				MyObject.class);
+		assertThat(result).isEqualTo(obj);
+	}
+
+	@Test(expected = ConversionException.class)
+	public void deserializeWrongValue() throws Exception {
+		final TypedInput input = new TypedByteArray(MIME_TYPE,
+				"<myObject><foo/><bar/></myObject>".getBytes());
+		converter.fromBody(input, MyObject.class);
+
+	}
+
+	@Test
+	public void deserializeWrongClass() throws Exception {
+		final TypedInput input = new TypedByteArray(MIME_TYPE,
+				objAsXML.getBytes());
+		Object result = converter.fromBody(input, String.class);
+		assertThat(result).isNull();
+	}
+
+	private String asString(TypedOutput typedOutput) throws Exception {
+		final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		typedOutput.writeTo(bytes);
+		return new String(bytes.toByteArray());
+	}
+
+	@Default(value = DefaultType.FIELD)
+	static class MyObject {
+		@Element
+		private String message;
+		@Element
+		private int count;
+
+		public MyObject() {
+		}
+
+		public MyObject(String message, int count) {
+			this.message = message;
+			this.count = count;
+		}
+
+		public void setMessage(String message) {
+			this.message = message;
+		}
+
+		public String getMessage() {
+			return message;
+		}
+
+		public void setCount(int count) {
+			this.count = count;
+		}
+
+		public int getCount() {
+			return count;
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + count;
+			result = prime * result
+					+ ((message == null) ? 0 : message.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj) {
+				return true;
+			}
+			if (obj == null) {
+				return false;
+			}
+			if (getClass() != obj.getClass()) {
+				return false;
+			}
+			MyObject other = (MyObject) obj;
+			if (count != other.count) {
+				return false;
+			}
+			if (message == null) {
+				if (other.message != null) {
+					return false;
+				}
+			} else if (!message.equals(other.message)) {
+				return false;
+			}
+			return true;
+		}
+	}
+}
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
new file mode 100644
index 000000000..739d9ee7e
--- /dev/null
+++ b/retrofit-mock/pom.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>parent</artifactId>
+    <version>1.2.3-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>retrofit-mock</artifactId>
+  <name>Retrofit Mock Adapter</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>com.netflix.rxjava</groupId>
+      <artifactId>rxjava-core</artifactId>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easytesting</groupId>
+      <artifactId>fest-assert-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
new file mode 100644
index 000000000..87d18b3bf
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
@@ -0,0 +1,107 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.util.ArrayList;
+import java.util.List;
+import retrofit.client.Header;
+import retrofit.client.Response;
+import retrofit.converter.Converter;
+
+import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
+import static java.net.HttpURLConnection.HTTP_FORBIDDEN;
+import static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+
+/**
+ * An exception used to trigger the simulation of an HTTP error for mock services.
+ *
+ * @see MockRestAdapter
+ */
+public class MockHttpException extends RuntimeException {
+  /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
+  public static MockHttpException newMovedPermanentely(String location, Object responseBody) {
+    if (location == null || "".equals(location.trim())) {
+      throw new IllegalArgumentException("Location must not be blank.");
+    }
+    return new MockHttpException(HTTP_MOVED_PERM, "Moved Permanently", responseBody)
+        .withHeader("Location", location);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 302 Moved Temporarily. */
+  public static MockHttpException newMovedTemporarily(String location, Object responseBody) {
+    if (location == null || "".equals(location.trim())) {
+      throw new IllegalArgumentException("Location must not be blank.");
+    }
+    return new MockHttpException(HTTP_MOVED_TEMP, "Moved Temporarily", responseBody)
+        .withHeader("Location", location);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 400 Bad Request. */
+  public static MockHttpException newBadRequest(Object responseBody) {
+    return new MockHttpException(HTTP_BAD_REQUEST, "Bad Request", responseBody);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 401 Unauthorized. */
+  public static MockHttpException newUnauthorized(Object responseBody) {
+    return new MockHttpException(HTTP_UNAUTHORIZED, "Unauthorized", responseBody);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 403 Forbidden. */
+  public static MockHttpException newForbidden(Object responseBody) {
+    return new MockHttpException(HTTP_FORBIDDEN, "Forbidded", responseBody);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 404 Not Found. */
+  public static MockHttpException newNotFound(Object responseBody) {
+    return new MockHttpException(HTTP_NOT_FOUND, "Not Found", responseBody);
+  }
+
+  /** Create a new {@link MockHttpException} for HTTP 500 Internal Server Error. */
+  public static MockHttpException newInternalError(Object responseBody) {
+    return new MockHttpException(HTTP_INTERNAL_ERROR, "Internal Server Error", responseBody);
+  }
+
+  final int code;
+  final String reason;
+  final Object responseBody;
+  final List<Header> headers = new ArrayList<Header>(2);
+
+  /**
+   * Create a new HTTP exception.
+   *
+   * @param code HTTP status code to trigger. Must be 300 or higher.
+   * @param reason HTTP status reason message.
+   * @param responseBody Object to use as the contents of the response body.
+   */
+  public MockHttpException(int code, String reason, Object responseBody) {
+    super("HTTP " + code + " " + reason);
+    if (code < 300 || code > 599) {
+      throw new IllegalArgumentException("Unsupported HTTP error code: " + code);
+    }
+    if (reason == null || "".equals(reason.trim())) {
+      throw new IllegalArgumentException("Reason must not be blank.");
+    }
+    this.code = code;
+    this.reason = reason;
+    this.responseBody = responseBody;
+  }
+
+  /** Add a header to the response. */
+  public MockHttpException withHeader(String name, String value) {
+    if (name == null || "".equals(name.trim())) {
+      throw new IllegalArgumentException("Header name must not be blank.");
+    }
+    if (value == null || "".equals(value.trim())) {
+      throw new IllegalArgumentException("Header value must not be blank.");
+    }
+    headers.add(new Header(name, value));
+    return this;
+  }
+
+  Response toResponse(Converter converter) {
+    return new Response(code, reason, headers, new MockTypedInput(converter, responseBody));
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
new file mode 100644
index 000000000..209b07a72
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
@@ -0,0 +1,22 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.lang.reflect.Type;
+import retrofit.client.Response;
+
+class MockHttpRetrofitError extends RetrofitError {
+  private final Object body;
+
+  MockHttpRetrofitError(String url, Response response, Object body) {
+    super(url, response, null, null, false, null);
+    this.body = body;
+  }
+
+  @Override public Object getBody() {
+    return body;
+  }
+
+  @Override public Object getBodyAs(Type type) {
+    return body;
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
new file mode 100644
index 000000000..25c02dac5
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
@@ -0,0 +1,535 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import retrofit.client.Request;
+import retrofit.client.Response;
+import rx.Observable;
+import rx.Observer;
+import rx.Subscription;
+import rx.concurrency.Schedulers;
+
+import static retrofit.RestAdapter.LogLevel;
+
+/**
+ * Wraps mocks implementations of API interfaces so that they exhibit the delay and error
+ * characteristics of a real network.
+ * <p>
+ * Because APIs are defined as interfaces, versions of the API that use mock data can be created by
+ * simply implementing the API interface on a class. These mock implementations execute
+ * synchronously which is a large deviation from the behavior of those backed by an API call over
+ * the network. By wrapping the mock instances using this class, the interface will still use mock
+ * data but exhibit the delays and errors that a real network would face.
+ * <p>
+ * Create an API interface and a mock implementation of it.
+ * <pre>
+ *   public interface UserService {
+ *     &#64;GET("/user/{id}")
+ *     User getUser(@Path("id") String userId);
+ *   }
+ *   public class MockUserService implements UserService {
+ *     &#64;Override public User getUser(String userId) {
+ *       return new User("Jake");
+ *     }
+ *   }
+ * </pre>
+ * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
+ * <pre>
+ *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+ * </pre>
+ * Instances of this class should be used as a singleton so that the behavior of every mock service
+ * is consistent.
+ * <p>
+ * Rather than using the {@code MockUserService} directly, pass it through
+ * {@link #create(Class, Object) the create method}.
+ * <pre>
+ *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
+ * </pre>
+ * The returned {@code UserService} instance will now behave like it is happening over the network
+ * while allowing the mock implementation to be written synchronously.
+ * <p>
+ * HTTP errors can be simulated in your mock services by throwing an instance of
+ * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
+ * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
+ */
+public final class MockRestAdapter {
+  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+  private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by Â±40%.
+  private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
+  private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
+
+  /**
+   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
+   * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
+   */
+  public static MockRestAdapter from(RestAdapter restAdapter) {
+    return new MockRestAdapter(restAdapter);
+  }
+
+  /** A listener invoked when the network behavior values for a {@link MockRestAdapter} change. */
+  public interface ValueChangeListener {
+    void onMockValuesChanged(long delayMs, int variancePct, int errorPct);
+
+    ValueChangeListener EMPTY = new ValueChangeListener() {
+      @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
+      }
+    };
+  }
+
+  private final RestAdapter restAdapter;
+  private final MockRxSupport mockRxSupport;
+  final Random random = new Random();
+
+  private ValueChangeListener listener = ValueChangeListener.EMPTY;
+  private int delayMs = DEFAULT_DELAY_MS;
+  private int variancePct = DEFAULT_VARIANCE_PCT;
+  private int errorPct = DEFAULT_ERROR_PCT;
+
+  private MockRestAdapter(RestAdapter restAdapter) {
+    this.restAdapter = restAdapter;
+
+    if (Platform.HAS_RX_JAVA) {
+      mockRxSupport = new MockRxSupport(restAdapter);
+    } else {
+      mockRxSupport = null;
+    }
+  }
+
+  /** Set a listener to be notified when any mock value changes. */
+  public void setValueChangeListener(ValueChangeListener listener) {
+    this.listener = listener;
+  }
+
+  private void notifyValueChangeListener() {
+    listener.onMockValuesChanged(delayMs, variancePct, errorPct);
+  }
+
+  /** Set the network round trip delay, in milliseconds. */
+  public void setDelay(long delayMs) {
+    if (delayMs < 0) {
+      throw new IllegalArgumentException("Delay must be positive value.");
+    }
+    if (delayMs > Integer.MAX_VALUE) {
+      throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
+    }
+    if (this.delayMs != delayMs) {
+      this.delayMs = (int) delayMs;
+      notifyValueChangeListener();
+    }
+  }
+
+  /** The network round trip delay, in milliseconds */
+  public long getDelay() {
+    return delayMs;
+  }
+
+  /** Set the plus-or-minus variance percentage of the network round trip delay. */
+  public void setVariancePercentage(int variancePct) {
+    if (variancePct < 0 || variancePct > 100) {
+      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+    }
+    if (this.variancePct != variancePct) {
+      this.variancePct = variancePct;
+      notifyValueChangeListener();
+    }
+  }
+
+  /** The plus-or-minus variance percentage of the network round trip delay. */
+  public int getVariancePercentage() {
+    return variancePct;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public void setErrorPercentage(int errorPct) {
+    if (errorPct < 0 || errorPct > 100) {
+      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
+    }
+    if (this.errorPct != errorPct) {
+      this.errorPct = errorPct;
+      notifyValueChangeListener();
+    }
+  }
+
+  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public int getErrorPercentage() {
+    return errorPct;
+  }
+
+  /**
+   * Randomly determine whether this call should result in a network failure.
+   * <p>
+   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
+   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
+   * using {@link #create(Class, Object)}.
+   */
+  public boolean calculateIsFailure() {
+    int randomValue = random.nextInt(100) + 1;
+    return randomValue <= errorPct;
+  }
+
+  /**
+   * Get the delay (in milliseconds) that should be used for triggering a network error.
+   * <p>
+   * Because we are triggering an error, use a random delay between 0 and three times the normal
+   * network delay to simulate a flaky connection failing anywhere from quickly to slowly.
+   * <p>
+   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
+   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
+   * using {@link #create(Class, Object)}.
+   */
+  public int calculateDelayForError() {
+    return random.nextInt(delayMs * ERROR_DELAY_FACTOR);
+  }
+
+  /**
+   * Get the delay (in milliseconds) that should be used for delaying a network call response.
+   * <p>
+   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
+   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
+   * using {@link #create(Class, Object)}.
+   */
+  public int calculateDelayForCall() {
+    float errorPercent = variancePct / 100f; // e.g., 20 / 100f == 0.2f
+    float lowerBound = 1f - errorPercent; // 0.2f --> 0.8f
+    float upperBound = 1f + errorPercent; // 0.2f --> 1.2f
+    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+    float delayPercent = (random.nextFloat() * bound) + lowerBound; // 0.8 + (rnd * 0.4)
+    return (int) (delayMs * delayPercent);
+  }
+
+  /**
+   * Wrap the supplied mock implementation of a service so that it exhibits the delay and error
+   * characteristics of a real network.
+   *
+   * @see #setDelay(long)
+   * @see #setVariancePercentage(int)
+   * @see #setErrorPercentage(int)
+   */
+  @SuppressWarnings("unchecked")
+  public <T> T create(Class<T> service, T mockService) {
+    Utils.validateServiceClass(service);
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        new MockHandler(mockService, restAdapter.getMethodInfoCache(service)));
+  }
+
+  private class MockHandler implements InvocationHandler {
+    private final Object mockService;
+    private final Map<Method, RestMethodInfo> methodInfoCache;
+
+    public MockHandler(Object mockService, Map<Method, RestMethodInfo> methodInfoCache) {
+      this.mockService = mockService;
+      this.methodInfoCache = methodInfoCache;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, final Object[] args)
+        throws Throwable {
+      // If the method is a method from Object then defer to normal invocation.
+      if (method.getDeclaringClass() == Object.class) {
+        return method.invoke(this, args);
+      }
+
+      // Load or create the details cache for the current method.
+      final RestMethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
+
+      if (methodInfo.isSynchronous) {
+        return invokeSync(methodInfo, restAdapter.requestInterceptor, args);
+      }
+
+      if (restAdapter.httpExecutor == null || restAdapter.callbackExecutor == null) {
+        throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
+      }
+      // Apply the interceptor synchronously, recording the interception so we can replay it later.
+      // This way we still defer argument serialization to the background thread.
+      final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
+      restAdapter.requestInterceptor.intercept(interceptorTape);
+
+      if (methodInfo.isObservable) {
+        return mockRxSupport.createMockObservable(this, methodInfo, interceptorTape, args);
+      }
+
+      restAdapter.httpExecutor.execute(new Runnable() {
+        @Override public void run() {
+          invokeAsync(methodInfo, interceptorTape, args);
+        }
+      });
+      return null; // Asynchronous methods should have return type of void.
+    }
+
+    private Request buildRequest(RestMethodInfo methodInfo, RequestInterceptor interceptor,
+        Object[] args) throws Throwable {
+      methodInfo.init();
+
+      // Begin building a normal request.
+      RequestBuilder requestBuilder = new RequestBuilder(restAdapter.converter, methodInfo);
+      requestBuilder.setApiUrl(restAdapter.server.getUrl());
+      requestBuilder.setArguments(args);
+
+      // Run it through the interceptor.
+      interceptor.intercept(requestBuilder);
+
+      Request request = requestBuilder.build();
+
+      if (restAdapter.logLevel.log()) {
+        request = restAdapter.logAndReplaceRequest("MOCK", request);
+      }
+
+      return request;
+    }
+
+    private Object invokeSync(RestMethodInfo methodInfo, RequestInterceptor interceptor,
+        Object[] args) throws Throwable {
+      Request request = buildRequest(methodInfo, interceptor, args);
+      String url = request.getUrl();
+
+      if (calculateIsFailure()) {
+        sleep(calculateDelayForError());
+        IOException exception = new IOException("Mock network error!");
+        if (restAdapter.logLevel.log()) {
+          restAdapter.logException(exception, url);
+        }
+        throw RetrofitError.networkError(url, exception);
+      }
+
+      LogLevel logLevel = restAdapter.logLevel;
+      RestAdapter.Log log = restAdapter.log;
+
+      int callDelay = calculateDelayForCall();
+      long beforeNanos = System.nanoTime();
+      try {
+        Object returnValue = methodInfo.method.invoke(mockService, args);
+
+        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
+        sleep(callDelay - tookMs);
+
+        if (logLevel.log()) {
+          log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
+          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+            log.log(returnValue + ""); // Hack to convert toString while supporting null.
+            log.log("<--- END MOCK");
+          }
+        }
+
+        return returnValue;
+      } catch (InvocationTargetException e) {
+        Throwable innerEx = e.getCause();
+        if (!(innerEx instanceof MockHttpException)) {
+          throw innerEx;
+        }
+        MockHttpException httpEx = (MockHttpException) innerEx;
+        Response response = httpEx.toResponse(restAdapter.converter);
+
+        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
+        sleep(callDelay - tookMs);
+
+        if (logLevel.log()) {
+          log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
+          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+            log.log(httpEx.responseBody + ""); // Hack to convert toString while supporting null.
+            log.log("<--- END MOCK");
+          }
+        }
+
+        throw new MockHttpRetrofitError(url, response, httpEx.responseBody);
+      }
+    }
+
+    private void invokeAsync(RestMethodInfo methodInfo, RequestInterceptor interceptorTape,
+        Object[] args) {
+      Request request;
+      try {
+        request = buildRequest(methodInfo, interceptorTape, args);
+      } catch (final Throwable throwable) {
+        restAdapter.callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            throw new RuntimeException(throwable);
+          }
+        });
+        return;
+      }
+
+      LogLevel logLevel = restAdapter.logLevel;
+      RestAdapter.Log log = restAdapter.log;
+
+      long beforeNanos = System.nanoTime();
+      int callDelay = calculateDelayForCall();
+
+      final String url = request.getUrl();
+      final Callback realCallback = (Callback) args[args.length - 1];
+
+      if (calculateIsFailure()) {
+        sleep(calculateDelayForError());
+        final IOException exception = new IOException("Mock network error!");
+        if (restAdapter.logLevel.log()) {
+          restAdapter.logException(exception, url);
+        }
+        restAdapter.callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            realCallback.failure(RetrofitError.networkError(url, exception));
+          }
+        });
+        return;
+      }
+
+      // Replace the normal callback with one which supports the delay.
+      Object[] newArgs = new Object[args.length];
+      System.arraycopy(args, 0, newArgs, 0, args.length - 1);
+      newArgs[args.length - 1] = new DelayingCallback(beforeNanos, callDelay, url, realCallback);
+
+      try {
+        methodInfo.method.invoke(mockService, newArgs);
+      } catch (Throwable throwable) {
+        final Throwable innerEx = throwable.getCause();
+        if (!(innerEx instanceof MockHttpException)) {
+          restAdapter.callbackExecutor.execute(new Runnable() {
+            @Override public void run() {
+              if (innerEx instanceof RuntimeException) {
+                throw (RuntimeException) innerEx;
+              }
+              throw new RuntimeException(innerEx);
+            }
+          });
+          return;
+        }
+
+        MockHttpException httpEx = (MockHttpException) innerEx;
+        Response response = httpEx.toResponse(restAdapter.converter);
+
+        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
+
+        sleep(callDelay - tookMs);
+
+        if (logLevel.log()) {
+          log.log(String.format("<---- MOCK %s %s (%sms)", httpEx.code, url, callDelay));
+          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+            log.log(httpEx.responseBody + ""); // Hack to convert toString while supporting null.
+            log.log("<--- END MOCK");
+          }
+        }
+
+        final RetrofitError error = new MockHttpRetrofitError(url, response, httpEx.responseBody);
+        restAdapter.callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            realCallback.failure(error);
+          }
+        });
+      }
+    }
+
+    private class DelayingCallback implements Callback {
+      private final long beforeNanos;
+      private final String url;
+      private final Callback realCallback;
+      private final long callDelay;
+
+      private DelayingCallback(long beforeNanos, int callDelay, String url, Callback realCallback) {
+        this.beforeNanos = beforeNanos;
+        this.callDelay = callDelay;
+        this.url = url;
+        this.realCallback = realCallback;
+      }
+
+      @Override public void success(final Object object, final Response response) {
+        LogLevel logLevel = restAdapter.logLevel;
+        RestAdapter.Log log = restAdapter.log;
+
+        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
+        sleep(callDelay - tookMs);
+
+        if (logLevel.log()) {
+          log.log(String.format("<--- MOCK 200 %s (%sms)", url, callDelay));
+          if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
+            log.log(object + ""); // Hack to convert toString while supporting null.
+            log.log("<--- END MOCK");
+          }
+        }
+
+        restAdapter.callbackExecutor.execute(new Runnable() {
+          @SuppressWarnings("unchecked") //
+          @Override public void run() {
+            realCallback.success(object, response);
+          }
+        });
+      }
+
+      @Override public void failure(final RetrofitError error) {
+        restAdapter.callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            throw new IllegalStateException(
+                "Calling failure directly is not supported. Throw MockHttpException instead.");
+          }
+        });
+      }
+    }
+  }
+
+  /**
+   * Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to {@link
+   * Thread#sleep(long)}, but does not throw {@link InterruptedException}; {@link
+   * Thread#interrupt()} events are deferred until the next interruptible operation.  Does not
+   * return until at least the specified number of milliseconds has elapsed.
+   *
+   * @param ms to sleep before returning, in milliseconds of uptime.
+   */
+  private static void sleep(long ms) {
+    // This implementation is modified from Android's SystemClock#sleep.
+
+    long start = uptimeMillis();
+    long duration = ms;
+    boolean interrupted = false;
+    while (duration > 0) {
+      try {
+        Thread.sleep(duration);
+      } catch (InterruptedException e) {
+        interrupted = true;
+      }
+      duration = start + ms - uptimeMillis();
+    }
+
+    if (interrupted) {
+      // Important: we don't want to quietly eat an interrupt() event,
+      // so we make sure to re-interrupt the thread so that the next
+      // call to Thread.sleep() or Object.wait() will be interrupted.
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private static long uptimeMillis() {
+    return System.nanoTime() / 1000000L;
+  }
+
+  /** Indirection to avoid VerifyError if RxJava isn't present. */
+  private static class MockRxSupport {
+    private final RestAdapter restAdapter;
+
+    MockRxSupport(RestAdapter restAdapter) {
+      this.restAdapter = restAdapter;
+    }
+
+    Observable createMockObservable(final MockHandler mockHandler, final RestMethodInfo methodInfo,
+        final RequestInterceptor interceptor, final Object[] args) {
+      return Observable.create(new Observable.OnSubscribeFunc<Object>() {
+        @Override public Subscription onSubscribe(Observer<? super Object> observer) {
+          try {
+            Observable observable =
+                (Observable) mockHandler.invokeSync(methodInfo, interceptor, args);
+            //noinspection unchecked
+            return observable.subscribe(observer);
+          } catch (Throwable throwable) {
+            return Observable.error(throwable).subscribe(observer);
+          }
+        }
+      }).subscribeOn(Schedulers.executor(restAdapter.httpExecutor));
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/MockTypedInput.java b/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
new file mode 100644
index 000000000..278aebc02
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/MockTypedInput.java
@@ -0,0 +1,47 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import retrofit.converter.Converter;
+import retrofit.mime.TypedInput;
+
+class MockTypedInput implements TypedInput {
+  private final Converter converter;
+  private final Object body;
+
+  private byte[] bytes;
+
+  MockTypedInput(Converter converter, Object body) {
+    this.converter = converter;
+    this.body = body;
+  }
+
+  @Override public String mimeType() {
+    return "application/unknown";
+  }
+
+  @Override public long length() {
+    try {
+      initBytes();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+    return bytes.length;
+  }
+
+  @Override public InputStream in() throws IOException {
+    initBytes();
+    return new ByteArrayInputStream(bytes);
+  }
+
+  private synchronized void initBytes() throws IOException {
+    if (bytes == null) {
+      ByteArrayOutputStream out = new ByteArrayOutputStream();
+      converter.toBody(body).writeTo(out);
+      bytes = out.toByteArray();
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java b/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
new file mode 100644
index 000000000..80cab9abc
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
@@ -0,0 +1,53 @@
+// Copyright 2013 Square, Inc.
+package retrofit.android;
+
+import android.content.SharedPreferences;
+import retrofit.MockRestAdapter;
+
+/**
+ * A {@link MockRestAdapter.ValueChangeListener value change listener} for {@link MockRestAdapter}
+ * which stores any customized behavior values into shared preferences.
+ */
+public final class AndroidMockValuePersistence implements MockRestAdapter.ValueChangeListener {
+  private static final String KEY_DELAY = "retrofit-mock-delay";
+  private static final String KEY_VARIANCE = "retrofit-mock-variance";
+  private static final String KEY_ERROR = "retrofit-mock-error";
+
+  /**
+   * Install a {@link MockRestAdapter.ValueChangeListener value change listener} on the supplied
+   * {@link MockRestAdapter} using the {@link SharedPreferences} for storing customized behavior
+   * values. Invoking this will load any existing stored values for the mock adapter's behavior.
+   */
+  public static void install(MockRestAdapter mockRestAdapter, SharedPreferences preferences) {
+    long delay = preferences.getLong(KEY_DELAY, -1);
+    if (delay != -1) {
+      mockRestAdapter.setDelay(delay);
+    }
+
+    int variance = preferences.getInt(KEY_VARIANCE, -1);
+    if (variance != -1) {
+      mockRestAdapter.setVariancePercentage(variance);
+    }
+
+    int error = preferences.getInt(KEY_ERROR, -1);
+    if (error != -1) {
+      mockRestAdapter.setErrorPercentage(error);
+    }
+
+    mockRestAdapter.setValueChangeListener(new AndroidMockValuePersistence(preferences));
+  }
+
+  private final SharedPreferences preferences;
+
+  private AndroidMockValuePersistence(SharedPreferences preferences) {
+    this.preferences = preferences;
+  }
+
+  @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
+    preferences.edit()
+        .putLong(KEY_DELAY, delayMs)
+        .putInt(KEY_VARIANCE, variancePct)
+        .putInt(KEY_ERROR, errorPct)
+        .apply();
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
new file mode 100644
index 000000000..443920bfd
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
@@ -0,0 +1,479 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.io.IOException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit.client.Client;
+import retrofit.client.Request;
+import retrofit.client.Response;
+import retrofit.http.GET;
+import rx.Observable;
+import rx.util.functions.Action1;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static retrofit.MockRestAdapter.ValueChangeListener;
+import static retrofit.Utils.SynchronousExecutor;
+
+public class MockRestAdapterTest {
+  interface SyncExample {
+    @GET("/") Object doStuff();
+  }
+
+  interface AsyncExample {
+    @GET("/") void doStuff(Callback<Object> cb);
+  }
+
+  interface ObservableExample {
+    @GET("/") Observable<Object> doStuff();
+  }
+
+  private Executor httpExecutor;
+  private Executor callbackExecutor;
+  private MockRestAdapter mockRestAdapter;
+  private ValueChangeListener valueChangeListener;
+
+  @Before public void setUp() throws IOException {
+    Client client = mock(Client.class);
+    doThrow(new AssertionError()).when(client).execute(any(Request.class));
+
+    httpExecutor = spy(new SynchronousExecutor());
+    callbackExecutor = spy(new SynchronousExecutor());
+
+    RestAdapter restAdapter = new RestAdapter.Builder() //
+        .setClient(client)
+        .setExecutors(httpExecutor, callbackExecutor)
+        .setServer("http://example.com")
+        .setLogLevel(RestAdapter.LogLevel.NONE)
+        .build();
+
+    valueChangeListener = mock(ValueChangeListener.class);
+
+    mockRestAdapter = MockRestAdapter.from(restAdapter);
+    mockRestAdapter.setValueChangeListener(valueChangeListener);
+
+    // Seed the random with a value so the tests are deterministic.
+    mockRestAdapter.random.setSeed(2847);
+  }
+
+  @Test public void delayRestrictsRange() {
+    try {
+      mockRestAdapter.setDelay(-1);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Delay must be positive value.");
+    }
+    try {
+      mockRestAdapter.setDelay(Long.MAX_VALUE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith("Delay value too large.");
+    }
+  }
+
+  @Test public void varianceRestrictsRange() {
+    try {
+      mockRestAdapter.setVariancePercentage(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+    try {
+      mockRestAdapter.setVariancePercentage(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorRestrictsRange() {
+    try {
+      mockRestAdapter.setErrorPercentage(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+    try {
+      mockRestAdapter.setErrorPercentage(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorPercentageIsAccurate() {
+    mockRestAdapter.setErrorPercentage(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
+    }
+
+    mockRestAdapter.setErrorPercentage(3);
+    int failures = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (mockRestAdapter.calculateIsFailure()) {
+        failures += 1;
+      }
+    }
+    assertThat(failures).isEqualTo(2964); // ~3% of 100k
+  }
+
+  @Test public void delayVarianceIsAccurate() {
+    mockRestAdapter.setDelay(2000);
+
+    mockRestAdapter.setVariancePercentage(0);
+    for (int i = 0; i < 100000; i++) {
+      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
+    }
+
+    mockRestAdapter.setVariancePercentage(40);
+    int lowerBound = Integer.MAX_VALUE;
+    int upperBound = Integer.MIN_VALUE;
+    for (int i = 0; i < 100000; i++) {
+      int delay = mockRestAdapter.calculateDelayForCall();
+      if (delay > upperBound) {
+        upperBound = delay;
+      }
+      if (delay < lowerBound) {
+        lowerBound = delay;
+      }
+    }
+    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
+  }
+
+  @Test public void errorVarianceIsAccurate() {
+    mockRestAdapter.setDelay(2000);
+
+    int lowerBound = Integer.MAX_VALUE;
+    int upperBound = Integer.MIN_VALUE;
+    for (int i = 0; i < 100000; i++) {
+      int delay = mockRestAdapter.calculateDelayForError();
+      if (delay > upperBound) {
+        upperBound = delay;
+      }
+      if (delay < lowerBound) {
+        lowerBound = delay;
+      }
+    }
+    assertThat(upperBound).isEqualTo(5999); // 3 * 2000
+    assertThat(lowerBound).isEqualTo(0);
+  }
+
+  @Test public void changeListenerOnlyInvokedWhenValueHasChanged() {
+    long delay = mockRestAdapter.getDelay();
+    int variance = mockRestAdapter.getVariancePercentage();
+    int error = mockRestAdapter.getErrorPercentage();
+
+    long newDelay = delay + 1;
+    mockRestAdapter.setDelay(newDelay);
+    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, error);
+
+    int newError = error + 1;
+    mockRestAdapter.setErrorPercentage(newError);
+    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, newError);
+
+    int newVariance = variance + 1;
+    mockRestAdapter.setVariancePercentage(newVariance);
+    verify(valueChangeListener).onMockValuesChanged(newDelay, newVariance, newError);
+
+    // Now try setting the same values and ensure the listener was never called.
+    mockRestAdapter.setDelay(newDelay);
+    mockRestAdapter.setVariancePercentage(newVariance);
+    mockRestAdapter.setErrorPercentage(newError);
+    verifyNoMoreInteractions(valueChangeListener);
+  }
+
+  @Test public void syncFailureTriggersNetworkError() {
+    mockRestAdapter.setErrorPercentage(100);
+    mockRestAdapter.setDelay(1);
+
+    class MockSyncExample implements SyncExample {
+      @Override public Object doStuff() {
+        throw new AssertionError();
+      }
+    }
+
+    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+
+    try {
+      mockService.doStuff();
+      fail();
+    } catch (RetrofitError e) {
+      assertThat(e.isNetworkError()).isTrue();
+      assertThat(e.getCause()).hasMessage("Mock network error!");
+    }
+  }
+
+  @Test public void asyncFailureTriggersNetworkError() {
+    mockRestAdapter.setDelay(1);
+    mockRestAdapter.setErrorPercentage(100);
+
+    class MockAsyncExample implements AsyncExample {
+      @Override public void doStuff(Callback<Object> cb) {
+        throw new AssertionError();
+      }
+    }
+
+    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    mockService.doStuff(new Callback<Object>() {
+      @Override public void success(Object o, Response response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(RetrofitError error) {
+        errorRef.set(error);
+      }
+    });
+
+    verify(httpExecutor).execute(any(Runnable.class));
+    verify(callbackExecutor).execute(any(Runnable.class));
+
+    RetrofitError error = errorRef.get();
+    assertThat(error.isNetworkError()).isTrue();
+    assertThat(error.getCause()).hasMessage("Mock network error!");
+  }
+
+  @Test public void syncApiIsCalledWithDelay() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final AtomicBoolean called = new AtomicBoolean();
+    final Object expected = new Object();
+    class MockSyncExample implements SyncExample {
+      @Override public Object doStuff() {
+        called.set(true);
+        return expected;
+      }
+    }
+
+    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+
+    long startNanos = System.nanoTime();
+    Object actual = mockService.doStuff();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+    assertThat(called.get()).isTrue();
+    assertThat(actual).isEqualTo(expected);
+    assertThat(tookMs).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void asyncApiIsCalledWithDelay() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final Object expected = new Object();
+    class MockAsyncExample implements AsyncExample {
+      @Override public void doStuff(Callback<Object> cb) {
+        cb.success(expected, null);
+      }
+    }
+
+    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Object> actual = new AtomicReference<Object>();
+    mockService.doStuff(new Callback<Object>() {
+      @Override public void success(Object result, Response response) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(result);
+      }
+
+      @Override public void failure(RetrofitError error) {
+        throw new AssertionError();
+      }
+    });
+
+    verify(httpExecutor).execute(any(Runnable.class));
+    verify(callbackExecutor).execute(any(Runnable.class));
+
+    assertThat(actual.get()).isNotNull().isSameAs(expected);
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void observableApiIsCalledWithDelay() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final Object expected = new Object();
+    class MockObservableExample implements ObservableExample {
+      @Override public Observable<Object> doStuff() {
+        return Observable.from(expected);
+      }
+    }
+
+    ObservableExample mockService =
+        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Object> actual = new AtomicReference<Object>();
+    Action1<Object> onSuccess = new Action1<Object>() {
+      @Override public void call(Object o) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(o);
+      }
+    };
+    Action1<Throwable> onError = new Action1<Throwable>() {
+      @Override public void call(Throwable throwable) {
+        throw new AssertionError();
+      }
+    };
+
+    mockService.doStuff().subscribe(onSuccess, onError);
+
+    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
+    verifyZeroInteractions(callbackExecutor);
+
+    assertThat(actual.get()).isNotNull().isSameAs(expected);
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+
+  @Test public void syncHttpExceptionBecomesError() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final Object expected = new Object();
+    class MockSyncExample implements SyncExample {
+      @Override public Object doStuff() {
+        throw new MockHttpException(404, "Not Found", expected);
+      }
+    }
+
+    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
+
+    long startNanos = System.nanoTime();
+    try {
+      mockService.doStuff();
+      fail();
+    } catch (RetrofitError e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+      assertThat(e.isNetworkError()).isFalse();
+      assertThat(e.getResponse().getStatus()).isEqualTo(404);
+      assertThat(e.getResponse().getReason()).isEqualTo("Not Found");
+      assertThat(e.getBody()).isSameAs(expected);
+    }
+  }
+
+  @Test public void asyncHttpExceptionBecomesError() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final Object expected = new Object();
+    class MockAsyncExample implements AsyncExample {
+      @Override public void doStuff(Callback<Object> cb) {
+        throw new MockHttpException(404, "Not Found", expected);
+      }
+    }
+
+    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    mockService.doStuff(new Callback<Object>() {
+      @Override public void success(Object o, Response response) {
+        throw new AssertionError();
+      }
+
+      @Override public void failure(RetrofitError error) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        errorRef.set(error);
+      }
+    });
+
+    verify(httpExecutor).execute(any(Runnable.class));
+    verify(callbackExecutor).execute(any(Runnable.class));
+
+    RetrofitError error = errorRef.get();
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(error.isNetworkError()).isFalse();
+    assertThat(error.getResponse().getStatus()).isEqualTo(404);
+    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getBody()).isSameAs(expected);
+  }
+
+  @Test public void observableHttpExceptionBecomesError() {
+    mockRestAdapter.setDelay(100);
+    mockRestAdapter.setVariancePercentage(0);
+    mockRestAdapter.setErrorPercentage(0);
+
+    final Object expected = new Object();
+    class MockObservableExample implements ObservableExample {
+      @Override public Observable<Object> doStuff() {
+        throw new MockHttpException(404, "Not Found", expected);
+      }
+    }
+
+    ObservableExample mockService =
+        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
+    mockService.doStuff().subscribe(new Action1<Object>() {
+      @Override public void call(Object o) {
+        throw new AssertionError();
+      }
+    }, new Action1<Throwable>() {
+      @Override public void call(Throwable error) {
+        assertThat(error).isInstanceOf(RetrofitError.class);
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        errorRef.set((RetrofitError) error);
+      }
+    });
+
+    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
+    verifyZeroInteractions(callbackExecutor);
+
+    RetrofitError error = errorRef.get();
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(error.isNetworkError()).isFalse();
+    assertThat(error.getResponse().getStatus()).isEqualTo(404);
+    assertThat(error.getResponse().getReason()).isEqualTo("Not Found");
+    assertThat(error.getBody()).isSameAs(expected);
+  }
+
+  @Test public void asyncCallToFailureIsNotAllowed() {
+    mockRestAdapter.setErrorPercentage(0);
+
+    class MockAsyncExample implements AsyncExample {
+      @Override public void doStuff(Callback<Object> cb) {
+        cb.failure(null);
+      }
+    }
+
+    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
+
+    try {
+      mockService.doStuff(mock(Callback.class));
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Calling failure directly is not supported. Throw MockHttpException instead.");
+    }
+  }
+}
diff --git a/retrofit-samples/mock-github-client/pom.xml b/retrofit-samples/mock-github-client/pom.xml
new file mode 100644
index 000000000..da0b64c09
--- /dev/null
+++ b/retrofit-samples/mock-github-client/pom.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  ~ Copyright 2013 Square, Inc.
+  -->
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit.samples</groupId>
+    <artifactId>parent</artifactId>
+    <version>1.2.3-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>mock-github-client</artifactId>
+  <name>Sample: Mock GitHub Client</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit-mock</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java b/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
new file mode 100644
index 000000000..77a9ce2aa
--- /dev/null
+++ b/retrofit-samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
@@ -0,0 +1,110 @@
+// Copyright 2013 Square, Inc.
+package com.example.retrofit;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import retrofit.MockRestAdapter;
+import retrofit.RestAdapter;
+import retrofit.http.GET;
+import retrofit.http.Path;
+
+public class GitHubClient {
+  private static final String API_URL = "https://api.github.com";
+
+  static class Contributor {
+    public final String login;
+    public final int contributions;
+
+    Contributor(String login, int contributions) {
+      this.login = login;
+      this.contributions = contributions;
+    }
+  }
+
+  public interface GitHub {
+    @GET("/repos/{owner}/{repo}/contributors")
+    List<Contributor> contributors(@Path("owner") String owner, @Path("repo") String repo);
+  }
+
+  /** A mock implementation of the {@link GitHub} API interface. */
+  static class MockGitHub implements GitHub {
+    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+
+    public MockGitHub() {
+      ownerRepoContributors = new LinkedHashMap<String, Map<String, List<Contributor>>>();
+
+      // Seed some mock data.
+      addContributor("square", "retrofit", "John Doe", 12);
+      addContributor("square", "retrofit", "Bob Smith", 2);
+      addContributor("square", "retrofit", "Big Bird", 40);
+      addContributor("square", "picasso", "Proposition Joe", 39);
+      addContributor("square", "picasso", "Keiser Soze", 152);
+    }
+
+    @Override public List<Contributor> contributors(String owner, String repo) {
+      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+      if (repoContributors == null) {
+        return Collections.emptyList();
+      }
+      List<Contributor> contributors = repoContributors.get(repo);
+      if (contributors == null) {
+        return Collections.emptyList();
+      }
+      return contributors;
+    }
+
+    public void addContributor(String owner, String repo, String name, int contributions) {
+      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+      if (repoContributors == null) {
+        repoContributors = new LinkedHashMap<String, List<Contributor>>();
+        ownerRepoContributors.put(owner, repoContributors);
+      }
+      List<Contributor> contributors = repoContributors.get(repo);
+      if (contributors == null) {
+        contributors = new ArrayList<Contributor>();
+        repoContributors.put(repo, contributors);
+      }
+      contributors.add(new Contributor(name, contributions));
+    }
+  }
+
+  public static void main(String... args) {
+    // Create a very simple REST adapter which points the GitHub API endpoint.
+    RestAdapter restAdapter = new RestAdapter.Builder()
+        .setServer(API_URL)
+        .build();
+
+    // Wrap our REST adapter to allow mock implementations and fake network delay.
+    MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
+
+    // Instantiate a mock object so we can interact with it later.
+    MockGitHub mockGitHub = new MockGitHub();
+    // Use the mock REST adapter and our mock object to create the API interface.
+    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+
+    // Query for some contributors for a few repositories.
+    printContributors(gitHub, "square", "retrofit");
+    printContributors(gitHub, "square", "picasso");
+
+    // Using the mock object, add some additional mock data.
+    System.out.println("Adding more mock data...\n");
+    mockGitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+    mockGitHub.addContributor("square", "picasso", "Kit Kat", 53);
+
+    // Query for the contributors again so we can see the mock data that was added.
+    printContributors(gitHub, "square", "retrofit");
+    printContributors(gitHub, "square", "picasso");
+  }
+
+  private static void printContributors(GitHub gitHub, String owner, String repo) {
+    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+    List<Contributor> contributors = gitHub.contributors(owner, repo);
+    for (Contributor contributor : contributors) {
+      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+    }
+    System.out.println();
+  }
+}
diff --git a/retrofit-samples/pom.xml b/retrofit-samples/pom.xml
index 57a7541b2..9566c8580 100644
--- a/retrofit-samples/pom.xml
+++ b/retrofit-samples/pom.xml
@@ -17,5 +17,6 @@
 
   <modules>
     <module>github-client</module>
+    <module>mock-github-client</module>
   </modules>
 </project>
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 3f42b945f..70e038f5b 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -28,6 +28,11 @@
       <artifactId>okhttp</artifactId>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>com.netflix.rxjava</groupId>
+      <artifactId>rxjava-core</artifactId>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index cdc04b1f5..12a7472da 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -36,6 +36,8 @@
 abstract class Platform {
   private static final Platform PLATFORM = findPlatform();
 
+  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
+
   static Platform get() {
     return PLATFORM;
   }
@@ -166,4 +168,13 @@ static Client instantiate() {
       return new OkClient();
     }
   }
+
+  private static boolean hasRxJavaOnClasspath() {
+    try {
+      Class.forName("rx.Observable");
+      return true;
+    } catch (ClassNotFoundException e) {
+    }
+    return false;
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index a4960a634..40ebe1ff5 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -35,6 +35,7 @@
   private final RestMethodInfo.ParamUsage[] paramUsages;
   private final String requestMethod;
   private final boolean isSynchronous;
+  private final boolean isObservable;
 
   private final FormUrlEncodedTypedOutput formBody;
   private final MultipartTypedOutput multipartBody;
@@ -50,6 +51,7 @@
     paramUsages = methodInfo.requestParamUsage;
     requestMethod = methodInfo.requestMethod;
     isSynchronous = methodInfo.isSynchronous;
+    isObservable = methodInfo.isObservable;
 
     headers = new ArrayList<Header>();
     if (methodInfo.headers != null) {
@@ -163,7 +165,7 @@ void setArguments(Object[] args) {
       return;
     }
     int count = args.length;
-    if (!isSynchronous) {
+    if (!isSynchronous && !isObservable) {
       count -= 1;
     }
     for (int i = 0; i < count; i++) {
diff --git a/retrofit/src/main/java/retrofit/ResponseCallback.java b/retrofit/src/main/java/retrofit/ResponseCallback.java
new file mode 100644
index 000000000..b841e99b2
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ResponseCallback.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import retrofit.client.Response;
+
+/**
+ * An extension of {@link Callback} which returns only {@link Response} object
+ * in {@link Callback#success(Object, retrofit.client.Response)} method.
+ */
+public abstract class ResponseCallback implements Callback<Response> {
+
+  @Override
+  public void success(Response response, Response response2) {
+    success(response);
+  }
+
+  /** Successful HTTP response. */
+  public abstract void success(Response response);
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 907b52386..465b6a5f7 100644
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -24,6 +24,7 @@
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import retrofit.Profiler.RequestInformation;
@@ -37,6 +38,12 @@
 import retrofit.mime.TypedByteArray;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
+import rx.Observable;
+import rx.Observer;
+import rx.Scheduler;
+import rx.Subscription;
+import rx.concurrency.Schedulers;
+import rx.subscriptions.Subscriptions;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -55,9 +62,8 @@
  * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
  * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
  * {@link retrofit.http.Query @Query}. If the path or query element has already been URI encoded
- * use {@link retrofit.http.EncodedPath @EncodedPath} or {@link retrofit.http.EncodedQuery
- *
- * @EncodedQuery} to prevent repeated encoding.
+ * use {@link retrofit.http.EncodedPath @EncodedPath} or
+ * {@link retrofit.http.EncodedQuery @EncodedQuery} to prevent repeated encoding.
  * <p>
  * HTTP requests happen in one of two ways:
  * <ul>
@@ -130,7 +136,11 @@
     BASIC,
     /** Log the basic information along with request and response headers. */
     HEADERS,
-    /** Log the headers, body, and metadata for both requests and responses. */
+    /**
+     * Log the headers, body, and metadata for both requests and responses.
+     * <p>
+     * Note: This requires that the entire request and response body be buffered in memory!
+     */
     FULL;
 
     public boolean log() {
@@ -138,16 +148,22 @@ public boolean log() {
     }
   }
 
-  private final Server server;
+  private final Map<Class<?>, Map<Method, RestMethodInfo>> serviceMethodInfoCache =
+      new LinkedHashMap<Class<?>, Map<Method, RestMethodInfo>>();
+
+  final Server server;
+  final Executor httpExecutor;
+  final Executor callbackExecutor;
+  final RequestInterceptor requestInterceptor;
+  final Converter converter;
+  final Log log;
+  final ErrorHandler errorHandler;
+
   private final Client.Provider clientProvider;
-  private final Executor httpExecutor;
-  private final Executor callbackExecutor;
-  private final RequestInterceptor requestInterceptor;
-  private final Converter converter;
   private final Profiler profiler;
-  private final ErrorHandler errorHandler;
-  private final Log log;
-  private volatile LogLevel logLevel;
+  private final RxSupport rxSupport;
+
+  volatile LogLevel logLevel;
 
   private RestAdapter(Server server, Client.Provider clientProvider, Executor httpExecutor,
       Executor callbackExecutor, RequestInterceptor requestInterceptor, Converter converter,
@@ -155,6 +171,11 @@ private RestAdapter(Server server, Client.Provider clientProvider, Executor http
     this.server = server;
     this.clientProvider = clientProvider;
     this.httpExecutor = httpExecutor;
+    if (Platform.HAS_RX_JAVA && httpExecutor != null) {
+      this.rxSupport = new RxSupport(httpExecutor);
+    } else {
+      this.rxSupport = null;
+    }
     this.callbackExecutor = callbackExecutor;
     this.requestInterceptor = requestInterceptor;
     this.converter = converter;
@@ -180,22 +201,70 @@ public LogLevel getLogLevel() {
   /** Create an implementation of the API defined by the specified {@code service} interface. */
   @SuppressWarnings("unchecked")
   public <T> T create(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface endpoint definitions are supported.");
+    Utils.validateServiceClass(service);
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        new RestHandler(getMethodInfoCache(service)));
+  }
+
+  Map<Method, RestMethodInfo> getMethodInfoCache(Class<?> service) {
+    synchronized (serviceMethodInfoCache) {
+      Map<Method, RestMethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
+      if (methodInfoCache == null) {
+        methodInfoCache = new LinkedHashMap<Method, RestMethodInfo>();
+        serviceMethodInfoCache.put(service, methodInfoCache);
+      }
+      return methodInfoCache;
     }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getSuperclass() != null) {
-      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+  }
+
+  static RestMethodInfo getMethodInfo(Map<Method, RestMethodInfo> cache, Method method) {
+    synchronized (cache) {
+      RestMethodInfo methodInfo = cache.get(method);
+      if (methodInfo == null) {
+        methodInfo = new RestMethodInfo(method);
+        cache.put(method, methodInfo);
+      }
+      return methodInfo;
+    }
+  }
+
+  /** Indirection to avoid VerifyError if RxJava isn't present. */
+  private static final class RxSupport {
+    private final Scheduler scheduler;
+
+    RxSupport(Executor executor) {
+      this.scheduler = Schedulers.executor(executor);
+    }
+
+    Scheduler getScheduler() {
+      return scheduler;
+    }
+
+    Observable createRequestObservable(final Callable<ResponseWrapper> request) {
+      return Observable.create(new Observable.OnSubscribeFunc<Object>() {
+        @Override public Subscription onSubscribe(Observer<? super Object> observer) {
+          try {
+            ResponseWrapper wrapper = request.call();
+            observer.onNext(wrapper.responseBody);
+            observer.onCompleted();
+          } catch (RetrofitError e) {
+            observer.onError(e);
+          } catch (Exception e) {
+            // This is from the Callable.  It shouldn't actually throw.
+            throw new RuntimeException(e);
+          }
+          return Subscriptions.empty();
+        }
+      });
     }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler());
   }
 
   private class RestHandler implements InvocationHandler {
-    private final Map<Method, RestMethodInfo> methodDetailsCache =
-        new LinkedHashMap<Method, RestMethodInfo>();
+    private final Map<Method, RestMethodInfo> methodDetailsCache;
+
+    RestHandler(Map<Method, RestMethodInfo> methodDetailsCache) {
+      this.methodDetailsCache = methodDetailsCache;
+    }
 
     @SuppressWarnings("unchecked") //
     @Override public Object invoke(Object proxy, Method method, final Object[] args)
@@ -206,19 +275,11 @@ public LogLevel getLogLevel() {
       }
 
       // Load or create the details cache for the current method.
-      final RestMethodInfo methodDetails;
-      synchronized (methodDetailsCache) {
-        RestMethodInfo tempMethodDetails = methodDetailsCache.get(method);
-        if (tempMethodDetails == null) {
-          tempMethodDetails = new RestMethodInfo(method);
-          methodDetailsCache.put(method, tempMethodDetails);
-        }
-        methodDetails = tempMethodDetails;
-      }
+      final RestMethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
 
-      if (methodDetails.isSynchronous) {
+      if (methodInfo.isSynchronous) {
         try {
-          return invokeRequest(requestInterceptor, methodDetails, args);
+          return invokeRequest(requestInterceptor, methodInfo, args);
         } catch (RetrofitError error) {
           Throwable newError = errorHandler.handleError(error);
           if (newError == null) {
@@ -232,14 +293,24 @@ public LogLevel getLogLevel() {
       if (httpExecutor == null || callbackExecutor == null) {
         throw new IllegalStateException("Asynchronous invocation requires calling setExecutors.");
       }
+
       // Apply the interceptor synchronously, recording the interception so we can replay it later.
       // This way we still defer argument serialization to the background thread.
       final RequestInterceptorTape interceptorTape = new RequestInterceptorTape();
       requestInterceptor.intercept(interceptorTape);
+
+      if (methodInfo.isObservable) {
+        return rxSupport.createRequestObservable(new Callable<ResponseWrapper>() {
+          @Override public ResponseWrapper call() throws Exception {
+            return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
+          }
+        }).subscribeOn(rxSupport.getScheduler());
+      }
+
       Callback<?> callback = (Callback<?>) args[args.length - 1];
       httpExecutor.execute(new CallbackRunnable(callback, callbackExecutor) {
         @Override public ResponseWrapper obtainResponse() {
-          return (ResponseWrapper) invokeRequest(interceptorTape, methodDetails, args);
+          return (ResponseWrapper) invokeRequest(interceptorTape, methodInfo, args);
         }
       });
       return null; // Asynchronous methods should have return type of void.
@@ -252,13 +323,13 @@ public LogLevel getLogLevel() {
      * @throws RetrofitError if any error occurs during the HTTP request.
      */
     private Object invokeRequest(RequestInterceptor requestInterceptor,
-        RestMethodInfo methodDetails, Object[] args) {
-      methodDetails.init(); // Ensure all relevant method information has been loaded.
+        RestMethodInfo methodInfo, Object[] args) {
+      methodInfo.init(); // Ensure all relevant method information has been loaded.
 
       String serverUrl = server.getUrl();
       String url = serverUrl; // Keep some url in case RequestBuilder throws an exception.
       try {
-        RequestBuilder requestBuilder = new RequestBuilder(converter, methodDetails);
+        RequestBuilder requestBuilder = new RequestBuilder(converter, methodInfo);
         requestBuilder.setApiUrl(serverUrl);
         requestBuilder.setArguments(args);
 
@@ -267,14 +338,14 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
         Request request = requestBuilder.build();
         url = request.getUrl();
 
-        if (!methodDetails.isSynchronous) {
+        if (!methodInfo.isSynchronous) {
           // If we are executing asynchronously then update the current thread with a useful name.
           Thread.currentThread().setName(THREAD_PREFIX + url.substring(serverUrl.length()));
         }
 
         if (logLevel.log()) {
           // Log the request data.
-          request = logAndReplaceRequest(request);
+          request = logAndReplaceRequest("HTTP", request);
         }
 
         Object profilerObject = null;
@@ -288,7 +359,7 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
 
         int statusCode = response.getStatus();
         if (profiler != null) {
-          RequestInformation requestInfo = getRequestInfo(serverUrl, methodDetails, request);
+          RequestInformation requestInfo = getRequestInfo(serverUrl, methodInfo, request);
           //noinspection unchecked
           profiler.afterCall(requestInfo, elapsedTime, statusCode, profilerObject);
         }
@@ -298,7 +369,7 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
           response = logAndReplaceResponse(url, response, elapsedTime);
         }
 
-        Type type = methodDetails.responseObjectType;
+        Type type = methodInfo.responseObjectType;
 
         if (statusCode >= 200 && statusCode < 300) { // 2XX == successful request
           // Caller requested the raw Response object directly.
@@ -306,7 +377,7 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
             // Read the entire stream and replace with one backed by a byte[]
             response = Utils.readBodyToBytesIfNecessary(response);
 
-            if (methodDetails.isSynchronous) {
+            if (methodInfo.isSynchronous) {
               return response;
             }
             return new ResponseWrapper(response, response);
@@ -320,7 +391,7 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
           ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(body);
           try {
             Object convert = converter.fromBody(wrapped, type);
-            if (methodDetails.isSynchronous) {
+            if (methodInfo.isSynchronous) {
               return convert;
             }
             return new ResponseWrapper(response, convert);
@@ -353,7 +424,7 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
         }
         throw RetrofitError.unexpectedError(url, t);
       } finally {
-        if (!methodDetails.isSynchronous) {
+        if (!methodInfo.isSynchronous) {
           Thread.currentThread().setName(IDLE_THREAD_NAME);
         }
       }
@@ -361,8 +432,8 @@ private Object invokeRequest(RequestInterceptor requestInterceptor,
   }
 
   /** Log request headers and body. Consumes request body and returns identical replacement. */
-  private Request logAndReplaceRequest(Request request) throws IOException {
-    log.log(String.format("---> HTTP %s %s", request.getMethod(), request.getUrl()));
+  Request logAndReplaceRequest(String name, Request request) throws IOException {
+    log.log(String.format("---> %s %s %s", name, request.getMethod(), request.getUrl()));
 
     if (logLevel.ordinal() >= LogLevel.HEADERS.ordinal()) {
       for (Header header : request.getHeaders()) {
@@ -399,7 +470,7 @@ private Request logAndReplaceRequest(Request request) throws IOException {
         }
       }
 
-      log.log(String.format("---> END HTTP (%s-byte body)", bodySize));
+      log.log(String.format("---> END %s (%s-byte body)", name, bodySize));
     }
 
     return request;
@@ -446,7 +517,7 @@ private Response logAndReplaceResponse(String url, Response response, long elaps
   }
 
   /** Log an exception that occurred during the processing of a request or response. */
-  private void logException(Throwable t, String url) {
+  void logException(Throwable t, String url) {
     log.log(String.format("---- ERROR %s", url));
     StringWriter sw = new StringWriter();
     t.printStackTrace(new PrintWriter(sw));
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index 13b0bcfe4..cd0957e55 100644
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -38,9 +38,17 @@
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.RestMethod;
+import rx.Observable;
 
 /** Request metadata about a service interface declaration. */
 final class RestMethodInfo {
+
+  private enum ResponseType {
+    VOID,
+    OBSERVABLE,
+    OBJECT
+  }
+
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
@@ -64,7 +72,9 @@
   boolean loaded = false;
 
   // Method-level details
+  final ResponseType responseType;
   final boolean isSynchronous;
+  final boolean isObservable;
   Type responseObjectType;
   RequestType requestType = RequestType.SIMPLE;
   String requestMethod;
@@ -80,7 +90,9 @@
 
   RestMethodInfo(Method method) {
     this.method = method;
-    isSynchronous = parseResponseType();
+    responseType = parseResponseType();
+    isSynchronous = (responseType == ResponseType.OBJECT);
+    isObservable = (responseType == ResponseType.OBSERVABLE);
   }
 
   synchronized void init() {
@@ -222,8 +234,9 @@ private void parsePath(String path) {
   }
 
   /** Loads {@link #responseObjectType}. Returns {@code true} if method is synchronous. */
-  private boolean parseResponseType() {
+  private ResponseType parseResponseType() {
     // Synchronous methods have a non-void return type.
+    // Observable methods have a return type of Observable.
     Type returnType = method.getGenericReturnType();
 
     // Asynchronous methods should have a Callback type as the last argument.
@@ -257,21 +270,22 @@ private boolean parseResponseType() {
     }
 
     if (hasReturnType) {
+      if (Platform.HAS_RX_JAVA) {
+        Class rawReturnType = Types.getRawType(returnType);
+        if (rawReturnType == Observable.class) {
+          returnType = Types.getSupertype(returnType, rawReturnType, Observable.class);
+          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
+          return ResponseType.OBSERVABLE;
+        }
+      }
       responseObjectType = returnType;
-      return true;
+      return ResponseType.OBJECT;
     }
 
     lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
     if (lastArgType instanceof ParameterizedType) {
-      Type[] types = ((ParameterizedType) lastArgType).getActualTypeArguments();
-      for (int i = 0; i < types.length; i++) {
-        Type type = types[i];
-        if (type instanceof WildcardType) {
-          types[i] = ((WildcardType) type).getUpperBounds()[0];
-        }
-      }
-      responseObjectType = types[0];
-      return false;
+      responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
+      return ResponseType.VOID;
     }
 
     throw new IllegalArgumentException("Last parameter of "
@@ -280,6 +294,18 @@ private boolean parseResponseType() {
         + lastArgType);
   }
 
+
+  private static Type getParameterUpperBound(ParameterizedType type) {
+    Type[] types = type.getActualTypeArguments();
+    for (int i = 0; i < types.length; i++) {
+      Type paramType = types[i];
+      if (paramType instanceof WildcardType) {
+        types[i] = ((WildcardType) paramType).getUpperBounds()[0];
+      }
+    }
+    return types[0];
+  }
+
   /**
    * Loads {@link #requestParamNames} and {@link #requestParamUsage}. Must be called after
    * {@link #parseMethodAnnotations()}.
@@ -289,7 +315,7 @@ private void parseParameters() {
 
     Annotation[][] parameterAnnotationArrays = method.getParameterAnnotations();
     int count = parameterAnnotationArrays.length;
-    if (!isSynchronous) {
+    if (!isSynchronous && !isObservable) {
       count -= 1; // Callback is last argument when not a synchronous method.
     }
 
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index 4a8b2cff0..3ee113207 100644
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -47,7 +47,7 @@ public static RetrofitError unexpectedError(String url, Throwable exception) {
   private final Type successType;
   private final boolean networkError;
 
-  private RetrofitError(String url, Response response, Converter converter, Type successType,
+  RetrofitError(String url, Response response, Converter converter, Type successType,
       boolean networkError, Throwable exception) {
     super(exception);
     this.url = url;
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 624c0f1e5..416c98b7a 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -96,6 +96,18 @@ static Response replaceResponseBody(Response response, TypedInput body) {
     return new Response(response.getStatus(), response.getReason(), response.getHeaders(), body);
   }
 
+  static <T> void validateServiceClass(Class<T> service) {
+    if (!service.isInterface()) {
+      throw new IllegalArgumentException("Only interface endpoint definitions are supported.");
+    }
+    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+    // the recommended pattern.
+    if (service.getSuperclass() != null) {
+      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+    }
+  }
+
   static class SynchronousExecutor implements Executor {
     @Override public void execute(Runnable runnable) {
       runnable.run();
diff --git a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
index 453b36a2f..10eaf3723 100644
--- a/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
+++ b/retrofit/src/main/java/retrofit/client/UrlConnectionClient.java
@@ -31,6 +31,7 @@
 
 /** Retrofit client that uses {@link HttpURLConnection} for communication. */
 public class UrlConnectionClient implements Client {
+  private static final int CHUNK_SIZE = 4096;
   private final Field methodField;
 
   public UrlConnectionClient() {
@@ -80,7 +81,10 @@ void prepareRequest(HttpURLConnection connection, Request request) throws IOExce
       connection.addRequestProperty("Content-Type", body.mimeType());
       long length = body.length();
       if (length != -1) {
+        connection.setFixedLengthStreamingMode((int) length);
         connection.addRequestProperty("Content-Length", String.valueOf(length));
+      } else {
+        connection.setChunkedStreamingMode(CHUNK_SIZE);
       }
       body.writeTo(connection.getOutputStream());
     }
diff --git a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
index 90ab62396..347e691ed 100644
--- a/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
+++ b/retrofit/src/main/java/retrofit/mime/MultipartTypedOutput.java
@@ -13,17 +13,62 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package retrofit.mime;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.UUID;
 
 public final class MultipartTypedOutput implements TypedOutput {
-  final List<byte[]> parts = new ArrayList<byte[]>();
+
+  private static final class MimePart {
+    private final TypedOutput body;
+    private final String name;
+    private final boolean isFirst;
+    private final String boundary;
+
+    private byte[] partBoundary;
+    private byte[] partHeader;
+    private boolean isBuilt;
+
+    public MimePart(String name, TypedOutput body, String boundary, boolean isFirst) {
+      this.name = name;
+      this.body = body;
+      this.isFirst = isFirst;
+      this.boundary = boundary;
+    }
+
+    public void writeTo(OutputStream out) throws IOException {
+      build();
+      out.write(partBoundary);
+      out.write(partHeader);
+      body.writeTo(out);
+    }
+
+    public long size() {
+      build();
+      if (body.length() > -1) {
+        return body.length() + partBoundary.length + partHeader.length;
+      } else {
+        return -1;
+      }
+    }
+
+    private void build() {
+      if (isBuilt) return;
+      partBoundary = buildBoundary(boundary, isFirst, false);
+      partHeader = buildHeader(name, body);
+      isBuilt = true;
+    }
+  }
+
+  private final List<MimePart> mimeParts = new LinkedList<MimePart>();
+
   private final byte[] footer;
   private final String boundary;
   private long length;
@@ -38,6 +83,16 @@ public MultipartTypedOutput() {
     length = footer.length;
   }
 
+  List<byte[]> getParts() throws IOException {
+    List<byte[]> parts = new ArrayList<byte[]>(mimeParts.size());
+    for (MimePart part : mimeParts) {
+      ByteArrayOutputStream bos = new ByteArrayOutputStream();
+      part.writeTo(bos);
+      parts.add(bos.toByteArray());
+    }
+    return parts;
+  }
+
   public void addPart(String name, TypedOutput body) {
     if (name == null) {
       throw new NullPointerException("Part name must not be null.");
@@ -46,13 +101,14 @@ public void addPart(String name, TypedOutput body) {
       throw new NullPointerException("Part body must not be null.");
     }
 
-    byte[] part = buildPart(name, body, parts.isEmpty());
-    parts.add(part);
-    length += part.length;
+    MimePart part = new MimePart(name, body, boundary, mimeParts.isEmpty());
+    mimeParts.add(part);
+
+    length += part.size();
   }
 
   public int getPartCount() {
-    return parts.size();
+    return mimeParts.size();
   }
 
   @Override public String fileName() {
@@ -68,32 +124,12 @@ public int getPartCount() {
   }
 
   @Override public void writeTo(OutputStream out) throws IOException {
-    for (byte[] part : parts) {
-      out.write(part);
+    for (MimePart part : mimeParts) {
+      part.writeTo(out);
     }
     out.write(footer);
   }
 
-  private byte[] buildPart(String name, TypedOutput body, boolean first) {
-    ByteArrayOutputStream out = null;
-    try {
-      out = new ByteArrayOutputStream();
-      out.write(buildBoundary(boundary, first, false));
-      out.write(buildHeader(name, body));
-      body.writeTo(out);
-      return out.toByteArray();
-    } catch (IOException ex) {
-      throw new RuntimeException("Unable to write multipart request.", ex);
-    } finally {
-      if (out != null) {
-        try {
-          out.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-  }
-
   private static byte[] buildBoundary(String boundary, boolean first, boolean last) {
     try {
       StringBuilder sb = new StringBuilder();
@@ -113,7 +149,7 @@ public int getPartCount() {
     }
   }
 
-  private byte[] buildHeader(String name, TypedOutput value) {
+  private static byte[] buildHeader(String name, TypedOutput value) {
     try {
       StringBuilder headers = new StringBuilder();
       headers.append("Content-Disposition: form-data; name=\"");
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
index 447e85a67..8974d5cfa 100644
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ b/retrofit/src/test/java/retrofit/RestAdapterTest.java
@@ -11,6 +11,7 @@
 import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.ArgumentCaptor;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import retrofit.client.Client;
@@ -22,9 +23,12 @@
 import retrofit.http.GET;
 import retrofit.http.Headers;
 import retrofit.http.POST;
+import retrofit.http.Path;
 import retrofit.mime.TypedInput;
 import retrofit.mime.TypedOutput;
 import retrofit.mime.TypedString;
+import rx.Observable;
+import rx.util.functions.Action1;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
@@ -32,7 +36,9 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.same;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
@@ -74,6 +80,8 @@
     @GET("/") void something(Callback<Object> callback);
     @GET("/") Response direct();
     @GET("/") void direct(Callback<Response> callback);
+    @POST("/") Observable<String> observable(@Body String body);
+    @POST("/{x}/{y}") Observable<Response> observable(@Path("x") String x, @Path("y") String y);
   }
   private interface InvalidExample extends Example {
   }
@@ -512,4 +520,49 @@ public void log(String message) {
     verify(mockCallbackExecutor).execute(any(Runnable.class));
     verify(callback).success(eq(response), same(response));
   }
+
+  @Test public void observableCallsOnNext() throws Exception {
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
+    Action1<String> action = mock(Action1.class);
+    example.observable("Howdy").subscribe(action);
+    verify(action).call(eq("hello"));
+  }
+
+  @Test public void observableCallsOnError() throws Exception {
+    when(mockClient.execute(any(Request.class))) //
+        .thenReturn(new Response(300, "FAIL", NO_HEADERS, new TypedString("bummer")));
+    Action1<String> onSuccess = mock(Action1.class);
+    Action1<Throwable> onError = mock(Action1.class);
+    example.observable("Howdy").subscribe(onSuccess, onError);
+    verifyZeroInteractions(onSuccess);
+    verify(onError).call(isA(RetrofitError.class));
+  }
+
+  @Test public void observableHandlesParams() throws Exception {
+    ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
+    when(mockClient.execute(requestCaptor.capture())) //
+        .thenReturn(new Response(200, "OK", NO_HEADERS, new TypedString("hello")));
+    ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);
+    Action1<Response> action = mock(Action1.class);
+    example.observable("X", "Y").subscribe(action);
+
+    Request request = requestCaptor.getValue();
+    assertThat(request.getUrl()).contains("/X/Y");
+
+    verify(action).call(responseCaptor.capture());
+    Response response = responseCaptor.getValue();
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test public void observableUsesHttpExecutor() throws IOException {
+    Response response = new Response(200, "OK", NO_HEADERS, new TypedString("hello"));
+    when(mockClient.execute(any(Request.class))).thenReturn(response);
+
+    example.observable("Howdy").subscribe(mock(Action1.class));
+
+    verify(mockRequestExecutor, atLeastOnce()).execute(any(Runnable.class));
+    verifyZeroInteractions(mockCallbackExecutor);
+  }
+
 }
diff --git a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
index e77b8a0d0..c4a21fa44 100644
--- a/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/RestMethodInfoTest.java
@@ -30,6 +30,7 @@
 import retrofit.http.Query;
 import retrofit.http.RestMethod;
 import retrofit.mime.TypedOutput;
+import rx.Observable;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -204,6 +205,47 @@ public void pathMustBePrefixedWithSlash() {
     assertThat(methodInfo.responseObjectType).isEqualTo(expected);
   }
 
+  @Test public void observableResponse() {
+    class Example {
+      @GET("/foo") Observable<Response> a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    assertThat(methodInfo.isSynchronous).isFalse();
+    assertThat(methodInfo.isObservable).isTrue();
+    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
+  }
+
+  @Test public void observableGenericResponse() {
+    class Example {
+      @GET("/foo") Observable<List<String>> a() {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    RestMethodInfo methodInfo = new RestMethodInfo(method);
+    assertThat(methodInfo.isSynchronous).isFalse();
+    assertThat(methodInfo.isObservable).isTrue();
+    Type expected = new TypeToken<List<String>>() {}.getType();
+    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void observableWithCallback() {
+    class Example {
+      @GET("/foo") Observable<Response> a(Callback<Response> callback) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.getMethod(Example.class, "a");
+    new RestMethodInfo(method);
+  }
+
   @Test(expected = IllegalArgumentException.class)
   public void missingCallbackTypes() {
     class Example {
diff --git a/retrofit/src/test/java/retrofit/mime/MimeHelper.java b/retrofit/src/test/java/retrofit/mime/MimeHelper.java
index 6b75aff5e..a78198ee3 100644
--- a/retrofit/src/test/java/retrofit/mime/MimeHelper.java
+++ b/retrofit/src/test/java/retrofit/mime/MimeHelper.java
@@ -5,6 +5,10 @@
 
 public class MimeHelper {
   public static List<byte[]> getParts(MultipartTypedOutput output) {
-    return output.parts;
+    try {
+      return output.getParts();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
   }
-}
+}
\ No newline at end of file
diff --git a/website/index.html b/website/index.html
index 05ac687a5..266468051 100644
--- a/website/index.html
+++ b/website/index.html
@@ -99,29 +99,40 @@ <h4>Form Encoded and Multipart</h4>
 User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
             <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
 
-            <h4>Synchronous vs. Asynchronous</h4>
+            <h4>Synchronous vs. Asynchronous vs. Observable</h4>
             <p>Methods can be declared for either synchronous or asynchronous execution.</p>
-            <p>A method with a return type will be executed sychronously.</p>
+            <p>A method with a return type will be executed synchronously.</p>
             <pre class="prettyprint">@GET("/user/{id}/photo")
-Photo listUsers(@Path("id") int id);</pre>
+Photo getUserPhoto(@Path("id") int id);</pre>
             <p>Asynchronous execution requires the last parameter of the method be a <code>Callback</code>.</p>
             <pre class="prettyprint">@GET("/user/{id}/photo")
-void listUsers(@Path("id") int id, Callback&lt;Photo> cb);</pre>
-            <p>On Android, the callbacks will be executed on the main thread. For desktop applications the callbacks will happen on the same thread that executed the HTTP request.</p>
-            
+void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
+            <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
+
+            <p>Retrofit also integrates <a href="https://github.com/Netflix/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
+            <pre class="prettyprint">@GET("/user/{id}/photo")
+Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
+            <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
+
             <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code>.
+            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
             <pre class="prettyprint">@GET("/users/list")
 List&lt;User> userList();
 
 @GET("/users/list")
-void userList(Callback&lt;List&lt;User>> cb);</pre>
+void userList(Callback&lt;List&lt;User>> cb);
+
+@GET("/users/list")
+Observable&lt;List&lt;User>> userList();</pre>
             <p>For access to the raw HTTP response use the <code>Response</code> type.</p>
             <pre class="prettyprint">@GET("/users/list")
 Response userList();
 
 @GET("/users/list")
-void userList(Callback&lt;Response> cb);</pre>
+void userList(Callback&lt;Response> cb);
+
+@GET("/users/list")
+Observable&lt;Response> userList();</pre>
 
             <!--<h3 id="restadapter-configuration">RestAdapter Configuration</h3>
             <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
