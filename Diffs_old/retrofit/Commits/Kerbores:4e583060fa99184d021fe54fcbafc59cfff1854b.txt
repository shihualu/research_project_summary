diff --git a/CHANGELOG.md b/CHANGELOG.md
index 66db0d42d..4ade4be59 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,34 @@
 Change Log
 ==========
 
+Version 2.2.0 *(2017-02-21)*
+----------------------------
+
+ * RxJava 2.x is now supported with a first-party 'adapter-rxjava2' artifact.
+ * New: `@QueryName` annotation allows creating a query parameter with no '=' separator or value.
+ * New: Support for messages generated by Protobuf 3.0 or newer when using the converter for Google's
+   protobuf.
+ * New: RxJava 1.x call adapter now correctly handles broken subscribers whose methods throw exceptions.
+ * New: Add `toString()` implementations for `Response` and `Result`.
+ * New: The Moshi converter factory now offers methods for enabling null serialization and lenient
+   parsing.
+ * New: Add `createAsync()` to RxJava 1.x call adapter factory which executes requests using
+   `Call.enqueue()` using the underlying HTTP client's asynchronous support.
+ * New: `NetworkBehavior` now allows setting an error percentage and returns HTTP errors when triggered.
+ * `HttpException` has been moved into the main artifact and should be used instead of the versions
+   embedded in each adapter (which have been deprecated).
+ * Promote the response body generic type on `CallAdapter` from the `adapt` method to the enclosing
+   class. This is a source-incompatible but binary-compatible change which is only relevant if you are
+   implementing your own `CallAdapter`s.
+ * Remove explicit handling of the now-defunct RoboVM platform.
+ * Fix: Close response on HTTP 204 and 205 to avoid resource leak.
+ * Fix: Reflect the canceled state of the HTTP client's `Call` in Retrofit's `Call`.
+ * Fix: Use supplied string converters for the `String` type on non-body parameters. This allows user
+   converters to handle cases such as when annotating string parameters instead of them always using
+   the raw string.
+ * Fix: Skip a UTF-8 BOM (if present) when using the converter for Moshi.
+
+
 Version 2.1.0 *(2016-06-15)*
 ----------------------------
 
diff --git a/README.md b/README.md
index c7a7cdd9e..0688de8e5 100644
--- a/README.md
+++ b/README.md
@@ -14,12 +14,12 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>retrofit</artifactId>
-  <version>2.1.0</version>
+  <version>2.2.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit2:retrofit:2.1.0'
+compile 'com.squareup.retrofit2:retrofit:2.2.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/pom.xml b/pom.xml
index 3b9062c9b..a93e7e2ec 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,7 +25,7 @@
 
   <groupId>com.squareup.retrofit2</groupId>
   <artifactId>parent</artifactId>
-  <version>2.1.1-SNAPSHOT</version>
+  <version>2.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
@@ -49,7 +49,7 @@
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.5.0</okhttp.version>
+    <okhttp.version>3.6.0</okhttp.version>
     <animal.sniffer.version>1.14</animal.sniffer.version>
 
     <!-- Adapter Dependencies -->
@@ -63,7 +63,7 @@
     <jackson.version>2.7.2</jackson.version>
     <wire.version>2.2.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.3.0</moshi.version>
+    <moshi.version>1.4.0</moshi.version>
 
     <!-- Sample Dependencies -->
     <jsoup.version>1.7.3</jsoup.version>
@@ -196,11 +196,25 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.6.1</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.1</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.0.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
       </plugins>
     </pluginManagement>
diff --git a/retrofit-adapters/guava/README.md b/retrofit-adapters/guava/README.md
index c4749e28e..171ba8a5e 100644
--- a/retrofit-adapters/guava/README.md
+++ b/retrofit-adapters/guava/README.md
@@ -1,7 +1,7 @@
 Guava Adapter
 ==============
 
-An `Adapter` for adapting [Guava][1] types.
+An `Adapter` for adapting [Guava][1] `ListenableFuture`.
 
 
 Download
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index ae5632642..884e97963 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index b3624fc3a..64dd0f5ad 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -41,8 +41,8 @@
  * There are two configurations supported for the {@code ListenableFuture} type parameter:
  * <ul>
  * <li>Direct body (e.g., {@code ListenableFuture<User>}) returns the deserialized body for 2XX
- * responses, sets {@link HttpException} errors for non-2XX responses, and sets {@link IOException}
- * for network errors.</li>
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
  * <li>Response wrapped body (e.g., {@code ListenableFuture<Response<User>>}) returns a
  * {@link Response} object for all HTTP responses and sets {@link IOException} for network
  * errors</li>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
index f18a81955..4eb780eaa 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -17,33 +17,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
index fb3ccb3da..f3ceeca62 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -65,7 +65,9 @@
       future.get();
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
           .hasMessage("HTTP 404 Client Error");
     }
   }
diff --git a/retrofit-adapters/java8/README.md b/retrofit-adapters/java8/README.md
index 84e151b9f..1280b727b 100644
--- a/retrofit-adapters/java8/README.md
+++ b/retrofit-adapters/java8/README.md
@@ -1,7 +1,7 @@
 Java8 Adapter
 ==============
 
-An `Adapter` for adapting [Java8][1] types.
+An `Adapter` for adapting [Java8][1] `CompletableFuture`.
 
 
 Download
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 4ca8fa229..87893ff43 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
index 022fa9848..c2d29cbbb 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -17,33 +17,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index fd905475d..35b79f1a3 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -40,8 +40,8 @@
  * There are two configurations supported for the {@code CompletableFuture} type parameter:
  * <ul>
  * <li>Direct body (e.g., {@code CompletableFuture<User>}) returns the deserialized body for 2XX
- * responses, sets {@link HttpException} errors for non-2XX responses, and sets {@link IOException}
- * for network errors.</li>
+ * responses, sets {@link retrofit2.HttpException HttpException} errors for non-2XX responses, and
+ * sets {@link IOException} for network errors.</li>
  * <li>Response wrapped body (e.g., {@code CompletableFuture<Response<User>>}) returns a
  * {@link Response} object for all HTTP responses and sets {@link IOException} for network
  * errors</li>
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
index d4a00a1dc..ee06a31eb 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -65,7 +65,9 @@
       future.get();
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
+      assertThat(e.getCause())
+          .isInstanceOf(HttpException.class) // Required for backwards compatibility.
+          .isInstanceOf(retrofit2.HttpException.class)
           .hasMessage("HTTP 404 Client Error");
     }
   }
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index fc5e8d505..da39f934c 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava/README.md b/retrofit-adapters/rxjava/README.md
index daaea6786..42e1804e0 100644
--- a/retrofit-adapters/rxjava/README.md
+++ b/retrofit-adapters/rxjava/README.md
@@ -3,6 +3,11 @@ RxJava Adapter
 
 An `Adapter` for adapting [RxJava 1.x][1] types.
 
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
 
 Download
 --------
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index 249156122..9046f2d28 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
index 1ae1499eb..2bedc367e 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyOnSubscribe.java
@@ -30,7 +30,7 @@
   }
 
   @Override public void call(Subscriber<? super T> subscriber) {
-    upstream.call(new BodySubscriber<>(subscriber));
+    upstream.call(new BodySubscriber<T>(subscriber));
   }
 
   private static class BodySubscriber<R> extends Subscriber<Response<R>> {
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
new file mode 100644
index 000000000..34b0b004a
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallArbiter.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.plugins.RxJavaPlugins;
+
+final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
+  private static final int STATE_WAITING = 0;
+  private static final int STATE_REQUESTED = 1;
+  private static final int STATE_HAS_RESPONSE = 2;
+  private static final int STATE_TERMINATED = 3;
+
+  private final Call<T> call;
+  private final Subscriber<? super Response<T>> subscriber;
+
+  private volatile Response<T> response;
+
+  CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
+    super(STATE_WAITING);
+
+    this.call = call;
+    this.subscriber = subscriber;
+  }
+
+  @Override public void unsubscribe() {
+    call.cancel();
+  }
+
+  @Override public boolean isUnsubscribed() {
+    return call.isCanceled();
+  }
+
+  @Override public void request(long amount) {
+    if (amount == 0) {
+      return;
+    }
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+          if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+        case STATE_TERMINATED:
+          return; // Nothing to do.
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  void emitResponse(Response<T> response) {
+    while (true) {
+      int state = get();
+      switch (state) {
+        case STATE_WAITING:
+          this.response = response;
+          if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_REQUESTED:
+          if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
+            deliverResponse(response);
+            return;
+          }
+          break; // State transition failed. Try again.
+
+        case STATE_HAS_RESPONSE:
+        case STATE_TERMINATED:
+          throw new AssertionError();
+
+        default:
+          throw new IllegalStateException("Unknown state: " + state);
+      }
+    }
+  }
+
+  private void deliverResponse(Response<T> response) {
+    try {
+      if (!isUnsubscribed()) {
+        subscriber.onNext(response);
+      }
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      try {
+        subscriber.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+      return;
+    }
+    try {
+      subscriber.onCompleted();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+    }
+  }
+
+  void emitError(Throwable t) {
+    set(STATE_TERMINATED);
+
+    if (!isUnsubscribed()) {
+      try {
+        subscriber.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        CompositeException composite = new CompositeException(t, inner);
+        RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
+      }
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
new file mode 100644
index 000000000..7dcf917c3
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallEnqueueOnSubscribe.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallEnqueueOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    final CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    call.enqueue(new Callback<T>() {
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        arbiter.emitResponse(response);
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        Exceptions.throwIfFatal(t);
+        arbiter.emitError(t);
+      }
+    });
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
new file mode 100644
index 000000000..593770aa7
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallExecuteOnSubscribe.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import retrofit2.Call;
+import retrofit2.Response;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+
+final class CallExecuteOnSubscribe<T> implements OnSubscribe<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteOnSubscribe(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override public void call(Subscriber<? super Response<T>> subscriber) {
+    // Since Call is a one-shot type, clone it for each new subscriber.
+    Call<T> call = originalCall.clone();
+    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
+    subscriber.add(arbiter);
+    subscriber.setProducer(arbiter);
+
+    Response<T> response;
+    try {
+      response = call.execute();
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      arbiter.emitError(t);
+      return;
+    }
+    arbiter.emitResponse(response);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
deleted file mode 100644
index 7e0f53969..000000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/CallOnSubscribe.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava;
-
-import java.util.concurrent.atomic.AtomicInteger;
-import retrofit2.Call;
-import retrofit2.Response;
-import rx.Observable.OnSubscribe;
-import rx.Producer;
-import rx.Subscriber;
-import rx.Subscription;
-import rx.exceptions.CompositeException;
-import rx.exceptions.Exceptions;
-import rx.plugins.RxJavaPlugins;
-
-final class CallOnSubscribe<T> implements OnSubscribe<Response<T>> {
-  private final Call<T> originalCall;
-
-  CallOnSubscribe(Call<T> originalCall) {
-    this.originalCall = originalCall;
-  }
-
-  @Override public void call(Subscriber<? super Response<T>> subscriber) {
-    // Since Call is a one-shot type, clone it for each new subscriber.
-    Call<T> call = originalCall.clone();
-    CallArbiter<T> arbiter = new CallArbiter<>(call, subscriber);
-    subscriber.add(arbiter);
-    subscriber.setProducer(arbiter);
-
-    Response<T> response;
-    try {
-      response = call.execute();
-    } catch (Throwable t) {
-      Exceptions.throwIfFatal(t);
-      arbiter.emitError(t);
-      return;
-    }
-    arbiter.emitResponse(response);
-  }
-
-  static final class CallArbiter<T> extends AtomicInteger implements Subscription, Producer {
-    private static final int STATE_WAITING = 0;
-    private static final int STATE_REQUESTED = 1;
-    private static final int STATE_HAS_RESPONSE = 2;
-    private static final int STATE_TERMINATED = 3;
-
-    private final Call<T> call;
-    private final Subscriber<? super Response<T>> subscriber;
-
-    private volatile Response<T> response;
-
-    CallArbiter(Call<T> call, Subscriber<? super Response<T>> subscriber) {
-      super(STATE_WAITING);
-
-      this.call = call;
-      this.subscriber = subscriber;
-    }
-
-    @Override public void unsubscribe() {
-      call.cancel();
-    }
-
-    @Override public boolean isUnsubscribed() {
-      return call.isCanceled();
-    }
-
-    @Override public void request(long amount) {
-      if (amount == 0) {
-        return;
-      }
-      while (true) {
-        int state = get();
-        switch (state) {
-          case STATE_WAITING:
-            if (compareAndSet(STATE_WAITING, STATE_REQUESTED)) {
-              return;
-            }
-            break; // State transition failed. Try again.
-
-          case STATE_HAS_RESPONSE:
-            if (compareAndSet(STATE_HAS_RESPONSE, STATE_TERMINATED)) {
-              deliverResponse(response);
-              return;
-            }
-            break; // State transition failed. Try again.
-
-          case STATE_REQUESTED:
-          case STATE_TERMINATED:
-            return; // Nothing to do.
-
-          default:
-            throw new IllegalStateException("Unknown state: " + state);
-        }
-      }
-    }
-
-    void emitResponse(Response<T> response) {
-      while (true) {
-        int state = get();
-        switch (state) {
-          case STATE_WAITING:
-            this.response = response;
-            if (compareAndSet(STATE_WAITING, STATE_HAS_RESPONSE)) {
-              return;
-            }
-            break; // State transition failed. Try again.
-
-          case STATE_REQUESTED:
-            if (compareAndSet(STATE_REQUESTED, STATE_TERMINATED)) {
-              deliverResponse(response);
-              return;
-            }
-            break; // State transition failed. Try again.
-
-          case STATE_HAS_RESPONSE:
-          case STATE_TERMINATED:
-            throw new AssertionError();
-
-          default:
-            throw new IllegalStateException("Unknown state: " + state);
-        }
-      }
-    }
-
-    private void deliverResponse(Response<T> response) {
-      try {
-        if (!isUnsubscribed()) {
-          subscriber.onNext(response);
-        }
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        try {
-          subscriber.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          CompositeException composite = new CompositeException(t, inner);
-          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
-        }
-        return;
-      }
-      try {
-        subscriber.onCompleted();
-      } catch (Throwable t) {
-        Exceptions.throwIfFatal(t);
-        RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
-      }
-    }
-
-    void emitError(Throwable t) {
-      set(STATE_TERMINATED);
-
-      if (!isUnsubscribed()) {
-        try {
-          subscriber.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          CompositeException composite = new CompositeException(t, inner);
-          RxJavaPlugins.getInstance().getErrorHandler().handleError(composite);
-        }
-      }
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index 2e501e121..c81ad938e 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -2,38 +2,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private static String getMessage(Response<?> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return "HTTP " + response.code() + " " + response.message();
-  }
-
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super(getMessage(response));
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index 8d8f3776a..f14c47181 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -26,15 +26,17 @@
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
   private final Scheduler scheduler;
+  private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isSingle;
   private final boolean isCompletable;
 
-  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
-      boolean isSingle, boolean isCompletable) {
+  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
+      boolean isBody, boolean isSingle, boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
     this.isResult = isResult;
     this.isBody = isBody;
     this.isSingle = isSingle;
@@ -46,7 +48,9 @@
   }
 
   @Override public Object adapt(Call<R> call) {
-    OnSubscribe<Response<R>> callFunc = new CallOnSubscribe<>(call);
+    OnSubscribe<Response<R>> callFunc = isAsync
+        ? new CallEnqueueOnSubscribe<>(call)
+        : new CallExecuteOnSubscribe<>(call);
 
     OnSubscribe<?> func;
     if (isResult) {
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 283451679..ee297ad30 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import retrofit2.CallAdapter;
+import retrofit2.HttpException;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import rx.Completable;
@@ -61,7 +62,15 @@
    * by default.
    */
   public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory(null);
+    return new RxJavaCallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJavaCallAdapterFactory createAsync() {
+    return new RxJavaCallAdapterFactory(null, true);
   }
 
   /**
@@ -70,13 +79,15 @@ public static RxJavaCallAdapterFactory create() {
    */
   public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJavaCallAdapterFactory(scheduler);
+    return new RxJavaCallAdapterFactory(scheduler, false);
   }
 
   private final Scheduler scheduler;
+  private final boolean isAsync;
 
-  private RxJavaCallAdapterFactory(Scheduler scheduler) {
+  private RxJavaCallAdapterFactory(Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
   }
 
   @Override
@@ -89,7 +100,7 @@ private RxJavaCallAdapterFactory(Scheduler scheduler) {
     }
 
     if (isCompletable) {
-      return new RxJavaCallAdapter(Void.class, scheduler, false, true, false, true);
+      return new RxJavaCallAdapter(Void.class, scheduler, isAsync, false, true, false, true);
     }
 
     boolean isResult = false;
@@ -121,6 +132,7 @@ private RxJavaCallAdapterFactory(Scheduler scheduler) {
       isBody = true;
     }
 
-    return new RxJavaCallAdapter(responseType, scheduler, isResult, isBody, isSingle, false);
+    return new RxJavaCallAdapter(responseType, scheduler, isAsync, isResult, isBody, isSingle,
+        false);
   }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
new file mode 100644
index 000000000..2c2703769
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/AsyncTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+import rx.Completable;
+import rx.exceptions.CompositeException;
+import rx.exceptions.Exceptions;
+import rx.observers.AsyncCompletableSubscriber;
+import rx.observers.TestSubscriber;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertCompleted();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    service.completable().subscribe(subscriber);
+    assertFalse(subscriber.awaitValueCount(1, 1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    subscriber.awaitTerminalEvent(1, SECONDS);
+    subscriber.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        throw e;
+      }
+
+      @Override public void onError(Throwable t) {
+        subscriber.onError(t);
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+      @Override public void handleError(Throwable throwable) {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    final TestSubscriber<Void> subscriber = new TestSubscriber<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().unsafeSubscribe(new AsyncCompletableSubscriber() {
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable t) {
+        errorRef.set(t);
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index b10ab34af..3d84b39f2 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -60,6 +60,7 @@
 
     RecordingSubscriber<Void> subscriber = subscriberRule.create();
     service.completable().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
     subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 53dcc0770..4a8d8652f 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -65,6 +65,7 @@
 
     RecordingSubscriber<String> subscriber = subscriberRule.create();
     service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
     subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index c4c35ab45..babd05c73 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -65,6 +65,7 @@
 
     RecordingSubscriber<String> subscriber = subscriberRule.create();
     service.body().unsafeSubscribe(subscriber);
+    // Required for backwards compatibility.
     subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava2/README.md b/retrofit-adapters/rxjava2/README.md
index 1c5ca742d..67564e490 100644
--- a/retrofit-adapters/rxjava2/README.md
+++ b/retrofit-adapters/rxjava2/README.md
@@ -3,6 +3,13 @@ RxJava2 Adapter
 
 An `Adapter` for adapting [RxJava 2.x][1] types.
 
+Available types:
+
+ * `Observable<T>`, `Observable<Response<T>>`, and `Observable<Result<T>>` where `T` is the body type.
+ * `Flowable<T>`, `Flowable<Response<T>>` and `Flowable<Result<T>>` where `T` is the body type.
+ * `Single<T>`, `Single<Response<T>>`, and `Single<Result<T>>`  where `T` is the body type.
+ * `Maybe<T>`, `Maybe<Response<T>>`, and `Maybe<Result<T>>`  where `T` is the body type.
+ * `Completable` where response bodies are discarded.
 
 Download
 --------
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
index 354834586..1bc459ded 100644
--- a/retrofit-adapters/rxjava2/pom.xml
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
index 2f1a234d7..c3f475604 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
@@ -31,7 +31,7 @@
   }
 
   @Override protected void subscribeActual(Observer<? super T> observer) {
-    upstream.subscribe(new BodyObserver<>(observer));
+    upstream.subscribe(new BodyObserver<T>(observer));
   }
 
   private static class BodyObserver<R> implements Observer<Response<R>> {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
new file mode 100644
index 000000000..aa5ca67a8
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+final class CallEnqueueObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    CallCallback<T> callback = new CallCallback<>(call, observer);
+    observer.onSubscribe(callback);
+    call.enqueue(callback);
+  }
+
+  private static final class CallCallback<T> implements Disposable, Callback<T> {
+    private final Call<?> call;
+    private final Observer<? super Response<T>> observer;
+    boolean terminated = false;
+
+    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
+      this.call = call;
+      this.observer = observer;
+    }
+
+    @Override public void onResponse(Call<T> call, Response<T> response) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onNext(response);
+
+        if (!call.isCanceled()) {
+          terminated = true;
+          observer.onComplete();
+        }
+      } catch (Throwable t) {
+        if (terminated) {
+          RxJavaPlugins.onError(t);
+        } else if (!call.isCanceled()) {
+          try {
+            observer.onError(t);
+          } catch (Throwable inner) {
+            Exceptions.throwIfFatal(inner);
+            RxJavaPlugins.onError(new CompositeException(t, inner));
+          }
+        }
+      }
+    }
+
+    @Override public void onFailure(Call<T> call, Throwable t) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        RxJavaPlugins.onError(new CompositeException(t, inner));
+      }
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
similarity index 94%
rename from retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
rename to retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
index d7a4f7197..bf9453368 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -24,10 +24,10 @@
 import retrofit2.Call;
 import retrofit2.Response;
 
-final class CallObservable<T> extends Observable<Response<T>> {
+final class CallExecuteObservable<T> extends Observable<Response<T>> {
   private final Call<T> originalCall;
 
-  CallObservable(Call<T> originalCall) {
+  CallExecuteObservable(Call<T> originalCall) {
     this.originalCall = originalCall;
   }
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
index d612b9d5a..6e282e583 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
@@ -17,38 +17,10 @@
 
 import retrofit2.Response;
 
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private static String getMessage(Response<?> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return "HTTP " + response.code() + " " + response.message();
-  }
-
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
+/** @deprecated Use {@link retrofit2.HttpException}. */
+@Deprecated
+public final class HttpException extends retrofit2.HttpException {
   public HttpException(Response<?> response) {
-    super(getMessage(response));
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
+    super(response);
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index e6b7861cb..a585e3113 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -26,6 +26,7 @@
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
   private final Scheduler scheduler;
+  private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isFlowable;
@@ -33,10 +34,12 @@
   private final boolean isMaybe;
   private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
-      boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
+  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
+      boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+      boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
     this.isResult = isResult;
     this.isBody = isBody;
     this.isFlowable = isFlowable;
@@ -50,7 +53,9 @@
   }
 
   @Override public Object adapt(Call<R> call) {
-    Observable<Response<R>> responseObservable = new CallObservable<>(call);
+    Observable<Response<R>> responseObservable = isAsync
+        ? new CallEnqueueObservable<>(call)
+        : new CallExecuteObservable<>(call);
 
     Observable<?> observable;
     if (isResult) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 1f1b056dd..e4b685999 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -26,6 +26,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import retrofit2.CallAdapter;
+import retrofit2.HttpException;
 import retrofit2.Response;
 import retrofit2.Retrofit;
 
@@ -59,7 +60,15 @@
    * by default.
    */
   public static RxJava2CallAdapterFactory create() {
-    return new RxJava2CallAdapterFactory(null);
+    return new RxJava2CallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJava2CallAdapterFactory createAsync() {
+    return new RxJava2CallAdapterFactory(null, true);
   }
 
   /**
@@ -68,13 +77,15 @@ public static RxJava2CallAdapterFactory create() {
    */
   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJava2CallAdapterFactory(scheduler);
+    return new RxJava2CallAdapterFactory(scheduler, false);
   }
 
   private final Scheduler scheduler;
+  private final boolean isAsync;
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler) {
+  private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
   }
 
   @Override
@@ -84,7 +95,8 @@ private RxJava2CallAdapterFactory(Scheduler scheduler) {
     if (rawType == Completable.class) {
       // Completable is not parameterized (which is what the rest of this method deals with) so it
       // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
+      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
+          false, true);
     }
 
     boolean isFlowable = rawType == Flowable.class;
@@ -98,7 +110,9 @@ private RxJava2CallAdapterFactory(Scheduler scheduler) {
     boolean isBody = false;
     Type responseType;
     if (!(returnType instanceof ParameterizedType)) {
-      String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
+      String name = isFlowable ? "Flowable"
+          : isSingle ? "Single"
+          : isMaybe ? "Maybe" : "Observable";
       throw new IllegalStateException(name + " return type must be parameterized"
           + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
@@ -123,7 +137,7 @@ private RxJava2CallAdapterFactory(Scheduler scheduler) {
       isBody = true;
     }
 
-    return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
+    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
         isSingle, isMaybe, false);
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
new file mode 100644
index 000000000..d008a5e70
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Completable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Consumer;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava2.CompletableThrowingTest.ForwardingCompletableObserver;
+import retrofit2.http.GET;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertFalse;
+
+public final class AsyncTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Completable completable();
+  }
+
+  private Service service;
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void success() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse());
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertComplete();
+  }
+
+
+  @Test public void failure() throws InterruptedException {
+    TestObserver<Void> observer = new TestObserver<>();
+    service.completable().subscribe(observer);
+    assertFalse(observer.await(1, SECONDS));
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    observer.awaitTerminalEvent(1, SECONDS);
+    observer.assertError(IOException.class);
+  }
+
+  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!errorRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onComplete() {
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    assertThat(errorRef.get()).isSameAs(e);
+  }
+
+  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+      @Override public void accept(Throwable throwable) throws Exception {
+        if (!pluginRef.compareAndSet(null, throwable)) {
+          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+        }
+        latch.countDown();
+      }
+    });
+
+    TestObserver<Void> observer = new TestObserver<>();
+    final RuntimeException e = new RuntimeException();
+    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+      @Override public void onError(Throwable throwable) {
+        errorRef.set(throwable);
+        throw e;
+      }
+    });
+
+    latch.await(1, SECONDS);
+    //noinspection ThrowableResultOfMethodCallIgnored
+    CompositeException composite = (CompositeException) pluginRef.get();
+    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
index 64fb3870a..999cf31bd 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -59,6 +59,7 @@
 
     RecordingCompletableObserver observer = observerRule.create();
     service.completable().subscribe(observer);
+    // Required for backwards compatibility.
     observer.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
index 535fdeeed..6c558b029 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -104,7 +104,7 @@
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
 
-  private static abstract class ForwardingCompletableObserver implements CompletableObserver {
+  static abstract class ForwardingCompletableObserver implements CompletableObserver {
     private final CompletableObserver delegate;
 
     ForwardingCompletableObserver(CompletableObserver delegate) {
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
index 042b8028d..22efcee2b 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -63,6 +63,7 @@
 
     RecordingSubscriber<String> subscriber = subscriberRule.create();
     service.body().subscribe(subscriber);
+    // Required for backwards compatibility.
     subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
deleted file mode 100644
index da781ffd0..000000000
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava2;
-
-import org.junit.Test;
-import retrofit2.Response;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class HttpExceptionTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    HttpException exception = new HttpException(response);
-    assertThat(exception.code()).isEqualTo(200);
-    assertThat(exception.message()).isEqualTo("OK");
-    assertThat(exception.response()).isSameAs(response);
-  }
-
-  @Test public void nullResponseThrows() {
-    try {
-      new HttpException(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
index d5eda7d9e..21f69c68a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -64,6 +64,7 @@
 
     RecordingMaybeObserver<String> observer = observerRule.create();
     service.body().subscribe(observer);
+    // Required for backwards compatibility.
     observer.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index be8f5c31a..e421c1652 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -63,6 +63,7 @@
 
     RecordingObserver<String> observer = observerRule.create();
     service.body().subscribe(observer);
+    // Required for backwards compatibility.
     observer.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
new file mode 100644
index 000000000..589716125
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit2.adapter.rxjava2;
+
+import com.google.common.reflect.TypeToken;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Completable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class RxJava2CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJava2CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJava2CallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Maybe return type must be parameterized as Maybe<Foo> or Maybe<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Flowable return type must be parameterized as Flowable<Foo> or Flowable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Response>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Response>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Result>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Result>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
index 9ebe67e94..dba2dd62a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -63,6 +63,7 @@
 
     RecordingSingleObserver<String> observer = observerRule.create();
     service.body().subscribe(observer);
+    // Required for backwards compatibility.
     observer.assertError(HttpException.class, "HTTP 404 Client Error");
   }
 
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 31f5c1983..b8347a96b 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index e6afa44ee..b22877e60 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 76cd1aaed..11ab6a2f4 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -23,12 +23,6 @@
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
     </dependency>
-    <!-- TODO remove this dependency once Moshi ships with 1.9.0 or newer. -->
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-      <version>1.9.0</version>
-    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index 60e5f1bfd..311d76d0d 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -51,27 +51,37 @@ public static MoshiConverterFactory create() {
   /** Create an instance using {@code moshi} for conversion. */
   public static MoshiConverterFactory create(Moshi moshi) {
     if (moshi == null) throw new NullPointerException("moshi == null");
-    return new MoshiConverterFactory(moshi, false, false);
+    return new MoshiConverterFactory(moshi, false, false, false);
   }
 
   private final Moshi moshi;
   private final boolean lenient;
+  private final boolean failOnUnknown;
   private final boolean serializeNulls;
 
-  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean serializeNulls) {
+  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean failOnUnknown,
+      boolean serializeNulls) {
     this.moshi = moshi;
     this.lenient = lenient;
+    this.failOnUnknown = failOnUnknown;
     this.serializeNulls = serializeNulls;
   }
 
   /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
   public MoshiConverterFactory asLenient() {
-    return new MoshiConverterFactory(moshi, true, serializeNulls);
+    return new MoshiConverterFactory(moshi, true, failOnUnknown, serializeNulls);
+  }
+
+  /**
+   * Return a new factory which uses {@link JsonAdapter#failOnUnknown()} adapters.
+   */
+  public MoshiConverterFactory failOnUnknown() {
+    return new MoshiConverterFactory(moshi, lenient, true, serializeNulls);
   }
 
   /** Return a new factory which includes null values into the serialized JSON. */
   public MoshiConverterFactory withNullSerialization() {
-    return new MoshiConverterFactory(moshi, lenient, true);
+    return new MoshiConverterFactory(moshi, lenient, failOnUnknown, true);
   }
 
   @Override
@@ -81,17 +91,28 @@ public MoshiConverterFactory withNullSerialization() {
     if (lenient) {
       adapter = adapter.lenient();
     }
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
     return new MoshiResponseBodyConverter<>(adapter);
   }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
+  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
       Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
     JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
     if (lenient) {
       adapter = adapter.lenient();
     }
-    return new MoshiRequestBodyConverter<>(adapter, serializeNulls);
+    if (failOnUnknown) {
+      adapter = adapter.failOnUnknown();
+    }
+    if (serializeNulls) {
+      adapter = adapter.serializeNulls();
+    }
+    return new MoshiRequestBodyConverter<>(adapter);
   }
 
   private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index 5e59b17fe..edbcf243e 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -27,17 +27,14 @@
   private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final JsonAdapter<T> adapter;
-  private final boolean serializeNulls;
 
-  MoshiRequestBodyConverter(JsonAdapter<T> adapter, boolean serializeNulls) {
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
     this.adapter = adapter;
-    this.serializeNulls = serializeNulls;
   }
 
   @Override public RequestBody convert(T value) throws IOException {
     Buffer buffer = new Buffer();
     JsonWriter writer = JsonWriter.of(buffer);
-    writer.setSerializeNulls(serializeNulls);
     adapter.toJson(writer, value);
     return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
   }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index d22c37267..14b00dafd 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.moshi.FromJson;
 import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.JsonDataException;
 import com.squareup.moshi.JsonQualifier;
 import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
@@ -120,6 +121,7 @@
   private Service service;
   private Service serviceLenient;
   private Service serviceNulls;
+  private Service serviceFailOnUnknown;
 
   @Before public void setUp() {
     Moshi moshi = new Moshi.Builder()
@@ -139,6 +141,7 @@
     MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
     MoshiConverterFactory factoryLenient = factory.asLenient();
     MoshiConverterFactory factoryNulls = factory.withNullSerialization();
+    MoshiConverterFactory factoryFailOnUnknown = factory.failOnUnknown();
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(factory)
@@ -151,9 +154,14 @@
         .baseUrl(server.url("/"))
         .addConverterFactory(factoryNulls)
         .build();
+    Retrofit retrofitFailOnUnknown = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(factoryFailOnUnknown)
+        .build();
     service = retrofit.create(Service.class);
     serviceLenient = retrofitLenient.create(Service.class);
     serviceNulls = retrofitNulls.create(Service.class);
+    serviceFailOnUnknown = retrofitFailOnUnknown.create(Service.class);
   }
 
   @Test public void anInterface() throws IOException, InterruptedException {
@@ -222,6 +230,18 @@
     assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
   }
 
+  @Test public void failOnUnknown() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"taco\":\"delicious\"}"));
+
+    Call<AnImplementation> call = serviceFailOnUnknown.anImplementation(new AnImplementation(null));
+    try {
+      call.execute();
+      fail();
+    } catch (JsonDataException e) {
+      assertThat(e).hasMessage("Cannot skip unexpected STRING at $.taco");
+    }
+  }
+
   @Test public void utf8BomSkipped() throws IOException {
     Buffer responseBody = new Buffer()
         .write(ByteString.decodeHex("EFBBBF"))
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 3fbbbf17b..4c49a4a88 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 761238f28..55f42504e 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index 52ce81b6a..70d15a493 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index d23c79a59..b7f03efcf 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 497eb41aa..9c36850ac 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 9d741819b..2e6079447 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..8ec2b7073 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -79,6 +79,11 @@ boolean delaySleep() {
           if (delaySleep()) {
             callback.onFailure(BehaviorCall.this, behavior.failureException());
           }
+        } else if (behavior.calculateIsError()) {
+          if (delaySleep()) {
+            //noinspection unchecked An error response has no body.
+            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());
+          }
         } else {
           delegate.enqueue(new Callback<T>() {
             @Override public void onResponse(Call<T> call, Response<T> response) {
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..4a4721e6a 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,6 +16,8 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -23,75 +25,146 @@
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
+  /**
+   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is
+   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}.
+   */
+  public static <T> Call<T> defer(Callable<Call<T>> callable) {
+    return new DeferredCall<>(callable);
+  }
+
   public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
+    return new FakeCall<>(Response.success(successValue), null);
+  }
+
+  public static <T> Call<T> response(Response<T> response) {
+    return new FakeCall<>(response, null);
   }
 
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
+  public static <T> Call<T> failure(IOException failure) {
+    return new FakeCall<>(null, failure);
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+
+  static final class FakeCall<T> implements Call<T> {
+    private final Response<T> response;
+    private final IOException error;
+    private final AtomicBoolean canceled = new AtomicBoolean();
+    private final AtomicBoolean executed = new AtomicBoolean();
+
+    FakeCall(Response<T> response, IOException error) {
+      if ((response == null) == (error == null)) {
+        throw new AssertionError("Only one of response or error can be set.");
+      }
+      this.response = response;
+      this.error = error;
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        throw new IOException("canceled");
+      }
+      if (response != null) {
         return response;
       }
+      throw error;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
+    @Override public void enqueue(Callback<T> callback) {
+      if (callback == null) {
+        throw new NullPointerException("callback == null");
+      }
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        callback.onFailure(this, new IOException("canceled"));
+      } else if (response != null) {
         callback.onResponse(this, response);
+      } else {
+        callback.onFailure(this, error);
       }
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public boolean isExecuted() {
+      return executed.get();
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public void cancel() {
+      canceled.set(true);
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public boolean isCanceled() {
+      return canceled.get();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public Call<T> clone() {
+      return new FakeCall<>(response, error);
+    }
 
-      @Override public Request request() {
+    @Override public Request request() {
+      if (response != null) {
         return response.raw().request();
       }
-    };
+      return new Request.Builder().url("http://localhost").build();
+    }
   }
 
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
+  static final class DeferredCall<T> implements Call<T> {
+    private final Callable<Call<T>> callable;
+    private Call<T> delegate;
+
+    DeferredCall(Callable<Call<T>> callable) {
+      this.callable = callable;
+    }
+
+    private synchronized Call<T> getDelegate() {
+      Call<T> delegate = this.delegate;
+      if (delegate == null) {
+        try {
+          delegate = callable.call();
+        } catch (IOException e) {
+          delegate = failure(e);
+        } catch (Exception e) {
+          throw new IllegalStateException("Callable threw unrecoverable exception", e);
+        }
+        this.delegate = delegate;
       }
+      return delegate;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
+    @Override public Response<T> execute() throws IOException {
+      return getDelegate().execute();
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public void enqueue(Callback<T> callback) {
+      getDelegate().enqueue(callback);
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public boolean isExecuted() {
+      return getDelegate().isExecuted();
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public void cancel() {
+      getDelegate().cancel();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public boolean isCanceled() {
+      return getDelegate().isCanceled();
+    }
 
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
+    @Override public Call<T> clone() {
+      return new DeferredCall<>(callable);
+    }
 
-  private Calls() {
-    throw new AssertionError("No instances.");
+    @Override public Request request() {
+      return getDelegate().request();
+    }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 8108c1d63..5636e9dd5 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -17,7 +17,10 @@
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+import okhttp3.ResponseBody;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -40,15 +43,7 @@
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by 40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
-
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
-    /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
-     */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
+  private static final int DEFAULT_ERROR_PERCENT = 0; // 0% of network calls will return errors.
 
   /** Create an instance with default behavior. */
   public static NetworkBehavior create() {
@@ -70,6 +65,12 @@ public static NetworkBehavior create(Random random) {
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
   private volatile Throwable failureException;
+  private volatile int errorPercent = DEFAULT_ERROR_PERCENT;
+  private volatile Callable<Response<?>> errorFactory = new Callable<Response<?>>() {
+    @Override public Response<?> call() {
+      return Response.error(500, ResponseBody.create(null, new byte[0]));
+    }
+  };
 
   private NetworkBehavior(Random random) {
     this.random = random;
@@ -93,9 +94,7 @@ public long delay(TimeUnit unit) {
 
   /** Set the plus-or-minus variance percentage of the network round trip delay. */
   public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(variancePercent, "Variance percentage must be between 0 and 100.");
     this.variancePercent = variancePercent;
   }
 
@@ -106,9 +105,7 @@ public int variancePercent() {
 
   /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
   public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
-    }
+    checkPercentageValidity(failurePercent, "Failure percentage must be between 0 and 100.");
     this.failurePercent = failurePercent;
   }
 
@@ -120,14 +117,14 @@ public int failurePercent() {
   /**
    * Set the exception to be used when a failure is triggered.
    * <p>
-   * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
-   * point to code unrelated to this class.
+   * It is a best practice to remove the stack trace from {@code exception} since it can
+   * misleadingly point to code unrelated to this class.
    */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+  public void setFailureException(Throwable exception) {
+    if (exception == null) {
+      throw new NullPointerException("exception == null");
     }
-    this.failureException = t;
+    this.failureException = exception;
   }
 
   /** The exception to be used when a failure is triggered. */
@@ -135,13 +132,59 @@ public Throwable failureException() {
     return failureException;
   }
 
+  /** The percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public int errorPercent() {
+    return errorPercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public void setErrorPercent(int errorPercent) {
+    checkPercentageValidity(errorPercent, "Error percentage must be between 0 and 100.");
+    this.errorPercent = errorPercent;
+  }
+
+  /**
+   * Set the error response factory to be used when an error is triggered. This factory may only
+   * return responses for which {@link Response#isSuccessful()} returns false.
+   */
+  public void setErrorFactory(Callable<Response<?>> errorFactory) {
+    if (errorFactory == null) {
+      throw new NullPointerException("errorFactory == null");
+    }
+    this.errorFactory = errorFactory;
+  }
+
+  /** The HTTP error to be used when an error is triggered. */
+  public Response<?> createErrorResponse() {
+    Response<?> call;
+    try {
+      call = errorFactory.call();
+    } catch (Exception e) {
+      throw new IllegalStateException("Error factory threw an exception.", e);
+    }
+    if (call == null) {
+      throw new IllegalStateException("Error factory returned null.");
+    }
+    if (call.isSuccessful()) {
+      throw new IllegalStateException("Error factory returned successful response.");
+    }
+    return call;
+  }
+
   /**
    * Randomly determine whether this call should result in a network failure in accordance with
    * configured behavior. When true, {@link #failureException()} should be thrown.
    */
   public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
+    return random.nextInt(100) < failurePercent;
+  }
+
+  /**
+   * Randomly determine whether this call should result in an HTTP error in accordance with
+   * configured behavior. When true, {@link #createErrorResponse()} should be returned.
+   */
+  public boolean calculateIsError() {
+    return random.nextInt(100) < errorPercent;
   }
 
   /**
@@ -157,4 +200,10 @@ public long calculateDelay(TimeUnit unit) {
     long callDelayMs = (long) (delayMs * delayPercent);
     return MILLISECONDS.convert(callDelayMs, unit);
   }
+
+  private static void checkPercentageValidity(int percentage, String message) {
+    if (percentage < 0 || percentage > 100) {
+      throw new IllegalArgumentException(message);
+    }
+  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
new file mode 100644
index 000000000..f32f4c4ee
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallsTest {
+  @Test public void bodyExecute() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+  }
+
+  @Test public void bodyEnqueue() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertThat(responseRef.get().body()).isEqualTo("Taco");
+  }
+
+  @Test public void responseExecute() throws IOException {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+    assertSame(response, taco.execute());
+    assertTrue(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void responseEnqueue() {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertSame(response, responseRef.get());
+    assertTrue(taco.isExecuted());
+
+    try {
+      taco.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+          fail();
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          fail();
+        }
+      });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void enqueueNullThrows() {
+    Call<String> taco = Calls.response("Taco");
+    try {
+      taco.enqueue(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callback == null");
+    }
+  }
+
+  @Test public void responseCancelExecute() {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void responseCancelEnqueue() throws IOException {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("canceled");
+  }
+
+  @Test public void failureExecute() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void failureEnqueue() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void cloneHasOwnState() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+    Call<String> anotherTaco = taco.clone();
+    assertFalse(anotherTaco.isExecuted());
+    assertEquals("Taco", anotherTaco.execute().body());
+    assertTrue(anotherTaco.isExecuted());
+  }
+
+  @Test public void deferredReturnExecute() throws IOException {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    assertEquals(1, b.execute().body().intValue());
+    assertEquals(2, a.execute().body().intValue());
+  }
+
+  @Test public void deferredReturnEnqueue() {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    final AtomicReference<Response<Integer>> responseRef = new AtomicReference<>();
+    Callback<Integer> callback = new Callback<Integer>() {
+      @Override public void onResponse(Call<Integer> call, Response<Integer> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<Integer> call, Throwable t) {
+        fail();
+      }
+    };
+    b.enqueue(callback);
+    assertEquals(1, responseRef.get().body().intValue());
+
+    a.enqueue(callback);
+    assertEquals(2, responseRef.get().body().intValue());
+  }
+
+  @Test public void deferredThrowExecute() throws IOException {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    try {
+      failing.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+  }
+
+  @Test public void deferredThrowEnqueue() {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    failing.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 180737826..300d57135 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -17,11 +17,15 @@
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
+import okhttp3.ResponseBody;
 import org.junit.Test;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
@@ -72,6 +76,97 @@
     }
   }
 
+  @Test public void failureExceptionIsNotNull() {
+    try {
+      behavior.setFailureException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("exception == null");
+    }
+  }
+
+  @Test public void errorRestrictsRange() {
+    try {
+      behavior.setErrorPercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setErrorPercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorFactoryIsNotNull() {
+    try {
+      behavior.setErrorFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("errorFactory == null");
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnNull() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return null;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned null.");
+    }
+  }
+
+  @Test public void errorFactoryCannotThrow() {
+    final RuntimeException broken = new RuntimeException("Broken");
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        throw broken;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory threw an exception.");
+      assertThat(e.getCause()).isSameAs(broken);
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnSuccess() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return Response.success("Taco");
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned successful response.");
+    }
+  }
+
+  @Test public void errorFactoryCalledEachTime() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      private int code = 500;
+
+      @Override public Response<?> call() throws Exception {
+        return Response.error(code++, ResponseBody.create(null, new byte[0]));
+      }
+    });
+
+    assertEquals(500, behavior.createErrorResponse().code());
+    assertEquals(501, behavior.createErrorResponse().code());
+    assertEquals(502, behavior.createErrorResponse().code());
+  }
+
   @Test public void failurePercentageIsAccurate() {
     behavior.setFailurePercent(0);
     for (int i = 0; i < 10000; i++) {
@@ -88,6 +183,22 @@
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
+  @Test public void errorPercentageIsAccurate() {
+    behavior.setErrorPercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsError()).isFalse();
+    }
+
+    behavior.setErrorPercent(3);
+    int errors = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsError()) {
+        errors += 1;
+      }
+    }
+    assertThat(errors).isEqualTo(2964); // ~3% of 100k
+  }
+
   @Test public void delayVarianceIsAccurate() {
     behavior.setDelay(2, SECONDS);
 
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 314c96636..f4e4a45b8 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index a633d60e8..f819c7863 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -21,6 +21,8 @@
 import java.util.concurrent.Executor;
 import okhttp3.Request;
 
+import static retrofit2.Utils.checkNotNull;
+
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
   final Executor callbackExecutor;
 
@@ -55,7 +57,7 @@
     }
 
     @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
+      checkNotNull(callback, "callback == null");
 
       delegate.enqueue(new Callback<T>() {
         @Override public void onResponse(Call<T> call, final Response<T> response) {
diff --git a/retrofit/src/main/java/retrofit2/HttpException.java b/retrofit/src/main/java/retrofit2/HttpException.java
new file mode 100644
index 000000000..c01f97dfe
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/HttpException.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import static retrofit2.Utils.checkNotNull;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public class HttpException extends RuntimeException {
+  private static String getMessage(Response<?> response) {
+    checkNotNull(response, "response == null");
+    return "HTTP " + response.code() + " " + response.message();
+  }
+
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super(getMessage(response));
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index ccbfe1ab2..14bc700b7 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -24,6 +24,8 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
+import static retrofit2.Utils.checkNotNull;
+
 final class OkHttpCall<T> implements Call<T> {
   private final ServiceMethod<T, ?> serviceMethod;
   private final Object[] args;
@@ -69,7 +71,7 @@
   }
 
   @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    checkNotNull(callback, "callback == null");
 
     okhttp3.Call call;
     Throwable failure;
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..f0aa001d1 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -110,6 +110,21 @@
     }
   }
 
+  static final class QueryName<T> extends ParameterHandler<T> {
+    private final Converter<T, String> nameConverter;
+    private final boolean encoded;
+
+    QueryName(Converter<T, String> nameConverter, boolean encoded) {
+      this.nameConverter = nameConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(nameConverter.convert(value), null, encoded);
+    }
+  }
+
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 3a25b6f53..d7661199f 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -26,6 +26,8 @@
 import okio.Buffer;
 import okio.BufferedSink;
 
+import static retrofit2.Utils.checkNotNull;
+
 final class RequestBuilder {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
@@ -69,7 +71,7 @@
   }
 
   void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+    checkNotNull(relativeUrl, "@Url parameter is null.");
     this.relativeUrl = relativeUrl.toString();
   }
 
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index a0efab014..684a6c067 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -20,6 +20,8 @@
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
+import static retrofit2.Utils.checkNotNull;
+
 /** An HTTP response. */
 public final class Response<T> {
   /** Create a synthetic successful response with {@code body} as the deserialized body. */
@@ -37,7 +39,7 @@
    * deserialized body.
    */
   public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
+    checkNotNull(headers, "headers == null");
     return success(body, new okhttp3.Response.Builder() //
         .code(200)
         .message("OK")
@@ -52,7 +54,7 @@
    * body.
    */
   public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    checkNotNull(rawResponse, "rawResponse == null");
     if (!rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse must be successful response");
     }
@@ -74,8 +76,8 @@
 
   /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
   public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+    checkNotNull(body, "body == null");
+    checkNotNull(rawResponse, "rawResponse == null");
     if (rawResponse.isSuccessful()) {
       throw new IllegalArgumentException("rawResponse should not be successful response");
     }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 8633de4af..a048b01c3 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -133,7 +133,7 @@
         new InvocationHandler() {
           private final Platform platform = Platform.get();
 
-          @Override public Object invoke(Object proxy, Method method, Object... args)
+          @Override public Object invoke(Object proxy, Method method, Object[] args)
               throws Throwable {
             // If the method is a method from Object then defer to normal invocation.
             if (method.getDeclaringClass() == Object.class) {
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 7765aba03..a32f8101a 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -53,6 +53,7 @@
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
@@ -429,6 +430,35 @@ private Headers parseHeaders(String[] headers) {
           return new ParameterHandler.Query<>(name, converter, encoded);
         }
 
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index cae93701e..9c5737516 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -37,7 +37,7 @@ private Utils() {
   }
 
   static Class<?> getRawType(Type type) {
-    if (type == null) throw new NullPointerException("type == null");
+    checkNotNull(type, "type == null");
 
     if (type instanceof Class<?>) {
       // Type is a normal class.
@@ -376,14 +376,14 @@ static Type getCallResponseType(Type returnType) {
         throw new IllegalArgumentException();
       }
 
+      for (Type typeArgument : typeArguments) {
+        checkNotNull(typeArgument, "typeArgument == null");
+        checkNotPrimitive(typeArgument);
+      }
+
       this.ownerType = ownerType;
       this.rawType = rawType;
       this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
     }
 
     @Override public Type[] getActualTypeArguments() {
@@ -407,9 +407,9 @@ static Type getCallResponseType(Type returnType) {
     }
 
     @Override public String toString() {
+      if (typeArguments.length == 0) return typeToString(rawType);
       StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
       result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
       result.append("<").append(typeToString(typeArguments[0]));
       for (int i = 1; i < typeArguments.length; i++) {
         result.append(", ").append(typeToString(typeArguments[i]));
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 01d294f3a..614795009 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -31,35 +31,36 @@
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("page") int page);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
  * </code></pre>
- * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
+ * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
  * <p>
  * Example with {@code null}:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("category") String category);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
  * </code></pre>
- * Calling with {@code foo.list(null)} yields {@code /list}.
+ * Calling with {@code foo.friends(null)} yields {@code /friends}.
  * <p>
  * Array/Varargs Example:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("category") String... categories);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
  * </code></pre>
- * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=bar&category=baz}.
+ * Calling with {@code foo.friends("coworker", "bowling")} yields
+ * {@code /friends?group=coworker&group=bowling}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@Query(value="foo", encoded=true) String foo);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
  * </code></pre>
- * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
  *
  * @see QueryMap
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 27e6ae836..119a59381 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -29,24 +29,25 @@
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@QueryMap Map&lt;String, String&gt; filters);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
- * {@code /search?foo=bar&kit=kat}.
+ * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
+ * {@code /friends?group=coworker&age=42}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
- * {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
+ * {@code /search?group=coworker+bowling}.
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
new file mode 100644
index 000000000..5d6f0e948
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/QueryName.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL that has no value.
+ * <p>
+ * Passing a {@link java.util.List List} or array will result in a query parameter for each
+ * non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
+ * {@code /friends?contains(Bob)&age(42)}.
+ * <p>
+ * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
+ * this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
+ *
+ * @see Query
+ * @see QueryMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryName {
+  /**
+   * Specifies whether the parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java b/retrofit/src/test/java/retrofit2/HttpExceptionTest.java
similarity index 95%
rename from retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
rename to retrofit/src/test/java/retrofit2/HttpExceptionTest.java
index 2e77f06c1..37fa3722c 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
+++ b/retrofit/src/test/java/retrofit2/HttpExceptionTest.java
@@ -13,10 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package retrofit2.adapter.rxjava;
+package retrofit2;
 
 import org.junit.Test;
-import retrofit2.Response;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 0f3b5ebe6..a2ef1376b 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -57,6 +57,7 @@
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -1059,11 +1060,11 @@
       }
     }
 
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
     Request request = buildRequest(Example.class, values);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
     assertThat(request.body()).isNull();
   }
 
@@ -1075,11 +1076,11 @@
       }
     }
 
-    Object[] values = { 1, 2, null, "three" };
+    Object[] values = { 1, 2, null, "three", "1" };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
     assertThat(request.body()).isNull();
   }
 
@@ -1091,11 +1092,98 @@
       }
     }
 
-    int[] values = { 1, 2, 3 };
+    int[] values = { 1, 2, 3, 1 };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3&key=1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pong");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithEncodedQueryNameParam() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?p%20o%20n%20g");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void queryNameParamOptionalOmitsQuery() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, new Object[] { null });
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+  }
+
+  @Test public void getWithQueryNameParamList() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName List<Object> keys) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
+    Request request = buildRequest(Example.class, values);
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName Object[] keys) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three", "1" };
+    Request request = buildRequest(Example.class, new Object[] { values });
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void getWithQueryNameParamPrimitiveArray() {
+    class Example {
+      @GET("/foo/bar/") //
+      Call<ResponseBody> method(@QueryName int[] keys) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3, 1 };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&3&1");
     assertThat(request.body()).isNull();
   }
 
diff --git a/samples/pom.xml b/samples/pom.xml
index 63123e082..84de4c276 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.retrofit2</groupId>
     <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -24,6 +24,11 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>converter-gson</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
new file mode 100644
index 000000000..0664d3482
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.gson.GsonBuilder;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.moshi.MoshiConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class AnnotatedConverters {
+  public static final class AnnotatedConverterFactory extends Converter.Factory {
+    private final Map<Class<? extends Annotation>, Converter.Factory> factories;
+
+    public static final class Builder {
+      private final Map<Class<? extends Annotation>, Converter.Factory> factories =
+          new LinkedHashMap<>();
+
+      public Builder add(Class<? extends Annotation> cls, Converter.Factory factory) {
+        if (cls == null) {
+          throw new NullPointerException("cls == null");
+        }
+        if (factory == null) {
+          throw new NullPointerException("factory == null");
+        }
+        factories.put(cls, factory);
+        return this;
+      }
+
+      public AnnotatedConverterFactory build() {
+        return new AnnotatedConverterFactory(factories);
+      }
+    }
+
+    AnnotatedConverterFactory(Map<Class<? extends Annotation>, Converter.Factory> factories) {
+      this.factories = new LinkedHashMap<>(factories);
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Retention(RUNTIME) public @interface Moshi {
+  }
+
+  @Retention(RUNTIME) public @interface Gson {
+  }
+
+  @Retention(RUNTIME) public @interface SimpleXml {
+  }
+
+  @Default(value = DefaultType.FIELD) static final class Library {
+    @Attribute String name;
+  }
+
+  interface Service {
+    @GET("/") @Moshi Call<Library> exampleMoshi();
+
+    @GET("/") @Gson Call<Library> exampleGson();
+
+    @GET("/") @SimpleXml Call<Library> exampleSimpleXml();
+
+    @GET("/") Call<Library> exampleDefault();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Moshi\"}"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"SimpleXML\"/>"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+
+    com.squareup.moshi.Moshi moshi = new com.squareup.moshi.Moshi.Builder().build();
+    com.google.gson.Gson gson = new GsonBuilder().create();
+    MoshiConverterFactory moshiConverterFactory = MoshiConverterFactory.create(moshi);
+    GsonConverterFactory gsonConverterFactory = GsonConverterFactory.create(gson);
+    SimpleXmlConverterFactory simpleXmlConverterFactory = SimpleXmlConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/"))
+        .addConverterFactory(
+            new AnnotatedConverterFactory.Builder().add(Moshi.class, moshiConverterFactory)
+                .add(Gson.class, gsonConverterFactory)
+                .add(SimpleXml.class, simpleXmlConverterFactory)
+                .build())
+        .addConverterFactory(gsonConverterFactory)
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Library library1 = service.exampleMoshi().execute().body();
+    System.out.println("Library 1: " + library1.name);
+
+    Library library2 = service.exampleGson().execute().body();
+    System.out.println("Library 2: " + library2.name);
+
+    Library library3 = service.exampleSimpleXml().execute().body();
+    System.out.println("Library 3: " + library3.name);
+
+    Library library4 = service.exampleDefault().execute().body();
+    System.out.println("Library 4: " + library4.name);
+
+    server.shutdown();
+  }
+}
