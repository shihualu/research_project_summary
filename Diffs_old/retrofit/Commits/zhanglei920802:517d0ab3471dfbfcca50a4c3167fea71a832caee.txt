diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
index 91f444b22..eeedbf9eb 100644
--- a/.buildscript/settings.xml
+++ b/.buildscript/settings.xml
@@ -1,9 +1,9 @@
 <settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
+    <servers>
+        <server>
+            <id>sonatype-nexus-snapshots</id>
+            <username>${env.CI_DEPLOY_USERNAME}</username>
+            <password>${env.CI_DEPLOY_PASSWORD}</password>
+        </server>
+    </servers>
 </settings>
diff --git a/checkstyle.xml b/checkstyle.xml
index a729c26a7..bb2518818 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -5,7 +5,7 @@
 
 <module name="Checker">
     <module name="NewlineAtEndOfFile">
-        <property name="lineSeparator" value="lf" />
+        <property name="lineSeparator" value="lf"/>
     </module>
     <module name="FileLength"/>
     <module name="FileTabCharacter"/>
@@ -46,7 +46,7 @@
         <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
         <module name="RedundantImport"/>
         <module name="UnusedImports">
-          <property name="processJavadoc" value="true"/>
+            <property name="processJavadoc" value="true"/>
         </module>
 
 
@@ -65,7 +65,7 @@
         <module name="EmptyForIteratorPad"/>
         <module name="MethodParamPad"/>
         <module name="NoWhitespaceAfter">
-          <property name="tokens" value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS"/>
+            <property name="tokens" value="BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS"/>
         </module>
         <module name="NoWhitespaceBefore"/>
         <module name="OperatorWrap"/>
@@ -122,7 +122,7 @@
         <!--module name="TodoComment"/-->
         <module name="UpperEll"/>
         <module name="Indentation">
-          <property name="basicOffset" value="2"/>
+            <property name="basicOffset" value="2"/>
         </module>
     </module>
 </module>
diff --git a/pom.xml b/pom.xml
index fa94edb15..21f5dd268 100644
--- a/pom.xml
+++ b/pom.xml
@@ -14,261 +14,262 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
+    <parent>
+        <groupId>org.sonatype.oss</groupId>
+        <artifactId>oss-parent</artifactId>
+        <version>7</version>
+    </parent>
 
-  <groupId>com.squareup.retrofit2</groupId>
-  <artifactId>parent</artifactId>
-  <version>2.1.1-SNAPSHOT</version>
-  <packaging>pom</packaging>
+    <groupId>com.squareup.retrofit2</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.1.1-SNAPSHOT</version>
+    <packaging>pom</packaging>
 
-  <name>Retrofit (Parent)</name>
-  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
-  <url>http://github.com/square/retrofit/</url>
+    <name>Retrofit (Parent)</name>
+    <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
+    <url>http://github.com/square/retrofit/</url>
 
-  <modules>
-    <module>retrofit</module>
-    <module>retrofit-adapters</module>
-    <module>retrofit-converters</module>
-    <module>retrofit-mock</module>
-    <module>samples</module>
-  </modules>
+    <modules>
+        <module>retrofit</module>
+        <module>retrofit-adapters</module>
+        <module>retrofit-converters</module>
+        <module>retrofit-mock</module>
+        <module>samples</module>
+    </modules>
 
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
-    <!-- Compilation -->
-    <java.version>1.7</java.version>
+        <!-- Compilation -->
+        <java.version>1.7</java.version>
 
-    <!-- Dependencies -->
-    <android.version>4.1.1.4</android.version>
-    <okhttp.version>3.4.1</okhttp.version>
-    <animal.sniffer.version>1.14</animal.sniffer.version>
+        <!-- Dependencies -->
+        <android.version>4.1.1.4</android.version>
+        <okhttp.version>3.4.1</okhttp.version>
+        <animal.sniffer.version>1.14</animal.sniffer.version>
 
-    <!-- Adapter Dependencies -->
-    <rxjava.version>1.2.0</rxjava.version>
-    <rxjava2.version>2.0.0</rxjava2.version>
-    <guava.version>19.0</guava.version>
+        <!-- Adapter Dependencies -->
+        <rxjava.version>1.2.0</rxjava.version>
+        <rxjava2.version>2.0.0</rxjava2.version>
+        <guava.version>19.0</guava.version>
 
-    <!-- Converter Dependencies -->
-    <gson.version>2.7</gson.version>
-    <protobuf.version>3.0.0</protobuf.version>
-    <jackson.version>2.7.2</jackson.version>
-    <wire.version>2.2.0</wire.version>
-    <simplexml.version>2.7.1</simplexml.version>
-    <moshi.version>1.3.0</moshi.version>
+        <!-- Converter Dependencies -->
+        <gson.version>2.7</gson.version>
+        <protobuf.version>3.0.0</protobuf.version>
+        <jackson.version>2.7.2</jackson.version>
+        <wire.version>2.2.0</wire.version>
+        <simplexml.version>2.7.1</simplexml.version>
+        <moshi.version>1.3.0</moshi.version>
 
-    <!-- Sample Dependencies -->
-    <jsoup.version>1.7.3</jsoup.version>
+        <!-- Sample Dependencies -->
+        <jsoup.version>1.7.3</jsoup.version>
 
-    <!-- Test Dependencies -->
-    <junit.version>4.12</junit.version>
-    <assertj.version>1.7.0</assertj.version>
-    <mockito.version>1.9.5</mockito.version>
-    <robolectric.version>3.0</robolectric.version>
-  </properties>
+        <!-- Test Dependencies -->
+        <junit.version>4.12</junit.version>
+        <assertj.version>1.7.0</assertj.version>
+        <mockito.version>1.9.5</mockito.version>
+        <robolectric.version>3.0</robolectric.version>
+    </properties>
 
-  <scm>
-    <url>http://github.com/square/retrofit</url>
-    <connection>scm:git:git://github.com/square/retrofit.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
+    <scm>
+        <url>http://github.com/square/retrofit</url>
+        <connection>scm:git:git://github.com/square/retrofit.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/square/retrofit.git</developerConnection>
+        <tag>HEAD</tag>
+    </scm>
 
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/square/retrofit/issues</url>
-  </issueManagement>
+    <issueManagement>
+        <system>GitHub Issues</system>
+        <url>http://github.com/square/retrofit/issues</url>
+    </issueManagement>
 
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
+    <licenses>
+        <license>
+            <name>Apache 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+        </license>
+    </licenses>
 
-  <organization>
-    <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
-  </organization>
+    <organization>
+        <name>Square, Inc.</name>
+        <url>http://squareup.com</url>
+    </organization>
 
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-annotations</artifactId>
-        <version>${animal.sniffer.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>okhttp</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.reactivex.rxjava2</groupId>
-        <artifactId>rxjava</artifactId>
-        <version>${rxjava2.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.protobuf</groupId>
-        <artifactId>protobuf-java</artifactId>
-        <version>${protobuf.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.fasterxml.jackson.core</groupId>
-        <artifactId>jackson-databind</artifactId>
-        <version>${jackson.version}</version>
-     </dependency>
-      <dependency>
-        <groupId>com.squareup.wire</groupId>
-        <artifactId>wire-runtime</artifactId>
-        <version>${wire.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.simpleframework</groupId>
-        <artifactId>simple-xml</artifactId>
-        <version>${simplexml.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>com.google.android</groupId>
+                <artifactId>android</artifactId>
+                <version>${android.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-annotations</artifactId>
+                <version>${animal.sniffer.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>okhttp</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.code.gson</groupId>
+                <artifactId>gson</artifactId>
+                <version>${gson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.reactivex</groupId>
+                <artifactId>rxjava</artifactId>
+                <version>${rxjava.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.reactivex.rxjava2</groupId>
+                <artifactId>rxjava</artifactId>
+                <version>${rxjava2.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.protobuf</groupId>
+                <artifactId>protobuf-java</artifactId>
+                <version>${protobuf.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.fasterxml.jackson.core</groupId>
+                <artifactId>jackson-databind</artifactId>
+                <version>${jackson.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.wire</groupId>
+                <artifactId>wire-runtime</artifactId>
+                <version>${wire.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.simpleframework</groupId>
+                <artifactId>simple-xml</artifactId>
+                <version>${simplexml.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.moshi</groupId>
+                <artifactId>moshi</artifactId>
+                <version>${moshi.version}</version>
+            </dependency>
 
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.assertj</groupId>
-        <artifactId>assertj-core</artifactId>
-        <version>${assertj.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.mockito</groupId>
-        <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.okhttp3</groupId>
-        <artifactId>mockwebserver</artifactId>
-        <version>${okhttp.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.robolectric</groupId>
-        <artifactId>robolectric</artifactId>
-        <version>${robolectric.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
+            <dependency>
+                <groupId>junit</groupId>
+                <artifactId>junit</artifactId>
+                <version>${junit.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.assertj</groupId>
+                <artifactId>assertj-core</artifactId>
+                <version>${assertj.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.mockito</groupId>
+                <artifactId>mockito-core</artifactId>
+                <version>${mockito.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+                <version>${guava.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>com.squareup.okhttp3</groupId>
+                <artifactId>mockwebserver</artifactId>
+                <version>${okhttp.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.robolectric</groupId>
+                <artifactId>robolectric</artifactId>
+                <version>${robolectric.version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
 
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
-          <configuration>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
+    <build>
+        <pluginManagement>
+            <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-compiler-plugin</artifactId>
+                    <version>3.0</version>
+                    <configuration>
+                        <source>${java.version}</source>
+                        <target>${java.version}</target>
+                    </configuration>
+                </plugin>
+            </plugins>
+        </pluginManagement>
 
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-release-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <autoVersionSubmodules>true</autoVersionSubmodules>
+                </configuration>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.15</version>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <version>2.15</version>
+                <configuration>
+                    <failsOnError>true</failsOnError>
+                    <configLocation>checkstyle.xml</configLocation>
+                    <consoleOutput>true</consoleOutput>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.3</version>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <version>2.10.3</version>
+                <executions>
+                    <execution>
+                        <id>attach-javadocs</id>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
 
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.1</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-maven-plugin</artifactId>
+                <version>${animal.sniffer.version}</version>
+                <executions>
+                    <execution>
+                        <phase>test</phase>
+                        <goals>
+                            <goal>check</goal>
+                        </goals>
+                    </execution>
+                </executions>
+                <configuration>
+                    <signature>
+                        <groupId>org.codehaus.mojo.signature</groupId>
+                        <artifactId>java16</artifactId>
+                        <version>1.1</version>
+                    </signature>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
index ae5632642..75423339d 100644
--- a/retrofit-adapters/guava/pom.xml
+++ b/retrofit-adapters/guava/pom.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-guava</artifactId>
-  <name>Adapter: Guava</name>
+    <artifactId>adapter-guava</artifactId>
+    <name>Adapter: Guava</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
index b3624fc3a..c8e8b6c02 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
@@ -17,10 +17,12 @@
 
 import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -49,104 +51,115 @@
  * </ul>
  */
 public final class GuavaCallAdapterFactory extends CallAdapter.Factory {
-  public static GuavaCallAdapterFactory create() {
-    return new GuavaCallAdapterFactory();
-  }
-
-  private GuavaCallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != ListenableFuture.class) {
-      return null;
-    }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("ListenableFuture return type must be parameterized"
-          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    public static GuavaCallAdapterFactory create() {
+        return new GuavaCallAdapterFactory();
     }
-    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    if (getRawType(innerType) != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter<>(innerType);
+    private GuavaCallAdapterFactory() {
     }
 
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter<>(responseType);
-  }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != ListenableFuture.class) {
+            return null;
+        }
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalStateException("ListenableFuture return type must be parameterized"
+                    + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+        }
+        Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-  private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
-    private final Type responseType;
+        if (getRawType(innerType) != Response.class) {
+            // Generic type is not Response<T>. Use it for body-only adapter.
+            return new BodyCallAdapter<>(innerType);
+        }
 
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+        if (!(innerType instanceof ParameterizedType)) {
+            throw new IllegalStateException("Response must be parameterized"
+                    + " as Response<Foo> or Response<? extends Foo>");
+        }
+        Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+        return new ResponseCallAdapter<>(responseType);
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static final class BodyCallAdapter<R> implements CallAdapter<R, ListenableFuture<R>> {
+        private final Type responseType;
 
-    @Override public ListenableFuture<R> adapt(final Call<R> call) {
-      return new AbstractFuture<R>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              if (response.isSuccessful()) {
-                set(response.body());
-              } else {
-                setException(new HttpException(response));
-              }
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
+        BodyCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
 
-        @Override protected void interruptTask() {
-          call.cancel();
+        @Override
+        public Type responseType() {
+            return responseType;
         }
-      };
-    }
-  }
-
-  private static final class ResponseCallAdapter<R>
-      implements CallAdapter<R, ListenableFuture<Response<R>>> {
-    private final Type responseType;
 
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        @Override
+        public ListenableFuture<R> adapt(final Call<R> call) {
+            return new AbstractFuture<R>() {
+                {
+                    call.enqueue(new Callback<R>() {
+                        @Override
+                        public void onResponse(Call<R> call, Response<R> response) {
+                            if (response.isSuccessful()) {
+                                set(response.body());
+                            }
+                            else {
+                                setException(new HttpException(response));
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(Call<R> call, Throwable t) {
+                            setException(t);
+                        }
+                    });
+                }
+
+                @Override
+                protected void interruptTask() {
+                    call.cancel();
+                }
+            };
+        }
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static final class ResponseCallAdapter<R>
+            implements CallAdapter<R, ListenableFuture<Response<R>>> {
+        private final Type responseType;
+
+        ResponseCallAdapter(Type responseType) {
+            this.responseType = responseType;
+        }
 
-    @Override public ListenableFuture<Response<R>> adapt(final Call<R> call) {
-      return new AbstractFuture<Response<R>>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              set(response);
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
+        @Override
+        public Type responseType() {
+            return responseType;
         }
 
-        @Override protected void interruptTask() {
-          call.cancel();
+        @Override
+        public ListenableFuture<Response<R>> adapt(final Call<R> call) {
+            return new AbstractFuture<Response<R>>() {
+                {
+                    call.enqueue(new Callback<R>() {
+                        @Override
+                        public void onResponse(Call<R> call, Response<R> response) {
+                            set(response);
+                        }
+
+                        @Override
+                        public void onFailure(Call<R> call, Throwable t) {
+                            setException(t);
+                        }
+                    });
+                }
+
+                @Override
+                protected void interruptTask() {
+                    call.cancel();
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
index f18a81955..b2f18c3dd 100644
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
+++ b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
@@ -19,31 +19,31 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super("HTTP " + response.code() + " " + response.message());
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /** HTTP status code. */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /** HTTP status message. */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
index c8abdf1c2..01d80e1b5 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
@@ -17,13 +17,17 @@
 
 import com.google.common.reflect.TypeToken;
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -32,69 +36,85 @@
 import static org.junit.Assert.fail;
 
 public final class GuavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
-  @Rule public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
-  private Retrofit retrofit;
+    private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
+    private Retrofit retrofit;
 
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
+    }
 
-  @Test public void responseType() {
-    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
-    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
-    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
-    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
+    @Test
+    public void responseType() {
+        Type bodyClass = new TypeToken<ListenableFuture<String>>() {
+        }.getType();
+        assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+    }
 
-  @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
+    @Test
+    public void nonListenableFutureReturnsNull() {
+        CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
+    }
 
-  @Test public void rawTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+    @Test
+    public void rawTypeThrows() {
+        Type observableType = new TypeToken<ListenableFuture>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
+        }
     }
-  }
 
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<ListenableFuture<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
index fb3ccb3da..f42050a02 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
@@ -16,13 +16,17 @@
 package retrofit2.adapter.guava;
 
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,83 +36,94 @@
 import static org.junit.Assert.fail;
 
 public final class ListenableFutureTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") ListenableFuture<String> body();
-    @GET("/") ListenableFuture<Response<String>> response();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<String> future = service.body();
-    assertThat(future.get()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
-          .hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        ListenableFuture<String> body();
+
+        @GET("/")
+        ListenableFuture<Response<String>> response();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(GuavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        ListenableFuture<String> future = service.body();
+        assertThat(future.get()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void bodySuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        ListenableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(HttpException.class)
+                                    .hasMessage("HTTP 404 Client Error");
+        }
+    }
+
+    @Test
+    public void bodyFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        ListenableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 
-  @Test public void bodyFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    @Test
+    public void responseSuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+        ListenableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
     }
-  }
-
-  @Test public void responseSuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    ListenableFuture<Response<String>> future = service.response();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+
+    @Test
+    public void responseSuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        ListenableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        ListenableFuture<Response<String>> future = service.response();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
index bb9ccf189..6a2b71fd3 100644
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/java8/pom.xml b/retrofit-adapters/java8/pom.xml
index 4ca8fa229..02435ccc3 100644
--- a/retrofit-adapters/java8/pom.xml
+++ b/retrofit-adapters/java8/pom.xml
@@ -1,65 +1,66 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-java8</artifactId>
-  <name>Adapter: Java 8</name>
+    <artifactId>adapter-java8</artifactId>
+    <name>Adapter: Java 8</name>
 
-  <properties>
-    <java.version>1.8</java.version>
-  </properties>
+    <properties>
+        <java.version>1.8</java.version>
+    </properties>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <configuration>
-          <signature>
-            <groupId>org.kaazing.mojo.signature</groupId>
-            <artifactId>java18</artifactId>
-            <version>1.0</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>animal-sniffer-maven-plugin</artifactId>
+                <version>${animal.sniffer.version}</version>
+                <configuration>
+                    <signature>
+                        <groupId>org.kaazing.mojo.signature</groupId>
+                        <artifactId>java18</artifactId>
+                        <version>1.0</version>
+                    </signature>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
index 022fa9848..cc316fbe3 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/HttpException.java
@@ -19,31 +19,31 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super("HTTP " + response.code() + " " + response.message());
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /** HTTP status code. */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /** HTTP status message. */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
index fd905475d..307379ce5 100644
--- a/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
+++ b/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.CompletableFuture;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -48,110 +49,121 @@
  * </ul>
  */
 public final class Java8CallAdapterFactory extends CallAdapter.Factory {
-  public static Java8CallAdapterFactory create() {
-    return new Java8CallAdapterFactory();
-  }
-
-  private Java8CallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != CompletableFuture.class) {
-      return null;
+    public static Java8CallAdapterFactory create() {
+        return new Java8CallAdapterFactory();
     }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("CompletableFuture return type must be parameterized"
-          + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
-    }
-    Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-    if (getRawType(innerType) != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter<>(innerType);
+    private Java8CallAdapterFactory() {
     }
 
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
-    return new ResponseCallAdapter<>(responseType);
-  }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != CompletableFuture.class) {
+            return null;
+        }
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalStateException("CompletableFuture return type must be parameterized"
+                    + " as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+        }
+        Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);
 
-  private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
-    private final Type responseType;
+        if (getRawType(innerType) != Response.class) {
+            // Generic type is not Response<T>. Use it for body-only adapter.
+            return new BodyCallAdapter<>(innerType);
+        }
 
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        // Generic type is Response<T>. Extract T and create the Response version of the adapter.
+        if (!(innerType instanceof ParameterizedType)) {
+            throw new IllegalStateException("Response must be parameterized"
+                    + " as Response<Foo> or Response<? extends Foo>");
+        }
+        Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);
+        return new ResponseCallAdapter<>(responseType);
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static final class BodyCallAdapter<R> implements CallAdapter<R, CompletableFuture<R>> {
+        private final Type responseType;
 
-    @Override public CompletableFuture<R> adapt(final Call<R> call) {
-      final CompletableFuture<R> future = new CompletableFuture<R>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
-        }
-      };
-
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          if (response.isSuccessful()) {
-            future.complete(response.body());
-          } else {
-            future.completeExceptionally(new HttpException(response));
-          }
+        BodyCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
-      });
-
-      return future;
-    }
-  }
 
-  private static final class ResponseCallAdapter<R>
-      implements CallAdapter<R, CompletableFuture<Response<R>>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
+        @Override
+        public CompletableFuture<R> adapt(final Call<R> call) {
+            final CompletableFuture<R> future = new CompletableFuture<R>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    if (response.isSuccessful()) {
+                        future.complete(response.body());
+                    }
+                    else {
+                        future.completeExceptionally(new HttpException(response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
+        }
     }
 
-    @Override public Type responseType() {
-      return responseType;
-    }
+    private static final class ResponseCallAdapter<R>
+            implements CallAdapter<R, CompletableFuture<Response<R>>> {
+        private final Type responseType;
 
-    @Override public CompletableFuture<Response<R>> adapt(final Call<R> call) {
-      final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
-        @Override public boolean cancel(boolean mayInterruptIfRunning) {
-          if (mayInterruptIfRunning) {
-            call.cancel();
-          }
-          return super.cancel(mayInterruptIfRunning);
+        ResponseCallAdapter(Type responseType) {
+            this.responseType = responseType;
         }
-      };
 
-      call.enqueue(new Callback<R>() {
-        @Override public void onResponse(Call<R> call, Response<R> response) {
-          future.complete(response);
+        @Override
+        public Type responseType() {
+            return responseType;
         }
 
-        @Override public void onFailure(Call<R> call, Throwable t) {
-          future.completeExceptionally(t);
+        @Override
+        public CompletableFuture<Response<R>> adapt(final Call<R> call) {
+            final CompletableFuture<Response<R>> future = new CompletableFuture<Response<R>>() {
+                @Override
+                public boolean cancel(boolean mayInterruptIfRunning) {
+                    if (mayInterruptIfRunning) {
+                        call.cancel();
+                    }
+                    return super.cancel(mayInterruptIfRunning);
+                }
+            };
+
+            call.enqueue(new Callback<R>() {
+                @Override
+                public void onResponse(Call<R> call, Response<R> response) {
+                    future.complete(response);
+                }
+
+                @Override
+                public void onFailure(Call<R> call, Throwable t) {
+                    future.completeExceptionally(t);
+                }
+            });
+
+            return future;
         }
-      });
-
-      return future;
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
index d4a00a1dc..e5c0c96a8 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/CompletableFutureTest.java
@@ -18,11 +18,14 @@
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -32,83 +35,94 @@
 import static org.junit.Assert.fail;
 
 public final class CompletableFutureTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") CompletableFuture<String> body();
-    @GET("/") CompletableFuture<Response<String>> response();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(Java8CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    CompletableFuture<String> future = service.body();
-    assertThat(future.get()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    CompletableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
-          .hasMessage("HTTP 404 Client Error");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        CompletableFuture<String> body();
+
+        @GET("/")
+        CompletableFuture<Response<String>> response();
     }
-  }
 
-  @Test public void bodyFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(Java8CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        CompletableFuture<String> future = service.body();
+        assertThat(future.get()).isEqualTo("Hi");
+    }
 
-    CompletableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    @Test
+    public void bodySuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        CompletableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(HttpException.class)
+                                    .hasMessage("HTTP 404 Client Error");
+        }
     }
-  }
-
-  @Test public void responseSuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    CompletableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    CompletableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    CompletableFuture<Response<String>> future = service.response();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
+
+    @Test
+    public void bodyFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        CompletableFuture<String> future = service.body();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
+    }
+
+    @Test
+    public void responseSuccess200() throws Exception {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        CompletableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseSuccess404() throws Exception {
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        CompletableFuture<Response<String>> future = service.response();
+        Response<String> response = future.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseFailure() throws Exception {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        CompletableFuture<Response<String>> future = service.response();
+        try {
+            future.get();
+            fail();
+        } catch (ExecutionException e) {
+            assertThat(e.getCause()).isInstanceOf(IOException.class);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
index 283268881..3854dd83d 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/Java8CallAdapterFactoryTest.java
@@ -16,14 +16,18 @@
 package retrofit2.adapter.java8;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -32,69 +36,85 @@
 import static org.junit.Assert.fail;
 
 public final class Java8CallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
 
-  @Rule public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-  private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
-  private Retrofit retrofit;
+    private final CallAdapter.Factory factory = Java8CallAdapterFactory.create();
+    private Retrofit retrofit;
 
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
+    }
 
-  @Test public void responseType() {
-    Type bodyClass = new TypeToken<CompletableFuture<String>>() {}.getType();
-    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {}.getType();
-    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {}.getType();
-    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
+    @Test
+    public void responseType() {
+        Type bodyClass = new TypeToken<CompletableFuture<String>>() {
+        }.getType();
+        assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyWildcard = new TypeToken<CompletableFuture<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type bodyGeneric = new TypeToken<CompletableFuture<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type responseClass = new TypeToken<CompletableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type responseWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultClass = new TypeToken<CompletableFuture<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type resultWildcard = new TypeToken<CompletableFuture<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+    }
 
-  @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
+    @Test
+    public void nonListenableFutureReturnsNull() {
+        CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
+    }
 
-  @Test public void rawTypeThrows() {
-    Type observableType = new TypeToken<CompletableFuture>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+    @Test
+    public void rawTypeThrows() {
+        Type observableType = new TypeToken<CompletableFuture>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "CompletableFuture return type must be parameterized as CompletableFuture<Foo> or CompletableFuture<? extends Foo>");
+        }
     }
-  }
 
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<CompletableFuture<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<CompletableFuture<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
index de4b63e61..230f9c4ff 100644
--- a/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
+++ b/retrofit-adapters/java8/src/test/java/retrofit2/adapter/java8/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index fc5e8d505..d5700547f 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -1,23 +1,24 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-adapters</artifactId>
-  <name>Adapters</name>
-  <packaging>pom</packaging>
+    <artifactId>retrofit-adapters</artifactId>
+    <name>Adapters</name>
+    <packaging>pom</packaging>
 
-  <modules>
-    <module>guava</module>
-    <module>java8</module>
-    <module>rxjava</module>
-    <module>rxjava2</module>
-  </modules>
+    <modules>
+        <module>guava</module>
+        <module>java8</module>
+        <module>rxjava</module>
+        <module>rxjava2</module>
+    </modules>
 </project>
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
index 249156122..c13352334 100644
--- a/retrofit-adapters/rxjava/pom.xml
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -1,48 +1,49 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-rxjava</artifactId>
-  <name>Adapter: RxJava</name>
+    <artifactId>adapter-rxjava</artifactId>
+    <name>Adapter: RxJava</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.reactivex</groupId>
+            <artifactId>rxjava</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
index 88e5c5e4e..88f06e527 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/BodyCallable.java
@@ -16,20 +16,22 @@
 package retrofit2.adapter.rxjava;
 
 import java.util.concurrent.Callable;
+
 import retrofit2.Response;
 
 final class BodyCallable<R> implements Callable<R> {
-  private final Callable<Response<R>> responseCallable;
+    private final Callable<Response<R>> responseCallable;
 
-  BodyCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
+    BodyCallable(Callable<Response<R>> responseCallable) {
+        this.responseCallable = responseCallable;
+    }
 
-  @Override public R call() throws Exception {
-    Response<R> response = responseCallable.call();
-    if (response.isSuccessful()) {
-      return response.body();
+    @Override
+    public R call() throws Exception {
+        Response<R> response = responseCallable.call();
+        if (response.isSuccessful()) {
+            return response.body();
+        }
+        throw new HttpException(response);
     }
-    throw new HttpException(response);
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
index 2e501e121..4c49120cc 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/HttpException.java
@@ -4,36 +4,36 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
-  private static String getMessage(Response<?> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return "HTTP " + response.code() + " " + response.message();
-  }
+    private static String getMessage(Response<?> response) {
+        if (response == null) throw new NullPointerException("response == null");
+        return "HTTP " + response.code() + " " + response.message();
+    }
 
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super(getMessage(response));
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super(getMessage(response));
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /** HTTP status code. */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /** HTTP status message. */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
index 7d075e71b..37505cdff 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResponseCallable.java
@@ -17,18 +17,20 @@
 
 import java.io.IOException;
 import java.util.concurrent.Callable;
+
 import retrofit2.Call;
 import retrofit2.Response;
 
 final class ResponseCallable<T> implements Callable<Response<T>> {
-  private final Call<T> call;
+    private final Call<T> call;
 
-  ResponseCallable(Call<T> call) {
-    this.call = call;
-  }
+    ResponseCallable(Call<T> call) {
+        this.call = call;
+    }
 
-  @Override public Response<T> call() throws IOException {
-    // Since Call is a one-shot type, clone it for each new caller.
-    return call.clone().execute();
-  }
+    @Override
+    public Response<T> call() throws IOException {
+        // Since Call is a one-shot type, clone it for each new caller.
+        return call.clone().execute();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
index 49abfae2b..5592330b8 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/Result.java
@@ -16,57 +16,59 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
-  public static <T> Result<T> error(Throwable error) {
-    if (error == null) throw new NullPointerException("error == null");
-    return new Result<>(null, error);
-  }
+    public static <T> Result<T> error(Throwable error) {
+        if (error == null) throw new NullPointerException("error == null");
+        return new Result<>(null, error);
+    }
 
-  public static <T> Result<T> response(Response<T> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return new Result<>(response, null);
-  }
+    public static <T> Result<T> response(Response<T> response) {
+        if (response == null) throw new NullPointerException("response == null");
+        return new Result<>(response, null);
+    }
 
-  private final Response<T> response;
-  private final Throwable error;
+    private final Response<T> response;
+    private final Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
-    this.response = response;
-    this.error = error;
-  }
+    private Result(Response<T> response, Throwable error) {
+        this.response = response;
+        this.error = error;
+    }
 
-  /**
-   * The response received from executing an HTTP request. Only present when {@link #isError()} is
-   * false, null otherwise.
-   */
-  public Response<T> response() {
-    return response;
-  }
+    /**
+     * The response received from executing an HTTP request. Only present when {@link #isError()} is
+     * false, null otherwise.
+     */
+    public Response<T> response() {
+        return response;
+    }
 
-  /**
-   * The error experienced while attempting to execute an HTTP request. Only present when {@link
-   * #isError()} is true, null otherwise.
-   * <p>
-   * If the error is an {@link IOException} then there was a problem with the transport to the
-   * remote server. Any other exception type indicates an unexpected failure and should be
-   * considered fatal (configuration error, programming error, etc.).
-   */
-  public Throwable error() {
-    return error;
-  }
+    /**
+     * The error experienced while attempting to execute an HTTP request. Only present when {@link
+     * #isError()} is true, null otherwise.
+     * <p>
+     * If the error is an {@link IOException} then there was a problem with the transport to the
+     * remote server. Any other exception type indicates an unexpected failure and should be
+     * considered fatal (configuration error, programming error, etc.).
+     */
+    public Throwable error() {
+        return error;
+    }
 
-  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
-  public boolean isError() {
-    return error != null;
-  }
+    /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+    public boolean isError() {
+        return error != null;
+    }
 
-  @Override public String toString() {
-    if (error != null) {
-      return "Result{isError=true, error=\"" + error + "\"}";
+    @Override
+    public String toString() {
+        if (error != null) {
+            return "Result{isError=true, error=\"" + error + "\"}";
+        }
+        return "Result{isError=false, response=" + response + '}';
     }
-    return "Result{isError=false, response=" + response + '}';
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
index ea9e37c25..334260285 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/ResultCallable.java
@@ -16,20 +16,22 @@
 package retrofit2.adapter.rxjava;
 
 import java.util.concurrent.Callable;
+
 import retrofit2.Response;
 
 final class ResultCallable<R> implements Callable<Result<R>> {
-  private final Callable<Response<R>> responseCallable;
+    private final Callable<Response<R>> responseCallable;
 
-  ResultCallable(Callable<Response<R>> responseCallable) {
-    this.responseCallable = responseCallable;
-  }
+    ResultCallable(Callable<Response<R>> responseCallable) {
+        this.responseCallable = responseCallable;
+    }
 
-  @Override public Result<R> call() {
-    try {
-      return Result.response(responseCallable.call());
-    } catch (Throwable t) {
-      return Result.error(t);
+    @Override
+    public Result<R> call() {
+        try {
+            return Result.response(responseCallable.call());
+        } catch (Throwable t) {
+            return Result.error(t);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
index 19cf184ad..341dbad35 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapter.java
@@ -16,65 +16,70 @@
 package retrofit2.adapter.rxjava;
 
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import rx.Observable;
 import rx.Scheduler;
 
 final class RxJavaCallAdapter<R> implements CallAdapter<R, Object> {
-  private final Type responseType;
-  private final Scheduler scheduler;
-  private final boolean isResult;
-  private final boolean isBody;
-  private final boolean isSingle;
-  private final boolean isCompletable;
+    private final Type responseType;
+    private final Scheduler scheduler;
+    private final boolean isResult;
+    private final boolean isBody;
+    private final boolean isSingle;
+    private final boolean isCompletable;
 
-  RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
-      boolean isSingle, boolean isCompletable) {
-    this.responseType = responseType;
-    this.scheduler = scheduler;
-    this.isResult = isResult;
-    this.isBody = isBody;
-    this.isSingle = isSingle;
-    this.isCompletable = isCompletable;
-  }
+    RxJavaCallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
+            boolean isSingle, boolean isCompletable) {
+        this.responseType = responseType;
+        this.scheduler = scheduler;
+        this.isResult = isResult;
+        this.isBody = isBody;
+        this.isSingle = isSingle;
+        this.isCompletable = isCompletable;
+    }
 
-  @Override public Type responseType() {
-    return responseType;
-  }
+    @Override
+    public Type responseType() {
+        return responseType;
+    }
 
-  @Override public Object adapt(Call<R> call) {
-    ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
+    @Override
+    public Object adapt(Call<R> call) {
+        ResponseCallable<R> resultCallable = new ResponseCallable<>(call);
 
-    Observable<?> observable;
-    if (isResult) {
-      observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
-    } else if (isBody) {
-      observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
-    } else {
-      observable = Observable.fromCallable(resultCallable);
-    }
+        Observable<?> observable;
+        if (isResult) {
+            observable = Observable.fromCallable(new ResultCallable<>(resultCallable));
+        }
+        else if (isBody) {
+            observable = Observable.fromCallable(new BodyCallable<>(resultCallable));
+        }
+        else {
+            observable = Observable.fromCallable(resultCallable);
+        }
 
-    if (scheduler != null) {
-      observable = observable.subscribeOn(scheduler);
-    }
+        if (scheduler != null) {
+            observable = observable.subscribeOn(scheduler);
+        }
 
-    if (isSingle) {
-      return observable.toSingle();
-    }
-    if (isCompletable) {
-      return CompletableHelper.toCompletable(observable);
+        if (isSingle) {
+            return observable.toSingle();
+        }
+        if (isCompletable) {
+            return CompletableHelper.toCompletable(observable);
+        }
+        return observable;
     }
-    return observable;
-  }
 
-  /**
-   * Separate static class defers classloading and bytecode verification since Completable is not an
-   * RxJava stable API yet.
-   */
-  private static final class CompletableHelper {
-    static Object toCompletable(Observable<?> observable) {
-      return observable.toCompletable();
+    /**
+     * Separate static class defers classloading and bytecode verification since Completable is not an
+     * RxJava stable API yet.
+     */
+    private static final class CompletableHelper {
+        static Object toCompletable(Observable<?> observable) {
+            return observable.toCompletable();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
index 283451679..8c5e5a88d 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactory.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -56,71 +57,73 @@
  * stable by RxJava.
  */
 public final class RxJavaCallAdapterFactory extends CallAdapter.Factory {
-  /**
-   * Returns an instance which creates synchronous observables that do not operate on any scheduler
-   * by default.
-   */
-  public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory(null);
-  }
-
-  /**
-   * Returns an instance which creates synchronous observables that
-   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
-   */
-  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
-    if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJavaCallAdapterFactory(scheduler);
-  }
+    /**
+     * Returns an instance which creates synchronous observables that do not operate on any scheduler
+     * by default.
+     */
+    public static RxJavaCallAdapterFactory create() {
+        return new RxJavaCallAdapterFactory(null);
+    }
 
-  private final Scheduler scheduler;
+    /**
+     * Returns an instance which creates synchronous observables that
+     * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+     */
+    public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {
+        if (scheduler == null) throw new NullPointerException("scheduler == null");
+        return new RxJavaCallAdapterFactory(scheduler);
+    }
 
-  private RxJavaCallAdapterFactory(Scheduler scheduler) {
-    this.scheduler = scheduler;
-  }
+    private final Scheduler scheduler;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = getRawType(returnType);
-    boolean isSingle = rawType == Single.class;
-    boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
-    if (rawType != Observable.class && !isSingle && !isCompletable) {
-      return null;
+    private RxJavaCallAdapterFactory(Scheduler scheduler) {
+        this.scheduler = scheduler;
     }
 
-    if (isCompletable) {
-      return new RxJavaCallAdapter(Void.class, scheduler, false, true, false, true);
-    }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        Class<?> rawType = getRawType(returnType);
+        boolean isSingle = rawType == Single.class;
+        boolean isCompletable = "rx.Completable".equals(rawType.getCanonicalName());
+        if (rawType != Observable.class && !isSingle && !isCompletable) {
+            return null;
+        }
 
-    boolean isResult = false;
-    boolean isBody = false;
-    Type responseType;
-    if (!(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
+        if (isCompletable) {
+            return new RxJavaCallAdapter(Void.class, scheduler, false, true, false, true);
+        }
 
-    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-    } else if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      isResult = true;
-    } else {
-      responseType = observableType;
-      isBody = true;
-    }
+        boolean isResult = false;
+        boolean isBody = false;
+        Type responseType;
+        if (!(returnType instanceof ParameterizedType)) {
+            String name = isSingle ? "Single" : "Observable";
+            throw new IllegalStateException(name + " return type must be parameterized"
+                    + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+        }
 
-    return new RxJavaCallAdapter(responseType, scheduler, isResult, isBody, isSingle, false);
-  }
+        Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+        Class<?> rawObservableType = getRawType(observableType);
+        if (rawObservableType == Response.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Response must be parameterized"
+                        + " as Response<Foo> or Response<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+        }
+        else if (rawObservableType == Result.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Result must be parameterized"
+                        + " as Result<Foo> or Result<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+            isResult = true;
+        }
+        else {
+            responseType = observableType;
+            isBody = true;
+        }
+
+        return new RxJavaCallAdapter(responseType, scheduler, isResult, isBody, isSingle, false);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
index b10ab34af..bf8be384f 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableTest.java
@@ -16,12 +16,15 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
@@ -29,45 +32,53 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 
 public final class CompletableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
 
-  interface Service {
-    @GET("/") Completable completable();
-  }
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
 
-  private Service service;
+    private Service service;
 
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
 
-  @Test public void completableSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
+    @Test
+    public void completableSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
 
-    RecordingSubscriber<Void> subscriber = subscriberRule.create();
-    service.completable().unsafeSubscribe(subscriber);
-    subscriber.assertCompleted();
-  }
+        RecordingSubscriber<Void> subscriber = subscriberRule.create();
+        service.completable().unsafeSubscribe(subscriber);
+        subscriber.assertCompleted();
+    }
 
-  @Test public void completableSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
+    @Test
+    public void completableSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
 
-    RecordingSubscriber<Void> subscriber = subscriberRule.create();
-    service.completable().unsafeSubscribe(subscriber);
-    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
+        RecordingSubscriber<Void> subscriber = subscriberRule.create();
+        service.completable().unsafeSubscribe(subscriber);
+        subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
 
-  @Test public void completableFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    @Test
+    public void completableFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    RecordingSubscriber<Void> subscriber = subscriberRule.create();
-    service.completable().unsafeSubscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
+        RecordingSubscriber<Void> subscriber = subscriberRule.create();
+        service.completable().unsafeSubscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
index 02c4778b1..52fe38f9b 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/CompletableWithSchedulerTest.java
@@ -17,41 +17,48 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 import rx.Completable;
 import rx.schedulers.TestScheduler;
 
 public final class CompletableWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void completableUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.completable().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertCompleted();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void completableUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.completable().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertCompleted();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
index d32d6f6ae..812ccf10a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ForwardingSubscriber.java
@@ -18,21 +18,24 @@
 import rx.Subscriber;
 
 abstract class ForwardingSubscriber<T> extends Subscriber<T> {
-  private final Subscriber<T> delegate;
+    private final Subscriber<T> delegate;
 
-  ForwardingSubscriber(Subscriber<T> delegate) {
-    this.delegate = delegate;
-  }
+    ForwardingSubscriber(Subscriber<T> delegate) {
+        this.delegate = delegate;
+    }
 
-  @Override public void onNext(T value) {
-    delegate.onNext(value);
-  }
+    @Override
+    public void onNext(T value) {
+        delegate.onNext(value);
+    }
 
-  @Override public void onCompleted() {
-    delegate.onCompleted();
-  }
+    @Override
+    public void onCompleted() {
+        delegate.onCompleted();
+    }
 
-  @Override public void onError(Throwable throwable) {
-    delegate.onError(throwable);
-  }
+    @Override
+    public void onError(Throwable throwable) {
+        delegate.onError(throwable);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
index 2e77f06c1..9487bf44a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/HttpExceptionTest.java
@@ -16,26 +16,29 @@
 package retrofit2.adapter.rxjava;
 
 import org.junit.Test;
+
 import retrofit2.Response;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class HttpExceptionTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    HttpException exception = new HttpException(response);
-    assertThat(exception.code()).isEqualTo(200);
-    assertThat(exception.message()).isEqualTo("OK");
-    assertThat(exception.response()).isSameAs(response);
-  }
+    @Test
+    public void response() {
+        Response<String> response = Response.success("Hi");
+        HttpException exception = new HttpException(response);
+        assertThat(exception.code()).isEqualTo(200);
+        assertThat(exception.message()).isEqualTo("OK");
+        assertThat(exception.response()).isSameAs(response);
+    }
 
-  @Test public void nullResponseThrows() {
-    try {
-      new HttpException(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
+    @Test
+    public void nullResponseThrows() {
+        try {
+            new HttpException(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("response == null");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
index 53dcc0770..8e900f5f9 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableTest.java
@@ -16,12 +16,15 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -31,146 +34,167 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ObservableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertValue("Hi").assertCompleted();
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void bodyRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
-    service.body().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.requestMore(1);
-    subscriber.assertAnyValue().assertCompleted();
-
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
-    subscriber.assertCompleted();
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().code()).isEqualTo(404);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void responseRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
-    service.response().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.requestMore(1);
-    subscriber.assertAnyValue().assertCompleted();
-
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.requestMore(1);
-    subscriber.assertAnyValue().assertCompleted();
-
-    subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertValue("Hi").assertCompleted();
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void bodyRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+        service.body().unsafeSubscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.requestMore(1);
+        subscriber.assertAnyValue().assertCompleted();
+
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void responseSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().code()).isEqualTo(404);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+        service.response().unsafeSubscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.requestMore(1);
+        subscriber.assertAnyValue().assertCompleted();
+
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.requestMore(1);
+        subscriber.assertAnyValue().assertCompleted();
+
+        subscriber.requestMore(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP requests.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
index 3cf00cd7a..e88b51b6c 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ObservableWithSchedulerTest.java
@@ -17,9 +17,11 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -27,57 +29,68 @@
 import rx.schedulers.TestScheduler;
 
 public final class ObservableWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
index 4919ddcd5..33402af4a 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RecordingSubscriber.java
@@ -19,9 +19,11 @@
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
+
 import rx.Notification;
 import rx.Subscriber;
 
@@ -29,118 +31,124 @@
 
 /** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
 final class RecordingSubscriber<T> extends Subscriber<T> {
-  private final long initialRequest;
-  private final Deque<Notification<T>> events = new ArrayDeque<>();
-
-  private RecordingSubscriber(long initialRequest) {
-    this.initialRequest = initialRequest;
-  }
-
-  @Override public void onStart() {
-    request(initialRequest);
-  }
-
-  @Override public void onNext(T value) {
-    events.add(Notification.createOnNext(value));
-  }
-
-  @Override public void onCompleted() {
-    events.add(Notification.<T>createOnCompleted());
-  }
-
-  @Override public void onError(Throwable e) {
-    events.add(Notification.<T>createOnError(e));
-  }
-
-  private Notification<T> takeNotification() {
-    Notification<T> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
-    }
-    return notification;
-  }
-
-  public T takeValue() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnNext())
-        .overridingErrorMessage("Expected onNext event but was %s", notification)
-        .isTrue();
-    return notification.getValue();
-  }
-
-  public Throwable takeError() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .overridingErrorMessage("Expected onError event but was %s", notification)
-        .isTrue();
-    return notification.getThrowable();
-  }
-
-  public RecordingSubscriber<T> assertAnyValue() {
-    takeValue();
-    return this;
-  }
-
-  public RecordingSubscriber<T> assertValue(T value) {
-    assertThat(takeValue()).isEqualTo(value);
-    return this;
-  }
-
-  public void assertCompleted() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnCompleted())
-        .overridingErrorMessage("Expected onCompleted event but was %s", notification)
-        .isTrue();
-    assertNoEvents();
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
-    }
-    assertNoEvents();
-  }
-
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
-
-  public void requestMore(long amount) {
-    request(amount);
-  }
-
-  public static final class Rule implements TestRule {
-    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
-
-    public <T> RecordingSubscriber<T> create() {
-      return createWithInitialRequest(Long.MAX_VALUE);
-    }
-
-    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
-      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
-      subscribers.add(subscriber);
-      return subscriber;
-    }
-
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingSubscriber<?> subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    private final long initialRequest;
+    private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+    private RecordingSubscriber(long initialRequest) {
+        this.initialRequest = initialRequest;
+    }
+
+    @Override
+    public void onStart() {
+        request(initialRequest);
+    }
+
+    @Override
+    public void onNext(T value) {
+        events.add(Notification.createOnNext(value));
+    }
+
+    @Override
+    public void onCompleted() {
+        events.add(Notification.<T>createOnCompleted());
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.<T>createOnError(e));
+    }
+
+    private Notification<T> takeNotification() {
+        Notification<T> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
+
+    public T takeValue() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnNext())
+                .overridingErrorMessage("Expected onNext event but was %s", notification)
+                .isTrue();
+        return notification.getValue();
+    }
+
+    public Throwable takeError() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .overridingErrorMessage("Expected onError event but was %s", notification)
+                .isTrue();
+        return notification.getThrowable();
+    }
+
+    public RecordingSubscriber<T> assertAnyValue() {
+        takeValue();
+        return this;
+    }
+
+    public RecordingSubscriber<T> assertValue(T value) {
+        assertThat(takeValue()).isEqualTo(value);
+        return this;
+    }
+
+    public void assertCompleted() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnCompleted())
+                .overridingErrorMessage("Expected onCompleted event but was %s", notification)
+                .isTrue();
+        assertNoEvents();
+    }
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
+
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
+    }
+
+    public void requestMore(long amount) {
+        request(amount);
+    }
+
+    public static final class Rule implements TestRule {
+        final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+        public <T> RecordingSubscriber<T> create() {
+            return createWithInitialRequest(Long.MAX_VALUE);
+        }
+
+        public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+            RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingSubscriber<?> subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
index 7c62c14ad..fa84636d1 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/ResultTest.java
@@ -16,7 +16,9 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.adapter.rxjava.Result;
 
@@ -24,37 +26,41 @@
 import static org.junit.Assert.fail;
 
 public final class ResultTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    Result<String> result = Result.response(response);
-    assertThat(result.isError()).isFalse();
-    assertThat(result.error()).isNull();
-    assertThat(result.response()).isSameAs(response);
-  }
-
-  @Test public void nullResponseThrows() {
-    try {
-      Result.response(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
+    @Test
+    public void response() {
+        Response<String> response = Response.success("Hi");
+        Result<String> result = Result.response(response);
+        assertThat(result.isError()).isFalse();
+        assertThat(result.error()).isNull();
+        assertThat(result.response()).isSameAs(response);
+    }
+
+    @Test
+    public void nullResponseThrows() {
+        try {
+            Result.response(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("response == null");
+        }
     }
-  }
-
-  @Test public void error() {
-    Throwable error = new IOException();
-    Result<Object> result = Result.error(error);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isSameAs(error);
-    assertThat(result.response()).isNull();
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Result.error(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("error == null");
+
+    @Test
+    public void error() {
+        Throwable error = new IOException();
+        Result<Object> result = Result.error(error);
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isSameAs(error);
+        assertThat(result.response()).isNull();
+    }
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Result.error(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("error == null");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
index 674575f74..19f0ad747 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaCallAdapterFactoryTest.java
@@ -16,11 +16,14 @@
 package retrofit2.adapter.rxjava;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -31,141 +34,170 @@
 import static org.junit.Assert.fail;
 
 public final class RxJavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-  private Retrofit retrofit;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl("http://localhost:1")
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
-
-  @Test public void nullSchedulerThrows() {
-    try {
-      RxJavaCallAdapterFactory.createWithScheduler(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("scheduler == null");
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+    private final CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    private Retrofit retrofit;
+
+    @Before
+    public void setUp() {
+        retrofit = new Retrofit.Builder()
+                .baseUrl("http://localhost:1")
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(factory)
+                .build();
     }
-  }
-
-  @Test public void nonRxJavaTypeReturnsNull() {
-    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void responseTypes() {
-    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
-    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
-    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
-    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
-    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
-    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
-    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-
-    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
-    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
-    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
-    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
-    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-
-    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
-    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void rawBodyTypeThrows() {
-    Type observableType = new TypeToken<Observable>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+
+    @Test
+    public void nullSchedulerThrows() {
+        try {
+            RxJavaCallAdapterFactory.createWithScheduler(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("scheduler == null");
+        }
     }
 
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    @Test
+    public void nonRxJavaTypeReturnsNull() {
+        CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+        assertThat(adapter).isNull();
     }
-  }
-
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+
+    @Test
+    public void responseTypes() {
+        Type oBodyClass = new TypeToken<Observable<String>>() {
+        }.getType();
+        assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sBodyClass = new TypeToken<Single<String>>() {
+        }.getType();
+        assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sBodyWildcard = new TypeToken<Single<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+        Type sBodyGeneric = new TypeToken<Single<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
+
+        Type oResponseClass = new TypeToken<Observable<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResponseClass = new TypeToken<Single<Response<String>>>() {
+        }.getType();
+        assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResultClass = new TypeToken<Observable<Result<String>>>() {
+        }.getType();
+        assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResultClass = new TypeToken<Single<Result<String>>>() {
+        }.getType();
+        assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+
+        Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {
+        }.getType();
+        assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
     }
 
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    @Test
+    public void rawBodyTypeThrows() {
+        Type observableType = new TypeToken<Observable>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+        }
     }
-  }
-
-  @Test public void rawResultTypeThrows() {
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+
+    @Test
+    public void rawResponseTypeThrows() {
+        Type observableType = new TypeToken<Observable<Response>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single<Response>>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+        }
     }
 
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
-    try {
-      factory.get(singleType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    @Test
+    public void rawResultTypeThrows() {
+        Type observableType = new TypeToken<Observable<Result>>() {
+        }.getType();
+        try {
+            factory.get(observableType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+        }
+
+        Type singleType = new TypeToken<Single<Result>>() {
+        }.getType();
+        try {
+            factory.get(singleType, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage(
+                    "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
index dfe336f07..b756b2151 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/RxJavaPluginsResetRule.java
@@ -18,20 +18,23 @@
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
+
 import rx.plugins.RxJavaPlugins;
 
 /** A JUnit @Rule which resets RxJava's plugins before and after each test. */
 final class RxJavaPluginsResetRule implements TestRule {
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        RxJavaPlugins.getInstance().reset();
-        try {
-          base.evaluate();
-        } finally {
-          RxJavaPlugins.getInstance().reset();
-        }
-      }
-    };
-  }
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                RxJavaPlugins.getInstance().reset();
+                try {
+                    base.evaluate();
+                } finally {
+                    RxJavaPlugins.getInstance().reset();
+                }
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
index c4c35ab45..379eb8804 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleTest.java
@@ -16,12 +16,15 @@
 package retrofit2.adapter.rxjava;
 
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -31,143 +34,167 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SingleTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule pluginsReset = new RxJavaPluginsResetRule();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertValue("Hi").assertCompleted();
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void bodyThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onNext(String value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
-    subscriber.assertCompleted();
-  }
-
-  @Test public void responseSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().code()).isEqualTo(404);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void responseThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onNext(Response<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultSuccess404() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void resultThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule pluginsReset = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertValue("Hi").assertCompleted();
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void bodyThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().unsafeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+            @Override
+            public void onNext(String value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().body()).isEqualTo("Hi");
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void responseSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().code()).isEqualTo(404);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().unsafeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+            @Override
+            public void onNext(Response<String> value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().response().body()).isEqualTo("Hi");
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultSuccess404() throws IOException {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().response().code()).isEqualTo(404);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        assertThat(subscriber.takeValue().error()).isInstanceOf(IOException.class);
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void resultThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().unsafeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+            @Override
+            public void onNext(Result<String> value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
index 5188c0ed9..75fa7ea64 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/SingleWithSchedulerTest.java
@@ -17,9 +17,11 @@
 
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -27,57 +29,68 @@
 import rx.schedulers.TestScheduler;
 
 public final class SingleWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().unsafeSubscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertCompleted();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().unsafeSubscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertCompleted();
+    }
 }
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
index c44038d02..250dd70d6 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit2/adapter/rxjava/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/rxjava2/pom.xml b/retrofit-adapters/rxjava2/pom.xml
index 354834586..90bc1987e 100644
--- a/retrofit-adapters/rxjava2/pom.xml
+++ b/retrofit-adapters/rxjava2/pom.xml
@@ -1,48 +1,49 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-adapters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>adapter-rxjava2</artifactId>
-  <name>Adapter: RxJava 2</name>
+    <artifactId>adapter-rxjava2</artifactId>
+    <name>Adapter: RxJava 2</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex.rxjava2</groupId>
-      <artifactId>rxjava</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.reactivex.rxjava2</groupId>
+            <artifactId>rxjava</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
index 2f1a234d7..2f7978b1a 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/BodyObservable.java
@@ -24,60 +24,67 @@
 import retrofit2.Response;
 
 final class BodyObservable<T> extends Observable<T> {
-  private final Observable<Response<T>> upstream;
+    private final Observable<Response<T>> upstream;
 
-  BodyObservable(Observable<Response<T>> upstream) {
-    this.upstream = upstream;
-  }
+    BodyObservable(Observable<Response<T>> upstream) {
+        this.upstream = upstream;
+    }
 
-  @Override protected void subscribeActual(Observer<? super T> observer) {
-    upstream.subscribe(new BodyObserver<>(observer));
-  }
+    @Override
+    protected void subscribeActual(Observer<? super T> observer) {
+        upstream.subscribe(new BodyObserver<>(observer));
+    }
 
-  private static class BodyObserver<R> implements Observer<Response<R>> {
-    private final Observer<? super R> observer;
-    private boolean terminated;
+    private static class BodyObserver<R> implements Observer<Response<R>> {
+        private final Observer<? super R> observer;
+        private boolean terminated;
 
-    BodyObserver(Observer<? super R> observer) {
-      this.observer = observer;
-    }
+        BodyObserver(Observer<? super R> observer) {
+            this.observer = observer;
+        }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      observer.onSubscribe(disposable);
-    }
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            observer.onSubscribe(disposable);
+        }
 
-    @Override public void onNext(Response<R> response) {
-      if (response.isSuccessful()) {
-        observer.onNext(response.body());
-      } else {
-        terminated = true;
-        Throwable t = new HttpException(response);
-        try {
-          observer.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          RxJavaPlugins.onError(new CompositeException(t, inner));
+        @Override
+        public void onNext(Response<R> response) {
+            if (response.isSuccessful()) {
+                observer.onNext(response.body());
+            }
+            else {
+                terminated = true;
+                Throwable t = new HttpException(response);
+                try {
+                    observer.onError(t);
+                } catch (Throwable inner) {
+                    Exceptions.throwIfFatal(inner);
+                    RxJavaPlugins.onError(new CompositeException(t, inner));
+                }
+            }
         }
-      }
-    }
 
-    @Override public void onComplete() {
-      if (!terminated) {
-        observer.onComplete();
-      }
-    }
+        @Override
+        public void onComplete() {
+            if (!terminated) {
+                observer.onComplete();
+            }
+        }
 
-    @Override public void onError(Throwable throwable) {
-      if (!terminated) {
-        observer.onError(throwable);
-      } else {
-        // This should never happen! onNext handles and forwards errors automatically.
-        Throwable broken = new AssertionError(
-            "This should never happen! Report as a bug with the full stacktrace.");
-        //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
-        broken.initCause(throwable);
-        RxJavaPlugins.onError(broken);
-      }
+        @Override
+        public void onError(Throwable throwable) {
+            if (!terminated) {
+                observer.onError(throwable);
+            }
+            else {
+                // This should never happen! onNext handles and forwards errors automatically.
+                Throwable broken = new AssertionError(
+                        "This should never happen! Report as a bug with the full stacktrace.");
+                //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
+                broken.initCause(throwable);
+                RxJavaPlugins.onError(broken);
+            }
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
index d7a4f7197..0fb1088c9 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
@@ -25,55 +25,59 @@
 import retrofit2.Response;
 
 final class CallObservable<T> extends Observable<Response<T>> {
-  private final Call<T> originalCall;
+    private final Call<T> originalCall;
 
-  CallObservable(Call<T> originalCall) {
-    this.originalCall = originalCall;
-  }
+    CallObservable(Call<T> originalCall) {
+        this.originalCall = originalCall;
+    }
 
-  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
-    // Since Call is a one-shot type, clone it for each new observer.
-    Call<T> call = originalCall.clone();
-    observer.onSubscribe(new CallDisposable(call));
+    @Override
+    protected void subscribeActual(Observer<? super Response<T>> observer) {
+        // Since Call is a one-shot type, clone it for each new observer.
+        Call<T> call = originalCall.clone();
+        observer.onSubscribe(new CallDisposable(call));
 
-    boolean terminated = false;
-    try {
-      Response<T> response = call.execute();
-      if (!call.isCanceled()) {
-        observer.onNext(response);
-      }
-      if (!call.isCanceled()) {
-        terminated = true;
-        observer.onComplete();
-      }
-    } catch (Throwable t) {
-      Exceptions.throwIfFatal(t);
-      if (terminated) {
-        RxJavaPlugins.onError(t);
-      } else if (!call.isCanceled()) {
+        boolean terminated = false;
         try {
-          observer.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          RxJavaPlugins.onError(new CompositeException(t, inner));
+            Response<T> response = call.execute();
+            if (!call.isCanceled()) {
+                observer.onNext(response);
+            }
+            if (!call.isCanceled()) {
+                terminated = true;
+                observer.onComplete();
+            }
+        } catch (Throwable t) {
+            Exceptions.throwIfFatal(t);
+            if (terminated) {
+                RxJavaPlugins.onError(t);
+            }
+            else if (!call.isCanceled()) {
+                try {
+                    observer.onError(t);
+                } catch (Throwable inner) {
+                    Exceptions.throwIfFatal(inner);
+                    RxJavaPlugins.onError(new CompositeException(t, inner));
+                }
+            }
         }
-      }
     }
-  }
 
-  private static final class CallDisposable implements Disposable {
-    private final Call<?> call;
+    private static final class CallDisposable implements Disposable {
+        private final Call<?> call;
 
-    CallDisposable(Call<?> call) {
-      this.call = call;
-    }
+        CallDisposable(Call<?> call) {
+            this.call = call;
+        }
 
-    @Override public void dispose() {
-      call.cancel();
-    }
+        @Override
+        public void dispose() {
+            call.cancel();
+        }
 
-    @Override public boolean isDisposed() {
-      return call.isCanceled();
+        @Override
+        public boolean isDisposed() {
+            return call.isCanceled();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
index d612b9d5a..369152b19 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/HttpException.java
@@ -19,36 +19,36 @@
 
 /** Exception for an unexpected, non-2xx HTTP response. */
 public final class HttpException extends Exception {
-  private static String getMessage(Response<?> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return "HTTP " + response.code() + " " + response.message();
-  }
+    private static String getMessage(Response<?> response) {
+        if (response == null) throw new NullPointerException("response == null");
+        return "HTTP " + response.code() + " " + response.message();
+    }
 
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
+    private final int code;
+    private final String message;
+    private final transient Response<?> response;
 
-  public HttpException(Response<?> response) {
-    super(getMessage(response));
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
+    public HttpException(Response<?> response) {
+        super(getMessage(response));
+        this.code = response.code();
+        this.message = response.message();
+        this.response = response;
+    }
 
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
+    /** HTTP status code. */
+    public int code() {
+        return code;
+    }
 
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
+    /** HTTP status message. */
+    public String message() {
+        return message;
+    }
 
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
+    /**
+     * The full HTTP response. This may be null if the exception was serialized.
+     */
+    public Response<?> response() {
+        return response;
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
index dac56cdbb..dfd3ad65e 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/Result.java
@@ -16,50 +16,51 @@
 package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
+
 import retrofit2.Response;
 
 /** The result of executing an HTTP request. */
 public final class Result<T> {
-  public static <T> Result<T> error(Throwable error) {
-    if (error == null) throw new NullPointerException("error == null");
-    return new Result<>(null, error);
-  }
+    public static <T> Result<T> error(Throwable error) {
+        if (error == null) throw new NullPointerException("error == null");
+        return new Result<>(null, error);
+    }
 
-  public static <T> Result<T> response(Response<T> response) {
-    if (response == null) throw new NullPointerException("response == null");
-    return new Result<>(response, null);
-  }
+    public static <T> Result<T> response(Response<T> response) {
+        if (response == null) throw new NullPointerException("response == null");
+        return new Result<>(response, null);
+    }
 
-  private final Response<T> response;
-  private final Throwable error;
+    private final Response<T> response;
+    private final Throwable error;
 
-  private Result(Response<T> response, Throwable error) {
-    this.response = response;
-    this.error = error;
-  }
+    private Result(Response<T> response, Throwable error) {
+        this.response = response;
+        this.error = error;
+    }
 
-  /**
-   * The response received from executing an HTTP request. Only present when {@link #isError()} is
-   * false, null otherwise.
-   */
-  public Response<T> response() {
-    return response;
-  }
+    /**
+     * The response received from executing an HTTP request. Only present when {@link #isError()} is
+     * false, null otherwise.
+     */
+    public Response<T> response() {
+        return response;
+    }
 
-  /**
-   * The error experienced while attempting to execute an HTTP request. Only present when {@link
-   * #isError()} is true, null otherwise.
-   * <p>
-   * If the error is an {@link IOException} then there was a problem with the transport to the
-   * remote server. Any other exception type indicates an unexpected failure and should be
-   * considered fatal (configuration error, programming error, etc.).
-   */
-  public Throwable error() {
-    return error;
-  }
+    /**
+     * The error experienced while attempting to execute an HTTP request. Only present when {@link
+     * #isError()} is true, null otherwise.
+     * <p>
+     * If the error is an {@link IOException} then there was a problem with the transport to the
+     * remote server. Any other exception type indicates an unexpected failure and should be
+     * considered fatal (configuration error, programming error, etc.).
+     */
+    public Throwable error() {
+        return error;
+    }
 
-  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
-  public boolean isError() {
-    return error != null;
-  }
+    /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+    public boolean isError() {
+        return error != null;
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
index 4fb08fbd0..bfdbd1e2d 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/ResultObservable.java
@@ -24,48 +24,53 @@
 import retrofit2.Response;
 
 final class ResultObservable<T> extends Observable<Result<T>> {
-  private final Observable<Response<T>> upstream;
+    private final Observable<Response<T>> upstream;
 
-  ResultObservable(Observable<Response<T>> upstream) {
-    this.upstream = upstream;
-  }
+    ResultObservable(Observable<Response<T>> upstream) {
+        this.upstream = upstream;
+    }
 
-  @Override protected void subscribeActual(Observer<? super Result<T>> observer) {
-    upstream.subscribe(new ResultObserver<T>(observer));
-  }
+    @Override
+    protected void subscribeActual(Observer<? super Result<T>> observer) {
+        upstream.subscribe(new ResultObserver<T>(observer));
+    }
 
-  private static class ResultObserver<R> implements Observer<Response<R>> {
-    private final Observer<? super Result<R>> observer;
+    private static class ResultObserver<R> implements Observer<Response<R>> {
+        private final Observer<? super Result<R>> observer;
 
-    ResultObserver(Observer<? super Result<R>> observer) {
-      this.observer = observer;
-    }
+        ResultObserver(Observer<? super Result<R>> observer) {
+            this.observer = observer;
+        }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      observer.onSubscribe(disposable);
-    }
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            observer.onSubscribe(disposable);
+        }
 
-    @Override public void onNext(Response<R> response) {
-      observer.onNext(Result.response(response));
-    }
+        @Override
+        public void onNext(Response<R> response) {
+            observer.onNext(Result.response(response));
+        }
 
-    @Override public void onError(Throwable throwable) {
-      try {
-        observer.onNext(Result.<R>error(throwable));
-      } catch (Throwable t) {
-        try {
-          observer.onError(t);
-        } catch (Throwable inner) {
-          Exceptions.throwIfFatal(inner);
-          RxJavaPlugins.onError(new CompositeException(t, inner));
+        @Override
+        public void onError(Throwable throwable) {
+            try {
+                observer.onNext(Result.<R>error(throwable));
+            } catch (Throwable t) {
+                try {
+                    observer.onError(t);
+                } catch (Throwable inner) {
+                    Exceptions.throwIfFatal(inner);
+                    RxJavaPlugins.onError(new CompositeException(t, inner));
+                }
+                return;
+            }
+            observer.onComplete();
         }
-        return;
-      }
-      observer.onComplete();
-    }
 
-    @Override public void onComplete() {
-      observer.onComplete();
+        @Override
+        public void onComplete() {
+            observer.onComplete();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index e6b7861cb..3264af1b1 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -18,65 +18,71 @@
 import io.reactivex.BackpressureStrategy;
 import io.reactivex.Observable;
 import io.reactivex.Scheduler;
+
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
-  private final Type responseType;
-  private final Scheduler scheduler;
-  private final boolean isResult;
-  private final boolean isBody;
-  private final boolean isFlowable;
-  private final boolean isSingle;
-  private final boolean isMaybe;
-  private final boolean isCompletable;
+    private final Type responseType;
+    private final Scheduler scheduler;
+    private final boolean isResult;
+    private final boolean isBody;
+    private final boolean isFlowable;
+    private final boolean isSingle;
+    private final boolean isMaybe;
+    private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
-      boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
-    this.responseType = responseType;
-    this.scheduler = scheduler;
-    this.isResult = isResult;
-    this.isBody = isBody;
-    this.isFlowable = isFlowable;
-    this.isSingle = isSingle;
-    this.isMaybe = isMaybe;
-    this.isCompletable = isCompletable;
-  }
+    RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
+            boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
+        this.responseType = responseType;
+        this.scheduler = scheduler;
+        this.isResult = isResult;
+        this.isBody = isBody;
+        this.isFlowable = isFlowable;
+        this.isSingle = isSingle;
+        this.isMaybe = isMaybe;
+        this.isCompletable = isCompletable;
+    }
 
-  @Override public Type responseType() {
-    return responseType;
-  }
+    @Override
+    public Type responseType() {
+        return responseType;
+    }
 
-  @Override public Object adapt(Call<R> call) {
-    Observable<Response<R>> responseObservable = new CallObservable<>(call);
+    @Override
+    public Object adapt(Call<R> call) {
+        Observable<Response<R>> responseObservable = new CallObservable<>(call);
 
-    Observable<?> observable;
-    if (isResult) {
-      observable = new ResultObservable<>(responseObservable);
-    } else if (isBody) {
-      observable = new BodyObservable<>(responseObservable);
-    } else {
-      observable = responseObservable;
-    }
+        Observable<?> observable;
+        if (isResult) {
+            observable = new ResultObservable<>(responseObservable);
+        }
+        else if (isBody) {
+            observable = new BodyObservable<>(responseObservable);
+        }
+        else {
+            observable = responseObservable;
+        }
 
-    if (scheduler != null) {
-      observable = observable.subscribeOn(scheduler);
-    }
+        if (scheduler != null) {
+            observable = observable.subscribeOn(scheduler);
+        }
 
-    if (isFlowable) {
-      return observable.toFlowable(BackpressureStrategy.LATEST);
-    }
-    if (isSingle) {
-      return observable.singleOrError();
-    }
-    if (isMaybe) {
-      return observable.singleElement();
-    }
-    if (isCompletable) {
-      return observable.ignoreElements();
+        if (isFlowable) {
+            return observable.toFlowable(BackpressureStrategy.LATEST);
+        }
+        if (isSingle) {
+            return observable.singleOrError();
+        }
+        if (isMaybe) {
+            return observable.singleElement();
+        }
+        if (isCompletable) {
+            return observable.ignoreElements();
+        }
+        return observable;
     }
-    return observable;
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index b6a92ac24..4a429cfe8 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -21,10 +21,12 @@
 import io.reactivex.Observable;
 import io.reactivex.Scheduler;
 import io.reactivex.Single;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -54,76 +56,78 @@
  * </ul>
  */
 public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
-  /**
-   * Returns an instance which creates synchronous observables that do not operate on any scheduler
-   * by default.
-   */
-  public static RxJava2CallAdapterFactory create() {
-    return new RxJava2CallAdapterFactory(null);
-  }
+    /**
+     * Returns an instance which creates synchronous observables that do not operate on any scheduler
+     * by default.
+     */
+    public static RxJava2CallAdapterFactory create() {
+        return new RxJava2CallAdapterFactory(null);
+    }
+
+    /**
+     * Returns an instance which creates synchronous observables that
+     * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
+     */
+    public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
+        if (scheduler == null) throw new NullPointerException("scheduler == null");
+        return new RxJava2CallAdapterFactory(scheduler);
+    }
 
-  /**
-   * Returns an instance which creates synchronous observables that
-   * {@linkplain Observable#subscribeOn(Scheduler) subscribe on} {@code scheduler} by default.
-   */
-  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
-    if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJava2CallAdapterFactory(scheduler);
-  }
+    private final Scheduler scheduler;
 
-  private final Scheduler scheduler;
+    private RxJava2CallAdapterFactory(Scheduler scheduler) {
+        this.scheduler = scheduler;
+    }
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler) {
-    this.scheduler = scheduler;
-  }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        Class<?> rawType = getRawType(returnType);
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    Class<?> rawType = getRawType(returnType);
+        if (rawType == Completable.class) {
+            // Completable is not parameterized (which is what the rest of this method deals with) so it
+            // can only be created with a single configuration.
+            return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
+        }
 
-    if (rawType == Completable.class) {
-      // Completable is not parameterized (which is what the rest of this method deals with) so it
-      // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
-    }
+        boolean isFlowable = rawType == Flowable.class;
+        boolean isSingle = rawType == Single.class;
+        boolean isMaybe = rawType == Maybe.class;
+        if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
+            return null;
+        }
 
-    boolean isFlowable = rawType == Flowable.class;
-    boolean isSingle = rawType == Single.class;
-    boolean isMaybe = rawType == Maybe.class;
-    if (rawType != Observable.class && !isFlowable && !isSingle && !isMaybe) {
-      return null;
-    }
+        boolean isResult = false;
+        boolean isBody = false;
+        Type responseType;
+        if (!(returnType instanceof ParameterizedType)) {
+            String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
+            throw new IllegalStateException(name + " return type must be parameterized"
+                    + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+        }
 
-    boolean isResult = false;
-    boolean isBody = false;
-    Type responseType;
-    if (!(returnType instanceof ParameterizedType)) {
-      String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
-    }
+        Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
+        Class<?> rawObservableType = getRawType(observableType);
+        if (rawObservableType == Response.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Response must be parameterized"
+                        + " as Response<Foo> or Response<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+        }
+        else if (rawObservableType == Result.class) {
+            if (!(observableType instanceof ParameterizedType)) {
+                throw new IllegalStateException("Result must be parameterized"
+                        + " as Result<Foo> or Result<? extends Foo>");
+            }
+            responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
+            isResult = true;
+        }
+        else {
+            responseType = observableType;
+            isBody = true;
+        }
 
-    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
-    Class<?> rawObservableType = getRawType(observableType);
-    if (rawObservableType == Response.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Response must be parameterized"
-            + " as Response<Foo> or Response<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-    } else if (rawObservableType == Result.class) {
-      if (!(observableType instanceof ParameterizedType)) {
-        throw new IllegalStateException("Result must be parameterized"
-            + " as Result<Foo> or Result<? extends Foo>");
-      }
-      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);
-      isResult = true;
-    } else {
-      responseType = observableType;
-      isBody = true;
+        return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
+                isSingle, isMaybe, false);
     }
-
-    return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
-        isSingle, isMaybe, false);
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
index 64fb3870a..5380c5dcb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableTest.java
@@ -16,57 +16,68 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Completable;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 
 public final class CompletableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingCompletableObserver.Rule observerRule =
-      new RecordingCompletableObserver.Rule();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void completableSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingCompletableObserver observer = observerRule.create();
-    service.completable().subscribe(observer);
-    observer.assertComplete();
-  }
-
-  @Test public void completableSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingCompletableObserver observer = observerRule.create();
-    service.completable().subscribe(observer);
-    observer.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void completableFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingCompletableObserver observer = observerRule.create();
-    service.completable().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingCompletableObserver.Rule observerRule =
+            new RecordingCompletableObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void completableSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingCompletableObserver observer = observerRule.create();
+        service.completable().subscribe(observer);
+        observer.assertComplete();
+    }
+
+    @Test
+    public void completableSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingCompletableObserver observer = observerRule.create();
+        service.completable().subscribe(observer);
+        observer.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void completableFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingCompletableObserver observer = observerRule.create();
+        service.completable().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
index 535fdeeed..eb9ba5233 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -22,105 +22,123 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Consumer;
 import io.reactivex.plugins.RxJavaPlugins;
+
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class CompletableThrowingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
-  @Rule public final RecordingCompletableObserver.Rule observerRule =
-      new RecordingCompletableObserver.Rule();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void throwingInOnCompleteDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
-        }
-      }
-    });
-
-    RecordingCompletableObserver observer = observerRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    assertThat(errorRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!pluginRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
-        }
-      }
-    });
-
-    RecordingCompletableObserver observer = observerRule.create();
-    final RuntimeException e = new RuntimeException();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
-      @Override public void onError(Throwable throwable) {
-        errorRef.set(throwable);
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) pluginRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  private static abstract class ForwardingCompletableObserver implements CompletableObserver {
-    private final CompletableObserver delegate;
-
-    ForwardingCompletableObserver(CompletableObserver delegate) {
-      this.delegate = delegate;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule resetRule = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingCompletableObserver.Rule observerRule =
+            new RecordingCompletableObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
     }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      delegate.onSubscribe(disposable);
+    @Test
+    public void throwingInOnCompleteDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+                }
+            }
+        });
+
+        RecordingCompletableObserver observer = observerRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        assertThat(errorRef.get()).isSameAs(e);
     }
 
-    @Override public void onComplete() {
-      delegate.onComplete();
+    @Test
+    public void bodyThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!pluginRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
+                }
+            }
+        });
+
+        RecordingCompletableObserver observer = observerRule.create();
+        final RuntimeException e = new RuntimeException();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        service.completable().subscribe(new ForwardingCompletableObserver(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                errorRef.set(throwable);
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) pluginRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onError(Throwable throwable) {
-      delegate.onError(throwable);
+    private static abstract class ForwardingCompletableObserver implements CompletableObserver {
+        private final CompletableObserver delegate;
+
+        ForwardingCompletableObserver(CompletableObserver delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            delegate.onSubscribe(disposable);
+        }
+
+        @Override
+        public void onComplete() {
+            delegate.onComplete();
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            delegate.onError(throwable);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
index b4a4bc9a2..a6cfe1e28 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableWithSchedulerTest.java
@@ -19,40 +19,47 @@
 import io.reactivex.schedulers.TestScheduler;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 public final class CompletableWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingCompletableObserver.Rule observerRule =
-      new RecordingCompletableObserver.Rule();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void completableUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingCompletableObserver observer = observerRule.create();
-    service.completable().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertComplete();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingCompletableObserver.Rule observerRule =
+            new RecordingCompletableObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Completable completable();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void completableUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingCompletableObserver observer = observerRule.create();
+        service.completable().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertComplete();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
index 042b8028d..2f8ab3f87 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableTest.java
@@ -16,12 +16,16 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Flowable;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -30,157 +34,177 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FlowableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Flowable<String> body();
-    @GET("/") Flowable<Response<String>> response();
-    @GET("/") Flowable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().subscribe(subscriber);
-    subscriber.assertValue("Hi").assertComplete();
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().subscribe(subscriber);
-    subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    service.body().subscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void bodyRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
-    Flowable<String> o = service.body();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.request(1);
-    subscriber.assertAnyValue().assertComplete();
-
-    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().subscribe(subscriber);
-    assertThat(subscriber.takeValue().isSuccessful()).isTrue();
-    subscriber.assertComplete();
-  }
-
-  @Test public void responseSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().subscribe(subscriber);
-    assertThat(subscriber.takeValue().isSuccessful()).isFalse();
-    subscriber.assertComplete();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    service.response().subscribe(subscriber);
-    subscriber.assertError(IOException.class);
-  }
-
-  @Test public void responseRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
-    Flowable<Response<String>> o = service.response();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.request(1);
-    subscriber.assertAnyValue().assertComplete();
-
-    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isTrue();
-    subscriber.assertComplete();
-  }
-
-  @Test public void resultSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isFalse();
-    subscriber.assertComplete();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    service.result().subscribe(subscriber);
-    Result<String> result = subscriber.takeValue();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-    subscriber.assertComplete();
-  }
-
-  @Test public void resultRespectsBackpressure() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
-    Flowable<Result<String>> o = service.result();
-
-    o.subscribe(subscriber);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    subscriber.assertNoEvents();
-
-    subscriber.request(1);
-    subscriber.assertAnyValue().assertComplete();
-
-    subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Flowable<String> body();
+
+        @GET("/")
+        Flowable<Response<String>> response();
+
+        @GET("/")
+        Flowable<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().subscribe(subscriber);
+        subscriber.assertValue("Hi").assertComplete();
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().subscribe(subscriber);
+        subscriber.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        service.body().subscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void bodyRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<String> subscriber = subscriberRule.createWithInitialRequest(0);
+        Flowable<String> o = service.body();
+
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.request(1);
+        subscriber.assertAnyValue().assertComplete();
+
+        subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().subscribe(subscriber);
+        assertThat(subscriber.takeValue().isSuccessful()).isTrue();
+        subscriber.assertComplete();
+    }
+
+    @Test
+    public void responseSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().subscribe(subscriber);
+        assertThat(subscriber.takeValue().isSuccessful()).isFalse();
+        subscriber.assertComplete();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        service.response().subscribe(subscriber);
+        subscriber.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+        Flowable<Response<String>> o = service.response();
+
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.request(1);
+        subscriber.assertAnyValue().assertComplete();
+
+        subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().subscribe(subscriber);
+        Result<String> result = subscriber.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isTrue();
+        subscriber.assertComplete();
+    }
+
+    @Test
+    public void resultSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().subscribe(subscriber);
+        Result<String> result = subscriber.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isFalse();
+        subscriber.assertComplete();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        service.result().subscribe(subscriber);
+        Result<String> result = subscriber.takeValue();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
+        subscriber.assertComplete();
+    }
+
+    @Test
+    public void resultRespectsBackpressure() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.createWithInitialRequest(0);
+        Flowable<Result<String>> o = service.result();
+
+        o.subscribe(subscriber);
+        assertThat(server.getRequestCount()).isEqualTo(1);
+        subscriber.assertNoEvents();
+
+        subscriber.request(1);
+        subscriber.assertAnyValue().assertComplete();
+
+        subscriber.request(Long.MAX_VALUE); // Subsequent requests do not trigger HTTP or notifications.
+        assertThat(server.getRequestCount()).isEqualTo(1);
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
index 34afbbeef..ede69beb5 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableThrowingTest.java
@@ -20,15 +20,19 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Consumer;
 import io.reactivex.plugins.RxJavaPlugins;
+
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -37,252 +41,290 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FlowableThrowingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Flowable<String> body();
-    @GET("/") Flowable<Response<String>> response();
-    @GET("/") Flowable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().safeSubscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onNext(String value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    subscriber.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<String> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void responseThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().safeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onNext(Response<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    subscriber.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void resultThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        throw e;
-      }
-    });
-
-    subscriber.assertError(e);
-  }
-
-  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().subscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    subscriber.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
-    final RuntimeException first = new RuntimeException();
-    final RuntimeException second = new RuntimeException();
-    service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
-      @Override public void onNext(Result<String> value) {
-        // The only way to trigger onError for a result is if onNext throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
-
-  private static abstract class ForwardingSubscriber<T> implements Subscriber<T> {
-    private final Subscriber<T> delegate;
-
-    ForwardingSubscriber(Subscriber<T> delegate) {
-      this.delegate = delegate;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule resetRule = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Flowable<String> body();
+
+        @GET("/")
+        Flowable<Response<String>> response();
+
+        @GET("/")
+        Flowable<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().safeSubscribe(new ForwardingSubscriber<String>(subscriber) {
+            @Override
+            public void onNext(String value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
+
+    @Test
+    public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        subscriber.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
+
     }
 
-    @Override public void onSubscribe(Subscription subscription) {
-      delegate.onSubscribe(subscription);
+    @Test
+    public void bodyThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<String> subscriber = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingSubscriber<String>(subscriber) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onNext(T value) {
-      delegate.onNext(value);
+    @Test
+    public void responseThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().safeSubscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+            @Override
+            public void onNext(Response<String> value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
+
+    @Test
+    public void responseThrowingInOnCompleteDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        subscriber.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
+    }
+
+    @Test
+    public void responseThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<Response<String>> subscriber = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingSubscriber<Response<String>>(subscriber) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+    }
+
+    @Test
+    public void resultThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+            @Override
+            public void onNext(Result<String> value) {
+                throw e;
+            }
+        });
+
+        subscriber.assertError(e);
+    }
+
+    @Test
+    public void resultThrowingInOnCompletedDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().subscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        subscriber.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
     }
 
-    @Override public void onError(Throwable throwable) {
-      delegate.onError(throwable);
+    @Test
+    public void resultThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSubscriber<Result<String>> subscriber = subscriberRule.create();
+        final RuntimeException first = new RuntimeException();
+        final RuntimeException second = new RuntimeException();
+        service.result().safeSubscribe(new ForwardingSubscriber<Result<String>>(subscriber) {
+            @Override
+            public void onNext(Result<String> value) {
+                // The only way to trigger onError for a result is if onNext throws.
+                throw first;
+            }
+
+            @Override
+            public void onError(Throwable throwable) {
+                throw second;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(first, second);
     }
 
-    @Override public void onComplete() {
-      delegate.onComplete();
+    private static abstract class ForwardingSubscriber<T> implements Subscriber<T> {
+        private final Subscriber<T> delegate;
+
+        ForwardingSubscriber(Subscriber<T> delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            delegate.onSubscribe(subscription);
+        }
+
+        @Override
+        public void onNext(T value) {
+            delegate.onNext(value);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            delegate.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            delegate.onComplete();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
index 946ff51f1..3c8ac7f53 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/FlowableWithSchedulerTest.java
@@ -19,65 +19,78 @@
 import io.reactivex.schedulers.TestScheduler;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 public final class FlowableWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
-
-  interface Service {
-    @GET("/") Flowable<String> body();
-    @GET("/") Flowable<Response<String>> response();
-    @GET("/") Flowable<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Object> subscriber = subscriberRule.create();
-    service.body().subscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertComplete();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Object> subscriber = subscriberRule.create();
-    service.response().subscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertComplete();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSubscriber<Object> subscriber = subscriberRule.create();
-    service.result().subscribe(subscriber);
-    subscriber.assertNoEvents();
-
-    scheduler.triggerActions();
-    subscriber.assertAnyValue().assertComplete();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSubscriber.Rule subscriberRule = new RecordingSubscriber.Rule();
+
+    interface Service {
+        @GET("/")
+        Flowable<String> body();
+
+        @GET("/")
+        Flowable<Response<String>> response();
+
+        @GET("/")
+        Flowable<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Object> subscriber = subscriberRule.create();
+        service.body().subscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertComplete();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Object> subscriber = subscriberRule.create();
+        service.response().subscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertComplete();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSubscriber<Object> subscriber = subscriberRule.create();
+        service.result().subscribe(subscriber);
+        subscriber.assertNoEvents();
+
+        scheduler.triggerActions();
+        subscriber.assertAnyValue().assertComplete();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
index da781ffd0..74dc02cf5 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/HttpExceptionTest.java
@@ -16,26 +16,29 @@
 package retrofit2.adapter.rxjava2;
 
 import org.junit.Test;
+
 import retrofit2.Response;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class HttpExceptionTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    HttpException exception = new HttpException(response);
-    assertThat(exception.code()).isEqualTo(200);
-    assertThat(exception.message()).isEqualTo("OK");
-    assertThat(exception.response()).isSameAs(response);
-  }
+    @Test
+    public void response() {
+        Response<String> response = Response.success("Hi");
+        HttpException exception = new HttpException(response);
+        assertThat(exception.code()).isEqualTo(200);
+        assertThat(exception.message()).isEqualTo("OK");
+        assertThat(exception.response()).isSameAs(response);
+    }
 
-  @Test public void nullResponseThrows() {
-    try {
-      new HttpException(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
+    @Test
+    public void nullResponseThrows() {
+        try {
+            new HttpException(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("response == null");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
index d5eda7d9e..6ae03c46a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeTest.java
@@ -18,9 +18,11 @@
 import io.reactivex.Maybe;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -31,102 +33,119 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class MaybeTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
-
-  interface Service {
-    @GET("/") Maybe<String> body();
-    @GET("/") Maybe<Response<String>> response();
-    @GET("/") Maybe<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingMaybeObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertValue("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingMaybeObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingMaybeObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    Response<String> response = observer.takeValue();
-    assertThat(response.isSuccessful()).isTrue();
-  }
-
-  @Test public void responseSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    assertThat(observer.takeValue().isSuccessful()).isFalse();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingMaybeObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isTrue();
-  }
-
-  @Test public void resultSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isFalse();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingMaybeObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Maybe<String> body();
+
+        @GET("/")
+        Maybe<Response<String>> response();
+
+        @GET("/")
+        Maybe<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingMaybeObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertValue("Hi");
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingMaybeObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingMaybeObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        Response<String> response = observer.takeValue();
+        assertThat(response.isSuccessful()).isTrue();
+    }
+
+    @Test
+    public void responseSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        assertThat(observer.takeValue().isSuccessful()).isFalse();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingMaybeObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isTrue();
+    }
+
+    @Test
+    public void resultSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isFalse();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingMaybeObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
index d5f83e1bd..21fb1418a 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeThrowingTest.java
@@ -24,11 +24,13 @@
 import io.reactivex.plugins.RxJavaPlugins;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -39,207 +41,239 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class MaybeThrowingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
-  @Rule public final RecordingMaybeObserver.Rule subscriberRule = new RecordingMaybeObserver.Rule();
-
-  interface Service {
-    @GET("/") Maybe<String> body();
-    @GET("/") Maybe<Response<String>> response();
-    @GET("/") Maybe<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<String> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onSuccess(String value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<String> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onSuccess(Response<String> value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onSuccess(Result<String> value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException first = new RuntimeException();
-    final RuntimeException second = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onSuccess(Result<String> value) {
-        // The only way to trigger onError for Result is if onSuccess throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
-
-  private static abstract class ForwardingObserver<T> implements MaybeObserver<T> {
-    private final MaybeObserver<T> delegate;
-
-    ForwardingObserver(MaybeObserver<T> delegate) {
-      this.delegate = delegate;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule resetRule = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingMaybeObserver.Rule subscriberRule = new RecordingMaybeObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Maybe<String> body();
+
+        @GET("/")
+        Maybe<Response<String>> response();
+
+        @GET("/")
+        Maybe<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<String> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onSuccess(String value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
     }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      delegate.onSubscribe(disposable);
+    @Test
+    public void bodyThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<String> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onSuccess(T value) {
-      delegate.onSuccess(value);
+    @Test
+    public void responseThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onSuccess(Response<String> value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
     }
 
-    @Override public void onError(Throwable throwable) {
-      delegate.onError(throwable);
+    @Test
+    public void responseThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<Response<String>> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onComplete() {
-      delegate.onComplete();
+    @Test
+    public void resultThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onSuccess(Result<String> value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
+    }
+
+    @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+    @Test
+    public void resultThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingMaybeObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException first = new RuntimeException();
+        final RuntimeException second = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onSuccess(Result<String> value) {
+                // The only way to trigger onError for Result is if onSuccess throws.
+                throw first;
+            }
+
+            @Override
+            public void onError(Throwable throwable) {
+                throw second;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(first, second);
+    }
+
+    private static abstract class ForwardingObserver<T> implements MaybeObserver<T> {
+        private final MaybeObserver<T> delegate;
+
+        ForwardingObserver(MaybeObserver<T> delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            delegate.onSubscribe(disposable);
+        }
+
+        @Override
+        public void onSuccess(T value) {
+            delegate.onSuccess(value);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            delegate.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            delegate.onComplete();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
index 53fe60d94..2a69876af 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/MaybeWithSchedulerTest.java
@@ -19,65 +19,78 @@
 import io.reactivex.schedulers.TestScheduler;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 public final class MaybeWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
-
-  interface Service {
-    @GET("/") Maybe<String> body();
-    @GET("/") Maybe<Response<String>> response();
-    @GET("/") Maybe<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingMaybeObserver<Object> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingMaybeObserver<Object> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingMaybeObserver<Object> observer = observerRule.create();
-    service.result().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingMaybeObserver.Rule observerRule = new RecordingMaybeObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Maybe<String> body();
+
+        @GET("/")
+        Maybe<Response<String>> response();
+
+        @GET("/")
+        Maybe<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingMaybeObserver<Object> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingMaybeObserver<Object> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingMaybeObserver<Object> observer = observerRule.create();
+        service.result().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
index be8f5c31a..2f41c4514 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableTest.java
@@ -16,12 +16,16 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Observable;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -30,106 +34,123 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ObservableTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertValue("Hi").assertComplete();
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    assertThat(observer.takeValue().isSuccessful()).isTrue();
-    observer.assertComplete();
-  }
-
-  @Test public void responseSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    assertThat(observer.takeValue().isSuccessful()).isFalse();
-    observer.assertComplete();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isTrue();
-    observer.assertComplete();
-  }
-
-  @Test public void resultSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isFalse();
-    observer.assertComplete();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-    observer.assertComplete();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertValue("Hi").assertComplete();
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        assertThat(observer.takeValue().isSuccessful()).isTrue();
+        observer.assertComplete();
+    }
+
+    @Test
+    public void responseSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        assertThat(observer.takeValue().isSuccessful()).isFalse();
+        observer.assertComplete();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isTrue();
+        observer.assertComplete();
+    }
+
+    @Test
+    public void resultSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isFalse();
+        observer.assertComplete();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
+        observer.assertComplete();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
index 05c1d4f8f..9bcc97199 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableThrowingTest.java
@@ -22,13 +22,17 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Consumer;
 import io.reactivex.plugins.RxJavaPlugins;
+
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -37,252 +41,290 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ObservableThrowingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
-  @Rule public final RecordingObserver.Rule subscriberRule = new RecordingObserver.Rule();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<String> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onNext(String value) {
-        throw e;
-      }
-    });
-
-    observer.assertError(e);
-  }
-
-  @Test public void bodyThrowingInOnCompleteDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<String> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    observer.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<String> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void responseThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Response<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onNext(Response<String> value) {
-        throw e;
-      }
-    });
-
-    observer.assertError(e);
-  }
-
-  @Test public void responseThrowingInOnCompleteDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<Response<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    observer.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<Response<String>> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void resultThrowingInOnNextDeliveredToError() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onNext(Result<String> value) {
-        throw e;
-      }
-    });
-
-    observer.assertError(e);
-  }
-
-  @Test public void resultThrowingInOnCompletedDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    observer.assertAnyValue();
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException first = new RuntimeException();
-    final RuntimeException second = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onNext(Result<String> value) {
-        // The only way to trigger onError for a result is if onNext throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
-
-  private static abstract class ForwardingObserver<T> implements Observer<T> {
-    private final Observer<T> delegate;
-
-    ForwardingObserver(Observer<T> delegate) {
-      this.delegate = delegate;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule resetRule = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingObserver.Rule subscriberRule = new RecordingObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<String> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onNext(String value) {
+                throw e;
+            }
+        });
+
+        observer.assertError(e);
+    }
+
+    @Test
+    public void bodyThrowingInOnCompleteDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<String> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        observer.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
+
     }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      delegate.onSubscribe(disposable);
+    @Test
+    public void bodyThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<String> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onNext(T value) {
-      delegate.onNext(value);
+    @Test
+    public void responseThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Response<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onNext(Response<String> value) {
+                throw e;
+            }
+        });
+
+        observer.assertError(e);
+    }
+
+    @Test
+    public void responseThrowingInOnCompleteDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<Response<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        observer.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
+    }
+
+    @Test
+    public void responseThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<Response<String>> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+    }
+
+    @Test
+    public void resultThrowingInOnNextDeliveredToError() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onNext(Result<String> value) {
+                throw e;
+            }
+        });
+
+        observer.assertError(e);
+    }
+
+    @Test
+    public void resultThrowingInOnCompletedDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onComplete() {
+                throw e;
+            }
+        });
+
+        observer.assertAnyValue();
+        assertThat(throwableRef.get()).isSameAs(e);
     }
 
-    @Override public void onError(Throwable throwable) {
-      delegate.onError(throwable);
+    @Test
+    public void resultThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException first = new RuntimeException();
+        final RuntimeException second = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onNext(Result<String> value) {
+                // The only way to trigger onError for a result is if onNext throws.
+                throw first;
+            }
+
+            @Override
+            public void onError(Throwable throwable) {
+                throw second;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(first, second);
     }
 
-    @Override public void onComplete() {
-      delegate.onComplete();
+    private static abstract class ForwardingObserver<T> implements Observer<T> {
+        private final Observer<T> delegate;
+
+        ForwardingObserver(Observer<T> delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            delegate.onSubscribe(disposable);
+        }
+
+        @Override
+        public void onNext(T value) {
+            delegate.onNext(value);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            delegate.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            delegate.onComplete();
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
index 2379f2835..470e5d6b6 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ObservableWithSchedulerTest.java
@@ -19,65 +19,78 @@
 import io.reactivex.schedulers.TestScheduler;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 public final class ObservableWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
-
-  interface Service {
-    @GET("/") Observable<String> body();
-    @GET("/") Observable<Response<String>> response();
-    @GET("/") Observable<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Object> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue().assertComplete();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Object> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue().assertComplete();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingObserver<Object> observer = observerRule.create();
-    service.result().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue().assertComplete();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingObserver.Rule observerRule = new RecordingObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Observable<String> body();
+
+        @GET("/")
+        Observable<Response<String>> response();
+
+        @GET("/")
+        Observable<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Object> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue().assertComplete();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Object> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue().assertComplete();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingObserver<Object> observer = observerRule.create();
+        service.result().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue().assertComplete();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
index de7c93055..63551d663 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingCompletableObserver.java
@@ -18,10 +18,12 @@
 import io.reactivex.CompletableObserver;
 import io.reactivex.Notification;
 import io.reactivex.disposables.Disposable;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -30,85 +32,90 @@
 
 /** A test {@link CompletableObserver} and JUnit rule which guarantees all events are asserted. */
 final class RecordingCompletableObserver implements CompletableObserver {
-  private final Deque<Notification<?>> events = new ArrayDeque<>();
+    private final Deque<Notification<?>> events = new ArrayDeque<>();
 
-  private RecordingCompletableObserver() {
-  }
+    private RecordingCompletableObserver() {
+    }
 
-  @Override public void onSubscribe(Disposable disposable) {
-  }
+    @Override
+    public void onSubscribe(Disposable disposable) {
+    }
 
-  @Override public void onComplete() {
-    events.add(Notification.createOnComplete());
-  }
+    @Override
+    public void onComplete() {
+        events.add(Notification.createOnComplete());
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.createOnError(e));
+    }
+
+    private Notification<?> takeNotification() {
+        Notification<?> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
 
-  @Override public void onError(Throwable e) {
-    events.add(Notification.createOnError(e));
-  }
+    public Throwable takeError() {
+        Notification<?> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .as("Expected onError event but was " + notification)
+                .isTrue();
+        return notification.getError();
+    }
 
-  private Notification<?> takeNotification() {
-    Notification<?> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
+    public void assertComplete() {
+        Notification<?> notification = takeNotification();
+        assertThat(notification.isOnComplete())
+                .as("Expected onCompleted event but was " + notification)
+                .isTrue();
+        assertNoEvents();
     }
-    return notification;
-  }
-
-  public Throwable takeError() {
-    Notification<?> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .as("Expected onError event but was " + notification)
-        .isTrue();
-    return notification.getError();
-  }
-
-  public void assertComplete() {
-    Notification<?> notification = takeNotification();
-    assertThat(notification.isOnComplete())
-        .as("Expected onCompleted event but was " + notification)
-        .isTrue();
-    assertNoEvents();
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
     }
-    assertNoEvents();
-  }
 
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
 
-  public static final class Rule implements TestRule {
-    final List<RecordingCompletableObserver> subscribers = new ArrayList<>();
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
 
-    public <T> RecordingCompletableObserver create() {
-      RecordingCompletableObserver subscriber = new RecordingCompletableObserver();
-      subscribers.add(subscriber);
-      return subscriber;
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
     }
 
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingCompletableObserver subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    public static final class Rule implements TestRule {
+        final List<RecordingCompletableObserver> subscribers = new ArrayList<>();
+
+        public <T> RecordingCompletableObserver create() {
+            RecordingCompletableObserver subscriber = new RecordingCompletableObserver();
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingCompletableObserver subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
index 63d34499f..a5dd99de4 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingMaybeObserver.java
@@ -19,6 +19,7 @@
 import io.reactivex.Notification;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -32,99 +33,105 @@
 
 /** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
 final class RecordingMaybeObserver<T> implements MaybeObserver<T> {
-  private final Deque<Notification<T>> events = new ArrayDeque<>();
+    private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+    private RecordingMaybeObserver() {
+    }
 
-  private RecordingMaybeObserver() {
-  }
+    @Override
+    public void onSubscribe(Disposable disposable) {
+    }
+
+    @Override
+    public void onSuccess(T value) {
+        events.add(Notification.createOnNext(value));
+    }
 
-  @Override public void onSubscribe(Disposable disposable) {
-  }
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.<T>createOnError(e));
+    }
+
+    @Override
+    public void onComplete() {
+        events.add(Notification.<T>createOnComplete());
+    }
+
+    private Notification<T> takeNotification() {
+        Notification<T> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
 
-  @Override public void onSuccess(T value) {
-    events.add(Notification.createOnNext(value));
-  }
+    public T takeValue() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnNext())
+                .as("Expected onNext event but was " + notification)
+                .isTrue();
+        return notification.getValue();
+    }
 
-  @Override public void onError(Throwable e) {
-    events.add(Notification.<T>createOnError(e));
-  }
+    public Throwable takeError() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .as("Expected onError event but was " + notification)
+                .isTrue();
+        return notification.getError();
+    }
 
-  @Override public void onComplete() {
-    events.add(Notification.<T>createOnComplete());
-  }
+    public RecordingMaybeObserver<T> assertAnyValue() {
+        takeValue();
+        return this;
+    }
 
-  private Notification<T> takeNotification() {
-    Notification<T> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
+    public RecordingMaybeObserver<T> assertValue(T value) {
+        assertThat(takeValue()).isEqualTo(value);
+        return this;
     }
-    return notification;
-  }
-
-  public T takeValue() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnNext())
-        .as("Expected onNext event but was " + notification)
-        .isTrue();
-    return notification.getValue();
-  }
-
-  public Throwable takeError() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .as("Expected onError event but was " + notification)
-        .isTrue();
-    return notification.getError();
-  }
-
-  public RecordingMaybeObserver<T> assertAnyValue() {
-    takeValue();
-    return this;
-  }
-
-  public RecordingMaybeObserver<T> assertValue(T value) {
-    assertThat(takeValue()).isEqualTo(value);
-    return this;
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
     }
-    assertNoEvents();
-  }
 
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
 
-  public static final class Rule implements TestRule {
-    final List<RecordingMaybeObserver<?>> subscribers = new ArrayList<>();
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
 
-    public <T> RecordingMaybeObserver<T> create() {
-      RecordingMaybeObserver<T> subscriber = new RecordingMaybeObserver<>();
-      subscribers.add(subscriber);
-      return subscriber;
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
     }
 
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingMaybeObserver<?> subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    public static final class Rule implements TestRule {
+        final List<RecordingMaybeObserver<?>> subscribers = new ArrayList<>();
+
+        public <T> RecordingMaybeObserver<T> create() {
+            RecordingMaybeObserver<T> subscriber = new RecordingMaybeObserver<>();
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingMaybeObserver<?> subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
index 033111ff4..194c7139b 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingObserver.java
@@ -18,10 +18,12 @@
 import io.reactivex.Notification;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -30,107 +32,113 @@
 
 /** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
 final class RecordingObserver<T> implements Observer<T> {
-  private final Deque<Notification<T>> events = new ArrayDeque<>();
-
-  private RecordingObserver() {
-  }
-
-  @Override public void onSubscribe(Disposable disposable) {
-  }
-
-  @Override public void onNext(T value) {
-    events.add(Notification.createOnNext(value));
-  }
-
-  @Override public void onComplete() {
-    events.add(Notification.<T>createOnComplete());
-  }
-
-  @Override public void onError(Throwable e) {
-    events.add(Notification.<T>createOnError(e));
-  }
-
-  private Notification<T> takeNotification() {
-    Notification<T> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
-    }
-    return notification;
-  }
-
-  public T takeValue() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnNext())
-        .as("Expected onNext event but was " + notification)
-        .isTrue();
-    return notification.getValue();
-  }
-
-  public Throwable takeError() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .as("Expected onError event but was " + notification)
-        .isTrue();
-    return notification.getError();
-  }
-
-  public RecordingObserver<T> assertAnyValue() {
-    takeValue();
-    return this;
-  }
-
-  public RecordingObserver<T> assertValue(T value) {
-    assertThat(takeValue()).isEqualTo(value);
-    return this;
-  }
-
-  public void assertComplete() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnComplete())
-        .as("Expected onCompleted event but was " + notification)
-        .isTrue();
-    assertNoEvents();
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
-    }
-    assertNoEvents();
-  }
-
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
-
-  public static final class Rule implements TestRule {
-    final List<RecordingObserver<?>> subscribers = new ArrayList<>();
-
-    public <T> RecordingObserver<T> create() {
-      RecordingObserver<T> subscriber = new RecordingObserver<>();
-      subscribers.add(subscriber);
-      return subscriber;
-    }
-
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingObserver<?> subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+    private RecordingObserver() {
+    }
+
+    @Override
+    public void onSubscribe(Disposable disposable) {
+    }
+
+    @Override
+    public void onNext(T value) {
+        events.add(Notification.createOnNext(value));
+    }
+
+    @Override
+    public void onComplete() {
+        events.add(Notification.<T>createOnComplete());
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.<T>createOnError(e));
+    }
+
+    private Notification<T> takeNotification() {
+        Notification<T> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
+
+    public T takeValue() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnNext())
+                .as("Expected onNext event but was " + notification)
+                .isTrue();
+        return notification.getValue();
+    }
+
+    public Throwable takeError() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .as("Expected onError event but was " + notification)
+                .isTrue();
+        return notification.getError();
+    }
+
+    public RecordingObserver<T> assertAnyValue() {
+        takeValue();
+        return this;
+    }
+
+    public RecordingObserver<T> assertValue(T value) {
+        assertThat(takeValue()).isEqualTo(value);
+        return this;
+    }
+
+    public void assertComplete() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnComplete())
+                .as("Expected onCompleted event but was " + notification)
+                .isTrue();
+        assertNoEvents();
+    }
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
+
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
+    }
+
+    public static final class Rule implements TestRule {
+        final List<RecordingObserver<?>> subscribers = new ArrayList<>();
+
+        public <T> RecordingObserver<T> create() {
+            RecordingObserver<T> subscriber = new RecordingObserver<>();
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingObserver<?> subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
index 6c7b61f77..3923d3df1 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSingleObserver.java
@@ -19,10 +19,12 @@
 import io.reactivex.Observer;
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -31,95 +33,100 @@
 
 /** A test {@link Observer} and JUnit rule which guarantees all events are asserted. */
 final class RecordingSingleObserver<T> implements SingleObserver<T> {
-  private final Deque<Notification<T>> events = new ArrayDeque<>();
+    private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+    private RecordingSingleObserver() {
+    }
+
+    @Override
+    public void onSubscribe(Disposable disposable) {
+    }
 
-  private RecordingSingleObserver() {
-  }
+    @Override
+    public void onSuccess(T value) {
+        events.add(Notification.createOnNext(value));
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.<T>createOnError(e));
+    }
+
+    private Notification<T> takeNotification() {
+        Notification<T> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
 
-  @Override public void onSubscribe(Disposable disposable) {
-  }
+    public T takeValue() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnNext())
+                .as("Expected onNext event but was " + notification)
+                .isTrue();
+        return notification.getValue();
+    }
 
-  @Override public void onSuccess(T value) {
-    events.add(Notification.createOnNext(value));
-  }
+    public Throwable takeError() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .as("Expected onError event but was " + notification)
+                .isTrue();
+        return notification.getError();
+    }
 
-  @Override public void onError(Throwable e) {
-    events.add(Notification.<T>createOnError(e));
-  }
+    public RecordingSingleObserver<T> assertAnyValue() {
+        takeValue();
+        return this;
+    }
 
-  private Notification<T> takeNotification() {
-    Notification<T> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
+    public RecordingSingleObserver<T> assertValue(T value) {
+        assertThat(takeValue()).isEqualTo(value);
+        return this;
     }
-    return notification;
-  }
-
-  public T takeValue() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnNext())
-        .as("Expected onNext event but was " + notification)
-        .isTrue();
-    return notification.getValue();
-  }
-
-  public Throwable takeError() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .as("Expected onError event but was " + notification)
-        .isTrue();
-    return notification.getError();
-  }
-
-  public RecordingSingleObserver<T> assertAnyValue() {
-    takeValue();
-    return this;
-  }
-
-  public RecordingSingleObserver<T> assertValue(T value) {
-    assertThat(takeValue()).isEqualTo(value);
-    return this;
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
     }
-    assertNoEvents();
-  }
 
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
 
-  public static final class Rule implements TestRule {
-    final List<RecordingSingleObserver<?>> subscribers = new ArrayList<>();
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
 
-    public <T> RecordingSingleObserver<T> create() {
-      RecordingSingleObserver<T> subscriber = new RecordingSingleObserver<>();
-      subscribers.add(subscriber);
-      return subscriber;
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
     }
 
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingSingleObserver<?> subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    public static final class Rule implements TestRule {
+        final List<RecordingSingleObserver<?>> subscribers = new ArrayList<>();
+
+        public <T> RecordingSingleObserver<T> create() {
+            RecordingSingleObserver<T> subscriber = new RecordingSingleObserver<>();
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingSingleObserver<?> subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
index f81bfd97a..ba8aced6c 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RecordingSubscriber.java
@@ -16,10 +16,12 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Notification;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -30,125 +32,131 @@
 
 /** A test {@link Subscriber} and JUnit rule which guarantees all events are asserted. */
 final class RecordingSubscriber<T> implements Subscriber<T> {
-  private final long initialRequest;
-  private final Deque<Notification<T>> events = new ArrayDeque<>();
-
-  private Subscription subscription;
-
-  private RecordingSubscriber(long initialRequest) {
-    this.initialRequest = initialRequest;
-  }
-
-  @Override public void onSubscribe(Subscription subscription) {
-    this.subscription = subscription;
-
-    subscription.request(initialRequest);
-  }
-
-  @Override public void onNext(T value) {
-    events.add(Notification.createOnNext(value));
-  }
-
-  @Override public void onComplete() {
-    events.add(Notification.<T>createOnComplete());
-  }
-
-  @Override public void onError(Throwable e) {
-    events.add(Notification.<T>createOnError(e));
-  }
-
-  private Notification<T> takeNotification() {
-    Notification<T> notification = events.pollFirst();
-    if (notification == null) {
-      throw new AssertionError("No event found!");
-    }
-    return notification;
-  }
-
-  public T takeValue() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnNext())
-        .as("Expected onNext event but was " + notification)
-        .isTrue();
-    return notification.getValue();
-  }
-
-  public Throwable takeError() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnError())
-        .as("Expected onError event but was " + notification)
-        .isTrue();
-    return notification.getError();
-  }
-
-  public RecordingSubscriber<T> assertAnyValue() {
-    takeValue();
-    return this;
-  }
-
-  public RecordingSubscriber<T> assertValue(T value) {
-    assertThat(takeValue()).isEqualTo(value);
-    return this;
-  }
-
-  public void assertComplete() {
-    Notification<T> notification = takeNotification();
-    assertThat(notification.isOnComplete())
-        .as("Expected onCompleted event but was " + notification)
-        .isTrue();
-    assertNoEvents();
-  }
-
-  public void assertError(Throwable throwable) {
-    assertThat(takeError()).isEqualTo(throwable);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass) {
-    assertError(errorClass, null);
-  }
-
-  public void assertError(Class<? extends Throwable> errorClass, String message) {
-    Throwable throwable = takeError();
-    assertThat(throwable).isInstanceOf(errorClass);
-    if (message != null) {
-      assertThat(throwable).hasMessage(message);
-    }
-    assertNoEvents();
-  }
-
-  public void assertNoEvents() {
-    assertThat(events).as("Unconsumed events found!").isEmpty();
-  }
-
-  public void request(long amount) {
-    if (subscription == null) {
-      throw new IllegalStateException("onSubscribe has not been called yet. Did you subscribe()?");
-    }
-    subscription.request(amount);
-  }
-
-  public static final class Rule implements TestRule {
-    final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
-
-    public <T> RecordingSubscriber<T> create() {
-      return createWithInitialRequest(Long.MAX_VALUE);
-    }
-
-    public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
-      RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
-      subscribers.add(subscriber);
-      return subscriber;
-    }
-
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          for (RecordingSubscriber<?> subscriber : subscribers) {
-            subscriber.assertNoEvents();
-          }
+    private final long initialRequest;
+    private final Deque<Notification<T>> events = new ArrayDeque<>();
+
+    private Subscription subscription;
+
+    private RecordingSubscriber(long initialRequest) {
+        this.initialRequest = initialRequest;
+    }
+
+    @Override
+    public void onSubscribe(Subscription subscription) {
+        this.subscription = subscription;
+
+        subscription.request(initialRequest);
+    }
+
+    @Override
+    public void onNext(T value) {
+        events.add(Notification.createOnNext(value));
+    }
+
+    @Override
+    public void onComplete() {
+        events.add(Notification.<T>createOnComplete());
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        events.add(Notification.<T>createOnError(e));
+    }
+
+    private Notification<T> takeNotification() {
+        Notification<T> notification = events.pollFirst();
+        if (notification == null) {
+            throw new AssertionError("No event found!");
+        }
+        return notification;
+    }
+
+    public T takeValue() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnNext())
+                .as("Expected onNext event but was " + notification)
+                .isTrue();
+        return notification.getValue();
+    }
+
+    public Throwable takeError() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnError())
+                .as("Expected onError event but was " + notification)
+                .isTrue();
+        return notification.getError();
+    }
+
+    public RecordingSubscriber<T> assertAnyValue() {
+        takeValue();
+        return this;
+    }
+
+    public RecordingSubscriber<T> assertValue(T value) {
+        assertThat(takeValue()).isEqualTo(value);
+        return this;
+    }
+
+    public void assertComplete() {
+        Notification<T> notification = takeNotification();
+        assertThat(notification.isOnComplete())
+                .as("Expected onCompleted event but was " + notification)
+                .isTrue();
+        assertNoEvents();
+    }
+
+    public void assertError(Throwable throwable) {
+        assertThat(takeError()).isEqualTo(throwable);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass) {
+        assertError(errorClass, null);
+    }
+
+    public void assertError(Class<? extends Throwable> errorClass, String message) {
+        Throwable throwable = takeError();
+        assertThat(throwable).isInstanceOf(errorClass);
+        if (message != null) {
+            assertThat(throwable).hasMessage(message);
+        }
+        assertNoEvents();
+    }
+
+    public void assertNoEvents() {
+        assertThat(events).as("Unconsumed events found!").isEmpty();
+    }
+
+    public void request(long amount) {
+        if (subscription == null) {
+            throw new IllegalStateException("onSubscribe has not been called yet. Did you subscribe()?");
+        }
+        subscription.request(amount);
+    }
+
+    public static final class Rule implements TestRule {
+        final List<RecordingSubscriber<?>> subscribers = new ArrayList<>();
+
+        public <T> RecordingSubscriber<T> create() {
+            return createWithInitialRequest(Long.MAX_VALUE);
+        }
+
+        public <T> RecordingSubscriber<T> createWithInitialRequest(long initialRequest) {
+            RecordingSubscriber<T> subscriber = new RecordingSubscriber<>(initialRequest);
+            subscribers.add(subscriber);
+            return subscriber;
+        }
+
+        @Override
+        public Statement apply(final Statement base, Description description) {
+            return new Statement() {
+                @Override
+                public void evaluate() throws Throwable {
+                    base.evaluate();
+                    for (RecordingSubscriber<?> subscriber : subscribers) {
+                        subscriber.assertNoEvents();
+                    }
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
index a26043296..5507295d8 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/ResultTest.java
@@ -16,44 +16,50 @@
 package retrofit2.adapter.rxjava2;
 
 import java.io.IOException;
+
 import org.junit.Test;
+
 import retrofit2.Response;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResultTest {
-  @Test public void response() {
-    Response<String> response = Response.success("Hi");
-    Result<String> result = Result.response(response);
-    assertThat(result.isError()).isFalse();
-    assertThat(result.error()).isNull();
-    assertThat(result.response()).isSameAs(response);
-  }
-
-  @Test public void nullResponseThrows() {
-    try {
-      Result.response(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("response == null");
+    @Test
+    public void response() {
+        Response<String> response = Response.success("Hi");
+        Result<String> result = Result.response(response);
+        assertThat(result.isError()).isFalse();
+        assertThat(result.error()).isNull();
+        assertThat(result.response()).isSameAs(response);
+    }
+
+    @Test
+    public void nullResponseThrows() {
+        try {
+            Result.response(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("response == null");
+        }
     }
-  }
-
-  @Test public void error() {
-    Throwable error = new IOException();
-    Result<Object> result = Result.error(error);
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isSameAs(error);
-    assertThat(result.response()).isNull();
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Result.error(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("error == null");
+
+    @Test
+    public void error() {
+        Throwable error = new IOException();
+        Result<Object> result = Result.error(error);
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isSameAs(error);
+        assertThat(result.response()).isNull();
+    }
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Result.error(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("error == null");
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
index 2e97cc6f4..9cc967495 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJavaPluginsResetRule.java
@@ -16,21 +16,24 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.plugins.RxJavaPlugins;
+
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
 final class RxJavaPluginsResetRule implements TestRule {
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        RxJavaPlugins.reset();
-        try {
-          base.evaluate();
-        } finally {
-          RxJavaPlugins.reset();
-        }
-      }
-    };
-  }
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                RxJavaPlugins.reset();
+                try {
+                    base.evaluate();
+                } finally {
+                    RxJavaPlugins.reset();
+                }
+            }
+        };
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
index 9ebe67e94..6d06cedfe 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleTest.java
@@ -16,12 +16,16 @@
 package retrofit2.adapter.rxjava2;
 
 import io.reactivex.Single;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -30,102 +34,119 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SingleTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSingleObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertValue("Hi");
-  }
-
-  @Test public void bodySuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSingleObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(HttpException.class, "HTTP 404 Client Error");
-  }
-
-  @Test public void bodyFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSingleObserver<String> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void responseSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSingleObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    Response<String> response = observer.takeValue();
-    assertThat(response.isSuccessful()).isTrue();
-  }
-
-  @Test public void responseSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSingleObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    assertThat(observer.takeValue().isSuccessful()).isFalse();
-  }
-
-  @Test public void responseFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSingleObserver<Response<String>> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void resultSuccess200() {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RecordingSingleObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isTrue();
-  }
-
-  @Test public void resultSuccess404() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    RecordingSingleObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isFalse();
-    assertThat(result.response().isSuccessful()).isFalse();
-  }
-
-  @Test public void resultFailure() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    RecordingSingleObserver<Result<String>> observer = observerRule.create();
-    service.result().subscribe(observer);
-    Result<String> result = observer.takeValue();
-    assertThat(result.isError()).isTrue();
-    assertThat(result.error()).isInstanceOf(IOException.class);
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
+    }
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodySuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSingleObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertValue("Hi");
+    }
+
+    @Test
+    public void bodySuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSingleObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(HttpException.class, "HTTP 404 Client Error");
+    }
+
+    @Test
+    public void bodyFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSingleObserver<String> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void responseSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSingleObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        Response<String> response = observer.takeValue();
+        assertThat(response.isSuccessful()).isTrue();
+    }
+
+    @Test
+    public void responseSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSingleObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        assertThat(observer.takeValue().isSuccessful()).isFalse();
+    }
+
+    @Test
+    public void responseFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSingleObserver<Response<String>> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertError(IOException.class);
+    }
+
+    @Test
+    public void resultSuccess200() {
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RecordingSingleObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isTrue();
+    }
+
+    @Test
+    public void resultSuccess404() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        RecordingSingleObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isFalse();
+        assertThat(result.response().isSuccessful()).isFalse();
+    }
+
+    @Test
+    public void resultFailure() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        RecordingSingleObserver<Result<String>> observer = observerRule.create();
+        service.result().subscribe(observer);
+        Result<String> result = observer.takeValue();
+        assertThat(result.isError()).isTrue();
+        assertThat(result.error()).isInstanceOf(IOException.class);
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
index 294722783..8286c7427 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleThrowingTest.java
@@ -22,14 +22,18 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Consumer;
 import io.reactivex.plugins.RxJavaPlugins;
+
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
@@ -38,203 +42,234 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SingleThrowingTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final TestRule resetRule = new RxJavaPluginsResetRule();
-  @Rule public final RecordingSingleObserver.Rule subscriberRule = new RecordingSingleObserver.Rule();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<String> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onSuccess(String value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<String> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.body().subscribe(new ForwardingObserver<String>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void responseThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onSuccess(Response<String> value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Test public void responseThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    final RuntimeException e = new RuntimeException();
-    service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
-      @Override public void onError(Throwable throwable) {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-        throw e;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-
-  @Test public void resultThrowingInOnSuccessDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException e = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onSuccess(Result<String> value) {
-        throw e;
-      }
-    });
-
-    assertThat(throwableRef.get()).isSameAs(e);
-  }
-
-  @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
-  @Test public void resultThrowingInOnErrorDeliveredToPlugin() {
-    server.enqueue(new MockResponse());
-
-    final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!throwableRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable);
-        }
-      }
-    });
-
-    RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
-    final RuntimeException first = new RuntimeException();
-    final RuntimeException second = new RuntimeException();
-    service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
-      @Override public void onSuccess(Result<String> value) {
-        // The only way to trigger onError for Result is if onSuccess throws.
-        throw first;
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw second;
-      }
-    });
-
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) throwableRef.get();
-    assertThat(composite.getExceptions()).containsExactly(first, second);
-  }
-
-  private static abstract class ForwardingObserver<T> implements SingleObserver<T> {
-    private final SingleObserver<T> delegate;
-
-    ForwardingObserver(SingleObserver<T> delegate) {
-      this.delegate = delegate;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final TestRule resetRule = new RxJavaPluginsResetRule();
+    @Rule
+    public final RecordingSingleObserver.Rule subscriberRule = new RecordingSingleObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
     }
 
-    @Override public void onSubscribe(Disposable disposable) {
-      delegate.onSubscribe(disposable);
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<String> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onSuccess(String value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
     }
 
-    @Override public void onSuccess(T value) {
-      delegate.onSuccess(value);
+    @Test
+    public void bodyThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setResponseCode(404));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<String> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.body().subscribe(new ForwardingObserver<String>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
     }
 
-    @Override public void onError(Throwable throwable) {
-      delegate.onError(throwable);
+    @Test
+    public void responseThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onSuccess(Response<String> value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
+    }
+
+    @Test
+    public void responseThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<Response<String>> observer = subscriberRule.create();
+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();
+        final RuntimeException e = new RuntimeException();
+        service.response().subscribe(new ForwardingObserver<Response<String>>(observer) {
+            @Override
+            public void onError(Throwable throwable) {
+                if (!errorRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+                throw e;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
+    }
+
+    @Test
+    public void resultThrowingInOnSuccessDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException e = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onSuccess(Result<String> value) {
+                throw e;
+            }
+        });
+
+        assertThat(throwableRef.get()).isSameAs(e);
+    }
+
+    @Ignore("Single's contract is onNext|onError so we have no way of triggering this case")
+    @Test
+    public void resultThrowingInOnErrorDeliveredToPlugin() {
+        server.enqueue(new MockResponse());
+
+        final AtomicReference<Throwable> throwableRef = new AtomicReference<>();
+        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable throwable) throws Exception {
+                if (!throwableRef.compareAndSet(null, throwable)) {
+                    throw Exceptions.propagate(throwable);
+                }
+            }
+        });
+
+        RecordingSingleObserver<Result<String>> observer = subscriberRule.create();
+        final RuntimeException first = new RuntimeException();
+        final RuntimeException second = new RuntimeException();
+        service.result().subscribe(new ForwardingObserver<Result<String>>(observer) {
+            @Override
+            public void onSuccess(Result<String> value) {
+                // The only way to trigger onError for Result is if onSuccess throws.
+                throw first;
+            }
+
+            @Override
+            public void onError(Throwable throwable) {
+                throw second;
+            }
+        });
+
+        //noinspection ThrowableResultOfMethodCallIgnored
+        CompositeException composite = (CompositeException) throwableRef.get();
+        assertThat(composite.getExceptions()).containsExactly(first, second);
+    }
+
+    private static abstract class ForwardingObserver<T> implements SingleObserver<T> {
+        private final SingleObserver<T> delegate;
+
+        ForwardingObserver(SingleObserver<T> delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public void onSubscribe(Disposable disposable) {
+            delegate.onSubscribe(disposable);
+        }
+
+        @Override
+        public void onSuccess(T value) {
+            delegate.onSuccess(value);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            delegate.onError(throwable);
+        }
     }
-  }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
index 5198d7bf3..7a8ef25eb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/SingleWithSchedulerTest.java
@@ -19,65 +19,78 @@
 import io.reactivex.schedulers.TestScheduler;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Response;
 import retrofit2.Retrofit;
 import retrofit2.http.GET;
 
 public final class SingleWithSchedulerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
-
-  interface Service {
-    @GET("/") Single<String> body();
-    @GET("/") Single<Response<String>> response();
-    @GET("/") Single<Result<String>> result();
-  }
-
-  private final TestScheduler scheduler = new TestScheduler();
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSingleObserver<Object> observer = observerRule.create();
-    service.body().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
-
-  @Test public void responseUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSingleObserver<Object> observer = observerRule.create();
-    service.response().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
-
-  @Test public void resultUsesScheduler() {
-    server.enqueue(new MockResponse());
-
-    RecordingSingleObserver<Object> observer = observerRule.create();
-    service.result().subscribe(observer);
-    observer.assertNoEvents();
-
-    scheduler.triggerActions();
-    observer.assertAnyValue();
-  }
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+    @Rule
+    public final RecordingSingleObserver.Rule observerRule = new RecordingSingleObserver.Rule();
+
+    interface Service {
+        @GET("/")
+        Single<String> body();
+
+        @GET("/")
+        Single<Response<String>> response();
+
+        @GET("/")
+        Single<Result<String>> result();
+    }
+
+    private final TestScheduler scheduler = new TestScheduler();
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new StringConverterFactory())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(scheduler))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSingleObserver<Object> observer = observerRule.create();
+        service.body().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
+
+    @Test
+    public void responseUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSingleObserver<Object> observer = observerRule.create();
+        service.response().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
+
+    @Test
+    public void resultUsesScheduler() {
+        server.enqueue(new MockResponse());
+
+        RecordingSingleObserver<Object> observer = observerRule.create();
+        service.result().subscribe(observer);
+        observer.assertNoEvents();
+
+        scheduler.triggerActions();
+        observer.assertAnyValue();
+    }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
index 5a6841840..a416f6cfb 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/StringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,22 +26,25 @@
 import retrofit2.Retrofit;
 
 final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        return new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        };
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        return new Converter<String, RequestBody>() {
+            @Override
+            public RequestBody convert(String value) throws IOException {
+                return RequestBody.create(MediaType.parse("text/plain"), value);
+            }
+        };
+    }
 }
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 31f5c1983..ca24d087b 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-gson</artifactId>
-  <name>Converter: Gson</name>
+    <artifactId>converter-gson</artifactId>
+    <name>Converter: Gson</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
index e6c702705..b09719604 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonConverterFactory.java
@@ -18,8 +18,10 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -34,40 +36,40 @@
  * last to allow the other converters a chance to see their types.
  */
 public final class GsonConverterFactory extends Converter.Factory {
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public static GsonConverterFactory create() {
-    return create(new Gson());
-  }
+    /**
+     * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    public static GsonConverterFactory create() {
+        return create(new Gson());
+    }
 
-  /**
-   * Create an instance using {@code gson} for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public static GsonConverterFactory create(Gson gson) {
-    return new GsonConverterFactory(gson);
-  }
+    /**
+     * Create an instance using {@code gson} for conversion. Encoding to JSON and
+     * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+     */
+    public static GsonConverterFactory create(Gson gson) {
+        return new GsonConverterFactory(gson);
+    }
 
-  private final Gson gson;
+    private final Gson gson;
 
-  private GsonConverterFactory(Gson gson) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    this.gson = gson;
-  }
+    private GsonConverterFactory(Gson gson) {
+        if (gson == null) throw new NullPointerException("gson == null");
+        this.gson = gson;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonResponseBodyConverter<>(gson, adapter);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonResponseBodyConverter<>(gson, adapter);
+    }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
-    return new GsonRequestBodyConverter<>(gson, adapter);
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+        return new GsonRequestBodyConverter<>(gson, adapter);
+    }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
index 2e30a4478..2c778e97c 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonRequestBodyConverter.java
@@ -18,33 +18,36 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-  private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private final Gson gson;
-  private final TypeAdapter<T> adapter;
+    private final Gson gson;
+    private final TypeAdapter<T> adapter;
 
-  GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
-    this.gson = gson;
-    this.adapter = adapter;
-  }
+    GsonRequestBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+        this.gson = gson;
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
-    JsonWriter jsonWriter = gson.newJsonWriter(writer);
-    adapter.write(jsonWriter, value);
-    jsonWriter.close();
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+        JsonWriter jsonWriter = gson.newJsonWriter(writer);
+        adapter.write(jsonWriter, value);
+        jsonWriter.close();
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+    }
 }
diff --git a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
index bd9509a18..cd407a9af 100644
--- a/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
+++ b/retrofit-converters/gson/src/main/java/retrofit2/converter/gson/GsonResponseBodyConverter.java
@@ -18,25 +18,28 @@
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final Gson gson;
-  private final TypeAdapter<T> adapter;
+    private final Gson gson;
+    private final TypeAdapter<T> adapter;
 
-  GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
-    this.gson = gson;
-    this.adapter = adapter;
-  }
+    GsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {
+        this.gson = gson;
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    JsonReader jsonReader = gson.newJsonReader(value.charStream());
-    try {
-      return adapter.read(jsonReader);
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        JsonReader jsonReader = gson.newJsonReader(value.charStream());
+        try {
+            return adapter.read(jsonReader);
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
index 5f584ec85..23874c3c2 100644
--- a/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit2/converter/gson/GsonConverterFactoryTest.java
@@ -21,13 +21,17 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -37,108 +41,120 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class GsonConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
+
+    static class AnImplementation implements AnInterface {
+        private final String theName;
+
+        AnImplementation(String name) {
+            theName = name;
+        }
+
+        @Override
+        public String getName() {
+            return theName;
+        }
+    }
+
+    static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
+        @Override
+        public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+            jsonWriter.beginObject();
+            jsonWriter.name("name").value(anInterface.getName());
+            jsonWriter.endObject();
+        }
 
-  static class AnImplementation implements AnInterface {
-    private final String theName;
+        @Override
+        public AnInterface read(JsonReader jsonReader) throws IOException {
+            jsonReader.beginObject();
+
+            String name = null;
+            while (jsonReader.peek() != JsonToken.END_OBJECT) {
+                switch (jsonReader.nextName()) {
+                    case "name":
+                        name = jsonReader.nextString();
+                        break;
+                }
+            }
+
+            jsonReader.endObject();
+            return new AnImplementation(name);
+        }
+    }
 
-    AnImplementation(String name) {
-      theName = name;
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
     }
 
-    @Override public String getName() {
-      return theName;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Gson gson = new GsonBuilder()
+                .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+                .setLenient()
+                .create();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(GsonConverterFactory.create(gson))
+                .build();
+        service = retrofit.create(Service.class);
     }
-  }
 
-  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
-    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
 
-    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
 
-      String name = null;
-      while (jsonReader.peek() != JsonToken.END_OBJECT) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void serializeUsesConfiguration() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{}"));
+
+        service.anImplementation(new AnImplementation(null)).execute();
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void deserializeUsesConfiguration() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
 
-      jsonReader.endObject();
-      return new AnImplementation(name);
+        Response<AnImplementation> response =
+                service.anImplementation(new AnImplementation("value")).execute();
+        assertThat(response.body().getName()).isNull();
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
-        .setLenient()
-        .create();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(GsonConverterFactory.create(gson))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void serializeUsesConfiguration() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{}"));
-
-    service.anImplementation(new AnImplementation(null)).execute();
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{}"); // Null value was not serialized.
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void deserializeUsesConfiguration() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{/* a comment! */}"));
-
-    Response<AnImplementation> response =
-        service.anImplementation(new AnImplementation("value")).execute();
-    assertThat(response.body().getName()).isNull();
-  }
 }
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index e6afa44ee..06022604f 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-jackson</artifactId>
-  <name>Converter: Jackson</name>
+    <artifactId>converter-jackson</artifactId>
+    <name>Converter: Jackson</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.fasterxml.jackson.core</groupId>
-      <artifactId>jackson-databind</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
index 4b224bd97..4daecd87d 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonConverterFactory.java
@@ -19,8 +19,10 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -35,36 +37,36 @@
  * instance} last to allow the other converters a chance to see their types.
  */
 public final class JacksonConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
-  public static JacksonConverterFactory create() {
-    return create(new ObjectMapper());
-  }
+    /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
+    public static JacksonConverterFactory create() {
+        return create(new ObjectMapper());
+    }
 
-  /** Create an instance using {@code mapper} for conversion. */
-  public static JacksonConverterFactory create(ObjectMapper mapper) {
-    return new JacksonConverterFactory(mapper);
-  }
+    /** Create an instance using {@code mapper} for conversion. */
+    public static JacksonConverterFactory create(ObjectMapper mapper) {
+        return new JacksonConverterFactory(mapper);
+    }
 
-  private final ObjectMapper mapper;
+    private final ObjectMapper mapper;
 
-  private JacksonConverterFactory(ObjectMapper mapper) {
-    if (mapper == null) throw new NullPointerException("mapper == null");
-    this.mapper = mapper;
-  }
+    private JacksonConverterFactory(ObjectMapper mapper) {
+        if (mapper == null) throw new NullPointerException("mapper == null");
+        this.mapper = mapper;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectReader reader = mapper.readerFor(javaType);
-    return new JacksonResponseBodyConverter<>(reader);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        JavaType javaType = mapper.getTypeFactory().constructType(type);
+        ObjectReader reader = mapper.readerFor(javaType);
+        return new JacksonResponseBodyConverter<>(reader);
+    }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    JavaType javaType = mapper.getTypeFactory().constructType(type);
-    ObjectWriter writer = mapper.writerFor(javaType);
-    return new JacksonRequestBodyConverter<>(writer);
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        JavaType javaType = mapper.getTypeFactory().constructType(type);
+        ObjectWriter writer = mapper.writerFor(javaType);
+        return new JacksonRequestBodyConverter<>(writer);
+    }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
index bd20a0ae0..103701ae7 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonRequestBodyConverter.java
@@ -16,22 +16,25 @@
 package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectWriter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private final ObjectWriter adapter;
+    private final ObjectWriter adapter;
 
-  JacksonRequestBodyConverter(ObjectWriter adapter) {
-    this.adapter = adapter;
-  }
+    JacksonRequestBodyConverter(ObjectWriter adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    byte[] bytes = adapter.writeValueAsBytes(value);
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        byte[] bytes = adapter.writeValueAsBytes(value);
+        return RequestBody.create(MEDIA_TYPE, bytes);
+    }
 }
diff --git a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
index f51fde7df..b329d5de6 100644
--- a/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit2/converter/jackson/JacksonResponseBodyConverter.java
@@ -16,22 +16,25 @@
 package retrofit2.converter.jackson;
 
 import com.fasterxml.jackson.databind.ObjectReader;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final ObjectReader adapter;
+    private final ObjectReader adapter;
 
-  JacksonResponseBodyConverter(ObjectReader adapter) {
-    this.adapter = adapter;
-  }
+    JacksonResponseBodyConverter(ObjectReader adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return adapter.readValue(value.charStream());
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return adapter.readValue(value.charStream());
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
index 19c18538e..edb29895b 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit2/converter/jackson/JacksonConverterFactoryTest.java
@@ -26,13 +26,17 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+
 import java.io.IOException;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -43,117 +47,127 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterFactoryTest {
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
 
-  static class AnImplementation implements AnInterface {
-    private String theName;
+    static class AnImplementation implements AnInterface {
+        private String theName;
 
-    AnImplementation() {
-    }
+        AnImplementation() {
+        }
+
+        AnImplementation(String name) {
+            theName = name;
+        }
 
-    AnImplementation(String name) {
-      theName = name;
+        @Override
+        public String getName() {
+            return theName;
+        }
     }
 
-    @Override public String getName() {
-      return theName;
+    static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
+        AnInterfaceSerializer() {
+            super(AnInterface.class);
+        }
+
+        @Override
+        public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
+                SerializerProvider serializerProvider) throws IOException {
+            jsonGenerator.writeStartObject();
+            jsonGenerator.writeFieldName("name");
+            jsonGenerator.writeString(anInterface.getName());
+            jsonGenerator.writeEndObject();
+        }
     }
-  }
 
-  static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
-    AnInterfaceSerializer() {
-      super(AnInterface.class);
+    static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
+        AnInterfaceDeserializer() {
+            super(AnInterface.class);
+        }
+
+        @Override
+        public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
+                throws IOException {
+            if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
+                throw new AssertionError("Expected start object.");
+            }
+
+            String name = null;
+
+            while (jp.nextToken() != JsonToken.END_OBJECT) {
+                switch (jp.getCurrentName()) {
+                    case "name":
+                        name = jp.getValueAsString();
+                        break;
+                }
+            }
+
+            return new AnImplementation(name);
+        }
     }
 
-    @Override public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
-        SerializerProvider serializerProvider) throws IOException {
-      jsonGenerator.writeStartObject();
-      jsonGenerator.writeFieldName("name");
-      jsonGenerator.writeString(anInterface.getName());
-      jsonGenerator.writeEndObject();
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
     }
-  }
 
-  static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
-    AnInterfaceDeserializer() {
-      super(AnInterface.class);
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        SimpleModule module = new SimpleModule();
+        module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
+        module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.registerModule(module);
+        mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
+        mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
+        mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
+        mapper.setVisibilityChecker(mapper.getSerializationConfig()
+                                          .getDefaultVisibilityChecker()
+                                          .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(JacksonConverterFactory.create(mapper))
+                .build();
+        service = retrofit.create(Service.class);
     }
 
-    @Override public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
-        throws IOException {
-      if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
-        throw new AssertionError("Expected start object.");
-      }
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
 
-      String name = null;
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
 
-      while (jp.nextToken() != JsonToken.END_OBJECT) {
-        switch (jp.getCurrentName()) {
-          case "name":
-            name = jp.getValueAsString();
-            break;
-        }
-      }
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    }
+
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
 
-      return new AnImplementation(name);
+        RecordedRequest request = server.takeRequest();
+        // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    SimpleModule module = new SimpleModule();
-    module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
-    module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
-    ObjectMapper mapper = new ObjectMapper();
-    mapper.registerModule(module);
-    mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
-    mapper.setVisibilityChecker(mapper.getSerializationConfig()
-        .getDefaultVisibilityChecker()
-        .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(JacksonConverterFactory.create(mapper))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
 }
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 76cd1aaed..6d16d14f9 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -1,49 +1,50 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-moshi</artifactId>
-  <name>Converter: Moshi</name>
+    <artifactId>converter-moshi</artifactId>
+    <name>Converter: Moshi</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-    <!-- TODO remove this dependency once Moshi ships with 1.9.0 or newer. -->
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-      <version>1.9.0</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.moshi</groupId>
+            <artifactId>moshi</artifactId>
+        </dependency>
+        <!-- TODO remove this dependency once Moshi ships with 1.9.0 or newer. -->
+        <dependency>
+            <groupId>com.squareup.okio</groupId>
+            <artifactId>okio</artifactId>
+            <version>1.9.0</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
index 60e5f1bfd..164ae60ae 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiConverterFactory.java
@@ -18,11 +18,13 @@
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.JsonQualifier;
 import com.squareup.moshi.Moshi;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -43,65 +45,65 @@
  * response body converter.
  */
 public final class MoshiConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Moshi} instance for conversion. */
-  public static MoshiConverterFactory create() {
-    return create(new Moshi.Builder().build());
-  }
+    /** Create an instance using a default {@link Moshi} instance for conversion. */
+    public static MoshiConverterFactory create() {
+        return create(new Moshi.Builder().build());
+    }
 
-  /** Create an instance using {@code moshi} for conversion. */
-  public static MoshiConverterFactory create(Moshi moshi) {
-    if (moshi == null) throw new NullPointerException("moshi == null");
-    return new MoshiConverterFactory(moshi, false, false);
-  }
+    /** Create an instance using {@code moshi} for conversion. */
+    public static MoshiConverterFactory create(Moshi moshi) {
+        if (moshi == null) throw new NullPointerException("moshi == null");
+        return new MoshiConverterFactory(moshi, false, false);
+    }
 
-  private final Moshi moshi;
-  private final boolean lenient;
-  private final boolean serializeNulls;
+    private final Moshi moshi;
+    private final boolean lenient;
+    private final boolean serializeNulls;
 
-  private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean serializeNulls) {
-    this.moshi = moshi;
-    this.lenient = lenient;
-    this.serializeNulls = serializeNulls;
-  }
+    private MoshiConverterFactory(Moshi moshi, boolean lenient, boolean serializeNulls) {
+        this.moshi = moshi;
+        this.lenient = lenient;
+        this.serializeNulls = serializeNulls;
+    }
 
-  /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
-  public MoshiConverterFactory asLenient() {
-    return new MoshiConverterFactory(moshi, true, serializeNulls);
-  }
+    /** Return a new factory which uses {@linkplain JsonAdapter#lenient() lenient} adapters. */
+    public MoshiConverterFactory asLenient() {
+        return new MoshiConverterFactory(moshi, true, serializeNulls);
+    }
 
-  /** Return a new factory which includes null values into the serialized JSON. */
-  public MoshiConverterFactory withNullSerialization() {
-    return new MoshiConverterFactory(moshi, lenient, true);
-  }
+    /** Return a new factory which includes null values into the serialized JSON. */
+    public MoshiConverterFactory withNullSerialization() {
+        return new MoshiConverterFactory(moshi, lenient, true);
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(annotations));
-    if (lenient) {
-      adapter = adapter.lenient();
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(annotations));
+        if (lenient) {
+            adapter = adapter.lenient();
+        }
+        return new MoshiResponseBodyConverter<>(adapter);
     }
-    return new MoshiResponseBodyConverter<>(adapter);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
-    if (lenient) {
-      adapter = adapter.lenient();
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        JsonAdapter<?> adapter = moshi.adapter(type, jsonAnnotations(parameterAnnotations));
+        if (lenient) {
+            adapter = adapter.lenient();
+        }
+        return new MoshiRequestBodyConverter<>(adapter, serializeNulls);
     }
-    return new MoshiRequestBodyConverter<>(adapter, serializeNulls);
-  }
 
-  private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
-    Set<Annotation> result = null;
-    for (Annotation annotation : annotations) {
-      if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
-        if (result == null) result = new LinkedHashSet<>();
-        result.add(annotation);
-      }
+    private static Set<? extends Annotation> jsonAnnotations(Annotation[] annotations) {
+        Set<Annotation> result = null;
+        for (Annotation annotation : annotations) {
+            if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                if (result == null) result = new LinkedHashSet<>();
+                result.add(annotation);
+            }
+        }
+        return result != null ? unmodifiableSet(result) : Collections.<Annotation>emptySet();
     }
-    return result != null ? unmodifiableSet(result) : Collections.<Annotation>emptySet();
-  }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
index 5e59b17fe..94bfeaa5d 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiRequestBodyConverter.java
@@ -17,28 +17,31 @@
 
 import com.squareup.moshi.JsonAdapter;
 import com.squareup.moshi.JsonWriter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
-  private final JsonAdapter<T> adapter;
-  private final boolean serializeNulls;
+    private final JsonAdapter<T> adapter;
+    private final boolean serializeNulls;
 
-  MoshiRequestBodyConverter(JsonAdapter<T> adapter, boolean serializeNulls) {
-    this.adapter = adapter;
-    this.serializeNulls = serializeNulls;
-  }
+    MoshiRequestBodyConverter(JsonAdapter<T> adapter, boolean serializeNulls) {
+        this.adapter = adapter;
+        this.serializeNulls = serializeNulls;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    JsonWriter writer = JsonWriter.of(buffer);
-    writer.setSerializeNulls(serializeNulls);
-    adapter.toJson(writer, value);
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        JsonWriter writer = JsonWriter.of(buffer);
+        writer.setSerializeNulls(serializeNulls);
+        adapter.toJson(writer, value);
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+    }
 }
diff --git a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
index 199776ff2..6c8a531b0 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit2/converter/moshi/MoshiResponseBodyConverter.java
@@ -16,32 +16,35 @@
 package retrofit2.converter.moshi;
 
 import com.squareup.moshi.JsonAdapter;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import okio.BufferedSource;
 import okio.ByteString;
 import retrofit2.Converter;
 
 final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private static final ByteString UTF8_BOM = ByteString.decodeHex("EFBBBF");
+    private static final ByteString UTF8_BOM = ByteString.decodeHex("EFBBBF");
 
-  private final JsonAdapter<T> adapter;
+    private final JsonAdapter<T> adapter;
 
-  MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    BufferedSource source = value.source();
-    try {
-      // Moshi has no document-level API so the responsibility of BOM skipping falls to whatever
-      // is delegating to it. Since it's a UTF-8-only library as well we only honor the UTF-8 BOM.
-      if (source.rangeEquals(0, UTF8_BOM)) {
-        source.skip(UTF8_BOM.size());
-      }
-      return adapter.fromJson(source);
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        BufferedSource source = value.source();
+        try {
+            // Moshi has no document-level API so the responsibility of BOM skipping falls to whatever
+            // is delegating to it. Since it's a UTF-8-only library as well we only honor the UTF-8 BOM.
+            if (source.rangeEquals(0, UTF8_BOM)) {
+                source.skip(UTF8_BOM.size());
+            }
+            return adapter.fromJson(source);
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
index d22c37267..199726361 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit2/converter/moshi/MoshiConverterFactoryTest.java
@@ -22,20 +22,24 @@
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
 import java.nio.charset.Charset;
 import java.util.Set;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -48,205 +52,229 @@
 import static org.junit.Assert.fail;
 
 public final class MoshiConverterFactoryTest {
-  @Retention(RUNTIME)
-  @JsonQualifier
-  @interface Qualifier {}
+    @Retention(RUNTIME)
+    @JsonQualifier
+    @interface Qualifier {
+    }
 
-  @Retention(RUNTIME)
-  @interface NonQualifer {}
+    @Retention(RUNTIME)
+    @interface NonQualifer {
+    }
 
-  interface AnInterface {
-    String getName();
-  }
+    interface AnInterface {
+        String getName();
+    }
 
-  static class AnImplementation implements AnInterface {
-    private final String theName;
+    static class AnImplementation implements AnInterface {
+        private final String theName;
 
-    AnImplementation(String name) {
-      theName = name;
+        AnImplementation(String name) {
+            theName = name;
+        }
+
+        @Override
+        public String getName() {
+            return theName;
+        }
     }
 
-    @Override public String getName() {
-      return theName;
+    static class Adapters {
+        @ToJson
+        public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+            jsonWriter.beginObject();
+            jsonWriter.name("name").value(anInterface.getName());
+            jsonWriter.endObject();
+        }
+
+        @FromJson
+        public AnInterface read(JsonReader jsonReader) throws IOException {
+            jsonReader.beginObject();
+
+            String name = null;
+            while (jsonReader.hasNext()) {
+                switch (jsonReader.nextName()) {
+                    case "name":
+                        name = jsonReader.nextString();
+                        break;
+                }
+            }
+
+            jsonReader.endObject();
+            return new AnImplementation(name);
+        }
+
+        @ToJson
+        public void write(JsonWriter writer, @Qualifier String value) throws IOException {
+            writer.value("qualified!");
+        }
+
+        @FromJson
+        @Qualifier
+        public String readQualified(JsonReader reader) throws IOException {
+            String string = reader.nextString();
+            if (string.equals("qualified!")) {
+                return "it worked!";
+            }
+            throw new AssertionError("Found: " + string);
+        }
     }
-  }
 
-  static class Adapters {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
+    interface Service {
+        @POST("/")
+        Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+
+        @POST("/")
+        Call<AnInterface> anInterface(@Body AnInterface impl);
+
+        @POST("/")
+        @Qualifier
+        @NonQualifer
+            //
+        Call<String> annotations(@Body @Qualifier @NonQualifer String body);
     }
 
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+    private Service serviceLenient;
+    private Service serviceNulls;
+
+    @Before
+    public void setUp() {
+        Moshi moshi = new Moshi.Builder()
+                .add(new JsonAdapter.Factory() {
+                    @Override
+                    public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
+                            Moshi moshi) {
+                        for (Annotation annotation : annotations) {
+                            if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
+                            }
+                        }
+                        return null;
+                    }
+                })
+                .add(new Adapters())
+                .build();
+        MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
+        MoshiConverterFactory factoryLenient = factory.asLenient();
+        MoshiConverterFactory factoryNulls = factory.withNullSerialization();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(factory)
+                .build();
+        Retrofit retrofitLenient = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(factoryLenient)
+                .build();
+        Retrofit retrofitNulls = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(factoryNulls)
+                .build();
+        service = retrofit.create(Service.class);
+        serviceLenient = retrofitLenient.create(Service.class);
+        serviceNulls = retrofitNulls.create(Service.class);
+    }
 
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
+    @Test
+    public void anInterface() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+        Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+        Response<AnInterface> response = call.execute();
+        AnInterface body = response.body();
+        assertThat(body.getName()).isEqualTo("value");
 
-      jsonReader.endObject();
-      return new AnImplementation(name);
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
 
-    @ToJson public void write(JsonWriter writer, @Qualifier String value) throws IOException {
-      writer.value("qualified!");
+    @Test
+    public void anImplementation() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
 
-    @FromJson @Qualifier public String readQualified(JsonReader reader) throws IOException {
-      String string = reader.nextString();
-      if (string.equals("qualified!")) {
-        return "it worked!";
-      }
-      throw new AssertionError("Found: " + string);
+    @Test
+    public void annotations() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("\"qualified!\""));
+
+        Call<String> call = service.annotations("value");
+        Response<String> response = call.execute();
+        assertThat(response.body()).isEqualTo("it worked!");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
     }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-
-    @POST("/") @Qualifier @NonQualifer //
-    Call<String> annotations(@Body @Qualifier @NonQualifer String body);
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-  private Service serviceLenient;
-  private Service serviceNulls;
-
-  @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new JsonAdapter.Factory() {
-          @Override public JsonAdapter<?> create(Type type, Set<? extends Annotation> annotations,
-              Moshi moshi) {
-            for (Annotation annotation : annotations) {
-              if (!annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
-                throw new AssertionError("Non-@JsonQualifier annotation: " + annotation);
-              }
-            }
-            return null;
-          }
-        })
-        .add(new Adapters())
-        .build();
-    MoshiConverterFactory factory = MoshiConverterFactory.create(moshi);
-    MoshiConverterFactory factoryLenient = factory.asLenient();
-    MoshiConverterFactory factoryNulls = factory.withNullSerialization();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factory)
-        .build();
-    Retrofit retrofitLenient = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factoryLenient)
-        .build();
-    Retrofit retrofitNulls = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(factoryNulls)
-        .build();
-    service = retrofit.create(Service.class);
-    serviceLenient = retrofitLenient.create(Service.class);
-    serviceNulls = retrofitNulls.create(Service.class);
-  }
-
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void annotations() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("\"qualified!\""));
-
-    Call<String> call = service.annotations("value");
-    Response<String> response = call.execute();
-    assertThat(response.body()).isEqualTo("it worked!");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("\"qualified!\"");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
-
-  @Test public void asLenient() throws IOException, InterruptedException {
-    MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
-    server.enqueue(malformedResponse);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertEquals(e.getMessage(),
-          "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+
+    @Test
+    public void asLenient() throws IOException, InterruptedException {
+        MockResponse malformedResponse = new MockResponse().setBody("{\"theName\":value}");
+        server.enqueue(malformedResponse);
+        server.enqueue(malformedResponse);
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertEquals(e.getMessage(),
+                    "Use JsonReader.setLenient(true) to accept malformed JSON at path $.theName");
+        }
+
+        Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call2.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
     }
 
-    Call<AnImplementation> call2 = serviceLenient.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call2.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-  }
-
-  @Test public void withNulls() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{}"));
-
-    Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
-    call.execute();
-    assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void utf8BomSkipped() throws IOException {
-    Buffer responseBody = new Buffer()
-        .write(ByteString.decodeHex("EFBBBF"))
-        .writeUtf8("{\"theName\":\"value\"}");
-    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
-  }
-
-  @Test public void nonUtf8BomIsNotSkipped() throws IOException {
-    Buffer responseBody = new Buffer()
-        .write(ByteString.decodeHex("FEFF"))
-        .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
-    MockResponse malformedResponse = new MockResponse().setBody(responseBody);
-    server.enqueue(malformedResponse);
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
+    @Test
+    public void withNulls() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("{}"));
+
+        Call<AnImplementation> call = serviceNulls.anImplementation(new AnImplementation(null));
+        call.execute();
+        assertEquals("{\"theName\":null}", server.takeRequest().getBody().readUtf8());
+    }
+
+    @Test
+    public void utf8BomSkipped() throws IOException {
+        Buffer responseBody = new Buffer()
+                .write(ByteString.decodeHex("EFBBBF"))
+                .writeUtf8("{\"theName\":\"value\"}");
+        MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+        server.enqueue(malformedResponse);
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        Response<AnImplementation> response = call.execute();
+        AnImplementation body = response.body();
+        assertThat(body.theName).isEqualTo("value");
+    }
+
+    @Test
+    public void nonUtf8BomIsNotSkipped() throws IOException {
+        Buffer responseBody = new Buffer()
+                .write(ByteString.decodeHex("FEFF"))
+                .writeString("{\"theName\":\"value\"}", Charset.forName("UTF-16"));
+        MockResponse malformedResponse = new MockResponse().setBody(responseBody);
+        server.enqueue(malformedResponse);
+
+        Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+        try {
+            call.execute();
+            fail();
+        } catch (IOException expected) {
+        }
     }
-  }
 }
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 3fbbbf17b..0e6c6fa64 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -1,26 +1,27 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-converters</artifactId>
-  <name>Converters</name>
-  <packaging>pom</packaging>
+    <artifactId>retrofit-converters</artifactId>
+    <name>Converters</name>
+    <packaging>pom</packaging>
 
-  <modules>
-    <module>gson</module>
-    <module>protobuf</module>
-    <module>jackson</module>
-    <module>wire</module>
-    <module>simplexml</module>
-    <module>scalars</module>
-    <module>moshi</module>
-  </modules>
+    <modules>
+        <module>gson</module>
+        <module>protobuf</module>
+        <module>jackson</module>
+        <module>wire</module>
+        <module>simplexml</module>
+        <module>scalars</module>
+        <module>moshi</module>
+    </modules>
 </project>
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index 761238f28..c45644197 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-protobuf</artifactId>
-  <name>Converter: Protocol Buffers</name>
+    <artifactId>converter-protobuf</artifactId>
+    <name>Converter: Protocol Buffers</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.protobuf</groupId>
-      <artifactId>protobuf-java</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.protobuf</groupId>
+            <artifactId>protobuf-java</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
index ec2aac452..ecd09f510 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoConverterFactory.java
@@ -18,11 +18,13 @@
 import com.google.protobuf.ExtensionRegistryLite;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -35,63 +37,63 @@
  * subclasses).
  */
 public final class ProtoConverterFactory extends Converter.Factory {
-  public static ProtoConverterFactory create() {
-    return new ProtoConverterFactory(null);
-  }
-
-  /** Create an instance which uses {@code registry} when deserializing. */
-  public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
-    return new ProtoConverterFactory(registry);
-  }
+    public static ProtoConverterFactory create() {
+        return new ProtoConverterFactory(null);
+    }
 
-  private final ExtensionRegistryLite registry;
+    /** Create an instance which uses {@code registry} when deserializing. */
+    public static ProtoConverterFactory createWithRegistry(ExtensionRegistryLite registry) {
+        return new ProtoConverterFactory(registry);
+    }
 
-  private ProtoConverterFactory(ExtensionRegistryLite registry) {
-    this.registry = registry;
-  }
+    private final ExtensionRegistryLite registry;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
-    }
-    Class<?> c = (Class<?>) type;
-    if (!MessageLite.class.isAssignableFrom(c)) {
-      return null;
+    private ProtoConverterFactory(ExtensionRegistryLite registry) {
+        this.registry = registry;
     }
 
-    Parser<MessageLite> parser;
-    try {
-      Method method = c.getDeclaredMethod("parser");
-      //noinspection unchecked
-      parser = (Parser<MessageLite>) method.invoke(null);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(e.getCause());
-    } catch (NoSuchMethodException | IllegalAccessException ignored) {
-      // If the method is missing, fall back to original static field for pre-3.0 support.
-      try {
-        Field field = c.getDeclaredField("PARSER");
-        //noinspection unchecked
-        parser = (Parser<MessageLite>) field.get(null);
-      } catch (NoSuchFieldException | IllegalAccessException e) {
-        throw new IllegalArgumentException("Found a protobuf message but "
-            + c.getName()
-            + " had no parser() method or PARSER field.");
-      }
-    }
-    return new ProtoResponseBodyConverter<>(parser, registry);
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!MessageLite.class.isAssignableFrom(c)) {
+            return null;
+        }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+        Parser<MessageLite> parser;
+        try {
+            Method method = c.getDeclaredMethod("parser");
+            //noinspection unchecked
+            parser = (Parser<MessageLite>) method.invoke(null);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(e.getCause());
+        } catch (NoSuchMethodException | IllegalAccessException ignored) {
+            // If the method is missing, fall back to original static field for pre-3.0 support.
+            try {
+                Field field = c.getDeclaredField("PARSER");
+                //noinspection unchecked
+                parser = (Parser<MessageLite>) field.get(null);
+            } catch (NoSuchFieldException | IllegalAccessException e) {
+                throw new IllegalArgumentException("Found a protobuf message but "
+                        + c.getName()
+                        + " had no parser() method or PARSER field.");
+            }
+        }
+        return new ProtoResponseBodyConverter<>(parser, registry);
     }
-    if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
-      return null;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
+            return null;
+        }
+        return new ProtoRequestBodyConverter<>();
     }
-    return new ProtoRequestBodyConverter<>();
-  }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
index 814dc326b..d515819b4 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoRequestBodyConverter.java
@@ -16,16 +16,19 @@
 package retrofit2.converter.protobuf;
 
 import com.google.protobuf.MessageLite;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public RequestBody convert(T value) throws IOException {
-    byte[] bytes = value.toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        byte[] bytes = value.toByteArray();
+        return RequestBody.create(MEDIA_TYPE, bytes);
+    }
 }
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
index 324199458..73ae0b11f 100644
--- a/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit2/converter/protobuf/ProtoResponseBodyConverter.java
@@ -19,27 +19,30 @@
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ProtoResponseBodyConverter<T extends MessageLite>
-    implements Converter<ResponseBody, T> {
-  private final Parser<T> parser;
-  private final ExtensionRegistryLite registry;
+        implements Converter<ResponseBody, T> {
+    private final Parser<T> parser;
+    private final ExtensionRegistryLite registry;
 
-  ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
-    this.parser = parser;
-    this.registry = registry;
-  }
+    ProtoResponseBodyConverter(Parser<T> parser, ExtensionRegistryLite registry) {
+        this.parser = parser;
+        this.registry = registry;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return parser.parseFrom(value.byteStream(), registry);
-    } catch (InvalidProtocolBufferException e) {
-      throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return parser.parseFrom(value.byteStream(), registry);
+        } catch (InvalidProtocolBufferException e) {
+            throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
index b37ab55bc..2133ee58c 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/FallbackParserFinderTest.java
@@ -17,9 +17,13 @@
 
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
+
 import java.lang.annotation.Annotation;
+
 import okhttp3.ResponseBody;
+
 import org.junit.Test;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 import retrofit2.converter.protobuf.PhoneProtos.Phone;
@@ -27,16 +31,17 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FallbackParserFinderTest {
-  @Test public void converterFactoryFallsBackToParserField() {
-    Retrofit retrofit = new Retrofit.Builder().baseUrl("http://localhost/").build();
-    ProtoConverterFactory factory = ProtoConverterFactory.create();
-    Converter<ResponseBody, ?> converter =
-        factory.responseBodyConverter(FakePhone.class, new Annotation[0], retrofit);
-    assertThat(converter).isNotNull();
-  }
-
-  @SuppressWarnings("unused") // Used reflectively.
-  public static abstract class FakePhone implements MessageLite {
-    public static final Parser<Phone> PARSER = Phone.parser();
-  }
+    @Test
+    public void converterFactoryFallsBackToParserField() {
+        Retrofit retrofit = new Retrofit.Builder().baseUrl("http://localhost/").build();
+        ProtoConverterFactory factory = ProtoConverterFactory.create();
+        Converter<ResponseBody, ?> converter =
+                factory.responseBodyConverter(FakePhone.class, new Annotation[0], retrofit);
+        assertThat(converter).isNotNull();
+    }
+
+    @SuppressWarnings("unused") // Used reflectively.
+    public static abstract class FakePhone implements MessageLite {
+        public static final Parser<Phone> PARSER = Phone.parser();
+    }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
index 3ad1bb0f6..8831130ed 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/PhoneProtos.java
@@ -4,653 +4,715 @@
 package retrofit2.converter.protobuf;
 
 public final class PhoneProtos {
-  private PhoneProtos() {}
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistryLite registry) {
-    registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
-  }
-
-  public static void registerAllExtensions(
-      com.google.protobuf.ExtensionRegistry registry) {
-    registerAllExtensions(
-        (com.google.protobuf.ExtensionRegistryLite) registry);
-  }
-  public interface PhoneOrBuilder extends
-      // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
-      com.google.protobuf.GeneratedMessage.
-          ExtendableMessageOrBuilder<Phone> {
-
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    boolean hasNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    java.lang.String getNumber();
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    com.google.protobuf.ByteString
-        getNumberBytes();
-  }
-  /**
-   * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-   */
-  public  static final class Phone extends
-      com.google.protobuf.GeneratedMessage.ExtendableMessage<
-        Phone> implements
-      // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
-      PhoneOrBuilder {
-    // Use Phone.newBuilder() to construct.
-    private Phone(com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
-      super(builder);
-    }
-    private Phone() {
-      number_ = "";
+    private PhoneProtos() {
     }
 
-    @java.lang.Override
-    public final com.google.protobuf.UnknownFieldSet
-    getUnknownFields() {
-      return this.unknownFields;
-    }
-    private Phone(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      this();
-      int mutable_bitField0_ = 0;
-      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
-          com.google.protobuf.UnknownFieldSet.newBuilder();
-      try {
-        boolean done = false;
-        while (!done) {
-          int tag = input.readTag();
-          switch (tag) {
-            case 0:
-              done = true;
-              break;
-            default: {
-              if (!parseUnknownField(input, unknownFields,
-                                     extensionRegistry, tag)) {
-                done = true;
-              }
-              break;
-            }
-            case 10: {
-              com.google.protobuf.ByteString bs = input.readBytes();
-              bitField0_ |= 0x00000001;
-              number_ = bs;
-              break;
-            }
-          }
-        }
-      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-        throw e.setUnfinishedMessage(this);
-      } catch (java.io.IOException e) {
-        throw new com.google.protobuf.InvalidProtocolBufferException(
-            e).setUnfinishedMessage(this);
-      } finally {
-        this.unknownFields = unknownFields.build();
-        makeExtensionsImmutable();
-      }
-    }
-    public static final com.google.protobuf.Descriptors.Descriptor
-        getDescriptor() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+    public static void registerAllExtensions(
+            com.google.protobuf.ExtensionRegistryLite registry) {
+        registry.add(retrofit2.converter.protobuf.PhoneProtos.voicemail);
     }
 
-    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-        internalGetFieldAccessorTable() {
-      return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-          .ensureFieldAccessorsInitialized(
-              retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+    public static void registerAllExtensions(
+            com.google.protobuf.ExtensionRegistry registry) {
+        registerAllExtensions(
+                (com.google.protobuf.ExtensionRegistryLite) registry);
     }
 
-    private int bitField0_;
-    public static final int NUMBER_FIELD_NUMBER = 1;
-    private volatile java.lang.Object number_;
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public boolean hasNumber() {
-      return ((bitField0_ & 0x00000001) == 0x00000001);
-    }
-    /**
-     * <code>optional string number = 1;</code>
-     */
-    public java.lang.String getNumber() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        return (java.lang.String) ref;
-      } else {
-        com.google.protobuf.ByteString bs = 
-            (com.google.protobuf.ByteString) ref;
-        java.lang.String s = bs.toStringUtf8();
-        if (bs.isValidUtf8()) {
-          number_ = s;
-        }
-        return s;
-      }
+    public interface PhoneOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:retrofit2.converter.protobuf.Phone)
+            com.google.protobuf.GeneratedMessage.
+                    ExtendableMessageOrBuilder<Phone> {
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        boolean hasNumber();
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        java.lang.String getNumber();
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        com.google.protobuf.ByteString
+        getNumberBytes();
     }
+
     /**
-     * <code>optional string number = 1;</code>
+     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
      */
-    public com.google.protobuf.ByteString
+    public static final class Phone extends
+            com.google.protobuf.GeneratedMessage.ExtendableMessage<
+                    Phone> implements
+            // @@protoc_insertion_point(message_implements:retrofit2.converter.protobuf.Phone)
+            PhoneOrBuilder {
+        // Use Phone.newBuilder() to construct.
+        private Phone(
+                com.google.protobuf.GeneratedMessage.ExtendableBuilder<retrofit2.converter.protobuf.PhoneProtos.Phone, ?> builder) {
+            super(builder);
+        }
+
+        private Phone() {
+            number_ = "";
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+
+        private Phone(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            this();
+            int mutable_bitField0_ = 0;
+            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+                    com.google.protobuf.UnknownFieldSet.newBuilder();
+            try {
+                boolean done = false;
+                while (!done) {
+                    int tag = input.readTag();
+                    switch (tag) {
+                        case 0:
+                            done = true;
+                            break;
+                        default: {
+                            if (!parseUnknownField(input, unknownFields,
+                                    extensionRegistry, tag)) {
+                                done = true;
+                            }
+                            break;
+                        }
+                        case 10: {
+                            com.google.protobuf.ByteString bs = input.readBytes();
+                            bitField0_ |= 0x00000001;
+                            number_ = bs;
+                            break;
+                        }
+                    }
+                }
+            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                throw e.setUnfinishedMessage(this);
+            } catch (java.io.IOException e) {
+                throw new com.google.protobuf.InvalidProtocolBufferException(
+                        e).setUnfinishedMessage(this);
+            } finally {
+                this.unknownFields = unknownFields.build();
+                makeExtensionsImmutable();
+            }
+        }
+
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+        }
+
+        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            retrofit2.converter.protobuf.PhoneProtos.Phone.class,
+                            retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int NUMBER_FIELD_NUMBER = 1;
+        private volatile java.lang.Object number_;
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public boolean hasNumber() {
+            return ((bitField0_ & 0x00000001) == 0x00000001);
+        }
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public java.lang.String getNumber() {
+            java.lang.Object ref = number_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            }
+            else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                if (bs.isValidUtf8()) {
+                    number_ = s;
+                }
+                return s;
+            }
+        }
+
+        /**
+         * <code>optional string number = 1;</code>
+         */
+        public com.google.protobuf.ByteString
         getNumberBytes() {
-      java.lang.Object ref = number_;
-      if (ref instanceof java.lang.String) {
-        com.google.protobuf.ByteString b = 
-            com.google.protobuf.ByteString.copyFromUtf8(
-                (java.lang.String) ref);
-        number_ = b;
-        return b;
-      } else {
-        return (com.google.protobuf.ByteString) ref;
-      }
-    }
+            java.lang.Object ref = number_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                number_ = b;
+                return b;
+            }
+            else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
 
-    private byte memoizedIsInitialized = -1;
-    public final boolean isInitialized() {
-      byte isInitialized = memoizedIsInitialized;
-      if (isInitialized == 1) return true;
-      if (isInitialized == 0) return false;
-
-      if (!extensionsAreInitialized()) {
-        memoizedIsInitialized = 0;
-        return false;
-      }
-      memoizedIsInitialized = 1;
-      return true;
-    }
+        private byte memoizedIsInitialized = -1;
 
-    public void writeTo(com.google.protobuf.CodedOutputStream output)
-                        throws java.io.IOException {
-      com.google.protobuf.GeneratedMessage
-        .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
-          extensionWriter = newExtensionWriter();
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
-      }
-      extensionWriter.writeUntil(3, output);
-      unknownFields.writeTo(output);
-    }
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
 
-    public int getSerializedSize() {
-      int size = memoizedSize;
-      if (size != -1) return size;
-
-      size = 0;
-      if (((bitField0_ & 0x00000001) == 0x00000001)) {
-        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
-      }
-      size += extensionsSerializedSize();
-      size += unknownFields.getSerializedSize();
-      memoizedSize = size;
-      return size;
-    }
+            if (!extensionsAreInitialized()) {
+                memoizedIsInitialized = 0;
+                return false;
+            }
+            memoizedIsInitialized = 1;
+            return true;
+        }
 
-    private static final long serialVersionUID = 0L;
-    @java.lang.Override
-    public boolean equals(final java.lang.Object obj) {
-      if (obj == this) {
-       return true;
-      }
-      if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
-        return super.equals(obj);
-      }
-      retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
-
-      boolean result = true;
-      result = result && (hasNumber() == other.hasNumber());
-      if (hasNumber()) {
-        result = result && getNumber()
-            .equals(other.getNumber());
-      }
-      result = result && unknownFields.equals(other.unknownFields);
-      result = result &&
-          getExtensionFields().equals(other.getExtensionFields());
-      return result;
-    }
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            com.google.protobuf.GeneratedMessage
+                    .ExtendableMessage<retrofit2.converter.protobuf.PhoneProtos.Phone>.ExtensionWriter
+                    extensionWriter = newExtensionWriter();
+            if (((bitField0_ & 0x00000001) == 0x00000001)) {
+                com.google.protobuf.GeneratedMessage.writeString(output, 1, number_);
+            }
+            extensionWriter.writeUntil(3, output);
+            unknownFields.writeTo(output);
+        }
 
-    @java.lang.Override
-    public int hashCode() {
-      if (memoizedHashCode != 0) {
-        return memoizedHashCode;
-      }
-      int hash = 41;
-      hash = (19 * hash) + getDescriptorForType().hashCode();
-      if (hasNumber()) {
-        hash = (37 * hash) + NUMBER_FIELD_NUMBER;
-        hash = (53 * hash) + getNumber().hashCode();
-      }
-      hash = hashFields(hash, getExtensionFields());
-      hash = (29 * hash) + unknownFields.hashCode();
-      memoizedHashCode = hash;
-      return hash;
-    }
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
 
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.ByteString data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        byte[] data,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws com.google.protobuf.InvalidProtocolBufferException {
-      return PARSER.parseFrom(data, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
-        java.io.InputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input);
-    }
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
-        com.google.protobuf.CodedInputStream input,
-        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-        throws java.io.IOException {
-      return com.google.protobuf.GeneratedMessage
-          .parseWithIOException(PARSER, input, extensionRegistry);
-    }
+            size = 0;
+            if (((bitField0_ & 0x00000001) == 0x00000001)) {
+                size += com.google.protobuf.GeneratedMessage.computeStringSize(1, number_);
+            }
+            size += extensionsSerializedSize();
+            size += unknownFields.getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
 
-    public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder() {
-      return DEFAULT_INSTANCE.toBuilder();
-    }
-    public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
-      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
-    }
-    public Builder toBuilder() {
-      return this == DEFAULT_INSTANCE
-          ? new Builder() : new Builder().mergeFrom(this);
-    }
+        private static final long serialVersionUID = 0L;
 
-    @java.lang.Override
-    protected Builder newBuilderForType(
-        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-      Builder builder = new Builder(parent);
-      return builder;
-    }
-    /**
-     * Protobuf type {@code retrofit2.converter.protobuf.Phone}
-     */
-    public static final class Builder extends
-        com.google.protobuf.GeneratedMessage.ExtendableBuilder<
-          retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
-        // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
-        retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
-      public static final com.google.protobuf.Descriptors.Descriptor
-          getDescriptor() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
-          internalGetFieldAccessorTable() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
-            .ensureFieldAccessorsInitialized(
-                retrofit2.converter.protobuf.PhoneProtos.Phone.class, retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
-      }
-
-      // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
-      private Builder() {
-        maybeForceBuilderInitialization();
-      }
-
-      private Builder(
-          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
-        super(parent);
-        maybeForceBuilderInitialization();
-      }
-      private void maybeForceBuilderInitialization() {
-        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-        }
-      }
-      public Builder clear() {
-        super.clear();
-        number_ = "";
-        bitField0_ = (bitField0_ & ~0x00000001);
-        return this;
-      }
-
-      public com.google.protobuf.Descriptors.Descriptor
-          getDescriptorForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
-        if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
-        }
-        return result;
-      }
-
-      public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
-        retrofit2.converter.protobuf.PhoneProtos.Phone result = new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
-        int from_bitField0_ = bitField0_;
-        int to_bitField0_ = 0;
-        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
-          to_bitField0_ |= 0x00000001;
-        }
-        result.number_ = number_;
-        result.bitField0_ = to_bitField0_;
-        onBuilt();
-        return result;
-      }
-
-      public Builder clone() {
-        return (Builder) super.clone();
-      }
-      public Builder setField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.setField(field, value);
-      }
-      public Builder clearField(
-          com.google.protobuf.Descriptors.FieldDescriptor field) {
-        return (Builder) super.clearField(field);
-      }
-      public Builder clearOneof(
-          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
-        return (Builder) super.clearOneof(oneof);
-      }
-      public Builder setRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          int index, Object value) {
-        return (Builder) super.setRepeatedField(field, index, value);
-      }
-      public Builder addRepeatedField(
-          com.google.protobuf.Descriptors.FieldDescriptor field,
-          Object value) {
-        return (Builder) super.addRepeatedField(field, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
-          Type value) {
-        return (Builder) super.setExtension(extension, value);
-      }
-      public <Type> Builder setExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          int index, Type value) {
-        return (Builder) super.setExtension(extension, index, value);
-      }
-      public <Type> Builder addExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
-          Type value) {
-        return (Builder) super.addExtension(extension, value);
-      }
-      public <Type> Builder clearExtension(
-          com.google.protobuf.GeneratedMessage.GeneratedExtension<
-              retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
-        return (Builder) super.clearExtension(extension);
-      }
-      public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
-          return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone)other);
-        } else {
-          super.mergeFrom(other);
-          return this;
-        }
-      }
-
-      public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
-        if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
-        if (other.hasNumber()) {
-          bitField0_ |= 0x00000001;
-          number_ = other.number_;
-          onChanged();
-        }
-        this.mergeExtensionFields(other);
-        this.mergeUnknownFields(other.unknownFields);
-        onChanged();
-        return this;
-      }
-
-      public final boolean isInitialized() {
-        if (!extensionsAreInitialized()) {
-          return false;
-        }
-        return true;
-      }
-
-      public Builder mergeFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws java.io.IOException {
-        retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
-        try {
-          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
-        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
-          throw e.unwrapIOException();
-        } finally {
-          if (parsedMessage != null) {
-            mergeFrom(parsedMessage);
-          }
-        }
-        return this;
-      }
-      private int bitField0_;
-
-      private java.lang.Object number_ = "";
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public boolean hasNumber() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public java.lang.String getNumber() {
-        java.lang.Object ref = number_;
-        if (!(ref instanceof java.lang.String)) {
-          com.google.protobuf.ByteString bs =
-              (com.google.protobuf.ByteString) ref;
-          java.lang.String s = bs.toStringUtf8();
-          if (bs.isValidUtf8()) {
-            number_ = s;
-          }
-          return s;
-        } else {
-          return (java.lang.String) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public com.google.protobuf.ByteString
-          getNumberBytes() {
-        java.lang.Object ref = number_;
-        if (ref instanceof String) {
-          com.google.protobuf.ByteString b = 
-              com.google.protobuf.ByteString.copyFromUtf8(
-                  (java.lang.String) ref);
-          number_ = b;
-          return b;
-        } else {
-          return (com.google.protobuf.ByteString) ref;
-        }
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumber(
-          java.lang.String value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder clearNumber() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        number_ = getDefaultInstance().getNumber();
-        onChanged();
-        return this;
-      }
-      /**
-       * <code>optional string number = 1;</code>
-       */
-      public Builder setNumberBytes(
-          com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        number_ = value;
-        onChanged();
-        return this;
-      }
-      public final Builder setUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.setUnknownFields(unknownFields);
-      }
-
-      public final Builder mergeUnknownFields(
-          final com.google.protobuf.UnknownFieldSet unknownFields) {
-        return super.mergeUnknownFields(unknownFields);
-      }
-
-
-      // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
-    }
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof retrofit2.converter.protobuf.PhoneProtos.Phone)) {
+                return super.equals(obj);
+            }
+            retrofit2.converter.protobuf.PhoneProtos.Phone other = (retrofit2.converter.protobuf.PhoneProtos.Phone) obj;
 
-    // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
-    private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
-    static {
-      DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
-    }
+            boolean result = true;
+            result = result && (hasNumber() == other.hasNumber());
+            if (hasNumber()) {
+                result = result && getNumber()
+                        .equals(other.getNumber());
+            }
+            result = result && unknownFields.equals(other.unknownFields);
+            result = result &&
+                    getExtensionFields().equals(other.getExtensionFields());
+            return result;
+        }
 
-    public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
-      return DEFAULT_INSTANCE;
-    }
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptorForType().hashCode();
+            if (hasNumber()) {
+                hash = (37 * hash) + NUMBER_FIELD_NUMBER;
+                hash = (53 * hash) + getNumber().hashCode();
+            }
+            hash = hashFields(hash, getExtensionFields());
+            hash = (29 * hash) + unknownFields.hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
 
-    @java.lang.Deprecated public static final com.google.protobuf.Parser<Phone>
-        PARSER = new com.google.protobuf.AbstractParser<Phone>() {
-      public Phone parsePartialFrom(
-          com.google.protobuf.CodedInputStream input,
-          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
-          throws com.google.protobuf.InvalidProtocolBufferException {
-          return new Phone(input, extensionRegistry);
-      }
-    };
-
-    public static com.google.protobuf.Parser<Phone> parser() {
-      return PARSER;
-    }
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
 
-    @java.lang.Override
-    public com.google.protobuf.Parser<Phone> getParserForType() {
-      return PARSER;
-    }
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
 
-    public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
-      return DEFAULT_INSTANCE;
-    }
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseWithIOException(PARSER, input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
 
-  }
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseWithIOException(PARSER, input);
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessage
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        public Builder newBuilderForType() {
+            return newBuilder();
+        }
+
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+
+        public static Builder newBuilder(retrofit2.converter.protobuf.PhoneProtos.Phone prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+
+        /**
+         * Protobuf type {@code retrofit2.converter.protobuf.Phone}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessage.ExtendableBuilder<
+                        retrofit2.converter.protobuf.PhoneProtos.Phone, Builder> implements
+                // @@protoc_insertion_point(builder_implements:retrofit2.converter.protobuf.Phone)
+                retrofit2.converter.protobuf.PhoneProtos.PhoneOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+            }
+
+            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                retrofit2.converter.protobuf.PhoneProtos.Phone.class,
+                                retrofit2.converter.protobuf.PhoneProtos.Phone.Builder.class);
+            }
+
+            // Construct using retrofit2.converter.protobuf.PhoneProtos.Phone.newBuilder()
+            private Builder() {
+                maybeForceBuilderInitialization();
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+                super(parent);
+                maybeForceBuilderInitialization();
+            }
+
+            private void maybeForceBuilderInitialization() {
+                if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+                }
+            }
+
+            public Builder clear() {
+                super.clear();
+                number_ = "";
+                bitField0_ = (bitField0_ & ~0x00000001);
+                return this;
+            }
+
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return retrofit2.converter.protobuf.PhoneProtos.internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+                return retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance();
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone build() {
+                retrofit2.converter.protobuf.PhoneProtos.Phone result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            public retrofit2.converter.protobuf.PhoneProtos.Phone buildPartial() {
+                retrofit2.converter.protobuf.PhoneProtos.Phone result =
+                        new retrofit2.converter.protobuf.PhoneProtos.Phone(this);
+                int from_bitField0_ = bitField0_;
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.number_ = number_;
+                result.bitField0_ = to_bitField0_;
+                onBuilt();
+                return result;
+            }
+
+            public Builder clone() {
+                return (Builder) super.clone();
+            }
+
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    Object value) {
+                return (Builder) super.setField(field, value);
+            }
+
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return (Builder) super.clearField(field);
+            }
+
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return (Builder) super.clearOneof(oneof);
+            }
+
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, Object value) {
+                return (Builder) super.setRepeatedField(field, index, value);
+            }
+
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    Object value) {
+                return (Builder) super.addRepeatedField(field, value);
+            }
+
+            public <Type> Builder setExtension(
+                    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+                            retrofit2.converter.protobuf.PhoneProtos.Phone, Type> extension,
+                    Type value) {
+                return (Builder) super.setExtension(extension, value);
+            }
+
+            public <Type> Builder setExtension(
+                    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+                            retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+                    int index, Type value) {
+                return (Builder) super.setExtension(extension, index, value);
+            }
+
+            public <Type> Builder addExtension(
+                    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+                            retrofit2.converter.protobuf.PhoneProtos.Phone, java.util.List<Type>> extension,
+                    Type value) {
+                return (Builder) super.addExtension(extension, value);
+            }
+
+            public <Type> Builder clearExtension(
+                    com.google.protobuf.GeneratedMessage.GeneratedExtension<
+                            retrofit2.converter.protobuf.PhoneProtos.Phone, ?> extension) {
+                return (Builder) super.clearExtension(extension);
+            }
 
-  public static final int VOICEMAIL_FIELD_NUMBER = 2;
-  /**
-   * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
-   */
-  public static final
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof retrofit2.converter.protobuf.PhoneProtos.Phone) {
+                    return mergeFrom((retrofit2.converter.protobuf.PhoneProtos.Phone) other);
+                }
+                else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(retrofit2.converter.protobuf.PhoneProtos.Phone other) {
+                if (other == retrofit2.converter.protobuf.PhoneProtos.Phone.getDefaultInstance()) return this;
+                if (other.hasNumber()) {
+                    bitField0_ |= 0x00000001;
+                    number_ = other.number_;
+                    onChanged();
+                }
+                this.mergeExtensionFields(other);
+                this.mergeUnknownFields(other.unknownFields);
+                onChanged();
+                return this;
+            }
+
+            public final boolean isInitialized() {
+                if (!extensionsAreInitialized()) {
+                    return false;
+                }
+                return true;
+            }
+
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                retrofit2.converter.protobuf.PhoneProtos.Phone parsedMessage = null;
+                try {
+                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    parsedMessage = (retrofit2.converter.protobuf.PhoneProtos.Phone) e.getUnfinishedMessage();
+                    throw e.unwrapIOException();
+                } finally {
+                    if (parsedMessage != null) {
+                        mergeFrom(parsedMessage);
+                    }
+                }
+                return this;
+            }
+
+            private int bitField0_;
+
+            private java.lang.Object number_ = "";
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public boolean hasNumber() {
+                return ((bitField0_ & 0x00000001) == 0x00000001);
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public java.lang.String getNumber() {
+                java.lang.Object ref = number_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    if (bs.isValidUtf8()) {
+                        number_ = s;
+                    }
+                    return s;
+                }
+                else {
+                    return (java.lang.String) ref;
+                }
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public com.google.protobuf.ByteString
+            getNumberBytes() {
+                java.lang.Object ref = number_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    number_ = b;
+                    return b;
+                }
+                else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder setNumber(
+                    java.lang.String value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                number_ = value;
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder clearNumber() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                number_ = getDefaultInstance().getNumber();
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>optional string number = 1;</code>
+             */
+            public Builder setNumberBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                number_ = value;
+                onChanged();
+                return this;
+            }
+
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:retrofit2.converter.protobuf.Phone)
+        }
+
+        // @@protoc_insertion_point(class_scope:retrofit2.converter.protobuf.Phone)
+        private static final retrofit2.converter.protobuf.PhoneProtos.Phone DEFAULT_INSTANCE;
+
+        static {
+            DEFAULT_INSTANCE = new retrofit2.converter.protobuf.PhoneProtos.Phone();
+        }
+
+        public static retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        @java.lang.Deprecated
+        public static final com.google.protobuf.Parser<Phone>
+                PARSER = new com.google.protobuf.AbstractParser<Phone>() {
+            public Phone parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                return new Phone(input, extensionRegistry);
+            }
+        };
+
+        public static com.google.protobuf.Parser<Phone> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Phone> getParserForType() {
+            return PARSER;
+        }
+
+        public retrofit2.converter.protobuf.PhoneProtos.Phone getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public static final int VOICEMAIL_FIELD_NUMBER = 2;
+    /**
+     * <code>extend .retrofit2.converter.protobuf.Phone { ... }</code>
+     */
+    public static final
     com.google.protobuf.GeneratedMessage.GeneratedExtension<
-      retrofit2.converter.protobuf.PhoneProtos.Phone,
-      java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
-          .newFileScopedGeneratedExtension(
-        java.lang.Boolean.class,
-        null);
-  private static final com.google.protobuf.Descriptors.Descriptor
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor;
-  private static final 
+            retrofit2.converter.protobuf.PhoneProtos.Phone,
+            java.lang.Boolean> voicemail = com.google.protobuf.GeneratedMessage
+            .newFileScopedGeneratedExtension(
+                    java.lang.Boolean.class,
+                    null);
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_retrofit2_converter_protobuf_Phone_descriptor;
+    private static final
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
-
-  public static com.google.protobuf.Descriptors.FileDescriptor
-      getDescriptor() {
-    return descriptor;
-  }
-  private static  com.google.protobuf.Descriptors.FileDescriptor
-      descriptor;
-  static {
-    java.lang.String[] descriptorData = {
-      "\n\022protos/phone.proto\022\034retrofit2.converte" +
-      "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
-      "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
-      "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
-      ".protobufB\013PhoneProtos"
-    };
-    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
-        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
-          public com.google.protobuf.ExtensionRegistry assignDescriptors(
-              com.google.protobuf.Descriptors.FileDescriptor root) {
-            descriptor = root;
-            return null;
-          }
+            internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable;
+
+    public static com.google.protobuf.Descriptors.FileDescriptor
+    getDescriptor() {
+        return descriptor;
+    }
+
+    private static com.google.protobuf.Descriptors.FileDescriptor
+            descriptor;
+
+    static {
+        java.lang.String[] descriptorData = {
+                "\n\022protos/phone.proto\022\034retrofit2.converte" +
+                        "r.protobuf\"\035\n\005Phone\022\016\n\006number\030\001 \001(\t*\004\010\002\020" +
+                        "\003:6\n\tvoicemail\022#.retrofit2.converter.pro" +
+                        "tobuf.Phone\030\002 \001(\010B+\n\034retrofit2.converter" +
+                        ".protobufB\013PhoneProtos"
         };
-    com.google.protobuf.Descriptors.FileDescriptor
-      .internalBuildGeneratedFileFrom(descriptorData,
-        new com.google.protobuf.Descriptors.FileDescriptor[] {
-        }, assigner);
-    internal_static_retrofit2_converter_protobuf_Phone_descriptor =
-      getDescriptor().getMessageTypes().get(0);
-    internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
-      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-        internal_static_retrofit2_converter_protobuf_Phone_descriptor,
-        new java.lang.String[] { "Number", });
-    voicemail.internalInit(descriptor.getExtensions().get(0));
-  }
-
-  // @@protoc_insertion_point(outer_class_scope)
+        com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
+                new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
+                    public com.google.protobuf.ExtensionRegistry assignDescriptors(
+                            com.google.protobuf.Descriptors.FileDescriptor root) {
+                        descriptor = root;
+                        return null;
+                    }
+                };
+        com.google.protobuf.Descriptors.FileDescriptor
+                .internalBuildGeneratedFileFrom(descriptorData,
+                        new com.google.protobuf.Descriptors.FileDescriptor[]{
+                        }, assigner);
+        internal_static_retrofit2_converter_protobuf_Phone_descriptor =
+                getDescriptor().getMessageTypes().get(0);
+        internal_static_retrofit2_converter_protobuf_Phone_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+                internal_static_retrofit2_converter_protobuf_Phone_descriptor,
+                new java.lang.String[]{"Number",});
+        voicemail.internalInit(descriptor.getExtensions().get(0));
+    }
+
+    // @@protoc_insertion_point(outer_class_scope)
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
index 5a585b21f..ab39e1af4 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit2/converter/protobuf/ProtoConverterFactoryTest.java
@@ -17,16 +17,20 @@
 
 import com.google.protobuf.ExtensionRegistry;
 import com.google.protobuf.InvalidProtocolBufferException;
+
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -39,120 +43,137 @@
 import static retrofit2.converter.protobuf.PhoneProtos.Phone;
 
 public final class ProtoConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-  interface ServiceWithRegistry {
-    @GET("/") Call<Phone> get();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-  private ServiceWithRegistry serviceWithRegistry;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ProtoConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-
-    ExtensionRegistry registry = ExtensionRegistry.newInstance();
-    PhoneProtos.registerAllExtensions(registry);
-    Retrofit retrofitWithRegistry = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
-        .build();
-    serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
-  }
-
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.hasNumber()).isFalse();
-  }
-
-  @Test public void deserializeUsesRegistry() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = serviceWithRegistry.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
-    assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongClass();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+    interface Service {
+        @GET("/")
+        Call<Phone> get();
+
+        @POST("/")
+        Call<Phone> post(@Body Phone impl);
+
+        @GET("/")
+        Call<String> wrongClass();
+
+        @GET("/")
+        Call<List<String>> wrongType();
     }
-  }
-
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongType();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for java.util.List<java.lang.String>\n"
-          + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+
+    interface ServiceWithRegistry {
+        @GET("/")
+        Call<Phone> get();
+    }
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+    private ServiceWithRegistry serviceWithRegistry;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ProtoConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+
+        ExtensionRegistry registry = ExtensionRegistry.newInstance();
+        PhoneProtos.registerAllExtensions(registry);
+        Retrofit retrofitWithRegistry = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ProtoConverterFactory.createWithRegistry(registry))
+                .build();
+        serviceWithRegistry = retrofitWithRegistry.create(ServiceWithRegistry.class);
     }
-  }
-
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
-          .hasMessageContaining("input ended unexpectedly");
+
+    @Test
+    public void serializeAndDeserialize() throws IOException, InterruptedException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+    }
+
+    @Test
+    public void deserializeEmpty() throws IOException {
+        server.enqueue(new MockResponse());
+
+        Call<Phone> call = service.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.hasNumber()).isFalse();
+    }
+
+    @Test
+    public void deserializeUsesRegistry() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwORAB");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = serviceWithRegistry.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+        assertThat(body.getExtension(PhoneProtos.voicemail)).isEqualTo(true);
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongClass();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method Service.wrongClass");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongType() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongType();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for java.util.List<java.lang.String>\n"
+                    + "    for method Service.wrongType");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.protobuf.ProtoConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("////");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
+                                    .hasMessageContaining("input ended unexpectedly");
+        }
     }
-  }
 }
diff --git a/retrofit-converters/scalars/pom.xml b/retrofit-converters/scalars/pom.xml
index 52ce81b6a..9ff6f95d0 100644
--- a/retrofit-converters/scalars/pom.xml
+++ b/retrofit-converters/scalars/pom.xml
@@ -1,39 +1,40 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-scalars</artifactId>
-  <name>Converter: Java Scalars</name>
+    <artifactId>converter-scalars</artifactId>
+    <name>Converter: Java Scalars</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
index fd65200d4..bef837918 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarRequestBodyConverter.java
@@ -16,18 +16,20 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import retrofit2.Converter;
 
 final class ScalarRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
-  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+    static final ScalarRequestBodyConverter<Object> INSTANCE = new ScalarRequestBodyConverter<>();
+    private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
 
-  private ScalarRequestBodyConverter() {
-  }
+    private ScalarRequestBodyConverter() {
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        return RequestBody.create(MEDIA_TYPE, String.valueOf(value));
+    }
 }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
index a91d87c82..2368ba0d6 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarResponseBodyConverters.java
@@ -16,87 +16,97 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class ScalarResponseBodyConverters {
-  private ScalarResponseBodyConverters() {
-  }
+    private ScalarResponseBodyConverters() {
+    }
 
-  static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
-    static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
+    static final class StringResponseBodyConverter implements Converter<ResponseBody, String> {
+        static final StringResponseBodyConverter INSTANCE = new StringResponseBodyConverter();
 
-    @Override public String convert(ResponseBody value) throws IOException {
-      return value.string();
+        @Override
+        public String convert(ResponseBody value) throws IOException {
+            return value.string();
+        }
     }
-  }
 
-  static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
-    static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
+    static final class BooleanResponseBodyConverter implements Converter<ResponseBody, Boolean> {
+        static final BooleanResponseBodyConverter INSTANCE = new BooleanResponseBodyConverter();
 
-    @Override public Boolean convert(ResponseBody value) throws IOException {
-      return Boolean.valueOf(value.string());
+        @Override
+        public Boolean convert(ResponseBody value) throws IOException {
+            return Boolean.valueOf(value.string());
+        }
     }
-  }
 
-  static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
-    static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
+    static final class ByteResponseBodyConverter implements Converter<ResponseBody, Byte> {
+        static final ByteResponseBodyConverter INSTANCE = new ByteResponseBodyConverter();
 
-    @Override public Byte convert(ResponseBody value) throws IOException {
-      return Byte.valueOf(value.string());
+        @Override
+        public Byte convert(ResponseBody value) throws IOException {
+            return Byte.valueOf(value.string());
+        }
     }
-  }
-
-  static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
-    static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
-
-    @Override public Character convert(ResponseBody value) throws IOException {
-      String body = value.string();
-      if (body.length() != 1) {
-        throw new IOException(
-            "Expected body of length 1 for Character conversion but was " + body.length());
-      }
-      return body.charAt(0);
+
+    static final class CharacterResponseBodyConverter implements Converter<ResponseBody, Character> {
+        static final CharacterResponseBodyConverter INSTANCE = new CharacterResponseBodyConverter();
+
+        @Override
+        public Character convert(ResponseBody value) throws IOException {
+            String body = value.string();
+            if (body.length() != 1) {
+                throw new IOException(
+                        "Expected body of length 1 for Character conversion but was " + body.length());
+            }
+            return body.charAt(0);
+        }
     }
-  }
 
-  static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
-    static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
+    static final class DoubleResponseBodyConverter implements Converter<ResponseBody, Double> {
+        static final DoubleResponseBodyConverter INSTANCE = new DoubleResponseBodyConverter();
 
-    @Override public Double convert(ResponseBody value) throws IOException {
-      return Double.valueOf(value.string());
+        @Override
+        public Double convert(ResponseBody value) throws IOException {
+            return Double.valueOf(value.string());
+        }
     }
-  }
 
-  static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
-    static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
+    static final class FloatResponseBodyConverter implements Converter<ResponseBody, Float> {
+        static final FloatResponseBodyConverter INSTANCE = new FloatResponseBodyConverter();
 
-    @Override public Float convert(ResponseBody value) throws IOException {
-      return Float.valueOf(value.string());
+        @Override
+        public Float convert(ResponseBody value) throws IOException {
+            return Float.valueOf(value.string());
+        }
     }
-  }
 
-  static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
-    static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
+    static final class IntegerResponseBodyConverter implements Converter<ResponseBody, Integer> {
+        static final IntegerResponseBodyConverter INSTANCE = new IntegerResponseBodyConverter();
 
-    @Override public Integer convert(ResponseBody value) throws IOException {
-      return Integer.valueOf(value.string());
+        @Override
+        public Integer convert(ResponseBody value) throws IOException {
+            return Integer.valueOf(value.string());
+        }
     }
-  }
 
-  static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
-    static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
+    static final class LongResponseBodyConverter implements Converter<ResponseBody, Long> {
+        static final LongResponseBodyConverter INSTANCE = new LongResponseBodyConverter();
 
-    @Override public Long convert(ResponseBody value) throws IOException {
-      return Long.valueOf(value.string());
+        @Override
+        public Long convert(ResponseBody value) throws IOException {
+            return Long.valueOf(value.string());
+        }
     }
-  }
 
-  static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
-    static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
+    static final class ShortResponseBodyConverter implements Converter<ResponseBody, Short> {
+        static final ShortResponseBodyConverter INSTANCE = new ShortResponseBodyConverter();
 
-    @Override public Short convert(ResponseBody value) throws IOException {
-      return Short.valueOf(value.string());
+        @Override
+        public Short convert(ResponseBody value) throws IOException {
+            return Short.valueOf(value.string());
+        }
     }
-  }
 }
diff --git a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
index 5bf838fe9..6faac1228 100644
--- a/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
+++ b/retrofit-converters/scalars/src/main/java/retrofit2/converter/scalars/ScalarsConverterFactory.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -36,67 +37,68 @@
  * to {@code text/plain} bodies.
  */
 public final class ScalarsConverterFactory extends Converter.Factory {
-  public static ScalarsConverterFactory create() {
-    return new ScalarsConverterFactory();
-  }
-
-  private ScalarsConverterFactory() {
-  }
-
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (type == String.class
-        || type == boolean.class
-        || type == Boolean.class
-        || type == byte.class
-        || type == Byte.class
-        || type == char.class
-        || type == Character.class
-        || type == double.class
-        || type == Double.class
-        || type == float.class
-        || type == Float.class
-        || type == int.class
-        || type == Integer.class
-        || type == long.class
-        || type == Long.class
-        || type == short.class
-        || type == Short.class) {
-      return ScalarRequestBodyConverter.INSTANCE;
+    public static ScalarsConverterFactory create() {
+        return new ScalarsConverterFactory();
     }
-    return null;
-  }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == String.class) {
-      return StringResponseBodyConverter.INSTANCE;
-    }
-    if (type == Boolean.class || type == boolean.class) {
-      return BooleanResponseBodyConverter.INSTANCE;
-    }
-    if (type == Byte.class || type == byte.class) {
-      return ByteResponseBodyConverter.INSTANCE;
-    }
-    if (type == Character.class || type == char.class) {
-      return CharacterResponseBodyConverter.INSTANCE;
+    private ScalarsConverterFactory() {
     }
-    if (type == Double.class || type == double.class) {
-      return DoubleResponseBodyConverter.INSTANCE;
-    }
-    if (type == Float.class || type == float.class) {
-      return FloatResponseBodyConverter.INSTANCE;
-    }
-    if (type == Integer.class || type == int.class) {
-      return IntegerResponseBodyConverter.INSTANCE;
-    }
-    if (type == Long.class || type == long.class) {
-      return LongResponseBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (type == String.class
+                || type == boolean.class
+                || type == Boolean.class
+                || type == byte.class
+                || type == Byte.class
+                || type == char.class
+                || type == Character.class
+                || type == double.class
+                || type == Double.class
+                || type == float.class
+                || type == Float.class
+                || type == int.class
+                || type == Integer.class
+                || type == long.class
+                || type == Long.class
+                || type == short.class
+                || type == Short.class) {
+            return ScalarRequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    if (type == Short.class || type == short.class) {
-      return ShortResponseBodyConverter.INSTANCE;
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (type == String.class) {
+            return StringResponseBodyConverter.INSTANCE;
+        }
+        if (type == Boolean.class || type == boolean.class) {
+            return BooleanResponseBodyConverter.INSTANCE;
+        }
+        if (type == Byte.class || type == byte.class) {
+            return ByteResponseBodyConverter.INSTANCE;
+        }
+        if (type == Character.class || type == char.class) {
+            return CharacterResponseBodyConverter.INSTANCE;
+        }
+        if (type == Double.class || type == double.class) {
+            return DoubleResponseBodyConverter.INSTANCE;
+        }
+        if (type == Float.class || type == float.class) {
+            return FloatResponseBodyConverter.INSTANCE;
+        }
+        if (type == Integer.class || type == int.class) {
+            return IntegerResponseBodyConverter.INSTANCE;
+        }
+        if (type == Long.class || type == long.class) {
+            return LongResponseBodyConverter.INSTANCE;
+        }
+        if (type == Short.class || type == short.class) {
+            return ShortResponseBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
index cc19d4fbc..2b3d5765a 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterFactoryTest.java
@@ -16,13 +16,16 @@
 package retrofit2.converter.scalars;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -35,256 +38,314 @@
 import static org.junit.Assert.fail;
 
 public final class ScalarsConverterFactoryTest {
-  interface Service {
-      @POST("/") Call<ResponseBody> object(@Body Object body);
-
-      @POST("/") Call<ResponseBody> stringObject(@Body String body);
-      @POST("/") Call<ResponseBody> booleanPrimitive(@Body boolean body);
-      @POST("/") Call<ResponseBody> booleanObject(@Body Boolean body);
-      @POST("/") Call<ResponseBody> bytePrimitive(@Body byte body);
-      @POST("/") Call<ResponseBody> byteObject(@Body Byte body);
-      @POST("/") Call<ResponseBody> charPrimitive(@Body char body);
-      @POST("/") Call<ResponseBody> charObject(@Body Character body);
-      @POST("/") Call<ResponseBody> doublePrimitive(@Body double body);
-      @POST("/") Call<ResponseBody> doubleObject(@Body Double body);
-      @POST("/") Call<ResponseBody> floatPrimitive(@Body float body);
-      @POST("/") Call<ResponseBody> floatObject(@Body Float body);
-      @POST("/") Call<ResponseBody> integerPrimitive(@Body int body);
-      @POST("/") Call<ResponseBody> integerObject(@Body Integer body);
-      @POST("/") Call<ResponseBody> longPrimitive(@Body long body);
-      @POST("/") Call<ResponseBody> longObject(@Body Long body);
-      @POST("/") Call<ResponseBody> shortPrimitive(@Body short body);
-      @POST("/") Call<ResponseBody> shortObject(@Body Short body);
-
-      @GET("/") Call<Object> object();
-
-      @GET("/") Call<String> stringObject();
-      @GET("/") Call<Boolean> booleanObject();
-      @GET("/") Call<Byte> byteObject();
-      @GET("/") Call<Character> charObject();
-      @GET("/") Call<Double> doubleObject();
-      @GET("/") Call<Float> floatObject();
-      @GET("/") Call<Integer> integerObject();
-      @GET("/") Call<Long> longObject();
-      @GET("/") Call<Short> shortObject();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ScalarsConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void unsupportedRequestTypesNotMatched() {
-    try {
-      service.object(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
-          + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.Object.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
-    }
-  }
-
-  @Test public void supportedRequestTypes() throws IOException, InterruptedException {
-    RecordedRequest request;
-
-    server.enqueue(new MockResponse());
-    service.stringObject("string").execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("6");
-    assertThat(request.getBody().readUtf8()).isEqualTo("string");
-
-    server.enqueue(new MockResponse());
-    service.booleanPrimitive(true).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("4");
-    assertThat(request.getBody().readUtf8()).isEqualTo("true");
-
-    server.enqueue(new MockResponse());
-    service.booleanObject(false).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("5");
-    assertThat(request.getBody().readUtf8()).isEqualTo("false");
-
-    server.enqueue(new MockResponse());
-    service.bytePrimitive((byte) 0).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("0");
-
-    server.enqueue(new MockResponse());
-    service.byteObject((byte) 1).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("1");
-
-    server.enqueue(new MockResponse());
-    service.charPrimitive('a').execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("a");
-
-    server.enqueue(new MockResponse());
-    service.charObject('b').execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("b");
-
-    server.enqueue(new MockResponse());
-    service.doublePrimitive(2.2d).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("2.2");
-
-    server.enqueue(new MockResponse());
-    service.doubleObject(3.3d).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("3.3");
-
-    server.enqueue(new MockResponse());
-    service.floatPrimitive(4.4f).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("4.4");
-
-    server.enqueue(new MockResponse());
-    service.floatObject(5.5f).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(request.getBody().readUtf8()).isEqualTo("5.5");
-
-    server.enqueue(new MockResponse());
-    service.integerPrimitive(6).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("6");
-
-    server.enqueue(new MockResponse());
-    service.integerObject(7).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("7");
-
-    server.enqueue(new MockResponse());
-    service.longPrimitive(8L).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("8");
-
-    server.enqueue(new MockResponse());
-    service.longObject(9L).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("1");
-    assertThat(request.getBody().readUtf8()).isEqualTo("9");
-
-    server.enqueue(new MockResponse());
-    service.shortPrimitive((short) 10).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
-    assertThat(request.getBody().readUtf8()).isEqualTo("10");
-
-    server.enqueue(new MockResponse());
-    service.shortObject((short) 11).execute();
-    request = server.takeRequest();
-    assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
-    assertThat(request.getHeader("Content-Length")).isEqualTo("2");
-    assertThat(request.getBody().readUtf8()).isEqualTo("11");
-  }
-
-  @Test public void unsupportedResponseTypesNotMatched() {
-    try {
-      service.object();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.Object\n"
-          + "    for method Service.object");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.Object.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
-    }
-  }
-
-  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("test"));
-    Response<String> stringResponse = service.stringObject().execute();
-    assertThat(stringResponse.body()).isEqualTo("test");
-
-    server.enqueue(new MockResponse().setBody("true"));
-    Response<Boolean> booleanResponse = service.booleanObject().execute();
-    assertThat(booleanResponse.body()).isTrue();
-
-    server.enqueue(new MockResponse().setBody("5"));
-    Response<Byte> byteResponse = service.byteObject().execute();
-    assertThat(byteResponse.body()).isEqualTo((byte) 5);
-
-    server.enqueue(new MockResponse().setBody("b"));
-    Response<Character> characterResponse = service.charObject().execute();
-    assertThat(characterResponse.body()).isEqualTo('b');
-
-    server.enqueue(new MockResponse().setBody(""));
-    try {
-      service.charObject().execute();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
-    }
+    interface Service {
+        @POST("/")
+        Call<ResponseBody> object(@Body Object body);
+
+        @POST("/")
+        Call<ResponseBody> stringObject(@Body String body);
+
+        @POST("/")
+        Call<ResponseBody> booleanPrimitive(@Body boolean body);
+
+        @POST("/")
+        Call<ResponseBody> booleanObject(@Body Boolean body);
+
+        @POST("/")
+        Call<ResponseBody> bytePrimitive(@Body byte body);
+
+        @POST("/")
+        Call<ResponseBody> byteObject(@Body Byte body);
+
+        @POST("/")
+        Call<ResponseBody> charPrimitive(@Body char body);
+
+        @POST("/")
+        Call<ResponseBody> charObject(@Body Character body);
+
+        @POST("/")
+        Call<ResponseBody> doublePrimitive(@Body double body);
+
+        @POST("/")
+        Call<ResponseBody> doubleObject(@Body Double body);
+
+        @POST("/")
+        Call<ResponseBody> floatPrimitive(@Body float body);
+
+        @POST("/")
+        Call<ResponseBody> floatObject(@Body Float body);
+
+        @POST("/")
+        Call<ResponseBody> integerPrimitive(@Body int body);
+
+        @POST("/")
+        Call<ResponseBody> integerObject(@Body Integer body);
+
+        @POST("/")
+        Call<ResponseBody> longPrimitive(@Body long body);
 
-    server.enqueue(new MockResponse().setBody("bb"));
-    try {
-      service.charObject().execute();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        @POST("/")
+        Call<ResponseBody> longObject(@Body Long body);
+
+        @POST("/")
+        Call<ResponseBody> shortPrimitive(@Body short body);
+
+        @POST("/")
+        Call<ResponseBody> shortObject(@Body Short body);
+
+        @GET("/")
+        Call<Object> object();
+
+        @GET("/")
+        Call<String> stringObject();
+
+        @GET("/")
+        Call<Boolean> booleanObject();
+
+        @GET("/")
+        Call<Byte> byteObject();
+
+        @GET("/")
+        Call<Character> charObject();
+
+        @GET("/")
+        Call<Double> doubleObject();
+
+        @GET("/")
+        Call<Float> floatObject();
+
+        @GET("/")
+        Call<Integer> integerObject();
+
+        @GET("/")
+        Call<Long> longObject();
+
+        @GET("/")
+        Call<Short> shortObject();
     }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    Response<Double> doubleResponse = service.doubleObject().execute();
-    assertThat(doubleResponse.body()).isEqualTo(13.13);
+    @Rule
+    public final MockWebServer server = new MockWebServer();
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    Response<Float> floatResponse = service.floatObject().execute();
-    assertThat(floatResponse.body()).isEqualTo(13.13f);
+    private Service service;
 
-    server.enqueue(new MockResponse().setBody("13"));
-    Response<Integer> integerResponse = service.integerObject().execute();
-    assertThat(integerResponse.body()).isEqualTo(13);
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ScalarsConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
+    }
 
-    server.enqueue(new MockResponse().setBody("1347"));
-    Response<Long> longResponse = service.longObject().execute();
-    assertThat(longResponse.body()).isEqualTo(1347L);
+    @Test
+    public void unsupportedRequestTypesNotMatched() {
+        try {
+            service.object(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create @Body converter for class java.lang.Object (parameter #1)\n"
+                    + "    for method Service.object");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.Object.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+        }
+    }
 
-    server.enqueue(new MockResponse().setBody("134"));
-    Response<Short> shortResponse = service.shortObject().execute();
-    assertThat(shortResponse.body()).isEqualTo((short) 134);
-  }
+    @Test
+    public void supportedRequestTypes() throws IOException, InterruptedException {
+        RecordedRequest request;
+
+        server.enqueue(new MockResponse());
+        service.stringObject("string").execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("6");
+        assertThat(request.getBody().readUtf8()).isEqualTo("string");
+
+        server.enqueue(new MockResponse());
+        service.booleanPrimitive(true).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("4");
+        assertThat(request.getBody().readUtf8()).isEqualTo("true");
+
+        server.enqueue(new MockResponse());
+        service.booleanObject(false).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("5");
+        assertThat(request.getBody().readUtf8()).isEqualTo("false");
+
+        server.enqueue(new MockResponse());
+        service.bytePrimitive((byte) 0).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("0");
+
+        server.enqueue(new MockResponse());
+        service.byteObject((byte) 1).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("1");
+
+        server.enqueue(new MockResponse());
+        service.charPrimitive('a').execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("a");
+
+        server.enqueue(new MockResponse());
+        service.charObject('b').execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("b");
+
+        server.enqueue(new MockResponse());
+        service.doublePrimitive(2.2d).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("2.2");
+
+        server.enqueue(new MockResponse());
+        service.doubleObject(3.3d).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("3.3");
+
+        server.enqueue(new MockResponse());
+        service.floatPrimitive(4.4f).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("4.4");
+
+        server.enqueue(new MockResponse());
+        service.floatObject(5.5f).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+        assertThat(request.getBody().readUtf8()).isEqualTo("5.5");
+
+        server.enqueue(new MockResponse());
+        service.integerPrimitive(6).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("6");
+
+        server.enqueue(new MockResponse());
+        service.integerObject(7).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("7");
+
+        server.enqueue(new MockResponse());
+        service.longPrimitive(8L).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("8");
+
+        server.enqueue(new MockResponse());
+        service.longObject(9L).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("1");
+        assertThat(request.getBody().readUtf8()).isEqualTo("9");
+
+        server.enqueue(new MockResponse());
+        service.shortPrimitive((short) 10).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+        assertThat(request.getBody().readUtf8()).isEqualTo("10");
+
+        server.enqueue(new MockResponse());
+        service.shortObject((short) 11).execute();
+        request = server.takeRequest();
+        assertThat(request.getHeader("Content-Type")).isEqualTo("text/plain; charset=UTF-8");
+        assertThat(request.getHeader("Content-Length")).isEqualTo("2");
+        assertThat(request.getBody().readUtf8()).isEqualTo("11");
+    }
+
+    @Test
+    public void unsupportedResponseTypesNotMatched() {
+        try {
+            service.object();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.Object\n"
+                    + "    for method Service.object");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.Object.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.scalars.ScalarsConverterFactory");
+        }
+    }
+
+    @Test
+    public void supportedResponseTypes() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("test"));
+        Response<String> stringResponse = service.stringObject().execute();
+        assertThat(stringResponse.body()).isEqualTo("test");
+
+        server.enqueue(new MockResponse().setBody("true"));
+        Response<Boolean> booleanResponse = service.booleanObject().execute();
+        assertThat(booleanResponse.body()).isTrue();
+
+        server.enqueue(new MockResponse().setBody("5"));
+        Response<Byte> byteResponse = service.byteObject().execute();
+        assertThat(byteResponse.body()).isEqualTo((byte) 5);
+
+        server.enqueue(new MockResponse().setBody("b"));
+        Response<Character> characterResponse = service.charObject().execute();
+        assertThat(characterResponse.body()).isEqualTo('b');
+
+        server.enqueue(new MockResponse().setBody(""));
+        try {
+            service.charObject().execute();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+        }
+
+        server.enqueue(new MockResponse().setBody("bb"));
+        try {
+            service.charObject().execute();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        }
+
+        server.enqueue(new MockResponse().setBody("13.13"));
+        Response<Double> doubleResponse = service.doubleObject().execute();
+        assertThat(doubleResponse.body()).isEqualTo(13.13);
+
+        server.enqueue(new MockResponse().setBody("13.13"));
+        Response<Float> floatResponse = service.floatObject().execute();
+        assertThat(floatResponse.body()).isEqualTo(13.13f);
+
+        server.enqueue(new MockResponse().setBody("13"));
+        Response<Integer> integerResponse = service.integerObject().execute();
+        assertThat(integerResponse.body()).isEqualTo(13);
+
+        server.enqueue(new MockResponse().setBody("1347"));
+        Response<Long> longResponse = service.longObject().execute();
+        assertThat(longResponse.body()).isEqualTo(1347L);
+
+        server.enqueue(new MockResponse().setBody("134"));
+        Response<Short> shortResponse = service.shortObject().execute();
+        assertThat(shortResponse.body()).isEqualTo((short) 134);
+    }
 }
diff --git a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
index 8145bde2d..aac94fcbf 100644
--- a/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
+++ b/retrofit-converters/scalars/src/test/java/retrofit2/converter/scalars/ScalarsConverterPrimitivesFactoryTest.java
@@ -18,11 +18,14 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -31,100 +34,120 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ScalarsConverterPrimitivesFactoryTest {
-  interface Service {
-    @GET("/") boolean booleanPrimitive();
-    @GET("/") byte bytePrimitive();
-    @GET("/") char charPrimitive();
-    @GET("/") double doublePrimitive();
-    @GET("/") float floatPrimitive();
-    @GET("/") int integerPrimitive();
-    @GET("/") long longPrimitive();
-    @GET("/") short shortPrimitive();
-  }
-
-  static class DirectCallIOException extends RuntimeException {
-    DirectCallIOException(String message, IOException e) {
-      super(message, e);
+    interface Service {
+        @GET("/")
+        boolean booleanPrimitive();
+
+        @GET("/")
+        byte bytePrimitive();
+
+        @GET("/")
+        char charPrimitive();
+
+        @GET("/")
+        double doublePrimitive();
+
+        @GET("/")
+        float floatPrimitive();
+
+        @GET("/")
+        int integerPrimitive();
+
+        @GET("/")
+        long longPrimitive();
+
+        @GET("/")
+        short shortPrimitive();
     }
-  }
-
-  static class DirectCallAdapterFactory extends CallAdapter.Factory {
-    @Override
-    public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      return new CallAdapter<Object, Object>() {
-        @Override public Type responseType() {
-          return returnType;
-        }
 
-        @Override public Object adapt(Call call) {
-          try {
-            return call.execute().body();
-          } catch (IOException e) {
-            throw new DirectCallIOException(e.getMessage(), e);
-          }
+    static class DirectCallIOException extends RuntimeException {
+        DirectCallIOException(String message, IOException e) {
+            super(message, e);
         }
-      };
     }
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(ScalarsConverterFactory.create())
-        .addCallAdapterFactory(new DirectCallAdapterFactory())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void supportedResponseTypes() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("true"));
-    boolean booleanResponse = service.booleanPrimitive();
-    assertThat(booleanResponse).isTrue();
-
-    server.enqueue(new MockResponse().setBody("5"));
-    byte byteResponse = service.bytePrimitive();
-    assertThat(byteResponse).isEqualTo((byte) 5);
-
-    server.enqueue(new MockResponse().setBody("b"));
-    char characterResponse = service.charPrimitive();
-    assertThat(characterResponse).isEqualTo('b');
-
-    server.enqueue(new MockResponse().setBody(""));
-    try {
-      service.charPrimitive();
-    } catch (DirectCallIOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+
+    static class DirectCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations, Retrofit retrofit) {
+            return new CallAdapter<Object, Object>() {
+                @Override
+                public Type responseType() {
+                    return returnType;
+                }
+
+                @Override
+                public Object adapt(Call call) {
+                    try {
+                        return call.execute().body();
+                    } catch (IOException e) {
+                        throw new DirectCallIOException(e.getMessage(), e);
+                    }
+                }
+            };
+        }
     }
 
-    server.enqueue(new MockResponse().setBody("bb"));
-    try {
-      service.charPrimitive();
-    } catch (DirectCallIOException e) {
-      assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(ScalarsConverterFactory.create())
+                .addCallAdapterFactory(new DirectCallAdapterFactory())
+                .build();
+        service = retrofit.create(Service.class);
     }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    double doubleResponse = service.doublePrimitive();
-    assertThat(doubleResponse).isEqualTo(13.13);
+    @Test
+    public void supportedResponseTypes() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody("true"));
+        boolean booleanResponse = service.booleanPrimitive();
+        assertThat(booleanResponse).isTrue();
+
+        server.enqueue(new MockResponse().setBody("5"));
+        byte byteResponse = service.bytePrimitive();
+        assertThat(byteResponse).isEqualTo((byte) 5);
+
+        server.enqueue(new MockResponse().setBody("b"));
+        char characterResponse = service.charPrimitive();
+        assertThat(characterResponse).isEqualTo('b');
+
+        server.enqueue(new MockResponse().setBody(""));
+        try {
+            service.charPrimitive();
+        } catch (DirectCallIOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 0");
+        }
+
+        server.enqueue(new MockResponse().setBody("bb"));
+        try {
+            service.charPrimitive();
+        } catch (DirectCallIOException e) {
+            assertThat(e).hasMessage("Expected body of length 1 for Character conversion but was 2");
+        }
 
-    server.enqueue(new MockResponse().setBody("13.13"));
-    float floatResponse = service.floatPrimitive();
-    assertThat(floatResponse).isEqualTo(13.13f);
+        server.enqueue(new MockResponse().setBody("13.13"));
+        double doubleResponse = service.doublePrimitive();
+        assertThat(doubleResponse).isEqualTo(13.13);
 
-    server.enqueue(new MockResponse().setBody("13"));
-    int integerResponse = service.integerPrimitive();
-    assertThat(integerResponse).isEqualTo(13);
+        server.enqueue(new MockResponse().setBody("13.13"));
+        float floatResponse = service.floatPrimitive();
+        assertThat(floatResponse).isEqualTo(13.13f);
 
-    server.enqueue(new MockResponse().setBody("1347"));
-    long longResponse = service.longPrimitive();
-    assertThat(longResponse).isEqualTo(1347L);
+        server.enqueue(new MockResponse().setBody("13"));
+        int integerResponse = service.integerPrimitive();
+        assertThat(integerResponse).isEqualTo(13);
 
-    server.enqueue(new MockResponse().setBody("134"));
-    short shortResponse = service.shortPrimitive();
-    assertThat(shortResponse).isEqualTo((short) 134);
-  }
+        server.enqueue(new MockResponse().setBody("1347"));
+        long longResponse = service.longPrimitive();
+        assertThat(longResponse).isEqualTo(1347L);
+
+        server.enqueue(new MockResponse().setBody("134"));
+        short shortResponse = service.shortPrimitive();
+        assertThat(shortResponse).isEqualTo((short) 134);
+    }
 }
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index d23c79a59..bcbe59c3b 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -1,43 +1,44 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-simplexml</artifactId>
-  <name>Converter: SimpleXML</name>
+    <artifactId>converter-simplexml</artifactId>
+    <name>Converter: SimpleXML</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.simpleframework</groupId>
-      <artifactId>simple-xml</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.simpleframework</groupId>
+            <artifactId>simple-xml</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
index b7563455e..c418a2676 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlConverterFactory.java
@@ -17,10 +17,13 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+
 import org.simpleframework.xml.Serializer;
 import org.simpleframework.xml.core.Persister;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
@@ -31,55 +34,55 @@
  * not handled.
  */
 public final class SimpleXmlConverterFactory extends Converter.Factory {
-  /** Create an instance using a default {@link Persister} instance for conversion. */
-  public static SimpleXmlConverterFactory create() {
-    return create(new Persister());
-  }
+    /** Create an instance using a default {@link Persister} instance for conversion. */
+    public static SimpleXmlConverterFactory create() {
+        return create(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for conversion. */
-  public static SimpleXmlConverterFactory create(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, true);
-  }
+    /** Create an instance using {@code serializer} for conversion. */
+    public static SimpleXmlConverterFactory create(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, true);
+    }
 
-  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict() {
-    return createNonStrict(new Persister());
-  }
+    /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
+    public static SimpleXmlConverterFactory createNonStrict() {
+        return createNonStrict(new Persister());
+    }
 
-  /** Create an instance using {@code serializer} for non-strict conversion. */
-  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
-    return new SimpleXmlConverterFactory(serializer, false);
-  }
+    /** Create an instance using {@code serializer} for non-strict conversion. */
+    public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+        return new SimpleXmlConverterFactory(serializer, false);
+    }
 
-  private final Serializer serializer;
-  private final boolean strict;
+    private final Serializer serializer;
+    private final boolean strict;
 
-  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
-    if (serializer == null) throw new NullPointerException("serializer == null");
-    this.serializer = serializer;
-    this.strict = strict;
-  }
+    private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+        if (serializer == null) throw new NullPointerException("serializer == null");
+        this.serializer = serializer;
+        this.strict = strict;
+    }
 
-  public boolean isStrict() {
-    return strict;
-  }
+    public boolean isStrict() {
+        return strict;
+    }
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        Class<?> cls = (Class<?>) type;
+        return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
     }
-    Class<?> cls = (Class<?>) type;
-    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class)) {
-      return null;
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class)) {
+            return null;
+        }
+        return new SimpleXmlRequestBodyConverter<>(serializer);
     }
-    return new SimpleXmlRequestBodyConverter<>(serializer);
-  }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
index 06aeee1e6..30b7a57c8 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlRequestBodyConverter.java
@@ -17,31 +17,35 @@
 
 import java.io.IOException;
 import java.io.OutputStreamWriter;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
+
 import org.simpleframework.xml.Serializer;
+
 import retrofit2.Converter;
 
 final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
-  private static final String CHARSET = "UTF-8";
-
-  private final Serializer serializer;
-
-  SimpleXmlRequestBodyConverter(Serializer serializer) {
-    this.serializer = serializer;
-  }
-
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    try {
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(value, osw);
-      osw.flush();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+    private static final String CHARSET = "UTF-8";
+
+    private final Serializer serializer;
+
+    SimpleXmlRequestBodyConverter(Serializer serializer) {
+        this.serializer = serializer;
+    }
+
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        try {
+            OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+            serializer.write(value, osw);
+            osw.flush();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+        return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
     }
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
-  }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
index 01759f449..540c1c71e 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit2/converter/simplexml/SimpleXmlResponseBodyConverter.java
@@ -16,34 +16,38 @@
 package retrofit2.converter.simplexml;
 
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
+
 import org.simpleframework.xml.Serializer;
+
 import retrofit2.Converter;
 
 final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
-  private final Class<T> cls;
-  private final Serializer serializer;
-  private final boolean strict;
+    private final Class<T> cls;
+    private final Serializer serializer;
+    private final boolean strict;
 
-  SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
-    this.cls = cls;
-    this.serializer = serializer;
-    this.strict = strict;
-  }
+    SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
+        this.cls = cls;
+        this.serializer = serializer;
+        this.strict = strict;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      T read = serializer.read(cls, value.charStream(), strict);
-      if (read == null) {
-        throw new IllegalStateException("Could not deserialize body as " + cls);
-      }
-      return read;
-    } catch (RuntimeException | IOException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            T read = serializer.read(cls, value.charStream(), strict);
+            if (read == null) {
+                throw new IllegalStateException("Could not deserialize body as " + cls);
+            }
+            return read;
+        } catch (RuntimeException | IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
index 18d2e146f..952d9011a 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/MyObject.java
@@ -21,45 +21,49 @@
 
 @Default(value = DefaultType.FIELD)
 final class MyObject {
-  @Element private String message;
-  @Element private int count;
+    @Element
+    private String message;
+    @Element
+    private int count;
 
-  public MyObject() {
-  }
+    public MyObject() {
+    }
 
-  public MyObject(String message, int count) {
-    this.message = message;
-    this.count = count;
-  }
+    public MyObject(String message, int count) {
+        this.message = message;
+        this.count = count;
+    }
 
-  public void setMessage(String message) {
-    this.message = message;
-  }
+    public void setMessage(String message) {
+        this.message = message;
+    }
 
-  public String getMessage() {
-    return message;
-  }
+    public String getMessage() {
+        return message;
+    }
 
-  public void setCount(int count) {
-    this.count = count;
-  }
+    public void setCount(int count) {
+        this.count = count;
+    }
 
-  public int getCount() {
-    return count;
-  }
+    public int getCount() {
+        return count;
+    }
 
-  @Override public int hashCode() {
-    int result = 1;
-    result = result * 31 + count;
-    result = result * 31 + (message == null ? 0 : message.hashCode());
-    return result;
-  }
+    @Override
+    public int hashCode() {
+        int result = 1;
+        result = result * 31 + count;
+        result = result * 31 + (message == null ? 0 : message.hashCode());
+        return result;
+    }
 
-  @Override public boolean equals(Object obj) {
-    if (obj == this) return true;
-    if (!(obj instanceof MyObject)) return false;
-    MyObject other = (MyObject) obj;
-    return count == other.count
-        && (message == null ? other.message == null : message.equals(other.message));
-  }
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) return true;
+        if (!(obj instanceof MyObject)) return false;
+        MyObject other = (MyObject) obj;
+        return count == other.count
+                && (message == null ? other.message == null : message.equals(other.message));
+    }
 }
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
index 7ad58b22d..ca620f029 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit2/converter/simplexml/SimpleXmlConverterFactoryTest.java
@@ -17,10 +17,12 @@
 
 import java.io.IOException;
 import java.nio.charset.Charset;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -29,6 +31,7 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -40,79 +43,91 @@
 import static org.junit.Assert.fail;
 
 public class SimpleXmlConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<MyObject> get();
-    @POST("/") Call<MyObject> post(@Body MyObject impl);
-    @GET("/") Call<String> wrongClass();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-    Persister persister = new Persister(format);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(SimpleXmlConverterFactory.create(persister))
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodyWays() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
-
-    Call<MyObject> call = service.post(new MyObject("hello world", 10));
-    Response<MyObject> response = call.execute();
-    MyObject body = response.body();
-    assertThat(body.getMessage()).isEqualTo("hello world");
-    assertThat(body.getCount()).isEqualTo(10);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isIn(
-        "<my-object><message>hello world</message><count>10</count></my-object>",
-        "<my-object><count>10</count><message>hello world</message></my-object>");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
-  }
-
-  @Test public void honorsCharacterEncoding() throws IOException {
-    Buffer buffer = new Buffer().writeString(
-        "<my-object><message></message><count>10</count></my-object>",
-        Charset.forName("GBK"));
-    server.enqueue(
-        new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
-
-    Call<MyObject> call = service.get();
-    Response<MyObject> response = call.execute();
-    MyObject body = response.body();
-    assertThat(body.getMessage()).isEqualTo("");
-  }
-
-  @Test public void deserializeWrongValue() throws IOException {
-    server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
-
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
+    interface Service {
+        @GET("/")
+        Call<MyObject> get();
+
+        @POST("/")
+        Call<MyObject> post(@Body MyObject impl);
+
+        @GET("/")
+        Call<String> wrongClass();
     }
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
-
-    Call<?> call = service.wrongClass();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+        Persister persister = new Persister(format);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(SimpleXmlConverterFactory.create(persister))
+                .build();
+        service = retrofit.create(Service.class);
+    }
+
+    @Test
+    public void bodyWays() throws IOException, InterruptedException {
+        server.enqueue(new MockResponse().setBody(
+                "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+        Call<MyObject> call = service.post(new MyObject("hello world", 10));
+        Response<MyObject> response = call.execute();
+        MyObject body = response.body();
+        assertThat(body.getMessage()).isEqualTo("hello world");
+        assertThat(body.getCount()).isEqualTo(10);
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readUtf8()).isIn(
+                "<my-object><message>hello world</message><count>10</count></my-object>",
+                "<my-object><count>10</count><message>hello world</message></my-object>");
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
+    }
+
+    @Test
+    public void honorsCharacterEncoding() throws IOException {
+        Buffer buffer = new Buffer().writeString(
+                "<my-object><message></message><count>10</count></my-object>",
+                Charset.forName("GBK"));
+        server.enqueue(
+                new MockResponse().setBody(buffer).addHeader("Content-Type", "text/xml;charset=GBK"));
+
+        Call<MyObject> call = service.get();
+        Response<MyObject> response = call.execute();
+        MyObject body = response.body();
+        assertThat(body.getMessage()).isEqualTo("");
+    }
+
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e.getCause()).isInstanceOf(ElementException.class)
+                                    .hasMessageStartingWith(
+                                            "Element 'foo' does not have a match in class retrofit2.converter.simplexml.MyObject");
+        }
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        server.enqueue(new MockResponse().setBody(
+                "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+        Call<?> call = service.wrongClass();
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index 497eb41aa..a433a017d 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -4,51 +4,52 @@
   ~ Copyright 2013 Square, Inc.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-converters</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>retrofit-converters</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>converter-wire</artifactId>
-  <name>Converter: Wire Protocol Buffers</name>
+    <artifactId>converter-wire</artifactId>
+    <name>Converter: Wire Protocol Buffers</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.wire</groupId>
-      <artifactId>wire-runtime</artifactId>
-      <exclusions>
-        <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
-        <exclusion>
-          <groupId>com.squareup.okio</groupId>
-          <artifactId>okio</artifactId>
-        </exclusion>
-      </exclusions>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.wire</groupId>
+            <artifactId>wire-runtime</artifactId>
+            <exclusions>
+                <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
+                <exclusion>
+                    <groupId>com.squareup.okio</groupId>
+                    <artifactId>okio</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
index fbaaeac4a..6c0ab2b20 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireConverterFactory.java
@@ -17,8 +17,10 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
@@ -30,40 +32,40 @@
  * This converter only applies for types which extend from {@link Message}.
  */
 public final class WireConverterFactory extends Converter.Factory {
-  public static WireConverterFactory create() {
-    return new WireConverterFactory();
-  }
-
-  private WireConverterFactory() {
-  }
-
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+    public static WireConverterFactory create() {
+        return new WireConverterFactory();
     }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      return null;
+
+    private WireConverterFactory() {
     }
-    //noinspection unchecked
-    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
-    return new WireResponseBodyConverter<>(adapter);
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (!(type instanceof Class<?>)) {
-      return null;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!Message.class.isAssignableFrom(c)) {
+            return null;
+        }
+        //noinspection unchecked
+        ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+        return new WireResponseBodyConverter<>(adapter);
     }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      return null;
+
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (!(type instanceof Class<?>)) {
+            return null;
+        }
+        Class<?> c = (Class<?>) type;
+        if (!Message.class.isAssignableFrom(c)) {
+            return null;
+        }
+        //noinspection unchecked
+        ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
+        return new WireRequestBodyConverter<>(adapter);
     }
-    //noinspection unchecked
-    ProtoAdapter<? extends Message> adapter = ProtoAdapter.get((Class<? extends Message>) c);
-    return new WireRequestBodyConverter<>(adapter);
-  }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
index d388a944c..5717d4080 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireRequestBodyConverter.java
@@ -17,24 +17,27 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okio.Buffer;
 import retrofit2.Converter;
 
 final class WireRequestBodyConverter<T extends Message<T, ?>> implements Converter<T, RequestBody> {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+    private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  private final ProtoAdapter<T> adapter;
+    private final ProtoAdapter<T> adapter;
 
-  WireRequestBodyConverter(ProtoAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    WireRequestBodyConverter(ProtoAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public RequestBody convert(T value) throws IOException {
-    Buffer buffer = new Buffer();
-    adapter.encode(buffer, value);
-    return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
-  }
+    @Override
+    public RequestBody convert(T value) throws IOException {
+        Buffer buffer = new Buffer();
+        adapter.encode(buffer, value);
+        return RequestBody.create(MEDIA_TYPE, buffer.snapshot());
+    }
 }
diff --git a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
index 5ab321381..b040b289c 100644
--- a/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit2/converter/wire/WireResponseBodyConverter.java
@@ -17,23 +17,26 @@
 
 import com.squareup.wire.Message;
 import com.squareup.wire.ProtoAdapter;
+
 import java.io.IOException;
+
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 
 final class WireResponseBodyConverter<T extends Message<T, ?>>
-    implements Converter<ResponseBody, T> {
-  private final ProtoAdapter<T> adapter;
+        implements Converter<ResponseBody, T> {
+    private final ProtoAdapter<T> adapter;
 
-  WireResponseBodyConverter(ProtoAdapter<T> adapter) {
-    this.adapter = adapter;
-  }
+    WireResponseBodyConverter(ProtoAdapter<T> adapter) {
+        this.adapter = adapter;
+    }
 
-  @Override public T convert(ResponseBody value) throws IOException {
-    try {
-      return adapter.decode(value.source());
-    } finally {
-      value.close();
+    @Override
+    public T convert(ResponseBody value) throws IOException {
+        try {
+            return adapter.decode(value.source());
+        } finally {
+            value.close();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
index c085094bb..50ecabc4b 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/Phone.java
@@ -9,127 +9,131 @@
 import com.squareup.wire.ProtoWriter;
 import com.squareup.wire.WireField;
 import com.squareup.wire.internal.Internal;
+
 import java.io.IOException;
 import java.lang.Object;
 import java.lang.Override;
 import java.lang.String;
 import java.lang.StringBuilder;
+
 import okio.ByteString;
 
 public final class Phone extends Message<Phone, Phone.Builder> {
-  public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
-
-  private static final long serialVersionUID = 0L;
-
-  public static final String DEFAULT_NUMBER = "";
-
-  @WireField(
-      tag = 1,
-      adapter = "com.squareup.wire.ProtoAdapter#STRING"
-  )
-  public final String number;
-
-  public Phone(String number) {
-    this(number, ByteString.EMPTY);
-  }
-
-  public Phone(String number, ByteString unknownFields) {
-    super(ADAPTER, unknownFields);
-    this.number = number;
-  }
-
-  @Override
-  public Builder newBuilder() {
-    Builder builder = new Builder();
-    builder.number = number;
-    builder.addUnknownFields(unknownFields());
-    return builder;
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) return true;
-    if (!(other instanceof Phone)) return false;
-    Phone o = (Phone) other;
-    return Internal.equals(unknownFields(), o.unknownFields())
-        && Internal.equals(number, o.number);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode;
-    if (result == 0) {
-      result = unknownFields().hashCode();
-      result = result * 37 + (number != null ? number.hashCode() : 0);
-      super.hashCode = result;
-    }
-    return result;
-  }
+    public static final ProtoAdapter<Phone> ADAPTER = new ProtoAdapter_Phone();
 
-  @Override
-  public String toString() {
-    StringBuilder builder = new StringBuilder();
-    if (number != null) builder.append(", number=").append(number);
-    return builder.replace(0, 2, "Phone{").append('}').toString();
-  }
+    private static final long serialVersionUID = 0L;
 
-  public static final class Builder extends Message.Builder<Phone, Builder> {
-    public String number;
+    public static final String DEFAULT_NUMBER = "";
 
-    public Builder() {
+    @WireField(
+            tag = 1,
+            adapter = "com.squareup.wire.ProtoAdapter#STRING"
+    )
+    public final String number;
+
+    public Phone(String number) {
+        this(number, ByteString.EMPTY);
     }
 
-    public Builder number(String number) {
-      this.number = number;
-      return this;
+    public Phone(String number, ByteString unknownFields) {
+        super(ADAPTER, unknownFields);
+        this.number = number;
     }
 
     @Override
-    public Phone build() {
-      return new Phone(number, buildUnknownFields());
+    public Builder newBuilder() {
+        Builder builder = new Builder();
+        builder.number = number;
+        builder.addUnknownFields(unknownFields());
+        return builder;
     }
-  }
 
-  private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
-    ProtoAdapter_Phone() {
-      super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (!(other instanceof Phone)) return false;
+        Phone o = (Phone) other;
+        return Internal.equals(unknownFields(), o.unknownFields())
+                && Internal.equals(number, o.number);
     }
 
     @Override
-    public int encodedSize(Phone value) {
-      return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
-          + value.unknownFields().size();
+    public int hashCode() {
+        int result = super.hashCode;
+        if (result == 0) {
+            result = unknownFields().hashCode();
+            result = result * 37 + (number != null ? number.hashCode() : 0);
+            super.hashCode = result;
+        }
+        return result;
     }
 
     @Override
-    public void encode(ProtoWriter writer, Phone value) throws IOException {
-      if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
-      writer.writeBytes(value.unknownFields());
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        if (number != null) builder.append(", number=").append(number);
+        return builder.replace(0, 2, "Phone{").append('}').toString();
     }
 
-    @Override
-    public Phone decode(ProtoReader reader) throws IOException {
-      Builder builder = new Builder();
-      long token = reader.beginMessage();
-      for (int tag; (tag = reader.nextTag()) != -1;) {
-        switch (tag) {
-          case 1: builder.number(ProtoAdapter.STRING.decode(reader)); break;
-          default: {
-            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
-            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
-            builder.addUnknownField(tag, fieldEncoding, value);
-          }
+    public static final class Builder extends Message.Builder<Phone, Builder> {
+        public String number;
+
+        public Builder() {
+        }
+
+        public Builder number(String number) {
+            this.number = number;
+            return this;
+        }
+
+        @Override
+        public Phone build() {
+            return new Phone(number, buildUnknownFields());
         }
-      }
-      reader.endMessage(token);
-      return builder.build();
     }
 
-    @Override
-    public Phone redact(Phone value) {
-      Builder builder = value.newBuilder();
-      builder.clearUnknownFields();
-      return builder.build();
+    private static final class ProtoAdapter_Phone extends ProtoAdapter<Phone> {
+        ProtoAdapter_Phone() {
+            super(FieldEncoding.LENGTH_DELIMITED, Phone.class);
+        }
+
+        @Override
+        public int encodedSize(Phone value) {
+            return (value.number != null ? ProtoAdapter.STRING.encodedSizeWithTag(1, value.number) : 0)
+                    + value.unknownFields().size();
+        }
+
+        @Override
+        public void encode(ProtoWriter writer, Phone value) throws IOException {
+            if (value.number != null) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.number);
+            writer.writeBytes(value.unknownFields());
+        }
+
+        @Override
+        public Phone decode(ProtoReader reader) throws IOException {
+            Builder builder = new Builder();
+            long token = reader.beginMessage();
+            for (int tag; (tag = reader.nextTag()) != -1; ) {
+                switch (tag) {
+                    case 1:
+                        builder.number(ProtoAdapter.STRING.decode(reader));
+                        break;
+                    default: {
+                        FieldEncoding fieldEncoding = reader.peekFieldEncoding();
+                        Object value = fieldEncoding.rawProtoAdapter().decode(reader);
+                        builder.addUnknownField(tag, fieldEncoding, value);
+                    }
+                }
+            }
+            reader.endMessage(token);
+            return builder.build();
+        }
+
+        @Override
+        public Phone redact(Phone value) {
+            Builder builder = value.newBuilder();
+            builder.clearUnknownFields();
+            return builder.build();
+        }
     }
-  }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
index e972d5287..0a979775e 100644
--- a/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit2/converter/wire/WireConverterFactoryTest.java
@@ -18,14 +18,17 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.ByteString;
+
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Response;
 import retrofit2.Retrofit;
@@ -37,95 +40,109 @@
 import static org.junit.Assert.fail;
 
 public final class WireConverterFactoryTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(WireConverterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(new Phone("(519) 867-5309"));
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isNull();
-  }
-
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongClass();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method Service.wrongClass");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+    interface Service {
+        @GET("/")
+        Call<Phone> get();
+
+        @POST("/")
+        Call<Phone> post(@Body Phone impl);
+
+        @GET("/")
+        Call<String> wrongClass();
+
+        @GET("/")
+        Call<List<String>> wrongType();
     }
-  }
-
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    try {
-      service.wrongType();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for java.util.List<java.lang.String>\n"
-          + "    for method Service.wrongType");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.converter.wire.WireConverterFactory");
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    private Service service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(WireConverterFactory.create())
+                .build();
+        service = retrofit.create(Service.class);
     }
-  }
 
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+    @Test
+    public void serializeAndDeserialize() throws IOException, InterruptedException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<Phone> call = service.post(new Phone("(519) 867-5309"));
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.number).isEqualTo("(519) 867-5309");
+
+        RecordedRequest request = server.takeRequest();
+        assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+        assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+    }
+
+    @Test
+    public void deserializeEmpty() throws IOException {
+        server.enqueue(new MockResponse());
+
+        Call<Phone> call = service.get();
+        Response<Phone> response = call.execute();
+        Phone body = response.body();
+        assertThat(body.number).isNull();
+    }
+
+    @Test
+    public void deserializeWrongClass() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongClass();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method Service.wrongClass");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.wire.WireConverterFactory");
+        }
+    }
+
+    @Test
+    public void deserializeWrongType() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        try {
+            service.wrongType();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for java.util.List<java.lang.String>\n"
+                    + "    for method Service.wrongType");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for java.util.List<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.converter.wire.WireConverterFactory");
+        }
+    }
 
-    Call<?> call = service.get();
-    try {
-      call.execute();
-      fail();
-    } catch (EOFException ignored) {
+    @Test
+    public void deserializeWrongValue() throws IOException {
+        ByteString encoded = ByteString.decodeBase64("////");
+        server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+        Call<?> call = service.get();
+        try {
+            call.execute();
+            fail();
+        } catch (EOFException ignored) {
+        }
     }
-  }
 }
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index 9d741819b..7014c9eac 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -1,39 +1,40 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit-mock</artifactId>
-  <name>Retrofit Mock Adapter</name>
+    <artifactId>retrofit-mock</artifactId>
+    <name>Retrofit Mock Adapter</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f7..a8c46535f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -28,117 +29,131 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 final class BehaviorCall<T> implements Call<T> {
-  final NetworkBehavior behavior;
-  final ExecutorService backgroundExecutor;
-  final Call<T> delegate;
-
-  private volatile Future<?> task;
-  volatile boolean canceled;
-  private volatile boolean executed;
-
-  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
-    this.behavior = behavior;
-    this.backgroundExecutor = backgroundExecutor;
-    this.delegate = delegate;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public Call<T> clone() {
-    return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
-  }
-
-  @Override public Request request() {
-    return delegate.request();
-  }
-
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed");
-      executed = true;
+    final NetworkBehavior behavior;
+    final ExecutorService backgroundExecutor;
+    final Call<T> delegate;
+
+    private volatile Future<?> task;
+    volatile boolean canceled;
+    private volatile boolean executed;
+
+    BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor, Call<T> delegate) {
+        this.behavior = behavior;
+        this.backgroundExecutor = backgroundExecutor;
+        this.delegate = delegate;
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public Call<T> clone() {
+        return new BehaviorCall<>(behavior, backgroundExecutor, delegate.clone());
+    }
+
+    @Override
+    public Request request() {
+        return delegate.request();
     }
-    task = backgroundExecutor.submit(new Runnable() {
-      boolean delaySleep() {
-        long sleepMs = behavior.calculateDelay(MILLISECONDS);
-        if (sleepMs > 0) {
-          try {
-            Thread.sleep(sleepMs);
-          } catch (InterruptedException e) {
-            callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-            return false;
-          }
+
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed");
+            executed = true;
         }
-        return true;
-      }
-
-      @Override public void run() {
-        if (canceled) {
-          callback.onFailure(BehaviorCall.this, new IOException("canceled"));
-        } else if (behavior.calculateIsFailure()) {
-          if (delaySleep()) {
-            callback.onFailure(BehaviorCall.this, behavior.failureException());
-          }
-        } else {
-          delegate.enqueue(new Callback<T>() {
-            @Override public void onResponse(Call<T> call, Response<T> response) {
-              if (delaySleep()) {
-                callback.onResponse(call, response);
-              }
+        task = backgroundExecutor.submit(new Runnable() {
+            boolean delaySleep() {
+                long sleepMs = behavior.calculateDelay(MILLISECONDS);
+                if (sleepMs > 0) {
+                    try {
+                        Thread.sleep(sleepMs);
+                    } catch (InterruptedException e) {
+                        callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                        return false;
+                    }
+                }
+                return true;
             }
 
-            @Override public void onFailure(Call<T> call, Throwable t) {
-              if (delaySleep()) {
-                callback.onFailure(call, t);
-              }
+            @Override
+            public void run() {
+                if (canceled) {
+                    callback.onFailure(BehaviorCall.this, new IOException("canceled"));
+                }
+                else if (behavior.calculateIsFailure()) {
+                    if (delaySleep()) {
+                        callback.onFailure(BehaviorCall.this, behavior.failureException());
+                    }
+                }
+                else {
+                    delegate.enqueue(new Callback<T>() {
+                        @Override
+                        public void onResponse(Call<T> call, Response<T> response) {
+                            if (delaySleep()) {
+                                callback.onResponse(call, response);
+                            }
+                        }
+
+                        @Override
+                        public void onFailure(Call<T> call, Throwable t) {
+                            if (delaySleep()) {
+                                callback.onFailure(call, t);
+                            }
+                        }
+                    });
+                }
             }
-          });
+        });
+    }
+
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
+    }
+
+    @Override
+    public Response<T> execute() throws IOException {
+        final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        enqueue(new Callback<T>() {
+            @Override
+            public void onResponse(Call<T> call, Response<T> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<T> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new IOException("canceled");
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    enqueue(new Callback<T>() {
-      @Override public void onResponse(Call<T> call, Response<T> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<T> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    try {
-      latch.await();
-    } catch (InterruptedException e) {
-      throw new IOException("canceled");
+        Response<T> response = responseRef.get();
+        if (response != null) return response;
+        Throwable failure = failureRef.get();
+        if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+        if (failure instanceof IOException) throw (IOException) failure;
+        throw new RuntimeException(failure);
     }
-    Response<T> response = responseRef.get();
-    if (response != null) return response;
-    Throwable failure = failureRef.get();
-    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
-    if (failure instanceof IOException) throw (IOException) failure;
-    throw new RuntimeException(failure);
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    Future<?> task = this.task;
-    if (task != null) {
-      task.cancel(true);
+
+    @Override
+    public void cancel() {
+        canceled = true;
+        Future<?> task = this.task;
+        if (task != null) {
+            task.cancel(true);
+        }
     }
-  }
 
-  @Override public boolean isCanceled() {
-    return canceled;
-  }
+    @Override
+    public boolean isCanceled() {
+        return canceled;
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
index 21af3a6d3..890d5b6b2 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorDelegate.java
@@ -21,6 +21,7 @@
 import java.lang.reflect.Proxy;
 import java.lang.reflect.Type;
 import java.util.concurrent.ExecutorService;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -33,36 +34,36 @@
  * @see MockRetrofit#create(Class)
  */
 public final class BehaviorDelegate<T> {
-  final Retrofit retrofit;
-  private final NetworkBehavior behavior;
-  private final ExecutorService executor;
-  private final Class<T> service;
+    final Retrofit retrofit;
+    private final NetworkBehavior behavior;
+    private final ExecutorService executor;
+    private final Class<T> service;
 
-  BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor,
-      Class<T> service) {
-    this.retrofit = retrofit;
-    this.behavior = behavior;
-    this.executor = executor;
-    this.service = service;
-  }
+    BehaviorDelegate(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor,
+            Class<T> service) {
+        this.retrofit = retrofit;
+        this.behavior = behavior;
+        this.executor = executor;
+        this.service = service;
+    }
 
-  public T returningResponse(Object response) {
-    return returning(Calls.response(response));
-  }
+    public T returningResponse(Object response) {
+        return returning(Calls.response(response));
+    }
 
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <R> T returning(Call<R> call) {
-    final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
-        new InvocationHandler() {
-          @Override
-          public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
-            Type returnType = method.getGenericReturnType();
-            Annotation[] methodAnnotations = method.getAnnotations();
-            CallAdapter<R, T> callAdapter =
-                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
-            return callAdapter.adapt(behaviorCall);
-          }
-        });
-  }
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <R> T returning(Call<R> call) {
+        final Call<R> behaviorCall = new BehaviorCall<>(behavior, executor, call);
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[]{service},
+                new InvocationHandler() {
+                    @Override
+                    public T invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                        Type returnType = method.getGenericReturnType();
+                        Annotation[] methodAnnotations = method.getAnnotations();
+                        CallAdapter<R, T> callAdapter =
+                                (CallAdapter<R, T>) retrofit.callAdapter(returnType, methodAnnotations);
+                        return callAdapter.adapt(behaviorCall);
+                    }
+                });
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490aee..baebc530f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,6 +16,7 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -23,75 +24,89 @@
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
-  public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
-  }
-
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        return response;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onResponse(this, response);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return response.raw().request();
-      }
-    };
-  }
-
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
-      }
-
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
-
-      @Override public boolean isExecuted() {
-        return false;
-      }
-
-      @Override public void cancel() {
-      }
-
-      @Override public boolean isCanceled() {
-        return false;
-      }
-
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
-
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
-
-  private Calls() {
-    throw new AssertionError("No instances.");
-  }
+    public static <T> Call<T> response(T successValue) {
+        return response(Response.success(successValue));
+    }
+
+    public static <T> Call<T> response(final Response<T> response) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                return response;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onResponse(this, response);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return response.raw().request();
+            }
+        };
+    }
+
+    public static <T> Call<T> failure(final IOException failure) {
+        return new Call<T>() {
+            @Override
+            public Response<T> execute() throws IOException {
+                throw failure;
+            }
+
+            @Override
+            public void enqueue(Callback<T> callback) {
+                callback.onFailure(this, failure);
+            }
+
+            @Override
+            public boolean isExecuted() {
+                return false;
+            }
+
+            @Override
+            public void cancel() {
+            }
+
+            @Override
+            public boolean isCanceled() {
+                return false;
+            }
+
+            @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+            @Override
+            public Call<T> clone() {
+                return this;
+            }
+
+            @Override
+            public Request request() {
+                return new Request.Builder().url("http://localhost").build();
+            }
+        };
+    }
+
+    private Calls() {
+        throw new AssertionError("No instances.");
+    }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
index 3c75b47a2..5a93accce 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/MockRetrofit.java
@@ -18,62 +18,63 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+
 import retrofit2.Retrofit;
 
 public final class MockRetrofit {
-  private final Retrofit retrofit;
-  private final NetworkBehavior behavior;
-  private final ExecutorService executor;
+    private final Retrofit retrofit;
+    private final NetworkBehavior behavior;
+    private final ExecutorService executor;
 
-  MockRetrofit(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor) {
-    this.retrofit = retrofit;
-    this.behavior = behavior;
-    this.executor = executor;
-  }
+    MockRetrofit(Retrofit retrofit, NetworkBehavior behavior, ExecutorService executor) {
+        this.retrofit = retrofit;
+        this.behavior = behavior;
+        this.executor = executor;
+    }
 
-  public Retrofit retrofit() {
-    return retrofit;
-  }
+    public Retrofit retrofit() {
+        return retrofit;
+    }
 
-  public NetworkBehavior networkBehavior() {
-    return behavior;
-  }
+    public NetworkBehavior networkBehavior() {
+        return behavior;
+    }
 
-  public Executor backgroundExecutor() {
-    return executor;
-  }
+    public Executor backgroundExecutor() {
+        return executor;
+    }
 
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> BehaviorDelegate<T> create(Class<T> service) {
-    return new BehaviorDelegate<>(retrofit, behavior, executor, service);
-  }
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> BehaviorDelegate<T> create(Class<T> service) {
+        return new BehaviorDelegate<>(retrofit, behavior, executor, service);
+    }
 
-  public static final class Builder {
-    private final Retrofit retrofit;
-    private NetworkBehavior behavior;
-    private ExecutorService executor;
+    public static final class Builder {
+        private final Retrofit retrofit;
+        private NetworkBehavior behavior;
+        private ExecutorService executor;
 
-    public Builder(Retrofit retrofit) {
-      if (retrofit == null) throw new NullPointerException("retrofit == null");
-      this.retrofit = retrofit;
-    }
+        public Builder(Retrofit retrofit) {
+            if (retrofit == null) throw new NullPointerException("retrofit == null");
+            this.retrofit = retrofit;
+        }
 
-    public Builder networkBehavior(NetworkBehavior behavior) {
-      if (behavior == null) throw new NullPointerException("behavior == null");
-      this.behavior = behavior;
-      return this;
-    }
+        public Builder networkBehavior(NetworkBehavior behavior) {
+            if (behavior == null) throw new NullPointerException("behavior == null");
+            this.behavior = behavior;
+            return this;
+        }
 
-    public Builder backgroundExecutor(ExecutorService executor) {
-      if (executor == null) throw new NullPointerException("executor == null");
-      this.executor = executor;
-      return this;
-    }
+        public Builder backgroundExecutor(ExecutorService executor) {
+            if (executor == null) throw new NullPointerException("executor == null");
+            this.executor = executor;
+            return this;
+        }
 
-    public MockRetrofit build() {
-      if (behavior == null) behavior = NetworkBehavior.create();
-      if (executor == null) executor = Executors.newCachedThreadPool();
-      return new MockRetrofit(retrofit, behavior, executor);
+        public MockRetrofit build() {
+            if (behavior == null) behavior = NetworkBehavior.create();
+            if (executor == null) executor = Executors.newCachedThreadPool();
+            return new MockRetrofit(retrofit, behavior, executor);
+        }
     }
-  }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 8108c1d63..4122a46ac 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -37,124 +37,124 @@
  * will occur 3% of the time.
  */
 public final class NetworkBehavior {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by 40%.
-  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+    private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+    private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by 40%.
+    private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+
+    /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+    public interface Adapter<T> {
+        /**
+         * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+         * traits when interacted with.
+         */
+        T applyBehavior(NetworkBehavior behavior, T value);
+    }
+
+    /** Create an instance with default behavior. */
+    public static NetworkBehavior create() {
+        return new NetworkBehavior(new Random());
+    }
 
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
     /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
+     * Create an instance with default behavior which uses {@code random} to control variance and
+     * failure calculation.
      */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
-
-  /** Create an instance with default behavior. */
-  public static NetworkBehavior create() {
-    return new NetworkBehavior(new Random());
-  }
-
-  /**
-   * Create an instance with default behavior which uses {@code random} to control variance and
-   * failure calculation.
-   */
-  public static NetworkBehavior create(Random random) {
-    if (random == null) throw new NullPointerException("random == null");
-    return new NetworkBehavior(random);
-  }
-
-  private final Random random;
-
-  private volatile long delayMs = DEFAULT_DELAY_MS;
-  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
-  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
-  private volatile Throwable failureException;
-
-  private NetworkBehavior(Random random) {
-    this.random = random;
-
-    failureException = new IOException("Mock failure!");
-    failureException.setStackTrace(new StackTraceElement[0]);
-  }
-
-  /** Set the network round trip delay. */
-  public void setDelay(long amount, TimeUnit unit) {
-    if (amount < 0) {
-      throw new IllegalArgumentException("Amount must be positive value.");
+    public static NetworkBehavior create(Random random) {
+        if (random == null) throw new NullPointerException("random == null");
+        return new NetworkBehavior(random);
+    }
+
+    private final Random random;
+
+    private volatile long delayMs = DEFAULT_DELAY_MS;
+    private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+    private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+    private volatile Throwable failureException;
+
+    private NetworkBehavior(Random random) {
+        this.random = random;
+
+        failureException = new IOException("Mock failure!");
+        failureException.setStackTrace(new StackTraceElement[0]);
     }
-    this.delayMs = unit.toMillis(amount);
-  }
-
-  /** The network round trip delay. */
-  public long delay(TimeUnit unit) {
-    return MILLISECONDS.convert(delayMs, unit);
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercent(int variancePercent) {
-    if (variancePercent < 0 || variancePercent > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+
+    /** Set the network round trip delay. */
+    public void setDelay(long amount, TimeUnit unit) {
+        if (amount < 0) {
+            throw new IllegalArgumentException("Amount must be positive value.");
+        }
+        this.delayMs = unit.toMillis(amount);
+    }
+
+    /** The network round trip delay. */
+    public long delay(TimeUnit unit) {
+        return MILLISECONDS.convert(delayMs, unit);
+    }
+
+    /** Set the plus-or-minus variance percentage of the network round trip delay. */
+    public void setVariancePercent(int variancePercent) {
+        if (variancePercent < 0 || variancePercent > 100) {
+            throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+        }
+        this.variancePercent = variancePercent;
+    }
+
+    /** The plus-or-minus variance percentage of the network round trip delay. */
+    public int variancePercent() {
+        return variancePercent;
     }
-    this.variancePercent = variancePercent;
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int variancePercent() {
-    return variancePercent;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setFailurePercent(int failurePercent) {
-    if (failurePercent < 0 || failurePercent > 100) {
-      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+
+    /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+    public void setFailurePercent(int failurePercent) {
+        if (failurePercent < 0 || failurePercent > 100) {
+            throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+        }
+        this.failurePercent = failurePercent;
     }
-    this.failurePercent = failurePercent;
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int failurePercent() {
-    return failurePercent;
-  }
-
-  /**
-   * Set the exception to be used when a failure is triggered.
-   * <p>
-   * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
-   * point to code unrelated to this class.
-   */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+
+    /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+    public int failurePercent() {
+        return failurePercent;
+    }
+
+    /**
+     * Set the exception to be used when a failure is triggered.
+     * <p>
+     * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
+     * point to code unrelated to this class.
+     */
+    public void setFailureException(Throwable t) {
+        if (t == null) {
+            throw new NullPointerException("t == null");
+        }
+        this.failureException = t;
+    }
+
+    /** The exception to be used when a failure is triggered. */
+    public Throwable failureException() {
+        return failureException;
+    }
+
+    /**
+     * Randomly determine whether this call should result in a network failure in accordance with
+     * configured behavior. When true, {@link #failureException()} should be thrown.
+     */
+    public boolean calculateIsFailure() {
+        int randomValue = random.nextInt(100);
+        return randomValue < failurePercent;
+    }
+
+    /**
+     * Get the delay that should be used for delaying a response in accordance with configured
+     * behavior.
+     */
+    public long calculateDelay(TimeUnit unit) {
+        float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+        float lowerBound = 1f - delta; // 0.2f --> 0.8f
+        float upperBound = 1f + delta; // 0.2f --> 1.2f
+        float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+        float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+        long callDelayMs = (long) (delayMs * delayPercent);
+        return MILLISECONDS.convert(callDelayMs, unit);
     }
-    this.failureException = t;
-  }
-
-  /** The exception to be used when a failure is triggered. */
-  public Throwable failureException() {
-    return failureException;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure in accordance with
-   * configured behavior. When true, {@link #failureException()} should be thrown.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
-  }
-
-  /**
-   * Get the delay that should be used for delaying a response in accordance with configured
-   * behavior.
-   */
-  public long calculateDelay(TimeUnit unit) {
-    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - delta; // 0.2f --> 0.8f
-    float upperBound = 1f + delta; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
-    long callDelayMs = (long) (delayMs * delayPercent);
-    return MILLISECONDS.convert(callDelayMs, unit);
-  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
index 7199da059..b05c87fd3 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/BehaviorDelegateTest.java
@@ -22,8 +22,10 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+
 import org.junit.Before;
 import org.junit.Test;
+
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -36,263 +38,288 @@
 import static org.junit.Assert.fail;
 
 public final class BehaviorDelegateTest {
-  interface DoWorkService {
-    Call<String> response();
-    Call<String> failure();
-  }
-
-  private final IOException mockFailure = new IOException("Timeout!");
-  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
-  private DoWorkService service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-    final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
-
-    service = new DoWorkService() {
-      @Override public Call<String> response() {
-        Call<String> response = Calls.response("Response!");
-        return delegate.returning(response).response();
-      }
-
-      @Override public Call<String> failure() {
-        Call<String> failure = Calls.failure(mockFailure);
-        return delegate.returning(failure).failure();
-      }
-    };
-  }
-
-  @Test public void syncFailureThrowsAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(e).isSameAs(behavior.failureException());
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    interface DoWorkService {
+        Call<String> response();
+
+        Call<String> failure();
+    }
+
+    private final IOException mockFailure = new IOException("Timeout!");
+    private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+    private DoWorkService service;
+
+    @Before
+    public void setUp() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .build();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+        final BehaviorDelegate<DoWorkService> delegate = mockRetrofit.create(DoWorkService.class);
+
+        service = new DoWorkService() {
+            @Override
+            public Call<String> response() {
+                Call<String> response = Calls.response("Response!");
+                return delegate.returning(response).response();
+            }
+
+            @Override
+            public Call<String> failure() {
+                Call<String> failure = Calls.failure(mockFailure);
+                return delegate.returning(failure).failure();
+            }
+        };
+    }
+
+    @Test
+    public void syncFailureThrowsAfterDelay() {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(100);
+
+        Call<String> call = service.response();
+
+        long startNanos = System.nanoTime();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+            assertThat(e).isSameAs(behavior.failureException());
+            assertThat(tookMs).isGreaterThanOrEqualTo(100);
+        }
+    }
+
+    @Test
+    public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(100);
+
+        Call<String> call = service.response();
+
+        final long startNanos = System.nanoTime();
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(failureRef.get()).isSameAs(behavior.failureException());
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void syncSuccessReturnsAfterDelay() throws IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.response();
+
+        long startNanos = System.nanoTime();
+        Response<String> response = call.execute();
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+        assertThat(response.body()).isEqualTo("Response!");
+        assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.response();
+
+        final long startNanos = System.nanoTime();
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<String> actual = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                actual.set(response.body());
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                throw new AssertionError();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(actual.get()).isEqualTo("Response!");
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    }
+
+    @Test
+    public void syncFailureThrownAfterDelay() {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.failure();
+
+        long startNanos = System.nanoTime();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+            assertThat(tookMs).isGreaterThanOrEqualTo(100);
+            assertThat(e).isSameAs(mockFailure);
+        }
     }
-  }
-
-  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(failureRef.get()).isSameAs(behavior.failureException());
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    long startNanos = System.nanoTime();
-    Response<String> response = call.execute();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-
-    assertThat(response.body()).isEqualTo("Response!");
-    assertThat(tookMs).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.response();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<String> actual = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(response.body());
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(actual.get()).isEqualTo("Response!");
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void syncFailureThrownAfterDelay() {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e).isSameAs(mockFailure);
+
+    @Test
+    public void asyncFailureCalledAfterDelay() throws InterruptedException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        Call<String> call = service.failure();
+
+        final AtomicLong tookMs = new AtomicLong();
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        final long startNanos = System.nanoTime();
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(1, SECONDS));
+
+        assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+        assertThat(failureRef.get()).isSameAs(mockFailure);
     }
-  }
-
-  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Call<String> call = service.failure();
-
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    final long startNanos = System.nanoTime();
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(failureRef.get()).isSameAs(mockFailure);
-  }
-
-  @Test public void syncCanBeCanceled() throws IOException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    new Thread(new Runnable() {
-      @Override public void run() {
+
+    @Test
+    public void syncCanBeCanceled() throws IOException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Thread.sleep(100);
+                    call.cancel();
+                } catch (InterruptedException ignored) {
+                }
+            }
+        }).start();
+
         try {
-          Thread.sleep(100);
-          call.cancel();
-        } catch (InterruptedException ignored) {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
         }
-      }
-    }).start();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
     }
-  }
-
-  @Test public void asyncCanBeCanceled() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    // TODO we shouldn't need to sleep
-    Thread.sleep(100); // Ensure the task has started.
-    call.cancel();
-
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
-  }
-
-  @Test public void syncCanceledBeforeStart() throws IOException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+
+    @Test
+    public void asyncCanBeCanceled() throws InterruptedException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        // TODO we shouldn't need to sleep
+        Thread.sleep(100); // Ensure the task has started.
+        call.cancel();
+
+        assertTrue(latch.await(1, SECONDS));
+        assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+    }
+
+    @Test
+    public void syncCanceledBeforeStart() throws IOException {
+        behavior.setDelay(100, MILLISECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+
+        call.cancel();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
+        }
+    }
+
+    @Test
+    public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+        behavior.setDelay(10, SECONDS);
+        behavior.setVariancePercent(0);
+        behavior.setFailurePercent(0);
+
+        final Call<String> call = service.response();
+        call.cancel();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        assertTrue(latch.await(1, SECONDS));
+        assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
     }
-  }
-
-  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
-    behavior.setDelay(10, SECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    final Call<String> call = service.response();
-    call.cancel();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    assertTrue(latch.await(1, SECONDS));
-    assertThat(failureRef.get()).isExactlyInstanceOf(IOException.class).hasMessage("canceled");
-  }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
index 3599cc972..19aa6aa79 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/MockRetrofitTest.java
@@ -2,72 +2,82 @@
 
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+
 import org.junit.Test;
+
 import retrofit2.Retrofit;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class MockRetrofitTest {
-  private final Retrofit retrofit = new Retrofit.Builder().baseUrl("http://example.com").build();
-  private final NetworkBehavior behavior = NetworkBehavior.create();
-  private final ExecutorService executor = Executors.newSingleThreadExecutor();
+    private final Retrofit retrofit = new Retrofit.Builder().baseUrl("http://example.com").build();
+    private final NetworkBehavior behavior = NetworkBehavior.create();
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
 
-  @Test public void retrofitNullThrows() {
-    try {
-      new MockRetrofit.Builder(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("retrofit == null");
+    @Test
+    public void retrofitNullThrows() {
+        try {
+            new MockRetrofit.Builder(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("retrofit == null");
+        }
     }
-  }
 
-  @Test public void retrofitPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.retrofit()).isSameAs(retrofit);
-  }
+    @Test
+    public void retrofitPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.retrofit()).isSameAs(retrofit);
+    }
 
-  @Test public void networkBehaviorNullThrows() {
-    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
-    try {
-      builder.networkBehavior(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("behavior == null");
+    @Test
+    public void networkBehaviorNullThrows() {
+        MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
+        try {
+            builder.networkBehavior(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("behavior == null");
+        }
     }
-  }
 
-  @Test public void networkBehaviorDefault() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.networkBehavior()).isNotNull();
-  }
+    @Test
+    public void networkBehaviorDefault() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.networkBehavior()).isNotNull();
+    }
 
-  @Test public void networkBehaviorPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-    assertThat(mockRetrofit.networkBehavior()).isSameAs(behavior);
-  }
+    @Test
+    public void networkBehaviorPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+        assertThat(mockRetrofit.networkBehavior()).isSameAs(behavior);
+    }
 
-  @Test public void backgroundExecutorNullThrows() {
-    MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
-    try {
-      builder.backgroundExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
+    @Test
+    public void backgroundExecutorNullThrows() {
+        MockRetrofit.Builder builder = new MockRetrofit.Builder(retrofit);
+        try {
+            builder.backgroundExecutor(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("executor == null");
+        }
     }
-  }
 
-  @Test public void backgroundExecutorDefault() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
-    assertThat(mockRetrofit.backgroundExecutor()).isNotNull();
-  }
+    @Test
+    public void backgroundExecutorDefault() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit).build();
+        assertThat(mockRetrofit.backgroundExecutor()).isNotNull();
+    }
 
-  @Test public void backgroundExecutorPropagated() {
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .backgroundExecutor(executor)
-        .build();
-    assertThat(mockRetrofit.backgroundExecutor()).isSameAs(executor);
-  }
+    @Test
+    public void backgroundExecutorPropagated() {
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .backgroundExecutor(executor)
+                .build();
+        assertThat(mockRetrofit.backgroundExecutor()).isSameAs(executor);
+    }
 }
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 180737826..e8051ea0c 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.util.Random;
+
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -25,90 +26,96 @@
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
-  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
-
-  @Test public void defaultThrowable() {
-    Throwable t = behavior.failureException();
-    assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage("Mock failure!");
-    assertThat(t.getStackTrace()).isEmpty();
-  }
+    private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
 
-  @Test public void delayMustBePositive() {
-    try {
-      behavior.setDelay(-1, SECONDS);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Amount must be positive value.");
+    @Test
+    public void defaultThrowable() {
+        Throwable t = behavior.failureException();
+        assertThat(t).isExactlyInstanceOf(IOException.class).hasMessage("Mock failure!");
+        assertThat(t.getStackTrace()).isEmpty();
     }
-  }
 
-  @Test public void varianceRestrictsRange() {
-    try {
-      behavior.setVariancePercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-    try {
-      behavior.setVariancePercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    @Test
+    public void delayMustBePositive() {
+        try {
+            behavior.setDelay(-1, SECONDS);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Amount must be positive value.");
+        }
     }
-  }
 
-  @Test public void failureRestrictsRange() {
-    try {
-      behavior.setFailurePercent(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    @Test
+    public void varianceRestrictsRange() {
+        try {
+            behavior.setVariancePercent(-13);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+        }
+        try {
+            behavior.setVariancePercent(174);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+        }
     }
-    try {
-      behavior.setFailurePercent(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
-    }
-  }
 
-  @Test public void failurePercentageIsAccurate() {
-    behavior.setFailurePercent(0);
-    for (int i = 0; i < 10000; i++) {
-      assertThat(behavior.calculateIsFailure()).isFalse();
+    @Test
+    public void failureRestrictsRange() {
+        try {
+            behavior.setFailurePercent(-13);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+        }
+        try {
+            behavior.setFailurePercent(174);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+        }
     }
 
-    behavior.setFailurePercent(3);
-    int failures = 0;
-    for (int i = 0; i < 100000; i++) {
-      if (behavior.calculateIsFailure()) {
-        failures += 1;
-      }
+    @Test
+    public void failurePercentageIsAccurate() {
+        behavior.setFailurePercent(0);
+        for (int i = 0; i < 10000; i++) {
+            assertThat(behavior.calculateIsFailure()).isFalse();
+        }
+
+        behavior.setFailurePercent(3);
+        int failures = 0;
+        for (int i = 0; i < 100000; i++) {
+            if (behavior.calculateIsFailure()) {
+                failures += 1;
+            }
+        }
+        assertThat(failures).isEqualTo(2964); // ~3% of 100k
     }
-    assertThat(failures).isEqualTo(2964); // ~3% of 100k
-  }
 
-  @Test public void delayVarianceIsAccurate() {
-    behavior.setDelay(2, SECONDS);
+    @Test
+    public void delayVarianceIsAccurate() {
+        behavior.setDelay(2, SECONDS);
 
-    behavior.setVariancePercent(0);
-    for (int i = 0; i < 100000; i++) {
-      assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
-    }
+        behavior.setVariancePercent(0);
+        for (int i = 0; i < 100000; i++) {
+            assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
+        }
 
-    behavior.setVariancePercent(40);
-    long lowerBound = Integer.MAX_VALUE;
-    long upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      long delay = behavior.calculateDelay(MILLISECONDS);
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
+        behavior.setVariancePercent(40);
+        long lowerBound = Integer.MAX_VALUE;
+        long upperBound = Integer.MIN_VALUE;
+        for (int i = 0; i < 100000; i++) {
+            long delay = behavior.calculateDelay(MILLISECONDS);
+            if (delay > upperBound) {
+                upperBound = delay;
+            }
+            if (delay < lowerBound) {
+                lowerBound = delay;
+            }
+        }
+        assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+        assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
     }
-    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
-    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
-  }
 }
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 314c96636..7517e851e 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -1,65 +1,66 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>retrofit</artifactId>
-  <name>Retrofit</name>
+    <artifactId>retrofit</artifactId>
+    <name>Retrofit</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-    </dependency>
+    <dependencies>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+        </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <optional>true</optional>
-    </dependency>
+        <dependency>
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-annotations</artifactId>
+            <optional>true</optional>
+        </dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mockito</groupId>
-      <artifactId>mockito-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.robolectric</groupId>
-      <artifactId>robolectric</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.robolectric</groupId>
+            <artifactId>robolectric</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/retrofit/src/main/java/retrofit2/BuiltInConverters.java b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
index f729383a3..2b19b52e5 100644
--- a/retrofit/src/main/java/retrofit2/BuiltInConverters.java
+++ b/retrofit/src/main/java/retrofit2/BuiltInConverters.java
@@ -18,79 +18,85 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Streaming;
 
 final class BuiltInConverters extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (type == ResponseBody.class) {
-      return Utils.isAnnotationPresent(annotations, Streaming.class)
-          ? StreamingResponseBodyConverter.INSTANCE
-          : BufferingResponseBodyConverter.INSTANCE;
-    }
-    if (type == Void.class) {
-      return VoidResponseBodyConverter.INSTANCE;
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (type == ResponseBody.class) {
+            return Utils.isAnnotationPresent(annotations, Streaming.class)
+                    ? StreamingResponseBodyConverter.INSTANCE
+                    : BufferingResponseBodyConverter.INSTANCE;
+        }
+        if (type == Void.class) {
+            return VoidResponseBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
-      return RequestBodyConverter.INSTANCE;
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) {
+            return RequestBodyConverter.INSTANCE;
+        }
+        return null;
     }
-    return null;
-  }
 
-  static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
-    static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
+    static final class VoidResponseBodyConverter implements Converter<ResponseBody, Void> {
+        static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter();
 
-    @Override public Void convert(ResponseBody value) throws IOException {
-      value.close();
-      return null;
+        @Override
+        public Void convert(ResponseBody value) throws IOException {
+            value.close();
+            return null;
+        }
     }
-  }
 
-  static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
-    static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
+    static final class RequestBodyConverter implements Converter<RequestBody, RequestBody> {
+        static final RequestBodyConverter INSTANCE = new RequestBodyConverter();
 
-    @Override public RequestBody convert(RequestBody value) throws IOException {
-      return value;
+        @Override
+        public RequestBody convert(RequestBody value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class StreamingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
+    static final class StreamingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      return value;
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            return value;
+        }
     }
-  }
 
-  static final class BufferingResponseBodyConverter
-      implements Converter<ResponseBody, ResponseBody> {
-    static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
+    static final class BufferingResponseBodyConverter
+            implements Converter<ResponseBody, ResponseBody> {
+        static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter();
 
-    @Override public ResponseBody convert(ResponseBody value) throws IOException {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        return Utils.buffer(value);
-      } finally {
-        value.close();
-      }
+        @Override
+        public ResponseBody convert(ResponseBody value) throws IOException {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                return Utils.buffer(value);
+            } finally {
+                value.close();
+            }
+        }
     }
-  }
 
-  static final class ToStringConverter implements Converter<Object, String> {
-    static final ToStringConverter INSTANCE = new ToStringConverter();
+    static final class ToStringConverter implements Converter<Object, String> {
+        static final ToStringConverter INSTANCE = new ToStringConverter();
 
-    @Override public String convert(Object value) {
-      return value.toString();
+        @Override
+        public String convert(Object value) {
+            return value.toString();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Call.java b/retrofit/src/main/java/retrofit2/Call.java
index 171d9e0c4..b7e420e13 100644
--- a/retrofit/src/main/java/retrofit2/Call.java
+++ b/retrofit/src/main/java/retrofit2/Call.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.Request;
 
 /**
@@ -23,7 +24,7 @@
  * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
  * calls with the same parameters to the same webserver; this may be used to implement polling or
  * to retry a failed call.
- *
+ * <p>
  * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
  * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
  * is busy writing its request or reading its response may receive a {@link IOException}; this is
@@ -32,42 +33,42 @@
  * @param <T> Successful response body type.
  */
 public interface Call<T> extends Cloneable {
-  /**
-   * Synchronously send the request and return its response.
-   *
-   * @throws IOException if a problem occurred talking to the server.
-   * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
-   * or decoding the response.
-   */
-  Response<T> execute() throws IOException;
+    /**
+     * Synchronously send the request and return its response.
+     *
+     * @throws IOException      if a problem occurred talking to the server.
+     * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request
+     *                          or decoding the response.
+     */
+    Response<T> execute() throws IOException;
 
-  /**
-   * Asynchronously send the request and notify {@code callback} of its response or if an error
-   * occurred talking to the server, creating the request, or processing the response.
-   */
-  void enqueue(Callback<T> callback);
+    /**
+     * Asynchronously send the request and notify {@code callback} of its response or if an error
+     * occurred talking to the server, creating the request, or processing the response.
+     */
+    void enqueue(Callback<T> callback);
 
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
-   */
-  boolean isExecuted();
+    /**
+     * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+     * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+     */
+    boolean isExecuted();
 
-  /**
-   * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
-   * yet been executed it never will be.
-   */
-  void cancel();
+    /**
+     * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
+     * yet been executed it never will be.
+     */
+    void cancel();
 
-  /** True if {@link #cancel()} was called. */
-  boolean isCanceled();
+    /** True if {@link #cancel()} was called. */
+    boolean isCanceled();
 
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call<T> clone();
+    /**
+     * Create a new, identical call to this one which can be enqueued or executed even if this call
+     * has already been.
+     */
+    Call<T> clone();
 
-  /** The original HTTP request. */
-  Request request();
+    /** The original HTTP request. */
+    Request request();
 }
diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index 927540bf4..6e72b2d32 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -26,61 +26,61 @@
  * instance.
  */
 public interface CallAdapter<R, T> {
-  /**
-   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
-   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
-   * is used to prepare the {@code call} passed to {@code #adapt}.
-   * <p>
-   * Note: This is typically not the same type as the {@code returnType} provided to this call
-   * adapter's factory.
-   */
-  Type responseType();
-
-  /**
-   * Returns an instance of {@code T} which delegates to {@code call}.
-   * <p>
-   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
-   * return a new {@code Async<R>} which invoked {@code call} when run.
-   * <pre><code>
-   * &#64;Override
-   * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
-   *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
-   *     &#64;Override
-   *     public Response&lt;R&gt; call() throws Exception {
-   *       return call.execute();
-   *     }
-   *   });
-   * }
-   * </code></pre>
-   */
-  T adapt(Call<R> call);
-
-  /**
-   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
-   * Retrofit#create(Class) the service interface} methods.
-   */
-  abstract class Factory {
     /**
-     * Returns a call adapter for interface methods that return {@code returnType}, or null if it
-     * cannot be handled by this factory.
+     * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+     * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+     * is used to prepare the {@code call} passed to {@code #adapt}.
+     * <p>
+     * Note: This is typically not the same type as the {@code returnType} provided to this call
+     * adapter's factory.
      */
-    public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit);
+    Type responseType();
 
     /**
-     * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
-     * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+     * Returns an instance of {@code T} which delegates to {@code call}.
+     * <p>
+     * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+     * return a new {@code Async<R>} which invoked {@code call} when run.
+     * <pre><code>
+     * &#64;Override
+     * public &lt;R&gt; Async&lt;R&gt; adapt(final Call&lt;R&gt; call) {
+     *   return Async.create(new Callable&lt;Response&lt;R&gt;&gt;() {
+     *     &#64;Override
+     *     public Response&lt;R&gt; call() throws Exception {
+     *       return call.execute();
+     *     }
+     *   });
+     * }
+     * </code></pre>
      */
-    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
-      return Utils.getParameterUpperBound(index, type);
-    }
+    T adapt(Call<R> call);
 
     /**
-     * Extract the raw class type from {@code type}. For example, the type representing
-     * {@code List<? extends Runnable>} returns {@code List.class}.
+     * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+     * Retrofit#create(Class) the service interface} methods.
      */
-    protected static Class<?> getRawType(Type type) {
-      return Utils.getRawType(type);
+    abstract class Factory {
+        /**
+         * Returns a call adapter for interface methods that return {@code returnType}, or null if it
+         * cannot be handled by this factory.
+         */
+        public abstract CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+                Retrofit retrofit);
+
+        /**
+         * Extract the upper bound of the generic parameter at {@code index} from {@code type}. For
+         * example, index 1 of {@code Map<String, ? extends Runnable>} returns {@code Runnable}.
+         */
+        protected static Type getParameterUpperBound(int index, ParameterizedType type) {
+            return Utils.getParameterUpperBound(index, type);
+        }
+
+        /**
+         * Extract the raw class type from {@code type}. For example, the type representing
+         * {@code List<? extends Runnable>} returns {@code List.class}.
+         */
+        protected static Class<?> getRawType(Type type) {
+            return Utils.getRawType(type);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Callback.java b/retrofit/src/main/java/retrofit2/Callback.java
index 62c93a621..8e75d0441 100644
--- a/retrofit/src/main/java/retrofit2/Callback.java
+++ b/retrofit/src/main/java/retrofit2/Callback.java
@@ -29,17 +29,17 @@
  * @param <T> Successful response body type.
  */
 public interface Callback<T> {
-  /**
-   * Invoked for a received HTTP response.
-   * <p>
-   * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
-   * Call {@link Response#isSuccessful()} to determine if the response indicates success.
-   */
-  void onResponse(Call<T> call, Response<T> response);
+    /**
+     * Invoked for a received HTTP response.
+     * <p>
+     * Note: An HTTP response may still indicate an application-level failure such as a 404 or 500.
+     * Call {@link Response#isSuccessful()} to determine if the response indicates success.
+     */
+    void onResponse(Call<T> call, Response<T> response);
 
-  /**
-   * Invoked when a network exception occurred talking to the server or when an unexpected
-   * exception occurred creating the request or processing the response.
-   */
-  void onFailure(Call<T> call, Throwable t);
+    /**
+     * Invoked when a network exception occurred talking to the server or when an unexpected
+     * exception occurred creating the request or processing the response.
+     */
+    void onFailure(Call<T> call, Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 880eea9b8..9ea1a1836 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.http.Body;
@@ -37,42 +38,42 @@
  * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
-  T convert(F value) throws IOException;
+    T convert(F value) throws IOException;
 
-  /** Creates {@link Converter} instances based on a type and target usage. */
-  abstract class Factory {
-    /**
-     * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for
-     * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
-     * declaration.
-     */
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
-    }
+    /** Creates {@link Converter} instances based on a type and target usage. */
+    abstract class Factory {
+        /**
+         * Returns a {@link Converter} for converting an HTTP response body to {@code type}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for
+         * response types such as {@code SimpleResponse} from a {@code Call<SimpleResponse>}
+         * declaration.
+         */
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
-     * values.
-     */
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      return null;
-    }
+        /**
+         * Returns a {@link Converter} for converting {@code type} to an HTTP request body, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap}
+         * values.
+         */
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            return null;
+        }
 
-    /**
-     * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
-     * {@code type} cannot be handled by this factory. This is used to create converters for types
-     * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
-     * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
-     * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
-     */
-    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      return null;
+        /**
+         * Returns a {@link Converter} for converting {@code type} to a {@link String}, or null if
+         * {@code type} cannot be handled by this factory. This is used to create converters for types
+         * specified by {@link Field @Field}, {@link FieldMap @FieldMap} values,
+         * {@link Header @Header}, {@link HeaderMap @HeaderMap}, {@link Path @Path},
+         * {@link Query @Query}, and {@link QueryMap @QueryMap} values.
+         */
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                Retrofit retrofit) {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
index c0f114cf3..b3fc6eb97 100644
--- a/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/DefaultCallAdapterFactory.java
@@ -24,23 +24,25 @@
  * asynchronous calls this is a thread provided by OkHttp's dispatcher.
  */
 final class DefaultCallAdapterFactory extends CallAdapter.Factory {
-  static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
+    static final CallAdapter.Factory INSTANCE = new DefaultCallAdapterFactory();
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
+        }
 
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object, Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Object, Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-      @Override public Call<Object> adapt(Call<Object> call) {
-        return call;
-      }
-    };
-  }
+            @Override
+            public Call<Object> adapt(Call<Object> call) {
+                return call;
+            }
+        };
+    }
 }
diff --git a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
index a633d60e8..3ce0435c5 100644
--- a/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit2/ExecutorCallAdapterFactory.java
@@ -19,91 +19,106 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
 
 final class ExecutorCallAdapterFactory extends CallAdapter.Factory {
-  final Executor callbackExecutor;
-
-  ExecutorCallAdapterFactory(Executor callbackExecutor) {
-    this.callbackExecutor = callbackExecutor;
-  }
-
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (getRawType(returnType) != Call.class) {
-      return null;
-    }
-    final Type responseType = Utils.getCallResponseType(returnType);
-    return new CallAdapter<Object, Call<?>>() {
-      @Override public Type responseType() {
-        return responseType;
-      }
-
-      @Override public Call<Object> adapt(Call<Object> call) {
-        return new ExecutorCallbackCall<>(callbackExecutor, call);
-      }
-    };
-  }
-
-  static final class ExecutorCallbackCall<T> implements Call<T> {
     final Executor callbackExecutor;
-    final Call<T> delegate;
 
-    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
-      this.callbackExecutor = callbackExecutor;
-      this.delegate = delegate;
+    ExecutorCallAdapterFactory(Executor callbackExecutor) {
+        this.callbackExecutor = callbackExecutor;
     }
 
-    @Override public void enqueue(final Callback<T> callback) {
-      if (callback == null) throw new NullPointerException("callback == null");
-
-      delegate.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, final Response<T> response) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              if (delegate.isCanceled()) {
-                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
-                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
-              } else {
-                callback.onResponse(ExecutorCallbackCall.this, response);
-              }
-            }
-          });
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        if (getRawType(returnType) != Call.class) {
+            return null;
         }
+        final Type responseType = Utils.getCallResponseType(returnType);
+        return new CallAdapter<Object, Call<?>>() {
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
 
-        @Override public void onFailure(Call<T> call, final Throwable t) {
-          callbackExecutor.execute(new Runnable() {
-            @Override public void run() {
-              callback.onFailure(ExecutorCallbackCall.this, t);
+            @Override
+            public Call<Object> adapt(Call<Object> call) {
+                return new ExecutorCallbackCall<>(callbackExecutor, call);
             }
-          });
-        }
-      });
+        };
     }
 
-    @Override public boolean isExecuted() {
-      return delegate.isExecuted();
-    }
+    static final class ExecutorCallbackCall<T> implements Call<T> {
+        final Executor callbackExecutor;
+        final Call<T> delegate;
 
-    @Override public Response<T> execute() throws IOException {
-      return delegate.execute();
-    }
+        ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+            this.callbackExecutor = callbackExecutor;
+            this.delegate = delegate;
+        }
 
-    @Override public void cancel() {
-      delegate.cancel();
-    }
+        @Override
+        public void enqueue(final Callback<T> callback) {
+            if (callback == null) throw new NullPointerException("callback == null");
+
+            delegate.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, final Response<T> response) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (delegate.isCanceled()) {
+                                // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.
+                                callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled"));
+                            }
+                            else {
+                                callback.onResponse(ExecutorCallbackCall.this, response);
+                            }
+                        }
+                    });
+                }
+
+                @Override
+                public void onFailure(Call<T> call, final Throwable t) {
+                    callbackExecutor.execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onFailure(ExecutorCallbackCall.this, t);
+                        }
+                    });
+                }
+            });
+        }
 
-    @Override public boolean isCanceled() {
-      return delegate.isCanceled();
-    }
+        @Override
+        public boolean isExecuted() {
+            return delegate.isExecuted();
+        }
 
-    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
-    @Override public Call<T> clone() {
-      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
-    }
+        @Override
+        public Response<T> execute() throws IOException {
+            return delegate.execute();
+        }
+
+        @Override
+        public void cancel() {
+            delegate.cancel();
+        }
 
-    @Override public Request request() {
-      return delegate.request();
+        @Override
+        public boolean isCanceled() {
+            return delegate.isCanceled();
+        }
+
+        @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+        @Override
+        public Call<T> clone() {
+            return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+        }
+
+        @Override
+        public Request request() {
+            return delegate.request();
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/OkHttpCall.java b/retrofit/src/main/java/retrofit2/OkHttpCall.java
index ccbfe1ab2..6f84c4f13 100644
--- a/retrofit/src/main/java/retrofit2/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit2/OkHttpCall.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.MediaType;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
@@ -25,280 +26,298 @@
 import okio.Okio;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final ServiceMethod<T, ?> serviceMethod;
-  private final Object[] args;
-
-  private volatile boolean canceled;
-
-  // All guarded by this.
-  private okhttp3.Call rawCall;
-  private Throwable creationFailure; // Either a RuntimeException or IOException.
-  private boolean executed;
-
-  OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
-    this.serviceMethod = serviceMethod;
-    this.args = args;
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(serviceMethod, args);
-  }
-
-  @Override public synchronized Request request() {
-    okhttp3.Call call = rawCall;
-    if (call != null) {
-      return call.request();
-    }
-    if (creationFailure != null) {
-      if (creationFailure instanceof IOException) {
-        throw new RuntimeException("Unable to create request.", creationFailure);
-      } else {
-        throw (RuntimeException) creationFailure;
-      }
-    }
-    try {
-      return (rawCall = createRawCall()).request();
-    } catch (RuntimeException e) {
-      creationFailure = e;
-      throw e;
-    } catch (IOException e) {
-      creationFailure = e;
-      throw new RuntimeException("Unable to create request.", e);
-    }
-  }
+    private final ServiceMethod<T, ?> serviceMethod;
+    private final Object[] args;
 
-  @Override public void enqueue(final Callback<T> callback) {
-    if (callback == null) throw new NullPointerException("callback == null");
+    private volatile boolean canceled;
 
-    okhttp3.Call call;
-    Throwable failure;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      call = rawCall;
-      failure = creationFailure;
-      if (call == null && failure == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (Throwable t) {
-          failure = creationFailure = t;
-        }
-      }
-    }
+    // All guarded by this.
+    private okhttp3.Call rawCall;
+    private Throwable creationFailure; // Either a RuntimeException or IOException.
+    private boolean executed;
 
-    if (failure != null) {
-      callback.onFailure(this, failure);
-      return;
+    OkHttpCall(ServiceMethod<T, ?> serviceMethod, Object[] args) {
+        this.serviceMethod = serviceMethod;
+        this.args = args;
     }
 
-    if (canceled) {
-      call.cancel();
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    @Override
+    public OkHttpCall<T> clone() {
+        return new OkHttpCall<>(serviceMethod, args);
     }
 
-    call.enqueue(new okhttp3.Callback() {
-      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
-          throws IOException {
-        Response<T> response;
-        try {
-          response = parseResponse(rawResponse);
-        } catch (Throwable e) {
-          callFailure(e);
-          return;
+    @Override
+    public synchronized Request request() {
+        okhttp3.Call call = rawCall;
+        if (call != null) {
+            return call.request();
         }
-        callSuccess(response);
-      }
-
-      @Override public void onFailure(okhttp3.Call call, IOException e) {
-        try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+        if (creationFailure != null) {
+            if (creationFailure instanceof IOException) {
+                throw new RuntimeException("Unable to create request.", creationFailure);
+            }
+            else {
+                throw (RuntimeException) creationFailure;
+            }
         }
-      }
-
-      private void callFailure(Throwable e) {
         try {
-          callback.onFailure(OkHttpCall.this, e);
-        } catch (Throwable t) {
-          t.printStackTrace();
+            return (rawCall = createRawCall()).request();
+        } catch (RuntimeException e) {
+            creationFailure = e;
+            throw e;
+        } catch (IOException e) {
+            creationFailure = e;
+            throw new RuntimeException("Unable to create request.", e);
         }
-      }
+    }
 
-      private void callSuccess(Response<T> response) {
-        try {
-          callback.onResponse(OkHttpCall.this, response);
-        } catch (Throwable t) {
-          t.printStackTrace();
+    @Override
+    public void enqueue(final Callback<T> callback) {
+        if (callback == null) throw new NullPointerException("callback == null");
+
+        okhttp3.Call call;
+        Throwable failure;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            call = rawCall;
+            failure = creationFailure;
+            if (call == null && failure == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (Throwable t) {
+                    failure = creationFailure = t;
+                }
+            }
         }
-      }
-    });
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public Response<T> execute() throws IOException {
-    okhttp3.Call call;
-
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already executed.");
-      executed = true;
-
-      if (creationFailure != null) {
-        if (creationFailure instanceof IOException) {
-          throw (IOException) creationFailure;
-        } else {
-          throw (RuntimeException) creationFailure;
+
+        if (failure != null) {
+            callback.onFailure(this, failure);
+            return;
         }
-      }
 
-      call = rawCall;
-      if (call == null) {
-        try {
-          call = rawCall = createRawCall();
-        } catch (IOException | RuntimeException e) {
-          creationFailure = e;
-          throw e;
+        if (canceled) {
+            call.cancel();
         }
-      }
+
+        call.enqueue(new okhttp3.Callback() {
+            @Override
+            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
+                    throws IOException {
+                Response<T> response;
+                try {
+                    response = parseResponse(rawResponse);
+                } catch (Throwable e) {
+                    callFailure(e);
+                    return;
+                }
+                callSuccess(response);
+            }
+
+            @Override
+            public void onFailure(okhttp3.Call call, IOException e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callFailure(Throwable e) {
+                try {
+                    callback.onFailure(OkHttpCall.this, e);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+
+            private void callSuccess(Response<T> response) {
+                try {
+                    callback.onResponse(OkHttpCall.this, response);
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
+            }
+        });
     }
 
-    if (canceled) {
-      call.cancel();
+    @Override
+    public synchronized boolean isExecuted() {
+        return executed;
     }
 
-    return parseResponse(call.execute());
-  }
+    @Override
+    public Response<T> execute() throws IOException {
+        okhttp3.Call call;
+
+        synchronized (this) {
+            if (executed) throw new IllegalStateException("Already executed.");
+            executed = true;
+
+            if (creationFailure != null) {
+                if (creationFailure instanceof IOException) {
+                    throw (IOException) creationFailure;
+                }
+                else {
+                    throw (RuntimeException) creationFailure;
+                }
+            }
+
+            call = rawCall;
+            if (call == null) {
+                try {
+                    call = rawCall = createRawCall();
+                } catch (IOException | RuntimeException e) {
+                    creationFailure = e;
+                    throw e;
+                }
+            }
+        }
 
-  private okhttp3.Call createRawCall() throws IOException {
-    Request request = serviceMethod.toRequest(args);
-    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
-    if (call == null) {
-      throw new NullPointerException("Call.Factory returned null.");
-    }
-    return call;
-  }
-
-  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
-    ResponseBody rawBody = rawResponse.body();
-
-    // Remove the body's source (the only stateful object) so we can pass the response along.
-    rawResponse = rawResponse.newBuilder()
-        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
-        .build();
-
-    int code = rawResponse.code();
-    if (code < 200 || code >= 300) {
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.buffer(rawBody);
-        return Response.error(bufferedBody, rawResponse);
-      } finally {
-        rawBody.close();
-      }
-    }
+        if (canceled) {
+            call.cancel();
+        }
 
-    if (code == 204 || code == 205) {
-      rawBody.close();
-      return Response.success(null, rawResponse);
+        return parseResponse(call.execute());
     }
 
-    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
-    try {
-      T body = serviceMethod.toResponse(catchingBody);
-      return Response.success(body, rawResponse);
-    } catch (RuntimeException e) {
-      // If the underlying source threw an exception, propagate that rather than indicating it was
-      // a runtime exception.
-      catchingBody.throwIfCaught();
-      throw e;
+    private okhttp3.Call createRawCall() throws IOException {
+        Request request = serviceMethod.toRequest(args);
+        okhttp3.Call call = serviceMethod.callFactory.newCall(request);
+        if (call == null) {
+            throw new NullPointerException("Call.Factory returned null.");
+        }
+        return call;
     }
-  }
 
-  public void cancel() {
-    canceled = true;
+    Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
+        ResponseBody rawBody = rawResponse.body();
+
+        // Remove the body's source (the only stateful object) so we can pass the response along.
+        rawResponse = rawResponse.newBuilder()
+                                 .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+                                 .build();
+
+        int code = rawResponse.code();
+        if (code < 200 || code >= 300) {
+            try {
+                // Buffer the entire body to avoid future I/O.
+                ResponseBody bufferedBody = Utils.buffer(rawBody);
+                return Response.error(bufferedBody, rawResponse);
+            } finally {
+                rawBody.close();
+            }
+        }
 
-    okhttp3.Call call;
-    synchronized (this) {
-      call = rawCall;
-    }
-    if (call != null) {
-      call.cancel();
-    }
-  }
+        if (code == 204 || code == 205) {
+            rawBody.close();
+            return Response.success(null, rawResponse);
+        }
 
-  @Override public boolean isCanceled() {
-    if (canceled) {
-      return true;
-    }
-    synchronized (this) {
-      return rawCall != null && rawCall.isCanceled();
+        ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+        try {
+            T body = serviceMethod.toResponse(catchingBody);
+            return Response.success(body, rawResponse);
+        } catch (RuntimeException e) {
+            // If the underlying source threw an exception, propagate that rather than indicating it was
+            // a runtime exception.
+            catchingBody.throwIfCaught();
+            throw e;
+        }
     }
-  }
 
-  static final class NoContentResponseBody extends ResponseBody {
-    private final MediaType contentType;
-    private final long contentLength;
+    public void cancel() {
+        canceled = true;
 
-    NoContentResponseBody(MediaType contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
+        okhttp3.Call call;
+        synchronized (this) {
+            call = rawCall;
+        }
+        if (call != null) {
+            call.cancel();
+        }
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
+    @Override
+    public boolean isCanceled() {
+        if (canceled) {
+            return true;
+        }
+        synchronized (this) {
+            return rawCall != null && rawCall.isCanceled();
+        }
     }
 
-    @Override public long contentLength() {
-      return contentLength;
-    }
+    static final class NoContentResponseBody extends ResponseBody {
+        private final MediaType contentType;
+        private final long contentLength;
 
-    @Override public BufferedSource source() {
-      throw new IllegalStateException("Cannot read raw response body of a converted body.");
-    }
-  }
+        NoContentResponseBody(MediaType contentType, long contentLength) {
+            this.contentType = contentType;
+            this.contentLength = contentLength;
+        }
 
-  static final class ExceptionCatchingRequestBody extends ResponseBody {
-    private final ResponseBody delegate;
-    IOException thrownException;
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
 
-    ExceptionCatchingRequestBody(ResponseBody delegate) {
-      this.delegate = delegate;
-    }
+        @Override
+        public long contentLength() {
+            return contentLength;
+        }
 
-    @Override public MediaType contentType() {
-      return delegate.contentType();
+        @Override
+        public BufferedSource source() {
+            throw new IllegalStateException("Cannot read raw response body of a converted body.");
+        }
     }
 
-    @Override public long contentLength() {
-      return delegate.contentLength();
-    }
+    static final class ExceptionCatchingRequestBody extends ResponseBody {
+        private final ResponseBody delegate;
+        IOException thrownException;
 
-    @Override public BufferedSource source() {
-      return Okio.buffer(new ForwardingSource(delegate.source()) {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          try {
-            return super.read(sink, byteCount);
-          } catch (IOException e) {
-            thrownException = e;
-            throw e;
-          }
+        ExceptionCatchingRequestBody(ResponseBody delegate) {
+            this.delegate = delegate;
         }
-      });
-    }
 
-    @Override public void close() {
-      delegate.close();
-    }
+        @Override
+        public MediaType contentType() {
+            return delegate.contentType();
+        }
 
-    void throwIfCaught() throws IOException {
-      if (thrownException != null) {
-        throw thrownException;
-      }
+        @Override
+        public long contentLength() {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public BufferedSource source() {
+            return Okio.buffer(new ForwardingSource(delegate.source()) {
+                @Override
+                public long read(Buffer sink, long byteCount) throws IOException {
+                    try {
+                        return super.read(sink, byteCount);
+                    } catch (IOException e) {
+                        thrownException = e;
+                        throw e;
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void close() {
+            delegate.close();
+        }
+
+        void throwIfCaught() throws IOException {
+            if (thrownException != null) {
+                throw thrownException;
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad50..7044a7d9b 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.util.Map;
+
 import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
@@ -25,280 +26,294 @@
 import static retrofit2.Utils.checkNotNull;
 
 abstract class ParameterHandler<T> {
-  abstract void apply(RequestBuilder builder, T value) throws IOException;
-
-  final ParameterHandler<Iterable<T>> iterable() {
-    return new ParameterHandler<Iterable<T>>() {
-      @Override void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (T value : values) {
-          ParameterHandler.this.apply(builder, value);
-        }
-      }
-    };
-  }
-
-  final ParameterHandler<Object> array() {
-    return new ParameterHandler<Object>() {
-      @Override void apply(RequestBuilder builder, Object values) throws IOException {
-        if (values == null) return; // Skip null values.
-
-        for (int i = 0, size = Array.getLength(values); i < size; i++) {
-          //noinspection unchecked
-          ParameterHandler.this.apply(builder, (T) Array.get(values, i));
-        }
-      }
-    };
-  }
-
-  static final class RelativeUrl extends ParameterHandler<Object> {
-    @Override void apply(RequestBuilder builder, Object value) {
-      builder.setRelativeUrl(value);
+    abstract void apply(RequestBuilder builder, T value) throws IOException;
+
+    final ParameterHandler<Iterable<T>> iterable() {
+        return new ParameterHandler<Iterable<T>>() {
+            @Override
+            void apply(RequestBuilder builder, Iterable<T> values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (T value : values) {
+                    ParameterHandler.this.apply(builder, value);
+                }
+            }
+        };
     }
-  }
 
-  static final class Header<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-
-    Header(String name, Converter<T, String> valueConverter) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addHeader(name, valueConverter.convert(value));
+    final ParameterHandler<Object> array() {
+        return new ParameterHandler<Object>() {
+            @Override
+            void apply(RequestBuilder builder, Object values) throws IOException {
+                if (values == null) return; // Skip null values.
+
+                for (int i = 0, size = Array.getLength(values); i < size; i++) {
+                    //noinspection unchecked
+                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));
+                }
+            }
+        };
     }
-  }
 
-  static final class Path<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+    static final class RelativeUrl extends ParameterHandler<Object> {
+        @Override
+        void apply(RequestBuilder builder, Object value) {
+            builder.setRelativeUrl(value);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Header<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
 
-  static final class Query<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Header(String name, Converter<T, String> valueConverter) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+        }
 
-    Query(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addHeader(name, valueConverter.convert(value));
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class Path<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-  static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        Path(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException(
+                        "Path parameter \"" + name + "\" value must not be null.");
+            }
+            builder.addPathParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Query map was null.");
-      }
+    static final class Query<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Query map contained null value for key '" + entryKey + "'.");
+        Query(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
-      }
-    }
-  }
-
-  static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
 
-    HeaderMap(Converter<T, String> valueConverter) {
-      this.valueConverter = valueConverter;
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addQueryParam(name, valueConverter.convert(value), encoded);
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Header map was null.");
-      }
+    static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String headerName = entry.getKey();
-        if (headerName == null) {
-          throw new IllegalArgumentException("Header map contained null key.");
+        QueryMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T headerValue = entry.getValue();
-        if (headerValue == null) {
-          throw new IllegalArgumentException(
-              "Header map contained null value for key '" + headerName + "'.");
-        }
-        builder.addHeader(headerName, valueConverter.convert(headerValue));
-      }
-    }
-  }
 
-  static final class Field<T> extends ParameterHandler<T> {
-    private final String name;
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
-
-    Field(String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Query map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Query map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Query map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addQueryParam(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addFormField(name, valueConverter.convert(value), encoded);
-    }
-  }
+    static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
 
-  static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, String> valueConverter;
-    private final boolean encoded;
+        HeaderMap(Converter<T, String> valueConverter) {
+            this.valueConverter = valueConverter;
+        }
 
-    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
-      this.valueConverter = valueConverter;
-      this.encoded = encoded;
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Header map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String headerName = entry.getKey();
+                if (headerName == null) {
+                    throw new IllegalArgumentException("Header map contained null key.");
+                }
+                T headerValue = entry.getValue();
+                if (headerValue == null) {
+                    throw new IllegalArgumentException(
+                            "Header map contained null value for key '" + headerName + "'.");
+                }
+                builder.addHeader(headerName, valueConverter.convert(headerValue));
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Field map was null.");
-      }
+    static final class Field<T> extends ParameterHandler<T> {
+        private final String name;
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
+        Field(String name, Converter<T, String> valueConverter, boolean encoded) {
+            this.name = checkNotNull(name, "name == null");
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
         }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Field map contained null value for key '" + entryKey + "'.");
+
+        @Override
+        void apply(RequestBuilder builder, T value) throws IOException {
+            if (value == null) return; // Skip null values.
+            builder.addFormField(name, valueConverter.convert(value), encoded);
         }
-        builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
-      }
     }
-  }
 
-  static final class Part<T> extends ParameterHandler<T> {
-    private final Headers headers;
-    private final Converter<T, RequestBody> converter;
+    static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, String> valueConverter;
+        private final boolean encoded;
 
-    Part(Headers headers, Converter<T, RequestBody> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) return; // Skip null values.
+        FieldMap(Converter<T, String> valueConverter, boolean encoded) {
+            this.valueConverter = valueConverter;
+            this.encoded = encoded;
+        }
 
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.addPart(headers, body);
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Field map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Field map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Field map contained null value for key '" + entryKey + "'.");
+                }
+                builder.addFormField(entryKey, valueConverter.convert(entryValue), encoded);
+            }
+        }
     }
-  }
 
-  static final class RawPart extends ParameterHandler<MultipartBody.Part> {
-    static final RawPart INSTANCE = new RawPart();
+    static final class Part<T> extends ParameterHandler<T> {
+        private final Headers headers;
+        private final Converter<T, RequestBody> converter;
 
-    private RawPart() {
-    }
+        Part(Headers headers, Converter<T, RequestBody> converter) {
+            this.headers = headers;
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
-      if (value != null) { // Skip null values.
-        builder.addPart(value);
-      }
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) return; // Skip null values.
+
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.addPart(headers, body);
+        }
     }
-  }
 
-  static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Converter<T, RequestBody> valueConverter;
-    private final String transferEncoding;
+    static final class RawPart extends ParameterHandler<MultipartBody.Part> {
+        static final RawPart INSTANCE = new RawPart();
+
+        private RawPart() {
+        }
 
-    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.valueConverter = valueConverter;
-      this.transferEncoding = transferEncoding;
+        @Override
+        void apply(RequestBuilder builder, MultipartBody.Part value) throws IOException {
+            if (value != null) { // Skip null values.
+                builder.addPart(value);
+            }
+        }
     }
 
-    @Override void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
-      if (value == null) {
-        throw new IllegalArgumentException("Part map was null.");
-      }
+    static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
+        private final Converter<T, RequestBody> valueConverter;
+        private final String transferEncoding;
 
-      for (Map.Entry<String, T> entry : value.entrySet()) {
-        String entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        T entryValue = entry.getValue();
-        if (entryValue == null) {
-          throw new IllegalArgumentException(
-              "Part map contained null value for key '" + entryKey + "'.");
+        PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
+            this.valueConverter = valueConverter;
+            this.transferEncoding = transferEncoding;
         }
 
-        Headers headers = Headers.of(
-            "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-
-        builder.addPart(headers, valueConverter.convert(entryValue));
-      }
+        @Override
+        void apply(RequestBuilder builder, Map<String, T> value) throws IOException {
+            if (value == null) {
+                throw new IllegalArgumentException("Part map was null.");
+            }
+
+            for (Map.Entry<String, T> entry : value.entrySet()) {
+                String entryKey = entry.getKey();
+                if (entryKey == null) {
+                    throw new IllegalArgumentException("Part map contained null key.");
+                }
+                T entryValue = entry.getValue();
+                if (entryValue == null) {
+                    throw new IllegalArgumentException(
+                            "Part map contained null value for key '" + entryKey + "'.");
+                }
+
+                Headers headers = Headers.of(
+                        "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
+                        "Content-Transfer-Encoding", transferEncoding);
+
+                builder.addPart(headers, valueConverter.convert(entryValue));
+            }
+        }
     }
-  }
 
-  static final class Body<T> extends ParameterHandler<T> {
-    private final Converter<T, RequestBody> converter;
+    static final class Body<T> extends ParameterHandler<T> {
+        private final Converter<T, RequestBody> converter;
 
-    Body(Converter<T, RequestBody> converter) {
-      this.converter = converter;
-    }
+        Body(Converter<T, RequestBody> converter) {
+            this.converter = converter;
+        }
 
-    @Override void apply(RequestBuilder builder, T value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      RequestBody body;
-      try {
-        body = converter.convert(value);
-      } catch (IOException e) {
-        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
-      }
-      builder.setBody(body);
+        @Override
+        void apply(RequestBuilder builder, T value) {
+            if (value == null) {
+                throw new IllegalArgumentException("Body parameter value must not be null.");
+            }
+            RequestBody body;
+            try {
+                body = converter.convert(value);
+            } catch (IOException e) {
+                throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
+            }
+            builder.setBody(body);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Platform.java b/retrofit/src/main/java/retrofit2/Platform.java
index ad9cf533c..1a2c2ce9f 100644
--- a/retrofit/src/main/java/retrofit2/Platform.java
+++ b/retrofit/src/main/java/retrofit2/Platform.java
@@ -18,89 +18,96 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
+
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  static Platform get() {
-    return PLATFORM;
-  }
-
-  private static Platform findPlatform() {
-    try {
-      Class.forName("android.os.Build");
-      if (Build.VERSION.SDK_INT != 0) {
-        return new Android();
-      }
-    } catch (ClassNotFoundException ignored) {
-    }
-    try {
-      Class.forName("java.util.Optional");
-      return new Java8();
-    } catch (ClassNotFoundException ignored) {
+    private static final Platform PLATFORM = findPlatform();
+
+    static Platform get() {
+        return PLATFORM;
     }
-    return new Platform();
-  }
 
-  Executor defaultCallbackExecutor() {
-    return null;
-  }
+    private static Platform findPlatform() {
+        try {
+            Class.forName("android.os.Build");
+            if (Build.VERSION.SDK_INT != 0) {
+                return new Android();
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+        try {
+            Class.forName("java.util.Optional");
+            return new Java8();
+        } catch (ClassNotFoundException ignored) {
+        }
+        return new Platform();
+    }
 
-  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-    if (callbackExecutor != null) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    Executor defaultCallbackExecutor() {
+        return null;
     }
-    return DefaultCallAdapterFactory.INSTANCE;
-  }
-
-  boolean isDefaultMethod(Method method) {
-    return false;
-  }
-
-  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
-      throws Throwable {
-    throw new UnsupportedOperationException();
-  }
-
-  @IgnoreJRERequirement // Only classloaded and used on Java 8.
-  static class Java8 extends Platform {
-    @Override boolean isDefaultMethod(Method method) {
-      return method.isDefault();
+
+    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+        if (callbackExecutor != null) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+        return DefaultCallAdapterFactory.INSTANCE;
     }
 
-    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
-        Object... args) throws Throwable {
-      // Because the service interface might not be public, we need to use a MethodHandle lookup
-      // that ignores the visibility of the declaringClass.
-      Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
-      constructor.setAccessible(true);
-      return constructor.newInstance(declaringClass, -1 /* trusted */)
-          .unreflectSpecial(method, declaringClass)
-          .bindTo(object)
-          .invokeWithArguments(args);
+    boolean isDefaultMethod(Method method) {
+        return false;
     }
-  }
 
-  static class Android extends Platform {
-    @Override public Executor defaultCallbackExecutor() {
-      return new MainThreadExecutor();
+    Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+            throws Throwable {
+        throw new UnsupportedOperationException();
     }
 
-    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
-      return new ExecutorCallAdapterFactory(callbackExecutor);
+    @IgnoreJRERequirement // Only classloaded and used on Java 8.
+    static class Java8 extends Platform {
+        @Override
+        boolean isDefaultMethod(Method method) {
+            return method.isDefault();
+        }
+
+        @Override
+        Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+                Object... args) throws Throwable {
+            // Because the service interface might not be public, we need to use a MethodHandle lookup
+            // that ignores the visibility of the declaringClass.
+            Constructor<Lookup> constructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);
+            constructor.setAccessible(true);
+            return constructor.newInstance(declaringClass, -1 /* trusted */)
+                              .unreflectSpecial(method, declaringClass)
+                              .bindTo(object)
+                              .invokeWithArguments(args);
+        }
     }
 
-    static class MainThreadExecutor implements Executor {
-      private final Handler handler = new Handler(Looper.getMainLooper());
+    static class Android extends Platform {
+        @Override
+        public Executor defaultCallbackExecutor() {
+            return new MainThreadExecutor();
+        }
+
+        @Override
+        CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+            return new ExecutorCallAdapterFactory(callbackExecutor);
+        }
+
+        static class MainThreadExecutor implements Executor {
+            private final Handler handler = new Handler(Looper.getMainLooper());
 
-      @Override public void execute(Runnable r) {
-        handler.post(r);
-      }
+            @Override
+            public void execute(Runnable r) {
+                handler.post(r);
+            }
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 3a25b6f53..cc277a69c 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -16,6 +16,7 @@
 package retrofit2;
 
 import java.io.IOException;
+
 import okhttp3.FormBody;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
@@ -27,220 +28,233 @@
 import okio.BufferedSink;
 
 final class RequestBuilder {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
-
-  private final String method;
-
-  private final HttpUrl baseUrl;
-  private String relativeUrl;
-  private HttpUrl.Builder urlBuilder;
-
-  private final Request.Builder requestBuilder;
-  private MediaType contentType;
-
-  private final boolean hasBody;
-  private MultipartBody.Builder multipartBuilder;
-  private FormBody.Builder formBuilder;
-  private RequestBody body;
-
-  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
-      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
-    this.baseUrl = baseUrl;
-    this.relativeUrl = relativeUrl;
-    this.requestBuilder = new Request.Builder();
-    this.contentType = contentType;
-    this.hasBody = hasBody;
-
-    if (headers != null) {
-      requestBuilder.headers(headers);
-    }
+    private static final char[] HEX_DIGITS =
+            {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+    private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+
+    private final String method;
+
+    private final HttpUrl baseUrl;
+    private String relativeUrl;
+    private HttpUrl.Builder urlBuilder;
+
+    private final Request.Builder requestBuilder;
+    private MediaType contentType;
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formBuilder = new FormBody.Builder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBody.Builder();
-      multipartBuilder.setType(MultipartBody.FORM);
+    private final boolean hasBody;
+    private MultipartBody.Builder multipartBuilder;
+    private FormBody.Builder formBuilder;
+    private RequestBody body;
+
+    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+            MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+        this.method = method;
+        this.baseUrl = baseUrl;
+        this.relativeUrl = relativeUrl;
+        this.requestBuilder = new Request.Builder();
+        this.contentType = contentType;
+        this.hasBody = hasBody;
+
+        if (headers != null) {
+            requestBuilder.headers(headers);
+        }
+
+        if (isFormEncoded) {
+            // Will be set to 'body' in 'build'.
+            formBuilder = new FormBody.Builder();
+        }
+        else if (isMultipart) {
+            // Will be set to 'body' in 'build'.
+            multipartBuilder = new MultipartBody.Builder();
+            multipartBuilder.setType(MultipartBody.FORM);
+        }
     }
-  }
-
-  void setRelativeUrl(Object relativeUrl) {
-    if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
-    this.relativeUrl = relativeUrl.toString();
-  }
-
-  void addHeader(String name, String value) {
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      MediaType type = MediaType.parse(value);
-      if (type == null) {
-        throw new IllegalArgumentException("Malformed content type: " + value);
-      }
-      contentType = type;
-    } else {
-      requestBuilder.addHeader(name, value);
+
+    void setRelativeUrl(Object relativeUrl) {
+        if (relativeUrl == null) throw new NullPointerException("@Url parameter is null.");
+        this.relativeUrl = relativeUrl.toString();
     }
-  }
 
-  void addPathParam(String name, String value, boolean encoded) {
-    if (relativeUrl == null) {
-      // The relative URL is cleared when the first query parameter is set.
-      throw new AssertionError();
+    void addHeader(String name, String value) {
+        if ("Content-Type".equalsIgnoreCase(name)) {
+            MediaType type = MediaType.parse(value);
+            if (type == null) {
+                throw new IllegalArgumentException("Malformed content type: " + value);
+            }
+            contentType = type;
+        }
+        else {
+            requestBuilder.addHeader(name, value);
+        }
     }
-    relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
-  }
-
-  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
-    int codePoint;
-    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, 0, i);
-        canonicalizeForPath(out, input, i, limit, alreadyEncoded);
-        return out.readUtf8();
-      }
+
+    void addPathParam(String name, String value, boolean encoded) {
+        if (relativeUrl == null) {
+            // The relative URL is cleared when the first query parameter is set.
+            throw new AssertionError();
+        }
+        relativeUrl = relativeUrl.replace("{" + name + "}", canonicalizeForPath(value, encoded));
     }
 
-    // Fast path: no characters required encoding.
-    return input;
-  }
-
-  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
-      boolean alreadyEncoded) {
-    Buffer utf8Buffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint < 0x20 || codePoint >= 0x7f
-          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
-          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
-        // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
-        }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
-        }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                Buffer out = new Buffer();
+                out.writeUtf8(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.readUtf8();
+            }
+        }
+
+        // Fast path: no characters required encoding.
+        return input;
     }
-  }
-
-  void addQueryParam(String name, String value, boolean encoded) {
-    if (relativeUrl != null) {
-      // Do a one-time combination of the built relative URL and the base URL.
-      urlBuilder = baseUrl.newBuilder(relativeUrl);
-      if (urlBuilder == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
-      relativeUrl = null;
+
+    private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,
+            boolean alreadyEncoded) {
+        Buffer utf8Buffer = null; // Lazily allocated.
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                    && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            }
+            else if (codePoint < 0x20 || codePoint >= 0x7f
+                    || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                    || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                if (utf8Buffer == null) {
+                    utf8Buffer = new Buffer();
+                }
+                utf8Buffer.writeUtf8CodePoint(codePoint);
+                while (!utf8Buffer.exhausted()) {
+                    int b = utf8Buffer.readByte() & 0xff;
+                    out.writeByte('%');
+                    out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.writeByte(HEX_DIGITS[b & 0xf]);
+                }
+            }
+            else {
+                // This character doesn't need encoding. Just copy it over.
+                out.writeUtf8CodePoint(codePoint);
+            }
+        }
     }
 
-    if (encoded) {
-      urlBuilder.addEncodedQueryParameter(name, value);
-    } else {
-      urlBuilder.addQueryParameter(name, value);
+    void addQueryParam(String name, String value, boolean encoded) {
+        if (relativeUrl != null) {
+            // Do a one-time combination of the built relative URL and the base URL.
+            urlBuilder = baseUrl.newBuilder(relativeUrl);
+            if (urlBuilder == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+            relativeUrl = null;
+        }
+
+        if (encoded) {
+            urlBuilder.addEncodedQueryParameter(name, value);
+        }
+        else {
+            urlBuilder.addQueryParameter(name, value);
+        }
     }
-  }
 
-  void addFormField(String name, String value, boolean encoded) {
-    if (encoded) {
-      formBuilder.addEncoded(name, value);
-    } else {
-      formBuilder.add(name, value);
+    void addFormField(String name, String value, boolean encoded) {
+        if (encoded) {
+            formBuilder.addEncoded(name, value);
+        }
+        else {
+            formBuilder.add(name, value);
+        }
     }
-  }
-
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
-
-  void addPart(MultipartBody.Part part) {
-    multipartBuilder.addPart(part);
-  }
-
-  void setBody(RequestBody body) {
-    this.body = body;
-  }
-
-  Request build() {
-    HttpUrl url;
-    HttpUrl.Builder urlBuilder = this.urlBuilder;
-    if (urlBuilder != null) {
-      url = urlBuilder.build();
-    } else {
-      // No query parameters triggered builder creation, just combine the relative URL and base URL.
-      url = baseUrl.resolve(relativeUrl);
-      if (url == null) {
-        throw new IllegalArgumentException(
-            "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
-      }
+
+    void addPart(Headers headers, RequestBody body) {
+        multipartBuilder.addPart(headers, body);
     }
 
-    RequestBody body = this.body;
-    if (body == null) {
-      // Try to pull from one of the builders.
-      if (formBuilder != null) {
-        body = formBuilder.build();
-      } else if (multipartBuilder != null) {
-        body = multipartBuilder.build();
-      } else if (hasBody) {
-        // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
-      }
+    void addPart(MultipartBody.Part part) {
+        multipartBuilder.addPart(part);
     }
 
-    MediaType contentType = this.contentType;
-    if (contentType != null) {
-      if (body != null) {
-        body = new ContentTypeOverridingRequestBody(body, contentType);
-      } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
-      }
+    void setBody(RequestBody body) {
+        this.body = body;
     }
 
-    return requestBuilder
-        .url(url)
-        .method(method, body)
-        .build();
-  }
+    Request build() {
+        HttpUrl url;
+        HttpUrl.Builder urlBuilder = this.urlBuilder;
+        if (urlBuilder != null) {
+            url = urlBuilder.build();
+        }
+        else {
+            // No query parameters triggered builder creation, just combine the relative URL and base URL.
+            url = baseUrl.resolve(relativeUrl);
+            if (url == null) {
+                throw new IllegalArgumentException(
+                        "Malformed URL. Base: " + baseUrl + ", Relative: " + relativeUrl);
+            }
+        }
+
+        RequestBody body = this.body;
+        if (body == null) {
+            // Try to pull from one of the builders.
+            if (formBuilder != null) {
+                body = formBuilder.build();
+            }
+            else if (multipartBuilder != null) {
+                body = multipartBuilder.build();
+            }
+            else if (hasBody) {
+                // Body is absent, make an empty body.
+                body = RequestBody.create(null, new byte[0]);
+            }
+        }
 
-  private static class ContentTypeOverridingRequestBody extends RequestBody {
-    private final RequestBody delegate;
-    private final MediaType contentType;
+        MediaType contentType = this.contentType;
+        if (contentType != null) {
+            if (body != null) {
+                body = new ContentTypeOverridingRequestBody(body, contentType);
+            }
+            else {
+                requestBuilder.addHeader("Content-Type", contentType.toString());
+            }
+        }
 
-    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
-      this.delegate = delegate;
-      this.contentType = contentType;
+        return requestBuilder
+                .url(url)
+                .method(method, body)
+                .build();
     }
 
-    @Override public MediaType contentType() {
-      return contentType;
-    }
+    private static class ContentTypeOverridingRequestBody extends RequestBody {
+        private final RequestBody delegate;
+        private final MediaType contentType;
 
-    @Override public long contentLength() throws IOException {
-      return delegate.contentLength();
-    }
+        ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
+            this.delegate = delegate;
+            this.contentType = contentType;
+        }
 
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      delegate.writeTo(sink);
+        @Override
+        public MediaType contentType() {
+            return contentType;
+        }
+
+        @Override
+        public long contentLength() throws IOException {
+            return delegate.contentLength();
+        }
+
+        @Override
+        public void writeTo(BufferedSink sink) throws IOException {
+            delegate.writeTo(sink);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Response.java b/retrofit/src/main/java/retrofit2/Response.java
index a0efab014..cc38366ea 100644
--- a/retrofit/src/main/java/retrofit2/Response.java
+++ b/retrofit/src/main/java/retrofit2/Response.java
@@ -22,112 +22,116 @@
 
 /** An HTTP response. */
 public final class Response<T> {
-  /** Create a synthetic successful response with {@code body} as the deserialized body. */
-  public static <T> Response<T> success(T body) {
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
-
-  /**
-   * Create a synthetic successful response using {@code headers} with {@code body} as the
-   * deserialized body.
-   */
-  public static <T> Response<T> success(T body, Headers headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-    return success(body, new okhttp3.Response.Builder() //
-        .code(200)
-        .message("OK")
-        .protocol(Protocol.HTTP_1_1)
-        .headers(headers)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
-
-  /**
-   * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
-   * body.
-   */
-  public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (!rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse must be successful response");
+    /** Create a synthetic successful response with {@code body} as the deserialized body. */
+    public static <T> Response<T> success(T body) {
+        return success(body, new okhttp3.Response.Builder() //
+                                                            .code(200)
+                                                            .message("OK")
+                                                            .protocol(Protocol.HTTP_1_1)
+                                                            .request(new Request.Builder().url("http://localhost/")
+                                                                                          .build())
+                                                            .build());
     }
-    return new Response<>(rawResponse, body, null);
-  }
-
-  /**
-   * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
-   * as the error body.
-   */
-  public static <T> Response<T> error(int code, ResponseBody body) {
-    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
-    return error(body, new okhttp3.Response.Builder() //
-        .code(code)
-        .protocol(Protocol.HTTP_1_1)
-        .request(new Request.Builder().url("http://localhost/").build())
-        .build());
-  }
-
-  /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
-  public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
-    if (body == null) throw new NullPointerException("body == null");
-    if (rawResponse == null) throw new NullPointerException("rawResponse == null");
-    if (rawResponse.isSuccessful()) {
-      throw new IllegalArgumentException("rawResponse should not be successful response");
+
+    /**
+     * Create a synthetic successful response using {@code headers} with {@code body} as the
+     * deserialized body.
+     */
+    public static <T> Response<T> success(T body, Headers headers) {
+        if (headers == null) throw new NullPointerException("headers == null");
+        return success(body, new okhttp3.Response.Builder() //
+                                                            .code(200)
+                                                            .message("OK")
+                                                            .protocol(Protocol.HTTP_1_1)
+                                                            .headers(headers)
+                                                            .request(new Request.Builder().url("http://localhost/")
+                                                                                          .build())
+                                                            .build());
+    }
+
+    /**
+     * Create a successful response from {@code rawResponse} with {@code body} as the deserialized
+     * body.
+     */
+    public static <T> Response<T> success(T body, okhttp3.Response rawResponse) {
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (!rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse must be successful response");
+        }
+        return new Response<>(rawResponse, body, null);
+    }
+
+    /**
+     * Create a synthetic error response with an HTTP status code of {@code code} and {@code body}
+     * as the error body.
+     */
+    public static <T> Response<T> error(int code, ResponseBody body) {
+        if (code < 400) throw new IllegalArgumentException("code < 400: " + code);
+        return error(body, new okhttp3.Response.Builder() //
+                                                          .code(code)
+                                                          .protocol(Protocol.HTTP_1_1)
+                                                          .request(new Request.Builder().url("http://localhost/")
+                                                                                        .build())
+                                                          .build());
+    }
+
+    /** Create an error response from {@code rawResponse} with {@code body} as the error body. */
+    public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {
+        if (body == null) throw new NullPointerException("body == null");
+        if (rawResponse == null) throw new NullPointerException("rawResponse == null");
+        if (rawResponse.isSuccessful()) {
+            throw new IllegalArgumentException("rawResponse should not be successful response");
+        }
+        return new Response<>(rawResponse, null, body);
+    }
+
+    private final okhttp3.Response rawResponse;
+    private final T body;
+    private final ResponseBody errorBody;
+
+    private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
+        this.rawResponse = rawResponse;
+        this.body = body;
+        this.errorBody = errorBody;
+    }
+
+    /** The raw response from the HTTP client. */
+    public okhttp3.Response raw() {
+        return rawResponse;
+    }
+
+    /** HTTP status code. */
+    public int code() {
+        return rawResponse.code();
+    }
+
+    /** HTTP status message or null if unknown. */
+    public String message() {
+        return rawResponse.message();
+    }
+
+    /** HTTP headers. */
+    public Headers headers() {
+        return rawResponse.headers();
+    }
+
+    /** Returns true if {@link #code()} is in the range [200..300). */
+    public boolean isSuccessful() {
+        return rawResponse.isSuccessful();
+    }
+
+    /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
+    public T body() {
+        return body;
+    }
+
+    /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
+    public ResponseBody errorBody() {
+        return errorBody;
+    }
+
+    @Override
+    public String toString() {
+        return rawResponse.toString();
     }
-    return new Response<>(rawResponse, null, body);
-  }
-
-  private final okhttp3.Response rawResponse;
-  private final T body;
-  private final ResponseBody errorBody;
-
-  private Response(okhttp3.Response rawResponse, T body, ResponseBody errorBody) {
-    this.rawResponse = rawResponse;
-    this.body = body;
-    this.errorBody = errorBody;
-  }
-
-  /** The raw response from the HTTP client. */
-  public okhttp3.Response raw() {
-    return rawResponse;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return rawResponse.code();
-  }
-
-  /** HTTP status message or null if unknown. */
-  public String message() {
-    return rawResponse.message();
-  }
-
-  /** HTTP headers. */
-  public Headers headers() {
-    return rawResponse.headers();
-  }
-
-  /** Returns true if {@link #code()} is in the range [200..300). */
-  public boolean isSuccessful() {
-    return rawResponse.isSuccessful();
-  }
-
-  /** The deserialized response body of a {@linkplain #isSuccessful() successful} response. */
-  public T body() {
-    return body;
-  }
-
-  /** The raw response body of an {@linkplain #isSuccessful() unsuccessful} response. */
-  public ResponseBody errorBody() {
-    return errorBody;
-  }
-
-  @Override public String toString() {
-    return rawResponse.toString();
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 8633de4af..9732a0489 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -25,6 +25,7 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -57,529 +58,530 @@
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
-
-  final okhttp3.Call.Factory callFactory;
-  final HttpUrl baseUrl;
-  final List<Converter.Factory> converterFactories;
-  final List<CallAdapter.Factory> adapterFactories;
-  final Executor callbackExecutor;
-  final boolean validateEagerly;
-
-  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
-      List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
-      Executor callbackExecutor, boolean validateEagerly) {
-    this.callFactory = callFactory;
-    this.baseUrl = baseUrl;
-    this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
-    this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
-    this.callbackExecutor = callbackExecutor;
-    this.validateEagerly = validateEagerly;
-  }
-
-  /**
-   * Create an implementation of the API endpoints defined by the {@code service} interface.
-   * <p>
-   * The relative path for a given method is obtained from an annotation on the method describing
-   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
-   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
-   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
-   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
-   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
-   * parameter with {@link Url @Url}.
-   * <p>
-   * Method parameters can be used to replace parts of the URL by annotating them with
-   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
-   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
-   * {@link retrofit2.http.Query @Query}.
-   * <p>
-   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
-   * object will be converted to request representation by one of the {@link Converter.Factory}
-   * instances. A {@link RequestBody} can also be used for a raw representation.
-   * <p>
-   * Alternative request body formats are supported by method annotations and corresponding
-   * parameter annotations:
-   * <ul>
-   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
-   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
-   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
-   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
-   * </ul>
-   * <p>
-   * Additional static headers can be added for an endpoint using the
-   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
-   * header annotate a parameter with {@link Header @Header}.
-   * <p>
-   * By default, methods return a {@link Call} which represents the HTTP request. The generic
-   * parameter of the call is the response body type and will be converted by one of the
-   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
-   * representation. {@link Void} can be used if you do not care about the body contents.
-   * <p>
-   * For example:
-   * <pre>
-   * public interface CategoryService {
-   *   &#64;POST("category/{cat}/")
-   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
-   * }
-   * </pre>
-   */
-  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
-  public <T> T create(final Class<T> service) {
-    Utils.validateServiceInterface(service);
-    if (validateEagerly) {
-      eagerlyValidateMethods(service);
-    }
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new InvocationHandler() {
-          private final Platform platform = Platform.get();
-
-          @Override public Object invoke(Object proxy, Method method, Object... args)
-              throws Throwable {
-            // If the method is a method from Object then defer to normal invocation.
-            if (method.getDeclaringClass() == Object.class) {
-              return method.invoke(this, args);
-            }
-            if (platform.isDefaultMethod(method)) {
-              return platform.invokeDefaultMethod(method, service, proxy, args);
-            }
-            ServiceMethod<Object, Object> serviceMethod =
-                (ServiceMethod<Object, Object>) loadServiceMethod(method);
-            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-            return serviceMethod.callAdapter.adapt(okHttpCall);
-          }
-        });
-  }
-
-  private void eagerlyValidateMethods(Class<?> service) {
-    Platform platform = Platform.get();
-    for (Method method : service.getDeclaredMethods()) {
-      if (!platform.isDefaultMethod(method)) {
-        loadServiceMethod(method);
-      }
-    }
-  }
-
-  ServiceMethod<?, ?> loadServiceMethod(Method method) {
-    ServiceMethod<?, ?> result = serviceMethodCache.get(method);
-    if (result != null) return result;
-
-    synchronized (serviceMethodCache) {
-      result = serviceMethodCache.get(method);
-      if (result == null) {
-        result = new ServiceMethod.Builder<>(this, method).build();
-        serviceMethodCache.put(method, result);
-      }
-    }
-    return result;
-  }
-
-  /**
-   * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
-   * Typically an instance of {@link OkHttpClient}.
-   */
-  public okhttp3.Call.Factory callFactory() {
-    return callFactory;
-  }
-
-  /** The API base URL. */
-  public HttpUrl baseUrl() {
-    return baseUrl;
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
-   */
-  public List<CallAdapter.Factory> callAdapterFactories() {
-    return adapterFactories;
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
-    return nextCallAdapter(null, returnType, annotations);
-  }
-
-  /**
-   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
-   * #callAdapterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no call adapter available for {@code type}.
-   */
-  public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
-      Annotation[] annotations) {
-    checkNotNull(returnType, "returnType == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = adapterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
-      if (adapter != null) {
-        return adapter;
-      }
+    private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap<>();
+
+    final okhttp3.Call.Factory callFactory;
+    final HttpUrl baseUrl;
+    final List<Converter.Factory> converterFactories;
+    final List<CallAdapter.Factory> adapterFactories;
+    final Executor callbackExecutor;
+    final boolean validateEagerly;
+
+    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
+            List<Converter.Factory> converterFactories, List<CallAdapter.Factory> adapterFactories,
+            Executor callbackExecutor, boolean validateEagerly) {
+        this.callFactory = callFactory;
+        this.baseUrl = baseUrl;
+        this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site.
+        this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site.
+        this.callbackExecutor = callbackExecutor;
+        this.validateEagerly = validateEagerly;
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
-        .append(returnType)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = adapterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a list of the factories tried when creating a
-   * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
-   * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
-   * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
-   */
-  public List<Converter.Factory> converterFactories() {
-    return converterFactories;
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(parameterAnnotations, "parameterAnnotations == null");
-    checkNotNull(methodAnnotations, "methodAnnotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter.Factory factory = converterFactories.get(i);
-      Converter<?, RequestBody> converter =
-          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, RequestBody>) converter;
-      }
+    /**
+     * Create an implementation of the API endpoints defined by the {@code service} interface.
+     * <p>
+     * The relative path for a given method is obtained from an annotation on the method describing
+     * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+     * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+     * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+     * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+     * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+     * parameter with {@link Url @Url}.
+     * <p>
+     * Method parameters can be used to replace parts of the URL by annotating them with
+     * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+     * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+     * {@link retrofit2.http.Query @Query}.
+     * <p>
+     * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+     * object will be converted to request representation by one of the {@link Converter.Factory}
+     * instances. A {@link RequestBody} can also be used for a raw representation.
+     * <p>
+     * Alternative request body formats are supported by method annotations and corresponding
+     * parameter annotations:
+     * <ul>
+     * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+     * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+     * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with
+     * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+     * </ul>
+     * <p>
+     * Additional static headers can be added for an endpoint using the
+     * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+     * header annotate a parameter with {@link Header @Header}.
+     * <p>
+     * By default, methods return a {@link Call} which represents the HTTP request. The generic
+     * parameter of the call is the response body type and will be converted by one of the
+     * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+     * representation. {@link Void} can be used if you do not care about the body contents.
+     * <p>
+     * For example:
+     * <pre>
+     * public interface CategoryService {
+     *   &#64;POST("category/{cat}/")
+     *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+     * }
+     * </pre>
+     */
+    @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+    public <T> T create(final Class<T> service) {
+        Utils.validateServiceInterface(service);
+        if (validateEagerly) {
+            eagerlyValidateMethods(service);
+        }
+        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service},
+                new InvocationHandler() {
+                    private final Platform platform = Platform.get();
+
+                    @Override
+                    public Object invoke(Object proxy, Method method, Object... args)
+                            throws Throwable {
+                        // If the method is a method from Object then defer to normal invocation.
+                        if (method.getDeclaringClass() == Object.class) {
+                            return method.invoke(this, args);
+                        }
+                        if (platform.isDefaultMethod(method)) {
+                            return platform.invokeDefaultMethod(method, service, proxy, args);
+                        }
+                        ServiceMethod<Object, Object> serviceMethod =
+                                (ServiceMethod<Object, Object>) loadServiceMethod(method);
+                        OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+                        return serviceMethod.callAdapter.adapt(okHttpCall);
+                    }
+                });
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-    }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
-    return nextResponseBodyConverter(null, type, annotations);
-  }
-
-  /**
-   * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
-   * {@linkplain #converterFactories() factories} except {@code skipPast}.
-   *
-   * @throws IllegalArgumentException if no converter available for {@code type}.
-   */
-  public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
-      Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    int start = converterFactories.indexOf(skipPast) + 1;
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      Converter<ResponseBody, ?> converter =
-          converterFactories.get(i).responseBodyConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<ResponseBody, T>) converter;
-      }
+    private void eagerlyValidateMethods(Class<?> service) {
+        Platform platform = Platform.get();
+        for (Method method : service.getDeclaredMethods()) {
+            if (!platform.isDefaultMethod(method)) {
+                loadServiceMethod(method);
+            }
+        }
     }
 
-    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
-        .append(type)
-        .append(".\n");
-    if (skipPast != null) {
-      builder.append("  Skipped:");
-      for (int i = 0; i < start; i++) {
-        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
-      }
-      builder.append('\n');
-    }
-    builder.append("  Tried:");
-    for (int i = start, count = converterFactories.size(); i < count; i++) {
-      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+    ServiceMethod<?, ?> loadServiceMethod(Method method) {
+        ServiceMethod<?, ?> result = serviceMethodCache.get(method);
+        if (result != null) return result;
+
+        synchronized (serviceMethodCache) {
+            result = serviceMethodCache.get(method);
+            if (result == null) {
+                result = new ServiceMethod.Builder<>(this, method).build();
+                serviceMethodCache.put(method, result);
+            }
+        }
+        return result;
     }
-    throw new IllegalArgumentException(builder.toString());
-  }
-
-  /**
-   * Returns a {@link Converter} for {@code type} to {@link String} from the available
-   * {@linkplain #converterFactories() factories}.
-   */
-  public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
-    checkNotNull(type, "type == null");
-    checkNotNull(annotations, "annotations == null");
-
-    for (int i = 0, count = converterFactories.size(); i < count; i++) {
-      Converter<?, String> converter =
-          converterFactories.get(i).stringConverter(type, annotations, this);
-      if (converter != null) {
-        //noinspection unchecked
-        return (Converter<T, String>) converter;
-      }
+
+    /**
+     * The factory used to create {@linkplain okhttp3.Call OkHttp calls} for sending a HTTP requests.
+     * Typically an instance of {@link OkHttpClient}.
+     */
+    public okhttp3.Call.Factory callFactory() {
+        return callFactory;
     }
 
-    // Nothing matched. Resort to default converter which just calls toString().
-    //noinspection unchecked
-    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
-  }
-
-  /**
-   * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
-   * in which case callbacks should be made synchronously on the background thread.
-   */
-  public Executor callbackExecutor() {
-    return callbackExecutor;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Build a new {@link Retrofit}.
-   * <p>
-   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static final class Builder {
-    private final Platform platform;
-    private okhttp3.Call.Factory callFactory;
-    private HttpUrl baseUrl;
-    private final List<Converter.Factory> converterFactories = new ArrayList<>();
-    private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
-    private Executor callbackExecutor;
-    private boolean validateEagerly;
-
-    Builder(Platform platform) {
-      this.platform = platform;
-      // Add the built-in converter factory first. This prevents overriding its behavior but also
-      // ensures correct behavior when using converters that consume all types.
-      converterFactories.add(new BuiltInConverters());
+    /** The API base URL. */
+    public HttpUrl baseUrl() {
+        return baseUrl;
     }
 
-    public Builder() {
-      this(Platform.get());
+    /**
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #callAdapter(Type, Annotation[])} call adapter}.
+     */
+    public List<CallAdapter.Factory> callAdapterFactories() {
+        return adapterFactories;
     }
 
-    Builder(Retrofit retrofit) {
-      platform = Platform.get();
-      callFactory = retrofit.callFactory;
-      baseUrl = retrofit.baseUrl;
-      converterFactories.addAll(retrofit.converterFactories);
-      adapterFactories.addAll(retrofit.adapterFactories);
-      // Remove the default, platform-aware call adapter added by build().
-      adapterFactories.remove(adapterFactories.size() - 1);
-      callbackExecutor = retrofit.callbackExecutor;
-      validateEagerly = retrofit.validateEagerly;
+    /**
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
+     */
+    public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
+        return nextCallAdapter(null, returnType, annotations);
     }
 
     /**
-     * The HTTP client used for requests.
-     * <p>
-     * This is a convenience method for calling {@link #callFactory}.
+     * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
+     * #callAdapterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no call adapter available for {@code type}.
      */
-    public Builder client(OkHttpClient client) {
-      return callFactory(checkNotNull(client, "client == null"));
+    public CallAdapter<?, ?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
+            Annotation[] annotations) {
+        checkNotNull(returnType, "returnType == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = adapterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            CallAdapter<?, ?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
+            if (adapter != null) {
+                return adapter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+                .append(returnType)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = adapterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(adapterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * Specify a custom call factory for creating {@link Call} instances.
-     * <p>
-     * Note: Calling {@link #client} automatically sets this value.
+     * Returns a list of the factories tried when creating a
+     * {@linkplain #requestBodyConverter(Type, Annotation[], Annotation[]) request body converter}, a
+     * {@linkplain #responseBodyConverter(Type, Annotation[]) response body converter}, or a
+     * {@linkplain #stringConverter(Type, Annotation[]) string converter}.
      */
-    public Builder callFactory(okhttp3.Call.Factory factory) {
-      this.callFactory = checkNotNull(factory, "factory == null");
-      return this;
+    public List<Converter.Factory> converterFactories() {
+        return converterFactories;
     }
 
     /**
-     * Set the API base URL.
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories}.
      *
-     * @see #baseUrl(HttpUrl)
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(String baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
-      if (httpUrl == null) {
-        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
-      }
-      return baseUrl(httpUrl);
+    public <T> Converter<T, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);
     }
 
     /**
-     * Set the API base URL.
-     * <p>
-     * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
-     * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
-     * {@code <a href="">} link on a website resolving on the current URL.
-     * <p>
-     * <b>Base URLs should always end in {@code /}.</b>
-     * <p>
-     * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
-     * append themselves to a base which has path components.
-     * <p>
-     * <b>Correct:</b><br>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/api/foo/bar/
-     * <p>
-     * <b>Incorrect:</b><br>
-     * Base URL: http://example.com/api<br>
-     * Endpoint: foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * This method enforces that {@code baseUrl} has a trailing {@code /}.
-     * <p>
-     * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
-     * <p>
-     * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
-     * components.
-     * <p>
-     * Base URL: http://example.com/api/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: /foo/bar/<br>
-     * Result: http://example.com/foo/bar/
-     * <p>
-     * <b>Endpoint values may be a full URL.</b>
-     * <p>
-     * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
-     * replace the scheme of {@code baseUrl}.
-     * <p>
-     * Base URL: http://example.com/<br>
-     * Endpoint: https://github.com/square/retrofit/<br>
-     * Result: https://github.com/square/retrofit/
-     * <p>
-     * Base URL: http://example.com<br>
-     * Endpoint: //github.com/square/retrofit/<br>
-     * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+     * Returns a {@link Converter} for {@code type} to {@link RequestBody} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder baseUrl(HttpUrl baseUrl) {
-      checkNotNull(baseUrl, "baseUrl == null");
-      List<String> pathSegments = baseUrl.pathSegments();
-      if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
-        throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
-      }
-      this.baseUrl = baseUrl;
-      return this;
+    public <T> Converter<T, RequestBody> nextRequestBodyConverter(Converter.Factory skipPast,
+            Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(parameterAnnotations, "parameterAnnotations == null");
+        checkNotNull(methodAnnotations, "methodAnnotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter.Factory factory = converterFactories.get(i);
+            Converter<?, RequestBody> converter =
+                    factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, RequestBody>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
-    /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory factory) {
-      converterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    /**
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
+     */
+    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {
+        return nextResponseBodyConverter(null, type, annotations);
     }
 
     /**
-     * Add a call adapter factory for supporting service method return types other than {@link
-     * Call}.
+     * Returns a {@link Converter} for {@link ResponseBody} to {@code type} from the available
+     * {@linkplain #converterFactories() factories} except {@code skipPast}.
+     *
+     * @throws IllegalArgumentException if no converter available for {@code type}.
      */
-    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
-      adapterFactories.add(checkNotNull(factory, "factory == null"));
-      return this;
+    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(Converter.Factory skipPast,
+            Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        int start = converterFactories.indexOf(skipPast) + 1;
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            Converter<ResponseBody, ?> converter =
+                    converterFactories.get(i).responseBodyConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<ResponseBody, T>) converter;
+            }
+        }
+
+        StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")
+                .append(type)
+                .append(".\n");
+        if (skipPast != null) {
+            builder.append("  Skipped:");
+            for (int i = 0; i < start; i++) {
+                builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+            }
+            builder.append('\n');
+        }
+        builder.append("  Tried:");
+        for (int i = start, count = converterFactories.size(); i < count; i++) {
+            builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());
+        }
+        throw new IllegalArgumentException(builder.toString());
     }
 
     /**
-     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
-     * your service method.
-     * <p>
-     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
-     * return types}.
+     * Returns a {@link Converter} for {@code type} to {@link String} from the available
+     * {@linkplain #converterFactories() factories}.
      */
-    public Builder callbackExecutor(Executor executor) {
-      this.callbackExecutor = checkNotNull(executor, "executor == null");
-      return this;
+    public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {
+        checkNotNull(type, "type == null");
+        checkNotNull(annotations, "annotations == null");
+
+        for (int i = 0, count = converterFactories.size(); i < count; i++) {
+            Converter<?, String> converter =
+                    converterFactories.get(i).stringConverter(type, annotations, this);
+            if (converter != null) {
+                //noinspection unchecked
+                return (Converter<T, String>) converter;
+            }
+        }
+
+        // Nothing matched. Resort to default converter which just calls toString().
+        //noinspection unchecked
+        return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
     }
 
     /**
-     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
-     * the configuration of all methods in the supplied interface.
+     * The executor used for {@link Callback} methods on a {@link Call}. This may be {@code null},
+     * in which case callbacks should be made synchronously on the background thread.
      */
-    public Builder validateEagerly(boolean validateEagerly) {
-      this.validateEagerly = validateEagerly;
-      return this;
+    public Executor callbackExecutor() {
+        return callbackExecutor;
+    }
+
+    public Builder newBuilder() {
+        return new Builder(this);
     }
 
     /**
-     * Create the {@link Retrofit} instance using the configured values.
+     * Build a new {@link Retrofit}.
      * <p>
-     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
-     * OkHttpClient} will be created and used.
+     * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+     * are optional.
      */
-    public Retrofit build() {
-      if (baseUrl == null) {
-        throw new IllegalStateException("Base URL required.");
-      }
-
-      okhttp3.Call.Factory callFactory = this.callFactory;
-      if (callFactory == null) {
-        callFactory = new OkHttpClient();
-      }
-
-      Executor callbackExecutor = this.callbackExecutor;
-      if (callbackExecutor == null) {
-        callbackExecutor = platform.defaultCallbackExecutor();
-      }
-
-      // Make a defensive copy of the adapters and add the default Call adapter.
-      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
-      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
-
-      // Make a defensive copy of the converters.
-      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
-
-      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
-          callbackExecutor, validateEagerly);
+    public static final class Builder {
+        private final Platform platform;
+        private okhttp3.Call.Factory callFactory;
+        private HttpUrl baseUrl;
+        private final List<Converter.Factory> converterFactories = new ArrayList<>();
+        private final List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+        private Executor callbackExecutor;
+        private boolean validateEagerly;
+
+        Builder(Platform platform) {
+            this.platform = platform;
+            // Add the built-in converter factory first. This prevents overriding its behavior but also
+            // ensures correct behavior when using converters that consume all types.
+            converterFactories.add(new BuiltInConverters());
+        }
+
+        public Builder() {
+            this(Platform.get());
+        }
+
+        Builder(Retrofit retrofit) {
+            platform = Platform.get();
+            callFactory = retrofit.callFactory;
+            baseUrl = retrofit.baseUrl;
+            converterFactories.addAll(retrofit.converterFactories);
+            adapterFactories.addAll(retrofit.adapterFactories);
+            // Remove the default, platform-aware call adapter added by build().
+            adapterFactories.remove(adapterFactories.size() - 1);
+            callbackExecutor = retrofit.callbackExecutor;
+            validateEagerly = retrofit.validateEagerly;
+        }
+
+        /**
+         * The HTTP client used for requests.
+         * <p>
+         * This is a convenience method for calling {@link #callFactory}.
+         */
+        public Builder client(OkHttpClient client) {
+            return callFactory(checkNotNull(client, "client == null"));
+        }
+
+        /**
+         * Specify a custom call factory for creating {@link Call} instances.
+         * <p>
+         * Note: Calling {@link #client} automatically sets this value.
+         */
+        public Builder callFactory(okhttp3.Call.Factory factory) {
+            this.callFactory = checkNotNull(factory, "factory == null");
+            return this;
+        }
+
+        /**
+         * Set the API base URL.
+         *
+         * @see #baseUrl(HttpUrl)
+         */
+        public Builder baseUrl(String baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+            if (httpUrl == null) {
+                throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+            }
+            return baseUrl(httpUrl);
+        }
+
+        /**
+         * Set the API base URL.
+         * <p>
+         * The specified endpoint values (such as with {@link GET @GET}) are resolved against this
+         * value using {@link HttpUrl#resolve(String)}. The behavior of this matches that of an
+         * {@code <a href="">} link on a website resolving on the current URL.
+         * <p>
+         * <b>Base URLs should always end in {@code /}.</b>
+         * <p>
+         * A trailing {@code /} ensures that endpoints values which are relative paths will correctly
+         * append themselves to a base which has path components.
+         * <p>
+         * <b>Correct:</b><br>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/api/foo/bar/
+         * <p>
+         * <b>Incorrect:</b><br>
+         * Base URL: http://example.com/api<br>
+         * Endpoint: foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * This method enforces that {@code baseUrl} has a trailing {@code /}.
+         * <p>
+         * <b>Endpoint values which contain a leading {@code /} are absolute.</b>
+         * <p>
+         * Absolute values retain only the host from {@code baseUrl} and ignore any specified path
+         * components.
+         * <p>
+         * Base URL: http://example.com/api/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: /foo/bar/<br>
+         * Result: http://example.com/foo/bar/
+         * <p>
+         * <b>Endpoint values may be a full URL.</b>
+         * <p>
+         * Values which have a host replace the host of {@code baseUrl} and values also with a scheme
+         * replace the scheme of {@code baseUrl}.
+         * <p>
+         * Base URL: http://example.com/<br>
+         * Endpoint: https://github.com/square/retrofit/<br>
+         * Result: https://github.com/square/retrofit/
+         * <p>
+         * Base URL: http://example.com<br>
+         * Endpoint: //github.com/square/retrofit/<br>
+         * Result: http://github.com/square/retrofit/ (note the scheme stays 'http')
+         */
+        public Builder baseUrl(HttpUrl baseUrl) {
+            checkNotNull(baseUrl, "baseUrl == null");
+            List<String> pathSegments = baseUrl.pathSegments();
+            if (!"".equals(pathSegments.get(pathSegments.size() - 1))) {
+                throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl);
+            }
+            this.baseUrl = baseUrl;
+            return this;
+        }
+
+        /** Add converter factory for serialization and deserialization of objects. */
+        public Builder addConverterFactory(Converter.Factory factory) {
+            converterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * Add a call adapter factory for supporting service method return types other than {@link
+         * Call}.
+         */
+        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+            adapterFactories.add(checkNotNull(factory, "factory == null"));
+            return this;
+        }
+
+        /**
+         * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+         * your service method.
+         * <p>
+         * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+         * return types}.
+         */
+        public Builder callbackExecutor(Executor executor) {
+            this.callbackExecutor = checkNotNull(executor, "executor == null");
+            return this;
+        }
+
+        /**
+         * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
+         * the configuration of all methods in the supplied interface.
+         */
+        public Builder validateEagerly(boolean validateEagerly) {
+            this.validateEagerly = validateEagerly;
+            return this;
+        }
+
+        /**
+         * Create the {@link Retrofit} instance using the configured values.
+         * <p>
+         * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+         * OkHttpClient} will be created and used.
+         */
+        public Retrofit build() {
+            if (baseUrl == null) {
+                throw new IllegalStateException("Base URL required.");
+            }
+
+            okhttp3.Call.Factory callFactory = this.callFactory;
+            if (callFactory == null) {
+                callFactory = new OkHttpClient();
+            }
+
+            Executor callbackExecutor = this.callbackExecutor;
+            if (callbackExecutor == null) {
+                callbackExecutor = platform.defaultCallbackExecutor();
+            }
+
+            // Make a defensive copy of the adapters and add the default Call adapter.
+            List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+            adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
+
+            // Make a defensive copy of the converters.
+            List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+            return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
+                    callbackExecutor, validateEagerly);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 3a4325a7e..6a097b9fc 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
@@ -57,702 +58,737 @@
 
 /** Adapts an invocation of an interface method into an HTTP call. */
 final class ServiceMethod<R, T> {
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-
-  final okhttp3.Call.Factory callFactory;
-  final CallAdapter<R, T> callAdapter;
-
-  private final HttpUrl baseUrl;
-  private final Converter<ResponseBody, R> responseConverter;
-  private final String httpMethod;
-  private final String relativeUrl;
-  private final Headers headers;
-  private final MediaType contentType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final ParameterHandler<?>[] parameterHandlers;
-
-  ServiceMethod(Builder<R, T> builder) {
-    this.callFactory = builder.retrofit.callFactory();
-    this.callAdapter = builder.callAdapter;
-    this.baseUrl = builder.retrofit.baseUrl();
-    this.responseConverter = builder.responseConverter;
-    this.httpMethod = builder.httpMethod;
-    this.relativeUrl = builder.relativeUrl;
-    this.headers = builder.headers;
-    this.contentType = builder.contentType;
-    this.hasBody = builder.hasBody;
-    this.isFormEncoded = builder.isFormEncoded;
-    this.isMultipart = builder.isMultipart;
-    this.parameterHandlers = builder.parameterHandlers;
-  }
-
-  /** Builds an HTTP request from method arguments. */
-  Request toRequest(Object... args) throws IOException {
-    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
-        contentType, hasBody, isFormEncoded, isMultipart);
-
-    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
-    ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
-
-    int argumentCount = args != null ? args.length : 0;
-    if (argumentCount != handlers.length) {
-      throw new IllegalArgumentException("Argument count (" + argumentCount
-          + ") doesn't match expected count (" + handlers.length + ")");
+    // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+    static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+    static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+    static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+
+    final okhttp3.Call.Factory callFactory;
+    final CallAdapter<R, T> callAdapter;
+
+    private final HttpUrl baseUrl;
+    private final Converter<ResponseBody, R> responseConverter;
+    private final String httpMethod;
+    private final String relativeUrl;
+    private final Headers headers;
+    private final MediaType contentType;
+    private final boolean hasBody;
+    private final boolean isFormEncoded;
+    private final boolean isMultipart;
+    private final ParameterHandler<?>[] parameterHandlers;
+
+    ServiceMethod(Builder<R, T> builder) {
+        this.callFactory = builder.retrofit.callFactory();
+        this.callAdapter = builder.callAdapter;
+        this.baseUrl = builder.retrofit.baseUrl();
+        this.responseConverter = builder.responseConverter;
+        this.httpMethod = builder.httpMethod;
+        this.relativeUrl = builder.relativeUrl;
+        this.headers = builder.headers;
+        this.contentType = builder.contentType;
+        this.hasBody = builder.hasBody;
+        this.isFormEncoded = builder.isFormEncoded;
+        this.isMultipart = builder.isMultipart;
+        this.parameterHandlers = builder.parameterHandlers;
     }
 
-    for (int p = 0; p < argumentCount; p++) {
-      handlers[p].apply(requestBuilder, args[p]);
-    }
+    /** Builds an HTTP request from method arguments. */
+    Request toRequest(Object... args) throws IOException {
+        RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
+                contentType, hasBody, isFormEncoded, isMultipart);
 
-    return requestBuilder.build();
-  }
-
-  /** Builds a method return value from an HTTP response body. */
-  R toResponse(ResponseBody body) throws IOException {
-    return responseConverter.convert(body);
-  }
-
-  /**
-   * Inspects the annotations on an interface method to construct a reusable service method. This
-   * requires potentially-expensive reflection so it is best to build each service method only once
-   * and reuse it. Builders cannot be reused.
-   */
-  static final class Builder<T, R> {
-    final Retrofit retrofit;
-    final Method method;
-    final Annotation[] methodAnnotations;
-    final Annotation[][] parameterAnnotationsArray;
-    final Type[] parameterTypes;
-
-    Type responseType;
-    boolean gotField;
-    boolean gotPart;
-    boolean gotBody;
-    boolean gotPath;
-    boolean gotQuery;
-    boolean gotUrl;
-    String httpMethod;
-    boolean hasBody;
-    boolean isFormEncoded;
-    boolean isMultipart;
-    String relativeUrl;
-    Headers headers;
-    MediaType contentType;
-    Set<String> relativeUrlParamNames;
-    ParameterHandler<?>[] parameterHandlers;
-    Converter<ResponseBody, T> responseConverter;
-    CallAdapter<T, R> callAdapter;
-
-    public Builder(Retrofit retrofit, Method method) {
-      this.retrofit = retrofit;
-      this.method = method;
-      this.methodAnnotations = method.getAnnotations();
-      this.parameterTypes = method.getGenericParameterTypes();
-      this.parameterAnnotationsArray = method.getParameterAnnotations();
-    }
+        @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.
+                ParameterHandler<Object>[] handlers = (ParameterHandler<Object>[]) parameterHandlers;
 
-    public ServiceMethod build() {
-      callAdapter = createCallAdapter();
-      responseType = callAdapter.responseType();
-      if (responseType == Response.class || responseType == okhttp3.Response.class) {
-        throw methodError("'"
-            + Utils.getRawType(responseType).getName()
-            + "' is not a valid response body type. Did you mean ResponseBody?");
-      }
-      responseConverter = createResponseConverter();
-
-      for (Annotation annotation : methodAnnotations) {
-        parseMethodAnnotation(annotation);
-      }
-
-      if (httpMethod == null) {
-        throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-      }
-
-      if (!hasBody) {
-        if (isMultipart) {
-          throw methodError(
-              "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-        }
-        if (isFormEncoded) {
-          throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
-              + "request body (e.g., @POST).");
-        }
-      }
-
-      int parameterCount = parameterAnnotationsArray.length;
-      parameterHandlers = new ParameterHandler<?>[parameterCount];
-      for (int p = 0; p < parameterCount; p++) {
-        Type parameterType = parameterTypes[p];
-        if (Utils.hasUnresolvableType(parameterType)) {
-          throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
-              parameterType);
+        int argumentCount = args != null ? args.length : 0;
+        if (argumentCount != handlers.length) {
+            throw new IllegalArgumentException("Argument count (" + argumentCount
+                    + ") doesn't match expected count (" + handlers.length + ")");
         }
 
-        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
-        if (parameterAnnotations == null) {
-          throw parameterError(p, "No Retrofit annotation found.");
+        for (int p = 0; p < argumentCount; p++) {
+            handlers[p].apply(requestBuilder, args[p]);
         }
 
-        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
-      }
-
-      if (relativeUrl == null && !gotUrl) {
-        throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
-      }
-      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-        throw methodError("Non-body HTTP method cannot contain @Body.");
-      }
-      if (isFormEncoded && !gotField) {
-        throw methodError("Form-encoded method must contain at least one @Field.");
-      }
-      if (isMultipart && !gotPart) {
-        throw methodError("Multipart method must contain at least one @Part.");
-      }
-
-      return new ServiceMethod<>(this);
+        return requestBuilder.build();
     }
 
-    private CallAdapter<T, R> createCallAdapter() {
-      Type returnType = method.getGenericReturnType();
-      if (Utils.hasUnresolvableType(returnType)) {
-        throw methodError(
-            "Method return type must not include a type variable or wildcard: %s", returnType);
-      }
-      if (returnType == void.class) {
-        throw methodError("Service methods cannot return void.");
-      }
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        //noinspection unchecked
-        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create call adapter for %s", returnType);
-      }
+    /** Builds a method return value from an HTTP response body. */
+    R toResponse(ResponseBody body) throws IOException {
+        return responseConverter.convert(body);
     }
 
-    private void parseMethodAnnotation(Annotation annotation) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-        if (!Void.class.equals(responseType)) {
-          throw methodError("HEAD method must use Void as response type.");
-        }
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof OPTIONS) {
-        parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        isFormEncoded = true;
-      }
-    }
+    /**
+     * Inspects the annotations on an interface method to construct a reusable service method. This
+     * requires potentially-expensive reflection so it is best to build each service method only once
+     * and reuse it. Builders cannot be reused.
+     */
+    static final class Builder<T, R> {
+        final Retrofit retrofit;
+        final Method method;
+        final Annotation[] methodAnnotations;
+        final Annotation[][] parameterAnnotationsArray;
+        final Type[] parameterTypes;
+
+        Type responseType;
+        boolean gotField;
+        boolean gotPart;
+        boolean gotBody;
+        boolean gotPath;
+        boolean gotQuery;
+        boolean gotUrl;
+        String httpMethod;
+        boolean hasBody;
+        boolean isFormEncoded;
+        boolean isMultipart;
+        String relativeUrl;
+        Headers headers;
+        MediaType contentType;
+        Set<String> relativeUrlParamNames;
+        ParameterHandler<?>[] parameterHandlers;
+        Converter<ResponseBody, T> responseConverter;
+        CallAdapter<T, R> callAdapter;
+
+        public Builder(Retrofit retrofit, Method method) {
+            this.retrofit = retrofit;
+            this.method = method;
+            this.methodAnnotations = method.getAnnotations();
+            this.parameterTypes = method.getGenericParameterTypes();
+            this.parameterAnnotationsArray = method.getParameterAnnotations();
+        }
+
+        public ServiceMethod build() {
+            callAdapter = createCallAdapter();
+            responseType = callAdapter.responseType();
+            if (responseType == Response.class || responseType == okhttp3.Response.class) {
+                throw methodError("'"
+                        + Utils.getRawType(responseType).getName()
+                        + "' is not a valid response body type. Did you mean ResponseBody?");
+            }
+            responseConverter = createResponseConverter();
 
-    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-      if (this.httpMethod != null) {
-        throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
-            this.httpMethod, httpMethod);
-      }
-      this.httpMethod = httpMethod;
-      this.hasBody = hasBody;
-
-      if (value.isEmpty()) {
-        return;
-      }
-
-      // Get the relative URL path and existing query string, if present.
-      int question = value.indexOf('?');
-      if (question != -1 && question < value.length() - 1) {
-        // Ensure the query string does not have any named parameters.
-        String queryParams = value.substring(question + 1);
-        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
-        if (queryParamMatcher.find()) {
-          throw methodError("URL query string \"%s\" must not have replace block. "
-              + "For dynamic query parameters use @Query.", queryParams);
-        }
-      }
+            for (Annotation annotation : methodAnnotations) {
+                parseMethodAnnotation(annotation);
+            }
 
-      this.relativeUrl = value;
-      this.relativeUrlParamNames = parsePathParameters(value);
-    }
+            if (httpMethod == null) {
+                throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+            }
 
-    private Headers parseHeaders(String[] headers) {
-      Headers.Builder builder = new Headers.Builder();
-      for (String header : headers) {
-        int colon = header.indexOf(':');
-        if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-          throw methodError(
-              "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
-        }
-        String headerName = header.substring(0, colon);
-        String headerValue = header.substring(colon + 1).trim();
-        if ("Content-Type".equalsIgnoreCase(headerName)) {
-          MediaType type = MediaType.parse(headerValue);
-          if (type == null) {
-            throw methodError("Malformed content type: %s", headerValue);
-          }
-          contentType = type;
-        } else {
-          builder.add(headerName, headerValue);
-        }
-      }
-      return builder.build();
-    }
+            if (!hasBody) {
+                if (isMultipart) {
+                    throw methodError(
+                            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+                }
+                if (isFormEncoded) {
+                    throw methodError("FormUrlEncoded can only be specified on HTTP methods with "
+                            + "request body (e.g., @POST).");
+                }
+            }
 
-    private ParameterHandler<?> parseParameter(
-        int p, Type parameterType, Annotation[] annotations) {
-      ParameterHandler<?> result = null;
-      for (Annotation annotation : annotations) {
-        ParameterHandler<?> annotationAction = parseParameterAnnotation(
-            p, parameterType, annotations, annotation);
+            int parameterCount = parameterAnnotationsArray.length;
+            parameterHandlers = new ParameterHandler<?>[parameterCount];
+            for (int p = 0; p < parameterCount; p++) {
+                Type parameterType = parameterTypes[p];
+                if (Utils.hasUnresolvableType(parameterType)) {
+                    throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s",
+                            parameterType);
+                }
+
+                Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
+                if (parameterAnnotations == null) {
+                    throw parameterError(p, "No Retrofit annotation found.");
+                }
+
+                parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
+            }
 
-        if (annotationAction == null) {
-          continue;
+            if (relativeUrl == null && !gotUrl) {
+                throw methodError("Missing either @%s URL or @Url parameter.", httpMethod);
+            }
+            if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+                throw methodError("Non-body HTTP method cannot contain @Body.");
+            }
+            if (isFormEncoded && !gotField) {
+                throw methodError("Form-encoded method must contain at least one @Field.");
+            }
+            if (isMultipart && !gotPart) {
+                throw methodError("Multipart method must contain at least one @Part.");
+            }
+
+            return new ServiceMethod<>(this);
         }
 
-        if (result != null) {
-          throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+        private CallAdapter<T, R> createCallAdapter() {
+            Type returnType = method.getGenericReturnType();
+            if (Utils.hasUnresolvableType(returnType)) {
+                throw methodError(
+                        "Method return type must not include a type variable or wildcard: %s", returnType);
+            }
+            if (returnType == void.class) {
+                throw methodError("Service methods cannot return void.");
+            }
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                //noinspection unchecked
+                return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create call adapter for %s", returnType);
+            }
         }
 
-        result = annotationAction;
-      }
+        private void parseMethodAnnotation(Annotation annotation) {
+            if (annotation instanceof DELETE) {
+                parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+            }
+            else if (annotation instanceof GET) {
+                parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+            }
+            else if (annotation instanceof HEAD) {
+                parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+                if (!Void.class.equals(responseType)) {
+                    throw methodError("HEAD method must use Void as response type.");
+                }
+            }
+            else if (annotation instanceof PATCH) {
+                parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+            }
+            else if (annotation instanceof POST) {
+                parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+            }
+            else if (annotation instanceof PUT) {
+                parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+            }
+            else if (annotation instanceof OPTIONS) {
+                parseHttpMethodAndPath("OPTIONS", ((OPTIONS) annotation).value(), false);
+            }
+            else if (annotation instanceof HTTP) {
+                HTTP http = (HTTP) annotation;
+                parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+            }
+            else if (annotation instanceof retrofit2.http.Headers) {
+                String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+                if (headersToParse.length == 0) {
+                    throw methodError("@Headers annotation is empty.");
+                }
+                headers = parseHeaders(headersToParse);
+            }
+            else if (annotation instanceof Multipart) {
+                if (isFormEncoded) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isMultipart = true;
+            }
+            else if (annotation instanceof FormUrlEncoded) {
+                if (isMultipart) {
+                    throw methodError("Only one encoding annotation is allowed.");
+                }
+                isFormEncoded = true;
+            }
+        }
 
-      if (result == null) {
-        throw parameterError(p, "No Retrofit annotation found.");
-      }
+        private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+            if (this.httpMethod != null) {
+                throw methodError("Only one HTTP method is allowed. Found: %s and %s.",
+                        this.httpMethod, httpMethod);
+            }
+            this.httpMethod = httpMethod;
+            this.hasBody = hasBody;
 
-      return result;
-    }
+            if (value.isEmpty()) {
+                return;
+            }
 
-    private ParameterHandler<?> parseParameterAnnotation(
-        int p, Type type, Annotation[] annotations, Annotation annotation) {
-      if (annotation instanceof Url) {
-        if (gotUrl) {
-          throw parameterError(p, "Multiple @Url method annotations found.");
-        }
-        if (gotPath) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (gotQuery) {
-          throw parameterError(p, "A @Url parameter must not come after a @Query");
-        }
-        if (relativeUrl != null) {
-          throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+            // Get the relative URL path and existing query string, if present.
+            int question = value.indexOf('?');
+            if (question != -1 && question < value.length() - 1) {
+                // Ensure the query string does not have any named parameters.
+                String queryParams = value.substring(question + 1);
+                Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+                if (queryParamMatcher.find()) {
+                    throw methodError("URL query string \"%s\" must not have replace block. "
+                            + "For dynamic query parameters use @Query.", queryParams);
+                }
+            }
+
+            this.relativeUrl = value;
+            this.relativeUrlParamNames = parsePathParameters(value);
+        }
+
+        private Headers parseHeaders(String[] headers) {
+            Headers.Builder builder = new Headers.Builder();
+            for (String header : headers) {
+                int colon = header.indexOf(':');
+                if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+                    throw methodError(
+                            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+                }
+                String headerName = header.substring(0, colon);
+                String headerValue = header.substring(colon + 1).trim();
+                if ("Content-Type".equalsIgnoreCase(headerName)) {
+                    MediaType type = MediaType.parse(headerValue);
+                    if (type == null) {
+                        throw methodError("Malformed content type: %s", headerValue);
+                    }
+                    contentType = type;
+                }
+                else {
+                    builder.add(headerName, headerValue);
+                }
+            }
+            return builder.build();
         }
 
-        gotUrl = true;
+        private ParameterHandler<?> parseParameter(
+                int p, Type parameterType, Annotation[] annotations) {
+            ParameterHandler<?> result = null;
+            for (Annotation annotation : annotations) {
+                ParameterHandler<?> annotationAction = parseParameterAnnotation(
+                        p, parameterType, annotations, annotation);
 
-        if (type == HttpUrl.class
-            || type == String.class
-            || type == URI.class
-            || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl();
-        } else {
-          throw parameterError(p,
-              "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
-        }
+                if (annotationAction == null) {
+                    continue;
+                }
 
-      } else if (annotation instanceof Path) {
-        if (gotQuery) {
-          throw parameterError(p, "A @Path parameter must not come after a @Query.");
-        }
-        if (gotUrl) {
-          throw parameterError(p, "@Path parameters may not be used with @Url.");
-        }
-        if (relativeUrl == null) {
-          throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
-        }
-        gotPath = true;
-
-        Path path = (Path) annotation;
-        String name = path.value();
-        validatePathName(p, name);
-
-        Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(name, converter, path.encoded());
-
-      } else if (annotation instanceof Query) {
-        Query query = (Query) annotation;
-        String name = query.value();
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Query<>(name, converter, encoded);
-        }
+                if (result != null) {
+                    throw parameterError(p, "Multiple Retrofit annotations found, only one allowed.");
+                }
 
-      } else if (annotation instanceof QueryMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@QueryMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
-
-        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
-
-      } else if (annotation instanceof Header) {
-        Header header = (Header) annotation;
-        String name = header.value();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
-        }
+                result = annotationAction;
+            }
 
-      } else if (annotation instanceof HeaderMap) {
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@HeaderMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+            if (result == null) {
+                throw parameterError(p, "No Retrofit annotation found.");
+            }
 
-        return new ParameterHandler.HeaderMap<>(valueConverter);
+            return result;
+        }
+
+        private ParameterHandler<?> parseParameterAnnotation(
+                int p, Type type, Annotation[] annotations, Annotation annotation) {
+            if (annotation instanceof Url) {
+                if (gotUrl) {
+                    throw parameterError(p, "Multiple @Url method annotations found.");
+                }
+                if (gotPath) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (gotQuery) {
+                    throw parameterError(p, "A @Url parameter must not come after a @Query");
+                }
+                if (relativeUrl != null) {
+                    throw parameterError(p, "@Url cannot be used with @%s URL", httpMethod);
+                }
+
+                gotUrl = true;
+
+                if (type == HttpUrl.class
+                        || type == String.class
+                        || type == URI.class
+                        || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
+                    return new ParameterHandler.RelativeUrl();
+                }
+                else {
+                    throw parameterError(p,
+                            "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
+                }
 
-      } else if (annotation instanceof Field) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@Field parameters can only be used with form encoding.");
-        }
-        Field field = (Field) annotation;
-        String name = field.value();
-        boolean encoded = field.encoded();
-
-        gotField = true;
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Field<>(name, converter, encoded);
-        }
+            }
+            else if (annotation instanceof Path) {
+                if (gotQuery) {
+                    throw parameterError(p, "A @Path parameter must not come after a @Query.");
+                }
+                if (gotUrl) {
+                    throw parameterError(p, "@Path parameters may not be used with @Url.");
+                }
+                if (relativeUrl == null) {
+                    throw parameterError(p, "@Path can only be used with relative url on @%s", httpMethod);
+                }
+                gotPath = true;
+
+                Path path = (Path) annotation;
+                String name = path.value();
+                validatePathName(p, name);
+
+                Converter<?, String> converter = retrofit.stringConverter(type, annotations);
+                return new ParameterHandler.Path<>(name, converter, path.encoded());
 
-      } else if (annotation instanceof FieldMap) {
-        if (!isFormEncoded) {
-          throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
-        }
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@FieldMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p,
-              "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
-        }
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        Converter<?, String> valueConverter =
-            retrofit.stringConverter(valueType, annotations);
+            }
+            else if (annotation instanceof Query) {
+                Query query = (Query) annotation;
+                String name = query.value();
+                boolean encoded = query.encoded();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                gotQuery = true;
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).iterable();
+                }
+                else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded).array();
+                }
+                else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Query<>(name, converter, encoded);
+                }
 
-        gotField = true;
-        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
+            }
+            else if (annotation instanceof QueryMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@QueryMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@QueryMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
-      } else if (annotation instanceof Part) {
-        if (!isMultipart) {
-          throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
-        }
-        Part part = (Part) annotation;
-        gotPart = true;
-
-        String partName = part.value();
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (partName.isEmpty()) {
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = rawParameterType.getComponentType();
-            if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p,
-                  "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-            }
-            return ParameterHandler.RawPart.INSTANCE.array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            return ParameterHandler.RawPart.INSTANCE;
-          } else {
-            throw parameterError(p,
-                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
-          }
-        } else {
-          Headers headers =
-              Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
-                  "Content-Transfer-Encoding", part.encoding());
-
-          if (Iterable.class.isAssignableFrom(rawParameterType)) {
-            if (!(type instanceof ParameterizedType)) {
-              throw parameterError(p, rawParameterType.getSimpleName()
-                  + " must include generic type (e.g., "
-                  + rawParameterType.getSimpleName()
-                  + "<String>)");
-            }
-            ParameterizedType parameterizedType = (ParameterizedType) type;
-            Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-            if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).iterable();
-          } else if (rawParameterType.isArray()) {
-            Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-            if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
-              throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                  + "include a part name in the annotation.");
-            }
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter).array();
-          } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
-            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
-                + "include a part name in the annotation.");
-          } else {
-            Converter<?, RequestBody> converter =
-                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(headers, converter);
-          }
-        }
+            }
+            else if (annotation instanceof Header) {
+                Header header = (Header) annotation;
+                String name = header.value();
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).iterable();
+                }
+                else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Header<>(name, converter).array();
+                }
+                else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Header<>(name, converter);
+                }
 
-      } else if (annotation instanceof PartMap) {
-        if (!isMultipart) {
-          throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
-        }
-        gotPart = true;
-        Class<?> rawParameterType = Utils.getRawType(type);
-        if (!Map.class.isAssignableFrom(rawParameterType)) {
-          throw parameterError(p, "@PartMap parameter type must be Map.");
-        }
-        Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
-        if (!(mapType instanceof ParameterizedType)) {
-          throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
-        }
-        ParameterizedType parameterizedType = (ParameterizedType) mapType;
+            }
+            else if (annotation instanceof HeaderMap) {
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@HeaderMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@HeaderMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                return new ParameterHandler.HeaderMap<>(valueConverter);
 
-        Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
-        if (String.class != keyType) {
-          throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
-        }
+            }
+            else if (annotation instanceof Field) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@Field parameters can only be used with form encoding.");
+                }
+                Field field = (Field) annotation;
+                String name = field.value();
+                boolean encoded = field.encoded();
+
+                gotField = true;
+
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                    if (!(type instanceof ParameterizedType)) {
+                        throw parameterError(p, rawParameterType.getSimpleName()
+                                + " must include generic type (e.g., "
+                                + rawParameterType.getSimpleName()
+                                + "<String>)");
+                    }
+                    ParameterizedType parameterizedType = (ParameterizedType) type;
+                    Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(iterableType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).iterable();
+                }
+                else if (rawParameterType.isArray()) {
+                    Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(arrayComponentType, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded).array();
+                }
+                else {
+                    Converter<?, String> converter =
+                            retrofit.stringConverter(type, annotations);
+                    return new ParameterHandler.Field<>(name, converter, encoded);
+                }
 
-        Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
-        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
-          throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
-              + "Use @Part List<Part> or a different value type instead.");
-        }
+            }
+            else if (annotation instanceof FieldMap) {
+                if (!isFormEncoded) {
+                    throw parameterError(p, "@FieldMap parameters can only be used with form encoding.");
+                }
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@FieldMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p,
+                            "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@FieldMap keys must be of type String: " + keyType);
+                }
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                Converter<?, String> valueConverter =
+                        retrofit.stringConverter(valueType, annotations);
+
+                gotField = true;
+                return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
-        Converter<?, RequestBody> valueConverter =
-            retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+            }
+            else if (annotation instanceof Part) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@Part parameters can only be used with multipart encoding.");
+                }
+                Part part = (Part) annotation;
+                gotPart = true;
+
+                String partName = part.value();
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (partName.isEmpty()) {
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (!MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.iterable();
+                    }
+                    else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = rawParameterType.getComponentType();
+                        if (!MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p,
+                                    "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                        }
+                        return ParameterHandler.RawPart.INSTANCE.array();
+                    }
+                    else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        return ParameterHandler.RawPart.INSTANCE;
+                    }
+                    else {
+                        throw parameterError(p,
+                                "@Part annotation must supply a name or use MultipartBody.Part parameter type.");
+                    }
+                }
+                else {
+                    Headers headers =
+                            Headers.of("Content-Disposition", "form-data; name=\"" + partName + "\"",
+                                    "Content-Transfer-Encoding", part.encoding());
+
+                    if (Iterable.class.isAssignableFrom(rawParameterType)) {
+                        if (!(type instanceof ParameterizedType)) {
+                            throw parameterError(p, rawParameterType.getSimpleName()
+                                    + " must include generic type (e.g., "
+                                    + rawParameterType.getSimpleName()
+                                    + "<String>)");
+                        }
+                        ParameterizedType parameterizedType = (ParameterizedType) type;
+                        Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+                        if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(iterableType))) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).iterable();
+                    }
+                    else if (rawParameterType.isArray()) {
+                        Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+                        if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
+                            throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                    + "include a part name in the annotation.");
+                        }
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter).array();
+                    }
+                    else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
+                        throw parameterError(p, "@Part parameters using the MultipartBody.Part must not "
+                                + "include a part name in the annotation.");
+                    }
+                    else {
+                        Converter<?, RequestBody> converter =
+                                retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                        return new ParameterHandler.Part<>(headers, converter);
+                    }
+                }
 
-        PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
+            }
+            else if (annotation instanceof PartMap) {
+                if (!isMultipart) {
+                    throw parameterError(p, "@PartMap parameters can only be used with multipart encoding.");
+                }
+                gotPart = true;
+                Class<?> rawParameterType = Utils.getRawType(type);
+                if (!Map.class.isAssignableFrom(rawParameterType)) {
+                    throw parameterError(p, "@PartMap parameter type must be Map.");
+                }
+                Type mapType = Utils.getSupertype(type, rawParameterType, Map.class);
+                if (!(mapType instanceof ParameterizedType)) {
+                    throw parameterError(p, "Map must include generic types (e.g., Map<String, String>)");
+                }
+                ParameterizedType parameterizedType = (ParameterizedType) mapType;
+
+                Type keyType = Utils.getParameterUpperBound(0, parameterizedType);
+                if (String.class != keyType) {
+                    throw parameterError(p, "@PartMap keys must be of type String: " + keyType);
+                }
+
+                Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
+                if (MultipartBody.Part.class.isAssignableFrom(Utils.getRawType(valueType))) {
+                    throw parameterError(p, "@PartMap values cannot be MultipartBody.Part. "
+                            + "Use @Part List<Part> or a different value type instead.");
+                }
+
+                Converter<?, RequestBody> valueConverter =
+                        retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
+
+                PartMap partMap = (PartMap) annotation;
+                return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
-      } else if (annotation instanceof Body) {
-        if (isFormEncoded || isMultipart) {
-          throw parameterError(p,
-              "@Body parameters cannot be used with form or multi-part encoding.");
-        }
-        if (gotBody) {
-          throw parameterError(p, "Multiple @Body method annotations found.");
+            }
+            else if (annotation instanceof Body) {
+                if (isFormEncoded || isMultipart) {
+                    throw parameterError(p,
+                            "@Body parameters cannot be used with form or multi-part encoding.");
+                }
+                if (gotBody) {
+                    throw parameterError(p, "Multiple @Body method annotations found.");
+                }
+
+                Converter<?, RequestBody> converter;
+                try {
+                    converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
+                } catch (RuntimeException e) {
+                    // Wide exception range because factories are user code.
+                    throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+                }
+                gotBody = true;
+                return new ParameterHandler.Body<>(converter);
+            }
+
+            return null; // Not a Retrofit annotation.
         }
 
-        Converter<?, RequestBody> converter;
-        try {
-          converter = retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-        } catch (RuntimeException e) {
-          // Wide exception range because factories are user code.
-          throw parameterError(e, p, "Unable to create @Body converter for %s", type);
+        private void validatePathName(int p, String name) {
+            if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+                throw parameterError(p, "@Path parameter name must match %s. Found: %s",
+                        PARAM_URL_REGEX.pattern(), name);
+            }
+            // Verify URL replacement name is actually present in the URL path.
+            if (!relativeUrlParamNames.contains(name)) {
+                throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+            }
         }
-        gotBody = true;
-        return new ParameterHandler.Body<>(converter);
-      }
 
-      return null; // Not a Retrofit annotation.
-    }
+        private Converter<ResponseBody, T> createResponseConverter() {
+            Annotation[] annotations = method.getAnnotations();
+            try {
+                return retrofit.responseBodyConverter(responseType, annotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+                throw methodError(e, "Unable to create converter for %s", responseType);
+            }
+        }
 
-    private void validatePathName(int p, String name) {
-      if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-        throw parameterError(p, "@Path parameter name must match %s. Found: %s",
-            PARAM_URL_REGEX.pattern(), name);
-      }
-      // Verify URL replacement name is actually present in the URL path.
-      if (!relativeUrlParamNames.contains(name)) {
-        throw parameterError(p, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
-      }
-    }
+        private RuntimeException methodError(String message, Object... args) {
+            return methodError(null, message, args);
+        }
 
-    private Converter<ResponseBody, T> createResponseConverter() {
-      Annotation[] annotations = method.getAnnotations();
-      try {
-        return retrofit.responseBodyConverter(responseType, annotations);
-      } catch (RuntimeException e) { // Wide exception range because factories are user code.
-        throw methodError(e, "Unable to create converter for %s", responseType);
-      }
-    }
+        private RuntimeException methodError(Throwable cause, String message, Object... args) {
+            message = String.format(message, args);
+            return new IllegalArgumentException(message
+                    + "\n    for method "
+                    + method.getDeclaringClass().getSimpleName()
+                    + "."
+                    + method.getName(), cause);
+        }
 
-    private RuntimeException methodError(String message, Object... args) {
-      return methodError(null, message, args);
-    }
+        private RuntimeException parameterError(
+                Throwable cause, int p, String message, Object... args) {
+            return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+        }
 
-    private RuntimeException methodError(Throwable cause, String message, Object... args) {
-      message = String.format(message, args);
-      return new IllegalArgumentException(message
-          + "\n    for method "
-          + method.getDeclaringClass().getSimpleName()
-          + "."
-          + method.getName(), cause);
+        private RuntimeException parameterError(int p, String message, Object... args) {
+            return methodError(message + " (parameter #" + (p + 1) + ")", args);
+        }
     }
 
-    private RuntimeException parameterError(
-        Throwable cause, int p, String message, Object... args) {
-      return methodError(cause, message + " (parameter #" + (p + 1) + ")", args);
+    /**
+     * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+     * in the URI, it will only show up once in the set.
+     */
+    static Set<String> parsePathParameters(String path) {
+        Matcher m = PARAM_URL_REGEX.matcher(path);
+        Set<String> patterns = new LinkedHashSet<>();
+        while (m.find()) {
+            patterns.add(m.group(1));
+        }
+        return patterns;
     }
 
-    private RuntimeException parameterError(int p, String message, Object... args) {
-      return methodError(message + " (parameter #" + (p + 1) + ")", args);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<>();
-    while (m.find()) {
-      patterns.add(m.group(1));
+    static Class<?> boxIfPrimitive(Class<?> type) {
+        if (boolean.class == type) return Boolean.class;
+        if (byte.class == type) return Byte.class;
+        if (char.class == type) return Character.class;
+        if (double.class == type) return Double.class;
+        if (float.class == type) return Float.class;
+        if (int.class == type) return Integer.class;
+        if (long.class == type) return Long.class;
+        if (short.class == type) return Short.class;
+        return type;
     }
-    return patterns;
-  }
-
-  static Class<?> boxIfPrimitive(Class<?> type) {
-    if (boolean.class == type) return Boolean.class;
-    if (byte.class == type) return Byte.class;
-    if (char.class == type) return Character.class;
-    if (double.class == type) return Double.class;
-    if (float.class == type) return Float.class;
-    if (int.class == type) return Integer.class;
-    if (long.class == type) return Long.class;
-    if (short.class == type) return Short.class;
-    return type;
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/Utils.java b/retrofit/src/main/java/retrofit2/Utils.java
index 09ab09064..eede0cee8 100644
--- a/retrofit/src/main/java/retrofit2/Utils.java
+++ b/retrofit/src/main/java/retrofit2/Utils.java
@@ -26,471 +26,502 @@
 import java.lang.reflect.WildcardType;
 import java.util.Arrays;
 import java.util.NoSuchElementException;
+
 import okhttp3.ResponseBody;
 import okio.Buffer;
 
 final class Utils {
-  static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
+    static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
-  private Utils() {
-    // No instances.
-  }
+    private Utils() {
+        // No instances.
+    }
 
-  static Class<?> getRawType(Type type) {
-    if (type == null) throw new NullPointerException("type == null");
+    static Class<?> getRawType(Type type) {
+        if (type == null) throw new NullPointerException("type == null");
 
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-    }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-    }
-    if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-    }
-    if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-    }
-    if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-    }
+        if (type instanceof Class<?>) {
+            // Type is a normal class.
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+
+            // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+            // suspects some pathological case related to nested classes exists.
+            Type rawType = parameterizedType.getRawType();
+            if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+            return (Class<?>) rawType;
+        }
+        if (type instanceof GenericArrayType) {
+            Type componentType = ((GenericArrayType) type).getGenericComponentType();
+            return Array.newInstance(getRawType(componentType), 0).getClass();
+        }
+        if (type instanceof TypeVariable) {
+            // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+            // type that's more general than necessary is okay.
+            return Object.class;
+        }
+        if (type instanceof WildcardType) {
+            return getRawType(((WildcardType) type).getUpperBounds()[0]);
+        }
 
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + type.getClass().getName());
     }
 
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
+    /** Returns true if {@code a} and {@code b} are equal. */
+    static boolean equals(Type a, Type b) {
+        if (a == b) {
+            return true; // Also handles (a == null && b == null).
 
-    // We can't resolve this further.
-    return toResolve;
-  }
+        }
+        else if (a instanceof Class) {
+            return a.equals(b); // Class already specifies equals().
 
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
         }
+        else if (a instanceof ParameterizedType) {
+            if (!(b instanceof ParameterizedType)) return false;
+            ParameterizedType pa = (ParameterizedType) a;
+            ParameterizedType pb = (ParameterizedType) b;
+            return equal(pa.getOwnerType(), pb.getOwnerType())
+                    && pa.getRawType().equals(pb.getRawType())
+                    && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
 
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
+        }
+        else if (a instanceof GenericArrayType) {
+            if (!(b instanceof GenericArrayType)) return false;
+            GenericArrayType ga = (GenericArrayType) a;
+            GenericArrayType gb = (GenericArrayType) b;
+            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
 
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
+        }
+        else if (a instanceof WildcardType) {
+            if (!(b instanceof WildcardType)) return false;
+            WildcardType wa = (WildcardType) a;
+            WildcardType wb = (WildcardType) b;
+            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+                    && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
 
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
         }
-        return original;
+        else if (a instanceof TypeVariable) {
+            if (!(b instanceof TypeVariable)) return false;
+            TypeVariable<?> va = (TypeVariable<?>) a;
+            TypeVariable<?> vb = (TypeVariable<?>) b;
+            return va.getGenericDeclaration() == vb.getGenericDeclaration()
+                    && va.getName().equals(vb.getName());
 
-      } else {
-        return toResolve;
-      }
+        }
+        else {
+            return false; // This isn't a type we support!
+        }
     }
-  }
 
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
+    /**
+     * Returns the generic supertype for {@code supertype}. For example, given a class {@code
+     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
+     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
+     */
+    static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
+        if (toResolve == rawType) return context;
+
+        // We skip searching through interfaces if unknown is an interface.
+        if (toResolve.isInterface()) {
+            Class<?>[] interfaces = rawType.getInterfaces();
+            for (int i = 0, length = interfaces.length; i < length; i++) {
+                if (interfaces[i] == toResolve) {
+                    return rawType.getGenericInterfaces()[i];
+                }
+                else if (toResolve.isAssignableFrom(interfaces[i])) {
+                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
+                }
+            }
+        }
 
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
+        // Check our supertypes.
+        if (!rawType.isInterface()) {
+            while (rawType != Object.class) {
+                Class<?> rawSupertype = rawType.getSuperclass();
+                if (rawSupertype == toResolve) {
+                    return rawType.getGenericSuperclass();
+                }
+                else if (toResolve.isAssignableFrom(rawSupertype)) {
+                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
+                }
+                rawType = rawSupertype;
+            }
+        }
 
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+        // We can't resolve this further.
+        return toResolve;
     }
 
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
+    private static int indexOf(Object[] array, Object toFind) {
+        for (int i = 0; i < array.length; i++) {
+            if (toFind.equals(array[i])) return i;
+        }
+        throw new NoSuchElementException();
     }
-  }
 
-  static <T> T checkNotNull(T object, String message) {
-    if (object == null) {
-      throw new NullPointerException(message);
+    private static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
     }
-    return object;
-  }
-
-  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
-  static boolean isAnnotationPresent(Annotation[] annotations,
-      Class<? extends Annotation> cls) {
-    for (Annotation annotation : annotations) {
-      if (cls.isInstance(annotation)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static ResponseBody buffer(final ResponseBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.source().readAll(buffer);
-    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
-  }
-
-  static <T> void validateServiceInterface(Class<T> service) {
-    if (!service.isInterface()) {
-      throw new IllegalArgumentException("API declarations must be interfaces.");
-    }
-    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
-    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
-    // the recommended pattern.
-    if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
-    }
-  }
 
-  static Type getParameterUpperBound(int index, ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    if (index < 0 || index >= types.length) {
-      throw new IllegalArgumentException(
-          "Index " + index + " not in range [0," + types.length + ") for " + type);
-    }
-    Type paramType = types[index];
-    if (paramType instanceof WildcardType) {
-      return ((WildcardType) paramType).getUpperBounds()[0];
+    static int hashCodeOrZero(Object o) {
+        return o != null ? o.hashCode() : 0;
     }
-    return paramType;
-  }
 
-  static boolean hasUnresolvableType(Type type) {
-    if (type instanceof Class<?>) {
-      return false;
+    static String typeToString(Type type) {
+        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
     }
-    if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
-        if (hasUnresolvableType(typeArgument)) {
-          return true;
-        }
-      }
-      return false;
+
+    /**
+     * Returns the generic form of {@code supertype}. For example, if this is {@code
+     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
+     * Iterable.class}.
+     *
+     * @param supertype a superclass of, or interface implemented by, this.
+     */
+    static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
+        if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
+        return resolve(context, contextRawType,
+                getGenericSupertype(context, contextRawType, supertype));
     }
-    if (type instanceof GenericArrayType) {
-      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+
+    static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+        // This implementation is made a little more complicated in an attempt to avoid object-creation.
+        while (true) {
+            if (toResolve instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
+                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
+                if (toResolve == typeVariable) {
+                    return toResolve;
+                }
+
+            }
+            else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
+                Class<?> original = (Class<?>) toResolve;
+                Type componentType = original.getComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            }
+            else if (toResolve instanceof GenericArrayType) {
+                GenericArrayType original = (GenericArrayType) toResolve;
+                Type componentType = original.getGenericComponentType();
+                Type newComponentType = resolve(context, contextRawType, componentType);
+                return componentType == newComponentType ? original : new GenericArrayTypeImpl(
+                        newComponentType);
+
+            }
+            else if (toResolve instanceof ParameterizedType) {
+                ParameterizedType original = (ParameterizedType) toResolve;
+                Type ownerType = original.getOwnerType();
+                Type newOwnerType = resolve(context, contextRawType, ownerType);
+                boolean changed = newOwnerType != ownerType;
+
+                Type[] args = original.getActualTypeArguments();
+                for (int t = 0, length = args.length; t < length; t++) {
+                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
+                    if (resolvedTypeArgument != args[t]) {
+                        if (!changed) {
+                            args = args.clone();
+                            changed = true;
+                        }
+                        args[t] = resolvedTypeArgument;
+                    }
+                }
+
+                return changed
+                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
+                        : original;
+
+            }
+            else if (toResolve instanceof WildcardType) {
+                WildcardType original = (WildcardType) toResolve;
+                Type[] originalLowerBound = original.getLowerBounds();
+                Type[] originalUpperBound = original.getUpperBounds();
+
+                if (originalLowerBound.length == 1) {
+                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
+                    if (lowerBound != originalLowerBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{Object.class}, new Type[]{lowerBound});
+                    }
+                }
+                else if (originalUpperBound.length == 1) {
+                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
+                    if (upperBound != originalUpperBound[0]) {
+                        return new WildcardTypeImpl(new Type[]{upperBound}, EMPTY_TYPE_ARRAY);
+                    }
+                }
+                return original;
+
+            }
+            else {
+                return toResolve;
+            }
+        }
     }
-    if (type instanceof TypeVariable) {
-      return true;
+
+    private static Type resolveTypeVariable(
+            Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
+        Class<?> declaredByRaw = declaringClassOf(unknown);
+
+        // We can't reduce this further.
+        if (declaredByRaw == null) return unknown;
+
+        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
+        if (declaredBy instanceof ParameterizedType) {
+            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
+            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
+        }
+
+        return unknown;
     }
-    if (type instanceof WildcardType) {
-      return true;
+
+    /**
+     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
+     * a class.
+     */
+    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
+        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
+        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
     }
-    String className = type == null ? "null" : type.getClass().getName();
-    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-        + "GenericArrayType, but <" + type + "> is of type " + className);
-  }
-
-  static Type getCallResponseType(Type returnType) {
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalArgumentException(
-          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+
+    static void checkNotPrimitive(Type type) {
+        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+            throw new IllegalArgumentException();
+        }
     }
-    return getParameterUpperBound(0, (ParameterizedType) returnType);
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
+
+    static <T> T checkNotNull(T object, String message) {
+        if (object == null) {
+            throw new NullPointerException(message);
+        }
+        return object;
     }
 
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
+    /** Returns true if {@code annotations} contains an instance of {@code cls}. */
+    static boolean isAnnotationPresent(Annotation[] annotations,
+            Class<? extends Annotation> cls) {
+        for (Annotation annotation : annotations) {
+            if (cls.isInstance(annotation)) {
+                return true;
+            }
+        }
+        return false;
     }
 
-    @Override public Type getRawType() {
-      return rawType;
+    static ResponseBody buffer(final ResponseBody body) throws IOException {
+        Buffer buffer = new Buffer();
+        body.source().readAll(buffer);
+        return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
     }
 
-    @Override public Type getOwnerType() {
-      return ownerType;
+    static <T> void validateServiceInterface(Class<T> service) {
+        if (!service.isInterface()) {
+            throw new IllegalArgumentException("API declarations must be interfaces.");
+        }
+        // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
+        // Android (http://b.android.com/58753) but it forces composition of API declarations which is
+        // the recommended pattern.
+        if (service.getInterfaces().length > 0) {
+            throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+        }
     }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+    static Type getParameterUpperBound(int index, ParameterizedType type) {
+        Type[] types = type.getActualTypeArguments();
+        if (index < 0 || index >= types.length) {
+            throw new IllegalArgumentException(
+                    "Index " + index + " not in range [0," + types.length + ") for " + type);
+        }
+        Type paramType = types[index];
+        if (paramType instanceof WildcardType) {
+            return ((WildcardType) paramType).getUpperBounds()[0];
+        }
+        return paramType;
     }
 
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+    static boolean hasUnresolvableType(Type type) {
+        if (type instanceof Class<?>) {
+            return false;
+        }
+        if (type instanceof ParameterizedType) {
+            ParameterizedType parameterizedType = (ParameterizedType) type;
+            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+                if (hasUnresolvableType(typeArgument)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        if (type instanceof GenericArrayType) {
+            return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+        }
+        if (type instanceof TypeVariable) {
+            return true;
+        }
+        if (type instanceof WildcardType) {
+            return true;
+        }
+        String className = type == null ? "null" : type.getClass().getName();
+        throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+                + "GenericArrayType, but <" + type + "> is of type " + className);
     }
 
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
+    static Type getCallResponseType(Type returnType) {
+        if (!(returnType instanceof ParameterizedType)) {
+            throw new IllegalArgumentException(
+                    "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+        return getParameterUpperBound(0, (ParameterizedType) returnType);
     }
-  }
 
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
+    private static final class ParameterizedTypeImpl implements ParameterizedType {
+        private final Type ownerType;
+        private final Type rawType;
+        private final Type[] typeArguments;
 
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
+        public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
+            // Require an owner type if the raw type needs it.
+            if (rawType instanceof Class<?>
+                    && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+                throw new IllegalArgumentException();
+            }
 
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
+            this.ownerType = ownerType;
+            this.rawType = rawType;
+            this.typeArguments = typeArguments.clone();
 
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Utils.equals(this, (GenericArrayType) o);
-    }
+            for (Type typeArgument : this.typeArguments) {
+                if (typeArgument == null) throw new NullPointerException();
+                checkNotPrimitive(typeArgument);
+            }
+        }
 
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
+        @Override
+        public Type[] getActualTypeArguments() {
+            return typeArguments.clone();
+        }
 
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
+        @Override
+        public Type getRawType() {
+            return rawType;
+        }
 
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
+        @Override
+        public Type getOwnerType() {
+            return ownerType;
+        }
 
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof ParameterizedType && Utils.equals(this, (ParameterizedType) other);
+        }
 
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+            result.append(typeToString(rawType));
+            if (typeArguments.length == 0) return result.toString();
+            result.append("<").append(typeToString(typeArguments[0]));
+            for (int i = 1; i < typeArguments.length; i++) {
+                result.append(", ").append(typeToString(typeArguments[i]));
+            }
+            return result.append(">").toString();
+        }
     }
 
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+    private static final class GenericArrayTypeImpl implements GenericArrayType {
+        private final Type componentType;
+
+        public GenericArrayTypeImpl(Type componentType) {
+            this.componentType = componentType;
+        }
+
+        @Override
+        public Type getGenericComponentType() {
+            return componentType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            return o instanceof GenericArrayType
+                    && Utils.equals(this, (GenericArrayType) o);
+        }
+
+        @Override
+        public int hashCode() {
+            return componentType.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return typeToString(componentType) + "[]";
+        }
     }
 
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
+    /**
+     * The WildcardType interface supports multiple upper bounds and multiple
+     * lower bounds. We only support what the Java 6 language needs - at most one
+     * bound. If a lower bound is set, the upper bound must be Object.class.
+     */
+    private static final class WildcardTypeImpl implements WildcardType {
+        private final Type upperBound;
+        private final Type lowerBound;
+
+        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+            if (lowerBounds.length > 1) throw new IllegalArgumentException();
+            if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+            if (lowerBounds.length == 1) {
+                if (lowerBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(lowerBounds[0]);
+                if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+                this.lowerBound = lowerBounds[0];
+                this.upperBound = Object.class;
+            }
+            else {
+                if (upperBounds[0] == null) throw new NullPointerException();
+                checkNotPrimitive(upperBounds[0]);
+                this.lowerBound = null;
+                this.upperBound = upperBounds[0];
+            }
+        }
+
+        @Override
+        public Type[] getUpperBounds() {
+            return new Type[]{upperBound};
+        }
+
+        @Override
+        public Type[] getLowerBounds() {
+            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return other instanceof WildcardType && Utils.equals(this, (WildcardType) other);
+        }
+
+        @Override
+        public int hashCode() {
+            // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
+        }
+
+        @Override
+        public String toString() {
+            if (lowerBound != null) return "? super " + typeToString(lowerBound);
+            if (upperBound == Object.class) return "?";
+            return "? extends " + typeToString(upperBound);
+        }
     }
-  }
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Body.java b/retrofit/src/main/java/retrofit2/http/Body.java
index 98d1d8684..3ac9822e0 100644
--- a/retrofit/src/main/java/retrofit2/http/Body.java
+++ b/retrofit/src/main/java/retrofit2/http/Body.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
diff --git a/retrofit/src/main/java/retrofit2/http/DELETE.java b/retrofit/src/main/java/retrofit2/http/DELETE.java
index 4a2b3e519..3c9094b3a 100644
--- a/retrofit/src/main/java/retrofit2/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit2/http/DELETE.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Field.java b/retrofit/src/main/java/retrofit2/http/Field.java
index 4dbd1bf11..77df73b27 100644
--- a/retrofit/src/main/java/retrofit2/http/Field.java
+++ b/retrofit/src/main/java/retrofit2/http/Field.java
@@ -56,8 +56,8 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Field {
-  String value();
+    String value();
 
-  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
-  boolean encoded() default false;
+    /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/FieldMap.java b/retrofit/src/main/java/retrofit2/http/FieldMap.java
index a7eb1ee86..89eb475cb 100644
--- a/retrofit/src/main/java/retrofit2/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit2/http/FieldMap.java
@@ -43,6 +43,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether the names and values are already URL encoded. */
-  boolean encoded() default false;
+    /** Specifies whether the names and values are already URL encoded. */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/GET.java b/retrofit/src/main/java/retrofit2/http/GET.java
index deca1820d..7f8f55934 100644
--- a/retrofit/src/main/java/retrofit2/http/GET.java
+++ b/retrofit/src/main/java/retrofit2/http/GET.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HEAD.java b/retrofit/src/main/java/retrofit2/http/HEAD.java
index 077787d4f..1f225bb39 100644
--- a/retrofit/src/main/java/retrofit2/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit2/http/HEAD.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HTTP.java b/retrofit/src/main/java/retrofit2/http/HTTP.java
index 101eecf3b..bd8a74074 100644
--- a/retrofit/src/main/java/retrofit2/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit2/http/HTTP.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -43,14 +44,16 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HTTP {
-  String method();
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String path() default "";
-  boolean hasBody() default false;
+    String method();
+
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String path() default "";
+
+    boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index b8f7a70ea..958712b6e 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -41,5 +41,5 @@
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Header {
-  String value();
+    String value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index b360f3ec3..b1d5ca81e 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -46,5 +46,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface Headers {
-  String[] value();
+    String[] value();
 }
diff --git a/retrofit/src/main/java/retrofit2/http/OPTIONS.java b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
index 17dc085e3..922b1206a 100644
--- a/retrofit/src/main/java/retrofit2/http/OPTIONS.java
+++ b/retrofit/src/main/java/retrofit2/http/OPTIONS.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface OPTIONS {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PATCH.java b/retrofit/src/main/java/retrofit2/http/PATCH.java
index 035276982..51676347f 100644
--- a/retrofit/src/main/java/retrofit2/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit2/http/PATCH.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/POST.java b/retrofit/src/main/java/retrofit2/http/POST.java
index 34352cd34..f44a96222 100644
--- a/retrofit/src/main/java/retrofit2/http/POST.java
+++ b/retrofit/src/main/java/retrofit2/http/POST.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PUT.java b/retrofit/src/main/java/retrofit2/http/PUT.java
index 0d4437f86..be3c5e057 100644
--- a/retrofit/src/main/java/retrofit2/http/PUT.java
+++ b/retrofit/src/main/java/retrofit2/http/PUT.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -28,12 +29,12 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
-  /**
-   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
-   * parameter of the method is annotated with {@link Url @Url}.
-   * <p>
-   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
-   * this is resolved against a base URL to create the full endpoint URL.
-   */
-  String value() default "";
+    /**
+     * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
+     * parameter of the method is annotated with {@link Url @Url}.
+     * <p>
+     * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
+     * this is resolved against a base URL to create the full endpoint URL.
+     */
+    String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Part.java b/retrofit/src/main/java/retrofit2/http/Part.java
index f320c088f..8ab764e1f 100644
--- a/retrofit/src/main/java/retrofit2/http/Part.java
+++ b/retrofit/src/main/java/retrofit2/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -54,11 +55,12 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Part {
-  /**
-   * The name of the part. Required for all parameter types except
-   * {@link okhttp3.MultipartBody.Part}.
-   */
-  String value() default "";
-  /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default "binary";
+    /**
+     * The name of the part. Required for all parameter types except
+     * {@link okhttp3.MultipartBody.Part}.
+     */
+    String value() default "";
+
+    /** The {@code Content-Transfer-Encoding} of this part. */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/PartMap.java b/retrofit/src/main/java/retrofit2/http/PartMap.java
index 79eae2147..cd01bf127 100644
--- a/retrofit/src/main/java/retrofit2/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit2/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import retrofit2.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
@@ -51,6 +52,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface PartMap {
-  /** The {@code Content-Transfer-Encoding} of the parts. */
-  String encoding() default "binary";
+    /** The {@code Content-Transfer-Encoding} of the parts. */
+    String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Path.java b/retrofit/src/main/java/retrofit2/http/Path.java
index 4d8c6f054..eb31d1560 100644
--- a/retrofit/src/main/java/retrofit2/http/Path.java
+++ b/retrofit/src/main/java/retrofit2/http/Path.java
@@ -50,10 +50,10 @@
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Path {
-  String value();
+    String value();
 
-  /**
-   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 01d294f3a..2d5ea6f8a 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -65,11 +65,11 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface Query {
-  /** The query parameter name. */
-  String value();
+    /** The query parameter name. */
+    String value();
 
-  /**
-   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
-   */
-  boolean encoded() default false;
+    /**
+     * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+     */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 27e6ae836..6d8b28448 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -52,6 +52,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
-  /** Specifies whether parameter names and values are already URL encoded. */
-  boolean encoded() default false;
+    /** Specifies whether parameter names and values are already URL encoded. */
+    boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/Url.java b/retrofit/src/main/java/retrofit2/http/Url.java
index 31187ca3d..f2e34c900 100644
--- a/retrofit/src/main/java/retrofit2/http/Url.java
+++ b/retrofit/src/main/java/retrofit2/http/Url.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+
 import okhttp3.HttpUrl;
 import retrofit2.Retrofit;
 
diff --git a/retrofit/src/test/java/retrofit2/CallAdapterTest.java b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
index d1ed83480..454aa32e7 100644
--- a/retrofit/src/test/java/retrofit2/CallAdapterTest.java
+++ b/retrofit/src/test/java/retrofit2/CallAdapterTest.java
@@ -16,10 +16,12 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.Map;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -28,69 +30,78 @@
 import static retrofit2.CallAdapter.Factory.getRawType;
 
 public final class CallAdapterTest {
-  @Test public void parameterizedTypeInvalidIndex() {
-    ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    try {
-      getParameterUpperBound(-1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+    @Test
+    public void parameterizedTypeInvalidIndex() {
+        ParameterizedType listOfString = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        try {
+            getParameterUpperBound(-1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index -1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
+        try {
+            getParameterUpperBound(1, listOfString);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+        }
     }
-    try {
-      getParameterUpperBound(1, listOfString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Index 1 not in range [0,1) for java.util.List<java.lang.String>");
+
+    @Test
+    public void parameterizedTypes() {
+        ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
+
+        ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
+        assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
+
+        ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType();
+        assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
     }
-  }
-
-  @Test public void parameterizedTypes() {
-    ParameterizedType one = (ParameterizedType) new TypeToken<List<String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, one)).isSameAs(String.class);
-
-    ParameterizedType two = (ParameterizedType) new TypeToken<Map<String, String>>() {}.getType();
-    assertThat(getParameterUpperBound(0, two)).isSameAs(String.class);
-    assertThat(getParameterUpperBound(1, two)).isSameAs(String.class);
-
-    ParameterizedType wild = (ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType();
-    assertThat(getParameterUpperBound(0, wild)).isSameAs(CharSequence.class);
-  }
-
-  @Test public void rawTypeThrowsOnNull() {
-    try {
-      getRawType(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("type == null");
+
+    @Test
+    public void rawTypeThrowsOnNull() {
+        try {
+            getRawType(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("type == null");
+        }
     }
-  }
 
-  @Test public void rawTypes() throws NoSuchMethodException {
-    assertThat(getRawType(String.class)).isSameAs(String.class);
+    @Test
+    public void rawTypes() throws NoSuchMethodException {
+        assertThat(getRawType(String.class)).isSameAs(String.class);
 
-    Type listOfString = new TypeToken<List<String>>() {}.getType();
-    assertThat(getRawType(listOfString)).isSameAs(List.class);
+        Type listOfString = new TypeToken<List<String>>() {
+        }.getType();
+        assertThat(getRawType(listOfString)).isSameAs(List.class);
 
-    Type stringArray = new TypeToken<String[]>() {}.getType();
-    assertThat(getRawType(stringArray)).isSameAs(String[].class);
+        Type stringArray = new TypeToken<String[]>() {
+        }.getType();
+        assertThat(getRawType(stringArray)).isSameAs(String[].class);
 
-    Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wild)).isSameAs(CharSequence.class);
+        Type wild = ((ParameterizedType) new TypeToken<List<? extends CharSequence>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wild)).isSameAs(CharSequence.class);
 
-    Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
-    }.getType()).getActualTypeArguments()[0];
-    assertThat(getRawType(wildParam)).isSameAs(List.class);
+        Type wildParam = ((ParameterizedType) new TypeToken<List<? extends List<String>>>() {
+        }.getType()).getActualTypeArguments()[0];
+        assertThat(getRawType(wildParam)).isSameAs(List.class);
 
-    Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
-    assertThat(getRawType(typeVar)).isSameAs(Object.class);
-  }
+        Type typeVar = A.class.getDeclaredMethod("method").getGenericReturnType();
+        assertThat(getRawType(typeVar)).isSameAs(Object.class);
+    }
 
-  @SuppressWarnings("unused") // Used reflectively.
-  static class A<T> {
-    T method() {
-      return null;
+    @SuppressWarnings("unused") // Used reflectively.
+    static class A<T> {
+        T method() {
+            return null;
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/CallTest.java b/retrofit/src/test/java/retrofit2/CallTest.java
index fffd43c1f..dccf0ea5d 100644
--- a/retrofit/src/test/java/retrofit2/CallTest.java
+++ b/retrofit/src/test/java/retrofit2/CallTest.java
@@ -21,6 +21,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.RequestBody;
@@ -32,8 +33,10 @@
 import okio.BufferedSource;
 import okio.ForwardingSource;
 import okio.Okio;
+
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.GET;
@@ -50,932 +53,1030 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class CallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Call<String> getString();
-    @GET("/") Call<ResponseBody> getBody();
-    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
-    @POST("/") Call<String> postString(@Body String body);
-    @POST("/{a}") Call<String> postRequestBody(@Path("a") Object a);
-  }
-
-  @Test public void http200Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http200Async() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Sync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void http404Async() throws InterruptedException, IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Response<String> response = responseRef.get();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.code()).isEqualTo(404);
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void transportProblemSync() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void transportProblemAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.getString().enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    Throwable failure = failureRef.get();
-    assertThat(failure).isInstanceOf(IOException.class);
-  }
-
-  @Test public void conversionProblemOutgoingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<?, RequestBody> requestBodyConverter(Type type,
-              Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
-              Retrofit retrofit) {
-            return new Converter<String, RequestBody>() {
-              @Override public RequestBody convert(String value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void conversionProblemIncomingSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.postString("Hi");
-    try {
-      call.execute();
-      fail();
-    } catch (UnsupportedOperationException e) {
-      assertThat(e).hasMessage("I am broken!");
-    }
-  }
-
-  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
-    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
-    OkHttpClient client = new OkHttpClient.Builder() //
-        .addInterceptor(new Interceptor() {
-          @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-            okhttp3.Response response = chain.proceed(chain.request());
-            ResponseBody body = response.body();
-            BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
-              @Override public long read(Buffer sink, long byteCount) throws IOException {
-                throw new IOException("cause");
-              }
-            });
-            body = ResponseBody.create(body.contentType(), body.contentLength(), source);
-            return response.newBuilder().body(body).build();
-          }
-        }).build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                try {
-                  return value.string();
-                } catch (IOException e) {
-                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
-                  throw new RuntimeException("wrapper", e);
-                }
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("cause");
-    }
-  }
-
-  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return new Converter<ResponseBody, String>() {
-              @Override public String convert(ResponseBody value) throws IOException {
-                throw new UnsupportedOperationException("I am broken!");
-              }
-            };
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.postString("Hi").enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
-        .hasMessage("I am broken!");
-  }
-
-  @Test public void http204SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(204);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void http205SkipsConverter() throws IOException {
-    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory() {
-          @Override
-          public Converter<ResponseBody, ?> responseBodyConverter(Type type,
-              Annotation[] annotations, Retrofit retrofit) {
-            return converter;
-          }
-        })
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.code()).isEqualTo(205);
-    assertThat(response.body()).isNull();
-    verifyNoMoreInteractions(converter);
-  }
-
-  @Test public void executeCallOnce() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-    server.enqueue(new MockResponse());
-    Call<String> call = example.getString();
-    call.execute();
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Already executed.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("1234"));
-
-    Response<ResponseBody> response = example.getBody().execute();
-    assertThat(response.body().string()).isEqualTo("1234");
-  }
-
-  @Test public void responseBodyBuffers() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call<ResponseBody> buffered = example.getBody();
-    // When buffering we will detect all socket problems before returning the Response.
-    try {
-      buffered.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void responseBodyStreams() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse()
-        .setBody("1234")
-        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
-
-    Response<ResponseBody> response = example.getStreamingBody().execute();
-
-    ResponseBody streamedBody = response.body();
-    // When streaming we only detect socket problems as the ResponseBody is read.
-    try {
-      streamedBody.string();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("unexpected end of stream");
-    }
-  }
-
-  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("Hi");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(2);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
-    try {
-      rawBody.source();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
-    }
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
-
-    Response<String> response = example.getString().execute();
-    assertThat(response.body()).isEqualTo("");
-    ResponseBody rawBody = response.raw().body();
-    assertThat(rawBody.contentLength()).isEqualTo(0);
-    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
-  }
-
-  @Test public void reportsExecutedSync() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.execute();
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void reportsExecutedAsync() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service example = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Call<String> call = example.getString();
-    assertThat(call.isExecuted()).isFalse();
-
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {}
-      @Override public void onFailure(Call<String> call, Throwable t) {}
-    });
-    assertThat(call.isExecuted()).isTrue();
-  }
-
-  @Test public void cancelBeforeExecute() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e).hasMessage("Canceled");
-    }
-  }
-
-  @Test public void cancelBeforeEnqueue() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-    Call<String> call = service.getString();
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).hasMessage("Canceled");
-  }
-
-  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-    server.enqueue(new MockResponse().setBody("Hello"));
-
-    Call<String> call = service.getString();
-    assertThat(call.execute().body()).isEqualTo("Hi");
-
-    Call<String> cloned = call.clone();
-    assertThat(cloned.execute().body()).isEqualTo("Hello");
-  }
-
-  @Test public void cancelRequest() throws InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    call.cancel();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void cancelOkHttpRequest() throws InterruptedException {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .client(client)
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    Call<String> call = service.getString();
-
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-
-    // Cancel the underlying HTTP Call. Should be reflected accurately back in the Retrofit Call.
-    client.dispatcher().cancelAll();
-    assertThat(call.isCanceled()).isTrue();
-
-    assertTrue(latch.await(10, SECONDS));
-    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
-  }
-
-  @Test public void requestBeforeExecuteCreates() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteReturnsCachedValue() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.execute();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface Service {
+        @GET("/")
+        Call<String> getString();
+
+        @GET("/")
+        Call<ResponseBody> getBody();
+
+        @GET("/")
+        @Streaming
+        Call<ResponseBody> getStreamingBody();
+
+        @POST("/")
+        Call<String> postString(@Body String body);
+
+        @POST("/{a}")
+        Call<String> postRequestBody(@Path("a") Object a);
+    }
+
+    @Test
+    public void http200Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http200Async() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Sync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void http404Async() throws InterruptedException, IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+        final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                responseRef.set(response);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Response<String> response = responseRef.get();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.code()).isEqualTo(404);
+        assertThat(response.errorBody().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void transportProblemSync() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException ignored) {
+        }
+    }
+
+    @Test
+    public void transportProblemAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.getString().enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        Throwable failure = failureRef.get();
+        assertThat(failure).isInstanceOf(IOException.class);
+    }
+
+    @Test
+    public void conversionProblemOutgoingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                            Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                            Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemOutgoingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<?, RequestBody> requestBodyConverter(Type type,
+                            Annotation[] parameterAnnotations, Annotation[] methodAnnotations,
+                            Retrofit retrofit) {
+                        return new Converter<String, RequestBody>() {
+                            @Override
+                            public RequestBody convert(String value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                                    .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void conversionProblemIncomingSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.postString("Hi");
+        try {
+            call.execute();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertThat(e).hasMessage("I am broken!");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+        // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+        OkHttpClient client = new OkHttpClient.Builder() //
+                                                         .addInterceptor(new Interceptor() {
+                                                             @Override
+                                                             public okhttp3.Response intercept(Chain chain)
+                                                                     throws IOException {
+                                                                 okhttp3.Response response =
+                                                                         chain.proceed(chain.request());
+                                                                 ResponseBody body = response.body();
+                                                                 BufferedSource source = Okio.buffer(
+                                                                         new ForwardingSource(body.source()) {
+                                                                             @Override
+                                                                             public long read(Buffer sink,
+                                                                                     long byteCount)
+                                                                                     throws IOException {
+                                                                                 throw new IOException("cause");
+                                                                             }
+                                                                         });
+                                                                 body = ResponseBody.create(body.contentType(),
+                                                                         body.contentLength(), source);
+                                                                 return response.newBuilder().body(body).build();
+                                                             }
+                                                         }).build();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .client(client)
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                try {
+                                    return value.string();
+                                } catch (IOException e) {
+                                    // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                                    throw new RuntimeException("wrapper", e);
+                                }
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("cause");
+        }
+    }
+
+    @Test
+    public void conversionProblemIncomingAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                            Annotation[] annotations, Retrofit retrofit) {
+                        return new Converter<ResponseBody, String>() {
+                            @Override
+                            public String convert(ResponseBody value) throws IOException {
+                                throw new UnsupportedOperationException("I am broken!");
+                            }
+                        };
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        example.postString("Hi").enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+                                    .hasMessage("I am broken!");
+    }
+
+    @Test
+    public void http204SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(204);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void http205SkipsConverter() throws IOException {
+        final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+            @Override
+            public String convert(ResponseBody value) throws IOException {
+                return value.string();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory() {
+                    @Override
+                    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
+                            Annotation[] annotations, Retrofit retrofit) {
+                        return converter;
+                    }
+                })
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.code()).isEqualTo(205);
+        assertThat(response.body()).isNull();
+        verifyNoMoreInteractions(converter);
+    }
+
+    @Test
+    public void executeCallOnce() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+        server.enqueue(new MockResponse());
+        Call<String> call = example.getString();
+        call.execute();
+        try {
+            call.execute();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Already executed.");
+        }
+    }
+
+    @Test
+    public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void responseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("1234"));
+
+        Response<ResponseBody> response = example.getBody().execute();
+        assertThat(response.body().string()).isEqualTo("1234");
+    }
+
+    @Test
+    public void responseBodyBuffers() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Call<ResponseBody> buffered = example.getBody();
+        // When buffering we will detect all socket problems before returning the Response.
+        try {
+            buffered.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void responseBodyStreams() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse()
+                .setBody("1234")
+                .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+        Response<ResponseBody> response = example.getStreamingBody().execute();
+
+        ResponseBody streamedBody = response.body();
+        // When streaming we only detect socket problems as the ResponseBody is read.
+        try {
+            streamedBody.string();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("unexpected end of stream");
+        }
+    }
+
+    @Test
+    public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("Hi");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(2);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+        try {
+            rawBody.source();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+        }
+    }
+
+    @Test
+    public void emptyResponse() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+        Response<String> response = example.getString().execute();
+        assertThat(response.body()).isEqualTo("");
+        ResponseBody rawBody = response.raw().body();
+        assertThat(rawBody.contentLength()).isEqualTo(0);
+        assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+    }
+
+    @Test
+    public void reportsExecutedSync() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.execute();
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void reportsExecutedAsync() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service example = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Call<String> call = example.getString();
+        assertThat(call.isExecuted()).isFalse();
+
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertThat(call.isExecuted()).isTrue();
+    }
+
+    @Test
+    public void cancelBeforeExecute() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        try {
+            call.execute();
+            fail();
+        } catch (IOException e) {
+            assertThat(e).hasMessage("Canceled");
+        }
+    }
+
+    @Test
+    public void cancelBeforeEnqueue() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+        Call<String> call = service.getString();
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).hasMessage("Canceled");
+    }
+
+    @Test
+    public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+        server.enqueue(new MockResponse().setBody("Hello"));
+
+        Call<String> call = service.getString();
+        assertThat(call.execute().body()).isEqualTo("Hi");
+
+        Call<String> cloned = call.clone();
+        assertThat(cloned.execute().body()).isEqualTo("Hello");
+    }
+
+    @Test
+    public void cancelRequest() throws InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+        Call<String> call = service.getString();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        call.cancel();
+        assertThat(call.isCanceled()).isTrue();
+
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+    }
+
+    @Test
+    public void cancelOkHttpRequest() throws InterruptedException {
+        OkHttpClient client = new OkHttpClient();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .client(client)
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+        Call<String> call = service.getString();
+
+        final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                failureRef.set(t);
+                latch.countDown();
+            }
+        });
+
+        // Cancel the underlying HTTP Call. Should be reflected accurately back in the Retrofit Call.
+        client.dispatcher().cancelAll();
+        assertThat(call.isCanceled()).isTrue();
+
+        assertTrue(latch.await(10, SECONDS));
+        assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+    }
+
+    @Test
+    public void requestBeforeExecuteCreates() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestThrowingBeforeEnqueueFailsEnqueue()
-      throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+
+        call.execute();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-  }
-
-  @Test public void requestAfterEnqueueReturnsCachedValue() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        return "Hello";
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
+    }
+
+    @Test
+    public void requestThrowingBeforeExecuteFailsExecute() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    call.request();
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
-
-  @Test public void requestAfterEnqueueFailingThrows() throws IOException,
-      InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    server.enqueue(new MockResponse());
-
-    final AtomicInteger writeCount = new AtomicInteger();
-    Object a = new Object() {
-      @Override public String toString() {
-        writeCount.incrementAndGet();
-        throw new RuntimeException("Broken!");
-      }
-    };
-    Call<String> call = service.postRequestBody(a);
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<String>() {
-      @Override public void onResponse(Call<String> call, Response<String> response) {
-      }
-
-      @Override public void onFailure(Call<String> call, Throwable t) {
-        assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterExecuteReturnsCachedValue() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.execute();
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterExecuteThrowingAlsoThrows() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.execute();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestBeforeEnqueueCreates() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        call.request();
         assertThat(writeCount.get()).isEqualTo(1);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(10, SECONDS));
-
-    try {
-      call.request();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Broken!");
-    }
-    assertThat(writeCount.get()).isEqualTo(1);
-  }
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestThrowingBeforeEnqueueFailsEnqueue()
+            throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+    }
+
+    @Test
+    public void requestAfterEnqueueReturnsCachedValue() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                return "Hello";
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        call.request();
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
+
+    @Test
+    public void requestAfterEnqueueFailingThrows() throws IOException,
+            InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        server.enqueue(new MockResponse());
+
+        final AtomicInteger writeCount = new AtomicInteger();
+        Object a = new Object() {
+            @Override
+            public String toString() {
+                writeCount.incrementAndGet();
+                throw new RuntimeException("Broken!");
+            }
+        };
+        Call<String> call = service.postRequestBody(a);
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<String>() {
+            @Override
+            public void onResponse(Call<String> call, Response<String> response) {
+            }
+
+            @Override
+            public void onFailure(Call<String> call, Throwable t) {
+                assertThat(t).isExactlyInstanceOf(RuntimeException.class).hasMessage("Broken!");
+                assertThat(writeCount.get()).isEqualTo(1);
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(10, SECONDS));
+
+        try {
+            call.request();
+            fail();
+        } catch (RuntimeException e) {
+            assertThat(e).hasMessage("Broken!");
+        }
+        assertThat(writeCount.get()).isEqualTo(1);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
index 6f1480d23..8fbffc0d1 100644
--- a/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/ExecutorCallAdapterFactoryTest.java
@@ -16,12 +16,15 @@
 package retrofit2;
 
 import com.google.common.reflect.TypeToken;
+
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.List;
 import java.util.concurrent.Executor;
+
 import okhttp3.Request;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -34,137 +37,164 @@
 
 @SuppressWarnings("unchecked")
 public final class ExecutorCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  private final Retrofit retrofit = new Retrofit.Builder()
-      .baseUrl("http://localhost:1")
-      .build();
-  private final Callback<String> callback = mock(Callback.class);
-  private final Executor callbackExecutor = spy(new Executor() {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
-    }
-  });
-  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
-
-  @Test public void rawTypeThrows() {
-    try {
-      factory.get(Call.class, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
-    }
-  }
-
-  @Test public void responseType() {
-    Type classType = new TypeToken<Call<String>>() {}.getType();
-    assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
-    assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
-    assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-  }
-
-  @Test public void adaptedCallExecute() throws IOException {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    Call<String> call = adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
-        return response;
-      }
+    private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+    private final Retrofit retrofit = new Retrofit.Builder()
+            .baseUrl("http://localhost:1")
+            .build();
+    private final Callback<String> callback = mock(Callback.class);
+    private final Executor callbackExecutor = spy(new Executor() {
+        @Override
+        public void execute(Runnable runnable) {
+            runnable.run();
+        }
     });
-    assertThat(call.execute()).isSameAs(response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Response<String> response = Response.success("Hi");
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onResponse(this, response);
-      }
-    };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verify(callback).onResponse(call, response);
-  }
-
-  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    final Throwable throwable = new IOException();
-    EmptyCall originalCall = new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
-        callback.onFailure(this, throwable);
-      }
-    };
-    Call<String> call = adapter.adapt(originalCall);
-    call.enqueue(callback);
-    verify(callbackExecutor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(callbackExecutor);
-    verify(callback).onFailure(call, throwable);
-    verifyNoMoreInteractions(callback);
-  }
-
-  @Test public void adaptedCallCloneDeepCopy() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
-    assertThat(cloned).isNotSameAs(call);
-    verify(delegate).clone();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  @Test public void adaptedCallCancel() {
-    Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String, Call<String>> adapter =
-        (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = adapter.adapt(delegate);
-    call.cancel();
-    verify(delegate).cancel();
-    verifyNoMoreInteractions(delegate);
-  }
-
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
-      throw new UnsupportedOperationException();
+    private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+    @Test
+    public void rawTypeThrows() {
+        try {
+            factory.get(Call.class, NO_ANNOTATIONS, retrofit);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+        }
+    }
+
+    @Test
+    public void responseType() {
+        Type classType = new TypeToken<Call<String>>() {
+        }.getType();
+        assertThat(factory.get(classType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type wilcardType = new TypeToken<Call<? extends String>>() {
+        }.getType();
+        assertThat(factory.get(wilcardType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(String.class);
+        Type genericType = new TypeToken<Call<List<String>>>() {
+        }.getType();
+        assertThat(factory.get(genericType, NO_ANNOTATIONS, retrofit).responseType())
+                .isEqualTo(new TypeToken<List<String>>() {
+                }.getType());
     }
 
-    @Override public boolean isExecuted() {
-      return false;
+    @Test
+    public void adaptedCallExecute() throws IOException {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<String, Call<String>> adapter =
+                (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        Call<String> call = adapter.adapt(new EmptyCall() {
+            @Override
+            public Response<String> execute() throws IOException {
+                return response;
+            }
+        });
+        assertThat(call.execute()).isSameAs(response);
     }
 
-    @Override public Response<String> execute() throws IOException {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<String, Call<String>> adapter =
+                (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Response<String> response = Response.success("Hi");
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onResponse(this, response);
+            }
+        };
+        Call<String> call = adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verify(callback).onResponse(call, response);
     }
 
-    @Override public void cancel() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<String, Call<String>> adapter =
+                (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        final Throwable throwable = new IOException();
+        EmptyCall originalCall = new EmptyCall() {
+            @Override
+            public void enqueue(Callback<String> callback) {
+                callback.onFailure(this, throwable);
+            }
+        };
+        Call<String> call = adapter.adapt(originalCall);
+        call.enqueue(callback);
+        verify(callbackExecutor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(callbackExecutor);
+        verify(callback).onFailure(call, throwable);
+        verifyNoMoreInteractions(callback);
     }
 
-    @Override public boolean isCanceled() {
-      return false;
+    @Test
+    public void adaptedCallCloneDeepCopy() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<String, Call<String>> adapter =
+                (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = adapter.adapt(delegate);
+        Call<String> cloned = call.clone();
+        assertThat(cloned).isNotSameAs(call);
+        verify(delegate).clone();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Call<String> clone() {
-      throw new UnsupportedOperationException();
+    @Test
+    public void adaptedCallCancel() {
+        Type returnType = new TypeToken<Call<String>>() {
+        }.getType();
+        CallAdapter<String, Call<String>> adapter =
+                (CallAdapter<String, Call<String>>) factory.get(returnType, NO_ANNOTATIONS, retrofit);
+        Call<String> delegate = mock(Call.class);
+        Call<String> call = adapter.adapt(delegate);
+        call.cancel();
+        verify(delegate).cancel();
+        verifyNoMoreInteractions(delegate);
     }
 
-    @Override public Request request() {
-      throw new UnsupportedOperationException();
+    static class EmptyCall implements Call<String> {
+        @Override
+        public void enqueue(Callback<String> callback) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isExecuted() {
+            return false;
+        }
+
+        @Override
+        public Response<String> execute() throws IOException {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void cancel() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isCanceled() {
+            return false;
+        }
+
+        @Override
+        public Call<String> clone() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Request request() {
+            throw new UnsupportedOperationException();
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
index 8333969c6..3d6647329 100644
--- a/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
+++ b/retrofit/src/test/java/retrofit2/Java8DefaultMethodsTest.java
@@ -17,29 +17,29 @@
 
 // TODO this test doesn't play nice in the IDE because it relies on Java 8 language features.
 public final class Java8DefaultMethodsTest {
-  //@Rule public final MockWebServer server = new MockWebServer();
-  //
-  //interface Example {
-  //  @GET("/") Call<String> user(@Query("name") String name);
-  //
-  //  default Call<String> user() {
-  //    return user("hey");
-  //  }
-  //}
-  //
-  //@Test public void test() throws IOException {
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //  server.enqueue(new MockResponse().setBody("Hi"));
-  //
-  //  Retrofit retrofit = new Retrofit.Builder()
-  //      .baseUrl(server.url("/"))
-  //      .addConverterFactory(new ToStringConverterFactory())
-  //      .build();
-  //  Example example = retrofit.create(Example.class);
-  //
-  //  Response<String> response = example.user().execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //  Response<String> response = example.user("hi").execute();
-  //  assertThat(response.body()).isEqualTo("Hi");
-  //}
+    //@Rule public final MockWebServer server = new MockWebServer();
+    //
+    //interface Example {
+    //  @GET("/") Call<String> user(@Query("name") String name);
+    //
+    //  default Call<String> user() {
+    //    return user("hey");
+    //  }
+    //}
+    //
+    //@Test public void test() throws IOException {
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //  server.enqueue(new MockResponse().setBody("Hi"));
+    //
+    //  Retrofit retrofit = new Retrofit.Builder()
+    //      .baseUrl(server.url("/"))
+    //      .addConverterFactory(new ToStringConverterFactory())
+    //      .build();
+    //  Example example = retrofit.create(Example.class);
+    //
+    //  Response<String> response = example.user().execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //  Response<String> response = example.user("hi").execute();
+    //  assertThat(response.body()).isEqualTo("Hi");
+    //}
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
index 63fa57b6c..4fed99328 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderAndroidTest.java
@@ -16,11 +16,14 @@
 package retrofit2;
 
 import android.net.Uri;
+
 import okhttp3.Request;
 import okhttp3.ResponseBody;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+
 import retrofit2.http.GET;
 import retrofit2.http.Url;
 
@@ -30,33 +33,35 @@
 @RunWith(RobolectricTestRunner.class)
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderAndroidTest {
-  @Test public void getWithAndroidUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
-    }
+    @Test
+    public void getWithAndroidUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
 
-    Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithAndroidUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Uri url) {
-        return null;
-      }
+        Request request = buildRequest(Example.class, Uri.parse("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
     }
 
-    Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
+    @Test
+    public void getWithAndroidUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Uri url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Uri.parse("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index 0f3b5ebe6..753d8287a 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.MultipartBody;
@@ -33,8 +34,10 @@
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okio.Buffer;
+
 import org.junit.Ignore;
 import org.junit.Test;
+
 import retrofit2.helpers.ToStringConverterFactory;
 import retrofit2.http.Body;
 import retrofit2.http.DELETE;
@@ -65,2472 +68,2725 @@
 
 @SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
 public final class RequestBuilderTest {
-  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
-
-  @Test public void customMethodNoBody() {
-    class Example {
-      @HTTP(method = "CUSTOM1", path = "/foo")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM1");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodWithBody() {
-    class Example {
-      @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("CUSTOM2");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
-    }
-  }
-
-  @Test public void invalidPathParam() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Path("hey!") String thing) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
-    class Example {
-      @GET("/foo?bar={bar}") //
-      Call<ResponseBody> method(@Path("bar") String thing) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body @Query("nope") String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @interface NonNull {}
-
-  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "yep");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
-  }
-
-  @Test public void twoMethodsFail() {
-    class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-        assertThat(e.getMessage())
-            .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
-                  "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
-    }
-  }
-
-  @Test public void lackingMethod() {
-    class Example {
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Part("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitMultipartWithPartMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@PartMap Map<String, String> params) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Field("a") int a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenEmptyOnMethod() {
-    class Example {
-      @GET("/") //
-      @Headers({}) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
-    }
-  }
-
-  @Test public void headersFailWhenMalformed() {
-    class Example {
-      @GET("/") //
-      @Headers("Malformed") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
-    }
-  }
-
-  @Test public void pathParamNonPathParamAndTypedBytes() {
-    class Example {
-      @PUT("/{a}") //
-      Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void parameterWithoutAnnotation() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(String a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void nonBodyHttpMethodWithSingleEntity() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@Body String o) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapMustBeAMap() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void queryMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
-  }
-
-  @Test public void queryMapRejectsNull() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullKeys() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
-    }
-  }
-
-  @Test public void queryMapRejectsNullValues() {
-    class Example {
-      @GET("/") //
-      Call<ResponseBody> method(@QueryMap Map<String, String> a) {
-        return null;
-      }
-    }
-
-    Map<String, String> queryParams = new LinkedHashMap<>();
-    queryParams.put("ping", "pong");
-    queryParams.put("kit", null);
-
-    try {
-      buildRequest(Example.class, queryParams);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void getWithHeaderMap() {
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
-        return null;
-      }
+    private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
+
+    @Test
+    public void customMethodNoBody() {
+        class Example {
+            @HTTP(method = "CUSTOM1", path = "/foo")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM1");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertThat(request.body()).isNull();
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodWithBody() {
+        class Example {
+            @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("CUSTOM2");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedMultipartFirst() {
+        class Example {
+            @Multipart //
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+        class Example {
+            @FormUrlEncoded //
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Only one encoding annotation is allowed.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void invalidPathParam() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Path("hey!") String thing) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+                            + " Found: hey! (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNotAllowedInQuery() throws Exception {
+        class Example {
+            @GET("/foo?bar={bar}")
+                //
+            Call<ResponseBody> method(@Path("bar") String thing) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL query string \"bar={bar}\" must not have replace block."
+                            + " For dynamic query parameters use @Query.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipleParameterAnnotationsNotAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body @Query("nope") String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @interface NonNull {
+    }
+
+    @Test
+    public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Query("maybe") @NonNull Object o) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "yep");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?maybe=yep");
+    }
+
+    @Test
+    public void twoMethodsFail() {
+        class Example {
+            @PATCH("/foo") //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage())
+                    .isIn("Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method",
+                            "Only one HTTP method is allowed. Found: POST and PATCH.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void lackingMethod() {
+        class Example {
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Part("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitMultipartWithPartMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, String> params) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsOnNonBodyMethod() {
+        class Example {
+            @Multipart //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartFailsWithNoParts() {
+        class Example {
+            @Multipart //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multipart method must contain at least one @Part.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Field("a") int a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void implicitFormEncodingByFieldMapForbidden() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsOnNonBodyMethod() {
+        class Example {
+            @FormUrlEncoded //
+            @GET("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void formEncodingFailsWithNoParts() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e)
+                    .hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenEmptyOnMethod() {
+        class Example {
+            @GET("/") //
+            @Headers({})
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headersFailWhenMalformed() {
+        class Example {
+            @GET("/") //
+            @Headers("Malformed")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void pathParamNonPathParamAndTypedBytes() {
+        class Example {
+            @PUT("/{a}")
+                //
+            Call<ResponseBody> method(@Path("a") int a, @Path("b") int b, @Body int c) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void parameterWithoutAnnotation() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(String a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void nonBodyHttpMethodWithSingleEntity() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@Body String o) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapMustBeAMap() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void queryMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/?hello=world");
+    }
+
+    @Test
+    public void queryMapRejectsNull() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map was null.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put(null, "kat");
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null key.");
+        }
+    }
+
+    @Test
+    public void queryMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, String> a) {
+                return null;
+            }
+        }
+
+        Map<String, String> queryParams = new LinkedHashMap<>();
+        queryParams.put("ping", "pong");
+        queryParams.put("kit", null);
+
+        try {
+            buildRequest(Example.class, queryParams);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void getWithHeaderMap() {
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {
+                return null;
+            }
+        }
+
+        Map<String, Object> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", "utf-8");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.body()).isNull();
+        assertThat(request.headers().size()).isEqualTo(2);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+        assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
+    }
+
+    @Test
+    public void headerMapMustBeAMap() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap List<String> headers) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void headerMapSupportsSubclasses() {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @GET("/search")
+            Call<ResponseBody> method(@HeaderMap Foo headers) {
+                return null;
+            }
+        }
+
+        Foo headers = new Foo();
+        headers.put("Accept", "text/plain");
+
+        Request request = buildRequest(Example.class, headers);
+        assertThat(request.url().toString()).isEqualTo("http://example.com/search");
+        assertThat(request.headers().size()).isEqualTo(1);
+        assertThat(request.header("Accept")).isEqualTo("text/plain");
+    }
+
+    @Test
+    public void headerMapRejectsNull() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (Map<String, String>) null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map was null.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullKeys() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put(null, "utf-8");
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null key.");
+        }
+    }
+
+    @Test
+    public void headerMapRejectsNullValues() {
+        class Example {
+            @GET("/")
+            Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
+                return null;
+            }
+        }
+
+        Map<String, String> headers = new LinkedHashMap<>();
+        headers.put("Accept", "text/plain");
+        headers.put("Accept-Charset", null);
+
+        try {
+            buildRequest(Example.class, headers);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
+        }
+    }
+
+    @Test
+    public void twoBodies() {
+        class Example {
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Body String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void bodyInNonBodyRequest() {
+        class Example {
+            @Multipart //
+            @PUT("/")
+                //
+            Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void get() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void delete() {
+        class Example {
+            @DELETE("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("DELETE");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertNull(request.body());
+    }
+
+    @Test
+    public void head() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<Void> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("HEAD");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headWithoutVoidThrows() {
+        class Example {
+            @HEAD("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "HEAD method must use Void as response type.\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void post() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void put() {
+        class Example {
+            @PUT("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PUT");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void patch() {
+        class Example {
+            @PATCH("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.method()).isEqualTo("PATCH");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void options() {
+        class Example {
+            @OPTIONS("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("OPTIONS");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnusedAndInvalidNamedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/{kit,kat}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "po%20ng");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathSegments() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/pong/more");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedPathStillPreventsRequestSplitting() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "baz/\r\npong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void pathParamRequired() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
+        }
+    }
+
+    @Test
+    public void getWithQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParam() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "p%20o%20n%20g");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void queryParamOptionalOmitsQuery() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new Object[]{null});
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+    }
+
+    @Test
+    public void queryParamOptional() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
+                    @Query("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
+    }
+
+    @Test
+    public void getWithQueryUrlAndParam() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method(@Query("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQuery() {
+        class Example {
+            @GET("/foo/bar/?hi=mom")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
+                    @Query("riff") String riff) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", "kat", "raff");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryThenPathThrows() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "kat", "pong");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathAndQueryQuestionMarkParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong?", "kat?");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryAmpersandParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong&", "kat&");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithPathAndQueryHashParam() {
+        class Example {
+            @GET("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong#", "kat#");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") List<Object> keys) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
+        Request request = buildRequest(Example.class, values);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") Object[] keys) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamPrimitiveArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Query("key") int[] keys) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, new Object[]{values});
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "kat");
+        params.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithEncodedQueryParamMap() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
+                return null;
+            }
+        }
+
+        Map<String, Object> params = new LinkedHashMap<>();
+        params.put("kit", "k%20t");
+        params.put("pi%20ng", "p%20g");
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getAbsoluteUrl() {
+        class Example {
+            @GET("http://example2.com/foo/bar/")
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithStringUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithJavaUriUrlAbsolute() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url URI url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithUrlAbsoluteSameHost() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithHttpUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void getWithNullUrl() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url HttpUrl url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, (HttpUrl) null);
+            fail();
+        } catch (NullPointerException expected) {
+            assertThat(expected).hasMessage("@Url parameter is null.");
+        }
+    }
+
+    @Test
+    public void getWithNonStringUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
+                            + " (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getUrlAndUrlParamThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithoutUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenPathThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithPathThenUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithQueryThenUrlThrows() {
+        class Example {
+            @GET("foo/bar")
+            Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, "hey", "foo/bar/");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void getWithUrlThenQuery() {
+        class Example {
+            @GET
+            Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "foo/bar/", "hey!");
+        assertThat(request.method()).isEqualTo("GET");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
+    }
+
+    @Test
+    public void postWithUrl() {
+        class Example {
+            @POST
+            Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
+        assertBody(request.body(), "hi");
+    }
+
+    @Test
+    public void normalPostWithPathParam() {
+        class Example {
+            @POST("/foo/bar/{ping}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void emptyBody() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Ignore("https://github.com/square/okhttp/issues/229")
+    @Test
+    public void customMethodEmptyBody() {
+        class Example {
+            @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true)
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("CUSTOM");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertBody(request.body(), "");
+    }
+
+    @Test
+    public void bodyRequired() {
+        class Example {
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+        }
+    }
+
+    @Test
+    public void bodyWithPathParams() {
+        class Example {
+            @POST("/foo/bar/{ping}/{kit}/")
+                //
+            Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+        Request request = buildRequest(Example.class, "pong", body, "kat");
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+        assertBody(request.body(), "Hi!");
+    }
+
+    @Test
+    public void simpleMultipart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartArray() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String[] ping) {
+                return null;
+            }
+        }
+
+        Request request =
+                buildRequest(Example.class, new Object[]{new String[]{"pong1", "pong2"}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartIterableRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<RequestBody> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayRequiresName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part RequestBody[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPartForbidsName() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartOkHttpPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpIterablePart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpArrayPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
+        MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
+        Request request =
+                buildRequest(Example.class, new Object[]{new MultipartBody.Part[]{part1, part2}});
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"foo\"\r\n")
+                .contains("\r\nbar\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartOkHttpPartWithFilename() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part MultipartBody.Part part) {
+                return null;
+            }
+        }
+
+        MultipartBody.Part part =
+                MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
+        Request request = buildRequest(Example.class, part);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartIterable() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<String> ping) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong1\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong2\r\n--");
+    }
+
+    @Test
+    public void multipartIterableOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartArrayOkHttpPart() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
+                    @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+                return null;
+            }
+        }
+
+        Request request = buildRequest(Example.class, "pong", RequestBody.create(
+                MediaType.parse("text/plain"), "kat"));
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 7-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMap() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapWithEncoding() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", RequestBody.create(null, "kat"));
+
+        Request request = buildRequest(Example.class, params);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"\r\n")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\npong\r\n--");
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"kit\"")
+                .contains("Content-Transfer-Encoding: 8-bit")
+                .contains("\r\nkat\r\n--");
+    }
+
+    @Test
+    public void multipartPartMapRejectsNonStringKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsOkHttpPartValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
+                            + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNull() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map was null.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullKeys() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put(null, RequestBody.create(null, "kat"));
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null key.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapRejectsNullValues() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
+                return null;
+            }
+        }
+
+        Map<String, RequestBody> params = new LinkedHashMap<>();
+        params.put("ping", RequestBody.create(null, "pong"));
+        params.put("kit", null);
+
+        try {
+            buildRequest(Example.class, params);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
+        }
+    }
+
+    @Test
+    public void multipartPartMapMustBeMap() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap List<Object> parts) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, Collections.emptyList());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void multipartPartMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@PartMap Foo parts) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8())
+                .contains("name=\"hello\"")
+                .contains("\r\n\r\nworld\r\n--");
+    }
+
+    @Test
+    public void multipartNullRemovesPart() throws IOException {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "pong", null);
+        assertThat(request.method()).isEqualTo("POST");
+        assertThat(request.headers().size()).isZero();
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+
+        RequestBody body = request.body();
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String bodyString = buffer.readUtf8();
+
+        assertThat(bodyString)
+                .contains("Content-Disposition: form-data;")
+                .contains("name=\"ping\"")
+                .contains("\r\npong\r\n--");
+    }
+
+    @Test
+    public void multipartPartOptional() {
+        class Example {
+            @Multipart //
+            @POST("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Part("ping") RequestBody ping) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+        }
+    }
+
+    @Test
+    public void simpleFormEncoded() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", "pong");
+        assertBody(request.body(), "foo=bar&ping=pong");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParam() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "ba%20r");
+        assertBody(request.body(), "na%20me=ba%20r");
+    }
+
+    @Test
+    public void formEncodedFieldOptional() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
+                    @Field("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "bar", null, "kat");
+        assertBody(request.body(), "foo=bar&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldList() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        Object[] values = {1, 2, null, "three"};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+    }
+
+    @Test
+    public void formEncodedFieldPrimitiveArray() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+                return null;
+            }
+        }
+
+        int[] values = {1, 2, 3};
+        Request request = buildRequest(Example.class, values, "kat");
+        assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+    }
+
+    @Test
+    public void formEncodedWithEncodedNameFieldParamMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("k%20it", "k%20at");
+        fieldMap.put("pin%20g", "po%20ng");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+    }
+
+    @Test
+    public void formEncodedFieldMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/foo")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("ping", "pong");
+
+        Request request = buildRequest(Example.class, fieldMap);
+        assertBody(request.body(), "kit=kat&ping=pong");
+    }
+
+    @Test
+    public void fieldMapRejectsNull() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        try {
+            buildRequest(Example.class, new Object[]{null});
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map was null.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullKeys() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put(null, "pong");
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null key.");
+        }
+    }
+
+    @Test
+    public void fieldMapRejectsNullValues() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
+                return null;
+            }
+        }
+
+        Map<String, Object> fieldMap = new LinkedHashMap<>();
+        fieldMap.put("kit", "kat");
+        fieldMap.put("foo", null);
+
+        try {
+            buildRequest(Example.class, fieldMap);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
+        }
+    }
+
+    @Test
+    public void fieldMapMustBeAMap() {
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap List<String> a) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+        }
+    }
+
+    @Test
+    public void fieldMapSupportsSubclasses() throws IOException {
+        class Foo extends HashMap<String, String> {
+        }
+
+        class Example {
+            @FormUrlEncoded //
+            @POST("/")
+                //
+            Call<ResponseBody> method(@FieldMap Foo a) {
+                return null;
+            }
+        }
+
+        Foo foo = new Foo();
+        foo.put("hello", "world");
+
+        Request request = buildRequest(Example.class, foo);
+        Buffer buffer = new Buffer();
+        request.body().writeTo(buffer);
+        assertThat(buffer.readUtf8()).isEqualTo("hello=world");
+    }
+
+    @Test
+    public void simpleHeaders() {
+        class Example {
+            @GET("/foo/bar/")
+            @Headers({
+                    "ping: pong",
+                    "kit: kat"
+            })
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamToString() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("kit") BigInteger kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, new BigInteger("1234"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(1);
+        assertThat(headers.get("kit")).isEqualTo("1234");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParam() {
+        class Example {
+            @GET("/foo/bar/") //
+            @Headers("ping: pong")
+                //
+            Call<ResponseBody> method(@Header("kit") String kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "kat");
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.get("ping")).isEqualTo("pong");
+        assertThat(headers.get("kit")).isEqualTo("kat");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamList() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") List<String> kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void headerParamArray() {
+        class Example {
+            @GET("/foo/bar/")
+                //
+            Call<ResponseBody> method(@Header("foo") String[] kit) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, (Object) new String[]{"bar", null, "baz"});
+        assertThat(request.method()).isEqualTo("GET");
+        okhttp3.Headers headers = request.headers();
+        assertThat(headers.size()).isEqualTo(2);
+        assertThat(headers.values("foo")).containsExactly("bar", "baz");
+        assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
+        assertThat(request.body()).isNull();
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderOverrides() {
+        class Example {
+            @POST("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        Request request = buildRequest(Example.class, body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void malformedContentTypeHeaderThrows() {
+        class Example {
+            @POST("/") //
+            @Headers("Content-Type: hello, world!")
+                //
+            Call<ResponseBody> method(@Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        try {
+            buildRequest(Example.class, body);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Malformed content type: hello, world!\n"
+                    + "    for method Example.method");
+        }
+    }
+
+    @Test
+    public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
+        class Example {
+            @DELETE("/") //
+            @Headers("Content-Type: text/not-plain")
+                //
+            Call<ResponseBody> method() {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class);
+        assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void contentTypeParameterHeaderOverrides() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+        Request request = buildRequest(Example.class, "text/not-plain", body);
+        assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
+    }
+
+    @Test
+    public void malformedContentTypeParameterThrows() {
+        class Example {
+            @POST("/")
+                //
+            Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+                return null;
+            }
+        }
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+        try {
+            buildRequest(Example.class, "hello, world!", body);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Malformed content type: hello, world!");
+        }
+    }
+
+    @Test
+    public void malformedAnnotationRelativeUrlThrows() {
+        class Example {
+            @GET("ftp://example.org")
+            Call<ResponseBody> get() {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    @Test
+    public void malformedParameterRelativeUrlThrows() {
+        class Example {
+            @GET
+            Call<ResponseBody> get(@Url String relativeUrl) {
+                return null;
+            }
+        }
+        try {
+            buildRequest(Example.class, "ftp://example.org");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
+        }
+    }
+
+    @Test
+    public void multipartPartsShouldBeInOrder() throws IOException {
+        class Example {
+            @Multipart
+            @POST("/foo")
+            Call<ResponseBody> get(@Part("first") String data, @Part("second") String dataTwo,
+                    @Part("third") String dataThree) {
+                return null;
+            }
+        }
+        Request request = buildRequest(Example.class, "firstParam", "secondParam", "thirdParam");
+        MultipartBody body = (MultipartBody) request.body();
+
+        Buffer buffer = new Buffer();
+        body.writeTo(buffer);
+        String readBody = buffer.readUtf8();
+
+        assertThat(readBody.indexOf("firstParam")).isLessThan(readBody.indexOf("secondParam"));
+        assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
+    }
+
+    private static void assertBody(RequestBody body, String expected) {
+        assertThat(body).isNotNull();
+        Buffer buffer = new Buffer();
+        try {
+            body.writeTo(buffer);
+            assertThat(buffer.readUtf8()).isEqualTo(expected);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    static <T> Request buildRequest(Class<T> cls, Object... args) {
+        final AtomicReference<Request> requestRef = new AtomicReference<>();
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                requestRef.set(request);
+                throw new UnsupportedOperationException("Not implemented");
+            }
+        };
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(new ToStringConverterFactory())
+                .callFactory(callFactory)
+                .build();
+
+        Method method = TestingUtils.onlyMethod(cls);
+        //noinspection unchecked
+        ServiceMethod<T, Call<T>> serviceMethod =
+                (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
+        Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
+        Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
+        try {
+            call.execute();
+            throw new AssertionError();
+        } catch (UnsupportedOperationException ignored) {
+            return requestRef.get();
+        } catch (RuntimeException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new AssertionError(e);
+        }
     }
-
-    Map<String, Object> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", "utf-8");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.body()).isNull();
-    assertThat(request.headers().size()).isEqualTo(2);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-    assertThat(request.header("Accept-Charset")).isEqualTo("utf-8");
-  }
-
-  @Test public void headerMapMustBeAMap() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap List<String> headers) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@HeaderMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void headerMapSupportsSubclasses() {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(@HeaderMap Foo headers) {
-        return null;
-      }
-    }
-
-    Foo headers = new Foo();
-    headers.put("Accept", "text/plain");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.headers().size()).isEqualTo(1);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-  }
-
-  @Test public void headerMapRejectsNull() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (Map<String, String>) null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullKeys() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put(null, "utf-8");
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key.");
-    }
-  }
-
-  @Test public void headerMapRejectsNullValues() {
-    class Example {
-      @GET("/")
-      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {
-        return null;
-      }
-    }
-
-    Map<String, String> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Accept-Charset", null);
-
-    try {
-      buildRequest(Example.class, headers);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
-    }
-  }
-
-  @Test public void twoBodies() {
-    class Example {
-      @PUT("/") //
-      Call<ResponseBody> method(@Body String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Call<ResponseBody> method(@Part("one") String o1, @Body String o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
-    }
-  }
-
-  @Test public void get() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void delete() {
-    class Example {
-      @DELETE("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("DELETE");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertNull(request.body());
-  }
-
-  @Test public void head() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<Void> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("HEAD");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headWithoutVoidThrows() {
-    class Example {
-      @HEAD("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "HEAD method must use Void as response type.\n    for method Example.method");
-    }
-  }
-
-  @Test public void post() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void put() {
-    class Example {
-      @PUT("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void patch() {
-    class Example {
-      @PATCH("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("PATCH");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void options() {
-    class Example {
-      @OPTIONS("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("OPTIONS");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnusedAndInvalidNamedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit,kat}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathSegments() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/pong/more");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/more/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\nheader: blue");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path(value = "ping", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "baz/\r\npong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/baz/pong/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void pathParamRequired() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
-    }
-  }
-
-  @Test public void getWithQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query(value = "pi%20ng", encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void queryParamOptional() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("foo") String foo, @Query("ping") String ping,
-          @Query("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?foo=bar&kit=kat");
-  }
-
-  @Test public void getWithQueryUrlAndParam() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method(@Query("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQuery() {
-    class Example {
-      @GET("/foo/bar/?hi=mom") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hi=mom");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit,
-          @Query("riff") String riff) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", "kat", "raff");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/?kit=kat&riff=raff");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryThenPathThrows() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Query("kit") String kit, @Path("ping") String ping) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "kat", "pong");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathAndQueryQuestionMarkParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong?", "kat?");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryAmpersandParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong&", "kat&");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong&/?kit=kat%26");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathAndQueryHashParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Query("kit") String kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong#", "kat#");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong%23/?kit=kat%23");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Query("key") int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "kat");
-    params.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=kat&ping=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryParamMap() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<>();
-    params.put("kit", "k%20t");
-    params.put("pi%20ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getAbsoluteUrl() {
-    class Example {
-      @GET("http://example2.com/foo/bar/")
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithStringUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithJavaUriUrlAbsolute() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url URI url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, URI.create("https://example2.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("https://example2.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithUrlAbsoluteSameHost() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithHttpUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url()).isEqualTo(HttpUrl.parse("http://example.com/foo/bar/"));
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithNullUrl() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url HttpUrl url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, (HttpUrl) null);
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null.");
-    }
-  }
-
-  @Test public void getWithNonStringUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type."
-              + " (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void getUrlAndUrlParamThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Url cannot be used with @GET URL (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithoutUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenPathThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Path("hey") String hey) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithPathThenUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Path("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithQueryThenUrlThrows() {
-    class Example {
-      @GET("foo/bar")
-      Call<ResponseBody> method(@Query("hey") String hey, @Url Object url) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, "hey", "foo/bar/");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void getWithUrlThenQuery() {
-    class Example {
-      @GET
-      Call<ResponseBody> method(@Url String url, @Query("hey") String hey) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
-  }
-
-  @Test public void postWithUrl() {
-    class Example {
-      @POST
-      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar");
-    assertBody(request.body(), "hi");
-  }
-
-  @Test public void normalPostWithPathParam() {
-    class Example {
-      @POST("/foo/bar/{ping}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void emptyBody() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Ignore("https://github.com/square/okhttp/issues/229")
-  @Test public void customMethodEmptyBody() {
-    class Example {
-      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("CUSTOM");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
-  }
-
-  @Test public void bodyRequired() {
-    class Example {
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
-    }
-  }
-
-  @Test public void bodyWithPathParams() {
-    class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Call<ResponseBody> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
-    Request request = buildRequest(Example.class, "pong", body, "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "Hi!");
-  }
-
-  @Test public void simpleMultipart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartArray() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String[] ping) {
-        return null;
-      }
-    }
-
-    Request request =
-        buildRequest(Example.class, new Object[] { new String[] { "pong1", "pong2" } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartIterableRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<RequestBody> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayRequiresName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part RequestBody[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPartForbidsName() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("name") MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartOkHttpPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpIterablePart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpArrayPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part1 = MultipartBody.Part.createFormData("foo", "bar");
-    MultipartBody.Part part2 = MultipartBody.Part.createFormData("kit", "kat");
-    Request request =
-        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"foo\"\r\n")
-        .contains("\r\nbar\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartOkHttpPartWithFilename() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part MultipartBody.Part part) {
-        return null;
-      }
-    }
-
-    MultipartBody.Part part =
-        MultipartBody.Part.createFormData("kit", "kit.txt", RequestBody.create(null, "kat"));
-    Request request = buildRequest(Example.class, part);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"; filename=\"kit.txt\"\r\n")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartIterable() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<String> ping) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, Arrays.asList("pong1", "pong2"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong1\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong2\r\n--");
-  }
-
-  @Test public void multipartIterableOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") List<MultipartBody.Part> part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartArrayOkHttpPart() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") MultipartBody.Part[] part) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
-        return null;
-      }
-    }
-
-    Request request = buildRequest(Example.class, "pong", RequestBody.create(
-        MediaType.parse("text/plain"), "kat"));
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 7-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMap() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapWithEncoding() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap(encoding = "8-bit") Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", RequestBody.create(null, "kat"));
-
-    Request request = buildRequest(Example.class, params);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"\r\n")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\npong\r\n--");
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"kit\"")
-        .contains("Content-Transfer-Encoding: 8-bit")
-        .contains("\r\nkat\r\n--");
-  }
-
-  @Test public void multipartPartMapRejectsNonStringKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap keys must be of type String: class java.lang.Object (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsOkHttpPartValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\n"
-              + "    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNull() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put(null, RequestBody.create(null, "kat"));
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
-    }
-  }
-
-  @Test public void multipartPartMapRejectsNullValues() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {
-        return null;
-      }
-    }
-
-    Map<String, RequestBody> params = new LinkedHashMap<>();
-    params.put("ping", RequestBody.create(null, "pong"));
-    params.put("kit", null);
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
-    }
-  }
-
-  @Test public void multipartPartMapMustBeMap() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap List<Object> parts) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, Collections.emptyList());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void multipartPartMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@PartMap Foo parts) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8())
-        .contains("name=\"hello\"")
-        .contains("\r\n\r\nworld\r\n--");
-  }
-
-  @Test public void multipartNullRemovesPart() throws IOException {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") String ping, @Part("fizz") String fizz) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong", null);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-
-    RequestBody body = request.body();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String bodyString = buffer.readUtf8();
-
-    assertThat(bodyString)
-        .contains("Content-Disposition: form-data;")
-        .contains("name=\"ping\"")
-        .contains("\r\npong\r\n--");
-  }
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Call<ResponseBody> method(@Part("ping") RequestBody ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field(value = "na%20me", encoded = true) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba%20r");
-    assertBody(request.body(), "na%20me=ba%20r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("k%20it", "k%20at");
-    fieldMap.put("pin%20g", "po%20ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNull() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapRejectsNullValues() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
-    }
-  }
-
-  @Test public void fieldMapSupportsSubclasses() throws IOException {
-    class Foo extends HashMap<String, String> {
-    }
-
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Call<ResponseBody> method(@FieldMap Foo a) {
-        return null;
-      }
-    }
-
-    Foo foo = new Foo();
-    foo.put("hello", "world");
-
-    Request request = buildRequest(Example.class, foo);
-    Buffer buffer = new Buffer();
-    request.body().writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo("hello=world");
-  }
-
-  @Test public void simpleHeaders() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamToString() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("kit") BigInteger kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new BigInteger("1234"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.get("kit")).isEqualTo("1234");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(@Header("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") List<String> kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, Arrays.asList("bar", null, "baz"));
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void headerParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@Header("foo") String[] kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, (Object) new String[] { "bar", null, "baz" });
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.values("foo")).containsExactly("bar", "baz");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void contentTypeAnnotationHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedContentTypeHeaderThrows() {
-    class Example {
-      @POST("/") //
-      @Headers("Content-Type: hello, world!") //
-      Call<ResponseBody> method(@Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    try {
-      buildRequest(Example.class, body);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Malformed content type: hello, world!\n"
-          + "    for method Example.method");
-    }
-  }
-
-  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      @Headers("Content-Type: text/not-plain") //
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeParameterHeaderOverrides() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
-    Request request = buildRequest(Example.class, "text/not-plain", body);
-    assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
-  }
-
-  @Test public void malformedContentTypeParameterThrows() {
-    class Example {
-      @POST("/") //
-      Call<ResponseBody> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
-        return null;
-      }
-    }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    try {
-      buildRequest(Example.class, "hello, world!", body);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Malformed content type: hello, world!");
-    }
-  }
-
-  @Test public void malformedAnnotationRelativeUrlThrows() {
-    class Example {
-      @GET("ftp://example.org")
-      Call<ResponseBody> get() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void malformedParameterRelativeUrlThrows() {
-    class Example {
-      @GET
-      Call<ResponseBody> get(@Url String relativeUrl) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, "ftp://example.org");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Malformed URL. Base: http://example.com/, Relative: ftp://example.org");
-    }
-  }
-
-  @Test public void multipartPartsShouldBeInOrder() throws IOException {
-    class Example {
-      @Multipart
-      @POST("/foo")
-      Call<ResponseBody> get(@Part("first") String data, @Part("second") String dataTwo, @Part("third") String dataThree) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "firstParam", "secondParam", "thirdParam");
-    MultipartBody body = (MultipartBody) request.body();
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    String readBody = buffer.readUtf8();
-
-    assertThat(readBody.indexOf("firstParam")).isLessThan(readBody.indexOf("secondParam"));
-    assertThat(readBody.indexOf("secondParam")).isLessThan(readBody.indexOf("thirdParam"));
-  }
-
-  private static void assertBody(RequestBody body, String expected) {
-    assertThat(body).isNotNull();
-    Buffer buffer = new Buffer();
-    try {
-      body.writeTo(buffer);
-      assertThat(buffer.readUtf8()).isEqualTo(expected);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static <T> Request buildRequest(Class<T> cls, Object... args) {
-    final AtomicReference<Request> requestRef = new AtomicReference<>();
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        requestRef.set(request);
-        throw new UnsupportedOperationException("Not implemented");
-      }
-    };
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(new ToStringConverterFactory())
-        .callFactory(callFactory)
-        .build();
-
-    Method method = TestingUtils.onlyMethod(cls);
-    //noinspection unchecked
-    ServiceMethod<T, Call<T>> serviceMethod =
-        (ServiceMethod<T, Call<T>>) retrofit.loadServiceMethod(method);
-    Call<T> okHttpCall = new OkHttpCall<>(serviceMethod, args);
-    Call<T> call = serviceMethod.callAdapter.adapt(okHttpCall);
-    try {
-      call.execute();
-      throw new AssertionError();
-    } catch (UnsupportedOperationException ignored) {
-      return requestRef.get();
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/ResponseTest.java b/retrofit/src/test/java/retrofit2/ResponseTest.java
index 3d059b8ad..26caea8a8 100644
--- a/retrofit/src/test/java/retrofit2/ResponseTest.java
+++ b/retrofit/src/test/java/retrofit2/ResponseTest.java
@@ -18,164 +18,184 @@
 import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.ResponseBody;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
-  private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
-      .code(200)
-      .message("OK")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-  private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
-      .code(400)
-      .message("Broken!")
-      .protocol(Protocol.HTTP_1_1)
-      .request(new okhttp3.Request.Builder().url("http://localhost").build())
-      .build();
-
-  @Test public void success() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successNullAllowed() {
-    Response<Object> response = Response.success(null);
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void successWithHeaders() {
-    Object body = new Object();
-    Headers headers = Headers.of("foo", "bar");
-    Response<Object> response = Response.success(body, headers);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullHeadersThrows() {
-    try {
-      Response.success("", (okhttp3.Headers) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("headers == null");
+    private final okhttp3.Response successResponse = new okhttp3.Response.Builder() //
+                                                                                    .code(200)
+                                                                                    .message("OK")
+                                                                                    .protocol(Protocol.HTTP_1_1)
+                                                                                    .request(
+                                                                                            new okhttp3.Request.Builder()
+                                                                                                    .url("http://localhost")
+                                                                                                    .build())
+                                                                                    .build();
+    private final okhttp3.Response errorResponse = new okhttp3.Response.Builder() //
+                                                                                  .code(400)
+                                                                                  .message("Broken!")
+                                                                                  .protocol(Protocol.HTTP_1_1)
+                                                                                  .request(new okhttp3.Request.Builder()
+                                                                                          .url("http://localhost")
+                                                                                          .build())
+                                                                                  .build();
+
+    @Test
+    public void success() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successNullAllowed() {
+        Response<Object> response = Response.success(null);
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void successWithHeaders() {
+        Object body = new Object();
+        Headers headers = Headers.of("foo", "bar");
+        Response<Object> response = Response.success(body, headers);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().toMultimap()).isEqualTo(headers.toMultimap());
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successWithNullHeadersThrows() {
+        try {
+            Response.success("", (okhttp3.Headers) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("headers == null");
+        }
+    }
+
+    @Test
+    public void successWithRawResponse() {
+        Object body = new Object();
+        Response<Object> response = Response.success(body, successResponse);
+        assertThat(response.raw()).isSameAs(successResponse);
+        assertThat(response.code()).isEqualTo(200);
+        assertThat(response.message()).isEqualTo("OK");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isTrue();
+        assertThat(response.body()).isSameAs(body);
+        assertThat(response.errorBody()).isNull();
+    }
+
+    @Test
+    public void successWithNullRawResponseThrows() {
+        try {
+            Response.success("", (okhttp3.Response) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
     }
-  }
-
-  @Test public void successWithRawResponse() {
-    Object body = new Object();
-    Response<Object> response = Response.success(body, successResponse);
-    assertThat(response.raw()).isSameAs(successResponse);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isTrue();
-    assertThat(response.body()).isSameAs(body);
-    assertThat(response.errorBody()).isNull();
-  }
-
-  @Test public void successWithNullRawResponseThrows() {
-    try {
-      Response.success("", (okhttp3.Response) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void successWithErrorRawResponseThrows() {
+        try {
+            Response.success("", errorResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse must be successful response");
+        }
     }
-  }
-
-  @Test public void successWithErrorRawResponseThrows() {
-    try {
-      Response.success("", errorResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse must be successful response");
+
+    @Test
+    public void error() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(400, errorBody);
+        assertThat(response.raw()).isNotNull();
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isNull();
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
+    }
+
+    @Test
+    public void nullErrorThrows() {
+        try {
+            Response.error(400, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
     }
-  }
-
-  @Test public void error() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(400, errorBody);
-    assertThat(response.raw()).isNotNull();
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isNull();
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorThrows() {
-    try {
-      Response.error(400, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void errorWithSuccessCodeThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(200, errorBody);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("code < 400: 200");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessCodeThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(200, errorBody);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("code < 400: 200");
+
+    @Test
+    public void errorWithRawResponse() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        Response<?> response = Response.error(errorBody, errorResponse);
+        assertThat(response.raw()).isSameAs(errorResponse);
+        assertThat(response.code()).isEqualTo(400);
+        assertThat(response.message()).isEqualTo("Broken!");
+        assertThat(response.headers().size()).isZero();
+        assertThat(response.isSuccessful()).isFalse();
+        assertThat(response.body()).isNull();
+        assertThat(response.errorBody()).isSameAs(errorBody);
     }
-  }
-
-  @Test public void errorWithRawResponse() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    Response<?> response = Response.error(errorBody, errorResponse);
-    assertThat(response.raw()).isSameAs(errorResponse);
-    assertThat(response.code()).isEqualTo(400);
-    assertThat(response.message()).isEqualTo("Broken!");
-    assertThat(response.headers().size()).isZero();
-    assertThat(response.isSuccessful()).isFalse();
-    assertThat(response.body()).isNull();
-    assertThat(response.errorBody()).isSameAs(errorBody);
-  }
-
-  @Test public void nullErrorWithRawResponseThrows() {
-    try {
-      Response.error(null, errorResponse);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("body == null");
+
+    @Test
+    public void nullErrorWithRawResponseThrows() {
+        try {
+            Response.error(null, errorResponse);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("body == null");
+        }
     }
-  }
-
-  @Test public void errorWithNullRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("rawResponse == null");
+
+    @Test
+    public void errorWithNullRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("rawResponse == null");
+        }
     }
-  }
-
-  @Test public void errorWithSuccessRawResponseThrows() {
-    ResponseBody errorBody = ResponseBody.create(null, "Broken!");
-    try {
-      Response.error(errorBody, successResponse);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("rawResponse should not be successful response");
+
+    @Test
+    public void errorWithSuccessRawResponseThrows() {
+        ResponseBody errorBody = ResponseBody.create(null, "Broken!");
+        try {
+            Response.error(errorBody, successResponse);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("rawResponse should not be successful response");
+        }
     }
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 92dfb74ca..fe6af44dd 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -39,8 +40,10 @@
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.junit.Rule;
 import org.junit.Test;
+
 import retrofit2.helpers.DelegatingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingCallAdapterFactory;
 import retrofit2.helpers.NonMatchingConverterFactory;
@@ -65,1271 +68,1410 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 public final class RetrofitTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface CallMethod {
-    @GET("/") Call<String> disallowed();
-    @POST("/") Call<ResponseBody> disallowed(@Body String body);
-
-    @GET("/") Call<retrofit2.Response> badType1();
-    @GET("/") Call<okhttp3.Response> badType2();
-
-    @GET("/") Call<ResponseBody> getResponseBody();
-    @GET("/") Call<Void> getVoid();
-    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
-    @GET("/") Call<ResponseBody> queryString(@Query("foo") String foo);
-    @GET("/") Call<ResponseBody> queryObject(@Query("foo") Object foo);
-  }
-  interface FutureMethod {
-    @GET("/") Future<String> method();
-  }
-  interface Extending extends CallMethod {
-  }
-  interface StringService {
-    @GET("/") String get();
-  }
-  interface UnresolvableResponseType {
-    @GET("/") <T> Call<T> typeVariable();
-    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
-    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
-    @GET("/") Call<?> wildcard();
-    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
-  }
-  interface UnresolvableParameterType {
-    @POST("/") <T> Call<ResponseBody> typeVariable(@Body T body);
-    @POST("/") <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
-    @POST("/") <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
-    @POST("/") Call<ResponseBody> wildcard(@Body List<?> body);
-    @POST("/") Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
-  }
-  interface VoidService {
-    @GET("/") void nope();
-  }
-  interface Annotated {
-    @GET("/") @Foo Call<String> method();
-    @POST("/") Call<ResponseBody> bodyParameter(@Foo @Body String param);
-    @GET("/") Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
-
-    @Retention(RUNTIME)
-    @interface Foo {}
-  }
-  interface MutableParameters {
-    @GET("/") Call<String> method(@Query("i") AtomicInteger value);
-  }
-
-  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
-  @Test public void objectMethodsStillWork() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    try {
-      retrofit.create(Extending.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
-    }
-  }
-
-  @Test public void cloneSharesStatefulInstances() {
-    CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
-    Converter.Factory converter = mock(Converter.Factory.class);
-    HttpUrl baseUrl = server.url("/");
-    Executor executor = mock(Executor.class);
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-
-    Retrofit one = new Retrofit.Builder()
-        .addCallAdapterFactory(callAdapter)
-        .addConverterFactory(converter)
-        .baseUrl(baseUrl)
-        .callbackExecutor(executor)
-        .callFactory(callFactory)
-        .build();
-
-    CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
-    Converter.Factory converter2 = mock(Converter.Factory.class);
-    Retrofit two = one.newBuilder()
-        .addCallAdapterFactory(callAdapter2)
-        .addConverterFactory(converter2)
-        .build();
-    assertEquals(one.callAdapterFactories().size() + 1, two.callAdapterFactories().size());
-    assertThat(two.callAdapterFactories()).contains(callAdapter, callAdapter2);
-    assertEquals(one.converterFactories().size() + 1, two.converterFactories().size());
-    assertThat(two.converterFactories()).contains(converter, converter2);
-    assertSame(baseUrl, two.baseUrl());
-    assertSame(executor, two.callbackExecutor());
-    assertSame(callFactory, two.callFactory());
-  }
-
-  @Test public void responseTypeCannotBeRetrofitResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType1();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType1");
-    }
-  }
-
-  @Test public void responseTypeCannotBeOkHttpResponse() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    try {
-      service.badType2();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
-              + "    for method CallMethod.badType2");
-    }
-  }
-
-  @Test public void voidReturnTypeNotAllowed() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    VoidService service = retrofit.create(VoidService.class);
-
-    try {
-      service.nope();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void validateEagerlyDisabledByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyDisabledByUser() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(false)
-        .build();
-
-    // Should not throw exception about incorrect configuration of the VoidService
-    retrofit.create(VoidService.class);
-  }
-
-  @Test public void validateEagerlyFailsAtCreation() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .validateEagerly(true)
-        .build();
-
-    try {
-      retrofit.create(VoidService.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith(
-          "Service methods cannot return void.\n    for method VoidService.nope");
-    }
-  }
-
-  @Test public void callCallAdapterAddedByDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-  }
-
-  @Test public void callCallCustomAdapter() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    final AtomicBoolean adapterCalled = new AtomicBoolean();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        if (getRawType(returnType) != Call.class) {
-          return null;
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    interface CallMethod {
+        @GET("/")
+        Call<String> disallowed();
+
+        @POST("/")
+        Call<ResponseBody> disallowed(@Body String body);
+
+        @GET("/")
+        Call<retrofit2.Response> badType1();
+
+        @GET("/")
+        Call<okhttp3.Response> badType2();
+
+        @GET("/")
+        Call<ResponseBody> getResponseBody();
+
+        @GET("/")
+        Call<Void> getVoid();
+
+        @POST("/")
+        Call<ResponseBody> postRequestBody(@Body RequestBody body);
+
+        @GET("/")
+        Call<ResponseBody> queryString(@Query("foo") String foo);
+
+        @GET("/")
+        Call<ResponseBody> queryObject(@Query("foo") Object foo);
+    }
+
+    interface FutureMethod {
+        @GET("/")
+        Future<String> method();
+    }
+
+    interface Extending extends CallMethod {
+    }
+
+    interface StringService {
+        @GET("/")
+        String get();
+    }
+
+    interface UnresolvableResponseType {
+        @GET("/")
+        <T> Call<T> typeVariable();
+
+        @GET("/")
+        <T extends ResponseBody> Call<T> typeVariableUpperBound();
+
+        @GET("/")
+        <T> Call<List<Map<String, Set<T[]>>>> crazy();
+
+        @GET("/")
+        Call<?> wildcard();
+
+        @GET("/")
+        Call<? extends ResponseBody> wildcardUpperBound();
+    }
+
+    interface UnresolvableParameterType {
+        @POST("/")
+        <T> Call<ResponseBody> typeVariable(@Body T body);
+
+        @POST("/")
+        <T extends RequestBody> Call<ResponseBody> typeVariableUpperBound(@Body T body);
+
+        @POST("/")
+        <T> Call<ResponseBody> crazy(@Body List<Map<String, Set<T[]>>> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcard(@Body List<?> body);
+
+        @POST("/")
+        Call<ResponseBody> wildcardUpperBound(@Body List<? extends RequestBody> body);
+    }
+
+    interface VoidService {
+        @GET("/")
+        void nope();
+    }
+
+    interface Annotated {
+        @GET("/")
+        @Foo
+        Call<String> method();
+
+        @POST("/")
+        Call<ResponseBody> bodyParameter(@Foo @Body String param);
+
+        @GET("/")
+        Call<ResponseBody> queryParameter(@Foo @Query("foo") Object foo);
+
+        @Retention(RUNTIME)
+        @interface Foo {
+        }
+    }
+
+    interface MutableParameters {
+        @GET("/")
+        Call<String> method(@Query("i") AtomicInteger value);
+    }
+
+    @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+    @Test
+    public void objectMethodsStillWork() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        assertThat(example.hashCode()).isNotZero();
+        assertThat(example.equals(this)).isFalse();
+        assertThat(example.toString()).isNotEmpty();
+    }
+
+    @Test
+    public void interfaceWithExtendIsNotSupported() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        try {
+            retrofit.create(Extending.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+        }
+    }
+
+    @Test
+    public void cloneSharesStatefulInstances() {
+        CallAdapter.Factory callAdapter = mock(CallAdapter.Factory.class);
+        Converter.Factory converter = mock(Converter.Factory.class);
+        HttpUrl baseUrl = server.url("/");
+        Executor executor = mock(Executor.class);
+        okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+
+        Retrofit one = new Retrofit.Builder()
+                .addCallAdapterFactory(callAdapter)
+                .addConverterFactory(converter)
+                .baseUrl(baseUrl)
+                .callbackExecutor(executor)
+                .callFactory(callFactory)
+                .build();
+
+        CallAdapter.Factory callAdapter2 = mock(CallAdapter.Factory.class);
+        Converter.Factory converter2 = mock(Converter.Factory.class);
+        Retrofit two = one.newBuilder()
+                          .addCallAdapterFactory(callAdapter2)
+                          .addConverterFactory(converter2)
+                          .build();
+        assertEquals(one.callAdapterFactories().size() + 1, two.callAdapterFactories().size());
+        assertThat(two.callAdapterFactories()).contains(callAdapter, callAdapter2);
+        assertEquals(one.converterFactories().size() + 1, two.converterFactories().size());
+        assertThat(two.converterFactories()).contains(converter, converter2);
+        assertSame(baseUrl, two.baseUrl());
+        assertSame(executor, two.callbackExecutor());
+        assertSame(callFactory, two.callFactory());
+    }
+
+    @Test
+    public void responseTypeCannotBeRetrofitResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType1();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'retrofit2.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType1");
+        }
+    }
+
+    @Test
+    public void responseTypeCannotBeOkHttpResponse() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        try {
+            service.badType2();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(
+                    "'okhttp3.Response' is not a valid response body type. Did you mean ResponseBody?\n"
+                            + "    for method CallMethod.badType2");
+        }
+    }
+
+    @Test
+    public void voidReturnTypeNotAllowed() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        VoidService service = retrofit.create(VoidService.class);
+
+        try {
+            service.nope();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void validateEagerlyDisabledByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyDisabledByUser() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(false)
+                .build();
+
+        // Should not throw exception about incorrect configuration of the VoidService
+        retrofit.create(VoidService.class);
+    }
+
+    @Test
+    public void validateEagerlyFailsAtCreation() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .validateEagerly(true)
+                .build();
+
+        try {
+            retrofit.create(VoidService.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageStartingWith(
+                    "Service methods cannot return void.\n    for method VoidService.nope");
+        }
+    }
+
+    @Test
+    public void callCallAdapterAddedByDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+    }
+
+    @Test
+    public void callCallCustomAdapter() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        final AtomicBoolean adapterCalled = new AtomicBoolean();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?, ?> get(final Type returnType, Annotation[] annotations,
+                    Retrofit retrofit) {
+                factoryCalled.set(true);
+                if (getRawType(returnType) != Call.class) {
+                    return null;
+                }
+                return new CallAdapter<Object, Call<?>>() {
+                    @Override
+                    public Type responseType() {
+                        return getParameterUpperBound(0, (ParameterizedType) returnType);
+                    }
+
+                    @Override
+                    public Call<Object> adapt(Call<Object> call) {
+                        adapterCalled.set(true);
+                        return call;
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        assertThat(example.getResponseBody()).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+        assertThat(adapterCalled.get()).isTrue();
+    }
+
+    @Test
+    public void customCallAdapter() {
+        class GreetingCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
+                    Retrofit retrofit) {
+                if (getRawType(returnType) != String.class) {
+                    return null;
+                }
+                return new CallAdapter<Object, String>() {
+                    @Override
+                    public Type responseType() {
+                        return String.class;
+                    }
+
+                    @Override
+                    public String adapt(Call<Object> call) {
+                        return "Hi!";
+                    }
+                };
+            }
+        }
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new GreetingCallAdapterFactory())
+                .build();
+        StringService example = retrofit.create(StringService.class);
+        assertThat(example.get()).isEqualTo("Hi!");
+    }
+
+    @Test
+    public void methodAnnotationsPassedToCallAdapter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyCallAdapterFactory extends CallAdapter.Factory {
+            @Override
+            public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+                    Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .addCallAdapterFactory(new MyCallAdapterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void customCallAdapterMissingThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        FutureMethod example = retrofit.create(FutureMethod.class);
+        try {
+            example.method();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+                    + "    for method FutureMethod.method");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+    }
+
+    @Test
+    public void methodAnnotationsPassedToResponseBodyConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                    Retrofit retrofit) {
+                annotationsRef.set(annotations);
+                return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.method(); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
+        final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
+        final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
+
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, RequestBody> requestBodyConverter(Type type,
+                    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+                parameterAnnotationsRef.set(parameterAnnotations);
+                methodAnnotationsRef.set(methodAnnotations);
+                return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
+                        methodAnnotations, retrofit);
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.bodyParameter(null); // Trigger internal setup.
+
+        assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
+        assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
+    }
+
+    @Test
+    public void parameterAnnotationsPassedToStringConverter() {
+        final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                    Retrofit retrofit) {
+                annotationsRef.set(annotations);
+
+                return new Converter<Object, String>() {
+                    @Override
+                    public String convert(Object value) throws IOException {
+                        return String.valueOf(value);
+                    }
+                };
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        Annotated annotated = retrofit.create(Annotated.class);
+        annotated.queryParameter(null); // Trigger internal setup.
+
+        Annotation[] annotations = annotationsRef.get();
+        assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+    }
+
+    @Test
+    public void stringConverterCalledForString() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                    Retrofit retrofit) {
+                factoryCalled.set(true);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryString(null);
+        assertThat(call).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+    }
+
+    @Test
+    public void stringConverterReturningNullResultsInDefault() {
+        final AtomicBoolean factoryCalled = new AtomicBoolean();
+        class MyConverterFactory extends Converter.Factory {
+            @Override
+            public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                    Retrofit retrofit) {
+                factoryCalled.set(true);
+                return null;
+            }
+        }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new MyConverterFactory())
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.queryObject(null);
+        assertThat(call).isNotNull();
+        assertThat(factoryCalled.get()).isTrue();
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonRequestBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+        try {
+            example.disallowed("Hi!");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void missingConverterThrowsOnNonResponseBody() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        try {
+            example.disallowed();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Unable to create converter for class java.lang.String\n"
+                    + "    for method CallMethod.disallowed");
+            assertThat(e.getCause()).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters");
+        }
+    }
+
+    @Test
+    public void requestBodyOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<ResponseBody> response = example.getResponseBody().execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+    }
+
+    @Test
+    public void voidOutgoingAllowed() throws IOException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        Response<Void> response = example.getVoid().execute();
+        assertThat(response.body()).isNull();
+    }
+
+    @Test
+    public void voidResponsesArePooled() throws Exception {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("abc"));
+        server.enqueue(new MockResponse().setBody("def"));
+
+        example.getVoid().execute();
+        example.getVoid().execute();
+
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+        assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    }
+
+    @Test
+    public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .build();
+        CallMethod example = retrofit.create(CallMethod.class);
+
+        server.enqueue(new MockResponse().setBody("Hi"));
+
+        RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+        Response<ResponseBody> response = example.postRequestBody(body).execute();
+        assertThat(response.body().string()).isEqualTo("Hi");
+
+        assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+    }
+
+    @Test
+    public void unresolvableResponseTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
+
+        try {
+            example.typeVariable();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+                    + "    for method UnresolvableResponseType.crazy");
+        }
+        try {
+            example.wildcard();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
+        }
+        try {
+            example.wildcardUpperBound();
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+                    + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
+                    + "    for method UnresolvableResponseType.wildcardUpperBound");
+        }
+    }
+
+    @Test
+    public void unresolvableParameterTypeThrows() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
+
+        try {
+            example.typeVariable(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
+        }
+        try {
+            example.typeVariableUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
+        }
+        try {
+            example.crazy(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.crazy");
         }
-        return new CallAdapter<Object, Call<?>>() {
-          @Override public Type responseType() {
-            return getParameterUpperBound(0, (ParameterizedType) returnType);
-          }
-
-          @Override public Call<Object> adapt(Call<Object> call) {
-            adapterCalled.set(true);
-            return call;
-          }
+        try {
+            example.wildcard(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
+        }
+        try {
+            example.wildcardUpperBound(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
+                    + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
+                    + "    for method UnresolvableParameterType.wildcardUpperBound");
+        }
+    }
+
+    @Test
+    public void baseUrlRequired() {
+        try {
+            new Retrofit.Builder().build();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Base URL required.");
+        }
+    }
+
+    @Test
+    public void baseUrlNullThrows() {
+        try {
+            new Retrofit.Builder().baseUrl((String) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+        try {
+            new Retrofit.Builder().baseUrl((HttpUrl) null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("baseUrl == null");
+        }
+    }
+
+    @Test
+    public void baseUrlInvalidThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("ftp://foo/bar");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+        }
+    }
+
+    @Test
+    public void baseUrlNoTrailingSlashThrows() {
+        try {
+            new Retrofit.Builder().baseUrl("http://example.com/api");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+        HttpUrl parsed = HttpUrl.parse("http://example.com/api");
+        try {
+            new Retrofit.Builder().baseUrl(parsed);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
+        }
+    }
+
+    @Test
+    public void baseUrlStringPropagated() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        HttpUrl baseUrl = retrofit.baseUrl();
+        assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
+    }
+
+    @Test
+    public void baseHttpUrlPropagated() {
+        HttpUrl url = HttpUrl.parse("http://example.com/");
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(url)
+                .build();
+        assertThat(retrofit.baseUrl()).isSameAs(url);
+    }
+
+    @Test
+    public void clientNullThrows() {
+        try {
+            new Retrofit.Builder().client(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("client == null");
+        }
+    }
+
+    @Test
+    public void callFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .build();
+        assertThat(retrofit.callFactory()).isNotNull();
+    }
+
+    @Test
+    public void callFactoryPropagated() {
+        okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(callFactory);
+    }
+
+    @Test
+    public void callFactoryClientPropagated() {
+        OkHttpClient client = new OkHttpClient();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .client(client)
+                .build();
+        assertThat(retrofit.callFactory()).isSameAs(client);
+    }
+
+    @Test
+    public void callFactoryUsed() throws IOException {
+        okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return new OkHttpClient().newCall(request);
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        service.getResponseBody().execute();
+        verify(callFactory).newCall(any(Request.class));
+        verifyNoMoreInteractions(callFactory);
+    }
+
+    @Test
+    public void callFactoryReturningNullThrows() throws IOException {
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                return null;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    assertThat(example.getResponseBody()).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-    assertThat(adapterCalled.get()).isTrue();
-  }
-
-  @Test public void customCallAdapter() {
-    class GreetingCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<Object, String> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        if (getRawType(returnType) != String.class) {
-          return null;
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("Call.Factory returned null.");
         }
-        return new CallAdapter<Object, String>() {
-          @Override public Type responseType() {
-            return String.class;
-          }
-
-          @Override public String adapt(Call<Object> call) {
-            return "Hi!";
-          }
+    }
+
+    @Test
+    public void callFactoryThrowingPropagates() {
+        final RuntimeException cause = new RuntimeException("Broken!");
+        okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
+            @Override
+            public okhttp3.Call newCall(Request request) {
+                throw cause;
+            }
         };
-      }
-    }
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new GreetingCallAdapterFactory())
-        .build();
-    StringService example = retrofit.create(StringService.class);
-    assertThat(example.get()).isEqualTo("Hi!");
-  }
-
-  @Test public void methodAnnotationsPassedToCallAdapter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyCallAdapterFactory extends CallAdapter.Factory {
-      @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .addCallAdapterFactory(new MyCallAdapterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void customCallAdapterMissingThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    FutureMethod example = retrofit.create(FutureMethod.class);
-    try {
-      example.method();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
-          + "    for method FutureMethod.method");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-  }
-
-  @Test public void methodAnnotationsPassedToResponseBodyConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-        return new ToStringConverterFactory().responseBodyConverter(type, annotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.method(); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void methodAndParameterAnnotationsPassedToRequestBodyConverter() {
-    final AtomicReference<Annotation[]> parameterAnnotationsRef = new AtomicReference<>();
-    final AtomicReference<Annotation[]> methodAnnotationsRef = new AtomicReference<>();
-
-    class MyConverterFactory extends Converter.Factory {
-      @Override
-      public Converter<?, RequestBody> requestBodyConverter(Type type,
-          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-        parameterAnnotationsRef.set(parameterAnnotations);
-        methodAnnotationsRef.set(methodAnnotations);
-        return new ToStringConverterFactory().requestBodyConverter(type, parameterAnnotations,
-            methodAnnotations, retrofit);
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.bodyParameter(null); // Trigger internal setup.
-
-    assertThat(parameterAnnotationsRef.get()).hasAtLeastOneElementOfType(Annotated.Foo.class);
-    assertThat(methodAnnotationsRef.get()).hasAtLeastOneElementOfType(POST.class);
-  }
-
-  @Test public void parameterAnnotationsPassedToStringConverter() {
-    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        annotationsRef.set(annotations);
-
-        return new Converter<Object, String>() {
-          @Override public String convert(Object value) throws IOException {
-            return String.valueOf(value);
-          }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callFactory(callFactory)
+                .build();
+
+        server.enqueue(new MockResponse());
+
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+        try {
+            call.execute();
+            fail();
+        } catch (Exception e) {
+            assertThat(e).isSameAs(cause);
+        }
+    }
+
+    @Test
+    public void converterNullThrows() {
+        try {
+            new Retrofit.Builder().addConverterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void converterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        List<Converter.Factory> converterFactories = retrofit.converterFactories();
+        assertThat(converterFactories).hasSize(1);
+        assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
+    }
+
+    @Test
+    public void requestConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] parameterAnnotations = new Annotation[0];
+        Annotation[] methodAnnotations = new Annotation[1];
+
+        Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
+                methodAnnotations, retrofit);
+
+        Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
+                parameterAnnotations, methodAnnotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void requestConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.requestBodyConverter(type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void requestConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate RequestBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
+
+        Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).responseBodyConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void responseConverterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.responseBodyConverter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void responseConverterFactorySkippedNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
+        NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(nonMatchingFactory1)
+                .addConverterFactory(nonMatchingFactory2)
+                .build();
+
+        try {
+            retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate ResponseBody converter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.BuiltInConverters\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingConverterFactory");
+        }
+
+        assertThat(nonMatchingFactory1.called).isFalse();
+        assertThat(nonMatchingFactory2.called).isTrue();
+    }
+
+    @Test
+    public void stringConverterFactoryQueried() {
+        Type type = Object.class;
+        Annotation[] annotations = new Annotation[0];
+
+        Converter<?, String> expectedAdapter = mock(Converter.class);
+        Converter.Factory factory = mock(Converter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
+
+        Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).stringConverter(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void converterFactoryPropagated() {
+        Converter.Factory factory = mock(Converter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addConverterFactory(factory)
+                .build();
+        assertThat(retrofit.converterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryNullThrows() {
+        try {
+            new Retrofit.Builder().addCallAdapterFactory(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("factory == null");
+        }
+    }
+
+    @Test
+    public void callAdapterFactoryDefault() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callAdapterFactories()).isNotEmpty();
+    }
+
+    @Test
+    public void callAdapterFactoryPropagated() {
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+        assertThat(retrofit.callAdapterFactories()).contains(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueried() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory)
+                .build();
+
+        doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
+
+        CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegate() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .build();
+
+        doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
+
+        CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+    }
+
+    @Test
+    public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
+        CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
+        CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+        CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
+            @Override
+            public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+                return retrofit.nextCallAdapter(this, returnType, annotations);
+            }
+        });
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(factory1)
+                .addCallAdapterFactory(factory2)
+                .addCallAdapterFactory(factory3)
+                .build();
+
+        doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
+
+        CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
+        assertThat(actualAdapter).isSameAs(expectedAdapter);
+
+        verify(factory1).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory1);
+        verify(factory2).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory2);
+        verify(factory3).get(type, annotations, retrofit);
+        verifyNoMoreInteractions(factory3);
+    }
+
+    @Test
+    public void callAdapterFactoryNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callAdapterFactoryDelegateNoMatchThrows() {
+        Type type = String.class;
+        Annotation[] annotations = new Annotation[0];
+
+        DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
+        DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
+        NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .addCallAdapterFactory(delegatingFactory1)
+                .addCallAdapterFactory(delegatingFactory2)
+                .addCallAdapterFactory(nonMatchingFactory)
+                .build();
+
+        try {
+            retrofit.callAdapter(type, annotations);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessage(""
+                    + "Could not locate call adapter for class java.lang.String.\n"
+                    + "  Skipped:\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
+                    + "  Tried:\n"
+                    + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
+                    + "   * retrofit2.DefaultCallAdapterFactory");
+        }
+
+        assertThat(delegatingFactory1.called).isTrue();
+        assertThat(delegatingFactory2.called).isTrue();
+        assertThat(nonMatchingFactory.called).isTrue();
+    }
+
+    @Test
+    public void callbackExecutorNullThrows() {
+        try {
+            new Retrofit.Builder().callbackExecutor(null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("executor == null");
+        }
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultJvm() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isNull();
+    }
+
+    @Test
+    public void callbackExecutorPropagatesDefaultAndroid() {
+        final Executor executor = Executors.newSingleThreadExecutor();
+        Platform platform = new Platform() {
+            @Override
+            Executor defaultCallbackExecutor() {
+                return executor;
+            }
         };
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    Annotated annotated = retrofit.create(Annotated.class);
-    annotated.queryParameter(null); // Trigger internal setup.
-
-    Annotation[] annotations = annotationsRef.get();
-    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
-  }
-
-  @Test public void stringConverterCalledForString() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryString(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void stringConverterReturningNullResultsInDefault() {
-    final AtomicBoolean factoryCalled = new AtomicBoolean();
-    class MyConverterFactory extends Converter.Factory {
-      @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-          Retrofit retrofit) {
-        factoryCalled.set(true);
-        return null;
-      }
-    }
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new MyConverterFactory())
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.queryObject(null);
-    assertThat(call).isNotNull();
-    assertThat(factoryCalled.get()).isTrue();
-  }
-
-  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-    try {
-      example.disallowed("Hi!");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    try {
-      example.disallowed();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Unable to create converter for class java.lang.String\n"
-          + "    for method CallMethod.disallowed");
-      assertThat(e.getCause()).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters");
-    }
-  }
-
-  @Test public void requestBodyOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<ResponseBody> response = example.getResponseBody().execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-  }
-
-  @Test public void voidOutgoingAllowed() throws IOException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    Response<Void> response = example.getVoid().execute();
-    assertThat(response.body()).isNull();
-  }
-
-  @Test public void voidResponsesArePooled() throws Exception {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    example.getVoid().execute();
-    example.getVoid().execute();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .build();
-    CallMethod example = retrofit.create(CallMethod.class);
-
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
-    Response<ResponseBody> response = example.postRequestBody(body).execute();
-    assertThat(response.body().string()).isEqualTo("Hi");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
-  }
-
-  @Test public void unresolvableResponseTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableResponseType example = retrofit.create(UnresolvableResponseType.class);
-
-    try {
-      example.typeVariable();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<T>\n    for method UnresolvableResponseType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
-          + "    for method UnresolvableResponseType.crazy");
-    }
-    try {
-      example.wildcard();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<?>\n    for method UnresolvableResponseType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit2.Call<? extends okhttp3.ResponseBody>\n"
-          + "    for method UnresolvableResponseType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void unresolvableParameterTypeThrows() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    UnresolvableParameterType example = retrofit.create(UnresolvableParameterType.class);
-
-    try {
-      example.typeVariable(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariable");
-    }
-    try {
-      example.typeVariableUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "T (parameter #1)\n    for method UnresolvableParameterType.typeVariableUpperBound");
-    }
-    try {
-      example.crazy(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.crazy");
-    }
-    try {
-      example.wildcard(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<?> (parameter #1)\n    for method UnresolvableParameterType.wildcard");
-    }
-    try {
-      example.wildcardUpperBound(null);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter type must not include a type variable or wildcard: "
-          + "java.util.List<? extends okhttp3.RequestBody> (parameter #1)\n"
-          + "    for method UnresolvableParameterType.wildcardUpperBound");
-    }
-  }
-
-  @Test public void baseUrlRequired() {
-    try {
-      new Retrofit.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Base URL required.");
-    }
-  }
-
-  @Test public void baseUrlNullThrows() {
-    try {
-      new Retrofit.Builder().baseUrl((String) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-    try {
-      new Retrofit.Builder().baseUrl((HttpUrl) null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("baseUrl == null");
-    }
-  }
-
-  @Test public void baseUrlInvalidThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("ftp://foo/bar");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
-    }
-  }
-
-  @Test public void baseUrlNoTrailingSlashThrows() {
-    try {
-      new Retrofit.Builder().baseUrl("http://example.com/api");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-    HttpUrl parsed = HttpUrl.parse("http://example.com/api");
-    try {
-      new Retrofit.Builder().baseUrl(parsed);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("baseUrl must end in /: http://example.com/api");
-    }
-  }
-
-  @Test public void baseUrlStringPropagated() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    HttpUrl baseUrl = retrofit.baseUrl();
-    assertThat(baseUrl).isEqualTo(HttpUrl.parse("http://example.com/"));
-  }
-
-  @Test public void baseHttpUrlPropagated() {
-    HttpUrl url = HttpUrl.parse("http://example.com/");
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(url)
-        .build();
-    assertThat(retrofit.baseUrl()).isSameAs(url);
-  }
-
-  @Test public void clientNullThrows() {
-    try {
-      new Retrofit.Builder().client(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("client == null");
-    }
-  }
-
-  @Test public void callFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .build();
-    assertThat(retrofit.callFactory()).isNotNull();
-  }
-
-  @Test public void callFactoryPropagated() {
-    okhttp3.Call.Factory callFactory = mock(okhttp3.Call.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(callFactory);
-  }
-
-  @Test public void callFactoryClientPropagated() {
-    OkHttpClient client = new OkHttpClient();
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .client(client)
-        .build();
-    assertThat(retrofit.callFactory()).isSameAs(client);
-  }
-
-  @Test public void callFactoryUsed() throws IOException {
-    okhttp3.Call.Factory callFactory = spy(new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return new OkHttpClient().newCall(request);
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    service.getResponseBody().execute();
-    verify(callFactory).newCall(any(Request.class));
-    verifyNoMoreInteractions(callFactory);
-  }
-
-  @Test public void callFactoryReturningNullThrows() throws IOException {
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        return null;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Call.Factory returned null.");
-    }
-  }
-
-  @Test public void callFactoryThrowingPropagates() {
-    final RuntimeException cause = new RuntimeException("Broken!");
-    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {
-      @Override public okhttp3.Call newCall(Request request) {
-        throw cause;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callFactory(callFactory)
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-    try {
-      call.execute();
-      fail();
-    } catch (Exception e) {
-      assertThat(e).isSameAs(cause);
-    }
-  }
-
-  @Test public void converterNullThrows() {
-    try {
-      new Retrofit.Builder().addConverterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void converterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    List<Converter.Factory> converterFactories = retrofit.converterFactories();
-    assertThat(converterFactories).hasSize(1);
-    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverters.class);
-  }
-
-  @Test public void requestConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] parameterAnnotations = new Annotation[0];
-    Annotation[] methodAnnotations = new Annotation[1];
-
-    Converter<?, RequestBody> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).requestBodyConverter(type, parameterAnnotations,
-        methodAnnotations, retrofit);
-
-    Converter<?, RequestBody> actualAdapter = retrofit.requestBodyConverter(type,
-        parameterAnnotations, methodAnnotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void requestConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.requestBodyConverter(type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void requestConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextRequestBodyConverter(nonMatchingFactory1, type, annotations, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate RequestBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void responseConverterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<ResponseBody, ?> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).responseBodyConverter(type, annotations, retrofit);
-
-    Converter<ResponseBody, ?> actualAdapter = retrofit.responseBodyConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).responseBodyConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void responseConverterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.responseBodyConverter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void responseConverterFactorySkippedNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingConverterFactory nonMatchingFactory1 = new NonMatchingConverterFactory();
-    NonMatchingConverterFactory nonMatchingFactory2 = new NonMatchingConverterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(nonMatchingFactory1)
-        .addConverterFactory(nonMatchingFactory2)
-        .build();
-
-    try {
-      retrofit.nextResponseBodyConverter(nonMatchingFactory1, type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate ResponseBody converter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.BuiltInConverters\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingConverterFactory");
-    }
-
-    assertThat(nonMatchingFactory1.called).isFalse();
-    assertThat(nonMatchingFactory2.called).isTrue();
-  }
-
-  @Test public void stringConverterFactoryQueried() {
-    Type type = Object.class;
-    Annotation[] annotations = new Annotation[0];
-
-    Converter<?, String> expectedAdapter = mock(Converter.class);
-    Converter.Factory factory = mock(Converter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).stringConverter(type, annotations, retrofit);
-
-    Converter<?, String> actualAdapter = retrofit.stringConverter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).stringConverter(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void converterFactoryPropagated() {
-    Converter.Factory factory = mock(Converter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addConverterFactory(factory)
-        .build();
-    assertThat(retrofit.converterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryNullThrows() {
-    try {
-      new Retrofit.Builder().addCallAdapterFactory(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("factory == null");
-    }
-  }
-
-  @Test public void callAdapterFactoryDefault() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
-  }
-
-  @Test public void callAdapterFactoryPropagated() {
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-    assertThat(retrofit.callAdapterFactories()).contains(factory);
-  }
-
-  @Test public void callAdapterFactoryQueried() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory)
-        .build();
-
-    doReturn(expectedAdapter).when(factory).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegate() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory2 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .build();
-
-    doReturn(expectedAdapter).when(factory2).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-  }
-
-  @Test public void callAdapterFactoryQueriedCanDelegateTwiceWithoutRecursion() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    CallAdapter<?, ?> expectedAdapter = mock(CallAdapter.class);
-    CallAdapter.Factory factory3 = mock(CallAdapter.Factory.class);
-    CallAdapter.Factory factory2 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-    CallAdapter.Factory factory1 = spy(new CallAdapter.Factory() {
-      @Override
-      public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-        return retrofit.nextCallAdapter(this, returnType, annotations);
-      }
-    });
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(factory1)
-        .addCallAdapterFactory(factory2)
-        .addCallAdapterFactory(factory3)
-        .build();
-
-    doReturn(expectedAdapter).when(factory3).get(type, annotations, retrofit);
-
-    CallAdapter<?, ?> actualAdapter = retrofit.callAdapter(type, annotations);
-    assertThat(actualAdapter).isSameAs(expectedAdapter);
-
-    verify(factory1).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory1);
-    verify(factory2).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory2);
-    verify(factory3).get(type, annotations, retrofit);
-    verifyNoMoreInteractions(factory3);
-  }
-
-  @Test public void callAdapterFactoryNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callAdapterFactoryDelegateNoMatchThrows() {
-    Type type = String.class;
-    Annotation[] annotations = new Annotation[0];
-
-    DelegatingCallAdapterFactory delegatingFactory1 = new DelegatingCallAdapterFactory();
-    DelegatingCallAdapterFactory delegatingFactory2 = new DelegatingCallAdapterFactory();
-    NonMatchingCallAdapterFactory nonMatchingFactory = new NonMatchingCallAdapterFactory();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .addCallAdapterFactory(delegatingFactory1)
-        .addCallAdapterFactory(delegatingFactory2)
-        .addCallAdapterFactory(nonMatchingFactory)
-        .build();
-
-    try {
-      retrofit.callAdapter(type, annotations);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""
-          + "Could not locate call adapter for class java.lang.String.\n"
-          + "  Skipped:\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "   * retrofit2.helpers.DelegatingCallAdapterFactory\n"
-          + "  Tried:\n"
-          + "   * retrofit2.helpers.NonMatchingCallAdapterFactory\n"
-          + "   * retrofit2.DefaultCallAdapterFactory");
-    }
-
-    assertThat(delegatingFactory1.called).isTrue();
-    assertThat(delegatingFactory2.called).isTrue();
-    assertThat(nonMatchingFactory.called).isTrue();
-  }
-
-  @Test public void callbackExecutorNullThrows() {
-    try {
-      new Retrofit.Builder().callbackExecutor(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("executor == null");
-    }
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultJvm() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isNull();
-  }
-
-  @Test public void callbackExecutorPropagatesDefaultAndroid() {
-    final Executor executor = Executors.newSingleThreadExecutor();
-    Platform platform = new Platform() {
-      @Override Executor defaultCallbackExecutor() {
-        return executor;
-      }
-    };
-    Retrofit retrofit = new Retrofit.Builder(platform)
-        .baseUrl("http://example.com/")
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorPropagated() {
-    Executor executor = mock(Executor.class);
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com/")
-        .callbackExecutor(executor)
-        .build();
-    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
-  }
-
-  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        t.printStackTrace();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
-    Executor executor = spy(new Executor() {
-      @Override public void execute(Runnable command) {
-        command.run();
-      }
-    });
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .callbackExecutor(executor)
-        .build();
-    CallMethod service = retrofit.create(CallMethod.class);
-    Call<ResponseBody> call = service.getResponseBody();
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback<ResponseBody>() {
-      @Override public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-        throw new AssertionError();
-      }
-
-      @Override public void onFailure(Call<ResponseBody> call, Throwable t) {
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(2, TimeUnit.SECONDS));
-
-    verify(executor).execute(any(Runnable.class));
-    verifyNoMoreInteractions(executor);
-  }
-
-  /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
-  @Test public void argumentCapture() throws Exception {
-    AtomicInteger i = new AtomicInteger();
-
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ToStringConverterFactory())
-        .build();
-    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
-
-    i.set(100);
-    Call<String> call1 = mutableParameters.method(i);
-
-    i.set(101);
-    Response<String> response1 = call1.execute();
-
-    i.set(102);
-    assertEquals("a", response1.body());
-    assertEquals("/?i=101", server.takeRequest().getPath());
-
-    i.set(200);
-    Call<String> call2 = call1.clone();
-
-    i.set(201);
-    Response<String> response2 = call2.execute();
-
-    i.set(202);
-    assertEquals("b", response2.body());
-
-    assertEquals("/?i=201", server.takeRequest().getPath());
-  }
+        Retrofit retrofit = new Retrofit.Builder(platform)
+                .baseUrl("http://example.com/")
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorPropagated() {
+        Executor executor = mock(Executor.class);
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com/")
+                .callbackExecutor(executor)
+                .build();
+        assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForSuccess() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse());
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.printStackTrace();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    @Test
+    public void callbackExecutorUsedForFailure() throws InterruptedException {
+        Executor executor = spy(new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                command.run();
+            }
+        });
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .callbackExecutor(executor)
+                .build();
+        CallMethod service = retrofit.create(CallMethod.class);
+        Call<ResponseBody> call = service.getResponseBody();
+
+        server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        call.enqueue(new Callback<ResponseBody>() {
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                latch.countDown();
+            }
+        });
+        assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+        verify(executor).execute(any(Runnable.class));
+        verifyNoMoreInteractions(executor);
+    }
+
+    /** Confirm that Retrofit encodes parameters when the call is executed, and not earlier. */
+    @Test
+    public void argumentCapture() throws Exception {
+        AtomicInteger i = new AtomicInteger();
+
+        server.enqueue(new MockResponse().setBody("a"));
+        server.enqueue(new MockResponse().setBody("b"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ToStringConverterFactory())
+                .build();
+        MutableParameters mutableParameters = retrofit.create(MutableParameters.class);
+
+        i.set(100);
+        Call<String> call1 = mutableParameters.method(i);
+
+        i.set(101);
+        Response<String> response1 = call1.execute();
+
+        i.set(102);
+        assertEquals("a", response1.body());
+        assertEquals("/?i=101", server.takeRequest().getPath());
+
+        i.set(200);
+        Call<String> call2 = call1.clone();
+
+        i.set(201);
+        Response<String> response2 = call2.execute();
+
+        i.set(202);
+        assertEquals("b", response2.body());
+
+        assertEquals("/?i=201", server.takeRequest().getPath());
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
index c9c48f31e..61803b211 100644
--- a/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
+++ b/retrofit/src/test/java/retrofit2/ServiceMethodTest.java
@@ -16,32 +16,34 @@
 package retrofit2;
 
 import java.util.Set;
+
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ServiceMethodTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
+    @Test
+    public void pathParameterParsing() throws Exception {
+        expectParams("/");
+        expectParams("/foo");
+        expectParams("/foo/bar");
+        expectParams("/foo/bar/{}");
+        expectParams("/foo/bar/{taco}", "taco");
+        expectParams("/foo/bar/{t}", "t");
+        expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+        expectParams("/foo/bar/{}/{taco}", "taco");
+        expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+        expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+        expectParams("/foo/bar/{taco-shell}", "taco-shell");
+        expectParams("/foo/bar/{taco_shell}", "taco_shell");
+        expectParams("/foo/bar/{sha256}", "sha256");
+        expectParams("/foo/bar/{TACO}", "TACO");
+        expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+        expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+    }
 
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = ServiceMethod.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
-  }
+    private static void expectParams(String path, String... expected) {
+        Set<String> calculated = ServiceMethod.parsePathParameters(path);
+        assertThat(calculated).containsExactly(expected);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/TestingUtils.java b/retrofit/src/test/java/retrofit2/TestingUtils.java
index 3847509ea..035baa135 100644
--- a/retrofit/src/test/java/retrofit2/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit2/TestingUtils.java
@@ -18,11 +18,11 @@
 import java.lang.reflect.Method;
 
 public final class TestingUtils {
-  public static Method onlyMethod(Class c) {
-    Method[] declaredMethods = c.getDeclaredMethods();
-    if (declaredMethods.length == 1) {
-      return declaredMethods[0];
+    public static Method onlyMethod(Class c) {
+        Method[] declaredMethods = c.getDeclaredMethods();
+        if (declaredMethods.length == 1) {
+            return declaredMethods[0];
+        }
+        throw new IllegalArgumentException("More than one method declared.");
     }
-    throw new IllegalArgumentException("More than one method declared.");
-  }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
index 6ce48efe2..9d7ae7b48 100644
--- a/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/DelegatingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class DelegatingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return retrofit.nextCallAdapter(this, returnType, annotations);
-  }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return retrofit.nextCallAdapter(this, returnType, annotations);
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
index 3f44ddff8..afe13b261 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingCallAdapterFactory.java
@@ -17,15 +17,16 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingCallAdapterFactory extends CallAdapter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
index 343839944..3f9f281f5 100644
--- a/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/NonMatchingConverterFactory.java
@@ -17,30 +17,33 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
 
 public final class NonMatchingConverterFactory extends Converter.Factory {
-  public boolean called;
+    public boolean called;
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 
-  @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    called = true;
-    return null;
-  }
+    @Override
+    public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        called = true;
+        return null;
+    }
 }
diff --git a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
index 0a70e3ddb..d520c56ab 100644
--- a/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
+++ b/retrofit/src/test/java/retrofit2/helpers/ToStringConverterFactory.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -25,30 +26,33 @@
 import retrofit2.Retrofit;
 
 public class ToStringConverterFactory extends Converter.Factory {
-  static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+    static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
 
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<ResponseBody, String>() {
-        @Override public String convert(ResponseBody value) throws IOException {
-          return value.string();
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+            Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<ResponseBody, String>() {
+                @Override
+                public String convert(ResponseBody value) throws IOException {
+                    return value.string();
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 
-  @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-    if (String.class.equals(type)) {
-      return new Converter<String, RequestBody>() {
-        @Override public RequestBody convert(String value) throws IOException {
-          return RequestBody.create(MEDIA_TYPE, value);
+    @Override
+    public Converter<?, RequestBody> requestBodyConverter(Type type,
+            Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+        if (String.class.equals(type)) {
+            return new Converter<String, RequestBody>() {
+                @Override
+                public RequestBody convert(String value) throws IOException {
+                    return RequestBody.create(MEDIA_TYPE, value);
+                }
+            };
         }
-      };
+        return null;
     }
-    return null;
-  }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index 63123e082..851522731 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -1,69 +1,70 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>parent</artifactId>
-    <version>2.1.1-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
+    <parent>
+        <groupId>com.squareup.retrofit2</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.1.1-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-  <artifactId>samples</artifactId>
-  <name>Samples</name>
+    <artifactId>samples</artifactId>
+    <name>Samples</name>
 
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit-mock</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>converter-gson</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>converter-simplexml</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>adapter-rxjava</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.jsoup</groupId>
-      <artifactId>jsoup</artifactId>
-      <version>${jsoup.version}</version>
-    </dependency>
-  </dependencies>
+    <dependencies>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>retrofit-mock</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>converter-gson</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>converter-simplexml</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>adapter-rxjava</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>mockwebserver</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>${jsoup.version}</version>
+        </dependency>
+    </dependencies>
 
-  <build>
-    <plugins>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+    <build>
+        <plugins>
+            <!-- Do not deploy this as an artifact to Maven central. -->
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-deploy-plugin</artifactId>
+                <configuration>
+                    <skip>true</skip>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
index 790675975..703b0b8d7 100644
--- a/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
+++ b/samples/src/main/java/com/example/retrofit/ChunkingConverter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.lang.reflect.Type;
+
 import okhttp3.MediaType;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -38,92 +39,96 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class ChunkingConverter {
-  @Target(PARAMETER)
-  @Retention(RUNTIME)
-  @interface Chunked {
-  }
-
-  /**
-   * A converter which removes known content lengths to force chunking when {@code @Chunked} is
-   * present on {@code @Body} params.
-   */
-  static class ChunkingConverterFactory extends Converter.Factory {
-    @Override
-    public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      boolean isBody = false;
-      boolean isChunked = false;
-      for (Annotation annotation : parameterAnnotations) {
-        isBody |= annotation instanceof Body;
-        isChunked |= annotation instanceof Chunked;
-      }
-      if (!isBody || !isChunked) {
-        return null;
-      }
-
-      // Look up the real converter to delegate to.
-      final Converter<Object, RequestBody> delegate =
-          retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
-      // Wrap it in a Converter which removes the content length from the delegate's body.
-      return new Converter<Object, RequestBody>() {
-        @Override public RequestBody convert(Object value) throws IOException {
-          final RequestBody realBody = delegate.convert(value);
-          return new RequestBody() {
-            @Override public MediaType contentType() {
-              return realBody.contentType();
-            }
+    @Target(PARAMETER)
+    @Retention(RUNTIME)
+    @interface Chunked {
+    }
 
-            @Override public void writeTo(BufferedSink sink) throws IOException {
-              realBody.writeTo(sink);
+    /**
+     * A converter which removes known content lengths to force chunking when {@code @Chunked} is
+     * present on {@code @Body} params.
+     */
+    static class ChunkingConverterFactory extends Converter.Factory {
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            boolean isBody = false;
+            boolean isChunked = false;
+            for (Annotation annotation : parameterAnnotations) {
+                isBody |= annotation instanceof Body;
+                isChunked |= annotation instanceof Chunked;
             }
-          };
+            if (!isBody || !isChunked) {
+                return null;
+            }
+
+            // Look up the real converter to delegate to.
+            final Converter<Object, RequestBody> delegate =
+                    retrofit.nextRequestBodyConverter(this, type, parameterAnnotations, methodAnnotations);
+            // Wrap it in a Converter which removes the content length from the delegate's body.
+            return new Converter<Object, RequestBody>() {
+                @Override
+                public RequestBody convert(Object value) throws IOException {
+                    final RequestBody realBody = delegate.convert(value);
+                    return new RequestBody() {
+                        @Override
+                        public MediaType contentType() {
+                            return realBody.contentType();
+                        }
+
+                        @Override
+                        public void writeTo(BufferedSink sink) throws IOException {
+                            realBody.writeTo(sink);
+                        }
+                    };
+                }
+            };
         }
-      };
     }
-  }
 
-  static class Repo {
-    final String owner;
-    final String name;
+    static class Repo {
+        final String owner;
+        final String name;
+
+        Repo(String owner, String name) {
+            this.owner = owner;
+            this.name = name;
+        }
+    }
+
+    interface Service {
+        @POST("/")
+        Call<ResponseBody> sendNormal(@Body Repo repo);
+
+        @POST("/")
+        Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
+    }
+
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.enqueue(new MockResponse());
+        server.enqueue(new MockResponse());
+        server.start();
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new ChunkingConverterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Repo retrofitRepo = new Repo("square", "retrofit");
+
+        service.sendNormal(retrofitRepo).execute();
+        RecordedRequest normalRequest = server.takeRequest();
+        System.out.println(
+                "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
+
+        service.sendChunked(retrofitRepo).execute();
+        RecordedRequest chunkedRequest = server.takeRequest();
+        System.out.println(
+                "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
 
-    Repo(String owner, String name) {
-      this.owner = owner;
-      this.name = name;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @POST("/")
-    Call<ResponseBody> sendNormal(@Body Repo repo);
-    @POST("/")
-    Call<ResponseBody> sendChunked(@Chunked @Body Repo repo);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new ChunkingConverterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Repo retrofitRepo = new Repo("square", "retrofit");
-
-    service.sendNormal(retrofitRepo).execute();
-    RecordedRequest normalRequest = server.takeRequest();
-    System.out.println(
-        "Normal @Body Transfer-Encoding: " + normalRequest.getHeader("Transfer-Encoding"));
-
-    service.sendChunked(retrofitRepo).execute();
-    RecordedRequest chunkedRequest = server.takeRequest();
-    System.out.println(
-        "@Chunked @Body Transfer-Encoding: " + chunkedRequest.getHeader("Transfer-Encoding"));
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/Crawler.java b/samples/src/main/java/com/example/retrofit/Crawler.java
index 97c739e39..7f05e8a46 100644
--- a/samples/src/main/java/com/example/retrofit/Crawler.java
+++ b/samples/src/main/java/com/example/retrofit/Crawler.java
@@ -27,14 +27,17 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import okhttp3.ConnectionPool;
 import okhttp3.Dispatcher;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.ResponseBody;
+
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
+
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Converter;
@@ -45,102 +48,107 @@
 
 /** A simple web crawler that uses a Retrofit service to turn URLs into webpages. */
 public final class Crawler {
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
-      new LinkedHashSet<HttpUrl>());
-  private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
-  private final PageService pageService;
-
-  public Crawler(PageService pageService) {
-    this.pageService = pageService;
-  }
-
-  public void crawlPage(HttpUrl url) {
-    // Skip hosts that we've visited many times.
-    AtomicInteger hostnameCount = new AtomicInteger();
-    AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
-    if (previous != null) hostnameCount = previous;
-    if (hostnameCount.incrementAndGet() > 100) return;
-
-    // Asynchronously visit URL.
-    pageService.get(url).enqueue(new Callback<Page>() {
-      @Override public void onResponse(Call<Page> call, Response<Page> response) {
-        if (!response.isSuccessful()) {
-          System.out.println(call.request().url() + ": failed: " + response.code());
-          return;
-        }
+    private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
+            new LinkedHashSet<HttpUrl>());
+    private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
+    private final PageService pageService;
+
+    public Crawler(PageService pageService) {
+        this.pageService = pageService;
+    }
+
+    public void crawlPage(HttpUrl url) {
+        // Skip hosts that we've visited many times.
+        AtomicInteger hostnameCount = new AtomicInteger();
+        AtomicInteger previous = hostnames.putIfAbsent(url.host(), hostnameCount);
+        if (previous != null) hostnameCount = previous;
+        if (hostnameCount.incrementAndGet() > 100) return;
+
+        // Asynchronously visit URL.
+        pageService.get(url).enqueue(new Callback<Page>() {
+            @Override
+            public void onResponse(Call<Page> call, Response<Page> response) {
+                if (!response.isSuccessful()) {
+                    System.out.println(call.request().url() + ": failed: " + response.code());
+                    return;
+                }
+
+                // Print this page's URL and title.
+                Page page = response.body();
+                HttpUrl base = response.raw().request().url();
+                System.out.println(base + ": " + page.title);
+
+                // Enqueue its links for visiting.
+                for (String link : page.links) {
+                    HttpUrl linkUrl = base.resolve(link);
+                    if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
+                        crawlPage(linkUrl);
+                    }
+                }
+            }
+
+            @Override
+            public void onFailure(Call<Page> call, Throwable t) {
+                System.out.println(call.request().url() + ": failed: " + t);
+            }
+        });
+    }
+
+    public static void main(String... args) throws Exception {
+        Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
+        dispatcher.setMaxRequests(20);
+        dispatcher.setMaxRequestsPerHost(1);
+
+        OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                .dispatcher(dispatcher)
+                .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
+                .build();
 
-        // Print this page's URL and title.
-        Page page = response.body();
-        HttpUrl base = response.raw().request().url();
-        System.out.println(base + ": " + page.title);
-
-        // Enqueue its links for visiting.
-        for (String link : page.links) {
-          HttpUrl linkUrl = base.resolve(link);
-          if (linkUrl != null && !fetchedUrls.add(linkUrl)) {
-            crawlPage(linkUrl);
-          }
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(HttpUrl.parse("https://example.com/"))
+                .addConverterFactory(PageAdapter.FACTORY)
+                .client(okHttpClient)
+                .build();
+
+        PageService pageService = retrofit.create(PageService.class);
+
+        Crawler crawler = new Crawler(pageService);
+        crawler.crawlPage(HttpUrl.parse(args[0]));
+    }
+
+    interface PageService {
+        @GET
+        Call<Page> get(@Url HttpUrl url);
+    }
+
+    static class Page {
+        public final String title;
+        public final List<String> links;
+
+        public Page(String title, List<String> links) {
+            this.title = title;
+            this.links = links;
         }
-      }
-
-      @Override public void onFailure(Call<Page> call, Throwable t) {
-        System.out.println(call.request().url() + ": failed: " + t);
-      }
-    });
-  }
-
-  public static void main(String... args) throws Exception {
-    Dispatcher dispatcher = new Dispatcher(Executors.newFixedThreadPool(20));
-    dispatcher.setMaxRequests(20);
-    dispatcher.setMaxRequestsPerHost(1);
-
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .dispatcher(dispatcher)
-        .connectionPool(new ConnectionPool(100, 30, TimeUnit.SECONDS))
-        .build();
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(HttpUrl.parse("https://example.com/"))
-        .addConverterFactory(PageAdapter.FACTORY)
-        .client(okHttpClient)
-        .build();
-
-    PageService pageService = retrofit.create(PageService.class);
-
-    Crawler crawler = new Crawler(pageService);
-    crawler.crawlPage(HttpUrl.parse(args[0]));
-  }
-
-  interface PageService {
-    @GET Call<Page> get(@Url HttpUrl url);
-  }
-
-  static class Page {
-    public final String title;
-    public final List<String> links;
-
-    public Page(String title, List<String> links) {
-      this.title = title;
-      this.links = links;
     }
-  }
-
-  static final class PageAdapter implements Converter<ResponseBody, Page> {
-    static final Converter.Factory FACTORY = new Converter.Factory() {
-      @Override public Converter<ResponseBody, ?> responseBodyConverter(
-          Type type, Annotation[] annotations, Retrofit retrofit) {
-        if (type == Page.class) return new PageAdapter();
-        return null;
-      }
-    };
-
-    @Override public Page convert(ResponseBody responseBody) throws IOException {
-      Document document = Jsoup.parse(responseBody.string());
-      List<String> links = new ArrayList<>();
-      for (Element element : document.select("a[href]")) {
-        links.add(element.attr("href"));
-      }
-      return new Page(document.title(), Collections.unmodifiableList(links));
+
+    static final class PageAdapter implements Converter<ResponseBody, Page> {
+        static final Converter.Factory FACTORY = new Converter.Factory() {
+            @Override
+            public Converter<ResponseBody, ?> responseBodyConverter(
+                    Type type, Annotation[] annotations, Retrofit retrofit) {
+                if (type == Page.class) return new PageAdapter();
+                return null;
+            }
+        };
+
+        @Override
+        public Page convert(ResponseBody responseBody) throws IOException {
+            Document document = Jsoup.parse(responseBody.string());
+            List<String> links = new ArrayList<>();
+            for (Element element : document.select("a[href]")) {
+                links.add(element.attr("href"));
+            }
+            return new Page(document.title(), Collections.unmodifiableList(links));
+        }
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
index 4fc6c8669..af18dc56f 100644
--- a/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
+++ b/samples/src/main/java/com/example/retrofit/DeserializeErrorBody.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -28,46 +29,47 @@
 import retrofit2.http.GET;
 
 public final class DeserializeErrorBody {
-  interface Service {
-    @GET("/user") Call<User> getUser();
-  }
+    interface Service {
+        @GET("/user")
+        Call<User> getUser();
+    }
 
-  static class User {
-    // normal fields...
-  }
+    static class User {
+        // normal fields...
+    }
 
-  static class Error {
-    String message;
-  }
+    static class Error {
+        String message;
+    }
 
-  public static void main(String... args) throws IOException {
-    // Create a local web server which response with a 404 and JSON body.
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse()
-        .setResponseCode(404)
-        .setBody("{\"message\":\"Unable to locate resource\"}"));
+    public static void main(String... args) throws IOException {
+        // Create a local web server which response with a 404 and JSON body.
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse()
+                .setResponseCode(404)
+                .setBody("{\"message\":\"Unable to locate resource\"}"));
 
-    // Create our Service instance with a Retrofit pointing at the local web server and Gson.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-    Service service = retrofit.create(Service.class);
+        // Create our Service instance with a Retrofit pointing at the local web server and Gson.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+        Service service = retrofit.create(Service.class);
 
-    Response<User> response = service.getUser().execute();
+        Response<User> response = service.getUser().execute();
 
-    // Normally you would check response.isSuccess() here before doing the following, but we know
-    // this call will always fail. You could also use response.code() to determine whether to
-    // convert the error body and/or which type to use for conversion.
+        // Normally you would check response.isSuccess() here before doing the following, but we know
+        // this call will always fail. You could also use response.code() to determine whether to
+        // convert the error body and/or which type to use for conversion.
 
-    // Look up a converter for the Error type on the Retrofit instance.
-    Converter<ResponseBody, Error> errorConverter =
-        retrofit.responseBodyConverter(Error.class, new Annotation[0]);
-    // Convert the error body into our Error type.
-    Error error = errorConverter.convert(response.errorBody());
-    System.out.println("ERROR: " + error.message);
+        // Look up a converter for the Error type on the Retrofit instance.
+        Converter<ResponseBody, Error> errorConverter =
+                retrofit.responseBodyConverter(Error.class, new Annotation[0]);
+        // Convert the error body into our Error type.
+        Error error = errorConverter.convert(response.errorBody());
+        System.out.println("ERROR: " + error.message);
 
-    server.shutdown();
-  }
+        server.shutdown();
+    }
 }
diff --git a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
index 7507b840a..2290b1b27 100644
--- a/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
+++ b/samples/src/main/java/com/example/retrofit/DynamicBaseUrl.java
@@ -16,6 +16,7 @@
 package com.example.retrofit;
 
 import java.io.IOException;
+
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -32,55 +33,56 @@
  * that's nearest geographically.
  */
 public final class DynamicBaseUrl {
-  public interface Pop {
-    @GET("robots.txt")
-    Call<ResponseBody> robots();
-  }
+    public interface Pop {
+        @GET("robots.txt")
+        Call<ResponseBody> robots();
+    }
 
-  static final class HostSelectionInterceptor implements Interceptor {
-    private volatile String host;
+    static final class HostSelectionInterceptor implements Interceptor {
+        private volatile String host;
 
-    public void setHost(String host) {
-      this.host = host;
-    }
+        public void setHost(String host) {
+            this.host = host;
+        }
 
-    @Override public okhttp3.Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-      String host = this.host;
-      if (host != null) {
-        HttpUrl newUrl = request.url().newBuilder()
-            .host(host)
-            .build();
-        request = request.newBuilder()
-            .url(newUrl)
-            .build();
-      }
-      return chain.proceed(request);
+        @Override
+        public okhttp3.Response intercept(Chain chain) throws IOException {
+            Request request = chain.request();
+            String host = this.host;
+            if (host != null) {
+                HttpUrl newUrl = request.url().newBuilder()
+                                        .host(host)
+                                        .build();
+                request = request.newBuilder()
+                                 .url(newUrl)
+                                 .build();
+            }
+            return chain.proceed(request);
+        }
     }
-  }
 
-  public static void main(String... args) throws IOException {
-    HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
+    public static void main(String... args) throws IOException {
+        HostSelectionInterceptor hostSelectionInterceptor = new HostSelectionInterceptor();
 
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .addInterceptor(hostSelectionInterceptor)
-        .build();
+        OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                .addInterceptor(hostSelectionInterceptor)
+                .build();
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://www.coca-cola.com/")
-        .callFactory(okHttpClient)
-        .build();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://www.coca-cola.com/")
+                .callFactory(okHttpClient)
+                .build();
 
-    Pop pop = retrofit.create(Pop.class);
+        Pop pop = retrofit.create(Pop.class);
 
-    Response<ResponseBody> response1 = pop.robots().execute();
-    System.out.println("Response from: " + response1.raw().request().url());
-    System.out.println(response1.body().string());
+        Response<ResponseBody> response1 = pop.robots().execute();
+        System.out.println("Response from: " + response1.raw().request().url());
+        System.out.println(response1.body().string());
 
-    hostSelectionInterceptor.setHost("www.pepsi.com");
+        hostSelectionInterceptor.setHost("www.pepsi.com");
 
-    Response<ResponseBody> response2 = pop.robots().execute();
-    System.out.println("Response from: " + response2.raw().request().url());
-    System.out.println(response2.body().string());
-  }
+        Response<ResponseBody> response2 = pop.robots().execute();
+        System.out.println("Response from: " + response2.raw().request().url());
+        System.out.println(response2.body().string());
+    }
 }
diff --git a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
index 28e8521ac..557a070cc 100644
--- a/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
+++ b/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.concurrent.Executor;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Callback;
@@ -33,159 +34,185 @@
  * version whose callback has more granular methods.
  */
 public final class ErrorHandlingAdapter {
-  /** A callback which offers granular callbacks for various conditions. */
-  interface MyCallback<T> {
-    /** Called for [200, 300) responses. */
-    void success(Response<T> response);
-    /** Called for 401 responses. */
-    void unauthenticated(Response<?> response);
-    /** Called for [400, 500) responses, except 401. */
-    void clientError(Response<?> response);
-    /** Called for [500, 600) response. */
-    void serverError(Response<?> response);
-    /** Called for network errors while making the call. */
-    void networkError(IOException e);
-    /** Called for unexpected errors while making the call. */
-    void unexpectedError(Throwable t);
-  }
-
-  interface MyCall<T> {
-    void cancel();
-    void enqueue(MyCallback<T> callback);
-    MyCall<T> clone();
-
-    // Left as an exercise for the reader...
-    // TODO MyResponse<T> execute() throws MyHttpException;
-  }
-
-  public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
-    @Override public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
-        Retrofit retrofit) {
-      if (getRawType(returnType) != MyCall.class) {
-        return null;
-      }
-      if (!(returnType instanceof ParameterizedType)) {
-        throw new IllegalStateException(
-            "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
-      }
-      Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
-      Executor callbackExecutor = retrofit.callbackExecutor();
-      return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
-    }
+    /** A callback which offers granular callbacks for various conditions. */
+    interface MyCallback<T> {
+        /** Called for [200, 300) responses. */
+        void success(Response<T> response);
+
+        /** Called for 401 responses. */
+        void unauthenticated(Response<?> response);
 
-    private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
-      private final Type responseType;
-      private final Executor callbackExecutor;
+        /** Called for [400, 500) responses, except 401. */
+        void clientError(Response<?> response);
 
-      ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
-        this.responseType = responseType;
-        this.callbackExecutor = callbackExecutor;
-      }
+        /** Called for [500, 600) response. */
+        void serverError(Response<?> response);
 
-      @Override public Type responseType() {
-        return responseType;
-      }
+        /** Called for network errors while making the call. */
+        void networkError(IOException e);
 
-      @Override public MyCall<R> adapt(Call<R> call) {
-        return new MyCallAdapter<>(call, callbackExecutor);
-      }
+        /** Called for unexpected errors while making the call. */
+        void unexpectedError(Throwable t);
     }
-  }
 
-  /** Adapts a {@link Call} to {@link MyCall}. */
-  static class MyCallAdapter<T> implements MyCall<T> {
-    private final Call<T> call;
-    private final Executor callbackExecutor;
+    interface MyCall<T> {
+        void cancel();
+
+        void enqueue(MyCallback<T> callback);
+
+        MyCall<T> clone();
 
-    MyCallAdapter(Call<T> call, Executor callbackExecutor) {
-      this.call = call;
-      this.callbackExecutor = callbackExecutor;
+        // Left as an exercise for the reader...
+        // TODO MyResponse<T> execute() throws MyHttpException;
     }
 
-    @Override public void cancel() {
-      call.cancel();
+    public static class ErrorHandlingCallAdapterFactory extends CallAdapter.Factory {
+        @Override
+        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
+                Retrofit retrofit) {
+            if (getRawType(returnType) != MyCall.class) {
+                return null;
+            }
+            if (!(returnType instanceof ParameterizedType)) {
+                throw new IllegalStateException(
+                        "MyCall must have generic type (e.g., MyCall<ResponseBody>)");
+            }
+            Type responseType = getParameterUpperBound(0, (ParameterizedType) returnType);
+            Executor callbackExecutor = retrofit.callbackExecutor();
+            return new ErrorHandlingCallAdapter<>(responseType, callbackExecutor);
+        }
+
+        private static final class ErrorHandlingCallAdapter<R> implements CallAdapter<R, MyCall<R>> {
+            private final Type responseType;
+            private final Executor callbackExecutor;
+
+            ErrorHandlingCallAdapter(Type responseType, Executor callbackExecutor) {
+                this.responseType = responseType;
+                this.callbackExecutor = callbackExecutor;
+            }
+
+            @Override
+            public Type responseType() {
+                return responseType;
+            }
+
+            @Override
+            public MyCall<R> adapt(Call<R> call) {
+                return new MyCallAdapter<>(call, callbackExecutor);
+            }
+        }
     }
 
-    @Override public void enqueue(final MyCallback<T> callback) {
-      call.enqueue(new Callback<T>() {
-        @Override public void onResponse(Call<T> call, Response<T> response) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
-
-          int code = response.code();
-          if (code >= 200 && code < 300) {
-            callback.success(response);
-          } else if (code == 401) {
-            callback.unauthenticated(response);
-          } else if (code >= 400 && code < 500) {
-            callback.clientError(response);
-          } else if (code >= 500 && code < 600) {
-            callback.serverError(response);
-          } else {
-            callback.unexpectedError(new RuntimeException("Unexpected response " + response));
-          }
+    /** Adapts a {@link Call} to {@link MyCall}. */
+    static class MyCallAdapter<T> implements MyCall<T> {
+        private final Call<T> call;
+        private final Executor callbackExecutor;
+
+        MyCallAdapter(Call<T> call, Executor callbackExecutor) {
+            this.call = call;
+            this.callbackExecutor = callbackExecutor;
         }
 
-        @Override public void onFailure(Call<T> call, Throwable t) {
-          // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
-          // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+        @Override
+        public void cancel() {
+            call.cancel();
+        }
+
+        @Override
+        public void enqueue(final MyCallback<T> callback) {
+            call.enqueue(new Callback<T>() {
+                @Override
+                public void onResponse(Call<T> call, Response<T> response) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    int code = response.code();
+                    if (code >= 200 && code < 300) {
+                        callback.success(response);
+                    }
+                    else if (code == 401) {
+                        callback.unauthenticated(response);
+                    }
+                    else if (code >= 400 && code < 500) {
+                        callback.clientError(response);
+                    }
+                    else if (code >= 500 && code < 600) {
+                        callback.serverError(response);
+                    }
+                    else {
+                        callback.unexpectedError(new RuntimeException("Unexpected response " + response));
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<T> call, Throwable t) {
+                    // TODO if 'callbackExecutor' is not null, the 'callback' methods should be executed
+                    // on that executor by submitting a Runnable. This is left as an exercise for the reader.
+
+                    if (t instanceof IOException) {
+                        callback.networkError((IOException) t);
+                    }
+                    else {
+                        callback.unexpectedError(t);
+                    }
+                }
+            });
+        }
 
-          if (t instanceof IOException) {
-            callback.networkError((IOException) t);
-          } else {
-            callback.unexpectedError(t);
-          }
+        @Override
+        public MyCall<T> clone() {
+            return new MyCallAdapter<>(call.clone(), callbackExecutor);
         }
-      });
     }
 
-    @Override public MyCall<T> clone() {
-      return new MyCallAdapter<>(call.clone(), callbackExecutor);
+    interface HttpBinService {
+        @GET("/ip")
+        MyCall<Ip> getIp();
+    }
+
+    static class Ip {
+        String origin;
+    }
+
+    public static void main(String... args) {
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://httpbin.org")
+                .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
+
+        HttpBinService service = retrofit.create(HttpBinService.class);
+        MyCall<Ip> ip = service.getIp();
+        ip.enqueue(new MyCallback<Ip>() {
+            @Override
+            public void success(Response<Ip> response) {
+                System.out.println("SUCCESS! " + response.body().origin);
+            }
+
+            @Override
+            public void unauthenticated(Response<?> response) {
+                System.out.println("UNAUTHENTICATED");
+            }
+
+            @Override
+            public void clientError(Response<?> response) {
+                System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void serverError(Response<?> response) {
+                System.out.println("SERVER ERROR " + response.code() + " " + response.message());
+            }
+
+            @Override
+            public void networkError(IOException e) {
+                System.err.println("NETOWRK ERROR " + e.getMessage());
+            }
+
+            @Override
+            public void unexpectedError(Throwable t) {
+                System.err.println("FATAL ERROR " + t.getMessage());
+            }
+        });
     }
-  }
-
-  interface HttpBinService {
-    @GET("/ip")
-    MyCall<Ip> getIp();
-  }
-
-  static class Ip {
-    String origin;
-  }
-
-  public static void main(String... args) {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://httpbin.org")
-        .addCallAdapterFactory(new ErrorHandlingCallAdapterFactory())
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
-
-    HttpBinService service = retrofit.create(HttpBinService.class);
-    MyCall<Ip> ip = service.getIp();
-    ip.enqueue(new MyCallback<Ip>() {
-      @Override public void success(Response<Ip> response) {
-        System.out.println("SUCCESS! " + response.body().origin);
-      }
-
-      @Override public void unauthenticated(Response<?> response) {
-        System.out.println("UNAUTHENTICATED");
-      }
-
-      @Override public void clientError(Response<?> response) {
-        System.out.println("CLIENT ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void serverError(Response<?> response) {
-        System.out.println("SERVER ERROR " + response.code() + " " + response.message());
-      }
-
-      @Override public void networkError(IOException e) {
-        System.err.println("NETOWRK ERROR " + e.getMessage());
-      }
-
-      @Override public void unexpectedError(Throwable t) {
-        System.err.println("FATAL ERROR " + t.getMessage());
-      }
-    });
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
index 2163f3dec..568c977c9 100644
--- a/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonAndXmlConverters.java
@@ -19,13 +19,16 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+
 import org.simpleframework.xml.Attribute;
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
+
 import retrofit2.Call;
 import retrofit2.Converter;
 import retrofit2.Retrofit;
@@ -43,86 +46,90 @@
  * converter.
  */
 public final class JsonAndXmlConverters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  @Retention(RUNTIME)
-  @interface Xml {
-  }
+    @Retention(RUNTIME)
+    @interface Xml {
+    }
 
-  static class QualifiedTypeConverterFactory extends Converter.Factory {
-    private final Converter.Factory jsonFactory;
-    private final Converter.Factory xmlFactory;
+    static class QualifiedTypeConverterFactory extends Converter.Factory {
+        private final Converter.Factory jsonFactory;
+        private final Converter.Factory xmlFactory;
 
-    QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
-      this.jsonFactory = jsonFactory;
-      this.xmlFactory = xmlFactory;
-    }
+        QualifiedTypeConverterFactory(Converter.Factory jsonFactory, Converter.Factory xmlFactory) {
+            this.jsonFactory = jsonFactory;
+            this.xmlFactory = xmlFactory;
+        }
 
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+        @Override
+        public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+                Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+                }
+            }
+            return null;
         }
-        if (annotation instanceof Xml) {
-          return xmlFactory.responseBodyConverter(type, annotations, retrofit);
+
+        @Override
+        public Converter<?, RequestBody> requestBodyConverter(Type type,
+                Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+            for (Annotation annotation : parameterAnnotations) {
+                if (annotation instanceof Json) {
+                    return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+                if (annotation instanceof Xml) {
+                    return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+                            retrofit);
+                }
+            }
+            return null;
         }
-      }
-      return null;
     }
 
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      for (Annotation annotation : parameterAnnotations) {
-        if (annotation instanceof Json) {
-          return jsonFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-        if (annotation instanceof Xml) {
-          return xmlFactory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-      }
-      return null;
+    @Default(value = DefaultType.FIELD)
+    static class User {
+        @Attribute
+        public String name;
+    }
+
+    interface Service {
+        @GET("/")
+        @Json
+        Call<User> exampleJson();
+
+        @GET("/")
+        @Xml
+        Call<User> exampleXml();
+    }
+
+    public static void main(String... args) throws IOException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
+        server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new QualifiedTypeConverterFactory(
+                        GsonConverterFactory.create(),
+                        SimpleXmlConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        User user1 = service.exampleJson().execute().body();
+        System.out.println("User 1: " + user1.name);
+
+        User user2 = service.exampleXml().execute().body();
+        System.out.println("User 2: " + user2.name);
+
+        server.shutdown();
     }
-  }
-
-  @Default(value = DefaultType.FIELD)
-  static class User {
-    @Attribute
-    public String name;
-  }
-
-  interface Service {
-    @GET("/") @Json
-    Call<User> exampleJson();
-    @GET("/") @Xml
-    Call<User> exampleXml();
-  }
-
-  public static void main(String... args) throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Jason\"}"));
-    server.enqueue(new MockResponse().setBody("<user name=\"Eximel\"/>"));
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new QualifiedTypeConverterFactory(
-            GsonConverterFactory.create(),
-            SimpleXmlConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    User user1 = service.exampleJson().execute().body();
-    System.out.println("User 1: " + user1.name);
-
-    User user2 = service.exampleXml().execute().body();
-    System.out.println("User 2: " + user2.name);
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
index bc29f8355..9feef99c9 100644
--- a/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
+++ b/samples/src/main/java/com/example/retrofit/JsonQueryParameters.java
@@ -19,6 +19,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Retention;
 import java.lang.reflect.Type;
+
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.mockwebserver.MockResponse;
@@ -36,79 +37,81 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 public final class JsonQueryParameters {
-  @Retention(RUNTIME)
-  @interface Json {
-  }
+    @Retention(RUNTIME)
+    @interface Json {
+    }
 
-  static class JsonStringConverterFactory extends Converter.Factory {
-    private final Converter.Factory delegateFactory;
+    static class JsonStringConverterFactory extends Converter.Factory {
+        private final Converter.Factory delegateFactory;
 
-    JsonStringConverterFactory(Converter.Factory delegateFactory) {
-      this.delegateFactory = delegateFactory;
-    }
+        JsonStringConverterFactory(Converter.Factory delegateFactory) {
+            this.delegateFactory = delegateFactory;
+        }
 
-    @Override public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        if (annotation instanceof Json) {
-          // NOTE: If you also have a JSON converter factory installed in addition to this factory,
-          // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
-          // reference to it explicitly as a field.
-          Converter<?, RequestBody> delegate =
-              delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
-          return new DelegateToStringConverter<>(delegate);
+        @Override
+        public Converter<?, String> stringConverter(Type type, Annotation[] annotations,
+                Retrofit retrofit) {
+            for (Annotation annotation : annotations) {
+                if (annotation instanceof Json) {
+                    // NOTE: If you also have a JSON converter factory installed in addition to this factory,
+                    // you can call retrofit.requestBodyConverter(type, annotations) instead of having a
+                    // reference to it explicitly as a field.
+                    Converter<?, RequestBody> delegate =
+                            delegateFactory.requestBodyConverter(type, annotations, new Annotation[0], retrofit);
+                    return new DelegateToStringConverter<>(delegate);
+                }
+            }
+            return null;
+        }
+
+        static class DelegateToStringConverter<T> implements Converter<T, String> {
+            private final Converter<T, RequestBody> delegate;
+
+            DelegateToStringConverter(Converter<T, RequestBody> delegate) {
+                this.delegate = delegate;
+            }
+
+            @Override
+            public String convert(T value) throws IOException {
+                Buffer buffer = new Buffer();
+                delegate.convert(value).writeTo(buffer);
+                return buffer.readUtf8();
+            }
         }
-      }
-      return null;
     }
 
-    static class DelegateToStringConverter<T> implements Converter<T, String> {
-      private final Converter<T, RequestBody> delegate;
+    static class Filter {
+        public final String userId;
 
-      DelegateToStringConverter(Converter<T, RequestBody> delegate) {
-        this.delegate = delegate;
-      }
+        public Filter(String userId) {
+            this.userId = userId;
+        }
+    }
 
-      @Override public String convert(T value) throws IOException {
-        Buffer buffer = new Buffer();
-        delegate.convert(value).writeTo(buffer);
-        return buffer.readUtf8();
-      }
+    interface Service {
+        @GET("/filter")
+        Call<ResponseBody> example(@Json @Query("value") Filter value);
     }
-  }
 
-  static class Filter {
-    public final String userId;
+    public static void main(String... args) throws IOException, InterruptedException {
+        MockWebServer server = new MockWebServer();
+        server.start();
+        server.enqueue(new MockResponse());
+
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(server.url("/"))
+                .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
+                .build();
+        Service service = retrofit.create(Service.class);
+
+        Call<ResponseBody> call = service.example(new Filter("123"));
+        Response<ResponseBody> response = call.execute();
+        // TODO handle user response...
+
+        // Print the request path that the server saw to show the JSON query param:
+        RecordedRequest recordedRequest = server.takeRequest();
+        System.out.println(recordedRequest.getPath());
 
-    public Filter(String userId) {
-      this.userId = userId;
+        server.shutdown();
     }
-  }
-
-  interface Service {
-    @GET("/filter")
-    Call<ResponseBody> example(@Json @Query("value") Filter value);
-  }
-
-  public static void main(String... args) throws IOException, InterruptedException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse());
-
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new JsonStringConverterFactory(GsonConverterFactory.create()))
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Call<ResponseBody> call = service.example(new Filter("123"));
-    Response<ResponseBody> response = call.execute();
-    // TODO handle user response...
-
-    // Print the request path that the server saw to show the JSON query param:
-    RecordedRequest recordedRequest = server.takeRequest();
-    System.out.println(recordedRequest.getPath());
-
-    server.shutdown();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
index 6c4fec40d..b5fffcb42 100644
--- a/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
+++ b/samples/src/main/java/com/example/retrofit/RxJavaObserveOnMainThread.java
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+
 import retrofit2.Call;
 import retrofit2.CallAdapter;
 import retrofit2.Retrofit;
@@ -28,50 +29,52 @@
 import static rx.schedulers.Schedulers.io;
 
 public final class RxJavaObserveOnMainThread {
-  public static void main(String... args) {
-    Scheduler observeOn = Schedulers.computation(); // Or use mainThread() for Android.
+    public static void main(String... args) {
+        Scheduler observeOn = Schedulers.computation(); // Or use mainThread() for Android.
 
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl("http://example.com")
-        .addCallAdapterFactory(new ObserveOnMainCallAdapterFactory(observeOn))
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(io()))
-        .build();
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl("http://example.com")
+                .addCallAdapterFactory(new ObserveOnMainCallAdapterFactory(observeOn))
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.createWithScheduler(io()))
+                .build();
 
-    // Services created with this instance that use Observable will execute on the 'io' scheduler
-    // and notify their observer on the 'computation' scheduler.
-  }
+        // Services created with this instance that use Observable will execute on the 'io' scheduler
+        // and notify their observer on the 'computation' scheduler.
+    }
 
-  static final class ObserveOnMainCallAdapterFactory extends CallAdapter.Factory {
-    final Scheduler scheduler;
+    static final class ObserveOnMainCallAdapterFactory extends CallAdapter.Factory {
+        final Scheduler scheduler;
 
-    ObserveOnMainCallAdapterFactory(Scheduler scheduler) {
-      this.scheduler = scheduler;
-    }
+        ObserveOnMainCallAdapterFactory(Scheduler scheduler) {
+            this.scheduler = scheduler;
+        }
 
-    @Override
-    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-      if (getRawType(returnType) != Observable.class) {
-        return null; // Ignore non-Observable types.
-      }
+        @Override
+        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
+            if (getRawType(returnType) != Observable.class) {
+                return null; // Ignore non-Observable types.
+            }
 
-      // Look up the next call adapter which would otherwise be used if this one was not present.
-      //noinspection unchecked returnType checked above to be Observable.
-      final CallAdapter<Object, Observable<?>> delegate =
-          (CallAdapter<Object, Observable<?>>) retrofit.nextCallAdapter(this, returnType,
-              annotations);
+            // Look up the next call adapter which would otherwise be used if this one was not present.
+            //noinspection unchecked returnType checked above to be Observable.
+            final CallAdapter<Object, Observable<?>> delegate =
+                    (CallAdapter<Object, Observable<?>>) retrofit.nextCallAdapter(this, returnType,
+                            annotations);
 
-      return new CallAdapter<Object, Object>() {
-        @Override public Object adapt(Call<Object> call) {
-          // Delegate to get the normal Observable...
-          Observable<?> o = delegate.adapt(call);
-          // ...and change it to send notifications to the observer on the specified scheduler.
-          return o.observeOn(scheduler);
-        }
+            return new CallAdapter<Object, Object>() {
+                @Override
+                public Object adapt(Call<Object> call) {
+                    // Delegate to get the normal Observable...
+                    Observable<?> o = delegate.adapt(call);
+                    // ...and change it to send notifications to the observer on the specified scheduler.
+                    return o.observeOn(scheduler);
+                }
 
-        @Override public Type responseType() {
-          return delegate.responseType();
+                @Override
+                public Type responseType() {
+                    return delegate.responseType();
+                }
+            };
         }
-      };
     }
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleMockService.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 347c911af..9e43a1f99 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleMockService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -3,6 +3,7 @@
 
 import com.example.retrofit.SimpleService.Contributor;
 import com.example.retrofit.SimpleService.GitHub;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+
 import retrofit2.Call;
 import retrofit2.Retrofit;
 import retrofit2.mock.BehaviorDelegate;
@@ -21,89 +23,90 @@
  * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
  */
 public final class SimpleMockService {
-  /** A mock implementation of the {@link GitHub} API interface. */
-  static final class MockGitHub implements GitHub {
-    private final BehaviorDelegate<GitHub> delegate;
-    private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
-
-    public MockGitHub(BehaviorDelegate<GitHub> delegate) {
-      this.delegate = delegate;
-      ownerRepoContributors = new LinkedHashMap<>();
-
-      // Seed some mock data.
-      addContributor("square", "retrofit", "John Doe", 12);
-      addContributor("square", "retrofit", "Bob Smith", 2);
-      addContributor("square", "retrofit", "Big Bird", 40);
-      addContributor("square", "picasso", "Proposition Joe", 39);
-      addContributor("square", "picasso", "Keiser Soze", 152);
-    }
+    /** A mock implementation of the {@link GitHub} API interface. */
+    static final class MockGitHub implements GitHub {
+        private final BehaviorDelegate<GitHub> delegate;
+        private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
+
+        public MockGitHub(BehaviorDelegate<GitHub> delegate) {
+            this.delegate = delegate;
+            ownerRepoContributors = new LinkedHashMap<>();
+
+            // Seed some mock data.
+            addContributor("square", "retrofit", "John Doe", 12);
+            addContributor("square", "retrofit", "Bob Smith", 2);
+            addContributor("square", "retrofit", "Big Bird", 40);
+            addContributor("square", "picasso", "Proposition Joe", 39);
+            addContributor("square", "picasso", "Keiser Soze", 152);
+        }
+
+        @Override
+        public Call<List<Contributor>> contributors(String owner, String repo) {
+            List<Contributor> response = Collections.emptyList();
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors != null) {
+                List<Contributor> contributors = repoContributors.get(repo);
+                if (contributors != null) {
+                    response = contributors;
+                }
+            }
+            return delegate.returningResponse(response).contributors(owner, repo);
+        }
 
-    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
-      List<Contributor> response = Collections.emptyList();
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors != null) {
-        List<Contributor> contributors = repoContributors.get(repo);
-        if (contributors != null) {
-          response = contributors;
+        public void addContributor(String owner, String repo, String name, int contributions) {
+            Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
+            if (repoContributors == null) {
+                repoContributors = new LinkedHashMap<>();
+                ownerRepoContributors.put(owner, repoContributors);
+            }
+            List<Contributor> contributors = repoContributors.get(repo);
+            if (contributors == null) {
+                contributors = new ArrayList<>();
+                repoContributors.put(repo, contributors);
+            }
+            contributors.add(new Contributor(name, contributions));
         }
-      }
-      return delegate.returningResponse(response).contributors(owner, repo);
     }
 
-    public void addContributor(String owner, String repo, String name, int contributions) {
-      Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<>();
-        ownerRepoContributors.put(owner, repoContributors);
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        contributors = new ArrayList<>();
-        repoContributors.put(repo, contributors);
-      }
-      contributors.add(new Contributor(name, contributions));
+    public static void main(String... args) throws IOException {
+        // Create a very simple Retrofit adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(SimpleService.API_URL)
+                .build();
+
+        // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
+        NetworkBehavior behavior = NetworkBehavior.create();
+        MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
+                .networkBehavior(behavior)
+                .build();
+
+        BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
+        MockGitHub gitHub = new MockGitHub(delegate);
+
+        // Query for some contributors for a few repositories.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
+
+        // Using the mock-only methods, add some additional data.
+        System.out.println("Adding more mock data...\n");
+        gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
+        gitHub.addContributor("square", "picasso", "Kit Kat", 53);
+
+        // Reduce the delay to make the next calls complete faster.
+        behavior.setDelay(500, TimeUnit.MILLISECONDS);
+
+        // Query for the contributors again so we can see the mock data that was added.
+        printContributors(gitHub, "square", "retrofit");
+        printContributors(gitHub, "square", "picasso");
     }
-  }
-
-  public static void main(String... args) throws IOException {
-    // Create a very simple Retrofit adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(SimpleService.API_URL)
-        .build();
-
-    // Create a MockRetrofit object with a NetworkBehavior which manages the fake behavior of calls.
-    NetworkBehavior behavior = NetworkBehavior.create();
-    MockRetrofit mockRetrofit = new MockRetrofit.Builder(retrofit)
-        .networkBehavior(behavior)
-        .build();
-
-    BehaviorDelegate<GitHub> delegate = mockRetrofit.create(GitHub.class);
-    MockGitHub gitHub = new MockGitHub(delegate);
-
-    // Query for some contributors for a few repositories.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-
-    // Using the mock-only methods, add some additional data.
-    System.out.println("Adding more mock data...\n");
-    gitHub.addContributor("square", "retrofit", "Foo Bar", 61);
-    gitHub.addContributor("square", "picasso", "Kit Kat", 53);
-
-    // Reduce the delay to make the next calls complete faster.
-    behavior.setDelay(500, TimeUnit.MILLISECONDS);
-
-    // Query for the contributors again so we can see the mock data that was added.
-    printContributors(gitHub, "square", "retrofit");
-    printContributors(gitHub, "square", "picasso");
-  }
-
-  private static void printContributors(GitHub gitHub, String owner, String repo)
-      throws IOException {
-    System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors.execute().body()) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+
+    private static void printContributors(GitHub gitHub, String owner, String repo)
+            throws IOException {
+        System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
+        Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+        for (Contributor contributor : contributors.execute().body()) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
+        System.out.println();
     }
-    System.out.println();
-  }
 }
diff --git a/samples/src/main/java/com/example/retrofit/SimpleService.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
index ef5a3060e..afc502e14 100644
--- a/samples/src/main/java/com/example/retrofit/SimpleService.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.util.List;
+
 import retrofit2.Call;
 import retrofit2.converter.gson.GsonConverterFactory;
 import retrofit2.Retrofit;
@@ -24,42 +25,42 @@
 import retrofit2.http.Path;
 
 public final class SimpleService {
-  public static final String API_URL = "https://api.github.com";
+    public static final String API_URL = "https://api.github.com";
 
-  public static class Contributor {
-    public final String login;
-    public final int contributions;
+    public static class Contributor {
+        public final String login;
+        public final int contributions;
 
-    public Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
+        public Contributor(String login, int contributions) {
+            this.login = login;
+            this.contributions = contributions;
+        }
     }
-  }
 
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    Call<List<Contributor>> contributors(
-        @Path("owner") String owner,
-        @Path("repo") String repo);
-  }
+    public interface GitHub {
+        @GET("/repos/{owner}/{repo}/contributors")
+        Call<List<Contributor>> contributors(
+                @Path("owner") String owner,
+                @Path("repo") String repo);
+    }
 
-  public static void main(String... args) throws IOException {
-    // Create a very simple REST adapter which points the GitHub API.
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(API_URL)
-        .addConverterFactory(GsonConverterFactory.create())
-        .build();
+    public static void main(String... args) throws IOException {
+        // Create a very simple REST adapter which points the GitHub API.
+        Retrofit retrofit = new Retrofit.Builder()
+                .baseUrl(API_URL)
+                .addConverterFactory(GsonConverterFactory.create())
+                .build();
 
-    // Create an instance of our GitHub API interface.
-    GitHub github = retrofit.create(GitHub.class);
+        // Create an instance of our GitHub API interface.
+        GitHub github = retrofit.create(GitHub.class);
 
-    // Create a call instance for looking up Retrofit contributors.
-    Call<List<Contributor>> call = github.contributors("square", "retrofit");
+        // Create a call instance for looking up Retrofit contributors.
+        Call<List<Contributor>> call = github.contributors("square", "retrofit");
 
-    // Fetch and print a list of the contributors to the library.
-    List<Contributor> contributors = call.execute().body();
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        // Fetch and print a list of the contributors to the library.
+        List<Contributor> contributors = call.execute().body();
+        for (Contributor contributor : contributors) {
+            System.out.println(contributor.login + " (" + contributor.contributions + ")");
+        }
     }
-  }
 }
diff --git a/website/index.html b/website/index.html
index 85358cfbf..a6cf179a9 100644
--- a/website/index.html
+++ b/website/index.html
@@ -1,6 +1,6 @@
 <!DOCTYPE html>
 <html lang="en">
-  <head>
+<head>
     <meta charset="utf-8">
     <title>Retrofit</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
@@ -8,171 +8,218 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
-    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
-  </head>
-  <body data-target=".content-nav">
-    <header>
-      <div class="container">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet"
+          type="text/css">
+    <!--[if lt IE 9]>
+    <script src="static/html5shiv.min.js"></script><![endif]-->
+</head>
+<body data-target=".content-nav">
+<header>
+    <div class="container">
         <div class="row">
-          <div class="span5">
-            <h1>Retrofit</h1>
-          </div>
-          <div class="span7">
-            <menu>
-              <ul>
-                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/retrofit" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
-              </ul>
-            </menu>
-          </div>
+            <div class="span5">
+                <h1>Retrofit</h1>
+            </div>
+            <div class="span7">
+                <menu>
+                    <ul>
+                        <li><a href="#download" class="menu download">Download <span
+                                class="version-tag">Latest</span></a></li>
+                        <li><a href="http://github.com/square/retrofit" data-title="View GitHub Project"
+                               class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                        <li><a href="http://square.github.io/" data-title="Square Open Source Portal"
+                               class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                    </ul>
+                </menu>
+            </div>
         </div>
-      </div>
-    </header>
-    <section id="subtitle">
-      <div class="container">
+    </div>
+</header>
+<section id="subtitle">
+    <div class="container">
         <div class="row">
-          <div class="span12">
-            <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
-          </div>
+            <div class="span12">
+                <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
+            </div>
         </div>
-      </div>
-    </section>
-    <section id="body">
-      <div class="container">
+    </div>
+</section>
+<section id="body">
+    <div class="container">
         <div class="row">
-          <div class="span9">
-            <section id="introduction">
-              <h3>Introduction</h3>
-              <p>Retrofit turns your HTTP API into a Java interface.</p>
-              <pre class="prettyprint">public interface GitHubService {
+            <div class="span9">
+                <section id="introduction">
+                    <h3>Introduction</h3>
+                    <p>Retrofit turns your HTTP API into a Java interface.</p>
+                    <pre class="prettyprint">public interface GitHubService {
   @GET("users/{user}/repos")
   Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-              <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-              <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+                    <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code>
+                        interface.</p>
+                    <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.github.com/")
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-              <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
-              <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
-              <p>Use annotations to describe the HTTP request:</p>
-              <ul>
-                <li>URL parameter replacement and query parameter support</li>
-                <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
-                <li>Multipart request body and file upload</li>
-              </ul>
-            </section>
+                    <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or
+                        asynchronous HTTP request to the remote webserver.</p>
+                    <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
+                    <p>Use annotations to describe the HTTP request:</p>
+                    <ul>
+                        <li>URL parameter replacement and query parameter support</li>
+                        <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
+                        <li>Multipart request body and file upload</li>
+                    </ul>
+                </section>
 
-            <section id="api-declaration">
-              <h3>API Declaration</h3>
-              <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
+                <section id="api-declaration">
+                    <h3>API Declaration</h3>
+                    <p>Annotations on the interface methods and its parameters indicate how a request will be
+                        handled.</p>
 
-              <h4>Request Method</h4>
-              <p>Every method must have an HTTP annotation that provides the request method and relative URL. There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the annotation.</p>
-              <pre class="prettyprint">@GET("users/list")</pre>
-              <p>You can also specify query parameters in the URL.</p>
-              <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
+                    <h4>Request Method</h4>
+                    <p>Every method must have an HTTP annotation that provides the request method and relative URL.
+                        There are five built-in annotations: <code>GET</code>, <code>POST</code>, <code>PUT</code>,
+                        <code>DELETE</code>, and <code>HEAD</code>. The relative URL of the resource is specified in the
+                        annotation.</p>
+                    <pre class="prettyprint">@GET("users/list")</pre>
+                    <p>You can also specify query parameters in the URL.</p>
+                    <pre class="prettyprint">@GET("users/list?sort=desc")</pre>
 
-              <h4>URL Manipulation</h4>
-              <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
-              <pre class="prettyprint">@GET("group/{id}/users")
+                    <h4>URL Manipulation</h4>
+                    <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A
+                        replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A
+                        corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
+                    <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId);</pre>
-              <p>Query parameters can also be added.</p>
-              <pre class="prettyprint">@GET("group/{id}/users")
+                    <p>Query parameters can also be added.</p>
+                    <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @Query("sort") String sort);</pre>
-              <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
-              <pre class="prettyprint">@GET("group/{id}/users")
+                    <p>For complex query parameter combinations a <code>Map</code> can be used.</p>
+                    <pre class="prettyprint">@GET("group/{id}/users")
 Call&lt;List&lt;User>> groupList(@Path("id") int groupId, @QueryMap Map&lt;String, String&gt; options);</pre>
 
-              <h4>Request Body</h4>
-              <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
-              <pre class="prettyprint">@POST("users/new")
+                    <h4>Request Body</h4>
+                    <p>An object can be specified for use as an HTTP request body with the <code>@Body</code>
+                        annotation.</p>
+                    <pre class="prettyprint">@POST("users/new")
 Call&lt;User> createUser(@Body User user);</pre>
-              <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
+                    <p>The object will also be converted using a converter specified on the <code>Retrofit</code>
+                        instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
-              <h4>Form Encoded and Multipart</h4>
-              <p>Methods can also be declared to send form-encoded and multipart data.</p>
-              <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
-              <pre class="prettyprint">@FormUrlEncoded
+                    <h4>Form Encoded and Multipart</h4>
+                    <p>Methods can also be declared to send form-encoded and multipart data.</p>
+                    <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each
+                        key-value pair is annotated with <code>@Field</code> containing the name and the object
+                        providing the value.</p>
+                    <pre class="prettyprint">@FormUrlEncoded
 @POST("user/edit")
 Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
-              <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
-              <pre class="prettyprint">@Multipart
+                    <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are
+                        declared using the <code>@Part</code> annotation.</p>
+                    <pre class="prettyprint">@Multipart
 @PUT("user/photo")
 Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
-              <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
+                    <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code>
+                        to handle their own serialization.</p>
 
-              <h4>Header Manipulation</h4>
-              <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
-              <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
+                    <h4>Header Manipulation</h4>
+                    <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
+                    <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("widget/list")
 Call&lt;List&lt;Widget>> widgetList();</pre>
-              <pre class="prettyprint">@Headers({
+                    <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
 @GET("users/{username}")
 Call&lt;User> getUser(@Path("username") String username);</pre>
-              <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
-              <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
-              <pre class="prettyprint">@GET("user")
+                    <p>Note that headers do not overwrite each other. All headers with the same name will be included in
+                        the request.</p>
+                    <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A
+                        corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the
+                        header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the
+                        result used.</p>
+                    <pre class="prettyprint">@GET("user")
 Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
-              <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
+                    <p>Headers that need to be added to every request can be specified using an <a
+                            href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
 
-              <h4>Synchronous vs. Asynchronous</h4>
-              <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
-              <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
-            </section>
+                    <h4>Synchronous vs. Asynchronous</h4>
+                    <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance
+                        can only be used once, but calling <code>clone()</code> will create a new instance that can be
+                        used.</p>
+                    <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on
+                        the same thread that executed the HTTP request.</p>
+                </section>
 
-            <section id="restadapter-configuration">
-              <h3>Retrofit Configuration</h3>
-              <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
+                <section id="restadapter-configuration">
+                    <h3>Retrofit Configuration</h3>
+                    <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable
+                        objects. By default, Retrofit will give you sane defaults for your platform but it allows for
+                        customization.</p>
 
-              <h4>Converters</h4>
-              <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
-              <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
-              <ul>
-                <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code></li>
-                <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code></li>
-                <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code></li>
-                <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code></li>
-                <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code></li>
-                <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code></li>
-                <li>Scalars (primitives, boxed, and String): <code>com.squareup.retrofit2:converter-scalars</code></li>
-              </ul>
-              <p>Here's an example of using the <code>GsonConverterFactory</code> class to generate an implementation of the <code>GitHubService</code> interface which uses Gson for its deserialization.</p>
-              <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+                    <h4>Converters</h4>
+                    <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code>
+                        type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
+                    <p>Converters can be added to support other types. Six sibling modules adapt popular serialization
+                        libraries for your convenience.</p>
+                    <ul>
+                        <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit2:converter-gson</code>
+                        </li>
+                        <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit2:converter-jackson</code>
+                        </li>
+                        <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit2:converter-moshi</code>
+                        </li>
+                        <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit2:converter-protobuf</code>
+                        </li>
+                        <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit2:converter-wire</code>
+                        </li>
+                        <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit2:converter-simplexml</code>
+                        </li>
+                        <li>Scalars (primitives, boxed, and String):
+                            <code>com.squareup.retrofit2:converter-scalars</code></li>
+                    </ul>
+                    <p>Here's an example of using the <code>GsonConverterFactory</code> class to generate an
+                        implementation of the <code>GitHubService</code> interface which uses Gson for its
+                        deserialization.</p>
+                    <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
     .baseUrl("https://api.github.com")
     .addConverterFactory(GsonConverterFactory.create())
     .build();
 
 GitHubService service = retrofit.create(GitHubService.class);</pre>
-              <h4>Custom Converters</h4>
-              <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that extends the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code> class</a> and pass in an instance when building your adapter.</p>
-            </section>
+                    <h4>Custom Converters</h4>
+                    <p>If you need to communicate with an API that uses a content-format that Retrofit does not support
+                        out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to
+                        implement an existing format, you can easily create your own converter. Create a class that
+                        extends the <a
+                                href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/Converter.java"><code>Converter.Factory</code>
+                            class</a> and pass in an instance when building your adapter.</p>
+                </section>
 
-            <section id="download">
-              <h3>Download</h3>
-              <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-              <p>The source code to the Retrofit, its samples, and this website is <a href="http://github.com/square/retrofit">available on GitHub</a>.</p>
-              <h4>Maven</h4>
-              <pre class="prettyprint">&lt;dependency>
+                <section id="download">
+                    <h3>Download</h3>
+                    <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit2&a=retrofit&v=LATEST"
+                          class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+                    <p>The source code to the Retrofit, its samples, and this website is <a
+                            href="http://github.com/square/retrofit">available on GitHub</a>.</p>
+                    <h4>Maven</h4>
+                    <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.retrofit2&lt;/groupId>
   &lt;artifactId>retrofit&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
-              <h4>Gradle</h4>
-              <pre class="prettyprint">
+                    <h4>Gradle</h4>
+                    <pre class="prettyprint">
 compile 'com.squareup.retrofit2:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-              <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
+                    <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-              <h4>ProGuard</h4>
-              <p>If you are using Proguard in your project add the following lines to your configuration:</p>
-              <pre class="prettyprint">
+                    <h4>ProGuard</h4>
+                    <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+                    <pre class="prettyprint">
 # Platform calls Class.forName on types which do not exist on Android to determine platform.
 -dontnote retrofit2.Platform
 # Platform used when running on Java 8 VMs. Will not be used at runtime.
@@ -182,18 +229,22 @@ <h4>ProGuard</h4>
 # Retain declared checked exceptions for use by a Proxy instance.
 -keepattributes Exceptions
 </pre>
-            </section>
+                </section>
 
-            <section id="contributing">
-              <h3>Contributing</h3>
-              <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-              <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-              <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
-            </section>
+                <section id="contributing">
+                    <h3>Contributing</h3>
+                    <p>If you would like to contribute code you can do so through GitHub by forking the repository and
+                        sending a pull request.</p>
+                    <p>When submitting code, please make every effort to follow existing conventions and style in order
+                        to keep the code as readable as possible. Please also make sure your code compiles by running
+                        <code>mvn clean verify</code>.</p>
+                    <p>Before your code can be accepted into the project you must also sign the <a
+                            href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+                </section>
 
-            <section id="license">
-              <h3>License</h3>
-              <pre>Copyright 2013 Square, Inc.
+                <section id="license">
+                    <h3>License</h3>
+                    <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -206,39 +257,40 @@ <h3>License</h3>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.</pre>
-            </section>
-          </div>
-          <div class="span3">
-            <div class="content-nav" data-spy="affix" data-offset-top="80">
-              <ul class="nav nav-tabs nav-stacked primary">
-                <li><a href="#introduction">Introduction</a></li>
-                <li><a href="#api-declaration">API Declaration</a></li>
-                <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
-                <li><a href="#download">Download</a></li>
-                <li><a href="#contributing">Contributing</a></li>
-                <li><a href="#license">License</a></li>
-              </ul>
-              <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="2.x/retrofit/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a></li>
-              </ul>
+                </section>
+            </div>
+            <div class="span3">
+                <div class="content-nav" data-spy="affix" data-offset-top="80">
+                    <ul class="nav nav-tabs nav-stacked primary">
+                        <li><a href="#introduction">Introduction</a></li>
+                        <li><a href="#api-declaration">API Declaration</a></li>
+                        <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
+                        <li><a href="#download">Download</a></li>
+                        <li><a href="#contributing">Contributing</a></li>
+                        <li><a href="#license">License</a></li>
+                    </ul>
+                    <ul class="nav nav-pills nav-stacked secondary">
+                        <li><a href="2.x/retrofit/">Javadoc</a></li>
+                        <li><a href="http://stackoverflow.com/questions/tagged/retrofit?sort=active">StackOverflow</a>
+                        </li>
+                    </ul>
+                </div>
             </div>
-          </div>
         </div>
         <div class="row">
-          <div class="span12 logo">
-            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
-          </div>
+            <div class="span12 logo">
+                <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
+            </div>
         </div>
-      </div>
-    </section>
-    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
-    <script src="static/bootstrap.min.js"></script>
-    <script src="static/jquery.smooth-scroll.min.js"></script>
-    <script src="static/jquery-maven-artifact.min.js"></script>
-    <script src="static/prettify.js"></script>
-    <script type="text/javascript">
-      $(function() {
+    </div>
+</section>
+<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+<script src="static/bootstrap.min.js"></script>
+<script src="static/jquery.smooth-scroll.min.js"></script>
+<script src="static/jquery-maven-artifact.min.js"></script>
+<script src="static/prettify.js"></script>
+<script type="text/javascript">
+    $(function () {
         // Syntax highlight code blocks.
         prettyPrint();
 
@@ -250,30 +302,37 @@ <h3>License</h3>
 
         // Enable tooltips on the header nav image items.
         $('.menu').tooltip({
-          placement: 'bottom',
-          trigger: 'hover',
-          container: 'body',
-          delay: {
-            show: 500,
-            hide: 0
-          }
+            placement: 'bottom',
+            trigger: 'hover',
+            container: 'body',
+            delay: {
+                show: 500,
+                hide: 0
+            }
         });
 
         // Look up the latest version of the library.
-        $.fn.artifactVersion('com.squareup.retrofit2', 'retrofit', function(version, url) {
-          $('.version').text(version);
-          $('.version-tag').text('v' + version);
-          $('.version-href').attr('href', url);
+        $.fn.artifactVersion('com.squareup.retrofit2', 'retrofit', function (version, url) {
+            $('.version').text(version);
+            $('.version-tag').text('v' + version);
+            $('.version-href').attr('href', url);
         });
-      });
+    });
 
-      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
+    (function (i, s, o, g, r, a, m) {
+        i['GoogleAnalyticsObject'] = r;
+        i[r] = i[r] || function () {
+                (i[r].q = i[r].q || []).push(arguments)
+            }, i[r].l = 1 * new Date();
+        a = s.createElement(o),
+            m = s.getElementsByTagName(o)[0];
+        a.async = 1;
+        a.src = g;
+        m.parentNode.insertBefore(a, m)
+    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
 
-      ga('create', 'UA-40704740-4', 'github.io');
-      ga('send', 'pageview');
-    </script>
-  </body>
+    ga('create', 'UA-40704740-4', 'github.io');
+    ga('send', 'pageview');
+</script>
+</body>
 </html>
diff --git a/website/static/app-theme.css b/website/static/app-theme.css
index dd6303559..fba7923f4 100644
--- a/website/static/app-theme.css
+++ b/website/static/app-theme.css
@@ -5,47 +5,91 @@
 header,
 #subtitle,
 a.dl {
-  background-color: #48b983;
+    background-color: #48b983;
 }
 
 .content-nav li.active a,
 .content-nav li.active a:hover {
-  border-left-color: #48b983;
+    border-left-color: #48b983;
 }
 
 /*** One step left on the monochromatic scale ***/
 
 header menu li a:hover,
 a.dl:hover {
-  background-color: #40a776;
+    background-color: #40a776;
 }
+
 a {
-  color: #40a776;
+    color: #40a776;
 }
 
 /*** Three steps left on the monochromatic scale ***/
 
 a:hover {
-  color: #32835c;
+    color: #32835c;
 }
 
-
 /****************************************************************\
  **** Syntax highlighting styles ********************************
 \****************************************************************/
 
-.pln { color: #000; }
-.str { color: #32835b; }
-.kwd { color: #666; }
-.com { color: #800; }
-.typ { color: #222; }
-.lit { color: #666; }
-.pun { color: #888; }
-.opn { color: #888; }
-.clo { color: #888; }
-.tag { color: #32835b; }
-.atn { color: #606; }
-.atv { color: #080; }
-.dec { color: #606; }
-.var { color: #606; }
-.fun { color: #f00; }
+.pln {
+    color: #000;
+}
+
+.str {
+    color: #32835b;
+}
+
+.kwd {
+    color: #666;
+}
+
+.com {
+    color: #800;
+}
+
+.typ {
+    color: #222;
+}
+
+.lit {
+    color: #666;
+}
+
+.pun {
+    color: #888;
+}
+
+.opn {
+    color: #888;
+}
+
+.clo {
+    color: #888;
+}
+
+.tag {
+    color: #32835b;
+}
+
+.atn {
+    color: #606;
+}
+
+.atv {
+    color: #080;
+}
+
+.dec {
+    color: #606;
+}
+
+.var {
+    color: #606;
+}
+
+.fun {
+    color: #f00;
+}
diff --git a/website/static/app.css b/website/static/app.css
index e3574b739..7cee0aefc 100644
--- a/website/static/app.css
+++ b/website/static/app.css
@@ -1,188 +1,208 @@
 html, body {
-  font-family: 'Roboto', sans-serif;
-  font-size: 15px;
+    font-family: 'Roboto', sans-serif;
+    font-size: 15px;
 }
+
 body {
-  background-color: #f6f6f6;
-  padding-bottom: 50px;
-  padding-top: 80px;
+    background-color: #f6f6f6;
+    padding-bottom: 50px;
+    padding-top: 80px;
 }
 
 header {
-  min-height: 80px;
-  color: #f6f6f6;
-  position: fixed;
-  top: 0;
-  left: 0;
-  width: 100%;
-  z-index: 99;
+    min-height: 80px;
+    color: #f6f6f6;
+    position: fixed;
+    top: 0;
+    left: 0;
+    width: 100%;
+    z-index: 99;
 }
+
 header h1 {
-  margin: 10px 0;
-  font-size: 50px;
-  line-height: 60px;
-  font-weight: 100;
-  text-rendering: auto;
+    margin: 10px 0;
+    font-size: 50px;
+    line-height: 60px;
+    font-weight: 100;
+    text-rendering: auto;
 }
+
 header menu {
-  margin: 20px 0 0;
-  padding: 0;
-  height: 40px;
+    margin: 20px 0 0;
+    padding: 0;
+    height: 40px;
 }
+
 header menu ul {
-  margin: 0;
-  padding: 0;
-  float: right;
+    margin: 0;
+    padding: 0;
+    float: right;
 }
+
 header menu li {
-  list-style: none;
-  float: left;
-  margin: 0;
-  padding: 0;
+    list-style: none;
+    float: left;
+    margin: 0;
+    padding: 0;
 }
+
 header menu li a {
-  display: inline-block;
-  height: 40px;
-  font-size: 17px;
-  line-height: 40px;
-  padding: 0 20px;
-  color: #f6f6f6;
+    display: inline-block;
+    height: 40px;
+    font-size: 17px;
+    line-height: 40px;
+    padding: 0 20px;
+    color: #f6f6f6;
 }
+
 header menu li a:hover {
-  color: #f6f6f6;
-  text-decoration: none;
+    color: #f6f6f6;
+    text-decoration: none;
 }
+
 header menu li a img {
-  margin: 0;
-  padding: 5px 0;
-  vertical-align: bottom;
-  width: 30px;
-  height: 30px;
+    margin: 0;
+    padding: 5px 0;
+    vertical-align: bottom;
+    width: 30px;
+    height: 30px;
 }
 
 #subtitle {
-  position: absolute;
-  top: 80px;
-  left: 0;
-  width: 100%;
+    position: absolute;
+    top: 80px;
+    left: 0;
+    width: 100%;
 }
+
 h2 {
-  font-weight: 200;
-  font-size: 26px;
-  line-height: 30px;
-  padding: 15px 0;
-  margin: 0;
-  color: #eee;
+    font-weight: 200;
+    font-size: 26px;
+    line-height: 30px;
+    padding: 15px 0;
+    margin: 0;
+    color: #eee;
 }
+
 h2 strong {
-  font-weight: 300;
+    font-weight: 300;
 }
 
 a.dl {
-  font-weight: 300;
-  font-size: 30px;
-  line-height: 40px;
-  padding: 3px 10px;
-  display: inline-block;
-  border-radius: 6px;
-  color: #f0f0f0;
-  margin: 5px 0;
+    font-weight: 300;
+    font-size: 30px;
+    line-height: 40px;
+    padding: 3px 10px;
+    display: inline-block;
+    border-radius: 6px;
+    color: #f0f0f0;
+    margin: 5px 0;
 }
+
 a.dl:hover {
-  color: #f0f0f0;
-  text-decoration: none;
+    color: #f0f0f0;
+    text-decoration: none;
 }
 
 .content-nav {
-  margin-top: 130px;
-  width: 220px;
+    margin-top: 130px;
+    width: 220px;
 }
+
 .content-nav.affix {
-  top: 0;
+    top: 0;
 }
+
 .content-nav li.active a, .content-nav li.active a:hover {
-  background-color: transparent;
-  color: #555;
-  border-left-width: 2px;
+    background-color: transparent;
+    color: #555;
+    border-left-width: 2px;
 }
+
 .content-nav .secondary a {
-  color: #aaa;
+    color: #aaa;
 }
+
 .content-nav .secondary a:hover {
-  color: #888;
+    color: #888;
 }
 
 h3 {
-  font-weight: 300;
-  font-style: italic;
-  color: #888;
-  font-size: 20px;
-  padding-top: 115px;
-  margin-top: 0;
+    font-weight: 300;
+    font-style: italic;
+    color: #888;
+    font-size: 20px;
+    padding-top: 115px;
+    margin-top: 0;
 }
 
 h4 {
-  font-weight: 400;
-  text-transform: uppercase;
-  color: #888;
-  font-size: 15px;
-  padding-top: 20px;
+    font-weight: 400;
+    text-transform: uppercase;
+    color: #888;
+    font-size: 15px;
+    padding-top: 20px;
 }
 
 p.license {
-  font-family: fixed-width;
+    font-family: fixed-width;
 }
 
 .row .logo {
-  text-align: center;
-  margin-top: 150px;
+    text-align: center;
+    margin-top: 150px;
 }
+
 .row .logo img {
-  height: 30px;
+    height: 30px;
 }
 
 pre, code {
-  color: #666;
+    color: #666;
 }
+
 code {
-  border: 0;
-  background-color: transparent;
+    border: 0;
+    background-color: transparent;
 }
 
 /* Widescreen desktop. */
 @media (min-width: 1200px) {
-  .content-nav {
-    width: 270px;
-  }
+    .content-nav {
+        width: 270px;
+    }
 }
 
 /* Smaller width browser, tablets. */
 @media (max-width: 979px) {
-  .content-nav {
-    width: 166px;
-  }
+    .content-nav {
+        width: 166px;
+    }
 }
 
 /* One-column mobile display. */
 @media (max-width: 767px) {
-  header {
-    position: absolute;
-    top: 0;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  header menu {
-    display: none;
-  }
-  #subtitle {
-    position: absolute;
-    top: 80px;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  .content-nav {
-    display: none;
-  }
+    header {
+        position: absolute;
+        top: 0;
+        left: 0;
+        width: 100%;
+        padding-left: 20px;
+    }
+
+    header menu {
+        display: none;
+    }
+
+    #subtitle {
+        position: absolute;
+        top: 80px;
+        left: 0;
+        width: 100%;
+        padding-left: 20px;
+    }
+
+    .content-nav {
+        display: none;
+    }
 }
\ No newline at end of file
