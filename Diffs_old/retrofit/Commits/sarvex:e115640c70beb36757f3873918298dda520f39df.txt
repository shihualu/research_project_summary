diff --git a/.travis.yml b/.travis.yml
index e6a844e22..79fe36a95 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,6 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
 
 after_success:
diff --git a/BUG-BOUNTY.md b/BUG-BOUNTY.md
new file mode 100644
index 000000000..b2c35b2da
--- /dev/null
+++ b/BUG-BOUNTY.md
@@ -0,0 +1,10 @@
+Serious about security
+======================
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 80c420272..a2b736bd6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,25 @@
 Change Log
 ==========
 
+Version 2.0.0-beta1 *(2015-08-27)*
+----------------------------------
+
+ * New: `Call` encapsulates a single request/response HTTP call. A call can by run synchronously
+   via `execute()` or asynchronously via `enqueue()` and can be canceled with `cancel()`.
+ * New: `Response` is now parameterized and includes the deserialized body object.
+ * New: `@Url` parameter annotation allows passing a complete URL for an endpoint.
+ * New: OkHttp is now required as a dependency. Types like `TypedInput` and `TypedOutput` (and its
+   implementations), `Request`, and `Header` have been replaced with OkHttp types like `RequestBody`,
+   `ResponseBody`, and `Headers`.
+ * New: `CallAdapter` (and `Factory`) provides extension point for supporting multiple execution
+   mechanisms. An RxJava implementation is provided by a sibling module.
+ * New: `Converter` (and `Factory`) provides extension point for supporting multiple serialization
+   mechanisms. Gson, Jackson, Moshi, Protobuf, Wire, and SimpleXml implementations are provided by sibling
+   modules.
+ * Fix: A lot of things.
+ * Hello Droidcon NYC 2015!
+
+
 Version 1.9.0 *(2015-01-07)*
 ----------------------------
 
diff --git a/README.md b/README.md
index c101a0078..a8276e398 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 Retrofit
 ========
 
-Type-safe REST client for Android and Java by Square, Inc.
+Type-safe HTTP client for Android and Java by Square, Inc.
 
 For more information please see [the website][1].
 
@@ -14,17 +14,17 @@ Download [the latest JAR][2] or grab via Maven:
 <dependency>
   <groupId>com.squareup.retrofit</groupId>
   <artifactId>retrofit</artifactId>
-  <version>1.9.0</version>
+  <version>2.0.0-beta1</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.retrofit:retrofit:1.9.0'
+compile 'com.squareup.retrofit:retrofit:2.0.0-beta1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Retrofit requires at minimum Java 6 or Android 2.3.
+Retrofit requires at minimum Java 7 or Android 2.3.
 
 
 
diff --git a/checkstyle.xml b/checkstyle.xml
index 693c0db7f..de5302db0 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -53,7 +53,7 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <module name="MethodLength"/>
+        <!--<module name="MethodLength"/>-->
         <!--module name="ParameterNumber"/-->
 
 
@@ -92,7 +92,6 @@
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
         <module name="EqualsAvoidNull"/>
         <module name="EqualsHashCode"/>
diff --git a/pom.xml b/pom.xml
index 5f43662a0..3c3ecd9fb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -29,11 +29,12 @@
   <packaging>pom</packaging>
 
   <name>Retrofit (Parent)</name>
-  <description>Type-safe REST client for Android and Java by Square, Inc.</description>
+  <description>Type-safe HTTP client for Android and Java by Square, Inc.</description>
   <url>http://github.com/square/retrofit/</url>
 
   <modules>
     <module>retrofit</module>
+    <module>retrofit-adapters</module>
     <module>retrofit-converters</module>
     <module>retrofit-mock</module>
     <module>samples</module>
@@ -44,23 +45,27 @@
     <project.reporting.sourceEncoding>UTF-8</project.reporting.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
 
     <!-- Dependencies -->
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <gson.version>2.3.1</gson.version>
-    <okhttp.version>2.2.0</okhttp.version>
-    <rxjava.version>1.0.0</rxjava.version>
+    <okhttp.version>2.5.0</okhttp.version>
+    <animal.sniffer.version>1.14</animal.sniffer.version>
+
+    <!-- Adapter Dependencies -->
+    <rxjava.version>1.0.14</rxjava.version>
 
     <!-- Converter Dependencies -->
+    <gson.version>2.3.1</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.4.3</jackson.version>
-    <wire.version>1.5.2</wire.version>
+    <wire.version>1.7.0</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
+    <moshi.version>0.9.0</moshi.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.11</junit.version>
+    <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
     <mockito.version>1.9.5</mockito.version>
     <guava.version>18.0</guava.version>
@@ -97,6 +102,11 @@
         <artifactId>android</artifactId>
         <version>${android.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-annotations</artifactId>
+        <version>${animal.sniffer.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.squareup.okhttp</groupId>
         <artifactId>okhttp</artifactId>
@@ -133,6 +143,11 @@
         <artifactId>simple-xml</artifactId>
         <version>${simplexml.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
 
       <dependency>
         <groupId>junit</groupId>
@@ -190,7 +205,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.15</version>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
@@ -205,6 +220,27 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>${animal.sniffer.version}</version>
+        <executions>
+          <execution>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
+          </signature>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/retrofit-adapters/README.md b/retrofit-adapters/README.md
new file mode 100644
index 000000000..2dd0b7d47
--- /dev/null
+++ b/retrofit-adapters/README.md
@@ -0,0 +1,4 @@
+Retrofit Adapters
+=================
+
+TODO
diff --git a/samples/github-client/pom.xml b/retrofit-adapters/pom.xml
similarity index 56%
rename from samples/github-client/pom.xml
rename to retrofit-adapters/pom.xml
index 123f2ddd9..b1a7320f8 100644
--- a/samples/github-client/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -4,20 +4,18 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
+    <groupId>com.squareup.retrofit</groupId>
     <artifactId>parent</artifactId>
     <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>github-client</artifactId>
-  <name>Sample: GitHub Client</name>
+  <artifactId>retrofit-adapters</artifactId>
+  <name>Adapters</name>
+  <packaging>pom</packaging>
 
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.retrofit</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
+  <modules>
+    <module>rxjava</module>
+    <module>rxjava-mock</module>
+  </modules>
 </project>
diff --git a/samples/mock-github-client/pom.xml b/retrofit-adapters/rxjava-mock/pom.xml
similarity index 51%
rename from samples/mock-github-client/pom.xml
rename to retrofit-adapters/rxjava-mock/pom.xml
index 11327d99b..d69458e9a 100644
--- a/samples/mock-github-client/pom.xml
+++ b/retrofit-adapters/rxjava-mock/pom.xml
@@ -1,21 +1,17 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<!--
-  ~ Copyright 2013 Square, Inc.
-  -->
-
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.retrofit.samples</groupId>
-    <artifactId>parent</artifactId>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
     <version>2.0.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>mock-github-client</artifactId>
-  <name>Sample: Mock GitHub Client</name>
+  <artifactId>adapter-rxjava-mock</artifactId>
+  <name>Adapter: RxJava Mock</name>
 
   <dependencies>
     <dependency>
@@ -28,5 +24,25 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>adapter-rxjava</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
new file mode 100644
index 000000000..054c5556a
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class RxJavaBehaviorAdapter implements NetworkBehavior.Adapter<Object> {
+  public static RxJavaBehaviorAdapter create() {
+    return new RxJavaBehaviorAdapter();
+  }
+
+  private RxJavaBehaviorAdapter() {
+  }
+
+  @Override public Object applyBehavior(NetworkBehavior behavior, Object value) {
+    if (value instanceof Observable) {
+      return applyObservableBehavior(behavior, (Observable<?>) value);
+    }
+    String name = value.getClass().getCanonicalName();
+    if ("rx.Single".equals(name)) {
+      // Apply behavior to the Single from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.applySingleBehavior(behavior, value);
+    }
+    throw new IllegalStateException("Unsupported type " + name);
+  }
+
+  public Observable<?> applyObservableBehavior(final NetworkBehavior behavior,
+      final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
new file mode 100644
index 000000000..d1c54214f
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.Single;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class SingleHelper {
+  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
+  public static Object applySingleBehavior(final NetworkBehavior behavior, Object value) {
+    final Single<Object> single = (Single<Object>) value;
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return single.toObservable();
+          }
+        })
+        .toSingle();
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
new file mode 100644
index 000000000..d256b84f0
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import rx.Observable;
+import rx.Single;
+import rx.Subscriber;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+
+public final class RxJavaBehaviorAdapterTest {
+  interface DoWorkService {
+    Observable<String> observableResponse();
+    Single<String> singleResponse();
+  }
+
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Observable<String> observableResponse() {
+        return Observable.just("Hi!");
+      }
+
+      @Override public Single<String> singleResponse() {
+        return Single.just("Hi!");
+      }
+    };
+
+    NetworkBehavior.Adapter<?> adapter = RxJavaBehaviorAdapter.create();
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
+  }
+
+  @Test public void observableFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void observableSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Observable<String> observable = service.observableResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Single<String> observable = service.singleResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String s) {
+        throw new AssertionError();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(throwable);
+        latch.countDown();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void singleSuccessAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Single<String> observable = service.singleResponse();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    observable.subscribe(new Subscriber<String>() {
+      @Override public void onNext(String value) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(value);
+        latch.countDown();
+      }
+
+      @Override public void onError(Throwable throwable) {
+        throw new AssertionError();
+      }
+
+      @Override public void onCompleted() {
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Hi!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+}
diff --git a/retrofit-adapters/rxjava/pom.xml b/retrofit-adapters/rxjava/pom.xml
new file mode 100644
index 000000000..2a0ac8787
--- /dev/null
+++ b/retrofit-adapters/rxjava/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-adapters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>adapter-rxjava</artifactId>
+  <name>Adapter: RxJava</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.reactivex</groupId>
+      <artifactId>rxjava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
new file mode 100644
index 000000000..77076a642
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/HttpException.java
@@ -0,0 +1,32 @@
+package retrofit;
+
+/** Exception for an unexpected, non-2xx HTTP response. */
+public final class HttpException extends Exception {
+  private final int code;
+  private final String message;
+  private final transient Response<?> response;
+
+  public HttpException(Response<?> response) {
+    super("HTTP " + response.code() + " " + response.message());
+    this.code = response.code();
+    this.message = response.message();
+    this.response = response;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return code;
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * The full HTTP response. This may be null if the exception was serialized.
+   */
+  public Response<?> response() {
+    return response;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
new file mode 100644
index 000000000..d6b1a9ede
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/Result.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+
+import static retrofit.Utils.checkNotNull;
+
+/** The result of executing an HTTP request. */
+public final class Result<T> {
+  public static <T> Result<T> error(Throwable error) {
+    return new Result<>(null, checkNotNull(error, "error == null"));
+  }
+
+  public static <T> Result<T> response(Response<T> response) {
+    return new Result<>(checkNotNull(response, "response == null"), null);
+  }
+
+  private final Response<T> response;
+  private final Throwable error;
+
+  Result(Response<T> response, Throwable error) {
+    this.response = response;
+    this.error = error;
+  }
+
+  /**
+   * The response received from executing an HTTP request. Only present when {@link #isError()} is
+   * false, null otherwise.
+   */
+  public Response<T> response() {
+    return response;
+  }
+
+  /**
+   * The error experienced while attempting to execute an HTTP request. Only present when {@link
+   * #isError()} is true, null otherwise.
+   * <p>
+   * If the error is an {@link IOException} then there was a problem with the transport to the
+   * remote server. Any other exception type indicates an unexpected failure and should be
+   * considered fatal (configuration error, programming error, etc.).
+   */
+  public Throwable error() {
+    return error;
+  }
+
+  /** {@code true} if the request resulted in an error. See {@link #error()} for the cause. */
+  public boolean isError() {
+    return error != null;
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
new file mode 100644
index 000000000..0449dd70b
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Func1;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * TODO docs
+ */
+public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
+  /**
+   * TODO
+   */
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory();
+  }
+
+  private RxJavaCallAdapterFactory() {
+  }
+
+  @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+    Class<?> rawType = Utils.getRawType(returnType);
+    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    CallAdapter<Observable<?>> callAdapter = getCallAdapter(returnType);
+    if (isSingle) {
+      // Add Single-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.makeSingle(callAdapter);
+    }
+    return callAdapter;
+  }
+
+  private CallAdapter<Observable<?>> getCallAdapter(Type returnType) {
+    Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+    Class<?> rawObservableType = Utils.getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResponseCallAdapter(responseType);
+    }
+
+    if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResultCallAdapter(responseType);
+    }
+
+    return new SimpleCallAdapter(observableType);
+  }
+
+  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
+    private final Call<T> originalCall;
+
+    private CallOnSubscribe(Call<T> originalCall) {
+      this.originalCall = originalCall;
+    }
+
+    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
+      // Since Call is a one-shot type, clone it for each new subscriber.
+      final Call<T> call = originalCall.clone();
+
+      // Attempt to cancel the call if it is still in-flight on unsubscription.
+      subscriber.add(Subscriptions.create(new Action0() {
+        @Override public void call() {
+          call.cancel();
+        }
+      }));
+
+      call.enqueue(new Callback<T>() {
+        @Override public void onResponse(Response<T> response) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          try {
+            subscriber.onNext(response);
+          } catch (Throwable t) {
+            subscriber.onError(t);
+            return;
+          }
+          subscriber.onCompleted();
+        }
+
+        @Override public void onFailure(Throwable t) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          subscriber.onError(t);
+        }
+      });
+    }
+  }
+
+  static final class ResponseCallAdapter implements CallAdapter<Observable<?>> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> Observable<Response<R>> adapt(Call<R> call) {
+      return Observable.create(new CallOnSubscribe<>(call));
+    }
+  }
+
+  static final class SimpleCallAdapter implements CallAdapter<Observable<?>> {
+    private final Type responseType;
+
+    SimpleCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> Observable<R> adapt(Call<R> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .flatMap(new Func1<Response<R>, Observable<R>>() {
+            @Override public Observable<R> call(Response<R> response) {
+              if (response.isSuccess()) {
+                return Observable.just(response.body());
+              }
+              return Observable.error(new HttpException(response));
+            }
+          });
+    }
+  }
+
+  static final class ResultCallAdapter implements CallAdapter<Observable<?>> {
+    private final Type responseType;
+
+    ResultCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public <R> Observable<Result<R>> adapt(Call<R> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .map(new Func1<Response<R>, Result<R>>() {
+            @Override public Result<R> call(Response<R> response) {
+              return Result.response(response);
+            }
+          })
+          .onErrorReturn(new Func1<Throwable, Result<R>>() {
+            @Override public Result<R> call(Throwable throwable) {
+              return Result.error(throwable);
+            }
+          });
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
new file mode 100644
index 000000000..9d3c28ef1
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Single;
+
+final class SingleHelper {
+  static CallAdapter<Single<?>> makeSingle(final CallAdapter<Observable<?>> callAdapter) {
+    return new CallAdapter<Single<?>>() {
+      @Override public Type responseType() {
+        return callAdapter.responseType();
+      }
+
+      @Override public <R> Single<?> adapt(Call<R> call) {
+        Observable<?> observable = callAdapter.adapt(call);
+        return observable.toSingle();
+      }
+    };
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
new file mode 100644
index 000000000..3eb406949
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ResultTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ResultTest {
+  @Test public void response() {
+    Response<String> response = Response.success("Hi");
+    Result<String> result = Result.response(response);
+    assertThat(result.isError()).isFalse();
+    assertThat(result.error()).isNull();
+    assertThat(result.response()).isSameAs(response);
+  }
+
+  @Test public void nullResponseThrows() {
+    try {
+      Result.response(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("response == null");
+    }
+  }
+
+  @Test public void error() {
+    Throwable error = new IOException();
+    Result<Object> result = Result.error(error);
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isSameAs(error);
+    assertThat(result.response()).isNull();
+  }
+
+  @Test public void nullErrorThrows() {
+    try {
+      Result.error(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("error == null");
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
new file mode 100644
index 000000000..142c4c9d6
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.GET;
+import rx.Observable;
+import rx.Single;
+import rx.observables.BlockingObservable;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class RxJavaCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Observable<String> observableBody();
+    @GET("/") Observable<Response<String>> observableResponse();
+    @GET("/") Observable<Result<String>> observableResult();
+    @GET("/") Single<String> singleBody();
+    @GET("/") Single<Response<String>> singleResponse();
+    @GET("/") Single<Result<String>> singleResult();
+  }
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodySuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<String> o = service.observableBody().toBlocking();
+    assertThat(o.first()).isEqualTo("Hi");
+  }
+
+  @Test public void bodySuccess404() {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    BlockingObservable<String> o = service.observableBody().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      assertThat(cause).isInstanceOf(HttpException.class).hasMessage("HTTP 404 OK");
+    }
+  }
+
+  @Test public void bodyFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<String> o = service.observableBody().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void responseSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    Response<String> response = o.first();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void responseFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    try {
+      o.first();
+      fail();
+    } catch (RuntimeException t) {
+      assertThat(t.getCause()).isInstanceOf(IOException.class);
+    }
+  }
+
+  @Test public void resultSuccess200() {
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void resultSuccess404() throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isFalse();
+    Response<String> response = result.response();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void resultFailure() {
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+
+    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    Result<String> result = o.first();
+    assertThat(result.isError()).isTrue();
+    assertThat(result.error()).isInstanceOf(IOException.class);
+  }
+
+  @Test public void responseType() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type classType = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(classType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType, NO_ANNOTATIONS).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type responseType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(responseType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    Type resultType = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(resultType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+  }
+
+  @Test public void nonObservableTypeReturnsNull() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void rawTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+  }
+
+  @Test public void rawObservableResponseTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+
+  @Test public void single() {
+    // TODO Better tests here. Why is there no toBlocking() on Single?
+    assertNotNull(service.singleBody());
+    assertNotNull(service.singleResponse());
+    assertNotNull(service.singleResult());
+  }
+
+  static class StringConverterFactory extends Converter.Factory {
+    @Override
+    public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
+        }
+      };
+    }
+
+    @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
+          return RequestBody.create(MediaType.parse("text/plain"), value);
+        }
+      };
+    }
+  }
+}
diff --git a/retrofit-converters/README.md b/retrofit-converters/README.md
index ec010c032..1e440adef 100644
--- a/retrofit-converters/README.md
+++ b/retrofit-converters/README.md
@@ -4,11 +4,11 @@ Retrofit Converters
 Retrofit ships with a default converter for JSON that uses Gson but the library is content-format
 agnostic. The child modules contained herein are additional converters for other popular formats.
 
-To use, supply an instance of your desired converter when building your `RestAdapter` instance.
+To use, supply an instance of your desired converter when building your `Retrofit` instance.
 
 ```java
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.example.com")
-    .setConverter(new ProtoConverter())
+Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.example.com")
+    .converter(new ProtoConverter())
     .build();
 ```
diff --git a/retrofit-converters/gson/README.md b/retrofit-converters/gson/README.md
new file mode 100644
index 000000000..1568926f2
--- /dev/null
+++ b/retrofit-converters/gson/README.md
@@ -0,0 +1,10 @@
+Gson Converter
+==============
+
+A `Converter` which uses [Gson][1] for serialization to and from JSON.
+
+A default `Gson` instance will be created or one can be configured and passed to the
+`GsonConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/google/gson
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
new file mode 100644
index 000000000..0cb591ace
--- /dev/null
+++ b/retrofit-converters/gson/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-gson</artifactId>
+  <name>Converter: Gson</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
new file mode 100644
index 000000000..f1f4001b0
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonConverterFactory.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Gson for JSON.
+ * <p>
+ * Because Gson is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class GsonConverterFactory extends Converter.Factory {
+  /**
+   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create() {
+    return create(new Gson());
+  }
+
+  /**
+   * Create an instance using {@code gson} for conversion. Encoding to JSON and
+   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
+   */
+  public static GsonConverterFactory create(Gson gson) {
+    return new GsonConverterFactory(gson);
+  }
+
+  private final Gson gson;
+
+  private GsonConverterFactory(Gson gson) {
+    if (gson == null) throw new NullPointerException("gson == null");
+    this.gson = gson;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonResponseBodyConverter<>(adapter);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
+    return new GsonRequestBodyConverter<>(adapter);
+  }
+}
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
new file mode 100644
index 000000000..278e3444f
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonRequestBodyConverter.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.TypeAdapter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.charset.Charset;
+import okio.Buffer;
+
+final class GsonRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private final TypeAdapter<T> adapter;
+
+  GsonRequestBodyConverter(TypeAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);
+    try {
+      adapter.toJson(writer, value);
+      writer.flush();
+    } catch (IOException e) {
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
new file mode 100644
index 000000000..5444202e9
--- /dev/null
+++ b/retrofit-converters/gson/src/main/java/retrofit/GsonResponseBodyConverter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.TypeAdapter;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.Reader;
+
+final class GsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final TypeAdapter<T> adapter;
+
+  GsonResponseBodyConverter(TypeAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
+    try {
+      return adapter.fromJson(reader);
+    } finally {
+      Utils.closeQuietly(reader);
+    }
+  }
+}
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
new file mode 100644
index 000000000..8dadf9cb5
--- /dev/null
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterFactoryTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class GsonConverterFactoryTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
+    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.peek() != JsonToken.END_OBJECT) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .create();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(GsonConverterFactory.create(gson))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+
+  }
+}
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 06c5a2992..18d0340b4 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
new file mode 100644
index 000000000..194992018
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonConverterFactory.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Jackson.
+ * <p>
+ * Because Jackson is so flexible in the types it supports, this converter assumes that it can
+ * handle all types. If you are mixing JSON serialization with something else (such as protocol
+ * buffers), you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this
+ * instance} last to allow the other converters a chance to see their types.
+ */
+public final class JacksonConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link ObjectMapper} instance for conversion. */
+  public static JacksonConverterFactory create() {
+    return create(new ObjectMapper());
+  }
+
+  /** Create an instance using {@code mapper} for conversion. */
+  public static JacksonConverterFactory create(ObjectMapper mapper) {
+    return new JacksonConverterFactory(mapper);
+  }
+
+  private final ObjectMapper mapper;
+
+  private JacksonConverterFactory(ObjectMapper mapper) {
+    if (mapper == null) throw new NullPointerException("mapper == null");
+    this.mapper = mapper;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectReader reader = mapper.reader(javaType);
+    return new JacksonResponseBodyConverter<>(reader);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    JavaType javaType = mapper.getTypeFactory().constructType(type);
+    ObjectWriter writer = mapper.writerWithType(javaType);
+    return new JacksonRequestBodyConverter<>(writer);
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
new file mode 100644
index 000000000..78edddee4
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonRequestBodyConverter.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class JacksonRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final ObjectWriter adapter;
+
+  JacksonRequestBodyConverter(ObjectWriter adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = adapter.writeValueAsBytes(value);
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
new file mode 100644
index 000000000..fe3763435
--- /dev/null
+++ b/retrofit-converters/jackson/src/main/java/retrofit/JacksonResponseBodyConverter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.Reader;
+
+final class JacksonResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final ObjectReader adapter;
+
+  JacksonResponseBodyConverter(ObjectReader adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    Reader reader = value.charStream();
+    try {
+      return adapter.readValue(reader);
+    } finally {
+      Utils.closeQuietly(reader);
+    }
+  }
+}
diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
deleted file mode 100644
index 1b41a536e..000000000
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package retrofit.converter;
-
-import com.fasterxml.jackson.core.JsonProcessingException;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Type;
-
-/**
- * A {@link Converter} which uses Jackson for reading and writing entities.
- *
- * @author Kai Waldron (kaiwaldron@gmail.com)
- */
-public class JacksonConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-
-  private final ObjectMapper objectMapper;
-
-  public JacksonConverter() {
-    this(new ObjectMapper());
-  }
-
-  public JacksonConverter(ObjectMapper objectMapper) {
-    if (objectMapper == null) throw new NullPointerException("objectMapper == null");
-    this.objectMapper = objectMapper;
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      return objectMapper.readValue(is, javaType);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    try {
-      JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return RequestBody.create(MEDIA_TYPE, json);
-    } catch (JsonProcessingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
new file mode 100644
index 000000000..83ba86fe6
--- /dev/null
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterFactoryTest.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.fasterxml.jackson.annotation.JsonAutoDetect;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.MapperFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class JacksonConverterFactoryTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private String theName;
+
+    AnImplementation() {
+    }
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
+    AnInterfaceSerializer() {
+      super(AnInterface.class);
+    }
+
+    @Override public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
+        SerializerProvider serializerProvider) throws IOException {
+      jsonGenerator.writeStartObject();
+      jsonGenerator.writeFieldName("name");
+      jsonGenerator.writeString(anInterface.getName());
+      jsonGenerator.writeEndObject();
+    }
+  }
+
+  static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
+    AnInterfaceDeserializer() {
+      super(AnInterface.class);
+    }
+
+    @Override public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
+        throws IOException {
+      if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
+        throw new AssertionError("Expected start object.");
+      }
+
+      String name = null;
+
+      while (jp.nextToken() != JsonToken.END_OBJECT) {
+        switch (jp.getCurrentName()) {
+          case "name":
+            name = jp.getValueAsString();
+            break;
+        }
+      }
+
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    SimpleModule module = new SimpleModule();
+    module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
+    module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
+    ObjectMapper mapper = new ObjectMapper();
+    mapper.registerModule(module);
+    mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
+    mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
+    mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
+    mapper.setVisibilityChecker(mapper.getSerializationConfig()
+        .getDefaultVisibilityChecker()
+        .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(JacksonConverterFactory.create(mapper))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+}
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
deleted file mode 100644
index 4114ba075..000000000
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package retrofit.converter;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.databind.JsonMappingException;
-import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class JacksonConverterTest {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
-  private static final MyObject OBJECT = new MyObject("hello world", 10);
-  private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
-
-  private final JacksonConverter converter = new JacksonConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(OBJECT, MyObject.class);
-    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
-    assertBody(body).isEqualTo(JSON);
-  }
-
-  @Test public void deserialize() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
-    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
-    assertThat(result).isEqualTo(OBJECT);
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
-    try {
-      converter.fromBody(body, MyObject.class);
-    } catch (UnrecognizedPropertyException ignored) {
-    }
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
-    try {
-      converter.fromBody(body, String.class);
-    } catch (JsonMappingException ignored) {
-    }
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-
-  static class MyObject {
-    private final String message;
-    private final int count;
-
-    public MyObject(@JsonProperty("message") String message, @JsonProperty("count") int count) {
-      this.message = message;
-      this.count = count;
-    }
-
-    public String getMessage() {
-      return message;
-    }
-
-    public int getCount() {
-      return count;
-    }
-
-    @Override public boolean equals(Object o) {
-      if (this == o) return true;
-      if (o == null || getClass() != o.getClass()) return false;
-
-      MyObject myObject = (MyObject) o;
-      return count == myObject.count
-          && !(message != null ? !message.equals(myObject.message) : myObject.message != null);
-    }
-
-    @Override public int hashCode() {
-      int result = message != null ? message.hashCode() : 0;
-      result = 31 * result + count;
-      return result;
-    }
-  }
-}
diff --git a/retrofit-converters/moshi/README.md b/retrofit-converters/moshi/README.md
new file mode 100644
index 000000000..492e42601
--- /dev/null
+++ b/retrofit-converters/moshi/README.md
@@ -0,0 +1,10 @@
+Moshi Converter
+===============
+
+A `Converter` which uses [Moshi][1] for serialization to and from JSON.
+
+A default `Moshi` instance will be created or one can be configured and passed to the
+`MoshiConverter` construction to further control the serialization.
+
+
+ [1]: https://github.com/square/moshi
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
new file mode 100644
index 000000000..627c62b99
--- /dev/null
+++ b/retrofit-converters/moshi/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.retrofit</groupId>
+    <artifactId>retrofit-converters</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>converter-moshi</artifactId>
+  <name>Converter: Moshi</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
new file mode 100644
index 000000000..70a605af6
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverterFactory.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Moshi for JSON.
+ * <p>
+ * Because Moshi is so flexible in the types it supports, this converter assumes that it can handle
+ * all types. If you are mixing JSON serialization with something else (such as protocol buffers),
+ * you must {@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance}
+ * last to allow the other converters a chance to see their types.
+ */
+public final class MoshiConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link Moshi} instance for conversion. */
+  public static MoshiConverterFactory create() {
+    return create(new Moshi.Builder().build());
+  }
+
+  /** Create an instance using {@code moshi} for conversion. */
+  public static MoshiConverterFactory create(Moshi moshi) {
+    return new MoshiConverterFactory(moshi);
+  }
+
+  private final Moshi moshi;
+
+  private MoshiConverterFactory(Moshi moshi) {
+    if (moshi == null) throw new NullPointerException("moshi == null");
+    this.moshi = moshi;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiResponseBodyConverter<>(adapter);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    JsonAdapter<?> adapter = moshi.adapter(type);
+    return new MoshiRequestBodyConverter<>(adapter);
+  }
+}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
new file mode 100644
index 000000000..f64109687
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiRequestBodyConverter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import okio.Buffer;
+
+final class MoshiRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+
+  private final JsonAdapter<T> adapter;
+
+  MoshiRequestBodyConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      adapter.toJson(buffer, value);
+    } catch (IOException e) {
+      throw new AssertionError(e); // Writing to Buffer does no I/O.
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
new file mode 100644
index 000000000..6ddb17e63
--- /dev/null
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiResponseBodyConverter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class MoshiResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final JsonAdapter<T> adapter;
+
+  MoshiResponseBodyConverter(JsonAdapter<T> adapter) {
+    this.adapter = adapter;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
+    try {
+      return adapter.fromJson(source);
+    } finally {
+      Utils.closeQuietly(source);
+    }
+  }
+}
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
new file mode 100644
index 000000000..b14da4b7e
--- /dev/null
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterFactoryTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.moshi.FromJson;
+import com.squareup.moshi.JsonReader;
+import com.squareup.moshi.JsonWriter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.ToJson;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class MoshiConverterFactoryTest {
+  interface AnInterface {
+    String getName();
+  }
+
+  static class AnImplementation implements AnInterface {
+    private final String theName;
+
+    AnImplementation(String name) {
+      theName = name;
+    }
+
+    @Override public String getName() {
+      return theName;
+    }
+  }
+
+  static class AnInterfaceAdapter {
+    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
+      jsonWriter.beginObject();
+      jsonWriter.name("name").value(anInterface.getName());
+      jsonWriter.endObject();
+    }
+
+    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
+      jsonReader.beginObject();
+
+      String name = null;
+      while (jsonReader.hasNext()) {
+        switch (jsonReader.nextName()) {
+          case "name":
+            name = jsonReader.nextString();
+            break;
+        }
+      }
+
+      jsonReader.endObject();
+      return new AnImplementation(name);
+    }
+  }
+
+  interface Service {
+    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
+    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Moshi moshi = new Moshi.Builder()
+        .add(new AnInterfaceAdapter())
+        .build();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(MoshiConverterFactory.create(moshi))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void anInterface() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+
+    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
+    Response<AnInterface> response = call.execute();
+    AnInterface body = response.body();
+    assertThat(body.getName()).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+
+  @Test public void anImplementation() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+
+    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
+    Response<AnImplementation> response = call.execute();
+    AnImplementation body = response.body();
+    assertThat(body.theName).isEqualTo("value");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  }
+}
diff --git a/retrofit-converters/pom.xml b/retrofit-converters/pom.xml
index 9fa974fc9..4fe586b8e 100644
--- a/retrofit-converters/pom.xml
+++ b/retrofit-converters/pom.xml
@@ -15,9 +15,11 @@
   <packaging>pom</packaging>
 
   <modules>
+    <module>gson</module>
     <module>protobuf</module>
     <module>jackson</module>
     <module>wire</module>
     <module>simplexml</module>
+    <module>moshi</module>
   </modules>
 </project>
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index d2808b7ea..c635c4854 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
new file mode 100644
index 000000000..9dfdbe253
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoConverterFactory.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Protocol Buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link MessageLite} (or one of its
+ * subclasses).
+ */
+public final class ProtoConverterFactory extends Converter.Factory {
+  public static ProtoConverterFactory create() {
+    return new ProtoConverterFactory();
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    Class<?> c = (Class<?>) type;
+    if (!MessageLite.class.isAssignableFrom(c)) {
+      return null;
+    }
+
+    Parser<MessageLite> parser;
+    try {
+      Field field = c.getDeclaredField("PARSER");
+      //noinspection unchecked
+      parser = (Parser<MessageLite>) field.get(null);
+    } catch (NoSuchFieldException | IllegalAccessException e) {
+      throw new IllegalArgumentException(
+          "Found a protobuf message but " + c.getName() + " had no PARSER field.");
+    }
+    return new ProtoResponseBodyConverter<>(parser);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    if (!MessageLite.class.isAssignableFrom((Class<?>) type)) {
+      return null;
+    }
+    return new ProtoRequestBodyConverter<>();
+  }
+}
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
new file mode 100644
index 000000000..e88a6ad73
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoRequestBodyConverter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.MessageLite;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class ProtoRequestBodyConverter<T extends MessageLite> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
new file mode 100644
index 000000000..63d611818
--- /dev/null
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/ProtoResponseBodyConverter.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.MessageLite;
+import com.google.protobuf.Parser;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+
+final class ProtoResponseBodyConverter<T extends MessageLite>
+    implements Converter<ResponseBody, T> {
+  private final Parser<T> parser;
+
+  ProtoResponseBodyConverter(Parser<T> parser) {
+    this.parser = parser;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
+    try {
+      return parser.parseFrom(is);
+    } catch (InvalidProtocolBufferException e) {
+      throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
+    } finally {
+      Utils.closeQuietly(is);
+    }
+  }
+}
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
deleted file mode 100644
index b9270c44e..000000000
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.protobuf.AbstractMessageLite;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-
-/** A {@link Converter} that reads and writes protocol buffers. */
-public class ProtoConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!AbstractMessageLite.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
-    }
-
-    InputStream is = body.byteStream();
-    try {
-      Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, is);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof AbstractMessageLite)) {
-      throw new IllegalArgumentException(
-          "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
-              : "null"));
-    }
-    byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
similarity index 85%
rename from retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
rename to retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
index 460f8cc35..1f233452a 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/PhoneProtos.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/PhoneProtos.java
@@ -1,7 +1,9 @@
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: protos/phone.proto
 
-package retrofit.converter;
+package retrofit;
+
+import com.google.protobuf.AbstractMessage;
 
 public final class PhoneProtos {
   private PhoneProtos() {}
@@ -96,14 +98,14 @@ private Phone(
     }
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+      return PhoneProtos.internal_static_retrofit_Phone_descriptor;
     }
 
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+      return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
           .ensureFieldAccessorsInitialized(
-              retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+              PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
     }
 
     public static com.google.protobuf.Parser<Phone> PARSER =
@@ -208,53 +210,53 @@ public int getSerializedSize() {
       return super.writeReplace();
     }
 
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.ByteString data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(byte[] data)
+    public static PhoneProtos.Phone parseFrom(byte[] data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         byte[] data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
+    public static PhoneProtos.Phone parseDelimitedFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseDelimitedFrom(
+    public static PhoneProtos.Phone parseDelimitedFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input, extensionRegistry);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static retrofit.converter.PhoneProtos.Phone parseFrom(
+    public static PhoneProtos.Phone parseFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
@@ -263,7 +265,7 @@ public int getSerializedSize() {
 
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(retrofit.converter.PhoneProtos.Phone prototype) {
+    public static Builder newBuilder(PhoneProtos.Phone prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
@@ -279,20 +281,20 @@ protected Builder newBuilderForType(
      */
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements retrofit.converter.PhoneProtos.PhoneOrBuilder {
+       implements PhoneProtos.PhoneOrBuilder {
       public static final com.google.protobuf.Descriptors.Descriptor
           getDescriptor() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
           internalGetFieldAccessorTable() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
+        return PhoneProtos.internal_static_retrofit_Phone_fieldAccessorTable
             .ensureFieldAccessorsInitialized(
-                retrofit.converter.PhoneProtos.Phone.class, retrofit.converter.PhoneProtos.Phone.Builder.class);
+                PhoneProtos.Phone.class, PhoneProtos.Phone.Builder.class);
       }
 
-      // Construct using retrofit.converter.PhoneProtos.Phone.newBuilder()
+      // Construct using retrofit.PhoneProtos.Phone.newBuilder()
       private Builder() {
         maybeForceBuilderInitialization();
       }
@@ -323,23 +325,23 @@ public Builder clone() {
 
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
-        return retrofit.converter.PhoneProtos.internal_static_retrofit_Phone_descriptor;
+        return PhoneProtos.internal_static_retrofit_Phone_descriptor;
       }
 
-      public retrofit.converter.PhoneProtos.Phone getDefaultInstanceForType() {
-        return retrofit.converter.PhoneProtos.Phone.getDefaultInstance();
+      public PhoneProtos.Phone getDefaultInstanceForType() {
+        return PhoneProtos.Phone.getDefaultInstance();
       }
 
-      public retrofit.converter.PhoneProtos.Phone build() {
-        retrofit.converter.PhoneProtos.Phone result = buildPartial();
+      public PhoneProtos.Phone build() {
+        PhoneProtos.Phone result = buildPartial();
         if (!result.isInitialized()) {
-          throw newUninitializedMessageException(result);
+          throw AbstractMessage.Builder.newUninitializedMessageException(result);
         }
         return result;
       }
 
-      public retrofit.converter.PhoneProtos.Phone buildPartial() {
-        retrofit.converter.PhoneProtos.Phone result = new retrofit.converter.PhoneProtos.Phone(this);
+      public PhoneProtos.Phone buildPartial() {
+        PhoneProtos.Phone result = new PhoneProtos.Phone(this);
         int from_bitField0_ = bitField0_;
         int to_bitField0_ = 0;
         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
@@ -352,16 +354,16 @@ public Builder clone() {
       }
 
       public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof retrofit.converter.PhoneProtos.Phone) {
-          return mergeFrom((retrofit.converter.PhoneProtos.Phone)other);
+        if (other instanceof PhoneProtos.Phone) {
+          return mergeFrom((PhoneProtos.Phone)other);
         } else {
           super.mergeFrom(other);
           return this;
         }
       }
 
-      public Builder mergeFrom(retrofit.converter.PhoneProtos.Phone other) {
-        if (other == retrofit.converter.PhoneProtos.Phone.getDefaultInstance()) return this;
+      public Builder mergeFrom(PhoneProtos.Phone other) {
+        if (other == PhoneProtos.Phone.getDefaultInstance()) return this;
         if (other.hasNumber()) {
           bitField0_ |= 0x00000001;
           number_ = other.number_;
@@ -379,11 +381,11 @@ public Builder mergeFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws java.io.IOException {
-        retrofit.converter.PhoneProtos.Phone parsedMessage = null;
+        PhoneProtos.Phone parsedMessage = null;
         try {
           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
         } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (retrofit.converter.PhoneProtos.Phone) e.getUnfinishedMessage();
+          parsedMessage = (PhoneProtos.Phone) e.getUnfinishedMessage();
           throw e;
         } finally {
           if (parsedMessage != null) {
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
new file mode 100644
index 000000000..4bcbce40b
--- /dev/null
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterFactoryTest.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static retrofit.PhoneProtos.Phone;
+
+public final class ProtoConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Phone> get();
+    @POST("/") Call<Phone> post(@Body Phone impl);
+    @GET("/") Call<String> wrongClass();
+    @GET("/") Call<List<String>> wrongType();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ProtoConverterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+  }
+
+  @Test public void deserializeEmpty() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call<Phone> call = service.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.hasNumber()).isFalse();
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongClass();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.ProtoConverterFactory");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongType();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.ProtoConverterFactory");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("////");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
+          .hasMessageContaining("input ended unexpectedly");
+    }
+  }
+}
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
deleted file mode 100644
index 99bcc58f5..000000000
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.google.protobuf.InvalidProtocolBufferException;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.util.ArrayList;
-import okio.Buffer;
-import okio.ByteString;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static retrofit.converter.PhoneProtos.Phone;
-
-public final class ProtoConverterTest {
-  private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
-  private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
-
-  private final ProtoConverter converter = new ProtoConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(PROTO, Phone.class);
-    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
-    assertBody(body).isEqualTo(ENCODED_PROTO);
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      converter.fromBody(protoResponse("////"), Phone.class);
-      fail();
-    } catch (RuntimeException expected) {
-      assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
-    }
-  }
-
-  private static ResponseBody protoResponse(String encodedProto) {
-    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
-        encodedProto).toByteArray());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readByteString().base64());
-  }
-}
diff --git a/retrofit-converters/protobuf/src/test/protos/phone.proto b/retrofit-converters/protobuf/src/test/protos/phone.proto
index 63a39a470..918c94570 100644
--- a/retrofit-converters/protobuf/src/test/protos/phone.proto
+++ b/retrofit-converters/protobuf/src/test/protos/phone.proto
@@ -1,6 +1,6 @@
 package retrofit;
 
-option java_package = "retrofit.converter";
+option java_package = "retrofit";
 option java_outer_classname = "PhoneProtos";
 
 message Phone {
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 4a83d0a78..1eba174cb 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
new file mode 100644
index 000000000..9e2909b80
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverterFactory.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import org.simpleframework.xml.Serializer;
+import org.simpleframework.xml.core.Persister;
+
+/**
+ * A {@linkplain Converter.Factory converter} which uses Simple Framework for XML.
+ * <p>
+ * This converter only applies for class types. Parameterized types (e.g., {@code List<Foo>}) are
+ * not handled.
+ */
+public final class SimpleXmlConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link Persister} instance for conversion. */
+  public static SimpleXmlConverterFactory create() {
+    return create(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for conversion. */
+  public static SimpleXmlConverterFactory create(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, true);
+  }
+
+  /** Create an instance using a default {@link Persister} instance for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict() {
+    return createNonStrict(new Persister());
+  }
+
+  /** Create an instance using {@code serializer} for non-strict conversion. */
+  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {
+    return new SimpleXmlConverterFactory(serializer, false);
+  }
+
+  private final Serializer serializer;
+  private final boolean strict;
+
+  private SimpleXmlConverterFactory(Serializer serializer, boolean strict) {
+    if (serializer == null) throw new NullPointerException("serializer == null");
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  public boolean isStrict() {
+    return strict;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class)) {
+      return null;
+    }
+    Class<?> cls = (Class<?>) type;
+    return new SimpleXmlResponseBodyConverter<>(cls, serializer, strict);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class)) {
+      return null;
+    }
+    return new SimpleXmlRequestBodyConverter<>(serializer);
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
new file mode 100644
index 000000000..f81c6b177
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlRequestBodyConverter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import okio.Buffer;
+import org.simpleframework.xml.Serializer;
+
+final class SimpleXmlRequestBodyConverter<T> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final String CHARSET = "UTF-8";
+
+  private final Serializer serializer;
+
+  SimpleXmlRequestBodyConverter(Serializer serializer) {
+    this.serializer = serializer;
+  }
+
+  @Override public RequestBody convert(T value) throws IOException {
+    Buffer buffer = new Buffer();
+    try {
+      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
+      serializer.write(value, osw);
+      osw.flush();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
new file mode 100644
index 000000000..6d4e37247
--- /dev/null
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlResponseBodyConverter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.io.InputStream;
+import org.simpleframework.xml.Serializer;
+
+final class SimpleXmlResponseBodyConverter<T> implements Converter<ResponseBody, T> {
+  private final Class<T> cls;
+  private final Serializer serializer;
+  private final boolean strict;
+
+  SimpleXmlResponseBodyConverter(Class<T> cls, Serializer serializer, boolean strict) {
+    this.cls = cls;
+    this.serializer = serializer;
+    this.strict = strict;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    InputStream is = value.byteStream();
+    try {
+      T read = serializer.read(cls, is, strict);
+      if (read == null) {
+        throw new IllegalStateException("Could not deserialize body as " + cls);
+      }
+      return read;
+    } catch (RuntimeException | IOException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+}
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
deleted file mode 100644
index 4d757a555..000000000
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import java.lang.reflect.Type;
-import okio.Buffer;
-import org.simpleframework.xml.Serializer;
-import org.simpleframework.xml.core.Persister;
-
-/**
- * A {@link Converter} which uses SimpleXML for reading and writing entities.
- *
- * @author Fabien Ric (fabien.ric@gmail.com)
- */
-public class SimpleXMLConverter implements Converter {
-  private static final boolean DEFAULT_STRICT = true;
-  private static final String CHARSET = "UTF-8";
-  private static final MediaType MEDIA_TYPE =
-      MediaType.parse("application/xml; charset=" + CHARSET);
-
-  private final Serializer serializer;
-
-  private final boolean strict;
-
-  public SimpleXMLConverter() {
-    this(DEFAULT_STRICT);
-  }
-
-  public SimpleXMLConverter(boolean strict) {
-    this(new Persister(), strict);
-  }
-
-  public SimpleXMLConverter(Serializer serializer) {
-    this(serializer, DEFAULT_STRICT);
-  }
-
-  public SimpleXMLConverter(Serializer serializer, boolean strict) {
-    this.serializer = serializer;
-    this.strict = strict;
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    InputStream is = body.byteStream();
-    try {
-      return serializer.read((Class<?>) type, is, strict);
-    } catch (IOException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object source, Type type) {
-    byte[] bytes;
-    try {
-      Buffer buffer = new Buffer();
-      OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
-      serializer.write(source, osw);
-      osw.flush();
-      bytes = buffer.readByteArray();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-
-  public boolean isStrict() {
-    return strict;
-  }
-}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
new file mode 100644
index 000000000..398854c19
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import org.simpleframework.xml.Element;
+
+@Default(value = DefaultType.FIELD)
+final class MyObject {
+  @Element private String message;
+  @Element private int count;
+
+  public MyObject() {
+  }
+
+  public MyObject(String message, int count) {
+    this.message = message;
+    this.count = count;
+  }
+
+  public void setMessage(String message) {
+    this.message = message;
+  }
+
+  public String getMessage() {
+    return message;
+  }
+
+  public void setCount(int count) {
+    this.count = count;
+  }
+
+  public int getCount() {
+    return count;
+  }
+
+  @Override public int hashCode() {
+    int result = 1;
+    result = result * 31 + count;
+    result = result * 31 + (message == null ? 0 : message.hashCode());
+    return result;
+  }
+
+  @Override public boolean equals(Object obj) {
+    if (obj == this) return true;
+    if (!(obj instanceof MyObject)) return false;
+    MyObject other = (MyObject) obj;
+    return count == other.count
+        && (message == null ? other.message == null : message.equals(other.message));
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
new file mode 100644
index 000000000..d0c6421ef
--- /dev/null
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterFactoryTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.simpleframework.xml.core.ElementException;
+import org.simpleframework.xml.core.Persister;
+import org.simpleframework.xml.stream.Format;
+import org.simpleframework.xml.stream.HyphenStyle;
+import org.simpleframework.xml.stream.Verbosity;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class SimpleXmlConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<MyObject> get();
+    @POST("/") Call<MyObject> post(@Body MyObject impl);
+    @GET("/") Call<String> wrongClass();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
+    Persister persister = new Persister(format);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(SimpleXmlConverterFactory.create(persister))
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void bodyWays() throws IOException, InterruptedException {
+    server.enqueue(new MockResponse().setBody(
+        "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+    Call<MyObject> call = service.post(new MyObject("hello world", 10));
+    Response<MyObject> response = call.execute();
+    MyObject body = response.body();
+    assertThat(body.getMessage()).isEqualTo("hello world");
+    assertThat(body.getCount()).isEqualTo(10);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo(
+        "<my-object><message>hello world</message><count>10</count></my-object>");
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e.getCause()).isInstanceOf(ElementException.class)
+          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit.MyObject");
+    }
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    server.enqueue(new MockResponse().setBody(
+        "<my-object><message>hello world</message><count>10</count></my-object>"));
+
+    Call<?> call = service.wrongClass();
+    try {
+      call.execute();
+      fail();
+    } catch (RuntimeException e) {
+      assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+    }
+  }
+}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
deleted file mode 100644
index 3c34b55f4..000000000
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Before;
-import org.junit.Test;
-import org.simpleframework.xml.Default;
-import org.simpleframework.xml.DefaultType;
-import org.simpleframework.xml.Element;
-import org.simpleframework.xml.core.Persister;
-import org.simpleframework.xml.stream.Format;
-import org.simpleframework.xml.stream.HyphenStyle;
-import org.simpleframework.xml.stream.Verbosity;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class SimpleXMLConverterTest {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
-  private static final MyObject OBJ = new MyObject("hello world", 10);
-  private static final String XML =
-      "<my-object><message>hello world</message><count>10</count></my-object>";
-
-  private Converter converter;
-
-  @Before public void setUp() {
-    Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
-    Persister persister = new Persister(format);
-    converter = new SimpleXMLConverter(persister);
-  }
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(OBJ, MyObject.class);
-    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
-    assertBody(body).isEqualTo(XML);
-  }
-
-  @Test public void deserialize() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
-    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
-    assertThat(result).isEqualTo(OBJ);
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
-    try {
-      converter.fromBody(body, MyObject.class);
-    } catch (RuntimeException ignored) {
-    }
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
-    Object result = converter.fromBody(body, String.class);
-    assertThat(result).isNull();
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
-      throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-
-  @Default(value = DefaultType.FIELD) static class MyObject {
-    @Element private String message;
-    @Element private int count;
-
-    public MyObject() {
-    }
-
-    public MyObject(String message, int count) {
-      this.message = message;
-      this.count = count;
-    }
-
-    public void setMessage(String message) {
-      this.message = message;
-    }
-
-    public String getMessage() {
-      return message;
-    }
-
-    public void setCount(int count) {
-      this.count = count;
-    }
-
-    public int getCount() {
-      return count;
-    }
-
-    @Override public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      result = prime * result + count;
-      result = prime * result + ((message == null) ? 0 : message.hashCode());
-      return result;
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null) {
-        return false;
-      }
-      if (getClass() != obj.getClass()) {
-        return false;
-      }
-      MyObject other = (MyObject) obj;
-      if (count != other.count) {
-        return false;
-      }
-      if (message == null) {
-        if (other.message != null) {
-          return false;
-        }
-      } else if (!message.equals(other.message)) {
-        return false;
-      }
-      return true;
-    }
-  }
-}
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index f56ef5fcb..d2bf06f14 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -26,6 +26,13 @@
     <dependency>
       <groupId>com.squareup.wire</groupId>
       <artifactId>wire-runtime</artifactId>
+      <exclusions>
+        <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
+        <exclusion>
+          <groupId>com.squareup.okio</groupId>
+          <artifactId>okio</artifactId>
+        </exclusion>
+      </exclusions>
     </dependency>
 
     <dependency>
@@ -34,13 +41,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
new file mode 100644
index 000000000..569527460
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireConverterFactory.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A {@linkplain Converter.Factory converter} that uses Wire for protocol buffers.
+ * <p>
+ * This converter only applies for types which extend from {@link Message} (or one of its
+ * subclasses).
+ */
+public final class WireConverterFactory extends Converter.Factory {
+  /** Create an instance using a default {@link Wire} instance for conversion. */
+  public static WireConverterFactory create() {
+    return create(new Wire());
+  }
+
+  /** Create an instance using {@code wire} for conversion. */
+  public static WireConverterFactory create(Wire wire) {
+    return new WireConverterFactory(wire);
+  }
+
+  private final Wire wire;
+
+  /** Create a converter using the supplied {@link Wire} instance. */
+  private WireConverterFactory(Wire wire) {
+    if (wire == null) throw new NullPointerException("wire == null");
+    this.wire = wire;
+  }
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    Class<?> c = (Class<?>) type;
+    if (!Message.class.isAssignableFrom(c)) {
+      return null;
+    }
+    //noinspection unchecked
+    return new WireResponseBodyConverter<>(wire, (Class<? extends Message>) c);
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (!(type instanceof Class<?>)) {
+      return null;
+    }
+    if (!Message.class.isAssignableFrom((Class<?>) type)) {
+      return null;
+    }
+    return new WireRequestBodyConverter<>();
+  }
+}
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
new file mode 100644
index 000000000..fd2defd6e
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireRequestBodyConverter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.wire.Message;
+import java.io.IOException;
+
+final class WireRequestBodyConverter<T extends Message> implements Converter<T, RequestBody> {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
+
+  @Override public RequestBody convert(T value) throws IOException {
+    byte[] bytes = value.toByteArray();
+    return RequestBody.create(MEDIA_TYPE, bytes);
+  }
+}
diff --git a/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
new file mode 100644
index 000000000..13530a9ad
--- /dev/null
+++ b/retrofit-converters/wire/src/main/java/retrofit/WireResponseBodyConverter.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.wire.Message;
+import com.squareup.wire.Wire;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class WireResponseBodyConverter<T extends Message> implements Converter<ResponseBody, T> {
+  private final Wire wire;
+  private final Class<T> cls;
+
+  WireResponseBodyConverter(Wire wire, Class<T> cls) {
+    this.wire = wire;
+    this.cls = cls;
+  }
+
+  @Override public T convert(ResponseBody value) throws IOException {
+    BufferedSource source = value.source();
+    try {
+      return wire.parseFrom(source, cls);
+    } finally {
+      Utils.closeQuietly(source);
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
deleted file mode 100644
index e44c50615..000000000
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.wire.Message;
-import com.squareup.wire.Wire;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Type;
-
-/** A {@link Converter} that reads and writes protocol buffers using Wire. */
-public class WireConverter implements Converter {
-  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
-
-  private final Wire wire;
-
-  /** Create a converter with a default {@link Wire} instance. */
-  public WireConverter() {
-    this(new Wire());
-  }
-
-  /** Create a converter using the supplied {@link Wire} instance. */
-  public WireConverter(Wire wire) {
-    if (wire == null) throw new NullPointerException("wire == null");
-    this.wire = wire;
-  }
-
-  @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    if (!(type instanceof Class<?>)) {
-      throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
-    }
-    Class<?> c = (Class<?>) type;
-    if (!Message.class.isAssignableFrom(c)) {
-      throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
-    }
-
-    InputStream in = body.byteStream();
-    try {
-      return wire.parseFrom(in, (Class<Message>) c);
-    } finally {
-      try {
-        in.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    if (!(object instanceof Message)) {
-      throw new IllegalArgumentException(
-          "Expected a proto message but was " + (object != null ? object.getClass().getName()
-              : "null"));
-    }
-    byte[] bytes = ((Message) object).toByteArray();
-    return RequestBody.create(MEDIA_TYPE, bytes);
-  }
-}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Phone.java b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
new file mode 100644
index 000000000..e8a47989d
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
@@ -0,0 +1,69 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/person.proto
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoField;
+
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.OPTIONAL;
+
+public final class Phone extends Message {
+
+  public static final String DEFAULT_PHONE = "";
+
+  @ProtoField(tag = 1, type = STRING, label = OPTIONAL)
+  public final String number;
+
+  public Phone(String number) {
+    this.number = number;
+  }
+
+  private Phone(Builder builder) {
+    this(builder.number);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof Phone)) return false;
+    Phone o = (Phone) other;
+    return equals(number, o.number);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = number != null ? number.hashCode() : 0;
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<Phone> {
+
+    public String number;
+
+    public Builder() {
+    }
+
+    public Builder(Phone message) {
+      super(message);
+      if (message == null) return;
+      this.number = message.number;
+    }
+
+    public Builder number(String name) {
+      this.number = name;
+      return this;
+    }
+
+    @Override
+    public Phone build() {
+      checkRequiredFields();
+      return new Phone(this);
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
new file mode 100644
index 000000000..9019654ec
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterFactoryTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class WireConverterFactoryTest {
+  interface Service {
+    @GET("/") Call<Phone> get();
+    @POST("/") Call<Phone> post(@Body Phone impl);
+    @GET("/") Call<String> wrongClass();
+    @GET("/") Call<List<String>> wrongType();
+  }
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private Service service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(WireConverterFactory.create())
+        .build();
+    service = retrofit.create(Service.class);
+  }
+
+  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<Phone> call = service.post(new Phone("(519) 867-5309"));
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.number).isEqualTo("(519) 867-5309");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
+    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
+  }
+
+  @Test public void deserializeEmpty() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call<Phone> call = service.get();
+    Response<Phone> response = call.execute();
+    Phone body = response.body();
+    assertThat(body.number).isNull();
+  }
+
+  @Test public void deserializeWrongClass() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongClass();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method Service.wrongClass");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.WireConverterFactory");
+    }
+  }
+
+  @Test public void deserializeWrongType() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    try {
+      service.wrongType();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for java.util.List<java.lang.String>\n"
+          + "    for method Service.wrongType");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for java.util.List<java.lang.String>. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.WireConverterFactory");
+    }
+  }
+
+  @Test public void deserializeWrongValue() throws IOException {
+    ByteString encoded = ByteString.decodeBase64("////");
+    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
+
+    Call<?> call = service.get();
+    try {
+      call.execute();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java b/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
deleted file mode 100644
index efffba3cb..000000000
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/Person.java
+++ /dev/null
@@ -1,248 +0,0 @@
-// Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: ../wire-runtime/src/test/proto/person.proto
-package retrofit.converter;
-
-import com.squareup.wire.Message;
-import com.squareup.wire.ProtoEnum;
-import com.squareup.wire.ProtoField;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.wire.Message.Datatype.ENUM;
-import static com.squareup.wire.Message.Datatype.INT32;
-import static com.squareup.wire.Message.Datatype.STRING;
-import static com.squareup.wire.Message.Label.REPEATED;
-import static com.squareup.wire.Message.Label.REQUIRED;
-
-public final class Person extends Message {
-
-  public static final String DEFAULT_NAME = "";
-  public static final Integer DEFAULT_ID = 0;
-  public static final String DEFAULT_EMAIL = "";
-  public static final List<PhoneNumber> DEFAULT_PHONE = Collections.emptyList();
-
-  /**
-   * The customer's full name.
-   */
-  @ProtoField(tag = 1, type = STRING, label = REQUIRED)
-  public final String name;
-
-  /**
-   * The customer's ID number.
-   */
-  @ProtoField(tag = 2, type = INT32, label = REQUIRED)
-  public final Integer id;
-
-  /**
-   * Email address for the customer.
-   */
-  @ProtoField(tag = 3, type = STRING)
-  public final String email;
-
-  /**
-   * A list of the customer's phone numbers.
-   */
-  @ProtoField(tag = 4, label = REPEATED)
-  public final List<PhoneNumber> phone;
-
-  public Person(String name, Integer id, String email, List<PhoneNumber> phone) {
-    this.name = name;
-    this.id = id;
-    this.email = email;
-    this.phone = immutableCopyOf(phone);
-  }
-
-  private Person(Builder builder) {
-    this(builder.name, builder.id, builder.email, builder.phone);
-    setBuilder(builder);
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) return true;
-    if (!(other instanceof Person)) return false;
-    Person o = (Person) other;
-    return equals(name, o.name)
-        && equals(id, o.id)
-        && equals(email, o.email)
-        && equals(phone, o.phone);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = hashCode;
-    if (result == 0) {
-      result = name != null ? name.hashCode() : 0;
-      result = result * 37 + (id != null ? id.hashCode() : 0);
-      result = result * 37 + (email != null ? email.hashCode() : 0);
-      result = result * 37 + (phone != null ? phone.hashCode() : 1);
-      hashCode = result;
-    }
-    return result;
-  }
-
-  public static final class Builder extends Message.Builder<Person> {
-
-    public String name;
-    public Integer id;
-    public String email;
-    public List<PhoneNumber> phone;
-
-    public Builder() {
-    }
-
-    public Builder(Person message) {
-      super(message);
-      if (message == null) return;
-      this.name = message.name;
-      this.id = message.id;
-      this.email = message.email;
-      this.phone = copyOf(message.phone);
-    }
-
-    /**
-     * The customer's full name.
-     */
-    public Builder name(String name) {
-      this.name = name;
-      return this;
-    }
-
-    /**
-     * The customer's ID number.
-     */
-    public Builder id(Integer id) {
-      this.id = id;
-      return this;
-    }
-
-    /**
-     * Email address for the customer.
-     */
-    public Builder email(String email) {
-      this.email = email;
-      return this;
-    }
-
-    /**
-     * A list of the customer's phone numbers.
-     */
-    public Builder phone(List<PhoneNumber> phone) {
-      this.phone = checkForNulls(phone);
-      return this;
-    }
-
-    @Override
-    public Person build() {
-      checkRequiredFields();
-      return new Person(this);
-    }
-  }
-
-  public enum PhoneType
-      implements ProtoEnum {
-    MOBILE(0),
-    HOME(1),
-    /**
-     * Could be phone or fax.
-     */
-    WORK(2);
-
-    private final int value;
-
-    private PhoneType(int value) {
-      this.value = value;
-    }
-
-    @Override
-    public int getValue() {
-      return value;
-    }
-  }
-
-  public static final class PhoneNumber extends Message {
-
-    public static final String DEFAULT_NUMBER = "";
-    public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
-
-    /**
-     * The customer's phone number.
-     */
-    @ProtoField(tag = 1, type = STRING, label = REQUIRED)
-    public final String number;
-
-    /**
-     * The type of phone stored here.
-     */
-    @ProtoField(tag = 2, type = ENUM)
-    public final PhoneType type;
-
-    public PhoneNumber(String number, PhoneType type) {
-      this.number = number;
-      this.type = type;
-    }
-
-    private PhoneNumber(Builder builder) {
-      this(builder.number, builder.type);
-      setBuilder(builder);
-    }
-
-    @Override
-    public boolean equals(Object other) {
-      if (other == this) return true;
-      if (!(other instanceof PhoneNumber)) return false;
-      PhoneNumber o = (PhoneNumber) other;
-      return equals(number, o.number)
-          && equals(type, o.type);
-    }
-
-    @Override
-    public int hashCode() {
-      int result = hashCode;
-      if (result == 0) {
-        result = number != null ? number.hashCode() : 0;
-        result = result * 37 + (type != null ? type.hashCode() : 0);
-        hashCode = result;
-      }
-      return result;
-    }
-
-    public static final class Builder extends Message.Builder<PhoneNumber> {
-
-      public String number;
-      public PhoneType type;
-
-      public Builder() {
-      }
-
-      public Builder(PhoneNumber message) {
-        super(message);
-        if (message == null) return;
-        this.number = message.number;
-        this.type = message.type;
-      }
-
-      /**
-       * The customer's phone number.
-       */
-      public Builder number(String number) {
-        this.number = number;
-        return this;
-      }
-
-      /**
-       * The type of phone stored here.
-       */
-      public Builder type(PhoneType type) {
-        this.type = type;
-        return this;
-      }
-
-      @Override
-      public PhoneNumber build() {
-        checkRequiredFields();
-        return new PhoneNumber(this);
-      }
-    }
-  }
-}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
deleted file mode 100644
index cc719fcbb..000000000
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.converter;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.util.ArrayList;
-import okio.Buffer;
-import okio.ByteString;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WireConverterTest {
-  private static final Person PROTO =
-      new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
-
-  private final WireConverter converter = new WireConverter();
-
-  @Test public void serialize() throws Exception {
-    RequestBody body = converter.toBody(PROTO, Person.class);
-    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
-    assertBody(body).isEqualTo(ENCODED_PROTO);
-  }
-
-  @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
-    assertThat(proto).isEqualTo(PROTO);
-  }
-
-  @Test public void deserializeWrongClass() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
-    }
-  }
-
-  @Test public void deserializeWrongType() throws Exception {
-    try {
-      converter.fromBody(protoResponse(ENCODED_PROTO),
-          ArrayList.class.getGenericSuperclass());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
-    }
-  }
-
-  @Test public void deserializeWrongValue() throws Exception {
-    try {
-      converter.fromBody(protoResponse("////"), Person.class);
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  private static ResponseBody protoResponse(String encodedProto) {
-    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
-        ByteString.decodeBase64(encodedProto).toByteArray());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readByteString().base64());
-  }
-}
diff --git a/retrofit-mock/pom.xml b/retrofit-mock/pom.xml
index d7f00edc5..ca7e9fe07 100644
--- a/retrofit-mock/pom.xml
+++ b/retrofit-mock/pom.xml
@@ -20,18 +20,6 @@
       <version>${project.version}</version>
     </dependency>
 
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <optional>true</optional>
-    </dependency>
-
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
-      <optional>true</optional>
-    </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -47,10 +35,5 @@
       <artifactId>mockito-core</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 </project>
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpException.java b/retrofit-mock/src/main/java/retrofit/MockHttpException.java
deleted file mode 100644
index 390bb9b01..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockHttpException.java
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import retrofit.converter.Converter;
-
-import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
-import static java.net.HttpURLConnection.HTTP_FORBIDDEN;
-import static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-
-/**
- * An exception used to trigger the simulation of an HTTP error for mock services.
- *
- * @see MockRestAdapter
- */
-public class MockHttpException extends RuntimeException {
-  /** Create a new {@link MockHttpException} for HTTP 301 Moved Permanently. */
-  public static MockHttpException newMovedPermanentely(String location, Object responseBody) {
-    if (location == null || "".equals(location.trim())) {
-      throw new IllegalArgumentException("Location must not be blank.");
-    }
-    return new MockHttpException(HTTP_MOVED_PERM, "Moved Permanently", responseBody)
-        .withHeader("Location", location);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 302 Moved Temporarily. */
-  public static MockHttpException newMovedTemporarily(String location, Object responseBody) {
-    if (location == null || "".equals(location.trim())) {
-      throw new IllegalArgumentException("Location must not be blank.");
-    }
-    return new MockHttpException(HTTP_MOVED_TEMP, "Moved Temporarily", responseBody)
-        .withHeader("Location", location);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 400 Bad Request. */
-  public static MockHttpException newBadRequest(Object responseBody) {
-    return new MockHttpException(HTTP_BAD_REQUEST, "Bad Request", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 401 Unauthorized. */
-  public static MockHttpException newUnauthorized(Object responseBody) {
-    return new MockHttpException(HTTP_UNAUTHORIZED, "Unauthorized", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 403 Forbidden. */
-  public static MockHttpException newForbidden(Object responseBody) {
-    return new MockHttpException(HTTP_FORBIDDEN, "Forbidded", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 404 Not Found. */
-  public static MockHttpException newNotFound(Object responseBody) {
-    return new MockHttpException(HTTP_NOT_FOUND, "Not Found", responseBody);
-  }
-
-  /** Create a new {@link MockHttpException} for HTTP 500 Internal Server Error. */
-  public static MockHttpException newInternalError(Object responseBody) {
-    return new MockHttpException(HTTP_INTERNAL_ERROR, "Internal Server Error", responseBody);
-  }
-
-  final int code;
-  final String reason;
-  final Object responseBody;
-  final Headers.Builder headers = new Headers.Builder();
-
-  /**
-   * Create a new HTTP exception.
-   *
-   * @param code HTTP status code to trigger. Must be 300 or higher.
-   * @param reason HTTP status reason message.
-   * @param responseBody Object to use as the contents of the response body.
-   */
-  public MockHttpException(int code, String reason, Object responseBody) {
-    super("HTTP " + code + " " + reason);
-    if (code < 300 || code > 599) {
-      throw new IllegalArgumentException("Unsupported HTTP error code: " + code);
-    }
-    if (reason == null || "".equals(reason.trim())) {
-      throw new IllegalArgumentException("Reason must not be blank.");
-    }
-    this.code = code;
-    this.reason = reason;
-    this.responseBody = responseBody;
-  }
-
-  /** Add a header to the response. */
-  public MockHttpException withHeader(String name, String value) {
-    if (name == null || "".equals(name.trim())) {
-      throw new IllegalArgumentException("Header name must not be blank.");
-    }
-    if (value == null || "".equals(value.trim())) {
-      throw new IllegalArgumentException("Header value must not be blank.");
-    }
-    headers.add(name, value);
-    return this;
-  }
-
-  Response toResponse(Request request, Converter converter) {
-    return new Response.Builder()
-        .code(code)
-        .message(reason)
-        .headers(headers.build())
-        .body(new MockResponseBody(converter, responseBody))
-        .protocol(Protocol.HTTP_1_1)
-        .request(request)
-        .build();
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java b/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
deleted file mode 100644
index 93112f6d1..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockHttpRetrofitError.java
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.lang.reflect.Type;
-
-class MockHttpRetrofitError extends RetrofitError {
-  private final Object body;
-
-  MockHttpRetrofitError(String message, String url, Response response, Object body,
-      Type responseType) {
-    super(message, url, response, null, responseType, Kind.HTTP, null);
-    this.body = body;
-  }
-
-  @Override public Object getBody() {
-    return body;
-  }
-
-  @Override public Object getBodyAs(Type type) {
-    return body;
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
deleted file mode 100644
index 03f1194e9..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import retrofit.converter.Converter;
-
-class MockResponseBody extends ResponseBody {
-  private final Converter converter;
-  private final Object body;
-
-  private byte[] bytes;
-
-  MockResponseBody(Converter converter, Object body) {
-    this.converter = converter;
-    this.body = body;
-  }
-
-  @Override public MediaType contentType() {
-    return MediaType.parse("application/unknown");
-  }
-
-  @Override public long contentLength() {
-    try {
-      initBytes();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-    return bytes.length;
-  }
-
-  @Override public BufferedSource source() {
-    return new Buffer().write(bytes);
-  }
-
-  private synchronized void initBytes() throws IOException {
-    if (bytes == null) {
-      Buffer buffer = new Buffer();
-      converter.toBody(body, body.getClass()).writeTo(buffer);
-      bytes = buffer.readByteArray();
-    }
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java b/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
deleted file mode 100644
index a5bbb9fa4..000000000
--- a/retrofit-mock/src/main/java/retrofit/MockRestAdapter.java
+++ /dev/null
@@ -1,431 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.Map;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import rx.Observable;
-import rx.Scheduler;
-import rx.functions.Func1;
-import rx.schedulers.Schedulers;
-
-import static retrofit.RetrofitError.unexpectedError;
-
-/**
- * Wraps mock implementations of API interfaces so that they exhibit the delay and error
- * characteristics of a real network.
- * <p>
- * Because APIs are defined as interfaces, versions of the API that use mock data can be created by
- * simply implementing the API interface on a class. These mock implementations execute
- * synchronously which is a large deviation from the behavior of those backed by an API call over
- * the network. By wrapping the mock instances using this class, the interface will still use mock
- * data but exhibit the delays and errors that a real network would face.
- * <p>
- * Create an API interface and a mock implementation of it.
- * <pre>
- *   public interface UserService {
- *     &#64;GET("/user/{id}")
- *     User getUser(@Path("id") String userId);
- *   }
- *   public class MockUserService implements UserService {
- *     &#64;Override public User getUser(String userId) {
- *       return new User("Jake");
- *     }
- *   }
- * </pre>
- * Given a {@link RestAdapter} an instance of this class can be created by calling {@link #from}.
- * <pre>
- *   MockRestAdapter mockRestAdapter = MockRestAdapter.from(restAdapter);
- * </pre>
- * Instances of this class should be used as a singleton so that the behavior of every mock service
- * is consistent.
- * <p>
- * Rather than using the {@code MockUserService} directly, pass it through
- * {@link #create(Class, Object) the create method}.
- * <pre>
- *   UserService service = mockRestAdapter.create(UserService.class, new MockUserService());
- * </pre>
- * The returned {@code UserService} instance will now behave like it is happening over the network
- * while allowing the mock implementation to be written synchronously.
- * <p>
- * HTTP errors can be simulated in your mock services by throwing an instance of
- * {@link MockHttpException}. This should be done for both synchronous and asynchronous methods.
- * Do not call the {@link Callback#failure(RetrofitError) failure()} method of a callback.
- */
-public final class MockRestAdapter {
-  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
-  private static final int DEFAULT_VARIANCE_PCT = 40; // Network delay varies by 40%.
-  private static final int DEFAULT_ERROR_PCT = 3; // 3% of network calls will fail.
-  private static final int ERROR_DELAY_FACTOR = 3; // Network errors will be scaled by this value.
-
-  /**
-   * Create a new {@link MockRestAdapter} which will act as a factory for mock services. Some of
-   * the configuration of the supplied {@link RestAdapter} will be used generating mock behavior.
-   */
-  public static MockRestAdapter from(RestAdapter restAdapter, Executor executor) {
-    return new MockRestAdapter(restAdapter, executor);
-  }
-
-  /** A listener invoked when the network behavior values for a {@link MockRestAdapter} change. */
-  public interface ValueChangeListener {
-    void onMockValuesChanged(long delayMs, int variancePct, int errorPct);
-
-    ValueChangeListener EMPTY = new ValueChangeListener() {
-      @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-      }
-    };
-  }
-
-  private final RestAdapter restAdapter;
-  private final Executor executor;
-  private MockRxSupport mockRxSupport;
-  final Random random = new Random();
-
-  private ValueChangeListener listener = ValueChangeListener.EMPTY;
-  private int delayMs = DEFAULT_DELAY_MS;
-  private int variancePct = DEFAULT_VARIANCE_PCT;
-  private int errorPct = DEFAULT_ERROR_PCT;
-
-  private MockRestAdapter(RestAdapter restAdapter, Executor executor) {
-    this.restAdapter = restAdapter;
-    this.executor = executor;
-  }
-
-  /** Set a listener to be notified when any mock value changes. */
-  public void setValueChangeListener(ValueChangeListener listener) {
-    this.listener = listener;
-  }
-
-  private void notifyValueChangeListener() {
-    listener.onMockValuesChanged(delayMs, variancePct, errorPct);
-  }
-
-  /** Set the network round trip delay, in milliseconds. */
-  public void setDelay(long delayMs) {
-    if (delayMs < 0) {
-      throw new IllegalArgumentException("Delay must be positive value.");
-    }
-    if (delayMs > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Delay value too large. Max: " + Integer.MAX_VALUE);
-    }
-    if (this.delayMs != delayMs) {
-      this.delayMs = (int) delayMs;
-      notifyValueChangeListener();
-    }
-  }
-
-  /** The network round trip delay, in milliseconds */
-  public long getDelay() {
-    return delayMs;
-  }
-
-  /** Set the plus-or-minus variance percentage of the network round trip delay. */
-  public void setVariancePercentage(int variancePct) {
-    if (variancePct < 0 || variancePct > 100) {
-      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
-    }
-    if (this.variancePct != variancePct) {
-      this.variancePct = variancePct;
-      notifyValueChangeListener();
-    }
-  }
-
-  /** The plus-or-minus variance percentage of the network round trip delay. */
-  public int getVariancePercentage() {
-    return variancePct;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public void setErrorPercentage(int errorPct) {
-    if (errorPct < 0 || errorPct > 100) {
-      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
-    }
-    if (this.errorPct != errorPct) {
-      this.errorPct = errorPct;
-      notifyValueChangeListener();
-    }
-  }
-
-  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
-  public int getErrorPercentage() {
-    return errorPct;
-  }
-
-  /**
-   * Randomly determine whether this call should result in a network failure.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100) + 1;
-    return randomValue <= errorPct;
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for triggering a network error.
-   * <p>
-   * Because we are triggering an error, use a random delay between 0 and three times the normal
-   * network delay to simulate a flaky connection failing anywhere from quickly to slowly.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public int calculateDelayForError() {
-    return random.nextInt(delayMs * ERROR_DELAY_FACTOR);
-  }
-
-  /**
-   * Get the delay (in milliseconds) that should be used for delaying a network call response.
-   * <p>
-   * This method is exposed for implementing other, non-Retrofit services which exhibit similar
-   * network behavior. Retrofit services automatically will exhibit network behavior when wrapped
-   * using {@link #create(Class, Object)}.
-   */
-  public int calculateDelayForCall() {
-    float errorPercent = variancePct / 100f; // e.g., 20 / 100f == 0.2f
-    float lowerBound = 1f - errorPercent; // 0.2f --> 0.8f
-    float upperBound = 1f + errorPercent; // 0.2f --> 1.2f
-    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
-    float delayPercent = (random.nextFloat() * bound) + lowerBound; // 0.8 + (rnd * 0.4)
-    return (int) (delayMs * delayPercent);
-  }
-
-  /**
-   * Wrap the supplied mock implementation of a service so that it exhibits the delay and error
-   * characteristics of a real network.
-   *
-   * @see #setDelay(long)
-   * @see #setVariancePercentage(int)
-   * @see #setErrorPercentage(int)
-   */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service, T mockService) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new MockHandler(mockService, restAdapter.getMethodInfoCache(service)));
-  }
-
-  private class MockHandler implements InvocationHandler {
-    private final Object mockService;
-    private final Map<Method, MethodInfo> methodInfoCache;
-
-    public MockHandler(Object mockService, Map<Method, MethodInfo> methodInfoCache) {
-      this.mockService = mockService;
-      this.methodInfoCache = methodInfoCache;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      // Load or create the details cache for the current method.
-      final MethodInfo methodInfo = RestAdapter.getMethodInfo(methodInfoCache, method);
-      final Request request = buildRequest(methodInfo, restAdapter.requestInterceptor, args);
-
-      if (methodInfo.executionType == MethodInfo.ExecutionType.SYNC) {
-        try {
-          return invokeSync(methodInfo, args, request);
-        } catch (RetrofitError error) {
-          Throwable newError = restAdapter.errorHandler.handleError(error);
-          if (newError == null) {
-            throw new IllegalStateException("Error handler returned null for wrapped exception.",
-                error);
-          }
-          throw newError;
-        }
-      }
-
-      if (methodInfo.executionType == MethodInfo.ExecutionType.RX) {
-        if (mockRxSupport == null) {
-          if (Platform.HAS_RX_JAVA) {
-            mockRxSupport = new MockRxSupport(restAdapter, executor);
-          } else {
-            throw new IllegalStateException("Observable method found but no RxJava on classpath");
-          }
-        }
-        return mockRxSupport.createMockObservable(this, methodInfo, args, request);
-      }
-
-      executor.execute(new Runnable() {
-        @Override public void run() {
-          invokeAsync(methodInfo, args, request);
-        }
-      });
-      return null; // Asynchronous methods should have return type of void.
-    }
-
-    private Request buildRequest(MethodInfo methodInfo, RequestInterceptor interceptor,
-        Object[] args) throws Throwable {
-      // Begin building a normal request.
-      String apiUrl = restAdapter.endpoint.url();
-      RequestBuilder requestBuilder = new RequestBuilder(apiUrl, methodInfo, restAdapter.converter);
-      requestBuilder.setArguments(args);
-
-      // Run it through the interceptor.
-      interceptor.intercept(requestBuilder);
-
-      return requestBuilder.build();
-    }
-
-    private Object invokeSync(MethodInfo methodInfo, Object[] args, Request request)
-        throws Throwable {
-      String url = request.urlString();
-
-      if (calculateIsFailure()) {
-        sleep(calculateDelayForError());
-        IOException exception = new IOException("Mock network error!");
-        throw RetrofitError.networkFailure(url, exception);
-      }
-
-      int callDelay = calculateDelayForCall();
-      long beforeNanos = System.nanoTime();
-      try {
-        Object returnValue = methodInfo.method.invoke(mockService, args);
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-        sleep(callDelay - tookMs);
-
-        return returnValue;
-      } catch (InvocationTargetException e) {
-        Throwable innerEx = e.getCause();
-        if (!(innerEx instanceof MockHttpException)) {
-          throw innerEx;
-        }
-        MockHttpException httpEx = (MockHttpException) innerEx;
-        Response response = httpEx.toResponse(request, restAdapter.converter);
-
-        // Sleep for whatever amount of time is left to satisfy the network delay, if any.
-        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - beforeNanos);
-        sleep(callDelay - tookMs);
-
-        throw new MockHttpRetrofitError(httpEx.reason, url, response, httpEx.responseBody,
-            methodInfo.responseObjectType);
-      }
-    }
-
-    private void invokeAsync(final MethodInfo methodInfo, final Object[] args,
-        final Request request) {
-      final String url = request.urlString();
-      final Callback callback = (Callback) args[args.length - 1];
-
-      if (calculateIsFailure()) {
-        sleep(calculateDelayForError());
-        IOException exception = new IOException("Mock network error!");
-        RetrofitError error = RetrofitError.networkFailure(url, exception);
-        Throwable cause = restAdapter.errorHandler.handleError(error);
-        final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
-        restAdapter.callbackExecutor.execute(new Runnable() {
-          @Override public void run() {
-            callback.failure(e);
-          }
-        });
-        return;
-      }
-
-      final int callDelay = calculateDelayForCall();
-      sleep(callDelay);
-
-      restAdapter.callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          try {
-            methodInfo.method.invoke(mockService, args);
-          } catch (Throwable throwable) {
-            final Throwable innerEx = throwable.getCause();
-            if (!(innerEx instanceof MockHttpException)) {
-              if (innerEx instanceof RuntimeException) {
-                throw (RuntimeException) innerEx;
-              }
-              throw new RuntimeException(innerEx);
-            }
-
-            MockHttpException httpEx = (MockHttpException) innerEx;
-            Response response = httpEx.toResponse(request, restAdapter.converter);
-
-            RetrofitError error = new MockHttpRetrofitError(httpEx.getMessage(), url, response,
-                httpEx.responseBody, methodInfo.responseObjectType);
-            Throwable cause = restAdapter.errorHandler.handleError(error);
-            final RetrofitError e = cause == error ? error : unexpectedError(error.getUrl(), cause);
-            callback.failure(e);
-          }
-        }
-      });
-    }
-  }
-
-  /**
-   * Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to {@link
-   * Thread#sleep(long)}, but does not throw {@link InterruptedException}; {@link
-   * Thread#interrupt()} events are deferred until the next interruptible operation.  Does not
-   * return until at least the specified number of milliseconds has elapsed.
-   *
-   * @param ms to sleep before returning, in milliseconds of uptime.
-   */
-  private static void sleep(long ms) {
-    // This implementation is modified from Android's SystemClock#sleep.
-
-    long start = uptimeMillis();
-    long duration = ms;
-    boolean interrupted = false;
-    while (duration > 0) {
-      try {
-        Thread.sleep(duration);
-      } catch (InterruptedException e) {
-        interrupted = true;
-      }
-      duration = start + ms - uptimeMillis();
-    }
-
-    if (interrupted) {
-      // Important: we don't want to quietly eat an interrupt() event,
-      // so we make sure to re-interrupt the thread so that the next
-      // call to Thread.sleep() or Object.wait() will be interrupted.
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private static long uptimeMillis() {
-    return System.nanoTime() / 1000000L;
-  }
-
-  /** Indirection to avoid VerifyError if RxJava isn't present. */
-  private static class MockRxSupport {
-    private final Scheduler httpScheduler;
-    private final ErrorHandler errorHandler;
-
-    MockRxSupport(RestAdapter restAdapter, Executor executor) {
-      httpScheduler = Schedulers.from(executor);
-      errorHandler = restAdapter.errorHandler;
-    }
-
-    Observable createMockObservable(final MockHandler mockHandler, final MethodInfo methodInfo,
-        final Object[] args, final Request request) {
-      return Observable.just("nothing") //
-          .flatMap(new Func1<String, Observable<?>>() {
-            @Override public Observable<?> call(String s) {
-              try {
-                return (Observable) mockHandler.invokeSync(methodInfo, args, request);
-              } catch (RetrofitError e) {
-                return Observable.error(errorHandler.handleError(e));
-              } catch (Throwable throwable) {
-                return Observable.error(throwable);
-              }
-            }
-          }).subscribeOn(httpScheduler);
-    }
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java b/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
deleted file mode 100644
index 80cab9abc..000000000
--- a/retrofit-mock/src/main/java/retrofit/android/AndroidMockValuePersistence.java
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit.android;
-
-import android.content.SharedPreferences;
-import retrofit.MockRestAdapter;
-
-/**
- * A {@link MockRestAdapter.ValueChangeListener value change listener} for {@link MockRestAdapter}
- * which stores any customized behavior values into shared preferences.
- */
-public final class AndroidMockValuePersistence implements MockRestAdapter.ValueChangeListener {
-  private static final String KEY_DELAY = "retrofit-mock-delay";
-  private static final String KEY_VARIANCE = "retrofit-mock-variance";
-  private static final String KEY_ERROR = "retrofit-mock-error";
-
-  /**
-   * Install a {@link MockRestAdapter.ValueChangeListener value change listener} on the supplied
-   * {@link MockRestAdapter} using the {@link SharedPreferences} for storing customized behavior
-   * values. Invoking this will load any existing stored values for the mock adapter's behavior.
-   */
-  public static void install(MockRestAdapter mockRestAdapter, SharedPreferences preferences) {
-    long delay = preferences.getLong(KEY_DELAY, -1);
-    if (delay != -1) {
-      mockRestAdapter.setDelay(delay);
-    }
-
-    int variance = preferences.getInt(KEY_VARIANCE, -1);
-    if (variance != -1) {
-      mockRestAdapter.setVariancePercentage(variance);
-    }
-
-    int error = preferences.getInt(KEY_ERROR, -1);
-    if (error != -1) {
-      mockRestAdapter.setErrorPercentage(error);
-    }
-
-    mockRestAdapter.setValueChangeListener(new AndroidMockValuePersistence(preferences));
-  }
-
-  private final SharedPreferences preferences;
-
-  private AndroidMockValuePersistence(SharedPreferences preferences) {
-    this.preferences = preferences;
-  }
-
-  @Override public void onMockValuesChanged(long delayMs, int variancePct, int errorPct) {
-    preferences.edit()
-        .putLong(KEY_DELAY, delayMs)
-        .putInt(KEY_VARIANCE, variancePct)
-        .putInt(KEY_ERROR, errorPct)
-        .apply();
-  }
-}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
new file mode 100644
index 000000000..6857cdc8b
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class BehaviorCall<T> implements Call<T> {
+  private final NetworkBehavior behavior;
+  private final ExecutorService backgroundExecutor;
+  private final Executor callbackExecutor;
+  private final Call<T> delegate;
+
+  private volatile Future<?> task;
+  private volatile boolean canceled;
+  private volatile boolean executed;
+
+  BehaviorCall(NetworkBehavior behavior, ExecutorService backgroundExecutor,
+      Executor callbackExecutor, Call<T> delegate) {
+    if (callbackExecutor == null) {
+      callbackExecutor = new Executor() {
+        @Override public void execute(Runnable command) {
+          command.run();
+        }
+      };
+    }
+    this.behavior = behavior;
+    this.backgroundExecutor = backgroundExecutor;
+    this.callbackExecutor = callbackExecutor;
+    this.delegate = delegate;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public Call<T> clone() {
+    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, delegate.clone());
+  }
+
+  @Override public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+    task = backgroundExecutor.submit(new Runnable() {
+      private boolean delaySleep() {
+        long sleepMs = behavior.calculateDelay(MILLISECONDS);
+        if (sleepMs > 0) {
+          try {
+            Thread.sleep(sleepMs);
+          } catch (InterruptedException e) {
+            callFailure(new InterruptedIOException("canceled"));
+            return false;
+          }
+        }
+        return true;
+      }
+
+      private void callResponse(final Response<T> response) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onResponse(response);
+          }
+        });
+      }
+
+      private void callFailure(final Throwable throwable) {
+        callbackExecutor.execute(new Runnable() {
+          @Override public void run() {
+            callback.onFailure(throwable);
+          }
+        });
+      }
+
+      @Override public void run() {
+        if (canceled) {
+          callFailure(new InterruptedIOException("canceled"));
+        } else if (behavior.calculateIsFailure()) {
+          if (delaySleep()) {
+            callFailure(behavior.failureException());
+          }
+        } else {
+          delegate.enqueue(new Callback<T>() {
+            @Override public void onResponse(final Response<T> response) {
+              if (delaySleep()) {
+                callResponse(response);
+              }
+            }
+
+            @Override public void onFailure(final Throwable t) {
+              if (delaySleep()) {
+                callFailure(t);
+              }
+            }
+          });
+        }
+      }
+    });
+  }
+
+  @Override public Response<T> execute() throws IOException {
+    final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    enqueue(new Callback<T>() {
+      @Override public void onResponse(Response<T> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException("canceled");
+    }
+    Response<T> response = responseRef.get();
+    if (response != null) return response;
+    Throwable failure = failureRef.get();
+    if (failure instanceof RuntimeException) throw (RuntimeException) failure;
+    if (failure instanceof IOException) throw (IOException) failure;
+    throw new RuntimeException(failure);
+  }
+
+  @Override public void cancel() {
+    canceled = true;
+    Future<?> task = this.task;
+    if (task != null) {
+      task.cancel(true);
+    }
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
new file mode 100644
index 000000000..551f706f0
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/CallBehaviorAdapter.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import retrofit.Call;
+import retrofit.Retrofit;
+
+public final class CallBehaviorAdapter implements NetworkBehavior.Adapter<Call<?>> {
+  private final Executor callbackExecutor;
+  private final ExecutorService backgroundExecutor;
+
+  /**
+   * Create an instance with a normal {@link Retrofit} instance and an executor service on which
+   * the simulated delays will be created. Instances of this class should be re-used so that the
+   * behavior of every mock service is consistent.
+   */
+  public CallBehaviorAdapter(Retrofit retrofit, ExecutorService backgroundExecutor) {
+    this.callbackExecutor = retrofit.callbackExecutor();
+    this.backgroundExecutor = backgroundExecutor;
+  }
+
+  @Override public Call<?> applyBehavior(NetworkBehavior behavior, Call<?> value) {
+    return new BehaviorCall<>(behavior, backgroundExecutor, callbackExecutor, value);
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
new file mode 100644
index 000000000..e1d0e7e4f
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import retrofit.Call;
+import retrofit.Callback;
+import retrofit.Response;
+
+/** Factory methods for creating {@link Call} instances which immediately respond or fail. */
+public final class Calls {
+  public static <T> Call<T> response(T successValue) {
+    return response(Response.success(successValue));
+  }
+
+  public static <T> Call<T> response(final Response<T> response) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        return response;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onResponse(response);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  public static <T> Call<T> failure(final IOException failure) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        throw failure;
+      }
+
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onFailure(failure);
+      }
+
+      @Override public void cancel() {
+      }
+
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
+    };
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
new file mode 100644
index 000000000..71aaaca6d
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/MockRetrofit.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+public final class MockRetrofit {
+  private final NetworkBehavior behavior;
+  private final NetworkBehavior.Adapter<Object> adapter;
+
+  @SuppressWarnings("unchecked") //
+  public MockRetrofit(NetworkBehavior behavior, NetworkBehavior.Adapter<?> adapter) {
+    this.adapter = (NetworkBehavior.Adapter<Object>) adapter;
+    this.behavior = behavior;
+  }
+
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(Class<T> service, final T instance) {
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service },
+        new InvocationHandler() {
+          @Override public Object invoke(Object proxy, Method method, Object[] args)
+              throws Throwable {
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            method.setAccessible(true); // Just In Case
+
+            Object value = method.invoke(instance, args);
+            return adapter.applyBehavior(behavior, value);
+          }
+        });
+  }
+}
diff --git a/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
new file mode 100644
index 000000000..f3fdffb77
--- /dev/null
+++ b/retrofit-mock/src/main/java/retrofit/mock/NetworkBehavior.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+/**
+ * A simple emulation of the behavior of network calls.
+ * <p>
+ * This class models three properties of a network:
+ * <ul>
+ * <li>Delay  the time it takes before a response is received (successful or otherwise).</li>
+ * <li>Variance  the amount of fluctuation of the delay to be faster or slower.</li>
+ * <li>Failure - the percentage of operations which fail (such as {@link IOException}).</li>
+ * </ul>
+ * Behavior can be applied to a Retrofit interface with {@link MockRetrofit}. Behavior can also
+ * be applied elsewhere using {@link #calculateDelay(TimeUnit)} and {@link #calculateIsFailure()}.
+ * <p>
+ * By default, instances of this class will use a 2 second delay with 40% variance and failures
+ * will occur 3% of the time.
+ */
+public final class NetworkBehavior {
+  private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
+  private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by 40%.
+  private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
+
+  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+  public interface Adapter<T> {
+    /**
+     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+     * traits when interacted with.
+     */
+    T applyBehavior(NetworkBehavior behavior, T value);
+  }
+
+  /** Create an instance with default behavior. */
+  public static NetworkBehavior create() {
+    return new NetworkBehavior(new Random());
+  }
+
+  /**
+   * Create an instance with default behavior which uses {@code random} to control variance and
+   * failure calculation.
+   */
+  public static NetworkBehavior create(Random random) {
+    if (random == null) throw new NullPointerException("random == null");
+    return new NetworkBehavior(random);
+  }
+
+  private final Random random;
+
+  private volatile long delayMs = DEFAULT_DELAY_MS;
+  private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
+  private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
+  private volatile Throwable failureException = new IOException("Mock failure!");
+
+  private NetworkBehavior(Random random) {
+    this.random = random;
+  }
+
+  /** Set the network round trip delay. */
+  public void setDelay(long amount, TimeUnit unit) {
+    if (amount < 0) {
+      throw new IllegalArgumentException("Amount must be positive value.");
+    }
+    this.delayMs = unit.toMillis(amount);
+  }
+
+  /** The network round trip delay. */
+  public long delay(TimeUnit unit) {
+    return MILLISECONDS.convert(delayMs, unit);
+  }
+
+  /** Set the plus-or-minus variance percentage of the network round trip delay. */
+  public void setVariancePercent(int variancePercent) {
+    if (variancePercent < 0 || variancePercent > 100) {
+      throw new IllegalArgumentException("Variance percentage must be between 0 and 100.");
+    }
+    this.variancePercent = variancePercent;
+  }
+
+  /** The plus-or-minus variance percentage of the network round trip delay. */
+  public int variancePercent() {
+    return variancePercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public void setFailurePercent(int failurePercent) {
+    if (failurePercent < 0 || failurePercent > 100) {
+      throw new IllegalArgumentException("Failure percentage must be between 0 and 100.");
+    }
+    this.failurePercent = failurePercent;
+  }
+
+  /** The percentage of calls to {@link #calculateIsFailure()} that return {@code true}. */
+  public int failurePercent() {
+    return failurePercent;
+  }
+
+  /** Set the exception to be used when a failure is triggered. */
+  public void setFailureException(Throwable t) {
+    if (t == null) {
+      throw new NullPointerException("t == null");
+    }
+    this.failureException = t;
+  }
+
+  /** The exception to be used when a failure is triggered. */
+  public Throwable failureException() {
+    return failureException;
+  }
+
+  /**
+   * Randomly determine whether this call should result in a network failure in accordance with
+   * configured behavior. When true, {@link #failureException()} should be thrown.
+   */
+  public boolean calculateIsFailure() {
+    int randomValue = random.nextInt(100);
+    return randomValue < failurePercent;
+  }
+
+  /**
+   * Get the delay that should be used for delaying a response in accordance with configured
+   * behavior.
+   */
+  public long calculateDelay(TimeUnit unit) {
+    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f
+    float lowerBound = 1f - delta; // 0.2f --> 0.8f
+    float upperBound = 1f + delta; // 0.2f --> 1.2f
+    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f
+    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)
+    long callDelayMs = (long) (delayMs * delayPercent);
+    return MILLISECONDS.convert(callDelayMs, unit);
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java b/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
deleted file mode 100644
index d187b7895..000000000
--- a/retrofit-mock/src/test/java/retrofit/MockRestAdapterTest.java
+++ /dev/null
@@ -1,632 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.http.GET;
-import rx.Observable;
-import rx.functions.Action1;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static retrofit.MockRestAdapter.ValueChangeListener;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class MockRestAdapterTest {
-  interface SyncExample {
-    @GET("/") Object doStuff();
-  }
-
-  interface AsyncExample {
-    @GET("/") void doStuff(Callback<String> cb);
-  }
-
-  interface AsyncCallbackSubtypeExample {
-    abstract class Foo implements Callback<String> {}
-
-    @GET("/") void doStuff(Foo foo);
-  }
-
-  interface ObservableExample {
-    @GET("/") Observable<String> doStuff();
-  }
-
-  private Executor httpExecutor;
-  private Executor callbackExecutor;
-  private MockRestAdapter mockRestAdapter;
-  private ValueChangeListener valueChangeListener;
-  private Throwable nextError;
-
-  @Before public void setUp() throws IOException {
-    httpExecutor = spy(new SynchronousExecutor());
-    callbackExecutor = spy(new SynchronousExecutor());
-
-    RestAdapter restAdapter = new RestAdapter.Builder() //
-        .setCallbackExecutor(callbackExecutor)
-        .setEndpoint("none")
-        .setErrorHandler(new ErrorHandler() {
-          @Override public Throwable handleError(RetrofitError cause) {
-            if (nextError != null) {
-              Throwable error = nextError;
-              nextError = null;
-              return error;
-            }
-            return cause;
-          }
-        })
-        .build();
-
-    valueChangeListener = mock(ValueChangeListener.class);
-
-    mockRestAdapter = MockRestAdapter.from(restAdapter, httpExecutor);
-    mockRestAdapter.setValueChangeListener(valueChangeListener);
-
-    // Seed the random with a value so the tests are deterministic.
-    mockRestAdapter.random.setSeed(2847);
-  }
-
-  @Test public void delayRestrictsRange() {
-    try {
-      mockRestAdapter.setDelay(-1);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Delay must be positive value.");
-    }
-    try {
-      mockRestAdapter.setDelay(Long.MAX_VALUE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessageStartingWith("Delay value too large.");
-    }
-  }
-
-  @Test public void varianceRestrictsRange() {
-    try {
-      mockRestAdapter.setVariancePercentage(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-    try {
-      mockRestAdapter.setVariancePercentage(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
-    }
-  }
-
-  @Test public void errorRestrictsRange() {
-    try {
-      mockRestAdapter.setErrorPercentage(-13);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-    try {
-      mockRestAdapter.setErrorPercentage(174);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
-    }
-  }
-
-  @Test public void errorPercentageIsAccurate() {
-    mockRestAdapter.setErrorPercentage(0);
-    for (int i = 0; i < 10000; i++) {
-      assertThat(mockRestAdapter.calculateIsFailure()).isFalse();
-    }
-
-    mockRestAdapter.setErrorPercentage(3);
-    int failures = 0;
-    for (int i = 0; i < 100000; i++) {
-      if (mockRestAdapter.calculateIsFailure()) {
-        failures += 1;
-      }
-    }
-    assertThat(failures).isEqualTo(2964); // ~3% of 100k
-  }
-
-  @Test public void delayVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
-
-    mockRestAdapter.setVariancePercentage(0);
-    for (int i = 0; i < 100000; i++) {
-      assertThat(mockRestAdapter.calculateDelayForCall()).isEqualTo(2000);
-    }
-
-    mockRestAdapter.setVariancePercentage(40);
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForCall();
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
-    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
-  }
-
-  @Test public void errorVarianceIsAccurate() {
-    mockRestAdapter.setDelay(2000);
-
-    int lowerBound = Integer.MAX_VALUE;
-    int upperBound = Integer.MIN_VALUE;
-    for (int i = 0; i < 100000; i++) {
-      int delay = mockRestAdapter.calculateDelayForError();
-      if (delay > upperBound) {
-        upperBound = delay;
-      }
-      if (delay < lowerBound) {
-        lowerBound = delay;
-      }
-    }
-    assertThat(upperBound).isEqualTo(5999); // 3 * 2000
-    assertThat(lowerBound).isEqualTo(0);
-  }
-
-  @Test public void changeListenerOnlyInvokedWhenValueHasChanged() {
-    long delay = mockRestAdapter.getDelay();
-    int variance = mockRestAdapter.getVariancePercentage();
-    int error = mockRestAdapter.getErrorPercentage();
-
-    long newDelay = delay + 1;
-    mockRestAdapter.setDelay(newDelay);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, error);
-
-    int newError = error + 1;
-    mockRestAdapter.setErrorPercentage(newError);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, variance, newError);
-
-    int newVariance = variance + 1;
-    mockRestAdapter.setVariancePercentage(newVariance);
-    verify(valueChangeListener).onMockValuesChanged(newDelay, newVariance, newError);
-
-    // Now try setting the same values and ensure the listener was never called.
-    mockRestAdapter.setDelay(newDelay);
-    mockRestAdapter.setVariancePercentage(newVariance);
-    mockRestAdapter.setErrorPercentage(newError);
-    verifyNoMoreInteractions(valueChangeListener);
-  }
-
-  @Test public void syncFailureTriggersNetworkError() {
-    mockRestAdapter.setErrorPercentage(100);
-    mockRestAdapter.setDelay(1);
-
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        throw new AssertionError();
-      }
-    }
-
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
-
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-      assertThat(e.getCause()).hasMessage("Mock network error!");
-    }
-  }
-
-  @Test public void asyncFailureTriggersNetworkError() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setErrorPercentage(100);
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw new AssertionError();
-      }
-    }
-
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
-
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        errorRef.set(error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    RetrofitError error = errorRef.get();
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-    assertThat(error.getCause()).hasMessage("Mock network error!");
-  }
-
-  @Test public void syncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    final AtomicBoolean called = new AtomicBoolean();
-    final Object expected = new Object();
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        called.set(true);
-        return expected;
-      }
-    }
-
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
-
-    long startNanos = System.nanoTime();
-    Object actual = mockService.doStuff();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-
-    assertThat(called.get()).isTrue();
-    assertThat(actual).isEqualTo(expected);
-    assertThat(tookMs).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void asyncApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hi");
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        cb.success(expected, null);
-      }
-    }
-
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String result, Response response) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(result);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    assertThat(actual.get()).isNotNull().isSameAs(expected);
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void observableApiIsCalledWithDelay() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hello");
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        return Observable.just(expected);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Object> actual = new AtomicReference<Object>();
-    Action1<Object> onSuccess = new Action1<Object>() {
-      @Override public void call(Object o) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(o);
-      }
-    };
-    Action1<Throwable> onError = new Action1<Throwable>() {
-      @Override public void call(Throwable throwable) {
-        throw new AssertionError();
-      }
-    };
-
-    mockService.doStuff().subscribe(onSuccess, onError);
-
-    verify(httpExecutor, atLeastOnce()).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    assertThat(actual.get()).isNotNull().isSameAs(expected);
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-
-  @Test public void syncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hello");
-
-    class MockSyncExample implements SyncExample {
-      @Override public String doStuff() {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
-
-    long startNanos = System.nanoTime();
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (RetrofitError e) {
-      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-      assertThat(tookMs).isGreaterThanOrEqualTo(100);
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().code()).isEqualTo(404);
-      assertThat(e.getResponse().message()).isEqualTo("Not Found");
-      assertThat(e.getBody()).isSameAs(expected);
-      assertThat(e.getSuccessType()).isEqualTo(Object.class);
-    }
-  }
-
-  @Test public void asyncHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Greetings");
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set(error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verify(callbackExecutor).execute(any(Runnable.class));
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(404);
-    assertThat(error.getResponse().message()).isEqualTo("Not Found");
-    assertThat(error.getBody()).isSameAs(expected);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void observableHttpExceptionBecomesError() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    @SuppressWarnings("RedundantStringConstructorCall") // Allocated on-heap.
-    final String expected = new String("Hi");
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw new MockHttpException(404, "Not Found", expected);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).isInstanceOf(RetrofitError.class);
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set((RetrofitError) error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(404);
-    assertThat(error.getResponse().message()).isEqualTo("Not Found");
-    assertThat(error.getBody()).isSameAs(expected);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void nullBodyIsAllowedOnHttpException() throws Exception {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw MockHttpException.newBadRequest(null);
-      }
-    }
-
-    ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).isInstanceOf(RetrofitError.class);
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        errorRef.set((RetrofitError) error);
-      }
-    });
-
-    verify(httpExecutor).execute(any(Runnable.class));
-    verifyZeroInteractions(callbackExecutor);
-
-    RetrofitError error = errorRef.get();
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-    assertThat(error.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-    assertThat(error.getResponse().code()).isEqualTo(400);
-    assertThat(error.getResponse().message()).isEqualTo("Bad Request");
-    assertThat(error.getBody()).isNull();
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-
-  @Test public void syncErrorUsesErrorHandler() {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    class MockSyncExample implements SyncExample {
-      @Override public Object doStuff() {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    SyncExample mockService = mockRestAdapter.create(SyncExample.class, new MockSyncExample());
-    nextError = new IllegalArgumentException("Test");
-
-    try {
-      mockService.doStuff();
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Test");
-    }
-  }
-
-  @Test public void asyncErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    class MockAsyncExample implements AsyncExample {
-      @Override public void doStuff(Callback<String> cb) {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    AsyncExample mockService = mockRestAdapter.create(AsyncExample.class, new MockAsyncExample());
-    nextError = new IllegalArgumentException("Test");
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff(new Callback<String>() {
-      @Override public void success(String o, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        assertThat(error.getCause()).hasMessage("Test");
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void observableErrorUsesErrorHandler() throws InterruptedException {
-    mockRestAdapter.setDelay(100);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    class MockObservableExample implements ObservableExample {
-      @Override public Observable<String> doStuff() {
-        throw MockHttpException.newNotFound(new Object());
-      }
-    }
-
-    ObservableExample mockService =
-        mockRestAdapter.create(ObservableExample.class, new MockObservableExample());
-    nextError = new IllegalArgumentException("Test");
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    mockService.doStuff().subscribe(new Action1<Object>() {
-      @Override public void call(Object o) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable error) {
-        assertThat(error).hasMessage("Test");
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void asyncCanUseCallbackSubtype() {
-    mockRestAdapter.setDelay(1);
-    mockRestAdapter.setVariancePercentage(0);
-    mockRestAdapter.setErrorPercentage(0);
-
-    class MockAsyncCallbackSubtypeExample implements AsyncCallbackSubtypeExample {
-      @Override public void doStuff(Foo foo) {
-        foo.success("Hello!", null);
-      }
-    }
-
-    AsyncCallbackSubtypeExample mockService =
-        mockRestAdapter.create(AsyncCallbackSubtypeExample.class,
-            new MockAsyncCallbackSubtypeExample());
-
-    final AtomicReference<String> actual = new AtomicReference<String>();
-    mockService.doStuff(new AsyncCallbackSubtypeExample.Foo() {
-      @Override public void success(String result, Response response) {
-        actual.set(result);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-
-    assertThat(actual.get()).isNotNull().isEqualTo("Hello!");
-  }
-}
diff --git a/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
new file mode 100644
index 000000000..55e4549bb
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/MockRetrofitTest.java
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
+
+import static java.util.concurrent.Executors.newSingleThreadExecutor;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class MockRetrofitTest {
+  interface DoWorkService {
+    Call<String> response();
+    Call<String> failure();
+  }
+
+  private final IOException mockFailure = new IOException("Timeout!");
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+  private DoWorkService service;
+
+  @Before public void setUp() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+
+    DoWorkService mockService = new DoWorkService() {
+      @Override public Call<String> response() {
+        return Calls.response("Response!");
+      }
+
+      @Override public Call<String> failure() {
+        return Calls.failure(mockFailure);
+      }
+    };
+
+    NetworkBehavior.Adapter<?> adapter =
+        new CallBehaviorAdapter(retrofit, newSingleThreadExecutor());
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, adapter);
+    service = mockRetrofit.create(DoWorkService.class, mockService);
+  }
+
+  @Test public void syncFailureThrowsAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(e).isSameAs(behavior.failureException());
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+    }
+  }
+
+  @Test public void asyncFailureTriggersFailureAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(100);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(failureRef.get()).isSameAs(behavior.failureException());
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncSuccessReturnsAfterDelay() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    long startNanos = System.nanoTime();
+    Response<String> response = call.execute();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+
+    assertThat(response.body()).isEqualTo("Response!");
+    assertThat(tookMs).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void asyncSuccessCalledAfterDelay() throws InterruptedException, IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.response();
+
+    final long startNanos = System.nanoTime();
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<String> actual = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        actual.set(response.body());
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        throw new AssertionError();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(actual.get()).isEqualTo("Response!");
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+  }
+
+  @Test public void syncFailureThrownAfterDelay() {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    long startNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+      assertThat(tookMs).isGreaterThanOrEqualTo(100);
+      assertThat(e).isSameAs(mockFailure);
+    }
+  }
+
+  @Test public void asyncFailureCalledAfterDelay() throws InterruptedException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    Call<String> call = service.failure();
+
+    final AtomicLong tookMs = new AtomicLong();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    final long startNanos = System.nanoTime();
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(1, SECONDS));
+
+    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
+    assertThat(failureRef.get()).isSameAs(mockFailure);
+  }
+
+  @Test public void syncCanBeCanceled() throws IOException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    new Thread(new Runnable() {
+      @Override public void run() {
+        try {
+          Thread.sleep(100);
+          call.cancel();
+        } catch (InterruptedException ignored) {
+        }
+      }
+    }).start();
+
+    try {
+      call.execute();
+      fail();
+    } catch (InterruptedIOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceled() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    // TODO we shouldn't need to sleep
+    Thread.sleep(100); // Ensure the task has started.
+    call.cancel();
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  }
+
+  @Test public void syncCanceledBeforeStart() throws IOException {
+    behavior.setDelay(100, MILLISECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (InterruptedIOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void asyncCanBeCanceledBeforeStart() throws InterruptedException {
+    behavior.setDelay(10, SECONDS);
+    behavior.setVariancePercent(0);
+    behavior.setFailurePercent(0);
+
+    final Call<String> call = service.response();
+    call.cancel();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    assertTrue(latch.await(1, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(InterruptedIOException.class).hasMessage("canceled");
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
new file mode 100644
index 000000000..916e8cf5c
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit/NetworkBehaviorTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.util.Random;
+import org.junit.Test;
+import retrofit.mock.NetworkBehavior;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class NetworkBehaviorTest {
+  private final NetworkBehavior behavior = NetworkBehavior.create(new Random(2847));
+
+  @Test public void delayMustBePositive() {
+    try {
+      behavior.setDelay(-1, SECONDS);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Amount must be positive value.");
+    }
+  }
+
+  @Test public void varianceRestrictsRange() {
+    try {
+      behavior.setVariancePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setVariancePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Variance percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failureRestrictsRange() {
+    try {
+      behavior.setFailurePercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setFailurePercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Failure percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void failurePercentageIsAccurate() {
+    behavior.setFailurePercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsFailure()).isFalse();
+    }
+
+    behavior.setFailurePercent(3);
+    int failures = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsFailure()) {
+        failures += 1;
+      }
+    }
+    assertThat(failures).isEqualTo(2964); // ~3% of 100k
+  }
+
+  @Test public void delayVarianceIsAccurate() {
+    behavior.setDelay(2, SECONDS);
+
+    behavior.setVariancePercent(0);
+    for (int i = 0; i < 100000; i++) {
+      assertThat(behavior.calculateDelay(MILLISECONDS)).isEqualTo(2000);
+    }
+
+    behavior.setVariancePercent(40);
+    long lowerBound = Integer.MAX_VALUE;
+    long upperBound = Integer.MIN_VALUE;
+    for (int i = 0; i < 100000; i++) {
+      long delay = behavior.calculateDelay(MILLISECONDS);
+      if (delay > upperBound) {
+        upperBound = delay;
+      }
+      if (delay < lowerBound) {
+        lowerBound = delay;
+      }
+    }
+    assertThat(upperBound).isEqualTo(2799); // ~40% above 2000
+    assertThat(lowerBound).isEqualTo(1200); // ~40% below 2000
+  }
+}
diff --git a/retrofit/pom.xml b/retrofit/pom.xml
index 6871fcc9e..a6d9f5496 100644
--- a/retrofit/pom.xml
+++ b/retrofit/pom.xml
@@ -15,8 +15,8 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
     </dependency>
 
     <dependency>
@@ -24,13 +24,10 @@
       <artifactId>android</artifactId>
       <optional>true</optional>
     </dependency>
+
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.reactivex</groupId>
-      <artifactId>rxjava</artifactId>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
       <optional>true</optional>
     </dependency>
 
@@ -60,17 +57,4 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <!-- The AppEngine dependency has an annotation processor we don't want to run. -->
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
 </project>
diff --git a/retrofit/src/main/java/retrofit/BaseUrl.java b/retrofit/src/main/java/retrofit/BaseUrl.java
new file mode 100644
index 000000000..7052f5083
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/BaseUrl.java
@@ -0,0 +1,14 @@
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+
+/** The base URL of the remote service. */
+public interface BaseUrl {
+  /**
+   * The base URL.
+   * <p>
+   * Consumers will call this method every time they need to create a request allowing values
+   * to change over time.
+   */
+  HttpUrl url();
+}
diff --git a/retrofit/src/main/java/retrofit/BuiltInConverterFactory.java b/retrofit/src/main/java/retrofit/BuiltInConverterFactory.java
new file mode 100644
index 000000000..66ba26488
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/BuiltInConverterFactory.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import retrofit.http.Streaming;
+
+final class BuiltInConverterFactory extends Converter.Factory {
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (ResponseBody.class.equals(type)) {
+      boolean isStreaming = Utils.isAnnotationPresent(annotations, Streaming.class);
+      return new OkHttpResponseBodyConverter(isStreaming);
+    }
+    if (Void.class.equals(type)) {
+      return new VoidConverter();
+    }
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (type instanceof Class && RequestBody.class.isAssignableFrom((Class<?>) type)) {
+      return new OkHttpRequestBodyConverter();
+    }
+    return null;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
new file mode 100644
index 000000000..9e96e45c5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+
+/**
+ * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
+ * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
+ * calls with the same parameters to the same webserver; this may be used to implement polling or
+ * to retry a failed call.
+ *
+ * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
+ * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
+ * is busy writing its request or reading its response may receive a {@link IOException}; this is
+ * working as designed.
+ */
+public interface Call<T> extends Cloneable {
+  Response<T> execute() throws IOException;
+  void enqueue(Callback<T> callback);
+  void cancel();
+  Call<T> clone();
+}
diff --git a/retrofit/src/main/java/retrofit/CallAdapter.java b/retrofit/src/main/java/retrofit/CallAdapter.java
new file mode 100644
index 000000000..4fd172a6b
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/CallAdapter.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/** Adapts a {@link Call} into the type of {@code T}. */
+public interface CallAdapter<T> {
+  /**
+   * Returns the value type that this adapter uses when converting the HTTP response body to a Java
+   * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
+   * is used to prepare the {@code call} passed to {@code #adapt}.
+   *
+   * <p>Note that this is typically not the same type as the {@code returnType} provided to
+   * this call adapter's factory.
+   */
+  Type responseType();
+
+  /** Returns an instance of the {@code T} which adapts the execution of {@code call}. */
+  <R> T adapt(Call<R> call);
+
+  interface Factory {
+    /**
+     * Returns a call adapter for interface methods that return {@code returnType}, or null if this
+     * factory doesn't adapt that type.
+     */
+    CallAdapter<?> get(Type returnType, Annotation[] annotations);
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Callback.java b/retrofit/src/main/java/retrofit/Callback.java
index 65f1bc5ed..6841a2dd3 100644
--- a/retrofit/src/main/java/retrofit/Callback.java
+++ b/retrofit/src/main/java/retrofit/Callback.java
@@ -15,13 +15,11 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.Response;
-
 /**
  * Communicates responses from a server or offline requests. One and only one method will be
  * invoked in response to a given request.
  * <p>
- * Callback methods are executed using the {@link RestAdapter} callback executor. When none is
+ * Callback methods are executed using the {@link Retrofit} callback executor. When none is
  * specified, the following defaults are used:
  * <ul>
  * <li>Android: Callbacks are executed on the application's main (UI) thread.</li>
@@ -29,16 +27,11 @@
  * </ul>
  *
  * @param <T> expected response type
- * @see RestAdapter.Builder#setCallbackExecutor
  */
 public interface Callback<T> {
-
   /** Successful HTTP response. */
-  void success(T t, Response response);
+  void onResponse(Response<T> response);
 
-  /**
-   * Unsuccessful HTTP response due to network failure, non-2XX status code, or unexpected
-   * exception.
-   */
-  void failure(RetrofitError error);
+  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
+  void onFailure(Throwable t);
 }
diff --git a/retrofit/src/main/java/retrofit/Converter.java b/retrofit/src/main/java/retrofit/Converter.java
new file mode 100644
index 000000000..1525d8878
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Converter.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * Convert objects to and from their representation as HTTP bodies. Register a converter with
+ * Retrofit using {@link Retrofit.Builder#addConverter(Type, Converter)} or {@link
+ * Retrofit.Builder#addConverterFactory(Factory)}.
+ */
+public interface Converter<F, T> {
+  T convert(F value) throws IOException;
+
+  abstract class Factory {
+    /**
+     * Create a {@link Converter} for converting an HTTP response body to {@code type} or null if it
+     * cannot be handled by this factory.
+     */
+    public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+      return null;
+    }
+
+    /**
+     * Create a {@link Converter} for converting {@code type} to an HTTP request body or null if it
+     * cannot be handled by this factory.
+     */
+    public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+      return null;
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapter.java b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
new file mode 100644
index 000000000..220169a48
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapter.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+/**
+ * A call adapter that uses the same thread for both I/O and application-level callbacks. For
+ * synchronous calls this is the application thread making the request; for asynchronous calls this
+ * is a thread provided by OkHttp's dispatcher.
+ */
+final class DefaultCallAdapter implements CallAdapter<Call<?>> {
+  public static final Factory FACTORY = new Factory() {
+    @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+      if (Utils.getRawType(returnType) != Call.class) {
+        return null;
+      }
+      Type responseType = Utils.getCallResponseType(returnType);
+      return new DefaultCallAdapter(responseType);
+    }
+  };
+
+  private final Type responseType;
+
+  DefaultCallAdapter(Type responseType) {
+    this.responseType = responseType;
+  }
+
+  @Override public Type responseType() {
+    return responseType;
+  }
+
+  @Override public <R> Call<R> adapt(Call<R> call) {
+    return call;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Endpoint.java b/retrofit/src/main/java/retrofit/Endpoint.java
deleted file mode 100644
index 771013c22..000000000
--- a/retrofit/src/main/java/retrofit/Endpoint.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package retrofit;
-
-import static retrofit.Utils.checkNotNull;
-
-/** An API endpoint. */
-public abstract class Endpoint {
-  /** Create an endpoint with the provided {@code url}. */
-  public static Endpoint createFixed(final String url) {
-    checkNotNull(url, "url == null");
-    return new Endpoint() {
-      @Override public String url() {
-        return url;
-      }
-    };
-  }
-
-  /**
-   * The base URL.
-   * <p>
-   * Consumers will call this method every time they need to create a request allowing values
-   * to change over time.
-   */
-  public abstract String url();
-}
diff --git a/retrofit/src/main/java/retrofit/ErrorHandler.java b/retrofit/src/main/java/retrofit/ErrorHandler.java
deleted file mode 100644
index 83c05a36d..000000000
--- a/retrofit/src/main/java/retrofit/ErrorHandler.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-/**
- * A hook allowing clients to customize {@link RetrofitError RetrofitError}.
- *
- * @author Sam Beran sberan@gmail.com
- */
-public interface ErrorHandler {
-  /**
-   * Return a custom exception to be thrown for a {@link RetrofitError}. It is recommended that you
-   * pass the supplied error as the cause to any new exceptions.
-   * <p>
-   * If the return exception is checked it must be declared to be thrown on the interface method.
-   * <p>
-   * Example usage:
-   * <pre>
-   * class MyErrorHandler implements ErrorHandler {
-   *   &#64;Override public Throwable handleError(RetrofitError cause) {
-   *     Response r = cause.getResponse();
-   *     if (r != null &amp;&amp; r.getStatus() == 401) {
-   *       return new UnauthorizedException(cause);
-   *     }
-   *     return cause;
-   *   }
-   * }
-   * </pre>
-   *
-   * @param cause the original {@link RetrofitError} exception
-   * @return Throwable an exception which will be thrown from a synchronous interface method or
-   *         passed to an asynchronous error callback. Must not be {@code null}.
-   */
-  Throwable handleError(RetrofitError cause);
-
-  /** An {@link ErrorHandler} which returns the original error. */
-  ErrorHandler DEFAULT = new ErrorHandler() {
-    @Override public Throwable handleError(RetrofitError cause) {
-      return cause;
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
index db7c14d63..52d0e819c 100644
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -8,7 +8,7 @@
 import okio.ForwardingSource;
 import okio.Okio;
 
-class ExceptionCatchingRequestBody extends ResponseBody {
+final class ExceptionCatchingRequestBody extends ResponseBody {
   private final ResponseBody delegate;
   private IOException thrownException;
 
@@ -20,12 +20,24 @@
     return delegate.contentType();
   }
 
-  @Override public long contentLength() {
-    return delegate.contentLength();
+  @Override public long contentLength() throws IOException {
+    try {
+      return delegate.contentLength();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
   }
 
-  @Override public BufferedSource source() {
-    return Okio.buffer(new ForwardingSource(delegate.source()) {
+  @Override public BufferedSource source() throws IOException {
+    BufferedSource delegateSource;
+    try {
+      delegateSource = delegate.source();
+    } catch (IOException e) {
+      thrownException = e;
+      throw e;
+    }
+    return Okio.buffer(new ForwardingSource(delegateSource) {
       @Override public long read(Buffer sink, long byteCount) throws IOException {
         try {
           return super.read(sink, byteCount);
@@ -37,11 +49,13 @@
     });
   }
 
-  IOException getThrownException() {
-    return thrownException;
+  @Override public void close() throws IOException {
+    delegate.close();
   }
 
-  boolean threwException() {
-    return thrownException != null;
+  void throwIfCaught() throws IOException {
+    if (thrownException != null) {
+      throw thrownException;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
new file mode 100644
index 000000000..655f60e25
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.concurrent.Executor;
+
+final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
+  private final Executor callbackExecutor;
+
+  ExecutorCallAdapterFactory(Executor callbackExecutor) {
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  @Override public CallAdapter<Call<?>> get(Type returnType, Annotation[] annotations) {
+    if (Utils.getRawType(returnType) != Call.class) {
+      return null;
+    }
+    final Type responseType = Utils.getCallResponseType(returnType);
+    return new CallAdapter<Call<?>>() {
+      @Override public Type responseType() {
+        return responseType;
+      }
+
+      @Override public <R> Call<R> adapt(Call<R> call) {
+        return new ExecutorCallbackCall<>(callbackExecutor, call);
+      }
+    };
+  }
+
+  static final class ExecutorCallbackCall<T> implements Call<T> {
+    private final Executor callbackExecutor;
+    private final Call<T> delegate;
+
+    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void enqueue(Callback<T> callback) {
+      delegate.enqueue(new ExecutorCallback<>(callbackExecutor, callback));
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      return delegate.execute();
+    }
+
+    @Override public void cancel() {
+      delegate.cancel();
+    }
+
+    @SuppressWarnings("CloneDoesntCallSuperClone") // Performing deep clone.
+    @Override public Call<T> clone() {
+      return new ExecutorCallbackCall<>(callbackExecutor, delegate.clone());
+    }
+  }
+
+  static final class ExecutorCallback<T> implements Callback<T> {
+    private final Executor callbackExecutor;
+    private final Callback<T> delegate;
+
+    ExecutorCallback(Executor callbackExecutor, Callback<T> delegate) {
+      this.callbackExecutor = callbackExecutor;
+      this.delegate = delegate;
+    }
+
+    @Override public void onResponse(final Response<T> response) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.onResponse(response);
+        }
+      });
+    }
+
+    @Override public void onFailure(final Throwable t) {
+      callbackExecutor.execute(new Runnable() {
+        @Override public void run() {
+          delegate.onFailure(t);
+        }
+      });
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
new file mode 100644
index 000000000..2312996f6
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/MethodHandler.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
+
+final class MethodHandler<T> {
+  @SuppressWarnings("unchecked")
+  static MethodHandler<?> create(Method method, OkHttpClient client, BaseUrl baseUrl,
+      List<CallAdapter.Factory> callAdapterFactories, List<Converter.Factory> converterFactories) {
+    CallAdapter<Object> callAdapter =
+        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactories);
+    Converter<ResponseBody, Object> responseConverter =
+        (Converter<ResponseBody, Object>) createResponseConverter(method,
+            callAdapter.responseType(), converterFactories);
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactories);
+    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
+  }
+
+  private static CallAdapter<?> createCallAdapter(Method method,
+      List<CallAdapter.Factory> adapterFactories) {
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw Utils.methodError(method,
+          "Method return type must not include a type variable or wildcard: %s", returnType);
+    }
+    if (returnType == void.class) {
+      throw Utils.methodError(method, "Service methods cannot return void.");
+    }
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return Utils.resolveCallAdapter(adapterFactories, returnType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
+    }
+  }
+
+  private static Converter<ResponseBody, ?> createResponseConverter(Method method,
+      Type responseType, List<Converter.Factory> converterFactories) {
+    Annotation[] annotations = method.getAnnotations();
+    try {
+      return Utils.resolveResponseBodyConverter(converterFactories, responseType, annotations);
+    } catch (RuntimeException e) { // Wide exception range because factories are user code.
+      throw Utils.methodError(e, method, "Unable to create converter for %s", responseType);
+    }
+  }
+
+  private final OkHttpClient client;
+  private final RequestFactory requestFactory;
+  private final CallAdapter<T> callAdapter;
+  private final Converter<ResponseBody, T> responseConverter;
+
+  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
+      CallAdapter<T> callAdapter, Converter<ResponseBody, T> responseConverter) {
+    this.client = client;
+    this.requestFactory = requestFactory;
+    this.callAdapter = callAdapter;
+    this.responseConverter = responseConverter;
+  }
+
+  Object invoke(Object... args) {
+    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
deleted file mode 100644
index 40c0bd59a..000000000
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ /dev/null
@@ -1,439 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.WildcardType;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import retrofit.http.Body;
-import retrofit.http.DELETE;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.FormUrlEncoded;
-import retrofit.http.GET;
-import retrofit.http.HEAD;
-import retrofit.http.Header;
-import retrofit.http.Headers;
-import retrofit.http.Multipart;
-import retrofit.http.PATCH;
-import retrofit.http.POST;
-import retrofit.http.PUT;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
-import retrofit.http.HTTP;
-import retrofit.http.Streaming;
-import rx.Observable;
-
-/** Request metadata about a service interface declaration. */
-final class MethodInfo {
-  enum ExecutionType {
-    ASYNC,
-    RX,
-    SYNC
-  }
-
-  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
-  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
-  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
-  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
-
-  enum RequestType {
-    /** No content-specific logic required. */
-    SIMPLE,
-    /** Multi-part request body. */
-    MULTIPART,
-    /** Form URL-encoded request body. */
-    FORM_URL_ENCODED
-  }
-
-  final Method method;
-
-  // Method-level details
-  final ExecutionType executionType;
-  Type responseObjectType;
-  Type requestObjectType;
-  RequestType requestType = RequestType.SIMPLE;
-  String requestMethod;
-  boolean requestHasBody;
-  String requestUrl;
-  Set<String> requestUrlParamNames;
-  String requestQuery;
-  com.squareup.okhttp.Headers headers;
-  String contentTypeHeader;
-  boolean isStreaming;
-
-  // Parameter-level details
-  Annotation[] requestParamAnnotations;
-
-  MethodInfo(Method method) {
-    this.method = method;
-    executionType = parseResponseType();
-
-    parseMethodAnnotations();
-    parseParameters();
-  }
-
-  private RuntimeException methodError(String message, Object... args) {
-    if (args.length > 0) {
-      message = String.format(message, args);
-    }
-    return new IllegalArgumentException(
-        method.getDeclaringClass().getSimpleName() + "." + method.getName() + ": " + message);
-  }
-
-  private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(message + " (parameter #" + (index + 1) + ")", args);
-  }
-
-  /** Loads {@link #requestMethod} and {@link #requestType}. */
-  private void parseMethodAnnotations() {
-    for (Annotation methodAnnotation : method.getAnnotations()) {
-      Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
-      if (annotationType == DELETE.class) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) methodAnnotation).value(), false);
-      } else if (annotationType == GET.class) {
-        parseHttpMethodAndPath("GET", ((GET) methodAnnotation).value(), false);
-      } else if (annotationType == HEAD.class) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) methodAnnotation).value(), false);
-      } else if (annotationType == PATCH.class) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) methodAnnotation).value(), true);
-      } else if (annotationType == POST.class) {
-        parseHttpMethodAndPath("POST", ((POST) methodAnnotation).value(), true);
-      } else if (annotationType == PUT.class) {
-        parseHttpMethodAndPath("PUT", ((PUT) methodAnnotation).value(), true);
-      } else if (annotationType == HTTP.class) {
-        HTTP http = (HTTP) methodAnnotation;
-        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotationType == Headers.class) {
-        String[] headersToParse = ((Headers) methodAnnotation).value();
-        if (headersToParse.length == 0) {
-          throw methodError("@Headers annotation is empty.");
-        }
-        headers = parseHeaders(headersToParse);
-      } else if (annotationType == Multipart.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        throw new UnsupportedOperationException("Multipart shall return!");
-        //requestType = RequestType.MULTIPART;
-      } else if (annotationType == FormUrlEncoded.class) {
-        if (requestType != RequestType.SIMPLE) {
-          throw methodError("Only one encoding annotation is allowed.");
-        }
-        throw new UnsupportedOperationException("Form URL encoding shall return!");
-        //requestType = RequestType.FORM_URL_ENCODED;
-      } else if (annotationType == Streaming.class) {
-        if (responseObjectType != Response.class) {
-          throw methodError(
-              "Only methods having %s as data type are allowed to have @%s annotation.",
-              Response.class.getSimpleName(), Streaming.class.getSimpleName());
-        }
-        isStreaming = true;
-      }
-    }
-
-    if (requestMethod == null) {
-      throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
-    }
-    if (!requestHasBody) {
-      if (requestType == RequestType.MULTIPART) {
-        throw methodError(
-            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-      }
-      if (requestType == RequestType.FORM_URL_ENCODED) {
-        throw methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
-                + "(e.g., @POST).");
-      }
-    }
-  }
-
-  /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
-  private void parseHttpMethodAndPath(String method, String path, boolean hasBody) {
-    if (requestMethod != null) {
-      throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
-          method);
-    }
-    if (path == null || path.length() == 0 || path.charAt(0) != '/') {
-      throw methodError("URL path \"%s\" must start with '/'.", path);
-    }
-
-    // Get the relative URL path and existing query string, if present.
-    String url = path;
-    String query = null;
-    int question = path.indexOf('?');
-    if (question != -1 && question < path.length() - 1) {
-      url = path.substring(0, question);
-      query = path.substring(question + 1);
-
-      // Ensure the query string does not have any named parameters.
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
-      if (queryParamMatcher.find()) {
-        throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
-            + " parameters use @Query.", query);
-      }
-    }
-
-    Set<String> urlParams = parsePathParameters(path);
-
-    requestMethod = method;
-    requestHasBody = hasBody;
-    requestUrl = url;
-    requestUrlParamNames = urlParams;
-    requestQuery = query;
-  }
-
-  com.squareup.okhttp.Headers parseHeaders(String[] headers) {
-    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
-    for (String header : headers) {
-      int colon = header.indexOf(':');
-      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
-            header);
-      }
-      String headerName = header.substring(0, colon);
-      String headerValue = header.substring(colon + 1).trim();
-      if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentTypeHeader = headerValue;
-      } else {
-        builder.add(headerName, headerValue);
-      }
-    }
-    return builder.build();
-  }
-
-  /** Loads {@link #responseObjectType}. */
-  private ExecutionType parseResponseType() {
-    // Synchronous methods have a non-void return type.
-    // Observable methods have a return type of Observable.
-    Type returnType = method.getGenericReturnType();
-
-    // Asynchronous methods should have a Callback type as the last argument.
-    Type lastArgType = null;
-    Class<?> lastArgClass = null;
-    Type[] parameterTypes = method.getGenericParameterTypes();
-    if (parameterTypes.length > 0) {
-      Type typeToCheck = parameterTypes[parameterTypes.length - 1];
-      lastArgType = typeToCheck;
-      if (typeToCheck instanceof ParameterizedType) {
-        typeToCheck = ((ParameterizedType) typeToCheck).getRawType();
-      }
-      if (typeToCheck instanceof Class) {
-        lastArgClass = (Class<?>) typeToCheck;
-      }
-    }
-
-    boolean hasReturnType = returnType != void.class;
-    boolean hasCallback = lastArgClass != null && Callback.class.isAssignableFrom(lastArgClass);
-
-    // Check for invalid configurations.
-    if (hasReturnType && hasCallback) {
-      throw methodError("Must have return type or Callback as last argument, not both.");
-    }
-    if (!hasReturnType && !hasCallback) {
-      throw methodError("Must have either a return type or Callback as last argument.");
-    }
-
-    if (hasReturnType) {
-      if (Platform.HAS_RX_JAVA) {
-        Class rawReturnType = Types.getRawType(returnType);
-        if (RxSupport.isObservable(rawReturnType)) {
-          returnType = RxSupport.getObservableType(returnType, rawReturnType);
-          responseObjectType = getParameterUpperBound((ParameterizedType) returnType);
-          return ExecutionType.RX;
-        }
-      }
-      responseObjectType = returnType;
-      return ExecutionType.SYNC;
-    }
-
-    lastArgType = Types.getSupertype(lastArgType, Types.getRawType(lastArgType), Callback.class);
-    if (lastArgType instanceof ParameterizedType) {
-      responseObjectType = getParameterUpperBound((ParameterizedType) lastArgType);
-      return ExecutionType.ASYNC;
-    }
-
-    throw methodError("Last parameter must be of type Callback<X> or Callback<? super X>.");
-  }
-
-  private static Type getParameterUpperBound(ParameterizedType type) {
-    Type[] types = type.getActualTypeArguments();
-    for (int i = 0; i < types.length; i++) {
-      Type paramType = types[i];
-      if (paramType instanceof WildcardType) {
-        types[i] = ((WildcardType) paramType).getUpperBounds()[0];
-      }
-    }
-    return types[0];
-  }
-
-  /**
-   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
-   */
-  private void parseParameters() {
-    Type[] methodParameterTypes = method.getGenericParameterTypes();
-
-    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-    int count = methodParameterAnnotationArrays.length;
-    if (executionType == ExecutionType.ASYNC) {
-      count -= 1; // Callback is last argument when not a synchronous method.
-    }
-
-    Annotation[] requestParamAnnotations = new Annotation[count];
-
-    boolean gotField = false;
-    boolean gotPart = false;
-    boolean gotBody = false;
-
-    for (int i = 0; i < count; i++) {
-      Type methodParameterType = methodParameterTypes[i];
-      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
-      if (methodParameterAnnotations != null) {
-        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          Class<? extends Annotation> methodAnnotationType =
-              methodParameterAnnotation.annotationType();
-
-          if (methodAnnotationType == Path.class) {
-            String name = ((Path) methodParameterAnnotation).value();
-            validatePathName(i, name);
-          } else if (methodAnnotationType == Query.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == QueryMap.class) {
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@QueryMap parameter type must be Map.");
-            }
-          } else if (methodAnnotationType == Header.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == Field.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@Field parameters can only be used with form encoding.");
-            }
-
-            gotField = true;
-          } else if (methodAnnotationType == FieldMap.class) {
-            if (requestType != RequestType.FORM_URL_ENCODED) {
-              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@FieldMap parameter type must be Map.");
-            }
-
-            gotField = true;
-          } else if (methodAnnotationType == Part.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
-            }
-
-            gotPart = true;
-          } else if (methodAnnotationType == PartMap.class) {
-            if (requestType != RequestType.MULTIPART) {
-              throw parameterError(i,
-                  "@PartMap parameters can only be used with multipart encoding.");
-            }
-            if (!Map.class.isAssignableFrom(Types.getRawType(methodParameterType))) {
-              throw parameterError(i, "@PartMap parameter type must be Map.");
-            }
-
-            gotPart = true;
-          } else if (methodAnnotationType == Body.class) {
-            if (requestType != RequestType.SIMPLE) {
-              throw parameterError(i,
-                  "@Body parameters cannot be used with form or multi-part encoding.");
-            }
-            if (gotBody) {
-              throw methodError("Multiple @Body method annotations found.");
-            }
-
-            requestObjectType = methodParameterType;
-            gotBody = true;
-          } else {
-            // This is a non-Retrofit annotation. Skip to the next one.
-            continue;
-          }
-
-          if (requestParamAnnotations[i] != null) {
-            throw parameterError(i,
-                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
-                requestParamAnnotations[i].annotationType().getSimpleName(),
-                methodAnnotationType.getSimpleName());
-          }
-          requestParamAnnotations[i] = methodParameterAnnotation;
-        }
-      }
-
-      if (requestParamAnnotations[i] == null) {
-        throw parameterError(i, "No Retrofit annotation found.");
-      }
-    }
-
-    if (requestType == RequestType.SIMPLE && !requestHasBody && gotBody) {
-      throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
-    }
-    if (requestType == RequestType.FORM_URL_ENCODED && !gotField) {
-      throw methodError("Form-encoded method must contain at least one @Field.");
-    }
-    if (requestType == RequestType.MULTIPART && !gotPart) {
-      throw methodError("Multipart method must contain at least one @Part.");
-    }
-
-    this.requestParamAnnotations = requestParamAnnotations;
-  }
-
-  private void validatePathName(int index, String name) {
-    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
-      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
-          PARAM_URL_REGEX.pattern(), name);
-    }
-    // Verify URL replacement name is actually present in the URL path.
-    if (!requestUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", requestUrl, name);
-    }
-  }
-
-  /**
-   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
-   * in the URI, it will only show up once in the set.
-   */
-  static Set<String> parsePathParameters(String path) {
-    Matcher m = PARAM_URL_REGEX.matcher(path);
-    Set<String> patterns = new LinkedHashSet<String>();
-    while (m.find()) {
-      patterns.add(m.group(1));
-    }
-    return patterns;
-  }
-
-  /** Indirection to avoid log complaints if RxJava isn't present. */
-  private static final class RxSupport {
-    public static boolean isObservable(Class rawType) {
-      return rawType == Observable.class;
-    }
-
-    public static Type getObservableType(Type contextType, Class contextRawType) {
-      return Types.getSupertype(contextType, contextRawType, Observable.class);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/NoContentResponseBody.java b/retrofit/src/main/java/retrofit/NoContentResponseBody.java
new file mode 100644
index 000000000..098087653
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/NoContentResponseBody.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.BufferedSource;
+
+final class NoContentResponseBody extends ResponseBody {
+  private final MediaType contentType;
+  private final long contentLength;
+
+  NoContentResponseBody(MediaType contentType, long contentLength) {
+    this.contentType = contentType;
+    this.contentLength = contentLength;
+  }
+
+  @Override public MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public long contentLength() throws IOException {
+    return contentLength;
+  }
+
+  @Override public BufferedSource source() throws IOException {
+    throw new IllegalStateException("Cannot read raw response body of a converted body.");
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
new file mode 100644
index 000000000..db009e9d5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+import static retrofit.Utils.closeQuietly;
+
+final class OkHttpCall<T> implements Call<T> {
+  private final OkHttpClient client;
+  private final RequestFactory requestFactory;
+  private final Converter<ResponseBody, T> responseConverter;
+  private final Object[] args;
+
+  private volatile com.squareup.okhttp.Call rawCall;
+  private boolean executed; // Guarded by this.
+  private volatile boolean canceled;
+
+  OkHttpCall(OkHttpClient client, RequestFactory requestFactory,
+      Converter<ResponseBody, T> responseConverter, Object[] args) {
+    this.client = client;
+    this.requestFactory = requestFactory;
+    this.responseConverter = responseConverter;
+    this.args = args;
+  }
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  @Override public OkHttpCall<T> clone() {
+    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+  }
+
+  @Override public void enqueue(final Callback<T> callback) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    com.squareup.okhttp.Call rawCall;
+    try {
+      rawCall = createRawCall();
+    } catch (Throwable t) {
+      callback.onFailure(t);
+      return;
+    }
+    if (canceled) {
+      rawCall.cancel();
+    }
+    this.rawCall = rawCall;
+
+    rawCall.enqueue(new com.squareup.okhttp.Callback() {
+      private void callFailure(Throwable e) {
+        try {
+          callback.onFailure(e);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      private void callSuccess(Response<T> response) {
+        try {
+          callback.onResponse(response);
+        } catch (Throwable t) {
+          t.printStackTrace();
+        }
+      }
+
+      @Override public void onFailure(Request request, IOException e) {
+        callFailure(e);
+      }
+
+      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
+        Response<T> response;
+        try {
+          response = parseResponse(rawResponse);
+        } catch (Throwable e) {
+          callFailure(e);
+          return;
+        }
+        callSuccess(response);
+      }
+    });
+  }
+
+  public Response<T> execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already executed");
+      executed = true;
+    }
+
+    com.squareup.okhttp.Call rawCall = createRawCall();
+    if (canceled) {
+      rawCall.cancel();
+    }
+    this.rawCall = rawCall;
+
+    return parseResponse(rawCall.execute());
+  }
+
+  private com.squareup.okhttp.Call createRawCall() {
+    return client.newCall(requestFactory.create(args));
+  }
+
+  private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
+    ResponseBody rawBody = rawResponse.body();
+
+    // Remove the body's source (the only stateful object) so we can pass the response along.
+    rawResponse = rawResponse.newBuilder()
+        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
+        .build();
+
+    int code = rawResponse.code();
+    if (code < 200 || code >= 300) {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        return Response.error(bufferedBody, rawResponse);
+      } finally {
+        closeQuietly(rawBody);
+      }
+    }
+
+    if (code == 204 || code == 205) {
+      return Response.success(null, rawResponse);
+    }
+
+    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    try {
+      T body = responseConverter.convert(catchingBody);
+      return Response.success(body, rawResponse);
+    } catch (RuntimeException e) {
+      // If the underlying source threw an exception, propagate that rather than indicating it was
+      // a runtime exception.
+      catchingBody.throwIfCaught();
+      throw e;
+    }
+  }
+
+  public void cancel() {
+    canceled = true;
+    com.squareup.okhttp.Call rawCall = this.rawCall;
+    if (rawCall != null) {
+      rawCall.cancel();
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
new file mode 100644
index 000000000..b22ab20e2
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+
+final class OkHttpRequestBodyConverter implements Converter<RequestBody, RequestBody> {
+  @Override public RequestBody convert(RequestBody value) throws IOException {
+    return value;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
new file mode 100644
index 000000000..c324c4c8e
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+import static retrofit.Utils.closeQuietly;
+
+final class OkHttpResponseBodyConverter implements Converter<ResponseBody, ResponseBody> {
+  private final boolean isStreaming;
+
+  OkHttpResponseBodyConverter(boolean isStreaming) {
+    this.isStreaming = isStreaming;
+  }
+
+  @Override public ResponseBody convert(ResponseBody value) throws IOException {
+    if (isStreaming) {
+      return value;
+    }
+
+    // Buffer the entire body to avoid future I/O.
+    try {
+      return Utils.readBodyToBytesIfNecessary(value);
+    } finally {
+      closeQuietly(value);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/Platform.java b/retrofit/src/main/java/retrofit/Platform.java
index 928fd1ae8..b28337158 100644
--- a/retrofit/src/main/java/retrofit/Platform.java
+++ b/retrofit/src/main/java/retrofit/Platform.java
@@ -18,17 +18,14 @@
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
-import com.squareup.okhttp.OkHttpClient;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 class Platform {
   private static final Platform PLATFORM = findPlatform();
 
-  static final boolean HAS_RX_JAVA = hasRxJavaOnClasspath();
-
   static Platform get() {
     return PLATFORM;
   }
@@ -41,45 +38,60 @@ private static Platform findPlatform() {
       }
     } catch (ClassNotFoundException ignored) {
     }
-
+    try {
+      Class.forName("java.util.Optional");
+      return new Java8();
+    } catch (ClassNotFoundException ignored) {
+    }
     return new Platform();
   }
 
-  Converter defaultConverter() {
-    return new GsonConverter();
+  CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+    if (callbackExecutor != null) {
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+    return DefaultCallAdapter.FACTORY;
   }
 
-  Executor defaultCallbackExecutor() {
-    return new Utils.SynchronousExecutor();
+  boolean isDefaultMethod(Method method) {
+    return false;
   }
 
-  OkHttpClient defaultClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setConnectTimeout(15, TimeUnit.SECONDS);
-    client.setReadTimeout(15, TimeUnit.SECONDS);
-    client.setWriteTimeout(15, TimeUnit.SECONDS);
-    return client;
+  Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object, Object... args)
+      throws Throwable {
+    throw new UnsupportedOperationException();
   }
 
-  /** Provides sane defaults for operation on Android. */
-  private static class Android extends Platform {
-    @Override Executor defaultCallbackExecutor() {
-      return new Executor() {
-        private final Handler handler = new Handler(Looper.getMainLooper());
+  @IgnoreJRERequirement // Only classloaded and used on Java 8.
+  static class Java8 extends Platform {
+    @Override boolean isDefaultMethod(Method method) {
+      return method.isDefault();
+    }
 
-        @Override public void execute(Runnable r) {
-          handler.post(r);
-        }
-      };
+    @Override Object invokeDefaultMethod(Method method, Class<?> declaringClass, Object object,
+        Object... args) throws Throwable {
+      return MethodHandles.lookup()
+          .in(declaringClass)
+          .unreflectSpecial(method, declaringClass)
+          .bindTo(object)
+          .invokeWithArguments(args);
     }
   }
 
-  private static boolean hasRxJavaOnClasspath() {
-    try {
-      Class.forName("rx.Observable");
-      return true;
-    } catch (ClassNotFoundException ignored) {
+  static class Android extends Platform {
+    @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
+      if (callbackExecutor == null) {
+        callbackExecutor = new MainThreadExecutor();
+      }
+      return new ExecutorCallAdapterFactory(callbackExecutor);
+    }
+
+    static class MainThreadExecutor implements Executor {
+      private final Handler handler = new Handler(Looper.getMainLooper());
+
+      @Override public void execute(Runnable r) {
+        handler.post(r);
+      }
     }
-    return false;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index d87332bec..7828dab06 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -15,95 +15,74 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.FormEncodingBuilder;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
 import java.net.URLEncoder;
-import java.util.Map;
 import okio.BufferedSink;
-import retrofit.converter.Converter;
-import retrofit.http.Body;
-import retrofit.http.Header;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
 
-final class RequestBuilder implements RequestInterceptor.RequestFacade {
-  private static final Headers NO_HEADERS = Headers.of();
-
-  private final Converter converter;
-  private final Annotation[] paramAnnotations;
-  private final String requestMethod;
-  private final boolean async;
-  private final String apiUrl;
-
-  private RequestBody body;
+final class RequestBuilder {
+  private final String method;
 
+  private final HttpUrl baseUrl;
   private String relativeUrl;
-  private StringBuilder queryParams;
-  private Headers.Builder headers;
-  private String contentTypeHeader;
+  private HttpUrl.Builder urlBuilder;
 
-  RequestBuilder(String apiUrl, MethodInfo methodInfo, Converter converter) {
-    this.apiUrl = apiUrl;
-    this.converter = converter;
-
-    paramAnnotations = methodInfo.requestParamAnnotations;
-    requestMethod = methodInfo.requestMethod;
-    async = methodInfo.executionType == MethodInfo.ExecutionType.ASYNC;
-
-    if (methodInfo.headers != null) {
-      headers = methodInfo.headers.newBuilder();
-    }
-    contentTypeHeader = methodInfo.contentTypeHeader;
+  private final Request.Builder requestBuilder;
+  private MediaType contentType;
 
-    relativeUrl = methodInfo.requestUrl;
+  private final boolean hasBody;
+  private MultipartBuilder multipartBuilder;
+  private FormEncodingBuilder formEncodingBuilder;
+  private RequestBody body;
 
-    String requestQuery = methodInfo.requestQuery;
-    if (requestQuery != null) {
-      queryParams = new StringBuilder().append('?').append(requestQuery);
-    }
-  }
+  RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
+    this.method = method;
+    this.baseUrl = baseUrl;
+    this.relativeUrl = relativeUrl;
+    this.requestBuilder = new Request.Builder();
+    this.contentType = contentType;
+    this.hasBody = hasBody;
 
-  @Override public void addHeader(String name, String value) {
-    if (name == null) {
-      throw new IllegalArgumentException("Header name must not be null.");
-    }
-    if ("Content-Type".equalsIgnoreCase(name)) {
-      contentTypeHeader = value;
-      return;
+    if (headers != null) {
+      requestBuilder.headers(headers);
     }
 
-    Headers.Builder headers = this.headers;
-    if (headers == null) {
-      this.headers = headers = new Headers.Builder();
+    if (isFormEncoded) {
+      // Will be set to 'body' in 'build'.
+      formEncodingBuilder = new FormEncodingBuilder();
+    } else if (isMultipart) {
+      // Will be set to 'body' in 'build'.
+      multipartBuilder = new MultipartBuilder();
     }
-    headers.add(name, value);
   }
 
-  @Override public void addPathParam(String name, String value) {
-    addPathParam(name, value, true);
+  void setRelativeUrl(String relativeUrl) {
+    this.relativeUrl = relativeUrl;
   }
 
-  @Override public void addEncodedPathParam(String name, String value) {
-    addPathParam(name, value, false);
+  void addHeader(String name, String value) {
+    if ("Content-Type".equalsIgnoreCase(name)) {
+      contentType = MediaType.parse(value);
+    } else {
+      requestBuilder.addHeader(name, value);
+    }
   }
 
-  private void addPathParam(String name, String value, boolean urlEncodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Path replacement name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException(
-          "Path replacement \"" + name + "\" value must not be null.");
+  void addPathParam(String name, String value, boolean encoded) {
+    if (relativeUrl == null) {
+      // The relative URL is cleared when the first query parameter is set.
+      throw new AssertionError();
     }
     try {
-      if (urlEncodeValue) {
+      if (!encoded) {
         String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
         // URLEncoder encodes for use as a query parameter. Path encoding uses %20 to
         // encode spaces rather than +. Query encoding difference specified in HTML spec.
@@ -119,276 +98,85 @@ private void addPathParam(String name, String value, boolean urlEncodeValue) {
     }
   }
 
-  @Override public void addQueryParam(String name, String value) {
-    addQueryParam(name, value, false, true);
-  }
-
-  @Override public void addEncodedQueryParam(String name, String value) {
-    addQueryParam(name, value, false, false);
-  }
+  void addQueryParam(String name, String value, boolean encoded) {
+    if (relativeUrl != null) {
+      // Do a one-time combination of the built relative URL and the base URL.
+      urlBuilder = baseUrl.resolve(relativeUrl).newBuilder();
+      relativeUrl = null;
+    }
 
-  private void addQueryParam(String name, Object value, boolean encodeName, boolean encodeValue) {
-    if (value instanceof Iterable) {
-      for (Object iterableValue : (Iterable<?>) value) {
-        if (iterableValue != null) { // Skip null values
-          addQueryParam(name, iterableValue.toString(), encodeName, encodeValue);
-        }
-      }
-    } else if (value.getClass().isArray()) {
-      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-        Object arrayValue = Array.get(value, x);
-        if (arrayValue != null) { // Skip null values
-          addQueryParam(name, arrayValue.toString(), encodeName, encodeValue);
-        }
-      }
+    if (encoded) {
+      urlBuilder.addEncodedQueryParameter(name, value);
     } else {
-      addQueryParam(name, value.toString(), encodeName, encodeValue);
+      urlBuilder.addQueryParameter(name, value);
     }
   }
 
-  private void addQueryParam(String name, String value, boolean encodeName, boolean encodeValue) {
-    if (name == null) {
-      throw new IllegalArgumentException("Query param name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException("Query param \"" + name + "\" value must not be null.");
-    }
-    try {
-      StringBuilder queryParams = this.queryParams;
-      if (queryParams == null) {
-        this.queryParams = queryParams = new StringBuilder();
-      }
-
-      queryParams.append(queryParams.length() > 0 ? '&' : '?');
-
-      if (encodeName) {
-        name = URLEncoder.encode(name, "UTF-8");
-      }
-      if (encodeValue) {
-        value = URLEncoder.encode(value, "UTF-8");
-      }
-      queryParams.append(name).append('=').append(value);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(
-          "Unable to convert query parameter \"" + name + "\" value to UTF-8: " + value, e);
+  void addFormField(String name, String value, boolean encoded) {
+    if (encoded) {
+      formEncodingBuilder.addEncoded(name, value);
+    } else {
+      formEncodingBuilder.add(name, value);
     }
   }
 
-  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encodeNames,
-      boolean encodeValues) {
-    for (Map.Entry<?, ?> entry : map.entrySet()) {
-      Object entryKey = entry.getKey();
-      if (entryKey == null) {
-        throw new IllegalArgumentException(
-            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
-      }
-      Object entryValue = entry.getValue();
-      if (entryValue != null) { // Skip null values.
-        addQueryParam(entryKey.toString(), entryValue.toString(), encodeNames, encodeValues);
-      }
-    }
+  void addPart(Headers headers, RequestBody body) {
+    multipartBuilder.addPart(headers, body);
   }
 
-  void setArguments(Object[] args) {
-    if (args == null) {
-      return;
-    }
-    int count = args.length;
-    if (async) {
-      count -= 1;
-    }
-    for (int i = 0; i < count; i++) {
-      Object value = args[i];
-
-      Annotation annotation = paramAnnotations[i];
-      Class<? extends Annotation> annotationType = annotation.annotationType();
-      if (annotationType == Path.class) {
-        Path path = (Path) annotation;
-        String name = path.value();
-        if (value == null) {
-          throw new IllegalArgumentException(
-              "Path parameter \"" + name + "\" value must not be null.");
-        }
-        addPathParam(name, value.toString(), path.encode());
-      } else if (annotationType == Query.class) {
-        if (value != null) { // Skip null values.
-          Query query = (Query) annotation;
-          addQueryParam(query.value(), value, query.encodeName(), query.encodeValue());
-        }
-      } else if (annotationType == QueryMap.class) {
-        if (value != null) { // Skip null values.
-          QueryMap queryMap = (QueryMap) annotation;
-          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
-        }
-      } else if (annotationType == Header.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Header) annotation).value();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                addHeader(name, iterableValue.toString());
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                addHeader(name, arrayValue.toString());
-              }
-            }
-          } else {
-            addHeader(name, value.toString());
-          }
-        }
-      // TODO bring back form url encoding!
-      //} else if (annotationType == Field.class) {
-      //  if (value != null) { // Skip null values.
-      //    Field field = (Field) annotation;
-      //    String name = field.value();
-      //    boolean encodeName = field.encodeName();
-      //    boolean encodeValue = field.encodeValue();
-      //    if (value instanceof Iterable) {
-      //      for (Object iterableValue : (Iterable<?>) value) {
-      //        if (iterableValue != null) { // Skip null values.
-      //          formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
-      //        }
-      //      }
-      //    } else if (value.getClass().isArray()) {
-      //      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-      //        Object arrayValue = Array.get(value, x);
-      //        if (arrayValue != null) { // Skip null values.
-      //          formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
-      //        }
-      //      }
-      //    } else {
-      //      formBody.addField(name, encodeName, value.toString(), encodeValue);
-      //    }
-      //  }
-      //} else if (annotationType == FieldMap.class) {
-      //  if (value != null) { // Skip null values.
-      //    FieldMap fieldMap = (FieldMap) annotation;
-      //    boolean encodeNames = fieldMap.encodeNames();
-      //    boolean encodeValues = fieldMap.encodeValues();
-      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-      //      Object entryKey = entry.getKey();
-      //      if (entryKey == null) {
-      //        throw new IllegalArgumentException(
-      //            "Parameter #" + (i + 1) + " field map contained null key.");
-      //      }
-      //      Object entryValue = entry.getValue();
-      //      if (entryValue != null) { // Skip null values.
-      //        formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
-      //            encodeValues);
-      //      }
-      //    }
-      //  }
-      // TODO bring back multipart!
-      //} else if (annotationType == Part.class) {
-      //  if (value != null) { // Skip null values.
-      //    String name = ((Part) annotation).value();
-      //    String transferEncoding = ((Part) annotation).encoding();
-      //    if (value instanceof RequestBody) {
-      //      multipartBody.addPart((RequestBody) value);
-      //      multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-      //    } else if (value instanceof String) {
-      //      multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-      //    } else {
-      //      multipartBody.addPart(name, transferEncoding,
-      //          converter.toBody(value, value.getClass()));
-      //    }
-      //  }
-      //} else if (annotationType == PartMap.class) {
-      //  if (value != null) { // Skip null values.
-      //    String transferEncoding = ((PartMap) annotation).encoding();
-      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-      //      Object entryKey = entry.getKey();
-      //      if (entryKey == null) {
-      //        throw new IllegalArgumentException(
-      //            "Parameter #" + (i + 1) + " part map contained null key.");
-      //      }
-      //      String entryName = entryKey.toString();
-      //      Object entryValue = entry.getValue();
-      //      if (entryValue != null) { // Skip null values.
-      //        if (entryValue instanceof TypedOutput) {
-      //          multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-      //        } else if (entryValue instanceof String) {
-      //          multipartBody.addPart(entryName, transferEncoding,
-      //              new TypedString((String) entryValue));
-      //        } else {
-      //          multipartBody.addPart(entryName, transferEncoding,
-      //              converter.toBody(entryValue, entryValue.getClass()));
-      //        }
-      //      }
-      //    }
-      //  }
-      } else if (annotationType == Body.class) {
-        if (value == null) {
-          throw new IllegalArgumentException("Body parameter value must not be null.");
-        }
-        if (value instanceof RequestBody) {
-          body = (RequestBody) value;
-        } else {
-          body = converter.toBody(value, value.getClass());
-        }
-      } else {
-        throw new IllegalArgumentException(
-            "Unknown annotation: " + annotationType.getCanonicalName());
-      }
-    }
+  void setBody(RequestBody body) {
+    this.body = body;
   }
 
   Request build() {
-    //if (multipartBody != null && multipartBody.getPartCount() == 0) {
-    //  throw new IllegalStateException("Multipart requests must contain at least one part.");
-    //}
-
-    String apiUrl = this.apiUrl;
-    StringBuilder url = new StringBuilder(apiUrl);
-    if (apiUrl.endsWith("/")) {
-      // We require relative paths to start with '/'. Prevent a double-slash.
-      url.deleteCharAt(url.length() - 1);
+    HttpUrl url;
+    HttpUrl.Builder urlBuilder = this.urlBuilder;
+    if (urlBuilder != null) {
+      url = urlBuilder.build();
+    } else {
+      // No query parameters triggered builder creation, just combine the relative URL and base URL.
+      url = baseUrl.resolve(relativeUrl);
     }
 
-    url.append(relativeUrl);
-
-    StringBuilder queryParams = this.queryParams;
-    if (queryParams != null) {
-      url.append(queryParams);
+    RequestBody body = this.body;
+    if (body == null) {
+      // Try to pull from one of the builders.
+      if (formEncodingBuilder != null) {
+        body = formEncodingBuilder.build();
+      } else if (multipartBuilder != null) {
+        body = multipartBuilder.build();
+      } else if (hasBody) {
+        // Body is absent, make an empty body.
+        body = RequestBody.create(null, new byte[0]);
+      }
     }
 
-    RequestBody body = this.body;
-    Headers.Builder headerBuilder = this.headers;
-    if (contentTypeHeader != null) {
+    MediaType contentType = this.contentType;
+    if (contentType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
+        body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        if (headerBuilder == null) {
-          headerBuilder = new Headers.Builder();
-        }
-        headerBuilder.add("Content-Type", contentTypeHeader);
+        requestBuilder.addHeader("Content-Type", contentType.toString());
       }
     }
 
-    Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
-
-    return new Request.Builder()
-        .url(url.toString())
-        .method(requestMethod, body)
-        .headers(headers)
+    return requestBuilder
+        .url(url)
+        .method(method, body)
         .build();
   }
 
-  private static class MediaTypeOverridingRequestBody extends RequestBody {
+  private static class ContentTypeOverridingRequestBody extends RequestBody {
     private final RequestBody delegate;
-    private final MediaType mediaType;
+    private final MediaType contentType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
+    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {
       this.delegate = delegate;
-      this.mediaType = MediaType.parse(mediaType);
+      this.contentType = contentType;
     }
 
     @Override public MediaType contentType() {
-      return mediaType;
+      return contentType;
     }
 
     @Override public long contentLength() throws IOException {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
new file mode 100644
index 000000000..ba302c483
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.util.List;
+import java.util.Map;
+
+import static retrofit.Utils.checkNotNull;
+
+abstract class RequestBuilderAction {
+  abstract void perform(RequestBuilder builder, Object value);
+
+  static final class Url extends RequestBuilderAction {
+    @Override void perform(RequestBuilder builder, Object value) {
+      builder.setRelativeUrl((String) value);
+    }
+  }
+
+  static final class Header extends RequestBuilderAction {
+    private final String name;
+
+    Header(String name) {
+      this.name = checkNotNull(name, "name == null");
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addHeader(name, iterableValue.toString());
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addHeader(name, arrayValue.toString());
+          }
+        }
+      } else {
+        builder.addHeader(name, value.toString());
+      }
+    }
+  }
+
+  static final class Path extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Path(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, value.toString(), encoded);
+    }
+  }
+
+  static final class Query extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Query(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addQueryParam(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addQueryParam(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addQueryParam(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class QueryMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    QueryMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Field extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Field(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addFormField(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addFormField(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addFormField(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class FieldMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    FieldMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Part<T> extends RequestBuilderAction {
+    private final Headers headers;
+    private final Converter<T, RequestBody> converter;
+
+    Part(Headers headers, Converter<T, RequestBody> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      RequestBody body;
+      try {
+        //noinspection unchecked
+        body = converter.convert((T) value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody");
+      }
+      builder.addPart(headers, body);
+    }
+  }
+
+  static final class PartMap extends RequestBuilderAction {
+    private final List<Converter.Factory> converterFactories;
+    private final String transferEncoding;
+    private final Annotation[] annotations;
+
+    PartMap(List<Converter.Factory> converterFactories, String transferEncoding,
+        Annotation[] annotations) {
+      this.converterFactories = converterFactories;
+      this.transferEncoding = transferEncoding;
+      this.annotations = annotations;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue == null) {
+          continue; // Skip null values.
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+
+        Class<?> entryClass = entryValue.getClass();
+        //noinspection unchecked
+        Converter<Object, RequestBody> converter =
+            (Converter<Object, RequestBody>) Utils.resolveRequestBodyConverter(converterFactories,
+                entryClass, annotations);
+        RequestBody body;
+        try {
+          body = converter.convert(entryValue);
+        } catch (IOException e) {
+          throw new RuntimeException("Unable to convert " + entryValue + " to RequestBody");
+        }
+        builder.addPart(headers, body);
+      }
+    }
+  }
+
+  static final class Body<T> extends RequestBuilderAction {
+    private final Converter<T, RequestBody> converter;
+
+    Body(Converter<T, RequestBody> converter) {
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      RequestBody body;
+      try {
+        //noinspection unchecked
+        body = converter.convert((T) value);
+      } catch (IOException e) {
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody");
+      }
+      builder.setBody(body);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
new file mode 100644
index 000000000..0e1668198
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestFactory.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+
+final class RequestFactory {
+  private final String method;
+  private final BaseUrl baseUrl;
+  private final String relativeUrl;
+  private final Headers headers;
+  private final MediaType contentType;
+  private final boolean hasBody;
+  private final boolean isFormEncoded;
+  private final boolean isMultipart;
+  private final RequestBuilderAction[] requestBuilderActions;
+
+  RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,
+      MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart,
+      RequestBuilderAction[] requestBuilderActions) {
+    this.method = method;
+    this.baseUrl = baseUrl;
+    this.relativeUrl = relativeUrl;
+    this.headers = headers;
+    this.contentType = contentType;
+    this.hasBody = hasBody;
+    this.isFormEncoded = isFormEncoded;
+    this.isMultipart = isMultipart;
+    this.requestBuilderActions = requestBuilderActions;
+  }
+
+  Request create(Object... args) {
+    RequestBuilder requestBuilder =
+        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
+            isFormEncoded, isMultipart);
+
+    if (args != null) {
+      RequestBuilderAction[] actions = requestBuilderActions;
+      if (actions.length != args.length) {
+        throw new IllegalArgumentException("Argument count ("
+            + args.length
+            + ") doesn't match action count ("
+            + actions.length
+            + ")");
+      }
+      for (int i = 0, count = args.length; i < count; i++) {
+        actions[i].perform(requestBuilder, args[i]);
+      }
+    }
+
+    return requestBuilder.build();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
new file mode 100644
index 000000000..7d3017115
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestFactoryParser.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import retrofit.http.Body;
+import retrofit.http.DELETE;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
+import retrofit.http.GET;
+import retrofit.http.HEAD;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+import retrofit.http.Headers;
+import retrofit.http.Multipart;
+import retrofit.http.PATCH;
+import retrofit.http.POST;
+import retrofit.http.PUT;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
+import retrofit.http.Url;
+
+import static retrofit.Utils.methodError;
+
+final class RequestFactoryParser {
+  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
+  private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
+  private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
+  private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
+
+  static RequestFactory parse(Method method, BaseUrl baseUrl,
+      List<Converter.Factory> converterFactories) {
+    RequestFactoryParser parser = new RequestFactoryParser(method);
+    parser.parseMethodAnnotations();
+    parser.parseParameters(converterFactories);
+    return parser.toRequestFactory(baseUrl);
+  }
+
+  private final Method method;
+
+  private String httpMethod;
+  private boolean hasBody;
+  private boolean isFormEncoded;
+  private boolean isMultipart;
+  private String relativeUrl;
+  private com.squareup.okhttp.Headers headers;
+  private MediaType contentType;
+  private RequestBuilderAction[] requestBuilderActions;
+
+  private Set<String> relativeUrlParamNames;
+
+  private RequestFactoryParser(Method method) {
+    this.method = method;
+  }
+
+  private RequestFactory toRequestFactory(BaseUrl baseUrl) {
+    return new RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,
+        isFormEncoded, isMultipart, requestBuilderActions);
+  }
+
+  private RuntimeException parameterError(Throwable cause, int index, String message,
+      Object... args) {
+    return methodError(cause, method, message + " (parameter #" + (index + 1) + ")", args);
+  }
+
+  private RuntimeException parameterError(int index, String message, Object... args) {
+    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
+  }
+
+  private void parseMethodAnnotations() {
+    for (Annotation annotation : method.getAnnotations()) {
+      if (annotation instanceof DELETE) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
+      } else if (annotation instanceof GET) {
+        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
+      } else if (annotation instanceof HEAD) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
+      } else if (annotation instanceof PATCH) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
+      } else if (annotation instanceof POST) {
+        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
+      } else if (annotation instanceof PUT) {
+        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
+      } else if (annotation instanceof HTTP) {
+        HTTP http = (HTTP) annotation;
+        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
+      } else if (annotation instanceof Headers) {
+        String[] headersToParse = ((Headers) annotation).value();
+        if (headersToParse.length == 0) {
+          throw methodError(method, "@Headers annotation is empty.");
+        }
+        headers = parseHeaders(headersToParse);
+      } else if (annotation instanceof Multipart) {
+        if (isFormEncoded) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isMultipart = true;
+      } else if (annotation instanceof FormUrlEncoded) {
+        if (isMultipart) {
+          throw methodError(method, "Only one encoding annotation is allowed.");
+        }
+        isFormEncoded = true;
+      }
+    }
+
+    if (httpMethod == null) {
+      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    }
+    if (!hasBody) {
+      if (isMultipart) {
+        throw methodError(method,
+            "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+      }
+      if (isFormEncoded) {
+        throw methodError(method,
+            "FormUrlEncoded can only be specified on HTTP methods with request body "
+                + "(e.g., @POST).");
+      }
+    }
+  }
+
+  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
+    if (this.httpMethod != null) {
+      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
+          this.httpMethod, httpMethod);
+    }
+    this.httpMethod = httpMethod;
+    this.hasBody = hasBody;
+
+    if (value.isEmpty()) {
+      return;
+    }
+
+    // Get the relative URL path and existing query string, if present.
+    int question = value.indexOf('?');
+    if (question != -1 && question < value.length() - 1) {
+      // Ensure the query string does not have any named parameters.
+      String queryParams = value.substring(question + 1);
+      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+      if (queryParamMatcher.find()) {
+        throw methodError(method, "URL query string \"%s\" must not have replace block. "
+            + "For dynamic query parameters use @Query.", queryParams);
+      }
+    }
+
+    this.relativeUrl = value;
+    this.relativeUrlParamNames = parsePathParameters(value);
+  }
+
+  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+    com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
+    for (String header : headers) {
+      int colon = header.indexOf(':');
+      if (colon == -1 || colon == 0 || colon == header.length() - 1) {
+        throw methodError(method,
+            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+      }
+      String headerName = header.substring(0, colon);
+      String headerValue = header.substring(colon + 1).trim();
+      if ("Content-Type".equalsIgnoreCase(headerName)) {
+        contentType = MediaType.parse(headerValue);
+      } else {
+        builder.add(headerName, headerValue);
+      }
+    }
+    return builder.build();
+  }
+
+  private void parseParameters(List<Converter.Factory> converterFactories) {
+    Type[] methodParameterTypes = method.getGenericParameterTypes();
+    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+
+    boolean gotField = false;
+    boolean gotPart = false;
+    boolean gotBody = false;
+    boolean gotPath = false;
+    boolean gotQuery = false;
+    boolean gotUrl = false;
+
+    int count = methodParameterAnnotationArrays.length;
+    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
+    for (int i = 0; i < count; i++) {
+      Type methodParameterType = methodParameterTypes[i];
+      Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
+      if (methodParameterAnnotations != null) {
+        for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
+          RequestBuilderAction action = null;
+          if (methodParameterAnnotation instanceof Url) {
+            if (gotUrl) {
+              throw parameterError(i, "Multiple @Url method annotations found.");
+            }
+            if (gotPath) {
+              throw parameterError(i, "@Path parameters may not be used with @Url.");
+            }
+            if (gotQuery) {
+              throw parameterError(i, "A @Url parameter must not come after a @Query");
+            }
+            if (methodParameterType != String.class) {
+              throw parameterError(i, "@Url must be String type.");
+            }
+            if (relativeUrl != null) {
+              throw parameterError(i, "@Url cannot be used with @%s URL", httpMethod);
+            }
+            gotUrl = true;
+            action = new RequestBuilderAction.Url();
+
+          } else if (methodParameterAnnotation instanceof Path) {
+            if (gotQuery) {
+              throw parameterError(i, "A @Path parameter must not come after a @Query.");
+            }
+            if (gotUrl) {
+              throw parameterError(i, "@Path parameters may not be used with @Url.");
+            }
+            if (relativeUrl == null) {
+              throw parameterError(i, "@Path can only be used with relative url on @%s",
+                  httpMethod);
+            }
+            gotPath = true;
+
+            Path path = (Path) methodParameterAnnotation;
+            String name = path.value();
+            validatePathName(i, name);
+            action = new RequestBuilderAction.Path(name, path.encoded());
+
+          } else if (methodParameterAnnotation instanceof Query) {
+            Query query = (Query) methodParameterAnnotation;
+            action = new RequestBuilderAction.Query(query.value(), query.encoded());
+            gotQuery = true;
+
+          } else if (methodParameterAnnotation instanceof QueryMap) {
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@QueryMap parameter type must be Map.");
+            }
+            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
+            action = new RequestBuilderAction.QueryMap(queryMap.encoded());
+
+          } else if (methodParameterAnnotation instanceof Header) {
+            Header header = (Header) methodParameterAnnotation;
+            action = new RequestBuilderAction.Header(header.value());
+
+          } else if (methodParameterAnnotation instanceof Field) {
+            if (!isFormEncoded) {
+              throw parameterError(i, "@Field parameters can only be used with form encoding.");
+            }
+            Field field = (Field) methodParameterAnnotation;
+            action = new RequestBuilderAction.Field(field.value(), field.encoded());
+            gotField = true;
+
+          } else if (methodParameterAnnotation instanceof FieldMap) {
+            if (!isFormEncoded) {
+              throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
+            }
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@FieldMap parameter type must be Map.");
+            }
+            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
+            action = new RequestBuilderAction.FieldMap(fieldMap.encoded());
+            gotField = true;
+
+          } else if (methodParameterAnnotation instanceof Part) {
+            if (!isMultipart) {
+              throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
+            }
+            Part part = (Part) methodParameterAnnotation;
+            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
+                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Transfer-Encoding", part.encoding());
+            Converter<?, RequestBody> converter;
+            try {
+              converter = Utils.resolveRequestBodyConverter(converterFactories, methodParameterType,
+                  methodParameterAnnotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+              throw parameterError(e, i, "Unable to create @Part converter for %s",
+                  methodParameterType);
+            }
+            action = new RequestBuilderAction.Part<>(headers, converter);
+            gotPart = true;
+
+          } else if (methodParameterAnnotation instanceof PartMap) {
+            if (!isMultipart) {
+              throw parameterError(i,
+                  "@PartMap parameters can only be used with multipart encoding.");
+            }
+            if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
+              throw parameterError(i, "@PartMap parameter type must be Map.");
+            }
+            PartMap partMap = (PartMap) methodParameterAnnotation;
+            action = new RequestBuilderAction.PartMap(converterFactories, partMap.encoding(),
+                methodParameterAnnotations);
+            gotPart = true;
+
+          } else if (methodParameterAnnotation instanceof Body) {
+            if (isFormEncoded || isMultipart) {
+              throw parameterError(i,
+                  "@Body parameters cannot be used with form or multi-part encoding.");
+            }
+            if (gotBody) {
+              throw parameterError(i, "Multiple @Body method annotations found.");
+            }
+
+            Converter<?, RequestBody> converter;
+            try {
+              converter = Utils.resolveRequestBodyConverter(converterFactories, methodParameterType,
+                  methodParameterAnnotations);
+            } catch (RuntimeException e) { // Wide exception range because factories are user code.
+              throw parameterError(e, i, "Unable to create @Body converter for %s",
+                  methodParameterType);
+            }
+            action = new RequestBuilderAction.Body<>(converter);
+            gotBody = true;
+          }
+
+          if (action != null) {
+            if (requestBuilderActions[i] != null) {
+              throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
+            }
+            requestBuilderActions[i] = action;
+          }
+        }
+      }
+
+      if (requestBuilderActions[i] == null) {
+        throw parameterError(i, "No Retrofit annotation found.");
+      }
+    }
+
+    if (relativeUrl == null && !gotUrl) {
+      throw methodError(method, "Missing either @%s URL or @Url parameter.", httpMethod);
+    }
+    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
+      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+    }
+    if (isFormEncoded && !gotField) {
+      throw methodError(method, "Form-encoded method must contain at least one @Field.");
+    }
+    if (isMultipart && !gotPart) {
+      throw methodError(method, "Multipart method must contain at least one @Part.");
+    }
+
+    this.requestBuilderActions = requestBuilderActions;
+  }
+
+  private void validatePathName(int index, String name) {
+    if (!PARAM_NAME_REGEX.matcher(name).matches()) {
+      throw parameterError(index, "@Path parameter name must match %s. Found: %s",
+          PARAM_URL_REGEX.pattern(), name);
+    }
+    // Verify URL replacement name is actually present in the URL path.
+    if (!relativeUrlParamNames.contains(name)) {
+      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", relativeUrl, name);
+    }
+  }
+
+  /**
+   * Gets the set of unique path parameters used in the given URI. If a parameter is used twice
+   * in the URI, it will only show up once in the set.
+   */
+  static Set<String> parsePathParameters(String path) {
+    Matcher m = PARAM_URL_REGEX.matcher(path);
+    Set<String> patterns = new LinkedHashSet<>();
+    while (m.find()) {
+      patterns.add(m.group(1));
+    }
+    return patterns;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestInterceptor.java b/retrofit/src/main/java/retrofit/RequestInterceptor.java
deleted file mode 100644
index 406014a99..000000000
--- a/retrofit/src/main/java/retrofit/RequestInterceptor.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package retrofit;
-
-/** Intercept every request before it is executed in order to add additional data. */
-public interface RequestInterceptor {
-  /** Called for every request. Add data using methods on the supplied {@link RequestFacade}. */
-  void intercept(RequestFacade request);
-
-  interface RequestFacade {
-    /** Add a header to the request. This will not replace any existing headers. */
-    void addHeader(String name, String value);
-
-    /**
-     * Add a path parameter replacement. This works exactly like a {@link retrofit.http.Path
-     * &#64;Path}-annotated method argument.
-     */
-    void addPathParam(String name, String value);
-
-    /**
-     * Add a path parameter replacement without first URI encoding. This works exactly like a
-     * {@link retrofit.http.Path &#64;Path}-annotated method argument with {@code encode=false}.
-     */
-    void addEncodedPathParam(String name, String value);
-
-    /** Add an additional query parameter. This will not replace any existing query parameters. */
-    void addQueryParam(String name, String value);
-
-    /**
-     * Add an additional query parameter without first URI encoding. This will not replace any
-     * existing query parameters.
-     */
-    void addEncodedQueryParam(String name, String value);
-  }
-
-  /** A {@link RequestInterceptor} which does no modification of requests. */
-  RequestInterceptor NONE = new RequestInterceptor() {
-    @Override public void intercept(RequestFacade request) {
-      // Do nothing.
-    }
-  };
-}
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
new file mode 100644
index 000000000..f653ca5d1
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.ResponseBody;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * TODO
+ */
+public final class Response<T> {
+  /**
+   * TODO
+   */
+  public static <T> Response<T> success(T body) {
+    return success(body, new com.squareup.okhttp.Response.Builder() //
+        .code(200)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
+    return new Response<>(rawResponse, body, null);
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> error(int code, ResponseBody body) {
+    return error(body, new com.squareup.okhttp.Response.Builder() //
+        .code(code)
+        .protocol(Protocol.HTTP_1_1)
+        .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
+            .build())
+        .build());
+  }
+
+  /**
+   * TODO
+   */
+  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+    return new Response<>(rawResponse, null, body);
+  }
+
+  private final com.squareup.okhttp.Response rawResponse;
+  private final T body;
+  private final ResponseBody errorBody;
+
+  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+    this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
+    this.body = body;
+    this.errorBody = errorBody;
+  }
+
+  /** The raw response from the HTTP client. */
+  public com.squareup.okhttp.Response raw() {
+    return rawResponse;
+  }
+
+  /** HTTP status code. */
+  public int code() {
+    return rawResponse.code();
+  }
+
+  /** HTTP status message. */
+  public String message() {
+    return rawResponse.message();
+  }
+
+  public Headers headers() {
+    return rawResponse.headers();
+  }
+
+  /** {@code true} if {@link #code()} is in the range [200..300). */
+  public boolean isSuccess() {
+    return rawResponse.isSuccessful();
+  }
+
+  /** The deserialized response body of a {@linkplain #isSuccess() successful} response. */
+  public T body() {
+    return body;
+  }
+
+  /** The raw response body of an {@linkplain #isSuccess() unsuccessful} response. */
+  public ResponseBody errorBody() {
+    return errorBody;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
deleted file mode 100644
index afd1ff400..000000000
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.concurrent.Executor;
-import retrofit.converter.Converter;
-import retrofit.http.HTTP;
-import retrofit.http.Header;
-
-/**
- * Adapts a Java interface to a REST API.
- * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
- * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit.http.GET GET},
- * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.POST PATCH},
- * {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a custom
- * HTTP method with {@link HTTP @HTTP}.
- * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit.http.Query @Query}.
- * <p>
- * HTTP requests happen in one of two ways:
- * <ul>
- * <li>On the provided HTTP {@link Executor} with callbacks marshaled to the callback
- * {@link Executor}. The last method parameter should be of type {@link Callback}. The HTTP
- * response will be converted to the callback's parameter type using the specified
- * {@link retrofit.converter.Converter Converter}. If the callback parameter type uses a wildcard,
- * the lower bound will be used as the conversion type.
- * <li>On the current thread returning the response or throwing a {@link RetrofitError}. The HTTP
- * response will be converted to the method's return type using the specified
- * {@link retrofit.converter.Converter Converter}.
- * </ul>
- * <p>
- * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
- * will be converted to request representation by a call to
- * {@link retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type) toBody}
- * on the supplied {@link retrofit.converter.Converter Converter} for this instance.
- * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
- * <ul>
- * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
- * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
- * specified by the {@link retrofit.http.Part @Part} parameter annotation.
- * </ul>
- * <p>
- * Additional static headers can be added for an endpoint using the
- * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
- * <p>
- * For example:
- * <pre>
- * public interface MyApi {
- *   &#64;POST("/category/{cat}") // Asynchronous execution.
- *   void categoryList(@Path("cat") String a, @Query("page") int b,
- *                     Callback&lt;List&lt;Item&gt;&gt; cb);
- *   &#64;POST("/category/{cat}") // Synchronous execution.
- *   List&lt;Item&gt; categoryList(@Path("cat") String a, @Query("page") int b);
- * }
- * </pre>
- * <p>
- * Calling {@link #create(Class)} with {@code MyApi.class} will validate and create a new
- * implementation of the API.
- *
- * @author Bob Lee (bob@squareup.com)
- * @author Jake Wharton (jw@squareup.com)
- */
-public class RestAdapter {
-  private final Map<Class<?>, Map<Method, MethodInfo>> serviceMethodInfoCache =
-      new LinkedHashMap<Class<?>, Map<Method, MethodInfo>>();
-
-  final Endpoint endpoint;
-  final Executor callbackExecutor;
-  final RequestInterceptor requestInterceptor;
-  final Converter converter;
-  final ErrorHandler errorHandler;
-
-  private final OkHttpClient client;
-  private RxSupport rxSupport;
-
-  private RestAdapter(Endpoint endpoint, OkHttpClient client, Executor callbackExecutor,
-      RequestInterceptor requestInterceptor, Converter converter, ErrorHandler errorHandler) {
-    this.endpoint = endpoint;
-    this.client = client;
-    this.callbackExecutor = callbackExecutor;
-    this.requestInterceptor = requestInterceptor;
-    this.converter = converter;
-    this.errorHandler = errorHandler;
-  }
-
-  /** Create an implementation of the API defined by the specified {@code service} interface. */
-  @SuppressWarnings("unchecked")
-  public <T> T create(Class<T> service) {
-    Utils.validateServiceClass(service);
-    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
-        new RestHandler(getMethodInfoCache(service)));
-  }
-
-  Map<Method, MethodInfo> getMethodInfoCache(Class<?> service) {
-    synchronized (serviceMethodInfoCache) {
-      Map<Method, MethodInfo> methodInfoCache = serviceMethodInfoCache.get(service);
-      if (methodInfoCache == null) {
-        methodInfoCache = new LinkedHashMap<Method, MethodInfo>();
-        serviceMethodInfoCache.put(service, methodInfoCache);
-      }
-      return methodInfoCache;
-    }
-  }
-
-  static MethodInfo getMethodInfo(Map<Method, MethodInfo> cache, Method method) {
-    synchronized (cache) {
-      MethodInfo methodInfo = cache.get(method);
-      if (methodInfo == null) {
-        methodInfo = new MethodInfo(method);
-        cache.put(method, methodInfo);
-      }
-      return methodInfo;
-    }
-  }
-
-  private class RestHandler implements InvocationHandler {
-    private final Map<Method, MethodInfo> methodDetailsCache;
-
-    RestHandler(Map<Method, MethodInfo> methodDetailsCache) {
-      this.methodDetailsCache = methodDetailsCache;
-    }
-
-    @SuppressWarnings("unchecked") //
-    @Override public Object invoke(Object proxy, Method method, final Object[] args)
-        throws Throwable {
-      // If the method is a method from Object then defer to normal invocation.
-      if (method.getDeclaringClass() == Object.class) {
-        return method.invoke(this, args);
-      }
-
-      MethodInfo methodInfo = getMethodInfo(methodDetailsCache, method);
-      Request request = createRequest(methodInfo, args);
-      switch (methodInfo.executionType) {
-        case SYNC:
-          return invokeSync(methodInfo, request);
-        case ASYNC:
-          invokeAsync(methodInfo, request, (Callback) args[args.length - 1]);
-          return null; // Async has void return type.
-        case RX:
-          return invokeRx(methodInfo, request);
-        default:
-          throw new IllegalStateException("Unknown response type: " + methodInfo.executionType);
-      }
-    }
-
-    private Object invokeSync(MethodInfo methodInfo, Request request) throws Throwable {
-      try {
-        Response response = client.newCall(request).execute();
-        return createResult(methodInfo, response);
-      } catch (IOException e) {
-        throw handleError(RetrofitError.networkFailure(request.urlString(), e));
-      } catch (RetrofitError error) {
-        throw handleError(error);
-      }
-    }
-
-    private Throwable handleError(RetrofitError error) {
-      Throwable throwable = errorHandler.handleError(error);
-      if (throwable == null) {
-        return new IllegalStateException("Error handler returned null for wrapped exception.",
-            error);
-      }
-      return throwable;
-    }
-
-    private void invokeAsync(final MethodInfo methodInfo, final Request request,
-        final Callback callback) {
-      Call call = client.newCall(request);
-      call.enqueue(new com.squareup.okhttp.Callback() {
-        @Override public void onFailure(Request request, IOException e) {
-          callFailure(callback, RetrofitError.networkFailure(request.urlString(), e));
-        }
-
-        @Override public void onResponse(Response response) {
-          try {
-            Object result = createResult(methodInfo, response);
-            callResponse(callback, result, response);
-          } catch (RetrofitError error) {
-            callFailure(callback, error);
-          }
-        }
-      });
-    }
-
-    private Object invokeRx(final MethodInfo methodInfo, final Request request) {
-      if (rxSupport == null) {
-        if (Platform.HAS_RX_JAVA) {
-          rxSupport = new RxSupport();
-        } else {
-          throw new IllegalStateException("Found Observable return type but RxJava not present.");
-        }
-      }
-      return rxSupport.createRequestObservable(new RxSupport.Invoker() {
-        @Override public void invoke(final Callback callback) {
-          Call call = client.newCall(request);
-          call.enqueue(new com.squareup.okhttp.Callback() {
-            @Override public void onFailure(Request request, IOException e) {
-              callback.next(RetrofitError.networkFailure(request.urlString(), e));
-            }
-
-            @Override public void onResponse(Response response) {
-              try {
-                Object result = createResult(methodInfo, response);
-                callback.next(result);
-              } catch (RetrofitError error) {
-                callback.error(handleError(error));
-              }
-            }
-          });
-
-        }
-      });
-    }
-
-    /**
-     * Create the object to return to the caller for a response.
-     *
-     * @throws RetrofitError if any HTTP, network, or unexpected errors occurred.
-     */
-    private Object createResult(MethodInfo methodInfo, Response response) {
-      try {
-        return parseResult(methodInfo, response);
-      } catch (RetrofitError error) {
-        throw error; // Let our own errors pass through.
-      } catch (IOException e) {
-        throw RetrofitError.networkError(response, e);
-      } catch (Throwable t) {
-        throw RetrofitError.unexpectedError(response, t);
-      }
-    }
-
-    /**
-     * Parse the object to return to the caller from a response.
-     *
-     * @throws RetrofitError on non-2xx response codes (kind = HTTP).
-     * @throws IOException on network problems reading the response data.
-     * @throws RuntimeException on malformed response data.
-     */
-    private Object parseResult(MethodInfo methodInfo, Response response)
-        throws IOException {
-      Type type = methodInfo.responseObjectType;
-
-      int statusCode = response.code();
-      if (statusCode < 200 || statusCode >= 300) {
-        response = Utils.readBodyToBytesIfNecessary(response);
-        throw RetrofitError.httpError(response, converter, type);
-      }
-
-      if (type.equals(Response.class)) {
-        if (!methodInfo.isStreaming) {
-          // Read the entire stream and replace with one backed by a byte[].
-          response = Utils.readBodyToBytesIfNecessary(response);
-        }
-        return response;
-      }
-
-      ResponseBody body = response.body();
-      if (body == null) {
-        return null;
-      }
-
-      ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(body);
-      try {
-        return converter.fromBody(wrapped, type);
-      } catch (RuntimeException e) {
-        // If the underlying input stream threw an exception, propagate that rather than
-        // indicating that it was a conversion exception.
-        if (wrapped.threwException()) {
-          throw wrapped.getThrownException();
-        }
-        throw e;
-      }
-    }
-
-    private void callResponse(final Callback callback, final Object result,
-        final Response response) {
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.success(result, response);
-        }
-      });
-    }
-
-    private void callFailure(final Callback callback, RetrofitError error) {
-      Throwable throwable = handleError(error);
-      if (throwable != error) {
-        Response response = error.getResponse();
-        if (response != null) {
-          error = RetrofitError.unexpectedError(response, throwable);
-        } else {
-          error = RetrofitError.unexpectedError(error.getUrl(), throwable);
-        }
-      }
-      final RetrofitError finalError = error;
-      callbackExecutor.execute(new Runnable() {
-        @Override public void run() {
-          callback.failure(finalError);
-        }
-      });
-    }
-
-    private Request createRequest(MethodInfo methodInfo, Object[] args) {
-      String serverUrl = endpoint.url();
-      RequestBuilder requestBuilder = new RequestBuilder(serverUrl, methodInfo, converter);
-      requestBuilder.setArguments(args);
-
-      requestInterceptor.intercept(requestBuilder);
-
-      return requestBuilder.build();
-    }
-  }
-
-  /**
-   * Build a new {@link RestAdapter}.
-   * <p>
-   * Calling {@link #setEndpoint} is required before calling {@link #build()}. All other methods
-   * are optional.
-   */
-  public static class Builder {
-    private Endpoint endpoint;
-    private OkHttpClient client;
-    private Executor callbackExecutor;
-    private RequestInterceptor requestInterceptor;
-    private Converter converter;
-    private ErrorHandler errorHandler;
-
-    /** API endpoint URL. */
-    public Builder setEndpoint(String url) {
-       return setEndpoint(Endpoint.createFixed(url));
-    }
-
-    /** API endpoint. */
-    public Builder setEndpoint(Endpoint endpoint) {
-      if (endpoint == null) {
-        throw new NullPointerException("Endpoint may not be null.");
-      }
-      this.endpoint = endpoint;
-      return this;
-    }
-
-    /** The HTTP client used for requests. */
-    public Builder setClient(OkHttpClient client) {
-      if (client == null) {
-        throw new NullPointerException("Client may not be null.");
-      }
-      this.client = client;
-      return this;
-    }
-
-    /**
-     * Executor on which any {@link Callback} methods will be invoked. If this argument is
-     * {@code null} then callback methods will be run on the same thread as the HTTP client.
-     */
-    public Builder setCallbackExecutor(Executor callbackExecutor) {
-      if (callbackExecutor == null) {
-        callbackExecutor = new Utils.SynchronousExecutor();
-      }
-      this.callbackExecutor = callbackExecutor;
-      return this;
-    }
-
-    /** A request interceptor for adding data to every request. */
-    public Builder setRequestInterceptor(RequestInterceptor requestInterceptor) {
-      if (requestInterceptor == null) {
-        throw new NullPointerException("Request interceptor may not be null.");
-      }
-      this.requestInterceptor = requestInterceptor;
-      return this;
-    }
-
-    /** The converter used for serialization and deserialization of objects. */
-    public Builder setConverter(Converter converter) {
-      if (converter == null) {
-        throw new NullPointerException("Converter may not be null.");
-      }
-      this.converter = converter;
-      return this;
-    }
-
-    /**
-     * The error handler allows you to customize the type of exception thrown for errors on
-     * synchronous requests.
-     */
-    public Builder setErrorHandler(ErrorHandler errorHandler) {
-      if (errorHandler == null) {
-        throw new NullPointerException("Error handler may not be null.");
-      }
-      this.errorHandler = errorHandler;
-      return this;
-    }
-    /** Create the {@link RestAdapter} instances. */
-    public RestAdapter build() {
-      if (endpoint == null) {
-        throw new IllegalArgumentException("Endpoint may not be null.");
-      }
-      ensureSaneDefaults();
-      return new RestAdapter(endpoint, client, callbackExecutor, requestInterceptor, converter,
-          errorHandler);
-    }
-
-    private void ensureSaneDefaults() {
-      if (converter == null) {
-        converter = Platform.get().defaultConverter();
-      }
-      if (client == null) {
-        client = Platform.get().defaultClient();
-      }
-      if (callbackExecutor == null) {
-        callbackExecutor = Platform.get().defaultCallbackExecutor();
-      }
-      if (errorHandler == null) {
-        errorHandler = ErrorHandler.DEFAULT;
-      }
-      if (requestInterceptor == null) {
-        requestInterceptor = RequestInterceptor.NONE;
-      }
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
new file mode 100644
index 000000000..765a9c5d5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import retrofit.http.HTTP;
+import retrofit.http.Header;
+
+import static retrofit.Utils.checkNotNull;
+
+/**
+ * Adapts a Java interface to a REST API.
+ * <p>
+ * API endpoints are defined as methods on an interface with annotations providing metadata about
+ * the form in which the HTTP call should be made.
+ * <p>
+ * The relative path for a given method is obtained from an annotation on the method describing
+ * the request type. The built-in methods are {@link retrofit.http.GET GET},
+ * {@link retrofit.http.PUT PUT}, {@link retrofit.http.POST POST}, {@link retrofit.http.PATCH
+ * PATCH}, {@link retrofit.http.HEAD HEAD}, and {@link retrofit.http.DELETE DELETE}. You can use a
+ * custom HTTP method with {@link HTTP @HTTP}.
+ * <p>
+ * Method parameters can be used to replace parts of the URL by annotating them with
+ * {@link retrofit.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
+ * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+ * {@link retrofit.http.Query @Query}.
+ * <p>
+ * The body of a request is denoted by the {@link retrofit.http.Body @Body} annotation. The object
+ * will be converted to request representation by one of the {@link Converter.Factory} instances.
+ * A {@link RequestBody} can also be used for a raw representation.
+ * <p>
+ * Alternative request body formats are supported by method annotations and corresponding parameter
+ * annotations:
+ * <ul>
+ * <li>{@link retrofit.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+ * pairs specified by the {@link retrofit.http.Field @Field} parameter annotation.
+ * <li>{@link retrofit.http.Multipart @Multipart} - RFC 2387-compliant multi-part data with parts
+ * specified by the {@link retrofit.http.Part @Part} parameter annotation.
+ * </ul>
+ * <p>
+ * Additional static headers can be added for an endpoint using the
+ * {@link retrofit.http.Headers @Headers} method annotation. For per-request control over a header
+ * annotate a parameter with {@link Header @Header}.
+ * <p>
+ * By default, methods return a {@link Call} which represents the HTTP request. The generic
+ * parameter of the call is the response body type and will be converted by one of the
+ * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+ * representation. {@link Void} can be used if you do not care about the body contents.
+ * <p>
+ * For example:
+ * <pre>
+ * public interface CategoryService {
+ *   &#64;POST("/category/{cat}")
+ *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+ * }
+ * </pre>
+ * <p>
+ * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
+ * annotations and create a new implementation of the service definition.
+ *
+ * @author Bob Lee (bob@squareup.com)
+ * @author Jake Wharton (jw@squareup.com)
+ */
+public final class Retrofit {
+  private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
+
+  private final OkHttpClient client;
+  private final BaseUrl baseUrl;
+  private final List<Converter.Factory> converterFactories;
+  private final List<CallAdapter.Factory> adapterFactories;
+  private final Executor callbackExecutor;
+
+  private Retrofit(OkHttpClient client, BaseUrl baseUrl, List<Converter.Factory> converterFactories,
+      List<CallAdapter.Factory> adapterFactories, Executor callbackExecutor) {
+    this.client = client;
+    this.baseUrl = baseUrl;
+    this.converterFactories = converterFactories;
+    this.adapterFactories = adapterFactories;
+    this.callbackExecutor = callbackExecutor;
+  }
+
+  /** Create an implementation of the API defined by the {@code service} interface. */
+  @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
+  public <T> T create(final Class<T> service) {
+    Utils.validateServiceInterface(service);
+    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
+        new InvocationHandler() {
+          private final Platform platform = Platform.get();
+
+          @Override public Object invoke(Object proxy, Method method, Object... args)
+              throws Throwable {
+            // If the method is a method from Object then defer to normal invocation.
+            if (method.getDeclaringClass() == Object.class) {
+              return method.invoke(this, args);
+            }
+            if (platform.isDefaultMethod(method)) {
+              return platform.invokeDefaultMethod(method, service, proxy, args);
+            }
+            return loadMethodHandler(method).invoke(args);
+          }
+        });
+  }
+
+  MethodHandler<?> loadMethodHandler(Method method) {
+    MethodHandler<?> handler;
+    synchronized (methodHandlerCache) {
+      handler = methodHandlerCache.get(method);
+      if (handler == null) {
+        handler =
+            MethodHandler.create(method, client, baseUrl, adapterFactories, converterFactories);
+        methodHandlerCache.put(method, handler);
+      }
+    }
+    return handler;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public BaseUrl baseUrl() {
+    return baseUrl;
+  }
+
+  /**
+   * TODO
+   */
+  public List<Converter.Factory> converterFactories() {
+    return Collections.unmodifiableList(converterFactories);
+  }
+
+  public List<CallAdapter.Factory> callAdapterFactories() {
+    return Collections.unmodifiableList(adapterFactories);
+  }
+
+  public Executor callbackExecutor() {
+    return callbackExecutor;
+  }
+
+  /**
+   * Build a new {@link Retrofit}.
+   * <p>
+   * Calling {@link #baseUrl} is required before calling {@link #build()}. All other methods
+   * are optional.
+   */
+  public static final class Builder {
+    private OkHttpClient client;
+    private BaseUrl baseUrl;
+    private List<Converter.Factory> converterFactories = new ArrayList<>();
+    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
+    private Executor callbackExecutor;
+
+    public Builder() {
+      // Add the built-in converter factory first. This prevents overriding its behavior but also
+      // ensures correct behavior when using converters that consume all types.
+      converterFactories.add(new BuiltInConverterFactory());
+    }
+
+    /** The HTTP client used for requests. */
+    public Builder client(OkHttpClient client) {
+      this.client = checkNotNull(client, "client == null");
+      return this;
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(String baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
+      if (httpUrl == null) {
+        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
+      }
+      return baseUrl(httpUrl);
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(final HttpUrl baseUrl) {
+      checkNotNull(baseUrl, "baseUrl == null");
+      return baseUrl(new BaseUrl() {
+        @Override public HttpUrl url() {
+          return baseUrl;
+        }
+      });
+    }
+
+    /** API base URL. */
+    public Builder baseUrl(BaseUrl baseUrl) {
+      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
+      return this;
+    }
+
+    /** Add converter factory for serialization and deserialization of objects. */
+    public Builder addConverterFactory(Converter.Factory converterFactory) {
+      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
+      return this;
+    }
+
+    /**
+     * TODO
+     */
+    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
+      adapterFactories.add(checkNotNull(factory, "factory == null"));
+      return this;
+    }
+
+    /**
+     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
+     * your service method.
+     */
+    public Builder callbackExecutor(Executor callbackExecutor) {
+      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
+      return this;
+    }
+
+    /** Create the {@link Retrofit} instances. */
+    public Retrofit build() {
+      if (baseUrl == null) {
+        throw new IllegalStateException("Base URL required.");
+      }
+
+      OkHttpClient client = this.client;
+      if (client == null) {
+        client = new OkHttpClient();
+      }
+
+      // Make a defensive copy of the adapters and add the default Call adapter.
+      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
+      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));
+
+      // Make a defensive copy of the converters.
+      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
+
+      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor);
+    }
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
deleted file mode 100644
index f604ac583..000000000
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import retrofit.converter.Converter;
-
-public class RetrofitError extends RuntimeException {
-  public static RetrofitError networkFailure(String url, IOException exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.NETWORK,
-        exception);
-  }
-
-  public static RetrofitError networkError(Response response, IOException exception) {
-    response = response.newBuilder().body(null).build(); // Remove any body.
-    return new RetrofitError(exception.getMessage(), response.request().urlString(), null, null,
-        null, Kind.NETWORK, exception);
-  }
-
-  public static RetrofitError httpError(Response response, Converter converter, Type successType) {
-    String message = response.code() + " " + response.message();
-    return new RetrofitError(message, response.request().urlString(), response, converter,
-        successType, Kind.HTTP, null);
-  }
-
-  public static RetrofitError unexpectedError(Response response, Throwable exception) {
-    response = response.newBuilder().body(null).build(); // Remove any body.
-    return new RetrofitError(exception.getMessage(), response.request().urlString(), response,
-        null, null, Kind.UNEXPECTED, exception);
-  }
-
-  public static RetrofitError unexpectedError(String url, Throwable exception) {
-    return new RetrofitError(exception.getMessage(), url, null, null, null, Kind.UNEXPECTED,
-        exception);
-  }
-
-  /** Identifies the event kind which triggered a {@link RetrofitError}. */
-  public enum Kind {
-    /** An {@link IOException} occurred while communicating to the server. */
-    NETWORK,
-    /** A non-200 HTTP status code was received from the server. */
-    HTTP,
-    /**
-     * An internal error occurred while attempting to execute a request. It is best practice to
-     * re-throw this exception so your application crashes.
-     */
-    UNEXPECTED
-  }
-
-  private final String url;
-  private final Response response;
-  private final Converter converter;
-  private final Type successType;
-  private final Kind kind;
-
-  RetrofitError(String message, String url, Response response, Converter converter,
-      Type successType, Kind kind, Throwable exception) {
-    super(message, exception);
-    this.url = url;
-    this.response = response;
-    this.converter = converter;
-    this.successType = successType;
-    this.kind = kind;
-  }
-
-  /** The request URL which produced the error. */
-  public String getUrl() {
-    return url;
-  }
-
-  /** Response object containing status code, headers, body, etc. */
-  public Response getResponse() {
-    return response;
-  }
-
-  /** The event kind which triggered this error. */
-  public Kind getKind() {
-    return kind;
-  }
-
-  /**
-   * HTTP response body converted to the type declared by either the interface method return type
-   * or the generic type of the supplied {@link Callback} parameter. {@code null} if there is no
-   * response.
-   *
-   * @throws RuntimeException if unable to convert the body to the {@link #getSuccessType() success
-   * type}.
-   */
-  public Object getBody() {
-    return getBodyAs(successType);
-  }
-
-  /**
-   * The type declared by either the interface method return type or the generic type of the
-   * supplied {@link Callback} parameter.
-   */
-  public Type getSuccessType() {
-    return successType;
-  }
-
-  /**
-   * HTTP response body converted to specified {@code type}. {@code null} if there is no response.
-   *
-   * @throws RuntimeException if unable to convert the body to the specified {@code type}.
-   */
-  public Object getBodyAs(Type type) {
-    if (response == null) {
-      return null;
-    }
-    ResponseBody body = response.body();
-    if (body == null) {
-      return null;
-    }
-    try {
-      return converter.fromBody(body, type);
-    } catch (IOException e) {
-      throw new RuntimeException(e); // Body is a Buffer, can't be a real IO exception.
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RxSupport.java b/retrofit/src/main/java/retrofit/RxSupport.java
deleted file mode 100644
index 80295b8c3..000000000
--- a/retrofit/src/main/java/retrofit/RxSupport.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package retrofit;
-
-import rx.Observable;
-import rx.Subscriber;
-
-/**
- * Utilities for supporting RxJava Observables.
- * <p>
- * RxJava might not be on the available to use. Check {@link Platform#HAS_RX_JAVA} before calling.
- */
-final class RxSupport {
-  interface Invoker {
-    void invoke(Callback callback);
-
-    interface Callback {
-      void next(Object o);
-      void error(Throwable t);
-    }
-  }
-
-  RxSupport() {
-  }
-
-  Observable createRequestObservable(final Invoker invoker) {
-    return Observable.create(new Observable.OnSubscribe<Object>() {
-      @Override public void call(final Subscriber<? super Object> subscriber) {
-        invoker.invoke(new Invoker.Callback() {
-          @Override public void next(Object o) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onNext(o);
-              subscriber.onCompleted();
-            }
-          }
-
-          @Override public void error(Throwable t) {
-            if (!subscriber.isUnsubscribed()) {
-              subscriber.onError(t);
-            }
-          }
-        });
-      }
-    });
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Types.java b/retrofit/src/main/java/retrofit/Types.java
deleted file mode 100644
index da28b1197..000000000
--- a/retrofit/src/main/java/retrofit/Types.java
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
-
-/**
- * Static methods for working with types.
- *
- * @author Bob Lee
- * @author Jesse Wilson
- */
-final class Types {
-  private static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
-
-  private Types() {
-    // No instances.
-  }
-
-  public static Class<?> getRawType(Type type) {
-    if (type instanceof Class<?>) {
-      // Type is a normal class.
-      return (Class<?>) type;
-
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-
-      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
-      // suspects some pathological case related to nested classes exists.
-      Type rawType = parameterizedType.getRawType();
-      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
-      return (Class<?>) rawType;
-
-    } else if (type instanceof GenericArrayType) {
-      Type componentType = ((GenericArrayType) type).getGenericComponentType();
-      return Array.newInstance(getRawType(componentType), 0).getClass();
-
-    } else if (type instanceof TypeVariable) {
-      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
-      // type that's more general than necessary is okay.
-      return Object.class;
-
-    } else if (type instanceof WildcardType) {
-      return getRawType(((WildcardType) type).getUpperBounds()[0]);
-
-    } else {
-      String className = type == null ? "null" : type.getClass().getName();
-      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
-          + "GenericArrayType, but <" + type + "> is of type " + className);
-    }
-  }
-
-  /** Returns true if {@code a} and {@code b} are equal. */
-  public static boolean equals(Type a, Type b) {
-    if (a == b) {
-      return true; // Also handles (a == null && b == null).
-
-    } else if (a instanceof Class) {
-      return a.equals(b); // Class already specifies equals().
-
-    } else if (a instanceof ParameterizedType) {
-      if (!(b instanceof ParameterizedType)) return false;
-      ParameterizedType pa = (ParameterizedType) a;
-      ParameterizedType pb = (ParameterizedType) b;
-      return equal(pa.getOwnerType(), pb.getOwnerType())
-          && pa.getRawType().equals(pb.getRawType())
-          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
-
-    } else if (a instanceof GenericArrayType) {
-      if (!(b instanceof GenericArrayType)) return false;
-      GenericArrayType ga = (GenericArrayType) a;
-      GenericArrayType gb = (GenericArrayType) b;
-      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
-
-    } else if (a instanceof WildcardType) {
-      if (!(b instanceof WildcardType)) return false;
-      WildcardType wa = (WildcardType) a;
-      WildcardType wb = (WildcardType) b;
-      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
-          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
-
-    } else if (a instanceof TypeVariable) {
-      if (!(b instanceof TypeVariable)) return false;
-      TypeVariable<?> va = (TypeVariable<?>) a;
-      TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
-          && va.getName().equals(vb.getName());
-
-    } else {
-      return false; // This isn't a type we support!
-    }
-  }
-
-  /**
-   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
-   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
-   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
-   */
-  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
-    if (toResolve == rawType) return context;
-
-    // We skip searching through interfaces if unknown is an interface.
-    if (toResolve.isInterface()) {
-      Class<?>[] interfaces = rawType.getInterfaces();
-      for (int i = 0, length = interfaces.length; i < length; i++) {
-        if (interfaces[i] == toResolve) {
-          return rawType.getGenericInterfaces()[i];
-        } else if (toResolve.isAssignableFrom(interfaces[i])) {
-          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
-        }
-      }
-    }
-
-    // Check our supertypes.
-    if (!rawType.isInterface()) {
-      while (rawType != Object.class) {
-        Class<?> rawSupertype = rawType.getSuperclass();
-        if (rawSupertype == toResolve) {
-          return rawType.getGenericSuperclass();
-        } else if (toResolve.isAssignableFrom(rawSupertype)) {
-          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
-        }
-        rawType = rawSupertype;
-      }
-    }
-
-    // We can't resolve this further.
-    return toResolve;
-  }
-
-  private static int indexOf(Object[] array, Object toFind) {
-    for (int i = 0; i < array.length; i++) {
-      if (toFind.equals(array[i])) return i;
-    }
-    throw new NoSuchElementException();
-  }
-
-  private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  private static int hashCodeOrZero(Object o) {
-    return o != null ? o.hashCode() : 0;
-  }
-
-  public static String typeToString(Type type) {
-    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
-  }
-
-  /**
-   * Returns the generic form of {@code supertype}. For example, if this is {@code
-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
-   * Iterable.class}.
-   *
-   * @param supertype a superclass of, or interface implemented by, this.
-   */
-  public static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
-    if (!supertype.isAssignableFrom(contextRawType)) throw new IllegalArgumentException();
-    return resolve(context, contextRawType,
-        getGenericSupertype(context, contextRawType, supertype));
-  }
-
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    // This implementation is made a little more complicated in an attempt to avoid object-creation.
-    while (true) {
-      if (toResolve instanceof TypeVariable) {
-        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
-        if (toResolve == typeVariable) {
-          return toResolve;
-        }
-
-      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
-        Class<?> original = (Class<?>) toResolve;
-        Type componentType = original.getComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof GenericArrayType) {
-        GenericArrayType original = (GenericArrayType) toResolve;
-        Type componentType = original.getGenericComponentType();
-        Type newComponentType = resolve(context, contextRawType, componentType);
-        return componentType == newComponentType ? original : new GenericArrayTypeImpl(
-            newComponentType);
-
-      } else if (toResolve instanceof ParameterizedType) {
-        ParameterizedType original = (ParameterizedType) toResolve;
-        Type ownerType = original.getOwnerType();
-        Type newOwnerType = resolve(context, contextRawType, ownerType);
-        boolean changed = newOwnerType != ownerType;
-
-        Type[] args = original.getActualTypeArguments();
-        for (int t = 0, length = args.length; t < length; t++) {
-          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);
-          if (resolvedTypeArgument != args[t]) {
-            if (!changed) {
-              args = args.clone();
-              changed = true;
-            }
-            args[t] = resolvedTypeArgument;
-          }
-        }
-
-        return changed
-            ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)
-            : original;
-
-      } else if (toResolve instanceof WildcardType) {
-        WildcardType original = (WildcardType) toResolve;
-        Type[] originalLowerBound = original.getLowerBounds();
-        Type[] originalUpperBound = original.getUpperBounds();
-
-        if (originalLowerBound.length == 1) {
-          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);
-          if (lowerBound != originalLowerBound[0]) {
-            return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { lowerBound });
-          }
-        } else if (originalUpperBound.length == 1) {
-          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);
-          if (upperBound != originalUpperBound[0]) {
-            return new WildcardTypeImpl(new Type[] { upperBound }, EMPTY_TYPE_ARRAY);
-          }
-        }
-        return original;
-
-      } else {
-        return toResolve;
-      }
-    }
-  }
-
-  private static Type resolveTypeVariable(
-      Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
-    Class<?> declaredByRaw = declaringClassOf(unknown);
-
-    // We can't reduce this further.
-    if (declaredByRaw == null) return unknown;
-
-    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);
-    if (declaredBy instanceof ParameterizedType) {
-      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);
-      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];
-    }
-
-    return unknown;
-  }
-
-  /**
-   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
-   * a class.
-   */
-  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
-    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
-    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
-  }
-
-  private static void checkNotPrimitive(Type type) {
-    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private static final class ParameterizedTypeImpl implements ParameterizedType {
-    private final Type ownerType;
-    private final Type rawType;
-    private final Type[] typeArguments;
-
-    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // Require an owner type if the raw type needs it.
-      if (rawType instanceof Class<?>
-          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
-        throw new IllegalArgumentException();
-      }
-
-      this.ownerType = ownerType;
-      this.rawType = rawType;
-      this.typeArguments = typeArguments.clone();
-
-      for (Type typeArgument : this.typeArguments) {
-        if (typeArgument == null) throw new NullPointerException();
-        checkNotPrimitive(typeArgument);
-      }
-    }
-
-    @Override public Type[] getActualTypeArguments() {
-      return typeArguments.clone();
-    }
-
-    @Override public Type getRawType() {
-      return rawType;
-    }
-
-    @Override public Type getOwnerType() {
-      return ownerType;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);
-    }
-
-    @Override public int hashCode() {
-      return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);
-    }
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
-      result.append(typeToString(rawType));
-      if (typeArguments.length == 0) return result.toString();
-      result.append("<").append(typeToString(typeArguments[0]));
-      for (int i = 1; i < typeArguments.length; i++) {
-        result.append(", ").append(typeToString(typeArguments[i]));
-      }
-      return result.append(">").toString();
-    }
-  }
-
-  private static final class GenericArrayTypeImpl implements GenericArrayType {
-    private final Type componentType;
-
-    public GenericArrayTypeImpl(Type componentType) {
-      this.componentType = componentType;
-    }
-
-    @Override public Type getGenericComponentType() {
-      return componentType;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof GenericArrayType
-          && Types.equals(this, (GenericArrayType) o);
-    }
-
-    @Override public int hashCode() {
-      return componentType.hashCode();
-    }
-
-    @Override public String toString() {
-      return typeToString(componentType) + "[]";
-    }
-  }
-
-  /**
-   * The WildcardType interface supports multiple upper bounds and multiple
-   * lower bounds. We only support what the Java 6 language needs - at most one
-   * bound. If a lower bound is set, the upper bound must be Object.class.
-   */
-  private static final class WildcardTypeImpl implements WildcardType {
-    private final Type upperBound;
-    private final Type lowerBound;
-
-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      if (lowerBounds.length > 1) throw new IllegalArgumentException();
-      if (upperBounds.length != 1) throw new IllegalArgumentException();
-
-      if (lowerBounds.length == 1) {
-        if (lowerBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(lowerBounds[0]);
-        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
-        this.lowerBound = lowerBounds[0];
-        this.upperBound = Object.class;
-      } else {
-        if (upperBounds[0] == null) throw new NullPointerException();
-        checkNotPrimitive(upperBounds[0]);
-        this.lowerBound = null;
-        this.upperBound = upperBounds[0];
-      }
-    }
-
-    @Override public Type[] getUpperBounds() {
-      return new Type[] { upperBound };
-    }
-
-    @Override public Type[] getLowerBounds() {
-      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof WildcardType && Types.equals(this, (WildcardType) other);
-    }
-
-    @Override public int hashCode() {
-      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
-      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());
-    }
-
-    @Override public String toString() {
-      if (lowerBound != null) return "? super " + typeToString(lowerBound);
-      if (upperBound == Object.class) return "?";
-      return "? extends " + typeToString(upperBound);
-    }
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index abe79ab44..053b12d0d 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -16,71 +16,242 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+import java.io.Closeable;
 import java.io.IOException;
-import java.util.concurrent.Executor;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.List;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Source;
 
 final class Utils {
-  static <T> T checkNotNull(T object, String message, Object... args) {
+  static <T> T checkNotNull(T object, String message) {
     if (object == null) {
-      throw new NullPointerException(String.format(message, args));
+      throw new NullPointerException(message);
     }
     return object;
   }
 
+  static void closeQuietly(Closeable closeable) {
+    if (closeable == null) return;
+    try {
+      closeable.close();
+    } catch (IOException ignored) {
+    }
+  }
+
+  /** Returns true if {@code annotations} contains an instance of {@code cls}. */
+  static boolean isAnnotationPresent(Annotation[] annotations,
+      Class<? extends Annotation> cls) {
+    for (Annotation annotation : annotations) {
+      if (cls.isInstance(annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static CallAdapter<?> resolveCallAdapter(List<CallAdapter.Factory> adapterFactories, Type type,
+      Annotation[] annotations) {
+    for (int i = 0, count = adapterFactories.size(); i < count; i++) {
+      CallAdapter<?> adapter = adapterFactories.get(i).get(type, annotations);
+      if (adapter != null) {
+        return adapter;
+      }
+    }
+
+    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")
+        .append(type)
+        .append(". Tried:");
+    for (CallAdapter.Factory adapterFactory : adapterFactories) {
+      builder.append("\n * ").append(adapterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  static Converter<?, RequestBody> resolveRequestBodyConverter(
+      List<Converter.Factory> converterFactories, Type type, Annotation[] annotations) {
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<?, RequestBody> converter =
+          converterFactories.get(i).toRequestBody(type, annotations);
+      if (converter != null) {
+        return converter;
+      }
+    }
+
+    StringBuilder builder =
+        new StringBuilder("Could not locate RequestBody converter for ").append(type)
+            .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
+  static Converter<ResponseBody, ?> resolveResponseBodyConverter(
+      List<Converter.Factory> converterFactories, Type type, Annotation[] annotations) {
+    for (int i = 0, count = converterFactories.size(); i < count; i++) {
+      Converter<ResponseBody, ?> converter =
+          converterFactories.get(i).fromResponseBody(type, annotations);
+      if (converter != null) {
+        return converter;
+      }
+    }
+
+    StringBuilder builder =
+        new StringBuilder("Could not locate ResponseBody converter for ").append(type)
+            .append(". Tried:");
+    for (Converter.Factory converterFactory : converterFactories) {
+      builder.append("\n * ").append(converterFactory.getClass().getName());
+    }
+    throw new IllegalArgumentException(builder.toString());
+  }
+
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
    */
-  static Response readBodyToBytesIfNecessary(Response response) throws IOException {
-    final ResponseBody body = response.body();
+  static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException {
     if (body == null) {
-      return response;
+      return null;
     }
 
     BufferedSource source = body.source();
-    final Buffer buffer = new Buffer();
+    Buffer buffer = new Buffer();
     buffer.writeAll(source);
     source.close();
 
-    return response.newBuilder()
-        .body(new ResponseBody() {
-          @Override public MediaType contentType() {
-            return body.contentType();
-          }
-
-          @Override public long contentLength() {
-            return buffer.size();
-          }
-
-          @Override public BufferedSource source() {
-            return buffer.clone();
-          }
-        })
-        .build();
+    return ResponseBody.create(body.contentType(), body.contentLength(), buffer);
   }
 
-  static <T> void validateServiceClass(Class<T> service) {
+  static <T> void validateServiceInterface(Class<T> service) {
     if (!service.isInterface()) {
-      throw new IllegalArgumentException("Only interface endpoint definitions are supported.");
+      throw new IllegalArgumentException("API declarations must be interfaces.");
     }
     // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
     // Android (http://b.android.com/58753) but it forces composition of API declarations which is
     // the recommended pattern.
     if (service.getInterfaces().length > 0) {
-      throw new IllegalArgumentException("Interface definitions must not extend other interfaces.");
+      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
+    }
+  }
+
+  public static Type getSingleParameterUpperBound(ParameterizedType type) {
+    Type[] types = type.getActualTypeArguments();
+    if (types.length != 1) {
+      throw new IllegalArgumentException(
+          "Expected one type argument but got: " + Arrays.toString(types));
     }
+    Type paramType = types[0];
+    if (paramType instanceof WildcardType) {
+      return ((WildcardType) paramType).getUpperBounds()[0];
+    }
+    return paramType;
+  }
+
+  public static boolean hasUnresolvableType(Type type) {
+    if (type instanceof Class<?>) {
+      return false;
+    }
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
+        if (hasUnresolvableType(typeArgument)) {
+          return true;
+        }
+      }
+      return false;
+    }
+    if (type instanceof GenericArrayType) {
+      return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());
+    }
+    if (type instanceof TypeVariable) {
+      return true;
+    }
+    if (type instanceof WildcardType) {
+      return true;
+    }
+    String className = type == null ? "null" : type.getClass().getName();
+    throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+        + "GenericArrayType, but <" + type + "> is of type " + className);
+  }
+
+  // This method is copyright 2008 Google Inc. and is taken from Gson under the Apache 2.0 license.
+  public static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // Type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      if (!(rawType instanceof Class)) throw new IllegalArgumentException();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. Having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
+  static RuntimeException methodError(Method method, String message, Object... args) {
+    return methodError(null, method, message, args);
+  }
+
+  static RuntimeException methodError(Throwable cause, Method method, String message,
+      Object... args) {
+    message = String.format(message, args);
+    IllegalArgumentException e = new IllegalArgumentException(message
+        + "\n    for method "
+        + method.getDeclaringClass().getSimpleName()
+        + "."
+        + method.getName());
+    e.initCause(cause);
+    return e;
+
   }
 
-  static class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable runnable) {
-      runnable.run();
+  static Type getCallResponseType(Type returnType) {
+    if (!(returnType instanceof ParameterizedType)) {
+      throw new IllegalArgumentException(
+          "Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+    final Type responseType = getSingleParameterUpperBound((ParameterizedType) returnType);
+
+    // Ensure the Call response type is not Response, we automatically deliver the Response object.
+    if (getRawType(responseType) == retrofit.Response.class) {
+      throw new IllegalArgumentException(
+          "Call<T> cannot use Response as its generic parameter. "
+              + "Specify the response body type only (e.g., Call<TweetResponse>).");
     }
+    return responseType;
   }
 
   private Utils() {
diff --git a/retrofit/src/main/java/retrofit/VoidConverter.java b/retrofit/src/main/java/retrofit/VoidConverter.java
new file mode 100644
index 000000000..09fa3f229
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/VoidConverter.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+final class VoidConverter implements Converter<ResponseBody, Void> {
+  @Override public Void convert(ResponseBody value) throws IOException {
+    value.close();
+    return null;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/converter/Converter.java
deleted file mode 100644
index 8c93f9934..000000000
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-
-/**
- * Arbiter for converting objects to and from their representation in HTTP.
- */
-public interface Converter {
-  /**
-   * Convert an HTTP response body to a concrete object of the specified type.
-   *
-   * @param body HTTP response body.
-   * @param type Target object type.
-   * @return Instance of {@code type} which will be cast by the caller.
-   */
-  Object fromBody(ResponseBody body, Type type) throws IOException;
-
-  /**
-   * Convert an object to an appropriate representation for HTTP transport.
-   *
-   * @param object Object instance to convert.
-   * @return Representation of the specified object as bytes.
-   */
-  RequestBody toBody(Object object, Type type);
-}
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
deleted file mode 100644
index 7240dc15e..000000000
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.converter;
-
-import com.google.gson.Gson;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Type;
-import java.nio.charset.Charset;
-
-/**
- * A {@link Converter} which uses GSON for serialization and deserialization of entities.
- */
-public class GsonConverter implements Converter {
-  private final Gson gson;
-  private final Charset charset;
-  private final MediaType mediaType;
-
-  /**
-   * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter() {
-    this(new Gson());
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use UTF-8.
-   */
-  public GsonConverter(Gson gson) {
-    this(gson, Charset.forName("UTF-8"));
-  }
-
-  /**
-   * Create an instance using the supplied {@link Gson} object for conversion. Encoding to JSON and
-   * decoding from JSON (when no charset is specified by a header) will use the specified charset.
-   */
-  public GsonConverter(Gson gson, Charset charset) {
-    if (gson == null) throw new NullPointerException("gson == null");
-    if (charset == null) throw new NullPointerException("charset == null");
-    this.gson = gson;
-    this.charset = charset;
-    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
-  }
-
-  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
-    Charset charset = this.charset;
-    if (body.contentType() != null) {
-      charset = body.contentType().charset(charset);
-    }
-
-    InputStream is = body.byteStream();
-    try {
-      return gson.fromJson(new InputStreamReader(is, charset), type);
-    } finally {
-      try {
-        is.close();
-      } catch (IOException ignored) {
-      }
-    }
-  }
-
-  @Override public RequestBody toBody(Object object, Type type) {
-    String json = gson.toJson(object, type);
-    return RequestBody.create(mediaType, json);
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/http/Body.java b/retrofit/src/main/java/retrofit/http/Body.java
index 393a5e14f..782559502 100644
--- a/retrofit/src/main/java/retrofit/http/Body.java
+++ b/retrofit/src/main/java/retrofit/http/Body.java
@@ -18,6 +18,8 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
+import retrofit.Retrofit;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -25,8 +27,8 @@
 /**
  * Use this annotation on a service method param when you want to directly control the request body
  * of a POST/PUT request (instead of sending in as request parameters or form-style request
- * body). The object will be serialized using the {@link retrofit.RestAdapter RestAdapter}'s
- * {@link retrofit.converter.Converter Converter} and the result will be set directly as the
+ * body). The object will be serialized using the {@link Retrofit Retrofit} instance
+ * {@link Converter Converter} and the result will be set directly as the
  * request body.
  * <p>
  * Body parameters may not be {@code null}.
diff --git a/retrofit/src/main/java/retrofit/http/DELETE.java b/retrofit/src/main/java/retrofit/http/DELETE.java
index 6f13b99fe..1f7dbdc5b 100644
--- a/retrofit/src/main/java/retrofit/http/DELETE.java
+++ b/retrofit/src/main/java/retrofit/http/DELETE.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface DELETE {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Field.java b/retrofit/src/main/java/retrofit/http/Field.java
index fce09d9c0..bfe020ec0 100644
--- a/retrofit/src/main/java/retrofit/http/Field.java
+++ b/retrofit/src/main/java/retrofit/http/Field.java
@@ -57,9 +57,6 @@
 public @interface Field {
   String value();
 
-  /** Specifies whether {@link #value()} is URL encoded. */
-  boolean encodeName() default true;
-
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encodeValue() default true;
+  /** Specifies whether the {@linkplain #value() name} and value are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/FieldMap.java b/retrofit/src/main/java/retrofit/http/FieldMap.java
index 09b6f4c0d..97c5684a2 100644
--- a/retrofit/src/main/java/retrofit/http/FieldMap.java
+++ b/retrofit/src/main/java/retrofit/http/FieldMap.java
@@ -44,9 +44,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface FieldMap {
-  /** Specifies whether parameter names (keys in the map) are URL encoded. */
-  boolean encodeNames() default true;
-
-  /** Specifies whether parameter values (values in the map) are URL encoded. */
-  boolean encodeValues() default true;
+  /** Specifies whether the names and values are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/GET.java b/retrofit/src/main/java/retrofit/http/GET.java
index de81a111c..b2dd2a4cf 100644
--- a/retrofit/src/main/java/retrofit/http/GET.java
+++ b/retrofit/src/main/java/retrofit/http/GET.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface GET {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HEAD.java b/retrofit/src/main/java/retrofit/http/HEAD.java
index b73685295..9ae6f7adc 100644
--- a/retrofit/src/main/java/retrofit/http/HEAD.java
+++ b/retrofit/src/main/java/retrofit/http/HEAD.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface HEAD {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/HTTP.java b/retrofit/src/main/java/retrofit/http/HTTP.java
index 759c5939f..f699bbe7d 100644
--- a/retrofit/src/main/java/retrofit/http/HTTP.java
+++ b/retrofit/src/main/java/retrofit/http/HTTP.java
@@ -27,6 +27,6 @@
 @Retention(RUNTIME)
 public @interface HTTP {
   String method();
-  String path();
+  String path() default "";
   boolean hasBody() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/PATCH.java b/retrofit/src/main/java/retrofit/http/PATCH.java
index 83b061978..2788ee8f0 100644
--- a/retrofit/src/main/java/retrofit/http/PATCH.java
+++ b/retrofit/src/main/java/retrofit/http/PATCH.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PATCH {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/POST.java b/retrofit/src/main/java/retrofit/http/POST.java
index b1f7b1088..0d39b2d1a 100644
--- a/retrofit/src/main/java/retrofit/http/POST.java
+++ b/retrofit/src/main/java/retrofit/http/POST.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface POST {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PUT.java b/retrofit/src/main/java/retrofit/http/PUT.java
index 915df56d7..5c382e33d 100644
--- a/retrofit/src/main/java/retrofit/http/PUT.java
+++ b/retrofit/src/main/java/retrofit/http/PUT.java
@@ -27,5 +27,5 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface PUT {
-  String value();
+  String value() default "";
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 573a46d04..0f5913777 100644
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * Values may be {@code null} which will omit them from the request body.
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index 0e9a292f3..a8d788447 100644
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -18,6 +18,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import retrofit.Converter;
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -29,8 +30,8 @@
  * <ul>
  * <li>If the type is {@link String} the value will also be used directly with a {@code text/plain}
  * content type.</li>
- * <li>Other object types will be converted to an appropriate representation by calling {@link
- * retrofit.converter.Converter#toBody(Object, java.lang.reflect.Type)}.</li>
+ * <li>Other object types will be converted to an appropriate representation by using
+ * {@linkplain Converter a converter}.</li>
  * </ul>
  * <p>
  * <pre>
diff --git a/retrofit/src/main/java/retrofit/http/Path.java b/retrofit/src/main/java/retrofit/http/Path.java
index 6a9deecf3..0a3afa4e8 100644
--- a/retrofit/src/main/java/retrofit/http/Path.java
+++ b/retrofit/src/main/java/retrofit/http/Path.java
@@ -52,6 +52,8 @@
 public @interface Path {
   String value();
 
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encode() default true;
+  /**
+   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Query.java b/retrofit/src/main/java/retrofit/http/Query.java
index f4cd0fd46..8e53a9c6a 100644
--- a/retrofit/src/main/java/retrofit/http/Query.java
+++ b/retrofit/src/main/java/retrofit/http/Query.java
@@ -49,23 +49,15 @@
  * void list(@Query("category") String... categories);
  * </pre>
  * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=foo&category=bar}.
+ * {@code /list?category=bar&category=baz}.
  * <p>
- * Parameter names are not URL encoded. Specify {@link #encodeName() encodeName=true} to change
- * this behavior.
+ * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
+ * to change this behavior.
  * <pre>
  * &#64;GET("/search")
- * void list(@Query(value="foo+bar", encodeName=true) String foobar);
+ * void list(@Query(value="foo", encoded=true) String foo);
  * </pre>
- * Calling with {@code foo.list("baz")} yields {@code /search?foo%2Bbar=foo}.
- * <p>
- * Parameter values are URL encoded by default. Specify {@link #encodeValue() encodeValue=false} to
- * change this behavior.
- * <pre>
- * &#64;GET("/search")
- * void list(@Query(value="foo", encodeValue=false) String foo);
- * </pre>
- * Calling with {@code foo.list("foo+foo"))} yields {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
  *
  * @see QueryMap
  */
@@ -76,9 +68,8 @@
   /** The query parameter name. */
   String value();
 
-  /** Specifies whether {@link #value()} is URL encoded. */
-  boolean encodeName() default false;
-
-  /** Specifies whether the argument value to the annotated method parameter is URL encoded. */
-  boolean encodeValue() default true;
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/QueryMap.java b/retrofit/src/main/java/retrofit/http/QueryMap.java
index a6a5e3c28..6aaaab78f 100644
--- a/retrofit/src/main/java/retrofit/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit/http/QueryMap.java
@@ -37,20 +37,11 @@
  * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
  * {@code /search?foo=bar&kit=kat}.
  * <p>
- * Map keys representing the parameter names are not URL encoded. Specify
- * {@link #encodeNames() encodeNames=true} to change this behavior.
+ * Map keys and values representing parameter values are URL encoded by default. Specify
+ * {@link #encoded() encoded=true} to change this behavior.
  * <pre>
  * &#64;GET("/search")
- * void list(@QueryMap(encodeNames=true) Map&lt;String, String&gt; filters);
- * </pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo+bar", "foo+bar"))} yields
- * {@code /search?foo%2Bbar=foo}.
- * <p>
- * Map values representing parameter values are URL encoded by default. Specify
- * {@link #encodeValues() encodeValues=false} to change this behavior.
- * <pre>
- * &#64;GET("/search")
- * void list(@QueryMap(encodeValues=false) Map&lt;String, String&gt; filters);
+ * void list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </pre>
  * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+foo"))} yields
  * {@code /search?foo=foo%2Bbar}.
@@ -61,9 +52,6 @@
 @Target(PARAMETER)
 @Retention(RUNTIME)
 public @interface QueryMap {
-  /** Specifies whether parameter names (keys in the map) are URL encoded. */
-  boolean encodeNames() default false;
-
-  /** Specifies whether parameter values (values in the map) are URL encoded. */
-  boolean encodeValues() default true;
+  /** Specifies whether parameter names and values are already URL encoded. */
+  boolean encoded() default false;
 }
diff --git a/retrofit/src/main/java/retrofit/http/Url.java b/retrofit/src/main/java/retrofit/http/Url.java
new file mode 100644
index 000000000..b953a3060
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/http/Url.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import retrofit.Retrofit;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Relative URL resolved against the {@linkplain Retrofit#baseUrl() base URL}.
+ * <pre>
+ * &#64;GET
+ * void list(@Url String url);
+ * </pre>
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface Url {
+}
diff --git a/retrofit/src/test/java/retrofit/CallTest.java b/retrofit/src/test/java/retrofit/CallTest.java
new file mode 100644
index 000000000..2b4c26156
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/CallTest.java
@@ -0,0 +1,608 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+import retrofit.http.Streaming;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class CallTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/") Call<String> getString();
+    @GET("/") Call<ResponseBody> getBody();
+    @GET("/") @Streaming Call<ResponseBody> getStreamingBody();
+    @POST("/") Call<String> postString(@Body String body);
+  }
+
+  @Test public void http200Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http200Async() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isTrue();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Sync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void http404Async() throws InterruptedException, IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Response<String> response = responseRef.get();
+    assertThat(response.isSuccess()).isFalse();
+    assertThat(response.code()).isEqualTo(404);
+    assertThat(response.errorBody().string()).isEqualTo("Hi");
+  }
+
+  @Test public void transportProblemSync() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void transportProblemAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.getString().enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    Throwable failure = failureRef.get();
+    assertThat(failure).isInstanceOf(IOException.class);
+  }
+
+  @Test public void conversionProblemOutgoingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemOutgoingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+            return new Converter<String, RequestBody>() {
+              @Override public RequestBody convert(String value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void conversionProblemIncomingSync() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.postString("Hi");
+    try {
+      call.execute();
+      fail();
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessage("I am broken!");
+    }
+  }
+
+  @Test public void conversionProblemIncomingMaskedByConverterIsUnwrapped() throws IOException {
+    // MWS has no way to trigger IOExceptions during the response body so use an interceptor.
+    OkHttpClient client = new OkHttpClient();
+    client.interceptors().add(new Interceptor() {
+      @Override public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
+        com.squareup.okhttp.Response response = chain.proceed(chain.request());
+        ResponseBody body = response.body();
+        BufferedSource source = Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public long read(Buffer sink, long byteCount) throws IOException {
+            throw new IOException("cause");
+          }
+        });
+        body = ResponseBody.create(body.contentType(), body.contentLength(), source);
+        return response.newBuilder().body(body).build();
+      }
+    });
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .client(client)
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                try {
+                  return value.string();
+                } catch (IOException e) {
+                  // Some serialization libraries mask transport problems in runtime exceptions. Bad!
+                  throw new RuntimeException("wrapper", e);
+                }
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Call<String> call = example.getString();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("cause");
+    }
+  }
+
+  @Test public void conversionProblemIncomingAsync() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return new Converter<ResponseBody, String>() {
+              @Override public String convert(ResponseBody value) throws IOException {
+                throw new UnsupportedOperationException("I am broken!");
+              }
+            };
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    example.postString("Hi").enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, SECONDS));
+
+    assertThat(failureRef.get()).isInstanceOf(UnsupportedOperationException.class)
+        .hasMessage("I am broken!");
+  }
+
+  @Test public void http204SkipsConverter() throws IOException {
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 204 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(204);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void http205SkipsConverter() throws IOException {
+    final Converter<ResponseBody, String> converter = spy(new Converter<ResponseBody, String>() {
+      @Override public String convert(ResponseBody value) throws IOException {
+        return value.string();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory() {
+          @Override
+          public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+            return converter;
+          }
+        })
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 205 Nothin"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.code()).isEqualTo(205);
+    assertThat(response.body()).isNull();
+    verifyNoMoreInteractions(converter);
+  }
+
+  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+  }
+
+  @Test public void responseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("1234"));
+
+    Response<ResponseBody> response = example.getBody().execute();
+    assertThat(response.body().string()).isEqualTo("1234");
+  }
+
+  @Test public void responseBodyBuffers() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call<ResponseBody> buffered = example.getBody();
+    // When buffering we will detect all socket problems before returning the Response.
+    try {
+      buffered.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void responseBodyStreams() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse()
+        .setBody("1234")
+        .setSocketPolicy(DISCONNECT_DURING_RESPONSE_BODY));
+
+    Response<ResponseBody> response = example.getStreamingBody().execute();
+
+    ResponseBody streamedBody = response.body();
+    // When streaming we only detect socket problems as the ResponseBody is read.
+    try {
+      streamedBody.string();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("unexpected end of stream");
+    }
+  }
+
+  @Test public void rawResponseContentTypeAndLengthButNoSource() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi").addHeader("Content-Type", "text/greeting"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("Hi");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(2);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/greeting");
+    try {
+      rawBody.source();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cannot read raw response body of a converted body.");
+    }
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("").addHeader("Content-Type", "text/stringy"));
+
+    Response<String> response = example.getString().execute();
+    assertThat(response.body()).isEqualTo("");
+    ResponseBody rawBody = response.raw().body();
+    assertThat(rawBody.contentLength()).isEqualTo(0);
+    assertThat(rawBody.contentType().toString()).isEqualTo("text/stringy");
+  }
+
+  @Test public void cancelBeforeExecute() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("Canceled");
+    }
+  }
+
+  @Test public void cancelBeforeEnqueue() throws Exception {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+    Call<String> call = service.getString();
+
+    call.cancel();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+    latch.await();
+    assertThat(failureRef.get()).hasMessage("Canceled");
+  }
+
+  @Test public void cloningExecutedRequestDoesNotCopyState() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+    server.enqueue(new MockResponse().setBody("Hello"));
+
+    Call<String> call = service.getString();
+    assertThat(call.execute().body()).isEqualTo("Hi");
+
+    Call<String> cloned = call.clone();
+    assertThat(cloned.execute().body()).isEqualTo("Hello");
+  }
+
+  @Test public void cancelRequest() throws InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    Call<String> call = service.getString();
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<String>() {
+      @Override public void onResponse(Response<String> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        failureRef.set(t);
+        latch.countDown();
+      }
+    });
+
+    call.cancel();
+
+    assertTrue(latch.await(2, SECONDS));
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("Canceled");
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/EndpointsTest.java b/retrofit/src/test/java/retrofit/EndpointsTest.java
deleted file mode 100644
index 50c41dcf3..000000000
--- a/retrofit/src/test/java/retrofit/EndpointsTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2014 Square, Inc.
-package retrofit;
-
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class EndpointsTest {
-  @Test public void endpoint() {
-    Endpoint endpoint = Endpoint.createFixed("http://example.com");
-    assertThat(endpoint.url()).isEqualTo("http://example.com");
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java b/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
deleted file mode 100644
index 6de8d00f4..000000000
--- a/retrofit/src/test/java/retrofit/ErrorHandlerTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import org.junit.Before;
-import org.junit.Test;
-import retrofit.http.GET;
-import rx.Observable;
-import rx.Observer;
-
-import static com.squareup.okhttp.Protocol.HTTP_1_1;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-
-public class ErrorHandlerTest {
-
-  interface ExampleClient {
-    @GET("/")
-    Response throwsCustomException() throws TestException;
-
-    @GET("/")
-    void onErrorWrappedCustomException(Callback<Response> callback);
-
-    @GET("/")
-    Observable<Response> onErrorCustomException();
-  }
-
-  static class TestException extends Exception {
-  }
-
-  ExampleClient example;
-  ErrorHandler errorHandler;
-
-  @Before public void setup() {
-    errorHandler = mock(ErrorHandler.class);
-
-    OkHttpClient client = new OkHttpClient();
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return new Response.Builder()
-            .code(400)
-            .message("Invalid")
-            .request(chain.request())
-            .protocol(HTTP_1_1)
-            .build();
-      }
-    });
-
-    example = new RestAdapter.Builder() //
-        .setEndpoint("http://example.com")
-        .setClient(client)
-        .setErrorHandler(errorHandler)
-        .setCallbackExecutor(new Utils.SynchronousExecutor())
-        .build()
-        .create(ExampleClient.class);
-  }
-
-  @Test public void customizedExceptionUsed() throws Throwable {
-    TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      example.throwsCustomException();
-      failBecauseExceptionWasNotThrown(TestException.class);
-    } catch (TestException e) {
-      assertThat(e).isSameAs(exception);
-    }
-  }
-
-  @Test public void onErrorWrappedCustomException() throws Throwable {
-    final TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    example.onErrorWrappedCustomException(new Callback<Response>() {
-
-      @Override public void success(Response response, Response response2) {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-
-      @Override public void failure(RetrofitError error) {
-        assertThat(error.getCause()).isSameAs(exception);
-      }
-    });
-  }
-
-  @Test public void onErrorCustomException() throws Throwable {
-    final TestException exception = new TestException();
-    doReturn(exception).when(errorHandler).handleError(any(RetrofitError.class));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.onErrorCustomException().subscribe(new Observer<Response>() {
-      @Override public void onCompleted() {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-
-      @Override public void onError(Throwable e) {
-        assertThat(e).isSameAs(exception);
-        latch.countDown();
-      }
-
-      @Override public void onNext(Response response) {
-        failBecauseExceptionWasNotThrown(TestException.class);
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-  }
-
-  @Test public void returningNullThrowsException() throws Exception {
-    doReturn(null).when(errorHandler).handleError(any(RetrofitError.class));
-
-    try {
-      example.throwsCustomException();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Error handler returned null for wrapped exception.");
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
new file mode 100644
index 000000000..1032cf461
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ExecutorCallAdapterFactoryTest.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.google.common.reflect.TypeToken;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@SuppressWarnings("unchecked")
+public final class ExecutorCallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final Callback<String> callback = mock(Callback.class);
+  private final Executor callbackExecutor = spy(new Executor() {
+    @Override public void execute(Runnable runnable) {
+      runnable.run();
+    }
+  });
+  private final CallAdapter.Factory factory = new ExecutorCallAdapterFactory(callbackExecutor);
+
+  @Test public void rawTypeThrows() {
+    try {
+      factory.get(Call.class, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call return type must be parameterized as Call<Foo> or Call<? extends Foo>");
+    }
+  }
+
+  @Test public void responseThrows() {
+    Type returnType = new TypeToken<Call<Response<String>>>() {}.getType();
+    try {
+      factory.get(returnType, NO_ANNOTATIONS);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Call<T> cannot use Response as its generic parameter. "
+          + "Specify the response body type only (e.g., Call<TweetResponse>).");
+    }
+  }
+
+  @Test public void responseType() {
+    Type classType = new TypeToken<Call<String>>() {}.getType();
+    assertThat(factory.get(classType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    Type wilcardType = new TypeToken<Call<? extends String>>() {}.getType();
+    assertThat(factory.get(wilcardType, NO_ANNOTATIONS).responseType()).isEqualTo(String.class);
+    Type genericType = new TypeToken<Call<List<String>>>() {}.getType();
+    assertThat(factory.get(genericType, NO_ANNOTATIONS).responseType()) //
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+  }
+
+  @Test public void adaptedCallExecute() throws IOException {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    final Response<String> response = Response.success("Hi");
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public Response<String> execute() throws IOException {
+        return response;
+      }
+    });
+    assertThat(call.execute()).isSameAs(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    final Response<String> response = Response.success("Hi");
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.onResponse(response);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verify(callback).onResponse(response);
+  }
+
+  @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    final Throwable throwable = new IOException();
+    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<String> callback) {
+        callback.onFailure(throwable);
+      }
+    });
+    call.enqueue(callback);
+    verify(callbackExecutor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(callbackExecutor);
+    verify(callback).onFailure(throwable);
+    verifyNoMoreInteractions(callback);
+  }
+
+  @Test public void adaptedCallCloneDeepCopy() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    Call<String> cloned = call.clone();
+    assertThat(cloned).isNotSameAs(call);
+    verify(delegate).clone();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  @Test public void adaptedCallCancel() {
+    Type returnType = new TypeToken<Call<String>>() {}.getType();
+    CallAdapter<Call<?>> adapter = (CallAdapter<Call<?>>) factory.get(returnType, NO_ANNOTATIONS);
+    Call<String> delegate = mock(Call.class);
+    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    call.cancel();
+    verify(delegate).cancel();
+    verifyNoMoreInteractions(delegate);
+  }
+
+  static class EmptyCall implements Call<String> {
+    @Override public void enqueue(Callback<String> callback) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Response<String> execute() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public void cancel() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public Call<String> clone() {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/MethodInfoTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
deleted file mode 100644
index cffec1afc..000000000
--- a/retrofit/src/test/java/retrofit/MethodInfoTest.java
+++ /dev/null
@@ -1,220 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.Response;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.POST;
-import retrofit.http.Streaming;
-import rx.Observable;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-@SuppressWarnings("unused") // Lots of unused parameters for example code.
-public class MethodInfoTest {
-  @Test public void pathParameterParsing() throws Exception {
-    expectParams("/");
-    expectParams("/foo");
-    expectParams("/foo/bar");
-    expectParams("/foo/bar/{}");
-    expectParams("/foo/bar/{taco}", "taco");
-    expectParams("/foo/bar/{t}", "t");
-    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
-    expectParams("/foo/bar/{}/{taco}", "taco");
-    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
-    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
-    expectParams("/foo/bar/{taco-shell}", "taco-shell");
-    expectParams("/foo/bar/{taco_shell}", "taco_shell");
-    expectParams("/foo/bar/{sha256}", "sha256");
-    expectParams("/foo/bar/{TACO}", "TACO");
-    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
-    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
-  }
-
-  private static void expectParams(String path, String... expected) {
-    Set<String> calculated = MethodInfo.parsePathParameters(path);
-    assertThat(calculated).hasSize(expected.length);
-    if (expected.length > 0) {
-      assertThat(calculated).containsExactly(expected);
-    }
-  }
-
-  static class Dummy {
-  }
-
-  @Test public void concreteBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body Dummy body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.requestObjectType).isEqualTo(Dummy.class);
-  }
-
-  @Test public void genericBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body List<String> body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
-  }
-
-  @Test public void wildcardBodyType() {
-    class Example {
-      @POST("/foo") Response a(@Body List<? super String> body) {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<? super String>>() {}.getType();
-    assertThat(methodInfo.requestObjectType).isEqualTo(expected);
-  }
-
-  @Test public void concreteCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(ResponseCallback cb) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<Response> cb) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void wildcardGenericCallbackTypes() {
-    class Example {
-      @GET("/foo") void a(Callback<? extends Response> c) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void genericCallbackWithGenericType() {
-    class Example {
-      @GET("/foo") void a(Callback<List<String>> c) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  // RestMethodInfo reconstructs this type from MultimapCallback<String, Set<Long>>. It contains
-  // a little of everything: a parameterized type, a generic array, and a wildcard.
-  private static Map<? extends String, Set<Long>[]> extendingGenericCallbackType;
-
-  @Test public void extendingGenericCallback() throws Exception {
-    class Example {
-      @GET("/foo") void a(MultimapCallback<String, Set<Long>> callback) {
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(
-        MethodInfoTest.class.getDeclaredField("extendingGenericCallbackType").getGenericType());
-  }
-
-  @Test public void synchronousResponse() {
-    class Example {
-      @GET("/foo") Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void synchronousGenericResponse() {
-    class Example {
-      @GET("/foo") List<String> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  @Test public void streamingResponse() {
-    class Example {
-      @GET("/foo") @Streaming Response a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableResponse() {
-    class Example {
-      @GET("/foo") Observable<Response> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    assertThat(methodInfo.responseObjectType).isEqualTo(Response.class);
-  }
-
-  @Test public void observableGenericResponse() {
-    class Example {
-      @GET("/foo") Observable<List<String>> a() {
-        return null;
-      }
-    }
-
-    Method method = TestingUtils.onlyMethod(Example.class);
-    MethodInfo methodInfo = new MethodInfo(method);
-    Type expected = new TypeToken<List<String>>() {}.getType();
-    assertThat(methodInfo.responseObjectType).isEqualTo(expected);
-  }
-
-  private static interface ResponseCallback extends Callback<Response> {
-  }
-
-  private static interface MultimapCallback<K, V> extends Callback<Map<? extends K, V[]>> {
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/MockClient.java b/retrofit/src/test/java/retrofit/MockClient.java
deleted file mode 100644
index 1fea6c0cc..000000000
--- a/retrofit/src/test/java/retrofit/MockClient.java
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2015 Square, Inc.
-package retrofit;
-
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-
-import static com.squareup.okhttp.Protocol.HTTP_1_1;
-
-final class MockClient implements Interceptor {
-  private Deque<Object> events = new ArrayDeque<Object>();
-  private Deque<Request> requests = new ArrayDeque<Request>();
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request request = chain.request();
-    requests.addLast(request);
-
-    Object event = events.removeFirst();
-    if (event instanceof IOException) {
-      throw (IOException) event;
-    }
-    if (event instanceof RuntimeException) {
-      throw (RuntimeException) event;
-    }
-    if (event instanceof Response.Builder) {
-      Response.Builder response = (Response.Builder) event;
-      return response.request(request).protocol(HTTP_1_1).build();
-    }
-    throw new IllegalStateException("Unknown event " + event.getClass());
-  }
-
-  public void enqueueResponse(Response.Builder response) {
-    events.addLast(response);
-  }
-
-  public void enqueueUnexpectedException(RuntimeException exception) {
-    events.addLast(exception);
-  }
-
-  public void enqueueIOException(IOException exception) {
-    events.addLast(exception);
-  }
-
-  public Request takeRequest() {
-    return requests.removeFirst();
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 3585600be..826b27472 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -1,32 +1,32 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.google.gson.Gson;
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import okio.Buffer;
 import org.junit.Ignore;
 import org.junit.Test;
-import retrofit.converter.Converter;
-import retrofit.converter.GsonConverter;
 import retrofit.http.Body;
 import retrofit.http.DELETE;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
+import retrofit.http.FormUrlEncoded;
 import retrofit.http.GET;
 import retrofit.http.HEAD;
 import retrofit.http.HTTP;
 import retrofit.http.Header;
 import retrofit.http.Headers;
+import retrofit.http.Multipart;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -35,20 +35,20 @@
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
-import retrofit.http.Streaming;
-import rx.Observable;
+import retrofit.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
-@SuppressWarnings("UnusedParameters") // Parameters inspected reflectively.
-public class RequestBuilderTest {
-  private RequestInterceptor interceptor;
+@SuppressWarnings({"UnusedParameters", "unused"}) // Parameters inspected reflectively.
+public final class RequestBuilderTest {
+  private static final MediaType TEXT_PLAIN = MediaType.parse("text/plain");
 
-  @Test public void custom1Method() {
+  @Test public void customMethodNoBody() {
     class Example {
       @HTTP(method = "CUSTOM1", path = "/foo")
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -59,11 +59,11 @@ Response method() {
     assertThat(request.body()).isNull();
   }
 
-  @Ignore // TODO https://github.com/square/okhttp/issues/229
-  @Test public void custom2Method() {
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodWithBody() {
     class Example {
       @HTTP(method = "CUSTOM2", path = "/foo", hasBody = true)
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -75,62 +75,30 @@ Response method(@Body RequestBody body) {
     assertBody(request.body(), "hi");
   }
 
-  //@Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-  //  class Example {
-  //    @Multipart //
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-  //  }
-  //}
-  //
-  //@Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @Multipart //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-  //  }
-  //}
-
-  @Test public void invalidPathParam() throws Exception {
+  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
     class Example {
-      @GET("/") //
-      Response method(@Path("hey!") String thing) {
+      @Multipart //
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)");
+          "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
-  @Test public void pathParamNotAllowedInQuery() throws Exception {
+  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
     class Example {
-      @GET("/foo?bar={bar}") //
-      Response method(@Path("bar") String thing) {
+      @FormUrlEncoded //
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -139,85 +107,80 @@ Response method(@Path("bar") String thing) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.");
+          "Only one encoding annotation is allowed.\n    for method Example.method");
     }
   }
 
-  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
+  @Test public void invalidPathParam() throws Exception {
     class Example {
       @GET("/") //
-      Response method(@Body @Query("nope") Object o) {
+      Call<Object> method(@Path("hey!") String thing) {
         return null;
       }
     }
+
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Multiple Retrofit annotations found, only one allowed:"
-              + " @Body, @Query. (parameter #1)");
+          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void twoMethodsFail() {
+  @Test public void pathParamNotAllowedInQuery() throws Exception {
     class Example {
-      @PATCH("/foo") //
-      @POST("/foo") //
-      Response method() {
+      @GET("/foo?bar={bar}") //
+      Call<Object> method(@Path("bar") String thing) {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Only one HTTP method is allowed. Found: PATCH and POST.");
+          "URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.\n    for method Example.method");
     }
   }
 
-  @Test public void pathMustBePrefixedWithSlash() {
+  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {
     class Example {
-      @GET("foo/bar") //
-      Response method() {
+      @GET("/") //
+      Call<Object> method(@Body @Query("nope") String o) {
         return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: URL path \"foo/bar\" must start with '/'.");
+      assertThat(e).hasMessage(
+          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void streamingResponseNotAllowed() {
+  @interface NonNull {}
+
+  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {
     class Example {
-      @GET("/foo") //
-      @Streaming //
-      String method() {
+      @GET("/") //
+      Call<Object> method(@Query("maybe") @NonNull Object o) {
         return null;
       }
     }
-
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
-    }
+    Request request = buildRequest(Example.class, "yep");
+    assertThat(request.urlString()).isEqualTo("http://example.com/?maybe=yep");
   }
 
-  @Test public void streamingResponseWithCallbackNotAllowed() {
+  @Test public void twoMethodsFail() {
     class Example {
-      @GET("/foo") //
-      @Streaming //
-      void method(Callback<String> callback) {
+      @PATCH("/foo") //
+      @POST("/foo") //
+      Call<Object> method() {
+        return null;
       }
     }
 
@@ -226,14 +189,13 @@ void method(Callback<String> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Only methods having Response as data type are allowed to have @Streaming annotation.");
+          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
     }
   }
 
-  @Test public void observableWithCallback() {
+  @Test public void lackingMethod() {
     class Example {
-      @GET("/foo") //
-      Observable<Response> method(Callback<Response> callback) {
+      Call<Object> method() {
         return null;
       }
     }
@@ -242,30 +204,31 @@ void method(Callback<String> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have return type or Callback as last argument, not both.");
+          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
     }
   }
 
-  @Test public void missingCallbackTypes() {
+  @Test public void implicitMultipartForbidden() {
     class Example {
-      @GET("/foo") //
-      void method(@Query("id") String id) {
+      @POST("/") //
+      Call<Object> method(@Part("a") int a) {
+        return null;
       }
     }
-
     try {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have either a return type or Callback as last argument.");
+          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void nonParameterizedCallbackFails() {
+  @Test public void implicitMultipartWithPartMapForbidden() {
     class Example {
-      @GET("/foo") //
-      void method(Callback cb) {
+      @POST("/") //
+      Call<Object> method(@PartMap Map<String, String> params) {
+        return null;
       }
     }
     try {
@@ -273,14 +236,15 @@ void method(Callback cb) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Last parameter must be of type Callback<X> or Callback<? super X>.");
+          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void synchronousWithAsyncCallback() {
+  @Test public void multipartFailsOnNonBodyMethod() {
     class Example {
-      @GET("/foo") //
-      Response method(Callback<Response> callback) {
+      @Multipart //
+      @GET("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -289,13 +253,15 @@ Response method(Callback<Response> callback) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Must have return type or Callback as last argument, not both.");
+          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
-  @Test public void lackingMethod() {
+  @Test public void multipartFailsWithNoParts() {
     class Example {
-      Response method() {
+      @Multipart //
+      @POST("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -304,14 +270,14 @@ Response method() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+          "Multipart method must contain at least one @Part.\n    for method Example.method");
     }
   }
 
-  @Test public void implicitMultipartForbidden() {
+  @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
       @POST("/") //
-      Response method(@Part("a") int a) {
+      Call<Object> method(@Field("a") int a) {
         return null;
       }
     }
@@ -320,14 +286,14 @@ Response method(@Part("a") int a) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Part parameters can only be used with multipart encoding. (parameter #1)");
+          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
     }
   }
 
-  @Test public void implicitMultipartWithPartMapForbidden() {
+  @Test public void implicitFormEncodingByFieldMapForbidden() {
     class Example {
       @POST("/") //
-      Response method(@PartMap Map<String, String> params) {
+      Call<Object> method(@FieldMap Map<String, String> a) {
         return null;
       }
     }
@@ -336,47 +302,15 @@ Response method(@PartMap Map<String, String> params) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
-    }
-  }
-
-  //@Test public void multipartFailsOnNonBodyMethod() {
-  //  class Example {
-  //    @Multipart //
-  //    @GET("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-  //  }
-  //}
-  //
-  //@Test public void multipartFailsWithNoParts() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
-  //  }
-  //}
+          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+    }
+  }
 
-  @Test public void implicitFormEncodingByFieldForbidden() {
+  @Test public void formEncodingFailsOnNonBodyMethod() {
     class Example {
-      @POST("/") //
-      Response method(@Field("a") int a) {
+      @FormUrlEncoded //
+      @GET("/") //
+      Call<Object> method() {
         return null;
       }
     }
@@ -385,14 +319,15 @@ Response method(@Field("a") int a) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Field parameters can only be used with form encoding. (parameter #1)");
+          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
     }
   }
 
-  @Test public void implicitFormEncodingByFieldMapForbidden() {
+  @Test public void formEncodingFailsWithNoParts() {
     class Example {
+      @FormUrlEncoded //
       @POST("/") //
-      Response method(@FieldMap Map<String, String> a) {
+      Call<Object> method() {
         return null;
       }
     }
@@ -400,49 +335,15 @@ Response method(@FieldMap Map<String, String> a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: @FieldMap parameters can only be used with form encoding. (parameter #1)");
-    }
-  }
-
-  //@Test public void formEncodingFailsOnNonBodyMethod() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @GET("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
-  //  }
-  //}
-  //
-  //@Test public void formEncodingFailsWithNoParts() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method() {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
-  //  }
-  //}
+      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+    }
+  }
 
   @Test public void headersFailWhenEmptyOnMethod() {
     class Example {
       @GET("/") //
       @Headers({}) //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -450,7 +351,7 @@ Response method() {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @Headers annotation is empty.");
+      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
     }
   }
 
@@ -458,7 +359,7 @@ Response method() {
     class Example {
       @GET("/") //
       @Headers("Malformed") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -467,14 +368,14 @@ Response method() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
+          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
     }
   }
 
   @Test public void pathParamNonPathParamAndTypedBytes() {
     class Example {
       @PUT("/{a}") //
-      Response method(@Path("a") int a, @Path("b") int b, @Body int c) {
+      Call<Object> method(@Path("a") int a, @Path("b") int b, @Body int c) {
         return null;
       }
     }
@@ -482,14 +383,15 @@ Response method(@Path("a") int a, @Path("b") int b, @Body int c) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
+      assertThat(e).hasMessage(
+          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
     }
   }
 
   @Test public void parameterWithoutAnnotation() {
     class Example {
       @GET("/") //
-      Response method(String a) {
+      Call<Object> method(String a) {
         return null;
       }
     }
@@ -497,14 +399,15 @@ Response method(String a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: No Retrofit annotation found. (parameter #1)");
+      assertThat(e).hasMessage(
+          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
     }
   }
 
   @Test public void nonBodyHttpMethodWithSingleEntity() {
     class Example {
       @GET("/") //
-      Response method(@Body Object o) {
+      Call<Object> method(@Body String o) {
         return null;
       }
     }
@@ -513,14 +416,14 @@ Response method(@Body Object o) {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Non-body HTTP method cannot contain @Body or @TypedOutput.");
+          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
     }
   }
 
   @Test public void queryMapMustBeAMap() {
     class Example {
       @GET("/") //
-      Response method(@QueryMap List<String> a) {
+      Call<Object> method(@QueryMap List<String> a) {
         return null;
       }
     }
@@ -528,19 +431,20 @@ Response method(@QueryMap List<String> a) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @QueryMap parameter type must be Map. (parameter #1)");
+      assertThat(e).hasMessage(
+          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
     }
   }
 
   @Test public void queryMapRejectsNullKeys() {
     class Example {
       @GET("/") //
-      Response method(@QueryMap Map<String, String> a) {
+      Call<Object> method(@QueryMap Map<String, String> a) {
         return null;
       }
     }
 
-    Map<String, String> queryParams = new LinkedHashMap<String, String>();
+    Map<String, String> queryParams = new LinkedHashMap<>();
     queryParams.put("ping", "pong");
     queryParams.put(null, "kat");
 
@@ -548,14 +452,31 @@ Response method(@QueryMap Map<String, String> a) {
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 query map contained null key.");
+      assertThat(e).hasMessage("Query map contained null key.");
     }
   }
 
   @Test public void twoBodies() {
     class Example {
       @PUT("/") //
-      Response method(@Body int o1, @Body int o2) {
+      Call<Object> method(@Body String o1, @Body String o2) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Multiple @Body method annotations found. (parameter #2)\n    for method Example.method");
+    }
+  }
+
+  @Test public void bodyInNonBodyRequest() {
+    class Example {
+      @Multipart //
+      @PUT("/") //
+      Call<Object> method(@Part("one") String o1, @Body String o2) {
         return null;
       }
     }
@@ -563,31 +484,15 @@ Response method(@Body int o1, @Body int o2) {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Multiple @Body method annotations found.");
-    }
-  }
-
-  //@Test public void bodyInNonBodyRequest() {
-  //  class Example {
-  //    @Multipart //
-  //    @PUT("/") //
-  //    Response method(@Part("one") int o1, @Body int o2) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage(
-  //        "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
-  //  }
-  //}
+      assertThat(e).hasMessage(
+          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+    }
+  }
 
   @Test public void get() {
     class Example {
       @GET("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -601,7 +506,7 @@ Response method() {
   @Test public void delete() {
     class Example {
       @DELETE("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -609,13 +514,13 @@ Response method() {
     assertThat(request.method()).isEqualTo("DELETE");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "");
+    assertNull(request.body());
   }
 
   @Test public void head() {
     class Example {
       @HEAD("/foo/bar/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -629,7 +534,7 @@ Response method() {
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -644,7 +549,7 @@ Response method(@Body RequestBody body) {
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -659,7 +564,7 @@ Response method(@Body RequestBody body) {
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -674,7 +579,7 @@ Response method(@Body RequestBody body) {
   @Test public void getWithPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -685,159 +590,38 @@ Response method(@Path("ping") String ping) {
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method(@Path(value = "ping", encode = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "po%20ng");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("ping", "po ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorEncodedPathParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addEncodedPathParam("ping", "po%20ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParam() {
+  @Test public void getWithUnusedAndInvalidNamedPathParam() {
     class Example {
-      @GET("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping) {
+      @GET("/foo/bar/{ping}/{kit,kat}/") //
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("kit", "kat");
-      }
-    };
     Request request = buildRequest(Example.class, "pong");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addQueryParam("ping", "po ng");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=po+ng");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/{kit}/") //
-      Response method(@Path("kit") String kit) {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addQueryParam("ping", "pong");
-      }
-    };
-    Request request = buildRequest(Example.class, "kat");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/kat/?ping=pong");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/%7Bkit,kat%7D/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithInterceptorPathParamAndInterceptorQueryParam() {
+  @Test public void getWithEncodedPathParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method() {
-        return null;
-      }
-    }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("ping", "pong");
-        request.addQueryParam("butter", "finger");
-      }
-    };
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/?butter=finger");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithPathParamAndInterceptorPathParamAndInterceptorQueryParam() {
-    class Example {
-      @GET("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path(value = "ping", encoded = true) String ping) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addPathParam("kit", "kat");
-        request.addQueryParam("butter", "finger");
-      }
-    };
-    Request request = buildRequest(Example.class, "pong");
+    Request request = buildRequest(Example.class, "po%20ng");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/?butter=finger");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/po%20ng/");
     assertThat(request.body()).isNull();
   }
 
   @Test public void pathParamRequired() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      Call<Object> method(@Path("ping") String ping) {
         return null;
       }
     }
@@ -852,7 +636,7 @@ Response method(@Path("ping") String ping) {
   @Test public void getWithQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -866,49 +650,21 @@ Response method(@Query("ping") String ping) {
   @Test public void getWithEncodedQueryParam() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query(value = "ping", encodeValue = false) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p+o+n+g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?ping=p+o+n+g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodeNameQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method(@Query(value = "pi ng", encodeName = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodeNameEncodedValueQueryParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Response method(@Query(value = "pi ng", encodeName = true, encodeValue = false) String ping) {
+      Call<Object> method(@Query(value = "pi%20ng", encoded = true) String ping) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "po+ng");
+    Request request = buildRequest(Example.class, "p%20o%20n%20g");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi+ng=po+ng");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g");
     assertThat(request.body()).isNull();
   }
 
   @Test public void queryParamOptionalOmitsQuery() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -919,7 +675,7 @@ Response method(@Query("ping") String ping) {
   @Test public void queryParamOptional() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("foo") String foo, @Query("ping") String ping,
+      Call<Object> method(@Query("foo") String foo, @Query("ping") String ping,
           @Query("kit") String kit) {
         return null;
       }
@@ -931,7 +687,7 @@ Response method(@Query("foo") String foo, @Query("ping") String ping,
   @Test public void getWithQueryUrlAndParam() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Response method(@Query("ping") String ping) {
+      Call<Object> method(@Query("ping") String ping) {
         return null;
       }
     }
@@ -945,7 +701,7 @@ Response method(@Query("ping") String ping) {
   @Test public void getWithQuery() {
     class Example {
       @GET("/foo/bar/?hi=mom") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
@@ -959,7 +715,7 @@ Response method() {
   @Test public void getWithPathAndQueryParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit,
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit,
           @Query("riff") String riff) {
         return null;
       }
@@ -972,10 +728,27 @@ Response method(@Path("ping") String ping, @Query("kit") String kit,
     assertThat(request.body()).isNull();
   }
 
+  @Test public void getWithQueryThenPathThrows() {
+    class Example {
+      @GET("/foo/bar/{ping}/") //
+      Call<Object> method(@Query("kit") String kit, @Path("ping") String ping) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "kat", "pong");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Path parameter must not come after a @Query. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
   @Test public void getWithPathAndQueryQuestionMarkParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -983,14 +756,14 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
     Request request = buildRequest(Example.class, "pong?", "kat?");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat%3F");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong%3F/?kit=kat?");
     assertThat(request.body()).isNull();
   }
 
   @Test public void getWithPathAndQueryAmpersandParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -1005,7 +778,7 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
   @Test public void getWithPathAndQueryHashParam() {
     class Example {
       @GET("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping, @Query("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Query("kit") String kit) {
         return null;
       }
     }
@@ -1020,7 +793,7 @@ Response method(@Path("ping") String ping, @Query("kit") String kit) {
   @Test public void getWithQueryParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") List<Object> keys) {
+      Call<Object> method(@Query("key") List<Object> keys) {
         return null;
       }
     }
@@ -1036,7 +809,7 @@ Response method(@Query("key") List<Object> keys) {
   @Test public void getWithQueryParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") Object[] keys) {
+      Call<Object> method(@Query("key") Object[] keys) {
         return null;
       }
     }
@@ -1052,7 +825,7 @@ Response method(@Query("key") Object[] keys) {
   @Test public void getWithQueryParamPrimitiveArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Query("key") int[] keys) {
+      Call<Object> method(@Query("key") int[] keys) {
         return null;
       }
     }
@@ -1068,12 +841,12 @@ Response method(@Query("key") int[] keys) {
   @Test public void getWithQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@QueryMap Map<String, Object> query) {
+      Call<Object> method(@QueryMap Map<String, Object> query) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "kat");
     params.put("foo", null);
     params.put("ping", "pong");
@@ -1088,590 +861,680 @@ Response method(@QueryMap Map<String, Object> query) {
   @Test public void getWithEncodedQueryParamMap() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@QueryMap(encodeValues = false) Map<String, Object> query) {
+      Call<Object> method(@QueryMap(encoded = true) Map<String, Object> query) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
+    Map<String, Object> params = new LinkedHashMap<>();
     params.put("kit", "k%20t");
     params.put("foo", null);
-    params.put("ping", "p%20g");
+    params.put("pi%20ng", "p%20g");
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&ping=p%20g");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodeNameQueryParamMap() {
+  @Test public void getWithUrl() {
     class Example {
-      @GET("/foo/bar/") //
-      Response method(@QueryMap(encodeNames = true) Map<String, Object> query) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("k it", "k t");
-    params.put("fo o", null);
-    params.put("pi ng", "p g");
-
-    Request request = buildRequest(Example.class, params);
+    Request request = buildRequest(Example.class, "foo/bar/");
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k+t&pi+ng=p+g");
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void getWithEncodeNameEncodedValueQueryParamMap() {
+  @Test public void getAbsoluteUrl() {
     class Example {
-      @GET("/foo/bar/") //
-      Response method(
-          @QueryMap(encodeNames = true, encodeValues = false) Map<String, Object> query) {
+      @GET("http://example2.com/foo/bar/")
+      Call<Object> method() {
         return null;
       }
     }
 
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("k it", "k%20t");
-    params.put("fo o", null);
-    params.put("pi ng", "p%20g");
-
-    Request request = buildRequest(Example.class, params);
+    Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?k+it=k%20t&pi+ng=p%20g");
+    assertThat(request.urlString()).isEqualTo("http://example2.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
 
-  @Test public void normalPostWithPathParam() {
+  @Test public void getWithUrlAbsolute() {
     class Example {
-      @POST("/foo/bar/{ping}/") //
-      Response method(@Path("ping") String ping) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("POST");
+
+    Request request = buildRequest(Example.class, "https://example2.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
-    assertBody(request.body(), "");
+    assertThat(request.urlString()).isEqualTo("https://example2.com/foo/bar/");
+    assertThat(request.body()).isNull();
   }
 
-  @Test public void bodyGson() {
+  @Test public void getWithUrlAbsoluteSameHost() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body Object body) {
+      @GET
+      Call<Object> method(@Url String url) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, Arrays.asList("quick", "brown", "fox"));
-    assertThat(request.method()).isEqualTo("POST");
+
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar/");
+    assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
+    assertThat(request.body()).isNull();
   }
 
-  @Test public void bodyTypedInput() {
+  @Test public void getWithNonStringUrlThrows() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      @GET
+      Call<Object> method(@Url Object url) {
         return null;
       }
     }
-    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
-    Request request = buildRequest(Example.class, body);
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertBody(request.body(), "hi");
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+          + "    for method Example.method");
+    }
   }
 
-  @Test public void bodyRequired() {
+  @Test public void getUrlAndUrlParamThrows() {
     class Example {
-      @POST("/foo/bar/") //
-      Response method(@Body RequestBody body) {
+      @GET("foo/bar")
+      Call<Object> method(@Url Object url) {
         return null;
       }
     }
+
     try {
-      buildRequest(Example.class, new Object[] { null });
+      buildRequest(Example.class, "foo/bar");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+      assertThat(e).hasMessage("@Url must be String type. (parameter #1)\n"
+          + "    for method Example.method");
     }
   }
 
-  @Test public void bodyWithPathParams() {
+  @Test public void getWithoutUrlThrows() {
     class Example {
-      @POST("/foo/bar/{ping}/{kit}/") //
-      Response method(@Path("ping") String ping, @Body Object body, @Path("kit") String kit) {
+      @GET
+      Call<Object> method() {
         return null;
       }
     }
-    Request request =
-        buildRequest(Example.class, "pong", Arrays.asList("quick", "brown", "fox"), "kat");
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
-    assertBody(request.body(), "[\"quick\",\"brown\",\"fox\"]");
-  }
-  //
-  //@Test public void simpleMultipart() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") String ping, @Part("kit") TypedInput kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartWithEncoding() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part(value = "ping", encoding = "8-bit") String ping,
-  //        @Part(value = "kit", encoding = "7-bit") TypedInput kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Request request = buildRequest(Example.class, "pong", new TypedString("kat"));
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"")
-  //      .contains("Content-Transfer-Encoding: 7-bit")
-  //      .endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMap() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put("kit", new TypedString("kat"));
-  //
-  //  Request request = buildRequest(Example.class, params);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n").endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"").endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMapWithEncoding() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put("kit", new TypedString("kat"));
-  //
-  //  Request request = buildRequest(Example.class, params);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(2);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"\r\n")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\npong");
-  //
-  //  String two = new String(iterator.next(), UTF_8);
-  //  assertThat(two).contains("name=\"kit\"")
-  //      .contains("Content-Transfer-Encoding: 8-bit")
-  //      .endsWith("\r\nkat");
-  //}
-  //
-  //@Test public void multipartPartMapRejectsNullKeys() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@PartMap Map<String, Object> parts) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
-  //  params.put("ping", "pong");
-  //  params.put(null, "kat");
-  //
-  //  try {
-  //    buildRequest(Example.class, params);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Parameter #1 part map contained null key.");
-  //  }
-  //}
-  //
-  //@Test public void multipartNullRemovesPart() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") String ping, @Part("fizz") String fizz) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "pong", null);
-  //  assertThat(request.method()).isEqualTo("POST");
-  //  assertThat(request.headers().size()).isZero();
-  //  assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-  //
-  //  MultipartTypedOutput body = (MultipartTypedOutput) request.body();
-  //  List<byte[]> bodyParts = MimeHelper.getParts(body);
-  //  assertThat(bodyParts).hasSize(1);
-  //
-  //  Iterator<byte[]> iterator = bodyParts.iterator();
-  //
-  //  String one = new String(iterator.next(), UTF_8);
-  //  assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
-  //}
-  //
-  //@Test public void multipartPartOptional() {
-  //  class Example {
-  //    @Multipart //
-  //    @POST("/foo/bar/") //
-  //    Response method(@Part("ping") RequestBody ping) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class, new Object[] { null });
-  //    fail();
-  //  } catch (IllegalStateException e) {
-  //    assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-  //  }
-  //}
-  //
-  //@Test public void simpleFormEncoded() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") String foo, @Field("ping") String ping) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "bar", "pong");
-  //  assertBody(request.body(), "foo=bar&ping=pong");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedNameFieldParam() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field(value = "na+me", encodeName = false) String foo) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "ba r");
-  //  assertBody(request.body(), "na+me=ba+r");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedValueFieldParam() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field(value = "na me", encodeValue = false) String foo) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "ba+r");
-  //  assertBody(request.body(), "na+me=ba+r");
-  //}
-  //
-  //@Test public void formEncodedFieldOptional() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") String foo, @Field("ping") String ping,
-  //        @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //  Request request = buildRequest(Example.class, "bar", null, "kat");
-  //  assertBody(request.body(), "foo=bar&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldList() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldArray() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Object[] values = { 1, 2, null, "three" };
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedFieldPrimitiveArray() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  int[] values = { 1, 2, 3 };
-  //  Request request = buildRequest(Example.class, values, "kat");
-  //  assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedNameFieldParamMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("k+it", "k at");
-  //  fieldMap.put("pin+g", "po ng");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  //}
-  //
-  //@Test public void formEncodedWithEncodedValueFieldParamMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("k it", "k+at");
-  //  fieldMap.put("pin g", "po+ng");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  //}
-  //
-  //@Test public void formEncodedFieldMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/foo") //
-  //    Response method(@FieldMap Map<String, Object> fieldMap) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("kit", "kat");
-  //  fieldMap.put("foo", null);
-  //  fieldMap.put("ping", "pong");
-  //
-  //  Request request = buildRequest(Example.class, fieldMap);
-  //  assertBody(request.body(), "kit=kat&ping=pong");
-  //}
-  //
-  //@Test public void fieldMapRejectsNullKeys() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method(@FieldMap Map<String, Object> a) {
-  //      return null;
-  //    }
-  //  }
-  //
-  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-  //  fieldMap.put("kit", "kat");
-  //  fieldMap.put("foo", null);
-  //  fieldMap.put(null, "pong");
-  //
-  //  try {
-  //    buildRequest(Example.class, fieldMap);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Parameter #1 field map contained null key.");
-  //  }
-  //}
-  //
-  //@Test public void fieldMapMustBeAMap() {
-  //  class Example {
-  //    @FormUrlEncoded //
-  //    @POST("/") //
-  //    Response method(@FieldMap List<String> a) {
-  //      return null;
-  //    }
-  //  }
-  //  try {
-  //    buildRequest(Example.class);
-  //    fail();
-  //  } catch (IllegalArgumentException e) {
-  //    assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
-  //  }
-  //}
 
-  @Test public void simpleHeaders() {
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Missing either @GET URL or @Url parameter.\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenPathThrows() {
     class Example {
-      @GET("/foo/bar/")
-      @Headers({
-          "ping: pong",
-          "kit: kat"
-      })
-      Response method() {
+      @GET
+      Call<Object> method(@Url String url, @Path("hey") String hey) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class);
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path parameters may not be used with @Url. (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithPathThenUrlThrows() {
+    class Example {
+      @GET
+      Call<Object> method(@Path("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("@Path can only be used with relative url on @GET (parameter #1)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithQueryThenUrlThrows() {
+    class Example {
+      @GET("foo/bar")
+      Call<Object> method(@Query("hey") String hey, @Url Object url) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, "hey", "foo/bar/");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("A @Url parameter must not come after a @Query (parameter #2)\n"
+          + "    for method Example.method");
+    }
+  }
+
+  @Test public void getWithUrlThenQuery() {
+    class Example {
+      @GET
+      Call<Object> method(@Url String url, @Query("hey") String hey) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "foo/bar/", "hey!");
     assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/?hey=hey!");
   }
 
-  @Test public void simpleInterceptorHeaders() {
+  @Test public void postWithUrl() {
     class Example {
-      @GET("/foo/bar/")
-      Response method() {
+      @POST
+      Call<Object> method(@Url String url, @Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, "http://example.com/foo/bar", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void normalPostWithPathParam() {
+    class Example {
+      @POST("/foo/bar/{ping}/") //
+      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("ping", "pong");
-        request.addHeader("kit", "kat");
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void emptyBody() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method() {
+        return null;
       }
-    };
+    }
     Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertBody(request.body(), "");
   }
 
-  @Test public void headersAndInterceptorHeaders() {
+  @Ignore("https://github.com/square/okhttp/issues/229")
+  @Test public void customMethodEmptyBody() {
     class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Response method() {
+      @HTTP(method = "CUSTOM", path = "/foo/bar/", hasBody = true) //
+      Call<Object> method() {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("kit", "kat");
-      }
-    };
     Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("kit")).isEqualTo("kat");
+    assertThat(request.method()).isEqualTo("CUSTOM");
+    assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
+    assertBody(request.body(), "");
   }
 
-  @Test public void allThreeHeaderTypes() {
+  @Test public void bodyResponseBody() {
     class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Response method(@Header("fizz") String fizz) {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
+        return null;
+      }
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "hi");
+    Request request = buildRequest(Example.class, body);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+    assertBody(request.body(), "hi");
+  }
+
+  @Test public void bodyRequired() {
+    class Example {
+      @POST("/foo/bar/") //
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("kit", "kat");
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
+    }
+  }
+
+  @Test public void bodyWithPathParams() {
+    class Example {
+      @POST("/foo/bar/{ping}/{kit}/") //
+      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+        return null;
       }
-    };
-    Request request = buildRequest(Example.class, "buzz");
+    }
+    RequestBody body = RequestBody.create(TEXT_PLAIN, "Hi!");
+    Request request = buildRequest(Example.class, "pong", body, "kat");
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/pong/kat/");
+    assertBody(request.body(), "Hi!");
+  }
+
+  @Test public void simpleMultipart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
+          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+        return null;
+      }
+    }
+
+    Request request = buildRequest(Example.class, "pong", RequestBody.create(
+        MediaType.parse("text/plain"), "kat"));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 7-bit")
+        .contains("\r\nkat\r\n--");
+  }
+
+  @Test public void multipartPartMap() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("foo", null); // Should be skipped.
+    params.put("kit", "kat");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"\r\n")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString)
+        .contains("name=\"kit\"")
+        .contains("\r\nkat\r\n--");
+
+    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+  }
+
+  @Test public void multipartPartMapWithEncoding() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap(encoding = "8-bit") Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put("foo", null); // Should be skipped.
+    params.put("kit", "kat");
+
+    Request request = buildRequest(Example.class, params);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString).contains("name=\"ping\"\r\n")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\npong\r\n--");
+
+    assertThat(bodyString).contains("name=\"kit\"")
+        .contains("Content-Transfer-Encoding: 8-bit")
+        .contains("\r\nkat\r\n--");
+
+    assertThat(bodyString).doesNotContain("name=\"foo\"\r\n");
+  }
+
+  @Test public void multipartPartMapRejectsNullKeys() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap Map<String, Object> parts) {
+        return null;
+      }
+    }
+
+    Map<String, Object> params = new LinkedHashMap<>();
+    params.put("ping", "pong");
+    params.put(null, "kat");
+
+    try {
+      buildRequest(Example.class, params);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Part map contained null key.");
+    }
+  }
+
+  @Test public void multipartPartMapMustBeMap() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@PartMap List<Object> parts) {
+        return null;
+      }
+    }
+
+    try {
+      buildRequest(Example.class, Collections.emptyList());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@PartMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void multipartNullRemovesPart() throws IOException {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") String ping, @Part("fizz") String fizz) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "pong", null);
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.headers().size()).isZero();
+    assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
+
+    RequestBody body = request.body();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    String bodyString = buffer.readUtf8();
+
+    assertThat(bodyString)
+        .contains("name=\"ping\"")
+        .contains("\r\npong\r\n--");
+  }
+
+  @Test public void multipartPartOptional() {
+    class Example {
+      @Multipart //
+      @POST("/foo/bar/") //
+      Call<Object> method(@Part("ping") RequestBody ping) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class, new Object[] { null });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
+    }
+  }
+
+  @Test public void simpleFormEncoded() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", "pong");
+    assertBody(request.body(), "foo=bar&ping=pong");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParam() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field(value = "na%20me", encoded = true) String foo) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "ba%20r");
+    assertBody(request.body(), "na%20me=ba%20r");
+  }
+
+  @Test public void formEncodedFieldOptional() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") String foo, @Field("ping") String ping,
+          @Field("kit") String kit) {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class, "bar", null, "kat");
+    assertBody(request.body(), "foo=bar&kit=kat");
+  }
+
+  @Test public void formEncodedFieldList() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedFieldArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    Object[] values = { 1, 2, null, "three" };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  }
+
+  @Test public void formEncodedFieldPrimitiveArray() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@Field("foo") int[] fields, @Field("kit") String kit) {
+        return null;
+      }
+    }
+
+    int[] values = { 1, 2, 3 };
+    Request request = buildRequest(Example.class, values, "kat");
+    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  }
+
+  @Test public void formEncodedWithEncodedNameFieldParamMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("k%20it", "k%20at");
+    fieldMap.put("pin%20g", "po%20ng");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "k%20it=k%20at&pin%20g=po%20ng");
+  }
+
+  @Test public void formEncodedFieldMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/foo") //
+      Call<Object> method(@FieldMap Map<String, Object> fieldMap) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put("ping", "pong");
+
+    Request request = buildRequest(Example.class, fieldMap);
+    assertBody(request.body(), "kit=kat&ping=pong");
+  }
+
+  @Test public void fieldMapRejectsNullKeys() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap Map<String, Object> a) {
+        return null;
+      }
+    }
+
+    Map<String, Object> fieldMap = new LinkedHashMap<>();
+    fieldMap.put("kit", "kat");
+    fieldMap.put("foo", null);
+    fieldMap.put(null, "pong");
+
+    try {
+      buildRequest(Example.class, fieldMap);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Field map contained null key.");
+    }
+  }
+
+  @Test public void fieldMapMustBeAMap() {
+    class Example {
+      @FormUrlEncoded //
+      @POST("/") //
+      Call<Object> method(@FieldMap List<String> a) {
+        return null;
+      }
+    }
+    try {
+      buildRequest(Example.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+    }
+  }
+
+  @Test public void simpleHeaders() {
+    class Example {
+      @GET("/foo/bar/")
+      @Headers({
+          "ping: pong",
+          "kit: kat"
+      })
+      Call<Object> method() {
+        return null;
+      }
+    }
+    Request request = buildRequest(Example.class);
     assertThat(request.method()).isEqualTo("GET");
     com.squareup.okhttp.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(3);
+    assertThat(headers.size()).isEqualTo(2);
     assertThat(headers.get("ping")).isEqualTo("pong");
     assertThat(headers.get("kit")).isEqualTo("kat");
-    assertThat(headers.get("fizz")).isEqualTo("buzz");
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
     assertThat(request.body()).isNull();
   }
@@ -1679,7 +1542,7 @@ Response method(@Header("fizz") String fizz) {
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("kit") BigInteger kit) {
+      Call<Object> method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1696,7 +1559,7 @@ Response method(@Header("kit") BigInteger kit) {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@Header("kit") String kit) {
+      Call<Object> method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1713,7 +1576,7 @@ Response method(@Header("kit") String kit) {
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("foo") List<String> kit) {
+      Call<Object> method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1729,7 +1592,7 @@ Response method(@Header("foo") List<String> kit) {
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@Header("foo") String[] kit) {
+      Call<Object> method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1746,7 +1609,7 @@ Response method(@Header("foo") String[] kit) {
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method(@Body RequestBody body) {
+      Call<Object> method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1759,26 +1622,10 @@ Response method(@Body RequestBody body) {
     class Example {
       @DELETE("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
-  }
-
-  @Test public void contentTypeInterceptorHeaderAddsHeaderWithNoBody() {
-    class Example {
-      @DELETE("/") //
-      Response method() {
+      Call<Object> method() {
         return null;
       }
     }
-    interceptor = new RequestInterceptor() {
-      @Override public void intercept(RequestFacade request) {
-        request.addHeader("Content-Type", "text/not-plain");
-      }
-    };
     Request request = buildRequest(Example.class);
     assertThat(request.headers().get("Content-Type")).isEqualTo("text/not-plain");
   }
@@ -1786,7 +1633,7 @@ Response method() {
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Response method(@Header("Content-Type") String contentType, @Body RequestBody body) {
+      Call<Object> method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
@@ -1806,18 +1653,18 @@ private static void assertBody(RequestBody body, String expected) {
     }
   }
 
-  private static final Converter GSON = new GsonConverter(new Gson());
-
   private Request buildRequest(Class<?> cls, Object... args) {
     Method method = TestingUtils.onlyMethod(cls);
-    MethodInfo methodInfo = new MethodInfo(method);
 
-    RequestBuilder builder = new RequestBuilder("http://example.com/", methodInfo, GSON);
-    if (interceptor != null) {
-      interceptor.intercept(builder);
-    }
-    builder.setArguments(args);
+    BaseUrl baseUrl = new BaseUrl() {
+      @Override public HttpUrl url() {
+        return HttpUrl.parse("http://example.com/");
+      }
+    };
+    List<Converter.Factory> converterFactories =
+        Arrays.asList(new BuiltInConverterFactory(), new ToStringConverterFactory());
 
-    return builder.build();
+    RequestFactory requestFactory = RequestFactoryParser.parse(method, baseUrl, converterFactories);
+    return requestFactory.create(args);
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java b/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
new file mode 100644
index 000000000..59d9cd9a9
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
@@ -0,0 +1,33 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import java.util.Set;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class RequestFactoryParserTest {
+  @Test public void pathParameterParsing() throws Exception {
+    expectParams("/");
+    expectParams("/foo");
+    expectParams("/foo/bar");
+    expectParams("/foo/bar/{}");
+    expectParams("/foo/bar/{taco}", "taco");
+    expectParams("/foo/bar/{t}", "t");
+    expectParams("/foo/bar/{!!!}/"); // Invalid parameter.
+    expectParams("/foo/bar/{}/{taco}", "taco");
+    expectParams("/foo/bar/{taco}/or/{burrito}", "taco", "burrito");
+    expectParams("/foo/bar/{taco}/or/{taco}", "taco");
+    expectParams("/foo/bar/{taco-shell}", "taco-shell");
+    expectParams("/foo/bar/{taco_shell}", "taco_shell");
+    expectParams("/foo/bar/{sha256}", "sha256");
+    expectParams("/foo/bar/{TACO}", "TACO");
+    expectParams("/foo/bar/{taco}/{tAco}/{taCo}", "taco", "tAco", "taCo");
+    expectParams("/foo/bar/{1}"); // Invalid parameter, name cannot start with digit.
+  }
+
+  private static void expectParams(String path, String... expected) {
+    Set<String> calculated = RequestFactoryParser.parsePathParameters(path);
+    assertThat(calculated).containsExactly(expected);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/RestAdapterTest.java b/retrofit/src/test/java/retrofit/RestAdapterTest.java
deleted file mode 100644
index d435fd514..000000000
--- a/retrofit/src/test/java/retrofit/RestAdapterTest.java
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright 2013 Square, Inc.
-package retrofit;
-
-import com.google.gson.JsonParseException;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.Headers;
-import retrofit.http.POST;
-import retrofit.http.Streaming;
-import rx.Observable;
-import rx.functions.Action1;
-
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static retrofit.Utils.SynchronousExecutor;
-
-public class RestAdapterTest {
-  private interface Example {
-    @Headers("Foo: Bar")
-    @GET("/") String something();
-    @Headers("Foo: Bar")
-    @GET("/") void something(Callback<String> callback);
-    @GET("/") Response direct();
-    @GET("/") void direct(Callback<Response> callback);
-    @GET("/") @Streaming Response streaming();
-    @POST("/") Observable<String> observable(@Body String body);
-  }
-  private interface InvalidExample extends Example {
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  private Example example;
-
-  @Before public void setUp() {
-    OkHttpClient client = new OkHttpClient();
-
-    example = new RestAdapter.Builder() //
-        .setClient(client)
-        .setCallbackExecutor(new SynchronousExecutor())
-        .setEndpoint(server.getUrl("/").toString())
-        .build()
-        .create(Example.class);
-  }
-
-  @Test public void objectMethodsStillWork() {
-    assertThat(example.hashCode()).isNotZero();
-    assertThat(example.equals(this)).isFalse();
-    assertThat(example.toString()).isNotEmpty();
-  }
-
-  @Test public void interfaceWithExtendIsNotSupported() {
-    try {
-      new RestAdapter.Builder().setEndpoint("http://foo/").build().create(InvalidExample.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Interface definitions must not extend other interfaces.");
-    }
-  }
-
-  @Test public void successfulRequestResponseWhenMimeTypeMissing() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi").removeHeader("Content-Type"));
-    String string = example.something();
-    assertThat(string).isEqualTo("Hi");
-  }
-
-  @Test public void malformedResponseThrowsConversionException() throws Exception {
-    server.enqueue(new MockResponse().setBody("{"));
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.UNEXPECTED);
-      assertThat(e.getResponse().code()).isEqualTo(200);
-      assertThat(e.getCause()).isInstanceOf(JsonParseException.class);
-      assertThat(e.getResponse().body()).isNull();
-    }
-  }
-
-  @Test public void errorResponseThrowsHttpError() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken"));
-
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.HTTP);
-      assertThat(e.getResponse().code()).isEqualTo(500);
-      assertThat(e.getSuccessType()).isEqualTo(String.class);
-    }
-  }
-
-  @Test public void clientExceptionThrowsNetworkError() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi").setSocketPolicy(DISCONNECT_AT_START));
-
-    try {
-      example.something();
-      fail();
-    } catch (RetrofitError e) {
-      assertThat(e.getKind()).isEqualTo(RetrofitError.Kind.NETWORK);
-    }
-  }
-
-  @Test public void getResponseDirectly() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-    Response response = example.direct();
-    assertThat(response.body().string()).isEqualTo("Hey");
-  }
-
-  @Test public void streamingResponse() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey").setBodyDelayTimeMs(500));
-    Response response = example.streaming();
-    long startNs = System.nanoTime();
-    response.body().string();
-    long tookNs = System.nanoTime() - startNs;
-    assertThat(tookNs).isGreaterThanOrEqualTo(500);
-  }
-
-  @Test public void getResponseDirectlyAsync() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-
-    final AtomicReference<Response> responseRef = new AtomicReference<Response>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.direct(new Callback<Response>() {
-      @Override public void success(Response response, Response response2) {
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(responseRef.get().body().string()).isEqualTo("Hey");
-  }
-
-  @Test public void getAsync() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hey"));
-
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.something(new Callback<String>() {
-      @Override public void success(String body, Response response) {
-        bodyRef.set(body);
-        latch.countDown();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        throw new AssertionError();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(bodyRef.get()).isEqualTo("Hey");
-  }
-
-  @Test public void errorAsync() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 500 Broken!").setBody("Hey"));
-
-    final AtomicReference<RetrofitError> errorRef = new AtomicReference<RetrofitError>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.something(new Callback<String>() {
-      @Override public void success(String s, Response response) {
-        throw new AssertionError();
-      }
-
-      @Override public void failure(RetrofitError error) {
-        errorRef.set(error);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    RetrofitError error = errorRef.get();
-    assertThat(error.getResponse().code()).isEqualTo(500);
-    assertThat(error.getResponse().message()).isEqualTo("Broken!");
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-    assertThat(error.getBody()).isEqualTo("Hey");
-  }
-
-  @Test public void observableCallsOnNext() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello"));
-
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.observable("Howdy").subscribe(new Action1<String>() {
-      @Override public void call(String body) {
-        bodyRef.set(body);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    assertThat(bodyRef.get()).isEqualTo("hello");
-  }
-
-  @Test public void observableCallsOnError() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    example.observable("Howdy").subscribe(new Action1<String>() {
-      @Override public void call(String s) {
-        throw new AssertionError();
-      }
-    }, new Action1<Throwable>() {
-      @Override public void call(Throwable throwable) {
-        errorRef.set(throwable);
-        latch.countDown();
-      }
-    });
-    assertTrue(latch.await(1, TimeUnit.SECONDS));
-
-    RetrofitError error = (RetrofitError) errorRef.get();
-    assertThat(error.getResponse().code()).isEqualTo(500);
-    assertThat(error.getSuccessType()).isEqualTo(String.class);
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
new file mode 100644
index 000000000..b80efc941
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -0,0 +1,634 @@
+// Copyright 2013 Square, Inc.
+package retrofit;
+
+import com.squareup.okhttp.HttpUrl;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.GET;
+import retrofit.http.POST;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+public final class RetrofitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface CallMethod {
+    @GET("/") Call<String> disallowed();
+    @POST("/") Call<ResponseBody> disallowed(@Body String body);
+    @GET("/") Call<ResponseBody> getResponseBody();
+    @GET("/") Call<Void> getVoid();
+    @POST("/") Call<ResponseBody> postRequestBody(@Body RequestBody body);
+  }
+  interface FutureMethod {
+    @GET("/") Future<String> method();
+  }
+  interface Extending extends CallMethod {
+  }
+  interface StringService {
+    @GET("/") String get();
+  }
+  interface Unresolvable {
+    @GET("/") <T> Call<T> typeVariable();
+    @GET("/") <T extends ResponseBody> Call<T> typeVariableUpperBound();
+    @GET("/") <T> Call<List<Map<String, Set<T[]>>>> crazy();
+    @GET("/") Call<?> wildcard();
+    @GET("/") Call<? extends ResponseBody> wildcardUpperBound();
+  }
+  interface VoidService {
+    @GET("/") void nope();
+  }
+  interface Annotated {
+    @GET("/") @Foo Call<String> method();
+    @POST("/") Call<ResponseBody> parameter(@Foo @Body String param);
+
+    @Retention(RUNTIME)
+    @interface Foo {}
+  }
+
+  @SuppressWarnings("EqualsBetweenInconvertibleTypes") // We are explicitly testing this behavior.
+  @Test public void objectMethodsStillWork() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    assertThat(example.hashCode()).isNotZero();
+    assertThat(example.equals(this)).isFalse();
+    assertThat(example.toString()).isNotEmpty();
+  }
+
+  @Test public void interfaceWithExtendIsNotSupported() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    try {
+      retrofit.create(Extending.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("API interfaces must not extend other interfaces.");
+    }
+  }
+
+  @Test public void voidReturnTypeNotAllowed() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    VoidService service = retrofit.create(VoidService.class);
+
+    try {
+      service.nope();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessageStartingWith(
+          "Service methods cannot return void.\n    for method VoidService.nope");
+    }
+  }
+
+  @Test public void callCallAdapterAddedByDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.getResponseBody()).isNotNull();
+  }
+
+  @Test public void callCallCustomAdapter() {
+    final AtomicBoolean factoryCalled = new AtomicBoolean();
+    final AtomicBoolean adapterCalled = new AtomicBoolean();
+    class MyCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(final Type returnType, Annotation[] annotations) {
+        factoryCalled.set(true);
+        if (Utils.getRawType(returnType) != Call.class) {
+          return null;
+        }
+        return new CallAdapter<Call<?>>() {
+          @Override public Type responseType() {
+            return Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+          }
+
+          @Override public <R> Call<R> adapt(Call<R> call) {
+            adapterCalled.set(true);
+            return call;
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    assertThat(example.getResponseBody()).isNotNull();
+    assertThat(factoryCalled.get()).isTrue();
+    assertThat(adapterCalled.get()).isTrue();
+  }
+
+  @Test public void customCallAdapter() {
+    class GreetingCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<String> get(Type returnType, Annotation[] annotations) {
+        if (Utils.getRawType(returnType) != String.class) {
+          return null;
+        }
+        return new CallAdapter<String>() {
+          @Override public Type responseType() {
+            return String.class;
+          }
+
+          @Override public <R> String adapt(Call<R> call) {
+            return "Hi!";
+          }
+        };
+      }
+    }
+
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new GreetingCallAdapterFactory())
+        .build();
+    StringService example = retrofit.create(StringService.class);
+    assertThat(example.get()).isEqualTo("Hi!");
+  }
+
+  @Test public void methodAnnotationsPassedToCallAdapter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyCallAdapterFactory implements CallAdapter.Factory {
+      @Override public CallAdapter<?> get(Type returnType, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+        return null;
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .addCallAdapterFactory(new MyCallAdapterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void customCallAdapterMissingThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    FutureMethod example = retrofit.create(FutureMethod.class);
+    try {
+      example.method();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create call adapter for java.util.concurrent.Future<java.lang.String>\n"
+              + "    for method FutureMethod.method");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate call adapter for java.util.concurrent.Future<java.lang.String>. Tried:\n"
+              + " * retrofit.DefaultCallAdapter$1");
+    }
+  }
+
+  @Test public void methodAnnotationsPassedToConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().fromResponseBody(type, annotations);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.method(); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void parameterAnnotationsPassedToConverter() {
+    final AtomicReference<Annotation[]> annotationsRef = new AtomicReference<>();
+    class MyConverterFactory extends Converter.Factory {
+      @Override
+      public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+        annotationsRef.set(annotations);
+        return new ToStringConverterFactory().toRequestBody(type, annotations);
+      }
+    }
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new MyConverterFactory())
+        .build();
+    Annotated annotated = retrofit.create(Annotated.class);
+    annotated.parameter(null); // Trigger internal setup.
+
+    Annotation[] annotations = annotationsRef.get();
+    assertThat(annotations).hasAtLeastOneElementOfType(Annotated.Foo.class);
+  }
+
+  @Test public void missingConverterThrowsOnNonRequestBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+    try {
+      example.disallowed("Hi!");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Unable to create @Body converter for class java.lang.String (parameter #1)\n"
+              + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate RequestBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory");
+    }
+  }
+
+  @Test public void missingConverterThrowsOnNonResponseBody() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    try {
+      example.disallowed();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory");
+    }
+  }
+
+  @Test public void converterReturningNullThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new Converter.Factory() {})
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+
+    try {
+      service.disallowed();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Unable to create converter for class java.lang.String\n"
+          + "    for method CallMethod.disallowed");
+      assertThat(e.getCause()).hasMessage(
+          "Could not locate ResponseBody converter for class java.lang.String. Tried:\n"
+              + " * retrofit.BuiltInConverterFactory\n"
+              + " * retrofit.RetrofitTest$1");
+    }
+  }
+
+  @Test public void requestBodyOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<ResponseBody> response = example.getResponseBody().execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+  }
+
+  @Test public void voidOutgoingAllowed() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Void> response = example.getVoid().execute();
+    assertThat(response.body()).isNull();
+  }
+
+  @Test public void responseBodyIncomingAllowed() throws IOException, InterruptedException {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build();
+    CallMethod example = retrofit.create(CallMethod.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Hey");
+    Response<ResponseBody> response = example.postRequestBody(body).execute();
+    assertThat(response.body().string()).isEqualTo("Hi");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("Hey");
+  }
+
+  @Test public void unresolvableTypeThrows() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(new ToStringConverterFactory())
+        .build();
+    Unresolvable example = retrofit.create(Unresolvable.class);
+
+    try {
+      example.typeVariable();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<T>\n    for method Unresolvable.typeVariable");
+    }
+    try {
+      example.typeVariableUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<T>\n    for method Unresolvable.typeVariableUpperBound");
+    }
+    try {
+      example.crazy();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n"
+          + "    for method Unresolvable.crazy");
+    }
+    try {
+      example.wildcard();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<?>\n    for method Unresolvable.wildcard");
+    }
+    try {
+      example.wildcardUpperBound();
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
+          + "retrofit.Call<? extends com.squareup.okhttp.ResponseBody>\n"
+          + "    for method Unresolvable.wildcardUpperBound");
+    }
+  }
+
+  @Test public void baseUrlRequired() {
+    try {
+      new Retrofit.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Base URL required.");
+    }
+  }
+
+  @Test public void baseUrlNullThrows() {
+    try {
+      new Retrofit.Builder().baseUrl((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+    try {
+      new Retrofit.Builder().baseUrl((HttpUrl) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+    try {
+      new Retrofit.Builder().baseUrl((BaseUrl) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("baseUrl == null");
+    }
+  }
+
+  @Test public void baseUrlInvalidThrows() {
+    try {
+      new Retrofit.Builder().baseUrl("ftp://foo/bar");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Illegal URL: ftp://foo/bar");
+    }
+  }
+
+  @Test public void baseUrlStringPropagated() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    BaseUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isNotNull();
+    assertThat(baseUrl.url().toString()).isEqualTo("http://example.com/");
+  }
+
+  @Test public void baseHttpUrlPropagated() {
+    HttpUrl url = HttpUrl.parse("http://example.com/");
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(url)
+        .build();
+    BaseUrl baseUrl = retrofit.baseUrl();
+    assertThat(baseUrl).isNotNull();
+    assertThat(baseUrl.url()).isSameAs(url);
+  }
+
+  @Test public void baseUrlPropagated() {
+    BaseUrl baseUrl = mock(BaseUrl.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(baseUrl)
+        .build();
+    assertThat(retrofit.baseUrl()).isSameAs(baseUrl);
+  }
+
+  @Test public void clientNullThrows() {
+    try {
+      new Retrofit.Builder().client(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("client == null");
+    }
+  }
+
+  @Test public void clientDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com")
+        .build();
+      assertThat(retrofit.client()).isNotNull();
+  }
+
+  @Test public void clientPropagated() {
+    OkHttpClient client = new OkHttpClient();
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .client(client)
+        .build();
+    assertThat(retrofit.client()).isSameAs(client);
+  }
+
+  @Test public void converterNullThrows() {
+    try {
+      new Retrofit.Builder().addConverterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("converterFactory == null");
+    }
+  }
+
+  @Test public void converterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    List<Converter.Factory> converterFactories = retrofit.converterFactories();
+    assertThat(converterFactories).hasSize(1);
+    assertThat(converterFactories.get(0)).isInstanceOf(BuiltInConverterFactory.class);
+  }
+
+  @Test public void converterFactoryPropagated() {
+    Converter.Factory factory = mock(Converter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addConverterFactory(factory)
+        .build();
+    assertThat(retrofit.converterFactories()).contains(factory);
+  }
+
+  @Test public void callAdapterFactoryNullThrows() {
+    try {
+      new Retrofit.Builder().addCallAdapterFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("factory == null");
+    }
+  }
+
+  @Test public void callAdapterFactoryDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callAdapterFactories()).isNotEmpty();
+  }
+
+  @Test public void callAdapterFactoryPropagated() {
+    CallAdapter.Factory factory = mock(CallAdapter.Factory.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .addCallAdapterFactory(factory)
+        .build();
+    assertThat(retrofit.callAdapterFactories()).contains(factory);
+  }
+
+  @Test public void callbackExecutorNullThrows() {
+    try {
+      new Retrofit.Builder().callbackExecutor(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callbackExecutor == null");
+    }
+  }
+
+  @Test public void callbackExecutorNoDefault() {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .build();
+    assertThat(retrofit.callbackExecutor()).isNull();
+  }
+
+  @Test public void callbackExecutorPropagated() {
+    Executor executor = mock(Executor.class);
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://example.com/")
+        .callbackExecutor(executor)
+        .build();
+    assertThat(retrofit.callbackExecutor()).isSameAs(executor);
+  }
+
+  @Test public void callbackExecutorUsedForSuccess() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse());
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Response<ResponseBody> response) {
+        latch.countDown();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        t.printStackTrace();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+
+  @Test public void callbackExecutorUsedForFailure() throws InterruptedException {
+    Executor executor = spy(new Executor() {
+      @Override public void execute(Runnable command) {
+        command.run();
+      }
+    });
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor(executor)
+        .build();
+    CallMethod service = retrofit.create(CallMethod.class);
+    Call<ResponseBody> call = service.getResponseBody();
+
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback<ResponseBody>() {
+      @Override public void onResponse(Response<ResponseBody> response) {
+        throw new AssertionError();
+      }
+
+      @Override public void onFailure(Throwable t) {
+        latch.countDown();
+      }
+    });
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+
+    verify(executor).execute(any(Runnable.class));
+    verifyNoMoreInteractions(executor);
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/ToStringConverterFactory.java b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
new file mode 100644
index 000000000..35919c867
--- /dev/null
+++ b/retrofit/src/test/java/retrofit/ToStringConverterFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+class ToStringConverterFactory extends Converter.Factory {
+  private static final MediaType MEDIA_TYPE = MediaType.parse("text/plain");
+
+  @Override
+  public Converter<ResponseBody, ?> fromResponseBody(Type type, Annotation[] annotations) {
+    if (String.class.equals(type)) {
+      return new Converter<ResponseBody, String>() {
+        @Override public String convert(ResponseBody value) throws IOException {
+          return value.string();
+        }
+      };
+    }
+    return null;
+  }
+
+  @Override public Converter<?, RequestBody> toRequestBody(Type type, Annotation[] annotations) {
+    if (String.class.equals(type)) {
+      return new Converter<String, RequestBody>() {
+        @Override public RequestBody convert(String value) throws IOException {
+          return RequestBody.create(MEDIA_TYPE, value);
+        }
+      };
+    }
+    return null;
+  }
+}
diff --git a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
deleted file mode 100644
index 98c10c93b..000000000
--- a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-// Copyright 2015 Square, Inc.
-package retrofit.converter;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import okio.Buffer;
-import org.assertj.core.api.AbstractCharSequenceAssert;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-
-public final class GsonConverterTest {
-  private Converter converter;
-
-  interface Example {
-    String getName();
-  }
-
-  class Impl implements Example {
-    private final String theName;
-
-    Impl(String name) {
-      theName = name;
-    }
-
-    @Override public String getName() {
-      return theName;
-    }
-  }
-
-  @Before public void setUp() {
-    Gson gson = new GsonBuilder()
-        .registerTypeAdapter(Example.class, new JsonSerializer<Example>() {
-          @Override public JsonElement serialize(Example example, Type type,
-              JsonSerializationContext json) {
-            JsonObject object = new JsonObject();
-            object.addProperty("name", example.getName());
-            return object;
-          }
-        })
-        .create();
-    converter = new GsonConverter(gson);
-  }
-
-  @Test public void serialization() throws IOException {
-    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
-    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
-  }
-
-  @Test public void serializationTypeUsed() throws IOException {
-    RequestBody body = converter.toBody(new Impl("value"), Example.class);
-    assertBody(body).isEqualTo("{\"name\":\"value\"}");
-  }
-
-  @Test public void deserialization() throws IOException {
-    ResponseBody body =
-        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
-    Impl impl = (Impl) converter.fromBody(body, Impl.class);
-    assertEquals("value", impl.getName());
-  }
-
-  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return assertThat(buffer.readUtf8());
-  }
-}
diff --git a/samples/pom.xml b/samples/pom.xml
index 272a39608..b1a3e9f85 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -10,13 +10,41 @@
     <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <groupId>com.squareup.retrofit.samples</groupId>
-  <artifactId>parent</artifactId>
+  <artifactId>samples</artifactId>
   <name>Samples</name>
-  <packaging>pom</packaging>
 
-  <modules>
-    <module>github-client</module>
-    <module>mock-github-client</module>
-  </modules>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>retrofit-mock</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.retrofit</groupId>
+      <artifactId>converter-gson</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
new file mode 100644
index 000000000..eba5385fa
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import retrofit.Call;
+import retrofit.CallAdapter;
+import retrofit.Callback;
+import retrofit.Response;
+import retrofit.Retrofit;
+import retrofit.http.GET;
+
+/**
+ * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
+ * a service method return type.
+ */
+public final class CustomCallAdapter {
+  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
+    @Override
+    public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations) {
+      TypeToken<?> token = TypeToken.of(returnType);
+      if (token.getRawType() != ListenableFuture.class) {
+        return null;
+      }
+
+      TypeToken<?> componentType = token.getComponentType();
+      if (componentType == null) {
+        throw new IllegalStateException(); // TODO
+      }
+      final Type responseType = componentType.getType();
+
+      return new CallAdapter<ListenableFuture<?>>() {
+        @Override public Type responseType() {
+          return responseType;
+        }
+
+        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
+          CallFuture<R> future = new CallFuture<>(call);
+          call.enqueue(future);
+          return future;
+        }
+      };
+    }
+
+    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
+      private final Call<T> call;
+
+      private CallFuture(Call<T> call) {
+        this.call = call;
+      }
+
+      @Override protected void interruptTask() {
+        call.cancel();
+      }
+
+      @Override public void onResponse(Response<T> response) {
+        if (response.isSuccess()) {
+          set(response.body());
+        } else {
+          setException(new IOException()); // TODO something more useful.
+        }
+      }
+
+      @Override public void onFailure(Throwable t) {
+        setException(t);
+      }
+    }
+  }
+
+  interface HttpBinService {
+    @GET("/ip")
+    ListenableFuture<Ip> getIp();
+  }
+
+  static class Ip {
+    String origin;
+  }
+
+  public static void main(String... args) {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://httpbin.org")
+        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .build();
+
+    HttpBinService service = retrofit.create(HttpBinService.class);
+    final ListenableFuture<Ip> ip = service.getIp();
+    ip.addListener(new Runnable() {
+      @Override public void run() {
+        try {
+          System.out.println("IP: " + ip.get().origin);
+        } catch (InterruptedException | ExecutionException e) {
+          e.printStackTrace();
+        }
+      }
+    }, Executors.newSingleThreadExecutor());
+  }
+}
diff --git a/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
similarity index 51%
rename from samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/java/com/example/retrofit/SimpleMockService.java
index 27563c9a7..a591e2be7 100644
--- a/samples/mock-github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleMockService.java
@@ -1,41 +1,35 @@
 // Copyright 2013 Square, Inc.
 package com.example.retrofit;
 
+import com.example.retrofit.SimpleService.Contributor;
+import com.example.retrofit.SimpleService.GitHub;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import retrofit.MockRestAdapter;
-import retrofit.RestAdapter;
-import retrofit.http.GET;
-import retrofit.http.Path;
-
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
-
-  static class Contributor {
-    public final String login;
-    public final int contributions;
-
-    Contributor(String login, int contributions) {
-      this.login = login;
-      this.contributions = contributions;
-    }
-  }
-
-  public interface GitHub {
-    @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(@Path("owner") String owner, @Path("repo") String repo);
-  }
-
+import retrofit.Call;
+import retrofit.Retrofit;
+import retrofit.mock.CallBehaviorAdapter;
+import retrofit.mock.Calls;
+import retrofit.mock.MockRetrofit;
+import retrofit.mock.NetworkBehavior;
+
+/**
+ * An example of using {@link MockRetrofit} to create a mock service implementation with
+ * fake data. This re-uses the GitHub service from {@link SimpleService} for its mocking.
+ */
+public final class SimpleMockService {
   /** A mock implementation of the {@link GitHub} API interface. */
-  static class MockGitHub implements GitHub {
+  static final class MockGitHub implements GitHub {
     private final Map<String, Map<String, List<Contributor>>> ownerRepoContributors;
 
     public MockGitHub() {
-      ownerRepoContributors = new LinkedHashMap<String, Map<String, List<Contributor>>>();
+      ownerRepoContributors = new LinkedHashMap<>();
 
       // Seed some mock data.
       addContributor("square", "retrofit", "John Doe", 12);
@@ -45,47 +39,50 @@ public MockGitHub() {
       addContributor("square", "picasso", "Keiser Soze", 152);
     }
 
-    @Override public List<Contributor> contributors(String owner, String repo) {
+    @Override public Call<List<Contributor>> contributors(String owner, String repo) {
+      List<Contributor> response = Collections.emptyList();
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
-      if (repoContributors == null) {
-        return Collections.emptyList();
-      }
-      List<Contributor> contributors = repoContributors.get(repo);
-      if (contributors == null) {
-        return Collections.emptyList();
+      if (repoContributors != null) {
+        List<Contributor> contributors = repoContributors.get(repo);
+        if (contributors != null) {
+          response = contributors;
+        }
       }
-      return contributors;
+      return Calls.response(response);
     }
 
     public void addContributor(String owner, String repo, String name, int contributions) {
       Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner);
       if (repoContributors == null) {
-        repoContributors = new LinkedHashMap<String, List<Contributor>>();
+        repoContributors = new LinkedHashMap<>();
         ownerRepoContributors.put(owner, repoContributors);
       }
       List<Contributor> contributors = repoContributors.get(repo);
       if (contributors == null) {
-        contributors = new ArrayList<Contributor>();
+        contributors = new ArrayList<>();
         repoContributors.put(repo, contributors);
       }
       contributors.add(new Contributor(name, contributions));
     }
   }
 
-  public static void main(String... args) {
-    // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setEndpoint(API_URL)
+  public static void main(String... args) throws IOException {
+    // Create a very simple Retrofit adapter which points the GitHub API.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(SimpleService.API_URL)
         .build();
 
-    // Wrap our REST adapter to allow mock implementations and fake network delay.
-    MockRestAdapter mockRestAdapter =
-        MockRestAdapter.from(restAdapter, Executors.newSingleThreadExecutor());
+    // Create the Behavior object which manages the fake behavior and the background executor.
+    NetworkBehavior behavior = NetworkBehavior.create();
+    ExecutorService bg = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
+        .setNameFormat("mock-retrofit-%d")
+        .setDaemon(true)
+        .build());
 
-    // Instantiate a mock object so we can interact with it later.
+    // Create the mock implementation and use MockRetrofit to apply the behavior to it.
+    MockRetrofit mockRetrofit = new MockRetrofit(behavior, new CallBehaviorAdapter(retrofit, bg));
     MockGitHub mockGitHub = new MockGitHub();
-    // Use the mock REST adapter and our mock object to create the API interface.
-    GitHub gitHub = mockRestAdapter.create(GitHub.class, mockGitHub);
+    GitHub gitHub = mockRetrofit.create(GitHub.class, mockGitHub);
 
     // Query for some contributors for a few repositories.
     printContributors(gitHub, "square", "retrofit");
@@ -101,10 +98,11 @@ public static void main(String... args) {
     printContributors(gitHub, "square", "picasso");
   }
 
-  private static void printContributors(GitHub gitHub, String owner, String repo) {
+  private static void printContributors(GitHub gitHub, String owner, String repo)
+      throws IOException {
     System.out.println(String.format("== Contributors for %s/%s ==", owner, repo));
-    List<Contributor> contributors = gitHub.contributors(owner, repo);
-    for (Contributor contributor : contributors) {
+    Call<List<Contributor>> contributors = gitHub.contributors(owner, repo);
+    for (Contributor contributor : contributors.execute().body()) {
       System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
     System.out.println();
diff --git a/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java b/samples/src/main/java/com/example/retrofit/SimpleService.java
similarity index 50%
rename from samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
rename to samples/src/main/java/com/example/retrofit/SimpleService.java
index f71a10bac..1fe28dc2a 100644
--- a/samples/github-client/src/main/java/com/example/retrofit/GitHubClient.java
+++ b/samples/src/main/java/com/example/retrofit/SimpleService.java
@@ -15,38 +15,49 @@
  */
 package com.example.retrofit;
 
+import java.io.IOException;
 import java.util.List;
-import retrofit.RestAdapter;
+import retrofit.Call;
+import retrofit.GsonConverterFactory;
+import retrofit.Retrofit;
 import retrofit.http.GET;
 import retrofit.http.Path;
 
-public class GitHubClient {
-  private static final String API_URL = "https://api.github.com";
+public final class SimpleService {
+  public static final String API_URL = "https://api.github.com";
 
-  static class Contributor {
-    String login;
-    int contributions;
+  public static class Contributor {
+    public final String login;
+    public final int contributions;
+
+    public Contributor(String login, int contributions) {
+      this.login = login;
+      this.contributions = contributions;
+    }
   }
 
-  interface GitHub {
+  public interface GitHub {
     @GET("/repos/{owner}/{repo}/contributors")
-    List<Contributor> contributors(
+    Call<List<Contributor>> contributors(
         @Path("owner") String owner,
-        @Path("repo") String repo
-    );
+        @Path("repo") String repo);
   }
 
-  public static void main(String... args) {
-    // Create a very simple REST adapter which points the GitHub API endpoint.
-    RestAdapter restAdapter = new RestAdapter.Builder()
-        .setEndpoint(API_URL)
+  public static void main(String... args) throws IOException {
+    // Create a very simple REST adapter which points the GitHub API.
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl(API_URL)
+        .addConverterFactory(GsonConverterFactory.create())
         .build();
 
     // Create an instance of our GitHub API interface.
-    GitHub github = restAdapter.create(GitHub.class);
+    GitHub github = retrofit.create(GitHub.class);
+
+    // Create a call instance for looking up Retrofit contributors.
+    Call<List<Contributor>> call = github.contributors("square", "retrofit");
 
-    // Fetch and print a list of the contributors to this library.
-    List<Contributor> contributors = github.contributors("square", "retrofit");
+    // Fetch and print a list of the contributors to the library.
+    List<Contributor> contributors = call.execute().body();
     for (Contributor contributor : contributors) {
       System.out.println(contributor.login + " (" + contributor.contributions + ")");
     }
diff --git a/website/index.html b/website/index.html
index cfd04f78b..ac8dc39db 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,11 +4,11 @@
     <meta charset="utf-8">
     <title>Retrofit</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="A type-safe REST client for Android and Java">
+    <meta name="description" content="A type-safe HTTP client for Android and Java">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -33,7 +33,7 @@ <h1>Retrofit</h1>
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
+            <h2>A type-safe <strong>HTTP client</strong> for Android and Java<!-- and Samsung! --></h2>
           </div>
         </div>
       </div>
@@ -43,25 +43,26 @@ <h2>A type-safe <strong>REST client</strong> for Android and Java</h2>
         <div class="row">
           <div class="span9">
             <h3 id="introduction">Introduction</h3>
-            <p>Retrofit turns your REST API into a Java interface.</p>
+            <p>Retrofit turns your HTTP API into a Java interface.</p>
             <pre class="prettyprint">public interface GitHubService {
   @GET("/users/{user}/repos")
-  List&lt;Repo> listRepos(@Path("user") String user);
+  Call&lt;List&lt;Repo>> listRepos(@Path("user") String user);
 }</pre>
-            <p>The <code>RestAdapter</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.github.com")
+            <p>The <code>Retrofit</code> class generates an implementation of the <code>GitHubService</code> interface.</p>
+            <pre class="prettyprint">Retrofit retrofit = new Retrofit.Builder()
+    .baseUrl("https://api.github.com")
     .build();
 
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GitHubService</code> makes an HTTP request to the remote webserver.</p>
-            <pre class="prettyprint">List&lt;Repo> repos = service.listRepos("octocat");</pre>
+GitHubService service = retrofit.create(GitHubService.class);</pre>
+            <p>Each <code>Call</code> from the created <code>GitHubService</code> can make a synchronous or asynchronous HTTP request to the remote webserver.</p>
+            <pre class="prettyprint">Call&lt;List&lt;Repo>> repos = service.listRepos("octocat");</pre>
             <p>Use annotations to describe the HTTP request:</p>
             <ul>
               <li>URL parameter replacement and query parameter support</li>
               <li>Object conversion to request body (e.g., JSON, protocol buffers)</li>
               <li>Multipart request body and file upload</li>
             </ul>
+            <p><em>Note:</em> This site is still in the process of being expanded for the new 2.0 APIs.</p>
 
             <h3 id="api-declaration">API Declaration</h3>
             <p>Annotations on the interface methods and its parameters indicate how a request will be handled.</p>
@@ -71,7 +72,6 @@ <h4>Request Method</h4>
             <pre class="prettyprint">@GET("/users/list")</pre>
             <p>You can also specify query parameters in the URL.</p>
             <pre class="prettyprint">@GET("/users/list?sort=desc")</pre>
-            </pre>
 
             <h4>URL Manipulation</h4>
             <p>A request URL can be updated dynamically using replacement blocks and parameters on the method. A replacement block is an alphanumeric string surrounded by <code>{</code> and <code>}</code>. A corresponding parameter must be annotated with <code>@Path</code> using the same string.</p>
@@ -87,143 +87,58 @@ <h4>URL Manipulation</h4>
             <h4>Request Body</h4>
             <p>An object can be specified for use as an HTTP request body with the <code>@Body</code> annotation.</p>
             <pre class="prettyprint">@POST("/users/new")
-void createUser(@Body User user, Callback&lt;User> cb);</pre>
-            <p>The object will also be converted using the <code>RestAdapter</code>'s converter.</p>
+Call&lt;User> createUser(@Body User user);</pre>
+            <p>The object will also be converted using a converter specified on the <code>Retrofit</code> instance. If no converter is added, only <code>RequestBody</code> can be used.</p>
 
             <h4>Form Encoded and Multipart</h4>
             <p>Methods can also be declared to send form-encoded and multipart data.</p>
             <p>Form-encoded data is sent when <code>@FormUrlEncoded</code> is present on the method. Each key-value pair is annotated with <code>@Field</code> containing the name and the object providing the value.</p>
             <pre class="prettyprint">@FormUrlEncoded
 @POST("/user/edit")
-User updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
+Call&lt;User> updateUser(@Field("first_name") String first, @Field("last_name") String last);</pre>
             <p>Multipart requests are used when <code>@Multipart</code> is present on the method. Parts are declared using the <code>@Part</code> annotation.</p>
             <pre class="prettyprint">@Multipart
 @PUT("/user/photo")
-User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description);</pre>
-            <p>Multipart parts use the <code>RestAdapter</code>'s converter or they can implement <code>TypedOutput</code> to handle their own serialization.</p>
+Call&lt;User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);</pre>
+            <p>Multipart parts use one of <code>Retrofit</code>'s converters or they can implement <code>RequestBody</code> to handle their own serialization.</p>
 
             <h4>Header Manipulation</h4>
             <p>You can set static headers for a method using the <code>@Headers</code> annotation.</p>
             <pre class="prettyprint">@Headers("Cache-Control: max-age=640000")
 @GET("/widget/list")
-List&lt;Widget> widgetList();</pre>
+Call&lt;List&lt;Widget>> widgetList();</pre>
             <pre class="prettyprint">@Headers({
     "Accept: application/vnd.github.v3.full+json",
     "User-Agent: Retrofit-Sample-App"
 })
 @GET("/users/{username}")
-User getUser(@Path("username") String username);</pre>
+Call&lt;User> getUser(@Path("username") String username);</pre>
             <p>Note that headers do not overwrite each other. All headers with the same name will be included in the request.</p>
             <p>A request Header can be updated dynamically using the <code>@Header</code> annotation. A corresponding parameter must be provided to the <code>@Header</code>. If the value is null, the header will be omitted. Otherwise, <code>toString</code> will be called on the value, and the result used.</p>
             <pre class="prettyprint">@GET("/user")
-void getUser(@Header("Authorization") String authorization, Callback&lt;User> callback)</pre>
-            <p>Headers that need to be added to every request can be specified using a <code>RequestInterceptor</code>. The following code creates a <code>RequestInterceptor</code> that will add a <code>User-Agent</code> header to every request.</p>
-            <pre class="prettyprint">RequestInterceptor requestInterceptor = new RequestInterceptor() {
-  @Override
-  public void intercept(RequestFacade request) {
-    request.addHeader("User-Agent", "Retrofit-Sample-App");
-  }
-};
+Call&lt;User> getUser(@Header("Authorization") String authorization)</pre>
+            <p>Headers that need to be added to every request can be specified using an <a href="https://github.com/square/okhttp/wiki/Interceptors">OkHttp interceptor</a>.
 
-RestAdapter restAdapter = new RestAdapter.Builder()
-  .setEndpoint("https://api.github.com")
-  .setRequestInterceptor(requestInterceptor)
-  .build();</pre>
+            <h4>Synchronous vs. Asynchronous</h4>
+            <p><code>Call</code> instances can be executed either synchronously or asynchronously. Each instance can only be used once, but calling <code>clone()</code> will create a new instance that can be used.</p>
+            <p>On Android, callbacks will be executed on the main thread. On the JVM, callbacks will happen on the same thread that executed the HTTP request.</p>
 
-            <h4>Synchronous vs. Asynchronous vs. Observable</h4>
-            <p>Methods can be declared for either synchronous or asynchronous execution.</p>
-            <p>A method with a return type will be executed synchronously.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Photo getUserPhoto(@Path("id") int id);</pre>
-            <p>Asynchronous execution requires the last parameter of the method be a <code>Callback</code>.</p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-void getUserPhoto(@Path("id") int id, Callback&lt;Photo> cb);</pre>
-            <p>On Android, callbacks will be executed on the main thread. For desktop applications callbacks will happen on the same thread that executed the HTTP request.</p>
+            <h3 id="restadapter-configuration">Retrofit Configuration</h3>
+            <p><code>Retrofit</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
 
-            <p>Retrofit also integrates <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> to support methods with a return type of <code>rx.Observable</code></p>
-            <pre class="prettyprint">@GET("/user/{id}/photo")
-Observable&lt;Photo> getUserPhoto(@Path("id") int id);</pre>
-            <p>Observable requests are subscribed asynchronously and observed on the same thread that executed the HTTP request.  To observe on a different thread (e.g. Android's main thread) call <code>observeOn(Scheduler)</code> on the returned <code>Observable</code>.</p>
-
-            <h4>Response Object Type</h4>
-            <p>HTTP responses are automatically converted to a specified type using the <code>RestAdapter</code>'s converter which defaults to JSON. The desired type is declared as the method return type or using the <code>Callback</code> or <code>Observable</code>.
-            <pre class="prettyprint">@GET("/users/list")
-List&lt;User> userList();
-
-@GET("/users/list")
-void userList(Callback&lt;List&lt;User>> cb);
-
-@GET("/users/list")
-Observable&lt;List&lt;User>> userList();</pre>
-            <p>For access to the raw HTTP response use the <code>Response</code> type.</p>
-            <pre class="prettyprint">@GET("/users/list")
-Response userList();
-
-@GET("/users/list")
-void userList(Callback&lt;Response> cb);
-
-@GET("/users/list")
-Observable&lt;Response> userList();</pre>
-
-            <h3 id="restadapter-configuration">RestAdapter Configuration</h3>
-            <p><code>RestAdapter</code> is the class through which your API interfaces are turned into callable objects. By default, Retrofit will give you sane defaults for your platform but it allows for customization.</p>
-
-            <h4>JSON Conversion</h4>
-            <p>Retrofit uses <a href="https://code.google.com/p/google-gson/">Gson</a> by default to convert HTTP bodies to and from JSON. If you want to specify behavior that is different from Gson's defaults (e.g. naming policies, date formats, custom types), provide a new <code>Gson</code> instance with your desired behavior when building a <code>RestAdapter</code>. Refer to the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson documentation</a> for more details on customization.</p>
-            <h4>Custom Gson Converter Example</h4>
-            <p>The following code creates a new <code>Gson</code> instance that will convert all fields from lower case with underscores to camel case and vice versa. It also registers a type adapter for the <code>Date</code> class. This <code>DateTypeAdapter</code> will be used anytime Gson encounters a <code>Date</code> field.</p>
-            <p>The <code>gson</code> instance is passed as a parameter to <code>GsonConverter</code>, which is a wrapper class for converting types.</p>
-            <pre class="prettyprint">Gson gson = new GsonBuilder()
-    .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
-    .registerTypeAdapter(Date.class, new DateTypeAdapter())
-    .create();
-
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.github.com")
-    .setConverter(new GsonConverter(gson))
-    .build();
-
-GitHubService service = restAdapter.create(GitHubService.class);</pre>
-            <p>Each call on the generated <code>GithubService</code> will return objects converted using the Gson implementation provided to the <code>RestAdapter</code>.</p>
-            <h4>Content format Agnostic</h4>
-            <p>In addition to JSON, Retrofit can be configured to use other content formats. Retrofit provides alternate converters for XML (using <a href="http://simple.sourceforge.net/">Simple</a>) and Protocol Buffers (using <a href="https://code.google.com/p/protobuf/">protobuf</a> or <a href="https://github.com/square/wire">Wire</a>). Please see the <a href="https://github.com/square/retrofit/tree/master/retrofit-converters">retrofit-converters</a> directory for the full listing of converters.</p>
-            <p>The following code shows how to use <code>SimpleXMLConverter</code> to communicate with an API that uses XML</p>
-            <pre class="prettyprint">RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.soundcloud.com")
-    .setConverter(new SimpleXMLConverter())
-    .build();
-
-SoundCloudService service = restAdapter.create(SoundCloudService.class);</pre>
+            <h4>Converters</h4>
+            <p>By default, Retrofit can only deserialize HTTP bodies into OkHttp's <code>ResponseBody</code> type and it can only accept its <code>RequestBody</code> type for <code>@Body</code>.</p>
+            <p>Converters can be added to support other types. Six sibling modules adapt popular serialization libraries for your convenience.</p>
+            <ul>
+              <li><a href="https://github.com/google/gson">Gson</a>: <code>com.squareup.retrofit:converter-gson</code></li>
+              <li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>: <code>com.squareup.retrofit:converter-jackson</code></li>
+              <li><a href="https://github.com/square/moshi/">Moshi</a>: <code>com.squareup.retrofit:converter-moshi</code></li>
+              <li><a href="https://developers.google.com/protocol-buffers/">Protobuf</a>: <code>com.squareup.retrofit:converter-protobuf</code></li>
+              <li><a href="https://github.com/square/wire">Wire</a>: <code>com.squareup.retrofit:converter-wire</code></li>
+              <li><a href="http://simple.sourceforge.net/">Simple XML</a>: <code>com.squareup.retrofit:converter-simplexml</code></li>
+            </ul>
             <h4>Custom Converters</h4>
-            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/converter/Converter.java"><code>Converter</code> interface</a> and pass in an instance when building your adapter.</p>
-            <h4>Custom Error Handling</h4>
-            <p>If you need custom error handling for requests, you may provide your own <code>ErrorHandler</code>. The following code shows how to throw a custom exception when a response returns a HTTP 401 status code</p>
-            <pre class="prettyprint">
-class MyErrorHandler implements ErrorHandler {
-  @Override public Throwable handleError(RetrofitError cause) {
-    Response r = cause.getResponse();
-    if (r != null && r.getStatus() == 401) {
-      return new UnauthorizedException(cause);
-    }
-    return cause;
-  }
-}
-
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setEndpoint("https://api.github.com")
-    .setErrorHandler(new MyErrorHandler())
-    .build();</pre>
-            <p>Note that if the return exception is checked, it must be declared on the interface method. It is recommended that you pass the supplied <code>RetrofitError</code> as the cause to any new exceptions you throw.</p>
-
-            <h4>Logging</h4>
-            <p>If you need to take a closer look at the requests and responses you can easily add logging levels to the <code>RestAdapter</code> with the <code>LogLevel</code> property. The possible logging levels are <code>BASIC</code>, <code>FULL</code>, <code>HEADERS</code>, and <code>NONE</code>.</p>
-            <p>The following code shows the addition of a full log level which will log the headers, body, and metadata for both requests and responses.</p>
-            <pre class="prettyprint">
-RestAdapter restAdapter = new RestAdapter.Builder()
-    .setLogLevel(RestAdapter.LogLevel.FULL)
-    .setEndpoint("https://api.github.com")
-    .build();</pre>
-            <p>This logging can be added or changed at any point in the <code>RestAdapter</code>'s lifecycle by calling the same <code>.setLogLevel()</code> method and supplying a different <code>LogLevel</code> value.</p>
+            <p>If you need to communicate with an API that uses a content-format that Retrofit does not support out of the box (e.g. YAML, txt, custom format) or you wish to use a different library to implement an existing format, you can easily create your own converter. Create a class that implements the <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/Converter.java"><code>Converter.Factory</code> interface</a> and pass in an instance when building your adapter.</p>
 
             <h3 id="download">Download</h3>
             <p><a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&a=retrofit&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
@@ -238,26 +153,15 @@ <h4>Gradle</h4>
             <pre class="prettyprint">
 compile 'com.squareup.retrofit:retrofit:<span class="version pln"><em>(insert latest version)</em></span>'
 </pre>
-            <p>Retrofit requires at minimum Java 6 or Android 2.3.</p>
+            <p>Retrofit requires at minimum Java 7 or Android 2.3.</p>
 
-            <h4>Integration with OkHttp</h4>
-            <p>When using Retrofit together with OkHttp, OkHttp (version 1.6.0 or newer) and OkHttp-UrlConnection are now required.</p>
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
-  &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version>2.0.0&lt;/version>
-&lt;/dependency>
-&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
-  &lt;artifactId>okhttp-urlconnection&lt;/artifactId>
-  &lt;version>2.0.0&lt;/version>
-&lt;/dependency>
-</pre>
-            <h4>Gradle</h4>
-<pre class="prettyprint">
-compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.0'
-compile 'com.squareup.okhttp:okhttp:2.0.0'
+            <h4>ProGuard</h4>
+            <p>If you are using Proguard in your project add the following lines to your configuration:</p>
+            <pre class="prettyprint">
+-dontwarn retrofit.**
+-keep class retrofit.** { *; }
+-keepattributes Signature
+-keepattributes Exceptions
 </pre>
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
@@ -284,7 +188,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-tabs nav-stacked primary">
                 <li><a href="#introduction">Introduction</a></li>
                 <li><a href="#api-declaration">API Declaration</a></li>
-                <li><a href="#restadapter-configuration">RestAdapter Configuration</a></li>
+                <li><a href="#restadapter-configuration">Retrofit Configuration</a></li>
                 <li><a href="#download">Download</a></li>
                 <li><a href="#contributing">Contributing</a></li>
                 <li><a href="#license">License</a></li>
@@ -303,7 +207,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
