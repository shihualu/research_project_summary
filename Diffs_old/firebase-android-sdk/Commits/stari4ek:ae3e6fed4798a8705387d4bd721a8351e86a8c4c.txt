diff --git a/.opensource/project.json b/.opensource/project.json
index 01f7c7132..1dfd5ca8d 100644
--- a/.opensource/project.json
+++ b/.opensource/project.json
@@ -4,13 +4,23 @@
     "platforms": [
         "Android"
     ],
-    "content": "README.md",
-    "pages": [
-        "firebase-common/README.md",
-        "firebase-firestore/README.md",
-        "protolite-well-known-types/README.md"
-    ],
+    "content": "docs/README.md",
+    "pages": {
+        "README.md": "Development Guide",
+        "docs/ktx/common.md": "Common KTX",
+        "docs/ktx/firestore.md": "Firestore KTX"
+    },
     "related": [
         "firebase/quickstart-android"
+    ],
+    "tabs": [
+        {
+            "title": "Main Reference",
+            "href": "https://firebase.google.com/docs/reference/android/"
+        },
+        {
+            "title": "KTX Reference",
+            "href": "https://firebase.github.io/firebase-android-sdk/reference/kotlin/firebase-ktx/"
+        }
     ]
 }
\ No newline at end of file
diff --git a/README.md b/README.md
index c86cb03e1..633836218 100644
--- a/README.md
+++ b/README.md
@@ -89,13 +89,41 @@ If you don't have a suitable testing project already:
   * Download the resulting `google-services.json` file and put it in the root of
     your checkout.
 
-#### Running Integration Tests
+#### Running Integration Tests on Local Emulator
 
 Integration tests can be executed on the command line by running
 ```bash
 ./gradlew :<firebase-project>:connectedCheck
 ```
 
+#### Running Integration Tests on Firebase Test Lab
+
+> You need additional setup for this to work:
+>
+> * `gcloud` needs to be [installed](https://cloud.google.com/sdk/install) on local machine
+> * `gcloud` needs to be configured with a project that has billing enabled
+> * `gcloud` needs to be authenticated with credentials that have 'Firebase Test Lab Admin' role
+
+Integration tests can be executed on the command line by running
+```bash
+./gradlew :<firebase-project>:deviceCheck
+```
+
+This will execute tests on devices that are configured per project, if nothing is configured for the
+project, the tests will run on `model=Pixel2,version=27,locale=en,orientation=portrait`.
+
+Projects can be configured in the following way:
+
+```
+firebaseTestLab {
+  // to get a list of available devices execute `gcloud firebase test android models list`
+  devices = [
+    '<device1>',
+    '<device2>',
+  ]
+}
+```
+
 ## Annotations
 
 Firebase SDKs use some special annotations for tooling purposes.
diff --git a/buildSrc/resources/dummy.apk b/buildSrc/resources/dummy.apk
new file mode 100644
index 000000000..2835aff35
Binary files /dev/null and b/buildSrc/resources/dummy.apk differ
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
index 06c27f96d..1d53aca83 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/ContinuousIntegrationPlugin.groovy
@@ -42,6 +42,7 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
         project.configure(project.subprojects) {
             def checkDependents = it.task('checkDependents') {}
             def connectedCheckDependents = it.task('connectedCheckDependents')
+            def deviceCheckDependents = it.task('deviceCheckDependents')
 
             configurations.all {
                 if (it.name == 'debugUnitTestRuntimeClasspath') {
@@ -56,6 +57,11 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
                             .debugAndroidTestRuntimeClasspath.getTaskDependencyFromProjectDependency(
                             false, "connectedCheckDependents"))
                     connectedCheckDependents.dependsOn 'connectedCheck'
+
+                    deviceCheckDependents.dependsOn(configurations
+                            .debugAndroidTestRuntimeClasspath.getTaskDependencyFromProjectDependency(
+                            false, "deviceCheckDependents"))
+                    deviceCheckDependents.dependsOn 'deviceCheck'
                 }
 
                 if (it.name == 'annotationProcessor') {
@@ -65,6 +71,9 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
                     checkDependents.dependsOn(configurations
                             .annotationProcessor.getTaskDependencyFromProjectDependency(
                             false, "checkDependents"))
+                    deviceCheckDependents.dependsOn(configurations
+                            .annotationProcessor.getTaskDependencyFromProjectDependency(
+                            false, "deviceCheckDependents"))
                 }
             }
 
@@ -81,6 +90,7 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
                     // defined.
                     tasks.maybeCreate('connectedCheck')
                     tasks.maybeCreate('check')
+                    tasks.maybeCreate('deviceCheck')
                 }
             }
         }
@@ -107,6 +117,14 @@ class ContinuousIntegrationPlugin implements Plugin<Project> {
             }
         }
 
+        project.task('deviceCheckChanged') { task ->
+            task.group = 'verification'
+            task.description = 'Runs the deviceCheck task in all changed projects.'
+            affectedProjects.each {
+                task.dependsOn("$it.path:deviceCheckDependents")
+            }
+        }
+
         project.task('ciTasksSanityCheck') {
             doLast {
                 [':firebase-common', ':tools:errorprone'].each { projectName ->
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/Environment.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/Environment.groovy
new file mode 100644
index 000000000..4ad55efc8
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/Environment.groovy
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.ci
+
+import java.util.regex.Matcher
+import java.util.regex.Pattern
+
+class Environment {
+    private static final Pattern ENV_PATTERN = Pattern.compile(/\$\(([A-Za-z0-9_-]+)\)/)
+
+    static String expand(String value) {
+        Matcher m = ENV_PATTERN.matcher(value)
+        while (m.find()) {
+            value = value.replace(m.group(), env(m.group(1)))
+        }
+        return value
+
+    }
+
+    private static String env(String varName) {
+        return Optional.ofNullable(System.getenv(varName)).orElse('')
+    }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabExtension.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabExtension.groovy
new file mode 100644
index 000000000..62f61f1e6
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabExtension.groovy
@@ -0,0 +1,19 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.ci.device;
+
+class FirebaseTestLabExtension {
+    List<String> devices = ['model=Pixel2,version=27,locale=en,orientation=portrait']
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabPlugin.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabPlugin.groovy
new file mode 100644
index 000000000..937f4c2bd
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestLabPlugin.groovy
@@ -0,0 +1,26 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.ci.device
+
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+
+class FirebaseTestLabPlugin implements Plugin<Project>{
+    @Override
+    void apply(Project project) {
+        def extension = project.extensions.create('firebaseTestLab', FirebaseTestLabExtension.class)
+        project.android.testServer(new FirebaseTestServer(project, extension))
+    }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy
new file mode 100644
index 000000000..100c29622
--- /dev/null
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/device/FirebaseTestServer.groovy
@@ -0,0 +1,76 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.gradle.plugins.ci.device
+
+import com.android.builder.testing.api.TestServer
+import com.google.firebase.gradle.plugins.ci.Environment
+
+import java.nio.file.Paths
+import org.gradle.api.Project
+
+
+class FirebaseTestServer extends TestServer {
+    private static final String DEFAULT_BUCKET_NAME = 'android-ci'
+    final Project project
+    final FirebaseTestLabExtension extension
+    final Random random
+
+    FirebaseTestServer(Project project, FirebaseTestLabExtension extension) {
+        this.project = project
+        this.extension = extension
+        this.random = new Random(System.currentTimeMillis())
+    }
+
+    @Override
+    String getName() {
+        return "firebase-test-lab"
+    }
+
+    @Override
+    void uploadApks(String variantName, File testApk, File testedApk) {
+        // test lab requires an "app" apk, so we give an empty apk to it.
+        String testedApkPath = testedApk ?: "$project.rootDir/buildSrc/resources/dummy.apk"
+
+        project.logger.warn("Uploading for $variantName: testApk=$testApk, testedApk=$testedApkPath")
+
+        def devicesCmd = extension.devices.collectMany { ['--device', it] }
+
+        def resultsArgs = getResultUploadArgs()
+
+        project.exec {
+            commandLine('gcloud', 'firebase', 'test', 'android', 'run',
+                    '--type=instrumentation',
+                    "--app=$testedApkPath", "--test=$testApk",
+                    '--no-auto-google-login', '--no-record-video', '--no-performance-metrics', '-q',
+                    *resultsArgs, *devicesCmd)
+        }
+    }
+
+    @Override
+    boolean isConfigured() {
+        return true
+    }
+
+    private List<String> getResultUploadArgs() {
+        Optional<String> resultsBucket = Optional.ofNullable(System.getenv('FTL_RESULTS_BUCKET')).map(Environment.&expand)
+        Optional<String> resultsDir = Optional.ofNullable(System.getenv('FTL_RESULTS_DIR')).map(Environment.&expand)
+
+        List<String> args = ['--results-bucket', resultsBucket.orElse(DEFAULT_BUCKET_NAME)]
+        if (resultsDir.isPresent()) {
+            args += ['--results-dir', Paths.get(resultsDir.get(), "${project.path}_${random.nextLong()}")]
+        }
+        return args
+    }
+}
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/Metrics.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/Metrics.java
index f96e7ee90..5f12ceb35 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/Metrics.java
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/Metrics.java
@@ -14,7 +14,10 @@
 
 package com.google.firebase.gradle.plugins.ci.metrics;
 
+import java.util.function.Predicate;
 import org.gradle.api.Task;
+import org.gradle.api.logging.LogLevel;
+import org.gradle.api.logging.Logger;
 
 /** Provides methods for measuring various parts of the build. */
 interface Metrics {
@@ -23,4 +26,41 @@
 
   /** Measure task execution failure. */
   void measureFailure(Task task);
+
+  /**
+   * Creates a {@link Metrics} implementation that uses a {@code predicate} to determine whether to
+   * emit measurements for it.
+   */
+  static Metrics filtered(Metrics metrics, Predicate<Task> predicate) {
+    return new Metrics() {
+      @Override
+      public void measureSuccess(Task task, long elapsedTime) {
+        if (predicate.test(task)) {
+          metrics.measureSuccess(task, elapsedTime);
+        }
+      }
+
+      @Override
+      public void measureFailure(Task task) {
+        if (predicate.test(task)) {
+          metrics.measureFailure(task);
+        }
+      }
+    };
+  }
+
+  /** Creates a {@link Metrics} implementation that logs results at the specified level. */
+  static Metrics toLog(Logger toLogger, LogLevel level) {
+    return new Metrics() {
+      @Override
+      public void measureSuccess(Task task, long elapsedTime) {
+        toLogger.log(level, "[METRICS] Task {} took {}ms.", task.getPath(), elapsedTime);
+      }
+
+      @Override
+      public void measureFailure(Task task) {
+        toLogger.log(level, "[METRICS] Task {} failed.", task.getPath());
+      }
+    };
+  }
 }
diff --git a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/MetricsPlugin.java b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/MetricsPlugin.java
index 910c4fe59..3c538092f 100644
--- a/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/MetricsPlugin.java
+++ b/buildSrc/src/main/groovy/com/google/firebase/gradle/plugins/ci/metrics/MetricsPlugin.java
@@ -16,26 +16,39 @@
 
 import org.gradle.api.Plugin;
 import org.gradle.api.Project;
+import org.gradle.api.Task;
 import org.gradle.api.execution.TaskExecutionGraph;
+import org.gradle.api.logging.LogLevel;
 
 /** Instruments Gradle to measure latency and success rate of all executed tasks. */
 public class MetricsPlugin implements Plugin<Project> {
   @Override
   public void apply(Project project) {
-    if (!isCollectionEnabled()) {
-      project.getLogger().lifecycle("Metrics collection is disabled.");
-      return;
-    }
-    project.getLogger().lifecycle("Metrics collection is enabled.");
 
-    Metrics metrics = new StackdriverMetrics(project.getGradle(), project.getLogger());
+    Metrics metrics = Metrics.filtered(initializeMetrics(project), MetricsPlugin::isTaskPublic);
 
     TaskExecutionGraph taskGraph = project.getGradle().getTaskGraph();
     taskGraph.addTaskExecutionListener(new MeasuringTaskExecutionListener(metrics, taskGraph));
   }
 
+  private static Metrics initializeMetrics(Project project) {
+    if (!isCollectionEnabled()) {
+      project.getLogger().lifecycle("Metrics collection is disabled. Logging to stdout...");
+      return Metrics.toLog(project.getLogger(), LogLevel.LIFECYCLE);
+    }
+    project.getLogger().lifecycle("Metrics collection is enabled.");
+    return new StackdriverMetrics(project.getGradle(), project.getLogger());
+  }
+
   private static boolean isCollectionEnabled() {
     String enabled = System.getenv("FIREBASE_ENABLE_METRICS");
     return enabled != null && enabled.equals("1");
   }
+
+  /**
+   * Determines whether a given gradle {@link Task} is "public", e.g. visible with `gradle tasks`.
+   */
+  private static boolean isTaskPublic(Task task) {
+    return task.getGroup() != null;
+  }
 }
diff --git a/ci/fireci/setup.py b/ci/fireci/setup.py
index 20c266f8d..22bb08778 100755
--- a/ci/fireci/setup.py
+++ b/ci/fireci/setup.py
@@ -24,13 +24,9 @@
 setup(
     name='fireci',
     version='0.1',
-    # this is a temporary measure until opencensus 0.2 release is out.
-    dependency_links=[
-        'https://github.com/census-instrumentation/opencensus-python/tarball/master#egg=opencensus'
-    ],
     install_requires=[
         'click==7.0',
-        'opencensus',
+        'opencensus==0.2.0',
         'google-cloud-monitoring==0.31.1',
     ],
     packages=find_packages(exclude=['tests']),
diff --git a/docs/README.md b/docs/README.md
new file mode 100644
index 000000000..70815fdd1
--- /dev/null
+++ b/docs/README.md
@@ -0,0 +1,30 @@
+# Firebase Android SDK
+
+The Firebase SDK for Android is the official way to add Firebase to your
+Android app. To get started, visit the [setup instructions][android-setup].
+
+## Open Source
+
+This repository includes the following Firebase SDKs for Android:
+
+  * `firebase-common`
+  * `firebase-database`
+  * `firebase-firestore`
+  * `firebase-functions`
+  * `firebase-inappmessaging-display`
+  * `firebase-storage`
+
+For more information on building the SDKs from source or contributing,
+visit the [main README][main-readme].
+
+## Kotlin Extensions
+
+The following Firebase SDKs for Android have Kotlin extension libraries
+that allow you to write more idiomatic Kotlin code when using Firebase
+in your app:
+
+  * [`firebase-common`](ktx/common.md)
+  * [`firebase-firestore`](ktx/firestore.md)
+
+[android-setup]: https://firebase.google.com/docs/android/setup
+[main-readme]: https://github.com/firebase/firebase-android-sdk/blob/master/README.md
\ No newline at end of file
diff --git a/docs/ktx/common.md b/docs/ktx/common.md
new file mode 100644
index 000000000..3935c9e1b
--- /dev/null
+++ b/docs/ktx/common.md
@@ -0,0 +1,42 @@
+# Firebase Common Kotlin Extensions
+
+## Getting Started
+
+To use the Firebase Common Android SDK with Kotlin Extensions, add the following
+to your app's `build.gradle` file:
+
+```groovy
+// See maven.google.com for the latest versions
+// This library transitively includes the firebase-common library
+implementation 'com.google.firebase:firebase-common-ktx:$VERSION'
+```
+
+## Features
+
+### Get the default FirebaseApp and FirebaseOptions
+
+**Kotlin**
+```kotlin
+val defaultApp = FirebaseApp.getInstance()
+val defaultOptions = defaultApp.options
+```
+
+**Kotlin + KTX**
+```kotlin
+val defaultApp = Firebase.app
+val defaultOptions = Firebase.options
+```
+
+### Initialize a FirebaseApp
+
+**Kotlin**
+```kotlin
+val options = FirebaseApp.getInstance().options
+val anotherApp = FirebaseApp.initializeApp(context, options, "myApp")
+```
+
+**Kotlin + KTX**
+```kotlin
+var anotherApp = Firebase.initialize(context, Firebase.options, "myApp")
+```
+
diff --git a/docs/ktx/firestore.md b/docs/ktx/firestore.md
new file mode 100644
index 000000000..248c71085
--- /dev/null
+++ b/docs/ktx/firestore.md
@@ -0,0 +1,70 @@
+# Firestore Kotlin Extensions
+
+## Getting Started
+
+To use the Cloud Firestore Android SDK with Kotlin Extensions, add the following
+to your app's `build.gradle` file:
+
+```groovy
+// See maven.google.com for the latest versions
+// This library transitively includes the firebase-firestore library
+implementation 'com.google.firebase:firebase-firestore-ktx:$VERSION'
+```
+
+## Features
+
+### Get an instance of FirebaseFirestore
+
+**Kotlin**
+```kotlin
+val firestore = FirebaseFirestore.getInstance()
+val anotherFirestore = FirebaseFirestore.getInstance(FirebaseApp.getInstance("myApp"))
+```
+
+**Kotlin + KTX**
+```kotlin
+val firestore = Firebase.firestore
+val anotherFirestore = Firebase.firestore(Firebase.app("myApp"))
+```
+
+### Convert a DocumentSnapshot field to a POJO
+
+**Kotlin**
+```kotlin
+val snapshot: DocumentSnapshot = ...
+val myObject = snapshot.get("fieldPath", MyClass::class.java)
+```
+
+**Kotlin + KTX**
+```kotlin
+val snapshot: DocumentSnapshot = ...
+val myObject = snapshot.get<MyClass>("fieldPath")
+```
+
+### Convert a DocumentSnapshot to a POJO
+
+**Kotlin**
+```kotlin
+val snapshot: DocumentSnapshot = ...
+val myObject = snapshot.toObject(MyClass::class.java)
+```
+
+**Kotlin + KTX**
+```kotlin
+val snapshot: DocumentSnapshot = ...
+val myObject = snapshot.toObject<MyClass>()
+```
+
+### Convert a QuerySnapshot to a list of POJOs
+
+**Kotlin**
+```kotlin
+val snapshot: QuerySnapshot = ...
+val objectList = snapshot.toObjects(MyClass::class.java)
+```
+
+**Kotlin + KTX**
+```kotlin
+val snapshot: QuerySnapshot = ...
+val objectList = snapshot.toObjects<MyClass>()
+```
\ No newline at end of file
diff --git a/fiamui-app/fiamui-app.gradle b/fiamui-app/fiamui-app.gradle
index 2d00192c0..db3061c13 100644
--- a/fiamui-app/fiamui-app.gradle
+++ b/fiamui-app/fiamui-app.gradle
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 apply plugin: "com.android.application"
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
   compileSdkVersion project.targetSdkVersion
diff --git a/firebase-common-ktx/gradle.properties b/firebase-common-ktx/gradle.properties
index e70417a1b..67b166461 100644
--- a/firebase-common-ktx/gradle.properties
+++ b/firebase-common-ktx/gradle.properties
@@ -1,2 +1,2 @@
-version=17.0.0-alpha01
+version=16.1.0
 android.enableUnitTestBinaryResources=true
diff --git a/firebase-common-ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt b/firebase-common-ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
index 845dfa507..bccab135f 100644
--- a/firebase-common-ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
+++ b/firebase-common-ktx/src/main/kotlin/com/google/firebase/ktx/Firebase.kt
@@ -36,21 +36,21 @@ val Firebase.app: FirebaseApp
 fun Firebase.app(name: String): FirebaseApp = FirebaseApp.getInstance(name)
 
 /** Initializes and returns a FirebaseApp. */
-fun Firebase.initialize(context: Context) = FirebaseApp.initializeApp(context)
+fun Firebase.initialize(context: Context): FirebaseApp? = FirebaseApp.initializeApp(context)
 
 /** Initializes and returns a FirebaseApp. */
-fun Firebase.initialize(context: Context, options: FirebaseOptions) =
+fun Firebase.initialize(context: Context, options: FirebaseOptions): FirebaseApp =
         FirebaseApp.initializeApp(context, options)
 
 /** Initializes and returns a FirebaseApp. */
-fun Firebase.initialize(context: Context, options: FirebaseOptions, name: String) =
+fun Firebase.initialize(context: Context, options: FirebaseOptions, name: String): FirebaseApp =
         FirebaseApp.initializeApp(context, options, name)
 
 /** Returns options of default FirebaseApp */
 val Firebase.options: FirebaseOptions
     get() = Firebase.app.options
 
-/** @hide */
+/** @suppress */
 @Keep
 class FirebaseCommonKtxRegistrar : ComponentRegistrar {
     override fun getComponents(): List<Component<*>> {
diff --git a/firebase-common-ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt b/firebase-common-ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
index 0bfda2e8a..87eea2af8 100644
--- a/firebase-common-ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
+++ b/firebase-common-ktx/src/test/kotlin/com/google/firebase/ktx/Tests.kt
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package com.google.firebase.ktx;
+package com.google.firebase.ktx
 
 import com.google.common.truth.Truth.assertThat
 import com.google.firebase.FirebaseApp
diff --git a/firebase-common/firebase-common.gradle b/firebase-common/firebase-common.gradle
index ff22e2286..5032843c7 100644
--- a/firebase-common/firebase-common.gradle
+++ b/firebase-common/firebase-common.gradle
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 apply plugin: 'com.android.library'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
     adbOptions {
diff --git a/firebase-common/gradle.properties b/firebase-common/gradle.properties
index b06f769c0..9fcdf80f7 100644
--- a/firebase-common/gradle.properties
+++ b/firebase-common/gradle.properties
@@ -1,2 +1,2 @@
-version=16.1.0
-latestReleasedVersion=16.0.4
+version=16.1.1
+latestReleasedVersion=16.1.0
diff --git a/firebase-common/src/main/java/com/google/firebase/annotations/PublicApi.java b/firebase-common/src/main/java/com/google/firebase/annotations/PublicApi.java
index 23dd2313d..9af7ff6e9 100644
--- a/firebase-common/src/main/java/com/google/firebase/annotations/PublicApi.java
+++ b/firebase-common/src/main/java/com/google/firebase/annotations/PublicApi.java
@@ -21,6 +21,10 @@
 /**
  * Indicates that this object (class, method, etc) should be retained while preguarding an SDK, but
  * is safe to be proguarded away in the final app.
+ *
+ * <p>NOTE: For projects /not/ using proguard, the PublicApi annotation acts merely as a convention
+ * and has no actual impact. These projects must abide by normal java visibility rules to govern the
+ * visibility of methods in their public API.
  */
 @KeepForSdk
 @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
diff --git a/firebase-database-collection/firebase-database-collection.gradle b/firebase-database-collection/firebase-database-collection.gradle
index e87098fb9..1ebe73844 100644
--- a/firebase-database-collection/firebase-database-collection.gradle
+++ b/firebase-database-collection/firebase-database-collection.gradle
@@ -17,13 +17,17 @@ apply plugin: 'com.android.library'
 android {
     compileSdkVersion project.targetSdkVersion
     defaultConfig {
-        minSdkVersion 9
+        targetSdkVersion project.targetSdkVersion
+        minSdkVersion project.minSdkVersion
     }
 }
 
 dependencies {
+    implementation "com.google.android.gms:play-services-base:$playServicesVersion"
+
     testImplementation 'junit:junit:4.12'
     testImplementation 'net.java:quickcheck:0.6'
+
     testAnnotationProcessor 'net.java:quickcheck-src-generator:0.6'
     testAnnotationProcessor 'net.java.quickcheck:quickcheck-src-generator:0.6'
 }
diff --git a/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java b/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
index 89daa4643..149650472 100644
--- a/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
+++ b/firebase-database-collection/src/main/java/com/google/firebase/database/collection/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.database.collection;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/CHANGELOG.md b/firebase-database/CHANGELOG.md
new file mode 100644
index 000000000..4d78b5421
--- /dev/null
+++ b/firebase-database/CHANGELOG.md
@@ -0,0 +1,12 @@
+# Unreleased
+- [changed] Added `@RestrictTo` annotations to discourage the use of APIs that
+  are not public. This affects internal APIs that were previously obfuscated
+  and are not mentioned in our documentation.
+- [changed] Improved error messages for certain Number types that are not
+  supported by our serialization layer (#272).
+- [internal] Updated the SDK initialization process and removed usages of
+  deprecated method
+
+# 16.0.6  
+- [fixed] Fixed an issue that could cause a NullPointerException during the
+  initial handshake with the Firebase backend (#119).
diff --git a/firebase-database/firebase-database.gradle b/firebase-database/firebase-database.gradle
index cf7520088..50ece209d 100644
--- a/firebase-database/firebase-database.gradle
+++ b/firebase-database/firebase-database.gradle
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 apply plugin: 'com.android.library'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
     adbOptions {
@@ -69,6 +70,9 @@ dependencies {
     implementation "com.google.android.gms:play-services-basement:$playServicesVersion"
     implementation "com.google.android.gms:play-services-base:$playServicesVersion"
     implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
+    implementation('com.google.firebase:firebase-auth-interop:16.0.1') {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
 
     androidTestImplementation "com.android.support:support-annotations:$supportAnnotationsVersion"
     androidTestImplementation 'com.android.support.test:rules:1.0.2'
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
index c9a27f8ed..cad2393d6 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/DataTest.java
@@ -53,18 +53,18 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
   public void basicInstantiation() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     assertTrue(ref != null);
   }
 
   @Test
   public void writeData() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     // just make sure it doesn't throw
     ref.setValue(42);
     assertTrue(true);
@@ -74,7 +74,7 @@ public void writeData() throws DatabaseException {
   public void readAndWrite()
       throws DatabaseException, ExecutionException, InterruptedException, TimeoutException,
           TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ReadFuture future = ReadFuture.untilNonNull(ref);
 
     ref.setValue(42);
@@ -90,7 +90,7 @@ public void valueReturnsJSONForNodesWithChildren()
     innerExpected.put("bar", 5L);
     expected.put("foo", innerExpected);
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture future = ReadFuture.untilNonNull(ref);
 
@@ -104,7 +104,7 @@ public void valueReturnsJSONForNodesWithChildren()
   @Test
   public void writeDataAndWaitForServerConfirmation()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.setValue(42);
 
     ReadFuture future = new ReadFuture(ref);
@@ -117,7 +117,7 @@ public void writeDataAndWaitForServerConfirmation()
   public void writeAValueReconnectRead()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -136,7 +136,7 @@ public void writeAValueReconnectRead()
   public void writeABunchOfDataReconnectRead()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -167,7 +167,7 @@ public void writeABunchOfDataReconnectRead()
   @Test
   public void writeLeafNodeOverwriteParentNodeWaitForEvents()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
@@ -189,7 +189,7 @@ public void writeLeafNodeOverwriteParentNodeWaitForEvents()
   @Test
   public void writeLeafNodeOverwriteAtParentMultipleTimesWaitForExpectedEvents()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicInteger bbCount = new AtomicInteger(0);
     ValueEventListener listener =
@@ -233,7 +233,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void writeParentNodeOverwriteAtLeafNodeWaitForEvents()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
@@ -256,7 +256,7 @@ public void writeParentNodeOverwriteAtLeafNodeWaitForEvents()
   public void writeLeafNodeRemoveParentWaitForEvents()
       throws DatabaseException, InterruptedException, TimeoutException, TestFailure,
           ExecutionException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -307,8 +307,8 @@ public void writeLeafNodeRemoveParentWaitForEvents()
     readHelper.cleanup();
 
     // Make sure we actually have null there now
-    assertNull(TestHelpers.getSnap(reader).getValue());
-    assertNull(TestHelpers.getSnap(writer).getValue());
+    assertNull(IntegrationTestHelpers.getSnap(reader).getValue());
+    assertNull(IntegrationTestHelpers.getSnap(writer).getValue());
 
     ReadFuture readFuture = ReadFuture.untilNonNull(reader);
 
@@ -332,7 +332,7 @@ public void writeLeafNodeRemoveParentWaitForEvents()
   public void writeLeafNodeRemoveLeafNodeWaitForEvents()
       throws DatabaseException, InterruptedException, TimeoutException, TestFailure,
           ExecutionException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -382,16 +382,16 @@ public void writeLeafNodeRemoveLeafNodeWaitForEvents()
     writeHelper.cleanup();
     readHelper.cleanup();
 
-    DataSnapshot readerSnap = TestHelpers.getSnap(reader);
+    DataSnapshot readerSnap = IntegrationTestHelpers.getSnap(reader);
     assertNull(readerSnap.getValue());
 
-    DataSnapshot writerSnap = TestHelpers.getSnap(writer);
+    DataSnapshot writerSnap = IntegrationTestHelpers.getSnap(writer);
     assertNull(writerSnap.getValue());
 
-    readerSnap = TestHelpers.getSnap(reader.child("a/aa"));
+    readerSnap = IntegrationTestHelpers.getSnap(reader.child("a/aa"));
     assertNull(readerSnap.getValue());
 
-    writerSnap = TestHelpers.getSnap(writer.child("a/aa"));
+    writerSnap = IntegrationTestHelpers.getSnap(writer.child("a/aa"));
     assertNull(writerSnap.getValue());
 
     ReadFuture readFuture = ReadFuture.untilNonNull(reader);
@@ -414,7 +414,7 @@ public void writeLeafNodeRemoveLeafNodeWaitForEvents()
   @Test
   public void writeMultipleLeafNodesRemoveOneLeafNodeWaitForEvents()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -470,8 +470,8 @@ public void writeMultipleLeafNodesRemoveOneLeafNodeWaitForEvents()
     assertTrue(writeHelper.waitForEvents());
     assertTrue(readHelper.waitForEvents());
 
-    DataSnapshot readerSnap = TestHelpers.getSnap(reader);
-    DataSnapshot writerSnap = TestHelpers.getSnap(writer);
+    DataSnapshot readerSnap = IntegrationTestHelpers.getSnap(reader);
+    DataSnapshot writerSnap = IntegrationTestHelpers.getSnap(writer);
     Map<String, Object> expected =
         new MapBuilder().put("a", new MapBuilder().put("bb", 24L).build()).build();
     DeepEquals.assertEquals(expected, readerSnap.getValue());
@@ -483,7 +483,7 @@ public void writeMultipleLeafNodesRemoveOneLeafNodeWaitForEvents()
 
   @Test
   public void verifyCantNameNodesStartingWithAPeriod() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     try {
       ref.child(".foo");
       fail("Should fail");
@@ -504,14 +504,14 @@ public void verifyCantNameNodesStartingWithAPeriod() throws DatabaseException {
 
   @Test
   public void numericKeysGetTurnedIntoArrays() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.child("0").setValue("alpha");
     ref.child("1").setValue("bravo");
     ref.child("2").setValue("charlie");
     ref.child("3").setValue("delta");
     ref.child("4").setValue("echo");
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     List<Object> expected = new ArrayList<Object>();
     expected.addAll(Arrays.asList((Object) "alpha", "bravo", "charlie", "delta", "echo"));
     DeepEquals.assertEquals(expected, snap.getValue());
@@ -520,7 +520,7 @@ public void numericKeysGetTurnedIntoArrays() throws DatabaseException, Interrupt
   @Test
   public void canWriteFullJSONObjectsWithSetAndGetThemBack()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> expected =
         new MapBuilder()
@@ -560,7 +560,7 @@ public void canWriteFullJSONObjectsWithSetAndGetThemBack()
   public void removeCallbackIsHit()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     WriteFuture writeFuture = new WriteFuture(ref, 42);
     writeFuture.timedGet();
@@ -593,7 +593,7 @@ public void onComplete(DatabaseError error, DatabaseReference callbackRef) {
   @Test
   public void removeCallbackIsHitForNodesThatAreAlreadyRemoved()
       throws DatabaseException, InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore callbackHit = new Semaphore(0);
     ref.removeValue(
@@ -620,7 +620,7 @@ public void onComplete(DatabaseError error, DatabaseReference callbackRef) {
   @Test
   public void usingNumbersAsKeysDoesntCreateHugeSparseArrays()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.child("3024").setValue(5);
     ReadFuture future = new ReadFuture(ref);
 
@@ -632,7 +632,7 @@ public void usingNumbersAsKeysDoesntCreateHugeSparseArrays()
   public void onceWithCallbackHitsServerToGetData()
       throws DatabaseException, InterruptedException, ExecutionException, TimeoutException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(3);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(3);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     DatabaseReference reader2 = refs.get(2);
@@ -652,7 +652,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     new WriteFuture(writer, 42).timedGet();
 
     reader2.addListenerForSingleValueEvent(
@@ -669,7 +669,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   // NOTE: skipping forEach abort test. Not relevant, we return an iterable that can be stopped any
@@ -679,7 +679,7 @@ public void onCancelled(DatabaseError error) {
   public void setAndThenListenForValueEvents()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, "cabbage").timedGet();
     EventRecord event = new ReadFuture(ref).timedGet().get(0);
@@ -690,7 +690,7 @@ public void setAndThenListenForValueEvents()
   @Test
   public void hasChildrenWorksCorrectly()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -734,7 +734,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void setANodeWithChildrenToAPrimitiveThenBack()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     final DatabaseReference writer = refs.get(1);
 
@@ -790,7 +790,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void writeLeafNodeRemoveItTryToAddChildToRemovedNode()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -807,7 +807,7 @@ public void writeLeafNodeRemoveItTryToAddChildToRemovedNode()
   public void listenForValueThenWriteOnANodeWithExistingData()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -826,7 +826,7 @@ public void listenForValueThenWriteOnANodeWithExistingData()
 
   @Test
   public void setPriorityOnNonexistentNodeFails() throws DatabaseException, InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ref.setPriority(
@@ -845,7 +845,7 @@ public void onComplete(DatabaseError error, DatabaseReference callbackRef) {
 
   @Test
   public void setPriorityOnExistingNodeSucceeds() throws DatabaseException, InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue("hello!");
     final Semaphore semaphore = new Semaphore(0);
@@ -867,7 +867,7 @@ public void onComplete(DatabaseError error, DatabaseReference callbackRef) {
   public void setWithPrioritySetsPriorityAndValue()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -893,7 +893,7 @@ public void setWithPrioritySetsPriorityAndValue()
   public void setOverwritesPriorityOfTopLevelNodesAndSubnodes()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -912,7 +912,7 @@ public void setOverwritesPriorityOfTopLevelNodesAndSubnodes()
   public void setWithPriorityOfALeafSavesCorrectly()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -927,7 +927,7 @@ public void setWithPriorityOfALeafSavesCorrectly()
   public void setPriorityOfAnObjectSavesCorrectly()
       throws DatabaseException, ExecutionException, TimeoutException, InterruptedException,
           TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -943,7 +943,7 @@ public void setPriorityOfAnObjectSavesCorrectly()
   @Test
   public void getPriorityReturnsTheCorrectType()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCountAfterNull(ref, 7);
 
@@ -970,7 +970,7 @@ public void normalizeDifferentIntegerAndDoubleValues()
       throws DatabaseException, InterruptedException, TimeoutException, TestFailure {
     final long intMaxPlusOne = 2147483648L;
 
-    DatabaseReference node = TestHelpers.getRandomNode();
+    DatabaseReference node = IntegrationTestHelpers.getRandomNode();
 
     Object[] writtenValues = {
       intMaxPlusOne,
@@ -1002,7 +1002,7 @@ public void normalizeDifferentIntegerAndDoubleValues()
   @Test
   public void exportFormatIncludesPriorities()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> expected =
         new MapBuilder()
@@ -1023,7 +1023,7 @@ public void exportFormatIncludesPriorities()
   @Test
   public void priorityIsOverwrittenByServerPriority()
       throws DatabaseException, TimeoutException, InterruptedException, TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     final DatabaseReference ref2 = refs.get(1);
 
@@ -1060,7 +1060,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void largeNumericPrioritiesWork()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException,
           ExecutionException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -1075,7 +1075,7 @@ public void largeNumericPrioritiesWork()
   public void urlEncodingAndDecodingWorks()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     DatabaseReference ref =
         new DatabaseReference(
@@ -1087,7 +1087,7 @@ public void urlEncodingAndDecodingWorks()
 
     String child = "" + new Random().nextInt(100000000);
     new WriteFuture(ref.child(child), "testdata").timedGet();
-    DataSnapshot snap = TestHelpers.getSnap(ref.child(child));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.child(child));
     assertEquals("testdata", snap.getValue());
   }
 
@@ -1095,7 +1095,7 @@ public void urlEncodingAndDecodingWorks()
   public void nameWorksForRootAndNonRootLocations()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     DatabaseReference ref = new DatabaseReference(IntegrationTestValues.getNamespace(), ctx);
     assertNull(ref.getKey());
@@ -1107,13 +1107,13 @@ public void nameWorksForRootAndNonRootLocations()
   public void nameAndRefWorkForSnapshots()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     DatabaseReference ref = new DatabaseReference(IntegrationTestValues.getNamespace(), ctx);
     // Clear any data there
     new WriteFuture(ref, new MapBuilder().put("foo", 10).build()).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     assertNull(snap.getKey());
     assertEquals(ref.toString(), snap.getRef().toString());
     DataSnapshot childSnap = snap.child("a");
@@ -1126,7 +1126,7 @@ public void nameAndRefWorkForSnapshots()
 
   @Test
   public void parentWorksForRootAndNonRootLocations() throws DatabaseException {
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     DatabaseReference ref = new DatabaseReference(IntegrationTestValues.getNamespace(), ctx);
     assertNull(ref.getParent());
@@ -1138,7 +1138,7 @@ public void parentWorksForRootAndNonRootLocations() throws DatabaseException {
 
   @Test
   public void rootWorksForRootAndNonRootLocations() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref = ref.getRoot();
     assertEquals(IntegrationTestValues.getNamespace(), ref.toString());
@@ -1154,7 +1154,7 @@ public void rootWorksForRootAndNonRootLocations() throws DatabaseException {
   public void setAChildAndListenAtTheRoot()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -1166,12 +1166,12 @@ public void setAChildAndListenAtTheRoot()
 
   @Test
   public void accessingInvalidPathsShouldThrow() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     List<String> badPaths = Arrays.asList(".test", "test.", "fo$o", "[what", "ever]", "ha#sh");
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
 
     for (String path : badPaths) {
       try {
@@ -1213,7 +1213,7 @@ public void accessingInvalidPathsShouldThrow() throws DatabaseException, Interru
 
   @Test
   public void invalidKeysThrowErrors() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     List<String> badKeys =
         Arrays.asList(
@@ -1249,7 +1249,7 @@ public void invalidKeysThrowErrors() throws DatabaseException {
 
   @Test
   public void invalidUpdateThrowErrors() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     List<Map<String, Object>> badUpdates =
         Arrays.asList(
@@ -1281,11 +1281,11 @@ public void invalidUpdateThrowErrors() throws DatabaseException {
   @Test
   public void asciiControlCharactersIllegal()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference node = TestHelpers.getRandomNode();
+    DatabaseReference node = IntegrationTestHelpers.getRandomNode();
     // Test all controls characters PLUS 0x7F (127).
     for (int i = 0; i <= 32; i++) {
       String ch = new String(Character.toChars(i < 32 ? i : 127));
-      HashMap obj = TestHelpers.buildObjFromPath(new Path(ch), "test_value");
+      HashMap obj = IntegrationTestHelpers.buildObjFromPath(new Path(ch), "test_value");
       try {
         node.setValue(obj);
         fail("Ascii control character should not be allowed in path.");
@@ -1298,7 +1298,7 @@ public void asciiControlCharactersIllegal()
   @Test
   public void invalidDoubleValues()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference node = TestHelpers.getRandomNode();
+    DatabaseReference node = IntegrationTestHelpers.getRandomNode();
     Object[] invalidValues =
         new Object[] {
           Double.NEGATIVE_INFINITY,
@@ -1328,10 +1328,10 @@ public void pathKeyLengthLimits()
 
     List<String> goodKeys =
         Arrays.asList(
-            TestHelpers.repeatedString("k", maxPathLengthBytes - 1),
-            TestHelpers.repeatedString(fire, maxPathLengthBytes / 4 - 1),
-            TestHelpers.repeatedString(base, maxPathLengthBytes / 3 - 1),
-            TestHelpers.repeatedString("key/", maxPathDepth - 1) + "key");
+            IntegrationTestHelpers.repeatedString("k", maxPathLengthBytes - 1),
+            IntegrationTestHelpers.repeatedString(fire, maxPathLengthBytes / 4 - 1),
+            IntegrationTestHelpers.repeatedString(base, maxPathLengthBytes / 3 - 1),
+            IntegrationTestHelpers.repeatedString("key/", maxPathDepth - 1) + "key");
 
     class BadGroup {
       String expectedError;
@@ -1348,25 +1348,26 @@ public void pathKeyLengthLimits()
             new BadGroup(
                 "key path longer than 768 bytes",
                 Arrays.asList(
-                    TestHelpers.repeatedString("k", maxPathLengthBytes),
-                    TestHelpers.repeatedString(fire, maxPathLengthBytes / 4),
-                    TestHelpers.repeatedString(base, maxPathLengthBytes / 3),
-                    TestHelpers.repeatedString("j", maxPathLengthBytes / 2)
+                    IntegrationTestHelpers.repeatedString("k", maxPathLengthBytes),
+                    IntegrationTestHelpers.repeatedString(fire, maxPathLengthBytes / 4),
+                    IntegrationTestHelpers.repeatedString(base, maxPathLengthBytes / 3),
+                    IntegrationTestHelpers.repeatedString("j", maxPathLengthBytes / 2)
                         + '/'
-                        + TestHelpers.repeatedString("k", maxPathLengthBytes / 2))),
+                        + IntegrationTestHelpers.repeatedString("k", maxPathLengthBytes / 2))),
             new BadGroup(
                 "Path specified exceeds the maximum depth",
-                Arrays.asList(TestHelpers.repeatedString("key/", maxPathDepth) + "key")));
+                Arrays.asList(
+                    IntegrationTestHelpers.repeatedString("key/", maxPathDepth) + "key")));
 
-    DatabaseReference node = TestHelpers.getRandomNode().getRoot();
+    DatabaseReference node = IntegrationTestHelpers.getRandomNode().getRoot();
 
     // Ensure "good keys" work from the root.
     for (String key : goodKeys) {
       Path path = new Path(key);
-      HashMap obj = TestHelpers.buildObjFromPath(path, "test_value");
+      HashMap obj = IntegrationTestHelpers.buildObjFromPath(path, "test_value");
       node.setValue(obj);
       ReadFuture future = ReadFuture.untilNonNull(node);
-      assertEquals("test_value", TestHelpers.applyPath(future.waitForLastValue(), path));
+      assertEquals("test_value", IntegrationTestHelpers.applyPath(future.waitForLastValue(), path));
 
       node.child(key).setValue("another_value");
       future = ReadFuture.untilNonNull(node.child(key));
@@ -1374,13 +1375,13 @@ public void pathKeyLengthLimits()
 
       node.updateChildren(obj);
       future = ReadFuture.untilNonNull(node);
-      assertEquals("test_value", TestHelpers.applyPath(future.waitForLastValue(), path));
+      assertEquals("test_value", IntegrationTestHelpers.applyPath(future.waitForLastValue(), path));
     }
 
     // Ensure "good keys" fail when created from child node (relative paths too long).
-    DatabaseReference nodeChild = TestHelpers.getRandomNode();
+    DatabaseReference nodeChild = IntegrationTestHelpers.getRandomNode();
     for (String key : goodKeys) {
-      HashMap obj = TestHelpers.buildObjFromPath(new Path(key), "test_value");
+      HashMap obj = IntegrationTestHelpers.buildObjFromPath(new Path(key), "test_value");
       try {
         nodeChild.setValue(obj);
         fail("Too-long path for setValue should throw exception.");
@@ -1410,43 +1411,43 @@ public void pathKeyLengthLimits()
 
     for (BadGroup badGroup : badGroups) {
       for (String key : badGroup.keys) {
-        HashMap obj = TestHelpers.buildObjFromPath(new Path(key), "test_value");
+        HashMap obj = IntegrationTestHelpers.buildObjFromPath(new Path(key), "test_value");
         try {
           node.setValue(obj);
           fail("Expected setValue(bad key) to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           node.child(key).setValue("another_value");
           fail("Expected child(\"" + key + "\").setValue() to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           node.updateChildren(obj);
           fail("Expected updateChildrean(bad key) to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           Map<String, Object> deepUpdate = new MapBuilder().put(key, "test_value").build();
           node.updateChildren(deepUpdate);
           fail("Expected updateChildrean(bad deep update key) to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           node.onDisconnect().setValue(obj);
           fail("Expected onDisconnect.setValue(bad key) to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           node.onDisconnect().updateChildren(obj);
           fail("Expected onDisconnect.updateChildren(bad key) to throw exception: " + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
         try {
           Map<String, Object> deepUpdate = new MapBuilder().put(key, "test_value").build();
@@ -1455,7 +1456,7 @@ public void pathKeyLengthLimits()
               "Expected onDisconnect.updateChildren(bad deep update key) to throw exception: "
                   + key);
         } catch (DatabaseException e) {
-          TestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
+          IntegrationTestHelpers.assertContains(e.getMessage(), badGroup.expectedError);
         }
       }
     }
@@ -1465,8 +1466,8 @@ public void pathKeyLengthLimits()
   public void namespaceAreCaseInsensitive()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseConfig ctx1 = TestHelpers.getContext(0);
-    DatabaseConfig ctx2 = TestHelpers.getContext(1);
+    DatabaseConfig ctx1 = IntegrationTestHelpers.getContext(0);
+    DatabaseConfig ctx2 = IntegrationTestHelpers.getContext(1);
 
     String child = "" + new Random().nextInt(100000000);
     DatabaseReference ref1 =
@@ -1482,13 +1483,13 @@ public void namespaceAreCaseInsensitive()
             ctx2);
 
     new WriteFuture(ref1, "testdata").timedGet();
-    DataSnapshot snap = TestHelpers.getSnap(ref2);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref2);
     assertEquals("testdata", snap.getValue());
   }
 
   @Test
   public void namespacesAreCaseInsensitiveInToString() throws DatabaseException {
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     DatabaseReference ref1 = new DatabaseReference(IntegrationTestValues.getNamespace(), ctx);
     DatabaseReference ref2 =
         new DatabaseReference(
@@ -1507,11 +1508,11 @@ public void namespacesAreCaseInsensitiveInToString() throws DatabaseException {
   public void setANodeWithAQuotedKey()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> expected = new MapBuilder().put("\"herp\"", 1234L).build();
     new WriteFuture(ref, expected).timedGet();
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     DeepEquals.assertEquals(expected, snap.getValue());
   }
 
@@ -1519,7 +1520,7 @@ public void setANodeWithAQuotedKey()
   public void setAChildWithAQuote()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = new ReadFuture(ref);
     new WriteFuture(ref.child("\""), 1).timedGet();
@@ -1530,7 +1531,7 @@ public void setAChildWithAQuote()
   @Test
   public void emptyChildrenGetValueEventBeforeParent()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
@@ -1550,7 +1551,7 @@ public void emptyChildrenGetValueEventBeforeParent()
   public void onAfterSetWaitsForLatestData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -1565,7 +1566,7 @@ public void onAfterSetWaitsForLatestData()
   public void onceWaitsForLatestDataEachTime()
       throws DatabaseException, InterruptedException, TestFailure, ExecutionException,
           TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -1584,7 +1585,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     new WriteFuture(ref2, 5).timedGet();
     ref1.addListenerForSingleValueEvent(
@@ -1601,7 +1602,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     new WriteFuture(ref2, 42).timedGet();
 
@@ -1619,17 +1620,17 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void memoryFreeingOnUnlistenDoesNotCorruptData()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException,
           ExecutionException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
-    DatabaseReference other = TestHelpers.getRandomNode();
+    DatabaseReference other = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     final AtomicBoolean hasRun = new AtomicBoolean(false);
@@ -1650,7 +1651,7 @@ public void onCancelled(DatabaseError error) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     new WriteFuture(ref1, "test").timedGet();
     ref1.removeEventListener(listener);
@@ -1669,7 +1670,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     ref2.addListenerForSingleValueEvent(
         new ValueEventListener() {
@@ -1685,13 +1686,13 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void updateRaisesCorrectLocalEvents()
       throws DatabaseException, InterruptedException, TestFailure, TimeoutException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCountAfterNull(ref, 2);
 
@@ -1721,7 +1722,7 @@ public void updateRaisesCorrectLocalEvents()
   public void updateRaisesCorrectRemoteEvents()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1742,7 +1743,7 @@ public void updateRaisesCorrectRemoteEvents()
     helper.waitForEvents();
     helper.cleanup();
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     Map<String, Object> expected =
         new MapBuilder().put("a", 4L).put("b", 2L).put("c", 3L).put("d", 1L).build();
     Object result = snap.getValue();
@@ -1753,7 +1754,7 @@ public void updateRaisesCorrectRemoteEvents()
   public void updateRaisesChildEventsOnNewListener()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     EventHelper helper =
         new EventHelper()
             .addValueExpectation(ref.child("a"))
@@ -1775,7 +1776,7 @@ public void updateRaisesChildEventsOnNewListener()
   public void updateAfterSetLeafNodeWorks()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
     final Map<String, Object> expected = new MapBuilder().put("a", 1L).put("b", 2L).build();
 
@@ -1794,14 +1795,14 @@ public void onCancelled(DatabaseError error) {}
     ref.setValue(42);
     ref.updateChildren(expected);
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void updateChangesAreStoredCorrectlyByTheServer()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1820,9 +1821,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     Map<String, Object> expected =
         new MapBuilder().put("a", 42L).put("b", 2L).put("c", 3L).put("d", 4L).build();
     Object result = snap.getValue();
@@ -1832,7 +1833,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void updateDoesntAffectPriorityLocally()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCountAfterNull(ref, 2);
 
@@ -1852,14 +1853,14 @@ public void updateDoesntAffectPriorityLocally()
   public void updateDoesntAffectPriorityRemotely()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
     new WriteFuture(writer, new MapBuilder().put("a", 1).put("b", 2).put("c", 3).build(), "testpri")
         .timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     assertEquals("testpri", snap.getPriority());
 
     final Semaphore semaphore = new Semaphore(0);
@@ -1873,15 +1874,15 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
-    snap = TestHelpers.getSnap(reader);
+    IntegrationTestHelpers.waitFor(semaphore);
+    snap = IntegrationTestHelpers.getSnap(reader);
     assertEquals("testpri", snap.getPriority());
   }
 
   @Test
   public void updateReplacesChildren()
       throws DatabaseException, InterruptedException, TestFailure, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1902,9 +1903,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     DeepEquals.assertEquals(expected, snap.getValue());
 
     snap = readFuture.timedGet().get(1).getSnapshot();
@@ -1914,7 +1915,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void deepUpdateWorks()
       throws DatabaseException, InterruptedException, TestFailure, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1942,9 +1943,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     DeepEquals.assertEquals(expected, snap.getValue());
     assertEquals(3.0, snap.getPriority());
 
@@ -1952,7 +1953,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
     DeepEquals.assertEquals(expected, snap.getValue());
     assertEquals(3.0, snap.getPriority());
 
-    snap = TestHelpers.getSnap(reader.child("a/ab"));
+    snap = IntegrationTestHelpers.getSnap(reader.child("a/ab"));
     assertEquals(2.0, snap.getPriority());
   }
 
@@ -1960,7 +1961,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
 
   @Test
   public void updateWithNoChangesWorks() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ref.updateChildren(
@@ -1973,7 +1974,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   // TODO: consider implementing update stress test
@@ -1983,7 +1984,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   public void updateFiresCorrectEventWhenAChildIsDeleted()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2003,7 +2004,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     writer.updateChildren(new MapBuilder().put("a", null).build());
     DataSnapshot snap = writerFuture.timedGet().get(1).getSnapshot();
@@ -2020,7 +2021,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void updateFiresCorrectEventOnNewChildren()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2051,8 +2052,8 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(readerInitializedSemaphore);
-    TestHelpers.waitFor(writerInitializedSemaphore);
+    IntegrationTestHelpers.waitFor(readerInitializedSemaphore);
+    IntegrationTestHelpers.waitFor(writerInitializedSemaphore);
 
     writer.updateChildren(new MapBuilder().put("a", 42).build());
     DataSnapshot snap = writerFuture.timedGet().get(1).getSnapshot();
@@ -2069,7 +2070,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void updateFiresCorrectEventWhenAllChildrenAreDeleted()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2089,7 +2090,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     writer.updateChildren(new MapBuilder().put("a", null).build());
     DataSnapshot snap = writerFuture.timedGet().get(1).getSnapshot();
@@ -2105,7 +2106,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void updateFiresCorrectEventOnChangedChildren()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2125,7 +2126,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     writer.updateChildren(new MapBuilder().put("a", 11).build());
     DataSnapshot snap = writerFuture.timedGet().get(1).getSnapshot();
@@ -2140,7 +2141,7 @@ public boolean isComplete(List<EventRecord> events) {
 
   @Test
   public void updateOfPriorityWorks() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2164,9 +2165,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             semaphore.release(1);
           }
         });
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(reader);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(reader);
     assertEquals(6L, snap.child("a").getValue());
     assertEquals("pri2", snap.getPriority());
     assertEquals("pri3", snap.child("b").getPriority());
@@ -2182,7 +2183,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void parentDeleteShadowsChildListeners()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference deleter = refs.get(1);
 
@@ -2213,7 +2214,7 @@ public void onCancelled(DatabaseError error) {}
                 });
     writer.child(childName).setValue("foo");
     // Make sure we get the data in the listener before we delete it
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     deleter.removeValue(
         new DatabaseReference.CompletionListener() {
@@ -2223,7 +2224,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertTrue(called.get());
     deleter.child(childName).removeEventListener(listener);
   }
@@ -2231,7 +2232,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void parentDeleteShadowsNonDefaultChildListeners()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference deleter = refs.get(1);
 
@@ -2286,7 +2287,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertTrue(queryCalled.get());
     assertTrue(deepChildCalled.get());
     deleter.child(childName).startAt(null, "b").removeEventListener(queryListener);
@@ -2296,7 +2297,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesSetWithPriorityRemoteEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2315,7 +2316,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value.
-    TestHelpers.waitFor(valSemaphore, 1);
+    IntegrationTestHelpers.waitFor(valSemaphore, 1);
 
     Map<String, Object> initialValues =
         new MapBuilder()
@@ -2337,7 +2338,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             opSemaphore.release();
           }
         });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord readerEventRecord = readerFuture.timedGet().get(1);
     DataSnapshot snap = readerEventRecord.getSnapshot();
@@ -2353,7 +2354,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesSetPriorityRemoteEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2395,7 +2396,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             opSemaphore.release();
           }
         });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("a")
@@ -2407,9 +2408,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     assert (Math.abs(System.currentTimeMillis() - priority.get()) < 2000);
   }
@@ -2417,7 +2418,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesUpdateRemoteEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2435,7 +2436,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value.
-    TestHelpers.waitFor(valSemaphore, 1);
+    IntegrationTestHelpers.waitFor(valSemaphore, 1);
 
     writer
         .child("a/b/d")
@@ -2448,7 +2449,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     Map<String, Object> updatedValue =
         new MapBuilder()
@@ -2471,7 +2472,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord readerEventRecord = readerFuture.timedGet().get(2);
     DataSnapshot snap = readerEventRecord.getSnapshot();
@@ -2485,7 +2486,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesSetWithPriorityLocalEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -2503,7 +2504,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value.
-    TestHelpers.waitFor(valSemaphore, 1);
+    IntegrationTestHelpers.waitFor(valSemaphore, 1);
 
     Map<String, Object> initialValues =
         new MapBuilder()
@@ -2525,7 +2526,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             opSemaphore.release();
           }
         });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord readerEventRecord = writerFuture.timedGet().get(1);
     DataSnapshot snap = readerEventRecord.getSnapshot();
@@ -2541,7 +2542,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesSetPriorityLocalEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -2582,7 +2583,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             opSemaphore.release();
           }
         });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("a")
@@ -2594,9 +2595,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     assert (Math.abs(System.currentTimeMillis() - priority.get()) < 2000);
   }
@@ -2604,7 +2605,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesUpdateLocalEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -2621,7 +2622,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value.
-    TestHelpers.waitFor(valSemaphore, 1);
+    IntegrationTestHelpers.waitFor(valSemaphore, 1);
 
     writer
         .child("a/b/d")
@@ -2634,7 +2635,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     Map<String, Object> updatedValue =
         new MapBuilder()
@@ -2656,7 +2657,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord readerEventRecord = writerFuture.timedGet().get(3);
     DataSnapshot snap = readerEventRecord.getSnapshot();
@@ -2670,7 +2671,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesTransactionLocalEvents()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(0);
 
@@ -2699,8 +2700,8 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for local (null) events.
-    TestHelpers.waitFor(valSemaphore1);
-    TestHelpers.waitFor(valSemaphore2);
+    IntegrationTestHelpers.waitFor(valSemaphore1);
+    IntegrationTestHelpers.waitFor(valSemaphore2);
 
     writer.runTransaction(
         new Transaction.Handler() {
@@ -2723,8 +2724,8 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
         });
 
     // Wait for local events.
-    TestHelpers.waitFor(valSemaphore1);
-    TestHelpers.waitFor(valSemaphore2);
+    IntegrationTestHelpers.waitFor(valSemaphore1);
+    IntegrationTestHelpers.waitFor(valSemaphore2);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(1);
     DataSnapshot snap1 = writerEventRecord.getSnapshot();
@@ -2741,7 +2742,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
   @Test
   public void testUpdateAfterChildSet() throws DatabaseException, InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore doneSemaphore = new Semaphore(0);
 
     Map<String, Object> initial = new MapBuilder().put("a", "a").build();
@@ -2774,7 +2775,7 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(doneSemaphore);
+    IntegrationTestHelpers.waitFor(doneSemaphore);
   }
 
   @Test
@@ -2786,20 +2787,20 @@ public void testMaxFrameSize()
       msg += i;
     }
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, msg).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     assertEquals(msg, snap.getValue());
   }
 
   @Test
   public void testDeltaSyncNoDataUpdatesAfterReconnect() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // Create a fresh connection so we can be sure we won't get any other data updates for stuff.
-    DatabaseConfig ctx = TestHelpers.newTestConfig();
+    DatabaseConfig ctx = IntegrationTestHelpers.newTestConfig();
     final DatabaseReference ref2 = new DatabaseReference(ref.toString(), ctx);
 
     final Map data =
@@ -2833,7 +2834,7 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(gotData);
+    IntegrationTestHelpers.waitFor(gotData);
 
     final Semaphore done = new Semaphore(0);
     assertEquals(1, ref2.repo.dataUpdateCount);
@@ -2869,15 +2870,15 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void testDeltaSyncWithQueryNoDataUpdatesAfterReconnect() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // Create a fresh connection so we can be sure we won't get any other data updates for stuff.
-    DatabaseConfig ctx = TestHelpers.newTestConfig();
+    DatabaseConfig ctx = IntegrationTestHelpers.newTestConfig();
     final DatabaseReference ref2 = new DatabaseReference(ref.toString(), ctx);
 
     final Map data =
@@ -2918,7 +2919,7 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(gotData);
+    IntegrationTestHelpers.waitFor(gotData);
 
     final Semaphore done = new Semaphore(0);
     assertEquals(1, ref2.repo.dataUpdateCount);
@@ -2954,13 +2955,13 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void testDeltaSyncWithUnfilteredQuery()
       throws InterruptedException, ExecutionException, TestFailure, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writeRef = refs.get(0), readRef = refs.get(1);
 
     // List must be large enough to trigger delta sync.
@@ -2990,7 +2991,7 @@ public void onDataChange(DataSnapshot snapshot) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(readSemaphore);
+    IntegrationTestHelpers.waitFor(readSemaphore);
     DeepEquals.assertEquals(longList, readSnapshots.get(0).getValue());
 
     // Add a new child while readRef is offline.
@@ -3004,7 +3005,7 @@ public void onCancelled(DatabaseError error) {}
 
     // Go back online and make sure we get the new item.
     readRef.getDatabase().goOnline();
-    TestHelpers.waitFor(readSemaphore);
+    IntegrationTestHelpers.waitFor(readSemaphore);
     DeepEquals.assertEquals(longList, readSnapshots.get(1).getValue());
   }
 
@@ -3012,13 +3013,13 @@ public void onCancelled(DatabaseError error) {}
   public void negativeIntegersDontCreateArrayValue()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(
             ref, new MapBuilder().put("-1", "minus-one").put("0", "zero").put("1", "one").build())
         .timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     Map<String, Object> expected =
         new MapBuilder().put("-1", "minus-one").put("0", "zero").put("1", "one").build();
     Object result = snap.getValue();
@@ -3028,7 +3029,7 @@ public void negativeIntegersDontCreateArrayValue()
   @Test
   public void testLocalServerValuesEventuallyButNotImmediatelyMatchServer()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -3068,7 +3069,7 @@ public void onDataChange(DataSnapshot snapshot) {
 
     writer.setValue(ServerValue.TIMESTAMP, ServerValue.TIMESTAMP);
 
-    TestHelpers.waitFor(completionSemaphore, 3);
+    IntegrationTestHelpers.waitFor(completionSemaphore, 3);
 
     assertEquals(readSnaps.size(), 1);
     assertEquals(writeSnaps.size(), 2);
@@ -3100,7 +3101,7 @@ public void testBasicObjectMappingRoundTrip()
     nestedBean.name = "nested-bean";
     bean.nestedBean = nestedBean;
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     new WriteFuture(ref, bean).timedGet();
 
     final Semaphore done = new Semaphore(0);
@@ -3119,7 +3120,7 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
@@ -3132,7 +3133,7 @@ public void testUpdateChildrenWithObjectMapping()
     DumbBean bean2 = new DumbBean();
     bean2.name = "bean2";
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore writeComplete = new Semaphore(0);
     ref.updateChildren(
@@ -3143,7 +3144,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             writeComplete.release();
           }
         });
-    TestHelpers.waitFor(writeComplete);
+    IntegrationTestHelpers.waitFor(writeComplete);
 
     final Semaphore done = new Semaphore(0);
     ref.addListenerForSingleValueEvent(
@@ -3161,7 +3162,7 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
@@ -3174,7 +3175,7 @@ public void testUpdateChildrenDeepUpdatesWithObjectMapping()
     DumbBean bean2 = new DumbBean();
     bean2.name = "bean2";
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore writeComplete = new Semaphore(0);
     ref.updateChildren(
@@ -3185,7 +3186,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             writeComplete.release();
           }
         });
-    TestHelpers.waitFor(writeComplete);
+    IntegrationTestHelpers.waitFor(writeComplete);
 
     final Semaphore done = new Semaphore(0);
     ref.addListenerForSingleValueEvent(
@@ -3201,6 +3202,6 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 }
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
index e64404dd2..2ef116394 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/EventTest.java
@@ -43,13 +43,13 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
   // NOTE: skipping test on valid types.
 
   @Test
   public void writeLeafNodeExpectValue() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -70,7 +70,7 @@ public void writeLeafNodeExpectValue() throws DatabaseException, InterruptedExce
 
   @Test
   public void writeNestedLeafNodeWaitForEvents() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     EventHelper helper =
         new EventHelper()
             .addChildExpectation(ref, Event.EventType.CHILD_ADDED, "foo")
@@ -86,7 +86,7 @@ public void writeNestedLeafNodeWaitForEvents() throws DatabaseException, Interru
 
   @Test
   public void writeTwoLeafNodeThenChangeThem() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -129,7 +129,7 @@ public void writeTwoLeafNodeThenChangeThem() throws DatabaseException, Interrupt
 
   @Test
   public void writeFloatValueThenChangeToInteger() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -145,14 +145,14 @@ public void writeFloatValueThenChangeToInteger() throws DatabaseException, Inter
     node.setValue((float) 1337.0); // This does not fire events.
     node.setValue(1337.1);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
 
   @Test
   public void writeDoubleValueThenChangeToInteger() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -167,7 +167,7 @@ public void writeDoubleValueThenChangeToInteger() throws DatabaseException, Inte
     node.setValue(1337); // This does not fire events.
     node.setValue(1337.1);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
@@ -175,7 +175,7 @@ public void writeDoubleValueThenChangeToInteger() throws DatabaseException, Inte
   @Test
   public void writeDoubleValueThenChangeToIntegerWithDifferentPriority()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -189,14 +189,14 @@ public void writeDoubleValueThenChangeToIntegerWithDifferentPriority()
     node.setValue(1337.0);
     node.setValue(1337, 1337);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
 
   @Test
   public void writeIntegerValueThenChangeToDouble() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -211,7 +211,7 @@ public void writeIntegerValueThenChangeToDouble() throws DatabaseException, Inte
     node.setValue(1337.0); // This does not fire events.
     node.setValue(1337.1);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
@@ -219,7 +219,7 @@ public void writeIntegerValueThenChangeToDouble() throws DatabaseException, Inte
   @Test
   public void writeIntegerValueThenChangeToDoubleWithDifferentPriority()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -233,14 +233,14 @@ public void writeIntegerValueThenChangeToDoubleWithDifferentPriority()
     node.setValue(1337);
     node.setValue(1337.0, 1337);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
 
   @Test
   public void writeLargeLongValueThenIncrement() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference node = refs.get(0);
 
     EventHelper readHelper =
@@ -253,14 +253,14 @@ public void writeLargeLongValueThenIncrement() throws DatabaseException, Interru
     node.setValue(Long.MAX_VALUE);
     node.setValue(Long.MAX_VALUE * 2.0);
 
-    TestHelpers.waitForRoundtrip(node);
+    IntegrationTestHelpers.waitForRoundtrip(node);
     assertTrue(readHelper.waitForEvents());
     ZombieVerifier.verifyRepoZombies(refs);
   }
 
   @Test
   public void setMultipleEventListenersOnSameNode() throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -285,7 +285,7 @@ public void setMultipleEventListenersOnSameNode() throws DatabaseException, Inte
   @Test
   public void setDataMultipleTimesEnsureValueIsCalledAppropriately()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilEquals(ref, 2L, /*ignoreFirstNull=*/ true);
     ZombieVerifier.verifyRepoZombies(ref);
@@ -306,7 +306,7 @@ public void setDataMultipleTimesEnsureValueIsCalledAppropriately()
   public void unsubscribeEventsAndConfirmEventsNoLongerFire()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
 
@@ -331,7 +331,7 @@ public void onCancelled(DatabaseError error) {
       ref.setValue(i);
     }
 
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(listener);
     ZombieVerifier.verifyRepoZombies(ref);
 
@@ -349,7 +349,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void subscribeThenUnsubscribeWithoutProblems()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueEventListener listener =
         new ValueEventListener() {
@@ -375,7 +375,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void subscribeThenUnsubscribeWithoutProblemsWithLimit()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueEventListener listener =
         new ValueEventListener() {
@@ -401,7 +401,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void writeChunkOfJSONButGetMoreGranularEventsForIndividualChanges()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -493,18 +493,18 @@ public void onCancelled(DatabaseError error) {}
     ZombieVerifier.verifyRepoZombies(refs);
 
     writer.setValue(new MapBuilder().put("a", 10).put("b", 20).build());
-    TestHelpers.waitFor(writerReady, 2);
-    TestHelpers.waitFor(readerReady, 2);
+    IntegrationTestHelpers.waitFor(writerReady, 2);
+    IntegrationTestHelpers.waitFor(readerReady, 2);
 
     writer.setValue(new MapBuilder().put("a", 10).put("b", 30).build());
-    TestHelpers.waitFor(writerReady);
-    TestHelpers.waitFor(readerReady);
+    IntegrationTestHelpers.waitFor(writerReady);
+    IntegrationTestHelpers.waitFor(readerReady);
   }
 
   @Test
   public void valueIsTriggeredForEmptyNodes()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     DataSnapshot snap = new ReadFuture(ref).timedGet().get(0).getSnapshot();
     ZombieVerifier.verifyRepoZombies(ref);
@@ -514,7 +514,7 @@ public void valueIsTriggeredForEmptyNodes()
   @Test
   public void correctEventsAreRaisedWhenALeafNodeTurnsIntoAnInternalNode()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCountAfterNull(ref, 4);
 
@@ -538,7 +538,7 @@ public void correctEventsAreRaisedWhenALeafNodeTurnsIntoAnInternalNode()
   public void canRegisterTheSameCallbackMultipleTimesNeedToUnregisterItMultipleTimes()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
     ValueEventListener listener =
@@ -583,7 +583,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void unregisterSameCallbackTooManyTimesSilentlyDoesNothing()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueEventListener listener =
         ref.addValueEventListener(
@@ -609,7 +609,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void removesHappenImmediately()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore blockSem = new Semaphore(0);
     final Semaphore endingSemaphore = new Semaphore(0);
 
@@ -621,7 +621,7 @@ public void onDataChange(DataSnapshot snapshot) {
             if (snapshot.getValue() != null) {
               assertTrue(called.compareAndSet(false, true));
               try {
-                TestHelpers.waitFor(blockSem);
+                IntegrationTestHelpers.waitFor(blockSem);
               } catch (InterruptedException e) {
                 e.printStackTrace();
               }
@@ -644,17 +644,17 @@ public void onCancelled(DatabaseError error) {
     ZombieVerifier.verifyRepoZombies(ref);
 
     ref.setValue(42);
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     ref.setValue(84);
     blockSem.release();
     new WriteFuture(ref, null).timedGet();
-    TestHelpers.waitFor(endingSemaphore);
+    IntegrationTestHelpers.waitFor(endingSemaphore);
   }
 
   @Test
   public void removesHappenImmediatelyOnOuterRef()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore gotInitialEvent = new Semaphore(0);
     final Semaphore blockSem = new Semaphore(0);
     final Semaphore endingSemaphore = new Semaphore(0);
@@ -669,7 +669,7 @@ public void onDataChange(DataSnapshot snapshot) {
                 if (snapshot.getValue() != null) {
                   assertTrue(called.compareAndSet(false, true));
                   try {
-                    TestHelpers.waitFor(blockSem);
+                    IntegrationTestHelpers.waitFor(blockSem);
                   } catch (InterruptedException e) {
                     e.printStackTrace();
                   }
@@ -691,20 +691,20 @@ public void onCancelled(DatabaseError error) {
             });
     ZombieVerifier.verifyRepoZombies(ref);
 
-    TestHelpers.waitFor(gotInitialEvent);
+    IntegrationTestHelpers.waitFor(gotInitialEvent);
 
     ref.child("a").setValue(42);
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     ref.child("b").setValue(84);
     blockSem.release();
     new WriteFuture(ref, null).timedGet();
-    TestHelpers.waitFor(endingSemaphore);
+    IntegrationTestHelpers.waitFor(endingSemaphore);
   }
 
   @Test
   public void removesHappenImmediatelyOnMultipleRef()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore gotInitialEvent = new Semaphore(0);
     final Semaphore blockSem = new Semaphore(0);
     final Semaphore endingSemaphore = new Semaphore(0);
@@ -718,7 +718,7 @@ public void onDataChange(DataSnapshot snapshot) {
             if (snapshot.getValue() != null) {
               assertTrue(called.compareAndSet(false, true));
               try {
-                TestHelpers.waitFor(blockSem);
+                IntegrationTestHelpers.waitFor(blockSem);
               } catch (InterruptedException e) {
                 e.printStackTrace();
               }
@@ -743,19 +743,19 @@ public void onCancelled(DatabaseError error) {
     ref.limitToFirst(5).addValueEventListener(listener);
     ZombieVerifier.verifyRepoZombies(ref);
 
-    TestHelpers.waitFor(gotInitialEvent, 2);
+    IntegrationTestHelpers.waitFor(gotInitialEvent, 2);
     ref.child("a").setValue(42);
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     ref.child("b").setValue(84);
     blockSem.release();
     new WriteFuture(ref, null).timedGet();
-    TestHelpers.waitFor(endingSemaphore);
+    IntegrationTestHelpers.waitFor(endingSemaphore);
   }
 
   @Test
   public void removesHappenImmediatelyChild()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore blockSem = new Semaphore(0);
     final Semaphore endingSemaphore = new Semaphore(0);
 
@@ -767,7 +767,7 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
             if (snapshot.getValue() != null) {
               assertTrue(called.compareAndSet(false, true));
               try {
-                TestHelpers.waitFor(blockSem);
+                IntegrationTestHelpers.waitFor(blockSem);
               } catch (InterruptedException e) {
                 e.printStackTrace();
               }
@@ -798,18 +798,18 @@ public void onCancelled(DatabaseError error) {}
     ZombieVerifier.verifyRepoZombies(ref);
 
     ref.child("a").setValue(42);
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     ref.child("b").setValue(84);
     blockSem.release();
     new WriteFuture(ref, null).timedGet();
-    TestHelpers.waitFor(endingSemaphore);
+    IntegrationTestHelpers.waitFor(endingSemaphore);
   }
 
   @Test
   public void onceFiresExactlyOnce()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicBoolean called = new AtomicBoolean(false);
     ref.addListenerForSingleValueEvent(
@@ -838,7 +838,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void valueOnEmptyChildFires()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     DataSnapshot snap = new ReadFuture(ref.child("test")).timedGet().get(0).getSnapshot();
     assertNull(snap.getValue());
@@ -848,7 +848,7 @@ public void valueOnEmptyChildFires()
   @Test
   public void valueOnEmptyChildFiresImmediatelyEvenAfterParentIsSynced()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // Sync parent
     new ReadFuture(ref).timedGet();
@@ -862,7 +862,7 @@ public void valueOnEmptyChildFiresImmediatelyEvenAfterParentIsSynced()
   public void childEventsAreRaised()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> firstValue =
         new MapBuilder()
@@ -948,7 +948,7 @@ public void onCancelled(DatabaseError error) {}
   public void childEventsAreRaisedWithAQuery()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> firstValue =
         new MapBuilder()
@@ -1034,7 +1034,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void priorityChangeShouldRaiseChildMovedAndChildChangedAndValueOnParentAndChild()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
@@ -1047,7 +1047,7 @@ public void priorityChangeShouldRaiseChildMovedAndChildChangedAndValueOnParentAn
             .startListening(true);
 
     ref.child("bar").setValue(42, 10);
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.child("foo").setValue(42, 20);
 
     assertTrue(helper.waitForEvents());
@@ -1067,7 +1067,7 @@ public void priorityChangeShouldRaiseChildMovedAndChildChangedAndValueOnParentAn
   @Test
   public void priorityChangeShouldRaiseChildMovedAndChildChangedAndValueOnParentAndChild2()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
index 75dbb05de..73d4048d6 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/FirebaseDatabaseTest.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database;
 
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.IntegrationTestHelpers.fromSingleQuotedString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;
@@ -35,7 +35,6 @@
 import java.util.List;
 import org.junit.After;
 import org.junit.Assert;
-import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
@@ -44,14 +43,9 @@
 public class FirebaseDatabaseTest {
   @Rule public RetryRule retryRule = new RetryRule(3);
 
-  @Before
-  public void setup() {
-    TestHelpers.ensureAppInitialized();
-  }
-
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
@@ -158,7 +152,7 @@ public void getReference() {
 
   @Test
   public void persistenceSettings() {
-    DatabaseConfig config = TestHelpers.newTestConfig();
+    DatabaseConfig config = IntegrationTestHelpers.newTestConfig();
 
     try {
       config.setPersistenceCacheSizeBytes(1 * 1024 * 1024 - 1);
@@ -250,11 +244,11 @@ public void defaultPersistenceLocation() {
   }
 
   private static DatabaseReference rootRefWithEngine(MockPersistenceStorageEngine engine) {
-    DatabaseConfig config = TestHelpers.newTestConfig();
+    DatabaseConfig config = IntegrationTestHelpers.newTestConfig();
     PersistenceManager persistenceManager =
         new DefaultPersistenceManager(config, engine, CachePolicy.NONE);
-    TestHelpers.setForcedPersistentCache(config, persistenceManager);
-    return TestHelpers.rootWithConfig(config);
+    IntegrationTestHelpers.setForcedPersistentCache(config, persistenceManager);
+    return IntegrationTestHelpers.rootWithConfig(config);
   }
 
   @Test
@@ -270,12 +264,12 @@ public void purgeWritesPurgesAllWrites() {
     ref.push().setValue("test-value-3");
     ref.push().setValue("test-value-4");
 
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     Assert.assertEquals(4, engine.loadUserWrites().size());
 
     app.purgeOutstandingWrites();
 
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     Assert.assertEquals(0, engine.loadUserWrites().size());
   }
 
@@ -332,12 +326,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               }
             });
 
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     Assert.assertEquals(4, engine.loadUserWrites().size());
 
     app.purgeOutstandingWrites();
 
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
     assertEquals(Arrays.asList("1", "2", "3", "4"), order);
   }
 
@@ -374,11 +368,11 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               }
             });
 
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
 
     app.purgeOutstandingWrites();
 
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
     assertEquals(Arrays.asList("1", "2"), order);
   }
 
@@ -484,7 +478,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
 
     app.purgeOutstandingWrites();
 
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
 
     assertEquals(Arrays.asList("foo-1", "bar", "foo-2"), cancelOrder);
 
@@ -494,7 +488,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
 
     app.goOnline();
     // Make sure we're back online and reconnected again
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
 
     // No events should be reraised...
     assertEquals(expectedFooValues, fooValues);
@@ -522,7 +516,7 @@ public void onCancelled(DatabaseError error) {}
         });
 
     // Make sure the first value event is fired
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
 
     app.goOffline();
 
@@ -558,7 +552,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
     ref.getDatabase().purgeOutstandingWrites();
 
-    TestHelpers.waitForEvents(ref);
+    IntegrationTestHelpers.waitForEvents(ref);
 
     // The order should really be cancel-1 then cancel-2, but too difficult to implement currently.
     assertEquals(
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
index 6fe43b5fc..7b718cdd8 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/InfoTest.java
@@ -35,11 +35,11 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   private DatabaseReference getRootNode() throws DatabaseException {
-    return TestHelpers.getRandomNode().getRoot();
+    return IntegrationTestHelpers.getRandomNode().getRoot();
   }
 
   @Test
@@ -50,7 +50,7 @@ public void canGetAReferenceToDotInfoNodes() throws DatabaseException {
     assertEquals(
         IntegrationTestValues.getNamespace() + "/.info/foo", root.child(".info/foo").toString());
 
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     DatabaseReference ref =
         new DatabaseReference(IntegrationTestValues.getNamespace() + "/.info", ctx);
     assertEquals(IntegrationTestValues.getNamespace() + "/.info", ref.toString());
@@ -132,7 +132,7 @@ public void canWatchInfoConnected()
   @Test
   public void testManualConnectionManagementWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // Wait until we're connected to the database
     ReadFuture.untilEquals(ref.getRoot().child(".info/connected"), true).timedGet();
@@ -167,7 +167,7 @@ public void dotInfoConnectedGoesToFalseWhenDisconnected()
     // Wait until we're connected
     ReadFuture.untilEquals(ref.child(".info/connected"), true).timedGet();
 
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.interrupt(ctx);
 
     DataSnapshot snap =
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/TestHelpers.java b/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestHelpers.java
similarity index 85%
rename from firebase-database/src/androidTest/java/com/google/firebase/database/TestHelpers.java
rename to firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestHelpers.java
index aa8878237..f9df68428 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/TestHelpers.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/IntegrationTestHelpers.java
@@ -15,15 +15,13 @@
 package com.google.firebase.database;
 
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import android.support.test.InstrumentationRegistry;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.firebase.FirebaseApp;
-import com.google.firebase.FirebaseOptions;
+import com.google.firebase.database.android.AndroidAuthTokenProvider;
 import com.google.firebase.database.core.CompoundWrite;
 import com.google.firebase.database.core.Context;
 import com.google.firebase.database.core.CoreTestHelpers;
@@ -59,7 +57,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-public class TestHelpers {
+public class IntegrationTestHelpers {
 
   private static List<DatabaseConfig> contexts = new ArrayList<DatabaseConfig>();
   private static String testSecret = null;
@@ -218,10 +216,6 @@ public static DatabaseConfig getContext(int i) {
     return contexts.get(i);
   }
 
-  public static DatabaseReference rootWithNewContext() throws DatabaseException {
-    return rootWithConfig(newTestConfig());
-  }
-
   public static DatabaseReference rootWithConfig(DatabaseConfig config) {
     return new DatabaseReference(IntegrationTestValues.getNamespace(), config);
   }
@@ -261,15 +255,13 @@ public static DatabaseConfig newFrozenTestConfig() {
   }
 
   public static DatabaseConfig newTestConfig() {
-    TestHelpers.ensureAppInitialized();
-
     TestRunLoop runLoop = new TestRunLoop();
     DatabaseConfig config = new DatabaseConfig();
     config.setLogLevel(Logger.Level.DEBUG);
     config.setEventTarget(new TestEventTarget());
     config.setRunLoop(runLoop);
     config.setFirebaseApp(FirebaseApp.getInstance());
-    config.setAuthTokenProvider(new TestTokenProvider(runLoop.getExecutorService()));
+    config.setAuthTokenProvider(AndroidAuthTokenProvider.forUnauthenticatedAccess());
     return config;
   }
 
@@ -355,37 +347,6 @@ public void onCancelled(DatabaseError error) {
     return snapshotList.get(0);
   }
 
-  public static void assertSuccessfulAuth(
-      DatabaseReference ref, TestTokenProvider provider, String credential) {
-    DatabaseReference authRef = ref.getRoot().child(".info/authenticated");
-    final Semaphore semaphore = new Semaphore(0);
-    final List<Boolean> authStates = new ArrayList<>();
-    ValueEventListener listener =
-        authRef.addValueEventListener(
-            new ValueEventListener() {
-              @Override
-              public void onDataChange(DataSnapshot snapshot) {
-                authStates.add(snapshot.getValue(Boolean.class));
-                semaphore.release();
-              }
-
-              @Override
-              public void onCancelled(DatabaseError error) {
-                throw new RuntimeException("Should not happen");
-              }
-            });
-
-    provider.setToken(credential);
-
-    try {
-      TestHelpers.waitFor(semaphore, 2);
-      assertEquals(Arrays.asList(false, true), authStates);
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
-    authRef.removeEventListener(listener);
-  }
-
   public static Map<String, Object> fromJsonString(String json) {
     try {
       ObjectMapper mapper = new ObjectMapper();
@@ -427,7 +388,7 @@ public void run() {
   public static void waitForEvents(DatabaseReference ref) {
     try {
       // Make sure queue is done and all events are queued
-      TestHelpers.waitForQueue(ref);
+      IntegrationTestHelpers.waitForQueue(ref);
       // Next, all events were queued, make sure all events are done raised
       final Semaphore semaphore = new Semaphore(0);
       ref.getRepo()
@@ -485,32 +446,4 @@ public static Object applyPath(Object value, Path path) {
   public static void assertContains(String str, String substr) {
     assertTrue("'" + str + "' does not contain '" + substr + "'.", str.contains(substr));
   }
-
-  public static void ensureAppInitialized() {
-    if (!appInitialized) {
-      appInitialized = true;
-      android.content.Context context = InstrumentationRegistry.getTargetContext();
-      FirebaseApp.initializeApp(
-          context,
-          new FirebaseOptions.Builder()
-              .setApiKey(context.getResources().getString(R.string.google_api_key))
-              .setApplicationId("sdflhkj")
-              .setDatabaseUrl(IntegrationTestValues.getNamespace())
-              .build());
-    }
-  }
-
-  public static void ensureConstantsInitialized() {
-    if (!appInitialized) {
-      appInitialized = true;
-      android.content.Context context = InstrumentationRegistry.getTargetContext();
-      FirebaseApp.initializeApp(
-          context,
-          new FirebaseOptions.Builder()
-              .setApiKey("jank")
-              .setApplicationId("jank")
-              .setDatabaseUrl(IntegrationTestValues.getNamespace())
-              .build());
-    }
-  }
 }
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
index a58bde095..50c4d5e58 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderByTest.java
@@ -38,10 +38,10 @@
   @Test
   public void snapshotsAreIteratedInOrder()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> initial =
-        TestHelpers.fromJsonString(
+        IntegrationTestHelpers.fromJsonString(
             "{"
                 + "\"alex\": {\"nuggets\": 60},"
                 + "\"greg\": {\"nuggets\": 52},"
@@ -90,7 +90,7 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
     Assert.assertEquals(expectedPrevNames, childPrevNames);
 
     // cleanup
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(testListener);
     ref.removeEventListener(valueListener);
   }
@@ -98,10 +98,10 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
   @Test
   public void canUseDeepPathsForIndex()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> initial =
-        TestHelpers.fromJsonString(
+        IntegrationTestHelpers.fromJsonString(
             "{"
                 + "\"alex\": {\"deep\": {\"nuggets\": 60}},"
                 + "\"greg\": {\"deep\": {\"nuggets\": 52}},"
@@ -145,7 +145,7 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
               }
             });
 
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
 
     Assert.assertEquals(expectedOrder, valueOrder);
     Assert.assertEquals(expectedOrder, childOrder);
@@ -159,10 +159,10 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
   @Test
   public void snapshotsAreIteratedInOrderForValueIndex()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> initial =
-        TestHelpers.fromJsonString(
+        IntegrationTestHelpers.fromJsonString(
             "{"
                 + "\"alex\": 60,"
                 + "\"greg\": 52,"
@@ -211,16 +211,16 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
     Assert.assertEquals(expectedPrevNames, childPrevNames);
 
     // cleanup
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(testListener);
     ref.removeEventListener(valueListener);
   }
 
   @Test
   public void childMovedEventsAreFired() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     Map<String, Object> initial =
-        TestHelpers.fromJsonString(
+        IntegrationTestHelpers.fromJsonString(
             "{"
                 + "\"alex\": {\"nuggets\": 60},"
                 + "\"greg\": {\"nuggets\": 52},"
@@ -254,7 +254,7 @@ public void onChildChanged(DataSnapshot snap, String previousChildName) {}
     ref.setValue(initial);
     ref.child("greg/nuggets").setValue(57);
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals("greg", snapshot[0].getKey());
     Assert.assertEquals("rob", prevName[0]);
@@ -262,13 +262,13 @@ public void onChildChanged(DataSnapshot snap, String previousChildName) {}
     expectedValue.put("nuggets", 57L);
     Assert.assertEquals(expectedValue, snapshot[0].getValue());
 
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(testListener);
   }
 
   @Test
   public void callbackRemovalWorks() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final int[] reads = new int[1];
     final Semaphore semaphore = new Semaphore(0);
@@ -333,30 +333,30 @@ public void onCancelled(DatabaseError error) {
             });
 
     // wait for initial null events.
-    TestHelpers.waitFor(semaphore, 4);
+    IntegrationTestHelpers.waitFor(semaphore, 4);
     Assert.assertEquals(4, reads[0]);
 
     ref.setValue(1);
 
-    TestHelpers.waitFor(semaphore, 4);
+    IntegrationTestHelpers.waitFor(semaphore, 4);
     Assert.assertEquals(8, reads[0]);
 
     ref.removeEventListener(fooListener);
     ref.setValue(2);
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
     Assert.assertEquals(11, reads[0]);
 
     // Should be a no-op resulting in 3 more reads
     ref.orderByChild("foo").removeEventListener(bazListener);
     ref.setValue(3);
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
     Assert.assertEquals(14, reads[0]);
 
     ref.orderByChild("bar").removeEventListener(barListener);
     ref.setValue(4);
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     Assert.assertEquals(16, reads[0]);
 
     // Now, remove everything
@@ -365,13 +365,13 @@ public void onCancelled(DatabaseError error) {
     ref.setValue(5);
 
     // No more reads
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     Assert.assertEquals(16, reads[0]);
   }
 
   @Test
   public void childAddedEventsAreInCorrectOrder() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> initial =
         new MapBuilder()
@@ -395,7 +395,7 @@ public void onChildAdded(DataSnapshot snap, String prevName) {
                 });
 
     ref.setValue(initial);
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     Assert.assertEquals(Arrays.asList("c", "a"), snapshotNames);
     Assert.assertEquals(Arrays.asList(null, "c"), prevNames);
 
@@ -404,7 +404,7 @@ public void onChildAdded(DataSnapshot snap, String prevName) {
     updates.put("d", new MapBuilder().put("value", 2).build());
     ref.updateChildren(updates);
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     Assert.assertEquals(Arrays.asList("c", "a", "d", "b"), snapshotNames);
     Assert.assertEquals(Arrays.asList(null, "c", null, "c"), prevNames);
     ref.removeEventListener(testListener);
@@ -413,7 +413,7 @@ public void onChildAdded(DataSnapshot snap, String prevName) {
   @Test
   public void updatesForUnindexedQuery()
       throws InterruptedException, ExecutionException, TestFailure, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -444,7 +444,7 @@ public void onCancelled(DatabaseError error) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals(1, snapshots.size());
 
@@ -455,7 +455,7 @@ public void onCancelled(DatabaseError error) {
 
     // update child which should trigger value event
     writer.child("one/index").setValue(4);
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals(2, snapshots.size());
     Map<String, Object> expected2 = new HashMap<String, Object>();
@@ -464,7 +464,7 @@ public void onCancelled(DatabaseError error) {
     Assert.assertEquals(expected2, snapshots.get(1).getValue());
 
     // cleanup
-    TestHelpers.waitForRoundtrip(reader);
+    IntegrationTestHelpers.waitForRoundtrip(reader);
     reader.removeEventListener(listener);
   }
 
@@ -472,7 +472,7 @@ public void onCancelled(DatabaseError error) {
   public void queriesWorkOnLeafNodes()
       throws DatabaseException, InterruptedException, ExecutionException, TestFailure,
           TimeoutException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
     new WriteFuture(ref, "leaf-node").timedGet();
 
@@ -493,20 +493,20 @@ public void onCancelled(DatabaseError error) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals(1, snapshots.size());
     Assert.assertNull(snapshots.get(0).getValue());
 
     // cleanup
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(listener);
   }
 
   @Test
   public void serverRespectsKeyIndex()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -539,7 +539,7 @@ public void onCancelled(DatabaseError error) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals(expectedChildren, actualChildren);
 
@@ -549,10 +549,10 @@ public void onCancelled(DatabaseError error) {
 
   @Test
   public void startAtAndEndAtWorkOnValueIndex() throws Throwable {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> initial =
-        TestHelpers.fromJsonString(
+        IntegrationTestHelpers.fromJsonString(
             "{"
                 + "\"alex\": 60,"
                 + "\"greg\": 52,"
@@ -601,14 +601,14 @@ public void onChildAdded(DataSnapshot snapshot, String previousChildName) {
     Assert.assertEquals(expectedPrevNames, childPrevNames);
 
     // cleanup
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     ref.removeEventListener(testListener);
     ref.removeEventListener(valueListener);
   }
 
   @Test
   public void removingDefaultListenerRemovesNonDefaultListenWithLoadsAllData() throws Throwable {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Object initialData = new MapBuilder().put("key", "value").build();
     new WriteFuture(ref, initialData).timedGet();
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
index 8c3db0fa3..e0cc95621 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/OrderTest.java
@@ -42,20 +42,20 @@
   @Before
   public void setUp()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode().getRoot();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode().getRoot();
 
     ReadFuture.untilEquals(ref.child(".info/connected"), true).timedGet();
   }
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
   public void pushABunchOfDataAndEnumerateItBack()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     for (int i = 0; i < 10; ++i) {
       ref.push().setValue(i);
@@ -75,7 +75,7 @@ public void pushABunchOfDataAndEnumerateItBack()
   @Test
   public void pushABunchOfDataThenWriteEnsureOrderIsCorrect()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     List<DatabaseReference> paths = new ArrayList<DatabaseReference>(20);
     // Generate children quickly to try to get a few in the same millisecond
@@ -102,7 +102,7 @@ public void pushABunchOfDataThenWriteEnsureOrderIsCorrect()
   public void pushABunchOfDataReconnectReadItBack()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
 
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
@@ -112,7 +112,7 @@ public void pushABunchOfDataReconnectReadItBack()
     }
     new WriteFuture(writer.push(), 9).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     long i = 0;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -120,7 +120,7 @@ public void pushABunchOfDataReconnectReadItBack()
     }
     assertEquals(10L, i);
 
-    snap = TestHelpers.getSnap(reader);
+    snap = IntegrationTestHelpers.getSnap(reader);
     i = 0;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -133,7 +133,7 @@ public void pushABunchOfDataReconnectReadItBack()
   public void pushABunchOfDataWithExplicitPriorityReconnectReadBackInOrder()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
 
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
@@ -143,7 +143,7 @@ public void pushABunchOfDataWithExplicitPriorityReconnectReadBackInOrder()
     }
     new WriteFuture(writer.push(), 9, 1).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     long i = 9;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -151,7 +151,7 @@ public void pushABunchOfDataWithExplicitPriorityReconnectReadBackInOrder()
     }
     assertEquals(-1L, i);
 
-    snap = TestHelpers.getSnap(reader);
+    snap = IntegrationTestHelpers.getSnap(reader);
     i = 9;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -164,7 +164,7 @@ public void pushABunchOfDataWithExplicitPriorityReconnectReadBackInOrder()
   public void pushDataWithExponentialPriorityAndCheckOrder()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
 
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
@@ -175,7 +175,7 @@ public void pushDataWithExponentialPriorityAndCheckOrder()
     new WriteFuture(writer.push(), 9, 111111111111111111111111111111.0 / Math.pow(10, 9))
         .timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     long i = 9;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -183,7 +183,7 @@ public void pushDataWithExponentialPriorityAndCheckOrder()
     }
     assertEquals(-1L, i);
 
-    snap = TestHelpers.getSnap(reader);
+    snap = IntegrationTestHelpers.getSnap(reader);
     i = 9;
     for (DataSnapshot child : snap.getChildren()) {
       assertEquals(i, child.getValue());
@@ -195,12 +195,12 @@ public void pushDataWithExponentialPriorityAndCheckOrder()
   @Test
   public void verifyNodesWithoutValuesAreNotEnumerated()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.child("foo");
     ref.child("bar").setValue("test");
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     int i = 0;
     for (DataSnapshot child : snap.getChildren()) {
       i++;
@@ -212,7 +212,7 @@ public void verifyNodesWithoutValuesAreNotEnumerated()
   @Test
   public void receiveChildMovedEventWhenPriorityChanges()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper =
         new EventHelper()
@@ -237,12 +237,12 @@ public void receiveChildMovedEventWhenPriorityChanges()
 
   @Test
   public void canResetPriorityToNull() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.child("a").setValue("a", 1);
     ref.child("b").setValue("b", 2);
 
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
     EventHelper helper =
         new EventHelper()
             .addChildExpectation(ref, Event.EventType.CHILD_ADDED, "a")
@@ -261,7 +261,7 @@ public void canResetPriorityToNull() throws DatabaseException, InterruptedExcept
     ref.child("b").setPriority(null);
     assertTrue(helper.waitForEvents());
 
-    DataSnapshot snap = TestHelpers.getSnap(ref);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref);
     assertNull(snap.child("b").getPriority());
     helper.cleanup();
   }
@@ -269,7 +269,7 @@ public void canResetPriorityToNull() throws DatabaseException, InterruptedExcept
   @Test
   public void insertingANodeUnderALeafPreservesItsPriority()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCountAfterNull(ref, 2);
 
@@ -284,7 +284,7 @@ public void insertingANodeUnderALeafPreservesItsPriority()
   public void verifyOrderOfMixedNumbersStringAndNoPriorities()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -334,14 +334,14 @@ public void verifyOrderOfMixedNumbersStringAndNoPriorities()
             "alpha41",
             "alpha42"));
     List<String> actual = new ArrayList<String>(expected.size());
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     for (DataSnapshot child : snap.getChildren()) {
       actual.add(child.getKey());
     }
     DeepEquals.assertEquals(expected, actual);
 
     actual.clear();
-    snap = TestHelpers.getSnap(reader);
+    snap = IntegrationTestHelpers.getSnap(reader);
     for (DataSnapshot child : snap.getChildren()) {
       actual.add(child.getKey());
     }
@@ -352,7 +352,7 @@ public void verifyOrderOfMixedNumbersStringAndNoPriorities()
   public void verifyOrderOfIntegerKeys()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
 
     writer.child("foo").setValue(0);
@@ -369,7 +369,7 @@ public void verifyOrderOfIntegerKeys()
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("0", "3", "03", "003", "5", "9", "20", "100", "bar", "foo"));
     List<String> actual = new ArrayList<String>(expected.size());
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     for (DataSnapshot child : snap.getChildren()) {
       actual.add(child.getKey());
     }
@@ -380,7 +380,7 @@ public void verifyOrderOfIntegerKeys()
   public void verifyOrderOfLargeIntegerKeys()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
 
     writer.child("2000000000").setValue(0);
@@ -389,7 +389,7 @@ public void verifyOrderOfLargeIntegerKeys()
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("-2000000000", "2000000000"));
     List<String> actual = new ArrayList<String>(expected.size());
-    DataSnapshot snap = TestHelpers.getSnap(writer);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(writer);
     for (DataSnapshot child : snap.getChildren()) {
       actual.add(child.getKey());
     }
@@ -399,7 +399,7 @@ public void verifyOrderOfLargeIntegerKeys()
   @Test
   public void ensurePrevNameIsCorrectOnChildAddedEvent()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -434,7 +434,7 @@ public void onCancelled(DatabaseError error) {}
 
     ref.setValue(new MapBuilder().put("a", 1).put("b", 2).put("c", 3).build());
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("a", null, "b", "a", "c", "b"));
     DeepEquals.assertEquals(expected, results);
@@ -444,7 +444,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void ensurePrevNameIsCorrectWhenAddingNewNodes()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -482,7 +482,7 @@ public void onCancelled(DatabaseError error) {}
     ref.child("a").setValue(1);
     ref.child("e").setValue(5);
 
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("b", null, "c", "b", "d", "c", "a", null, "e", "d"));
     DeepEquals.assertEquals(expected, results);
@@ -492,7 +492,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void ensurePrevNameIsCorrectWhenAddingNewNodesWithJSON()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -531,7 +531,7 @@ public void onCancelled(DatabaseError error) {}
     ref.setValue(
         new MapBuilder().put("a", 1).put("b", 2).put("c", 3).put("d", 4).put("e", 5).build());
 
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("b", null, "c", "b", "d", "c", "a", null, "e", "d"));
     DeepEquals.assertEquals(expected, results);
@@ -541,7 +541,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void ensurePrevNameIsCorrectWhenMovingNodes()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -585,7 +585,7 @@ public void onCancelled(DatabaseError error) {}
 
     ref.child("c").setPriority(0.5);
 
-    TestHelpers.waitFor(semaphore, 6);
+    IntegrationTestHelpers.waitFor(semaphore, 6);
 
     List<String> expected = new ArrayList<String>();
     expected.add("MOVED:d/null");
@@ -601,7 +601,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void ensurePrevNameIsCorrectWhenMovingNodesBySettingWholeJSON()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -666,7 +666,7 @@ public void onCancelled(DatabaseError error) {}
             .put("a", new MapBuilder().put(".value", "a").put(".priority", 4).build())
             .build());
 
-    TestHelpers.waitFor(semaphore, 6);
+    IntegrationTestHelpers.waitFor(semaphore, 6);
 
     List<String> expected = new ArrayList<String>();
     expected.add("MOVED:d/null");
@@ -683,7 +683,7 @@ public void onCancelled(DatabaseError error) {}
   public void case595ShouldNotGetChildMovedWhenDeletingPrioritizedGrandChild()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ChildEventListener listener =
         ref.addChildEventListener(
@@ -723,7 +723,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void canSetValuePriorityToZero()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = new ReadFuture(ref);
     ref.setValue("test", 0);
@@ -736,7 +736,7 @@ public void canSetValuePriorityToZero()
   @Test
   public void canSetObjectPriorityToZero()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = new ReadFuture(ref);
     ref.setValue(new MapBuilder().put("x", "test").put("y", 7).build(), 0);
@@ -749,7 +749,7 @@ public void canSetObjectPriorityToZero()
   @Test
   public void case2003ShouldGetChildMovedForAnyPriorityChangeRegardlessOfOrder()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -791,7 +791,7 @@ public void onCancelled(DatabaseError error) {}
             .build());
 
     ref.child("b").setPriority(1.5);
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
 
     assertEquals(2, results.size());
     assertEquals(Arrays.asList("MOVED:b/a", "CHANGED:b/a"), results);
@@ -801,7 +801,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void case2003ShouldGetChildMovedForAnyPriorityChangeRegardlessOfOrder2()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> results = new ArrayList<String>();
     final Semaphore semaphore = new Semaphore(0);
@@ -852,7 +852,7 @@ public void onCancelled(DatabaseError error) {
             .put("d", new MapBuilder().put(".value", "d").put(".priority", 3).build())
             .build());
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
 
     assertEquals(2, results.size());
     assertEquals(Arrays.asList("MOVED:b/a", "CHANGED:b/a"), results);
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/PerformanceBenchmarks.java b/firebase-database/src/androidTest/java/com/google/firebase/database/PerformanceBenchmarks.java
index 4c671ef4d..9442b3ff2 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/PerformanceBenchmarks.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/PerformanceBenchmarks.java
@@ -55,7 +55,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
 
   // @Test
   public void queryPerformance() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     System.err.println("Setting up...");
 
@@ -144,7 +144,7 @@ private Object randomObject(int recursionDepth, int recursionFanOut) {
 
   // @Test
   public void largeValuePerformance() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final int approximateObjectSize = 2 * 1024 * 1024;
     final int topLevelChildren = 200;
@@ -211,7 +211,7 @@ public void onCancelled(DatabaseError error) {}
 
   // @Test
   public void childObserverPerformance() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final int numberOfChildren = 50000;
 
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
index dba20f32d..d3eef2aeb 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/QueryTest.java
@@ -48,13 +48,13 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
   public void canCreateBasicQueries() throws DatabaseException {
     // Just make sure they don't throw anything
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.limitToLast(10);
     ref.startAt("199").limitToLast(10);
@@ -71,7 +71,7 @@ public void canCreateBasicQueries() throws DatabaseException {
 
   @Test
   public void invalidPathsToOrderByThrow() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     List<String> badKeys =
         Arrays.asList(
@@ -97,7 +97,7 @@ public void invalidPathsToOrderByThrow() throws DatabaseException {
 
   @Test
   public void invalidQueriesThrow() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     try {
       ref.orderByKey().orderByPriority();
@@ -309,7 +309,7 @@ public void invalidQueriesThrow() throws DatabaseException {
 
   @Test
   public void passingInvalidKeysToStartAtOrEndAtThrows() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     List<String> badKeys =
         Arrays.asList(
@@ -337,7 +337,7 @@ public void passingInvalidKeysToStartAtOrEndAtThrows() throws DatabaseException
   public void listenerCanBeRemovedFromSpecificQuery()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ValueEventListener listener =
@@ -357,7 +357,7 @@ public void onCancelled(DatabaseError error) {}
     semaphore.acquire();
     ref.limitToLast(5).removeEventListener(listener);
     new WriteFuture(ref, new MapBuilder().put("a", 6).put("b", 5).build()).timedGet();
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
     assertEquals(0, semaphore.availablePermits());
   }
 
@@ -365,7 +365,7 @@ public void onCancelled(DatabaseError error) {}
   public void removingListenersWorks()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ValueEventListener listener =
@@ -382,10 +382,10 @@ public void onCancelled(DatabaseError error) {}
                 });
 
     ref.setValue(new MapBuilder().put("a", 5).put("b", 6).build());
-    TestHelpers.waitFor(semaphore, 1);
+    IntegrationTestHelpers.waitFor(semaphore, 1);
     ref.limitToLast(5).removeEventListener(listener);
     new WriteFuture(ref, new MapBuilder().put("a", 6).put("b", 5).build()).timedGet();
-    TestHelpers.waitForQueue(ref);
+    IntegrationTestHelpers.waitForQueue(ref);
 
     assertEquals(0, semaphore.availablePermits());
   }
@@ -395,7 +395,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void limit5ShouldHave5Children()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -419,14 +419,14 @@ public void limit5ShouldHave5Children()
   public void serverShouldOnlySend5Items()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     for (int i = 0; i < 9; ++i) {
       ref.push().setValue(i);
     }
     new WriteFuture(ref.push(), 9).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToLast(5));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToLast(5));
 
     long i = 5;
     for (DataSnapshot child : snap.getChildren()) {
@@ -439,7 +439,7 @@ public void serverShouldOnlySend5Items()
 
   @Test
   public void setVariousLimitsEnsureDataIsCorrect() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper expectations = new ValueExpectationHelper();
     expectations.add(ref.limitToLast(1), new MapBuilder().put("c", 3L).build());
@@ -457,7 +457,7 @@ public void setVariousLimitsEnsureDataIsCorrect() throws DatabaseException, Inte
 
   @Test
   public void setVariousLimitsWithStartAtName() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper expectations = new ValueExpectationHelper();
     expectations.add(ref.startAt(null).limitToFirst(1), new MapBuilder().put("a", 1L).build());
@@ -477,7 +477,7 @@ public void setVariousLimitsWithStartAtName() throws DatabaseException, Interrup
   public void setVariousLimitsWithStartAtNameWithServerData()
       throws DatabaseException, InterruptedException, TestFailure, ExecutionException,
           TimeoutException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // TODO: this test kinda has race conditions. The listens are added sequentially, so we get a
     // lot of partial data back from the server. This all correct, and we end up in the correct
@@ -502,7 +502,7 @@ public void setVariousLimitsWithStartAtNameWithServerData()
   public void setLimitEnsureChildRemovedAndChildAddedHitWhenLimitIsHit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -552,7 +552,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildRemovedAndChildAddedHitWhenLimitIsHitWithServerData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -587,7 +587,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     List<String> expected = new ArrayList<String>();
     expected.add("b");
     expected.add("c");
@@ -605,7 +605,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildRemovedAndChildAddedHitWhenLimitIsHitFromFront()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -656,7 +656,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildRemovedAndChildAddedHitWhenLimitIsHitFromFrontWithServerData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -692,7 +692,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     List<String> expected = new ArrayList<String>();
     expected.add("a");
     expected.add("b");
@@ -710,7 +710,7 @@ public void onCancelled(DatabaseError error) {}
   public void setStartAndLimitEnsureChildAddedFiredWhenLimitIsntHit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -760,7 +760,7 @@ public void onCancelled(DatabaseError error) {}
   public void setStartAndLimitEnsureChildAddedFiredWhenLimitIsntHitWithServerData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, new MapBuilder().put("c", 3).build()).timedGet();
 
@@ -796,7 +796,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     List<String> expected = new ArrayList<String>();
     expected.add("c");
     DeepEquals.assertEquals(expected, added);
@@ -813,7 +813,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildAddedAndChildRemovedAreFiredWhenAnElementIsRemoved()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -865,7 +865,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildAddedAndChildRemovedAreFiredWhenAnElementIsRemovedUsingServerData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, new MapBuilder().put("a", 1).put("b", 2).put("c", 3).build()).timedGet();
     final List<String> added = new ArrayList<String>();
@@ -899,7 +899,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     List<String> expected = new ArrayList<String>();
     expected.add("b");
     expected.add("c");
@@ -919,7 +919,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildRemovedFiredWhenAllElementsRemoved()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> added = new ArrayList<String>();
     final List<String> removed = new ArrayList<String>();
@@ -973,7 +973,7 @@ public void onCancelled(DatabaseError error) {}
   public void setLimitEnsureChildRemovedFiredWhenAllElementsRemovedUsingServerData()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, new MapBuilder().put("b", 2).put("c", 3).build()).timedGet();
     final List<String> added = new ArrayList<String>();
@@ -1008,7 +1008,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
                   public void onCancelled(DatabaseError error) {}
                 });
 
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
     List<String> expected = new ArrayList<String>();
     expected.add("b");
     expected.add("c");
@@ -1029,7 +1029,7 @@ public void onCancelled(DatabaseError error) {}
 
   @Test
   public void startAtEndAtWithPriorityWorks() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper helper = new ValueExpectationHelper();
     helper.add(
@@ -1052,7 +1052,7 @@ public void startAtEndAtWithPriorityWorks() throws DatabaseException, Interrupte
   @Test
   public void startAtEndAtWithPriorityWorksWithServerData()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1075,7 +1075,7 @@ public void startAtEndAtWithPriorityWorksWithServerData()
   @Test
   public void startAtEndAtWithPriorityAndNameWorks()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper helper = new ValueExpectationHelper();
     helper.add(
@@ -1099,7 +1099,7 @@ public void startAtEndAtWithPriorityAndNameWorks()
   @Test
   public void startAtEndAtWithPriorityAndNameWorksWithServerData()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1123,7 +1123,7 @@ public void startAtEndAtWithPriorityAndNameWorksWithServerData()
   @Test
   public void startAtEndAtWithPriorityAndNameWorks2()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper helper = new ValueExpectationHelper();
     helper.add(
@@ -1147,7 +1147,7 @@ public void startAtEndAtWithPriorityAndNameWorks2()
   @Test
   public void startAtEndAtWithPriorityAndNameWorksWithServerData2()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1172,7 +1172,7 @@ public void startAtEndAtWithPriorityAndNameWorksWithServerData2()
   public void ensurePrevNameWorksWithLimit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> names = new ArrayList<String>();
     ref.limitToLast(2)
@@ -1218,7 +1218,7 @@ public void onCancelled(DatabaseError error) {}
   public void setALimitMoveNodesCheckPrevName()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> names = new ArrayList<String>();
     ref.limitToLast(2)
@@ -1273,7 +1273,7 @@ public void onCancelled(DatabaseError error) {}
   public void setALimitAddNodesRemotelyWatchForEvents()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1330,14 +1330,14 @@ public void onCancelled(DatabaseError error) {
             "2 removed",
             "4 added"));
     // Make sure we wait for all the events
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     DeepEquals.assertEquals(expected, events);
     reader.limitToLast(2).removeEventListener(listener);
   }
 
   @Test
   public void attachingAListenerReturnsTheListener() throws DatabaseException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueEventListener listener =
         ref.limitToLast(1)
@@ -1358,7 +1358,7 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void limitOnUnsyncedNodeFiresValueEvent()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     // This will timeout if value never fires
     org.junit.Assert.assertEquals(1, new ReadFuture(ref.limitToLast(1)).timedGet().size());
@@ -1366,7 +1366,7 @@ public void limitOnUnsyncedNodeFiresValueEvent()
 
   @Test
   public void filteringToOnlyNullPrioritiesWorks() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1377,7 +1377,7 @@ public void filteringToOnlyNullPrioritiesWorks() throws DatabaseException, Inter
             .put("e", new MapBuilder().put(".priority", "hi").put(".value", 4).build())
             .build());
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.endAt(null));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.endAt(null));
     Map<String, Object> expected = new MapBuilder().put("a", 0L).put("b", 1L).build();
     Object result = snap.getValue();
     DeepEquals.assertEquals(expected, result);
@@ -1385,7 +1385,7 @@ public void filteringToOnlyNullPrioritiesWorks() throws DatabaseException, Inter
 
   @Test
   public void nullPrioritiesIncludedInEndAt2() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1396,7 +1396,7 @@ public void nullPrioritiesIncludedInEndAt2() throws DatabaseException, Interrupt
             .put("e", new MapBuilder().put(".priority", "hi").put(".value", 4).build())
             .build());
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.endAt(2));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.endAt(2));
     Map<String, Object> expected = new MapBuilder().put("a", 0L).put("b", 1L).put("c", 2L).build();
     Object result = snap.getValue();
     DeepEquals.assertEquals(expected, result);
@@ -1404,7 +1404,7 @@ public void nullPrioritiesIncludedInEndAt2() throws DatabaseException, Interrupt
 
   @Test
   public void nullPrioritiesIncludedInStartAt2() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(
         new MapBuilder()
@@ -1415,7 +1415,7 @@ public void nullPrioritiesIncludedInStartAt2() throws DatabaseException, Interru
             .put("e", new MapBuilder().put(".priority", "hi").put(".value", 4).build())
             .build());
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.startAt(2));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.startAt(2));
     Map<String, Object> expected = new MapBuilder().put("c", 2L).put("d", 3L).put("e", 4L).build();
     Object result = snap.getValue();
     DeepEquals.assertEquals(expected, result);
@@ -1445,7 +1445,7 @@ public void onCancelled(DatabaseError error) {
   @Test
   @Ignore // TODO: re-enable once dumpListens is implemented again
   public void dedupeListensListenOnParent() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ValueEventListener listener = dummyListener();
 
     assertEquals("[]", dumpListens(ref));
@@ -1473,7 +1473,7 @@ public void dedupeListensListenOnParent() throws DatabaseException, InterruptedE
   @Test
   @Ignore // TODO: re-enable once dumpListens is implemented again
   public void dedupeListensListenOnGrandChild() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ValueEventListener listener = dummyListener();
 
     ref.addValueEventListener(listener);
@@ -1497,7 +1497,7 @@ public void dedupeListensListenOnGrandChild() throws DatabaseException, Interrup
   @Ignore // TODO: re-enable once dumpListens is implemented again
   public void dedupeListensListenOnGrandparentOfTwoChildren()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ValueEventListener listener = dummyListener();
 
     String listens = dumpListens(ref);
@@ -1533,7 +1533,7 @@ public void dedupeListensListenOnGrandparentOfTwoChildren()
   // broken with org.json.  Need to make more robust.
   public void dedupeQueriedListensMultipleListensNoDupes()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ValueEventListener listener = dummyListener();
 
     ref.child("a").limitToLast(1).addValueEventListener(listener);
@@ -1564,7 +1564,7 @@ public void dedupeQueriedListensMultipleListensNoDupes()
   @Test
   public void limitWithMixOfNullAndNonNullPrioritiesUsingServerData()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     Map<String, Object> toSet =
         new MapBuilder()
             .put(
@@ -1635,7 +1635,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("Sally", "James", "Andrew", "Mike", "Vikrum"));
     DeepEquals.assertEquals(expected, names);
@@ -1643,7 +1643,7 @@ public void onCancelled(DatabaseError error) {}
 
   @Test
   public void limitOnNodeWithPriority() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
 
     final Map data = new MapBuilder().put("a", "blah").put(".priority", "priority").build();
@@ -1669,13 +1669,13 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void limitWithMixOfNullAndNonNullPriorities()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     Map<String, Object> toSet =
         new MapBuilder()
             .put(
@@ -1749,7 +1749,7 @@ public void onCancelled(DatabaseError error) {
                   }
                 });
     ref.setValue(toSet);
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     List<String> expected = new ArrayList<String>();
     expected.addAll(Arrays.asList("Sally", "James", "Andrew", "Mike", "Vikrum"));
     DeepEquals.assertEquals(expected, names);
@@ -1761,12 +1761,12 @@ public void onCancelled(DatabaseError error) {
   @Test
   public void handlesAnUpdateThatDeletesEntireQueryWindow()
       throws DatabaseException, InterruptedException, TestFailure, TimeoutException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture readFuture = ReadFuture.untilCount(ref.limitToLast(2), 3);
 
     // wait for null event
-    TestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(ref);
 
     ref.setValue(
         new MapBuilder()
@@ -1795,7 +1795,7 @@ public void handlesAnUpdateThatDeletesEntireQueryWindow()
   public void handlesAnOutOfViewQueryOnAChild()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture parentFuture = ReadFuture.untilCountAfterNull(ref.limitToLast(1), 2);
 
@@ -1835,7 +1835,7 @@ public void onCancelled(DatabaseError error) {}
   public void handlesAChildQueryGoingOutOfViewOfTheParent()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ReadFuture parentFuture = ReadFuture.untilCountAfterNull(ref.limitToLast(1), 3);
 
@@ -1884,7 +1884,7 @@ public void onCancelled(DatabaseError error) {
   public void handlesDivergingViews()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<DataSnapshot> cSnaps = new ArrayList<DataSnapshot>();
     final List<DataSnapshot> dSnaps = new ArrayList<DataSnapshot>();
@@ -1939,7 +1939,7 @@ public void onCancelled(DatabaseError error) {}
   public void handlesRemovingAQueriedElement()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<Long> vals = new ArrayList<Long>();
     final Semaphore semaphore = new Semaphore(0);
@@ -1976,7 +1976,7 @@ public void onCancelled(DatabaseError error) {}
 
     ref.setValue(new MapBuilder().put("a", 1).put("b", 2).build());
     ref.child("b").removeValue();
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     List<Long> expected = new ArrayList<Long>();
     expected.addAll(Arrays.asList(2L, 1L));
     DeepEquals.assertEquals(expected, vals);
@@ -1984,10 +1984,10 @@ public void onCancelled(DatabaseError error) {}
 
   @Test
   public void startAtLimitWorks() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(new MapBuilder().put("a", 1).put("b", 2).build());
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToFirst(1));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToFirst(1));
 
     assertEquals(1L, snap.child("a").getValue());
   }
@@ -1995,7 +1995,7 @@ public void startAtLimitWorks() throws DatabaseException, InterruptedException {
   @Test
   public void startAtLimitWorksWhenChildIsRemovedCase1664()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(new MapBuilder().put("a", 1).put("b", 2).build());
     final List<Long> vals = new ArrayList<Long>();
@@ -2030,10 +2030,10 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for first value
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals((Long) 1L, vals.get(0));
     ref.child("a").removeValue();
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals((Long) 2L, vals.get(1));
   }
 
@@ -2041,7 +2041,7 @@ public void onCancelled(DatabaseError error) {}
   public void startAtWithTwoArgumentsWorksCase1169()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(
             ref,
@@ -2063,7 +2063,7 @@ public void startAtWithTwoArgumentsWorksCase1169()
                 .build())
         .timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.startAt(20, "Walker").limitToFirst(2));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.startAt(20, "Walker").limitToFirst(2));
     List<String> expected = Arrays.asList("Walker", "Michael");
     int i = 0;
     for (DataSnapshot child : snap.getChildren()) {
@@ -2077,7 +2077,7 @@ public void startAtWithTwoArgumentsWorksCase1169()
   public void handlesMultipleQueriesOnTheSameNode()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(
             ref,
@@ -2109,9 +2109,9 @@ public void onCancelled(DatabaseError error) {}
 
     // Skipping nested calls, no re-entrant APIs in Java
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToLast(1));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToLast(1));
     Map<String, Object> expected = new MapBuilder().put("f", 6L).build();
 
     DeepEquals.assertEquals(expected, snap.getValue());
@@ -2121,7 +2121,7 @@ public void onCancelled(DatabaseError error) {}
   public void handlesOnceCalledOnANodeWithADefaultListener()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(
             ref,
@@ -2150,9 +2150,9 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToLast(1));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToLast(1));
     Map<String, Object> expected = new MapBuilder().put("f", 6L).build();
 
     DeepEquals.assertEquals(expected, snap.getValue());
@@ -2162,7 +2162,7 @@ public void onCancelled(DatabaseError error) {}
   public void handlesOnceCalledOnANodeWithADefaultListenerAndNonCompleteLimit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, new MapBuilder().put("a", 1).put("b", 2).put("c", 3).build()).timedGet();
 
@@ -2181,7 +2181,7 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToLast(5));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToLast(5));
     Map<String, Object> expected = new MapBuilder().put("a", 1L).put("b", 2L).put("c", 3L).build();
 
     DeepEquals.assertEquals(expected, snap.getValue());
@@ -2191,7 +2191,7 @@ public void onCancelled(DatabaseError error) {}
   public void remoteRemoveEventTriggers()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     final DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2234,7 +2234,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void endAtWithTwoArgumentsAndLimitWorks()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> toSet =
         new MapBuilder()
@@ -2250,7 +2250,7 @@ public void endAtWithTwoArgumentsAndLimitWorks()
 
     new WriteFuture(ref, toSet).timedGet();
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.endAt(null, "f").limitToLast(5));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.endAt(null, "f").limitToLast(5));
     Map<String, Object> expected =
         new MapBuilder()
             .put("b", "b")
@@ -2267,7 +2267,7 @@ public void endAtWithTwoArgumentsAndLimitWorks()
   public void complexUpdateAtQueryRootRaisesCorrectValueEvent()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2289,7 +2289,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     Map<String, Object> update =
         new MapBuilder()
             .put("b", null)
@@ -2316,7 +2316,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void updateAtQueryRootRaisesCorrectValueEvent()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2338,7 +2338,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     Map<String, Object> update =
         new MapBuilder().put("bar", "d").put("bam", null).put("bat", "e").build();
     writer.updateChildren(update);
@@ -2358,7 +2358,7 @@ public boolean isComplete(List<EventRecord> events) {
   public void listenForChildAddedEventsWithLimit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     writer.child("a").setValue(1);
@@ -2414,14 +2414,14 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
   }
 
   @Test
   public void listenForChildChangedEventsWithLimit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     new WriteFuture(
@@ -2452,7 +2452,7 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for the read to be initialized
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     reader
         .limitToLast(3)
@@ -2501,14 +2501,14 @@ public void onCancelled(DatabaseError error) {}
     writer.child("b").setValue("b");
     writer.child("c").setValue(deepObject);
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
   }
 
   @Test
   public void listenForChildRemoveEventsWithLimit()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     writer.child("a").setValue(1);
@@ -2538,7 +2538,7 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for the read to be initialized
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     reader
         .limitToLast(3)
@@ -2584,14 +2584,14 @@ public void onCancelled(DatabaseError error) {}
     writer.child("b").removeValue();
     writer.child("c").removeValue();
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
   }
 
   @Test
   public void listenForChildRemovedWhenParentRemoved()
       throws DatabaseException, InterruptedException, TestFailure, ExecutionException,
           TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     writer.child("a").setValue(1);
@@ -2621,7 +2621,7 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for the read to be initialized
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     reader
         .limitToLast(3)
@@ -2665,14 +2665,14 @@ public void onCancelled(DatabaseError error) {}
 
     writer.removeValue();
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
   }
 
   @Test
   public void listenForChildRemovedWhenParentSetToScalar()
       throws DatabaseException, InterruptedException, TestFailure, ExecutionException,
           TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     writer.child("a").setValue(1);
@@ -2702,7 +2702,7 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for the read to be initialized
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     reader
         .limitToLast(3)
@@ -2746,14 +2746,14 @@ public void onCancelled(DatabaseError error) {}
 
     writer.setValue("scalar");
 
-    TestHelpers.waitFor(semaphore, 3);
+    IntegrationTestHelpers.waitFor(semaphore, 3);
   }
 
   @Test
   public void queriesBehaveAfterOnce()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2762,7 +2762,7 @@ public void queriesBehaveAfterOnce()
 
     new WriteFuture(writer, toSet).timedGet();
 
-    TestHelpers.getSnap(reader);
+    IntegrationTestHelpers.getSnap(reader);
 
     final Semaphore semaphore = new Semaphore(0);
     final AtomicInteger queryAddedCount = new AtomicInteger(0);
@@ -2823,7 +2823,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(semaphore, 5);
+    IntegrationTestHelpers.waitFor(semaphore, 5);
     assertEquals(1, queryAddedCount.get());
     assertEquals(4, defaultAddedCount.get());
   }
@@ -2832,7 +2832,7 @@ public void onCancelled(DatabaseError error) {}
   public void case2003CorrectlyGetEventsForStartAtEndAtQueriesWhenPriorityChanges()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final List<String> addedFirst = new ArrayList<String>();
     final List<String> removedFirst = new ArrayList<String>();
@@ -2918,7 +2918,7 @@ public void onCancelled(DatabaseError error) {}
   public void behavesWithDivergingQueries()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     final DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -2972,7 +2972,7 @@ public boolean isComplete(List<EventRecord> events) {
   @Test
   public void staleItemsRemovedFromTheCache()
       throws InterruptedException, TestFailure, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference reader = refs.get(0);
     DatabaseReference writer = refs.get(1);
 
@@ -2996,7 +2996,7 @@ public boolean isComplete(List<EventRecord> events) {
               }
             });
 
-    TestHelpers.waitFor(ready);
+    IntegrationTestHelpers.waitFor(ready);
     for (int i = 0; i < 4; ++i) {
       writer.child("k" + i).setValue(i);
     }
@@ -3008,7 +3008,7 @@ public boolean isComplete(List<EventRecord> events) {
   @Test
   public void integerKeysBehaveNumerically1()
       throws InterruptedException, TestFailure, TimeoutException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
     ref.setValue(
         new MapBuilder()
@@ -3045,13 +3045,13 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void integerKeysBehaveNumerically2()
       throws InterruptedException, TestFailure, TimeoutException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
     ref.setValue(
         new MapBuilder()
@@ -3089,13 +3089,13 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void integerKeysBehaveNumerically3()
       throws InterruptedException, TestFailure, TimeoutException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
     ref.setValue(
         new MapBuilder()
@@ -3133,13 +3133,13 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void moveOutsideOfWindowIntoWindow()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     Map<String, Object> initialValue =
         new MapBuilder()
             .put("a", new MapBuilder().put(".priority", 1L).put(".value", "a").build())
@@ -3169,7 +3169,7 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(ready);
+    IntegrationTestHelpers.waitFor(ready);
 
     ref.child("a")
         .setPriority(
@@ -3181,16 +3181,16 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               }
             });
 
-    TestHelpers.waitFor(ready);
+    IntegrationTestHelpers.waitFor(ready);
   }
 
   @Test
   public void emptyLimitWithBadHash() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.getRepo().setHijackHash(true);
 
-    DataSnapshot snap = TestHelpers.getSnap(ref.limitToLast(1));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(ref.limitToLast(1));
     assertNull(snap.getValue());
 
     ref.getRepo().setHijackHash(false);
@@ -3199,7 +3199,7 @@ public void emptyLimitWithBadHash() throws InterruptedException {
   @Test
   public void addingQueriesDoesNotAffectOthers()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref.child("0"), "test1").timedGet();
 
@@ -3230,7 +3230,7 @@ public void onCancelled(DatabaseError firebaseError) {}
 
   @Test
   public void equalToOnlyReturnsChildrenEqualTo() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ValueExpectationHelper expectations = new ValueExpectationHelper();
     expectations.add(ref.equalTo(1), new MapBuilder().put("a", "vala").build());
@@ -3250,7 +3250,7 @@ public void equalToOnlyReturnsChildrenEqualTo() throws DatabaseException, Interr
   @Test
   public void removeListenerOnDefaultQueryRemovesAllQueryListeners()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     new WriteFuture(ref.child("a"), "foo", 100).timedGet();
 
     final Semaphore semaphore = new Semaphore(0);
@@ -3272,7 +3272,7 @@ public void onCancelled(DatabaseError error) {
                   }
                 });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     Map<String, Object> expected = new MapBuilder().put("a", "foo").build();
     DeepEquals.assertEquals(expected, snapshotHolder[0].getValue());
 
@@ -3285,7 +3285,7 @@ public void onCancelled(DatabaseError error) {
 
   @Test
   public void handlesFallbackForOrderBy() throws InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
 
     Map<String, Object> initial =
@@ -3304,7 +3304,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     final List<String> children = new ArrayList<String>();
     ref.orderByChild("foo")
@@ -3331,7 +3331,7 @@ public void onChildMoved(DataSnapshot snapshot, String previousChildName) {}
               public void onCancelled(DatabaseError error) {}
             });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     List<String> expected = new ArrayList<String>();
     expected.add("b");
@@ -3343,8 +3343,8 @@ public void onCancelled(DatabaseError error) {}
   @Test
   public void notifiesOfDeletesWhileOffline() throws DatabaseException, InterruptedException {
     // Create a fresh connection so we can be sure we won't get any other data updates for stuff.
-    DatabaseReference writerRef = TestHelpers.getRandomNode();
-    final DatabaseConfig ctx = TestHelpers.newTestConfig();
+    DatabaseReference writerRef = IntegrationTestHelpers.getRandomNode();
+    final DatabaseConfig ctx = IntegrationTestHelpers.newTestConfig();
     final DatabaseReference queryRef = new DatabaseReference(writerRef.toString(), ctx);
     final List<DataSnapshot> readSnaps = new ArrayList<DataSnapshot>();
     final Semaphore semaphore = new Semaphore(0);
@@ -3380,7 +3380,7 @@ public void onCancelled(DatabaseError error) {}
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     // Now make the queryRef go offline so we don't get updates.
     RepoManager.interrupt(ctx);
@@ -3398,14 +3398,14 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             });
 
     // Now wait for us to get notified that b is deleted.
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void querySnapshotChildrenRespectDefaultOrdering()
       throws DatabaseException, ExecutionException, TimeoutException, TestFailure,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
     final Semaphore semaphore = new Semaphore(0);
@@ -3492,7 +3492,7 @@ public void onDataChange(DataSnapshot snapshot) {
               @Override
               public void onCancelled(DatabaseError error) {}
             });
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
@@ -3506,7 +3506,7 @@ public void testAddingListensForTheSamePathDoesNotCheckFail() throws Throwable {
     // default view. This left the zombie one-time listener and check failed on the second attempt
     // to create a listener for the same path (asana#61028598952586).
 
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
 
     ValueEventListener dummyListen =
@@ -3520,17 +3520,17 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         };
 
-    ref.child("child").setValue(TestHelpers.fromJsonString("{\"name\": \"John\"}"));
+    ref.child("child").setValue(IntegrationTestHelpers.fromJsonString("{\"name\": \"John\"}"));
 
     ref.orderByChild("name").equalTo("John").addValueEventListener(dummyListen);
     ref.child("child").addValueEventListener(dummyListen);
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
 
     ref.child("child").child("favoriteToy").addListenerForSingleValueEvent(dummyListen);
-    TestHelpers.waitFor(semaphore, 1);
+    IntegrationTestHelpers.waitFor(semaphore, 1);
 
     ref.child("child").child("favoriteToy").addListenerForSingleValueEvent(dummyListen);
-    TestHelpers.waitFor(semaphore, 1);
+    IntegrationTestHelpers.waitFor(semaphore, 1);
 
     ref.removeEventListener(dummyListen);
     ref.child("child").removeEventListener(dummyListen);
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
index 8ba43ef1f..898db04ab 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/RealtimeTest.java
@@ -45,7 +45,7 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
@@ -66,10 +66,10 @@ public void testUrlParsing() throws DatabaseException {
   @Test
   public void testOnDisconnectSetWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -99,7 +99,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value on both reader and writer.
-    TestHelpers.waitFor(valSemaphore, 2);
+    IntegrationTestHelpers.waitFor(valSemaphore, 2);
 
     Object expected = "dummy";
     writer
@@ -115,7 +115,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(1);
     EventRecord readerEventRecord = readerFuture.timedGet().get(1);
@@ -129,10 +129,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectSetWithPriorityWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -162,7 +162,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value on both reader and writer.
-    TestHelpers.waitFor(valSemaphore, 2);
+    IntegrationTestHelpers.waitFor(valSemaphore, 2);
 
     Object expected = true;
     String expectedPriority = "12345";
@@ -180,7 +180,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(1);
     EventRecord readerEventRecord = readerFuture.timedGet().get(1);
@@ -197,10 +197,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectRemoveWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -228,7 +228,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value on both reader and writer.
-    TestHelpers.waitFor(valSemaphore, 2);
+    IntegrationTestHelpers.waitFor(valSemaphore, 2);
 
     writer
         .child("foo")
@@ -240,7 +240,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo")
@@ -253,7 +253,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(2);
     EventRecord readerEventRecord = readerFuture.timedGet().get(2);
@@ -268,10 +268,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectUpdateWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -299,7 +299,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value on both reader and writer.
-    TestHelpers.waitFor(valSemaphore, 2);
+    IntegrationTestHelpers.waitFor(valSemaphore, 2);
 
     Map<String, Object> initialValues = new MapBuilder().put("bar", "a").put("baz", "b").build();
     writer
@@ -312,7 +312,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     Map<String, Object> updatedValues = new MapBuilder().put("baz", "c").put("bat", "d").build();
     writer
@@ -328,7 +328,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(3);
     EventRecord readerEventRecord = readerFuture.timedGet().get(2);
@@ -346,9 +346,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectTriggersSingleLocalValueEventForWriter()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
@@ -364,7 +364,7 @@ public boolean isComplete(List<EventRecord> events) {
                 return events.size() == 2;
               }
             });
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     final Semaphore opSemaphore = new Semaphore(0);
     writer
@@ -378,7 +378,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo")
@@ -391,7 +391,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo/baz")
@@ -403,12 +403,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     RepoManager.interrupt(ctx);
     ;
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
     EventRecord writerEventRecord = writerFuture.timedGet().get(1);
 
     RepoManager.resume(ctx);
@@ -425,10 +425,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectTriggersSingleLocalValueEventForReader()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
@@ -444,7 +444,7 @@ public boolean isComplete(List<EventRecord> events) {
                 return events.size() == 2;
               }
             });
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     final Semaphore opSemaphore = new Semaphore(0);
     writer
@@ -458,7 +458,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo")
@@ -471,7 +471,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo/baz")
@@ -483,12 +483,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     RepoManager.interrupt(ctx);
     ;
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
     EventRecord readerEventRecord = readerFuture.timedGet().get(1);
 
     RepoManager.resume(ctx);
@@ -505,9 +505,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectTriggersSingleLocalValueEventForWriterWithQuery()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
     ;
 
@@ -524,7 +524,7 @@ public boolean isComplete(List<EventRecord> events) {
                 return events.size() == 2;
               }
             });
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     final Semaphore opSemaphore = new Semaphore(0);
     writer
@@ -538,7 +538,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo")
@@ -551,7 +551,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo/baz")
@@ -563,12 +563,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     RepoManager.interrupt(ctx);
     ;
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
     EventRecord writerEventRecord = writerFuture.timedGet().get(1);
 
     RepoManager.resume(ctx);
@@ -585,10 +585,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectTriggersSingleLocalValueEventForReaderWithQuery()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
     final Semaphore valSemaphore = new Semaphore(0);
@@ -603,7 +603,7 @@ public boolean isComplete(List<EventRecord> events) {
                 return events.size() == 2;
               }
             });
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     final Semaphore opSemaphore = new Semaphore(0);
     writer
@@ -617,7 +617,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo")
@@ -630,7 +630,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo/baz")
@@ -642,12 +642,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     RepoManager.interrupt(ctx);
     ;
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
     EventRecord readerEventRecord = readerFuture.timedGet().get(1);
 
     RepoManager.resume(ctx);
@@ -664,10 +664,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectDeepMergeTriggersOnlyOneValueEventForReaderWithQuery()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     final AtomicInteger callbackCount = new AtomicInteger(0);
     final Semaphore valSemaphore = new Semaphore(0);
@@ -682,7 +682,7 @@ public boolean isComplete(List<EventRecord> events) {
                 return events.size() == 3;
               }
             });
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     final Semaphore opSemaphore = new Semaphore(0);
     Map<String, Object> initialValues =
@@ -704,8 +704,8 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             opSemaphore.release(1);
           }
         });
-    TestHelpers.waitFor(valSemaphore);
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("b/c")
@@ -718,7 +718,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("b/d")
@@ -730,11 +730,11 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release(1);
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     RepoManager.interrupt(ctx);
 
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
     EventRecord readerEventRecord = readerFuture.timedGet().get(2);
 
     RepoManager.resume(ctx);
@@ -756,10 +756,10 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectCancelWorks()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
     ;
 
@@ -788,7 +788,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value on both reader and writer.
-    TestHelpers.waitFor(valSemaphore, 2);
+    IntegrationTestHelpers.waitFor(valSemaphore, 2);
 
     Map<String, Object> initialValues = new MapBuilder().put("bar", "a").put("baz", "b").build();
     writer
@@ -801,7 +801,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     Map<String, Object> updatedValues = new MapBuilder().put("baz", "c").put("bat", "d").build();
     writer
@@ -815,7 +815,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     writer
         .child("foo/bat")
@@ -829,7 +829,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord writerEventRecord = writerFuture.timedGet().get(2);
     EventRecord readerEventRecord = readerFuture.timedGet().get(2);
@@ -846,9 +846,9 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testOnDisconnectWithServerValuesWorks()
       throws TestFailure, TimeoutException, DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(1);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(1);
     DatabaseReference writer = refs.get(0);
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore opSemaphore = new Semaphore(0);
@@ -866,7 +866,7 @@ public boolean isComplete(List<EventRecord> events) {
             });
 
     // Wait for initial (null) value.
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
 
     Map<String, Object> initialValues =
         new MapBuilder()
@@ -891,7 +891,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
                 opSemaphore.release();
               }
             });
-    TestHelpers.waitFor(opSemaphore);
+    IntegrationTestHelpers.waitFor(opSemaphore);
 
     EventRecord readerEventRecord = writerFuture.timedGet().get(1);
     DataSnapshot snap = readerEventRecord.getSnapshot();
@@ -913,7 +913,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Ignore
   public void testShutdown()
       throws InterruptedException, ExecutionException, TestFailure, TimeoutException {
-    DatabaseConfig config = TestHelpers.newTestConfig();
+    DatabaseConfig config = IntegrationTestHelpers.newTestConfig();
     config.setLogLevel(Logger.Level.DEBUG);
     DatabaseReference ref = new DatabaseReference(IntegrationTestValues.getNamespace(), config);
 
@@ -949,16 +949,16 @@ public void onCancelled(DatabaseError error) {}
             });
 
     // Wait for us to be connected so we send the buffered put
-    TestHelpers.waitFor(ready);
+    IntegrationTestHelpers.waitFor(ready);
 
-    DataSnapshot snap = TestHelpers.getSnap(pushed);
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(pushed);
     assertEquals("foo", snap.getValue(String.class));
   }
 
   @Test
   public void testWritesToSameLocationWhileOfflineAreInOrder()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     DatabaseReference.goOffline();
     for (int i = 0; i < 100; i++) {
@@ -984,14 +984,14 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void testOnDisconnectIsNotRerunOnReconnect()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
-    final DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
+    final DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
     RepoManager.resume(ctx);
 
     final Semaphore semaphore = new Semaphore(0);
@@ -1018,7 +1018,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
     RepoManager.resume(ctx);
 
     // Should be complete initially
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     // One onComplete called
     assertEquals(1, counter[0]);
 
@@ -1027,8 +1027,8 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
     RepoManager.resume(ctx);
 
     // Make sure we sent all outstanding onDisconnects
-    TestHelpers.waitForRoundtrip(ref);
-    TestHelpers.waitForRoundtrip(
+    IntegrationTestHelpers.waitForRoundtrip(ref);
+    IntegrationTestHelpers.waitForRoundtrip(
         ref); // Two are needed because writes are restored first, then onDisconnects
     assertEquals(1, counter[0]); // No onComplete should have triggered
   }
@@ -1037,7 +1037,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void testServerValuesEventualConsistencyBetweenLocalAndRemote() throws DatabaseException,
       InterruptedException {
-      List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+      List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
       DatabaseReference writer = refs.get(0);
       DatabaseReference reader = refs.get(1);
 
@@ -1087,7 +1087,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
       });
 
-      TestHelpers.waitFor(valMatchSemaphore);
+      IntegrationTestHelpers.waitFor(valMatchSemaphore);
 
       ctx.resume();
   }*/
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
index 3167b1f0e..823395988 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/TransactionTest.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database;
 
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.IntegrationTestHelpers.fromSingleQuotedString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -34,6 +34,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -51,13 +52,13 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   @Test
   public void newValueIsImmediatelyVisible()
       throws DatabaseException, TestFailure, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.child("foo")
         .runTransaction(
@@ -88,7 +89,7 @@ public void onComplete(
 
   @Test
   public void eventIsRaisedForNewValue() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     EventHelper helper = new EventHelper().addValueExpectation(ref).startListening();
 
@@ -116,7 +117,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   @Test
   public void nonAbortedTransactionSetsCommittedToTrueInCallback()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ref.runTransaction(
@@ -143,13 +144,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void abortedTransactionSetsCommittedToFalseInCallback()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     ref.runTransaction(
@@ -168,14 +169,14 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void setDataReconnectDoTransactionThatAbortsVerifyCorrectEvents()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
 
     new WriteFuture(refs.get(0), 42).timedGet();
 
@@ -243,7 +244,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   @Test
   public void useTransactionToCreateANodeMakeSureOneEventReceived()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicInteger events = new AtomicInteger(0);
     ref.addValueEventListener(
@@ -285,7 +286,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
             }
           }
         });
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals(1, events.get());
   }
 
@@ -293,7 +294,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   public void useTransactionToUpdateOneOfTwoExistingChildNodes()
       throws DatabaseException, TestFailure, ExecutionException, TimeoutException,
           InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -336,13 +337,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
         });
 
     assertTrue(helper.waitForEvents());
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void transactionIsOnlyCalledOnceWhenInitializingAnEmptyNode()
       throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final AtomicInteger called = new AtomicInteger(0);
     final Semaphore semaphore = new Semaphore(0);
@@ -370,14 +371,14 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals(1, called.get());
   }
 
   @Test
   public void secondTransactionGetsRunImmediatelyOnPreviousOutputAndOnlyRunsOnce()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref = refs.get(0);
 
     final AtomicBoolean firstRun = new AtomicBoolean(false);
@@ -425,10 +426,10 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
             second.release(1);
           }
         });
-    TestHelpers.waitFor(first);
-    TestHelpers.waitFor(second);
+    IntegrationTestHelpers.waitFor(first);
+    IntegrationTestHelpers.waitFor(second);
 
-    DataSnapshot snap = TestHelpers.getSnap(refs.get(1));
+    DataSnapshot snap = IntegrationTestHelpers.getSnap(refs.get(1));
     assertEquals(84L, snap.getValue());
   }
 
@@ -445,7 +446,7 @@ public void setCancelsPendingTransactionsAndRerunsAffectedTransactions()
     // - Transaction #3 should be re-run after #2 is reverted, and then be sent to the server and
     //   succeed.
 
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     final List<DataSnapshot> nodeSnaps = new ArrayList<DataSnapshot>();
@@ -484,7 +485,7 @@ public void onCancelled(DatabaseError error) {
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     final AtomicBoolean firstRun = new AtomicBoolean(false);
     ref.child("foo")
@@ -560,7 +561,7 @@ public void onComplete(
     // so we're left with the last value event
     ref.child("foo").setValue(0);
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     assertTrue(firstDone.get());
     assertTrue(secondDone.get());
@@ -572,7 +573,7 @@ public void onComplete(
   @Test
   public void transactionSetSetShouldWork() throws InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.runTransaction(
         new Transaction.Handler() {
           @Override
@@ -592,12 +593,12 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
     ref.setValue("foo");
     ref.setValue("bar");
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void priorityIsNotPreservedWhenSettingData() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
 
     final List<DataSnapshot> snaps = new ArrayList<DataSnapshot>();
@@ -631,7 +632,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     assertEquals(2, snaps.size());
     assertNull(snaps.get(1).getPriority());
@@ -642,7 +643,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   @Test
   public void resultingSnapshotIsPassedToOnComplete() throws InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -673,7 +674,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     // Do it again for the aborted case
     ref1.runTransaction(
@@ -692,7 +693,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     // Now on a fresh connection...
     ref2.runTransaction(
@@ -715,13 +716,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void transactionsAbortAfter25Retries() throws InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.setHijackHash(true);
     final AtomicInteger retries = new AtomicInteger(0);
     ref.runTransaction(
@@ -742,7 +743,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals(25, retries.get());
     ref.setHijackHash(false);
   }
@@ -751,7 +752,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   public void setShouldCancelAlreadySentTransactionsThatComeBackAsDatastale()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, 5).timedGet();
 
@@ -782,7 +783,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
               ref.getRepo().setHijackHash(false);
             }
           });
-      TestHelpers.waitFor(semaphore);
+      IntegrationTestHelpers.waitFor(semaphore);
     } finally {
       ref.getRepo().setHijackHash(false);
     }
@@ -791,7 +792,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
   @Test
   public void updateShouldNotCancelUnrelatedTransactions()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore fooTransaction = new Semaphore(0);
     final Semaphore barTransaction = new Semaphore(0);
@@ -861,14 +862,14 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(barTransaction);
+    IntegrationTestHelpers.waitFor(barTransaction);
   }
 
   @Test
   public void transactionsWorkOnWackyUnicode()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, "").timedGet();
 
@@ -892,12 +893,12 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void immediatelyAbortingATransactionWorks() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
 
     ref.runTransaction(
@@ -914,14 +915,14 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
             semaphore.release(1);
           }
         });
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void addToAnArrayWithATransaction()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     new WriteFuture(ref, Arrays.asList("cat", "horse")).timedGet();
     ref.runTransaction(
@@ -952,14 +953,14 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void mergedTransactionsHaveCorrectSnapshotInOnComplete()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final String nodeName = ref.getKey();
     new WriteFuture(ref, new MapBuilder().put("a", 0).build()).timedGet();
@@ -1012,7 +1013,7 @@ public void onComplete(
                 semaphore.release(1);
               }
             });
-    TestHelpers.waitFor(semaphore, 2);
+    IntegrationTestHelpers.waitFor(semaphore, 2);
   }
 
   // Note: skipping tests for reentrant API calls
@@ -1021,9 +1022,9 @@ public void onComplete(
   public void pendingTransactionsAreCancelledOnDisconnect()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
-    DatabaseConfig ctx = TestHelpers.getContext(0);
+    DatabaseConfig ctx = IntegrationTestHelpers.getContext(0);
 
     new WriteFuture(ref, "initial").timedGet();
 
@@ -1045,7 +1046,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
     RepoManager.interrupt(ctx);
     RepoManager.resume(ctx);
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
@@ -1053,7 +1054,7 @@ public void transactionWithLocalEvents1() throws InterruptedException {
     final Semaphore semaphore = new Semaphore(0);
     final Semaphore completeSemaphore = new Semaphore(0);
     final List<DataSnapshot> results = new ArrayList<DataSnapshot>();
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.addValueEventListener(
         new ValueEventListener() {
@@ -1071,7 +1072,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     ref.runTransaction(
         new Transaction.Handler() {
@@ -1085,7 +1086,7 @@ public void onCancelled(DatabaseError error) {
           @Override
           public void onComplete(DatabaseError error, boolean committed, DataSnapshot currentData) {
             try {
-              TestHelpers.waitFor(semaphore);
+              IntegrationTestHelpers.waitFor(semaphore);
               assertTrue(committed);
               completeSemaphore.release(1);
             } catch (InterruptedException e) {
@@ -1095,12 +1096,12 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
         },
         false);
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     assertEquals(1, results.size());
     assertNull(results.get(0).getValue());
     // Let the completion handler run
     semaphore.release(1);
-    TestHelpers.waitFor(completeSemaphore);
+    IntegrationTestHelpers.waitFor(completeSemaphore);
 
     assertEquals(2, results.size());
     assertEquals("hello!", results.get(1).getValue());
@@ -1109,7 +1110,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   @Test
   public void transactionWithoutLocalEvents2()
       throws InterruptedException, TestFailure, ExecutionException, TimeoutException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     final DatabaseReference ref1 = refs.get(0);
     DatabaseReference ref2 = refs.get(1);
 
@@ -1124,7 +1125,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
             done.release();
           }
         });
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     ref1.addValueEventListener(
         new ValueEventListener() {
@@ -1142,7 +1143,7 @@ public void onCancelled(DatabaseError error) {
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     final AtomicInteger retries = new AtomicInteger(0);
     ref1.runTransaction(
@@ -1173,7 +1174,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
       new WriteFuture(ref2, i).timedGet();
     }
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     assertTrue(retries.get() > 1);
     int size = events.size();
@@ -1187,10 +1188,10 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
   @Test
   public void transactionRunsOnNullOnlyOnceAfterReconnectCase1981()
       throws TestFailure, ExecutionException, TimeoutException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     new WriteFuture(ref, 42).timedGet();
 
-    DatabaseConfig ctx = TestHelpers.newTestConfig();
+    DatabaseConfig ctx = IntegrationTestHelpers.newTestConfig();
     ctx.setLogLevel(Logger.Level.DEBUG);
     DatabaseReference newRef = new DatabaseReference(ref.toString(), ctx);
 
@@ -1223,12 +1224,12 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void transactionRespectsPriority() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore done = new Semaphore(0);
     final List<DataSnapshot> values = new ArrayList<DataSnapshot>();
@@ -1261,7 +1262,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     ref.runTransaction(
         new Transaction.Handler() {
@@ -1281,7 +1282,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     assertEquals(5L, values.get(values.size() - 2).getValue());
     assertEquals(5.0, values.get(values.size() - 2).getPriority());
@@ -1291,7 +1292,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
   @Test
   public void transactionRevertsDataWhenAddADeeperListen() throws InterruptedException {
-    final List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    final List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
 
     final Semaphore gotTest = new Semaphore(0);
     refs.get(0)
@@ -1335,12 +1336,12 @@ public void onCancelled(DatabaseError error) {}
                         });
               }
             });
-    TestHelpers.waitFor(gotTest);
+    IntegrationTestHelpers.waitFor(gotTest);
   }
 
   @Test
   public void transactionWithNumericKeys() throws InterruptedException {
-    final DatabaseReference ref = TestHelpers.getRandomNode();
+    final DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
 
     Map<String, Object> initial =
@@ -1370,13 +1371,13 @@ public void onComplete(
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void canRemoveChildWithPriority0()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore done = new Semaphore(0);
 
     long value = 1378744239756L;
@@ -1399,12 +1400,12 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void userCodeExceptionsAbortTheTransaction() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore done = new Semaphore(0);
 
@@ -1423,7 +1424,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
 
     // Now try it with a Throwable, rather than exception
     ref.runTransaction(
@@ -1441,13 +1442,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   // https://app.asana.com/0/5673976843758/9259161251948
   @Test
   public void bubbleAppTransactionBug() throws InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore done = new Semaphore(0);
     ref.child("a")
@@ -1519,13 +1520,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void testLocalServerValuesEventuallyButNotImmediatelyMatchServerWithTxns()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     DatabaseReference writer = refs.get(0);
     DatabaseReference reader = refs.get(1);
 
@@ -1583,7 +1584,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
     Thread.sleep(5);
     writer.getDatabase().goOnline();
 
-    TestHelpers.waitFor(completionSemaphore, 3);
+    IntegrationTestHelpers.waitFor(completionSemaphore, 3);
 
     assertEquals(readSnaps.size(), 1);
     assertEquals(writeSnaps.size(), 2);
@@ -1601,7 +1602,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
 
   @Test
   public void testTransactionWithQueryListen() throws DatabaseException, InterruptedException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     final Semaphore semaphore = new Semaphore(0);
 
     ref.setValue(
@@ -1648,13 +1649,13 @@ public void onComplete(
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void testTransactionDoesNotPickUpCachedDataFromPreviousOnce()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     final DatabaseReference me = refs.get(0);
     final DatabaseReference other = refs.get(1);
 
@@ -1669,7 +1670,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     me.addListenerForSingleValueEvent(
         new ValueEventListener() {
@@ -1682,7 +1683,7 @@ public void onDataChange(DataSnapshot snapshot) {
           public void onCancelled(DatabaseError error) {}
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     other.setValue(
         null,
@@ -1693,7 +1694,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     me.runTransaction(
         new Transaction.Handler() {
@@ -1716,13 +1717,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void testTransactionDoesNotPickUpCachedDataFromPreviousTransaction()
       throws DatabaseException, InterruptedException {
-    List<DatabaseReference> refs = TestHelpers.getRandomNode(2);
+    List<DatabaseReference> refs = IntegrationTestHelpers.getRandomNode(2);
     final DatabaseReference me = refs.get(0);
     final DatabaseReference other = refs.get(1);
 
@@ -1744,7 +1745,7 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     other.setValue(
         null,
@@ -1755,7 +1756,7 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     me.runTransaction(
         new Transaction.Handler() {
@@ -1778,13 +1779,13 @@ public void onComplete(DatabaseError error, boolean committed, DataSnapshot curr
           }
         });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
   public void transactionOnQueriedLocationDoesntRunInitiallyOnNull()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     DatabaseReference child = ref.push();
     final Map<String, Object> initialData = new MapBuilder().put("a", 1L).put("b", 2L).build();
     new WriteFuture(child, initialData).timedGet();
@@ -1825,7 +1826,7 @@ public void onComplete(
                   public void onChildRemoved(DataSnapshot snapshot) {}
                 });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     // cleanup
     ref.removeEventListener(listener);
@@ -1834,7 +1835,7 @@ public void onChildRemoved(DataSnapshot snapshot) {}
   @Test
   public void transactionsRaiseCorrectChildChangedEventsOnQueries()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     Map<String, Object> value =
         new MapBuilder().put("foo", new MapBuilder().put("value", 1).build()).build();
@@ -1879,7 +1880,7 @@ public void onComplete(
             },
             false);
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
 
     Assert.assertEquals(2, snapshots.size());
     DataSnapshot addedSnapshot = snapshots.get(0);
@@ -1896,11 +1897,11 @@ public void onComplete(
   @Test
   public void transactionsUseLocalMerges()
       throws InterruptedException, ExecutionException, TimeoutException, TestFailure {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
     // Go offline to ensure the update doesn't complete before the transaction runs.
-    TestHelpers.goOffline(TestHelpers.getContext(0));
+    IntegrationTestHelpers.goOffline(IntegrationTestHelpers.getContext(0));
     ref.updateChildren(new MapBuilder().put("foo", "bar").build());
     ref.child("foo")
         .runTransaction(
@@ -1921,8 +1922,8 @@ public void onComplete(
               }
             });
 
-    TestHelpers.goOnline(TestHelpers.getContext(0));
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.goOnline(IntegrationTestHelpers.getContext(0));
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   // See https://app.asana.com/0/15566422264127/23303789496881
@@ -1930,7 +1931,7 @@ public void onComplete(
   public void outOfOrderRemoveWritesAreHandledCorrectly()
       throws DatabaseException, InterruptedException, ExecutionException, TestFailure,
           TimeoutException {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.setValue(new MapBuilder().put("foo", "bar").build());
     ref.runTransaction(
@@ -1968,12 +1969,12 @@ public void onComplete(DatabaseError error, DatabaseReference ref) {
           }
         });
 
-    TestHelpers.waitFor(done);
+    IntegrationTestHelpers.waitFor(done);
   }
 
   @Test
   public void returningNullReturnsNullPointerExceptionError() throws Throwable {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     final Semaphore semaphore = new Semaphore(0);
 
@@ -1993,7 +1994,7 @@ public void onComplete(
               }
             });
 
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 
   @Test
@@ -2001,7 +2002,7 @@ public void unsentTransactionsAreNotCancelledOnDisconnect() throws InterruptedEx
     // Hack: To trigger us to disconnect before restoring state, we inject a bad auth token.
     // In real-world usage the much more common case is that we get redirected to a different
     // server, but that's harder to manufacture from a test.
-    final DatabaseConfig cfg = TestHelpers.newTestConfig();
+    final DatabaseConfig cfg = IntegrationTestHelpers.newTestConfig();
     cfg.setAuthTokenProvider(
         new AuthTokenProvider() {
           private int count = 0;
@@ -2009,7 +2010,7 @@ public void unsentTransactionsAreNotCancelledOnDisconnect() throws InterruptedEx
           @Override
           public void getToken(boolean forceRefresh, final GetTokenCompletionListener listener) {
             // Return "bad-token" once to trigger a disconnect, and then a null token.
-            TestHelpers.getExecutorService(cfg)
+            IntegrationTestHelpers.getExecutorService(cfg)
                 .schedule(
                     new Runnable() {
                       @Override
@@ -2027,14 +2028,15 @@ public void run() {
           }
 
           @Override
-          public void addTokenChangeListener(TokenChangeListener listener) {}
+          public void addTokenChangeListener(
+              ExecutorService executorService, TokenChangeListener listener) {}
 
           @Override
           public void removeTokenChangeListener(TokenChangeListener listener) {}
         });
 
     // Queue a transaction offline.
-    DatabaseReference ref = TestHelpers.rootWithConfig(cfg);
+    DatabaseReference ref = IntegrationTestHelpers.rootWithConfig(cfg);
     ref.getDatabase().goOffline();
     final Semaphore semaphore = new Semaphore(0);
     ref.push()
@@ -2057,6 +2059,6 @@ public void onComplete(
             });
 
     ref.getDatabase().goOnline();
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
   }
 }
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/ValueExpectationHelper.java b/firebase-database/src/androidTest/java/com/google/firebase/database/ValueExpectationHelper.java
index f6685d376..57dfd64f6 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/ValueExpectationHelper.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/ValueExpectationHelper.java
@@ -62,7 +62,7 @@ public void onCancelled(DatabaseError error) {
   }
 
   public void waitForEvents() throws InterruptedException {
-    TestHelpers.waitFor(semaphore, count);
+    IntegrationTestHelpers.waitFor(semaphore, count);
     Iterator<QueryAndListener> iter = expectations.iterator();
     while (iter.hasNext()) {
       QueryAndListener pair = iter.next();
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
index af8ac401f..870fc902e 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ConnectionTest.java
@@ -17,9 +17,9 @@
 import static org.junit.Assert.assertFalse;
 
 import android.support.test.runner.AndroidJUnit4;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.IntegrationTestValues;
 import com.google.firebase.database.RetryRule;
-import com.google.firebase.database.TestHelpers;
 import com.google.firebase.database.core.DatabaseConfig;
 import java.util.Map;
 import java.util.concurrent.Semaphore;
@@ -65,9 +65,9 @@ public void onCacheHost(String s) {}
             IntegrationTestValues.getProjectId() + "." + IntegrationTestValues.getServer(),
             IntegrationTestValues.getProjectId(),
             /*secure=*/ true);
-    DatabaseConfig config = TestHelpers.newFrozenTestConfig();
+    DatabaseConfig config = IntegrationTestHelpers.newFrozenTestConfig();
     Connection conn = new Connection(config.getConnectionContext(), info, null, del, null);
     conn.open();
-    TestHelpers.waitFor(valSemaphore);
+    IntegrationTestHelpers.waitFor(valSemaphore);
   }
 }
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ListenAggregator.java b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ListenAggregator.java
index 480d8e961..f2974cd3d 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ListenAggregator.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/connection/ListenAggregator.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.connection;
 
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.core.CoreTestHelpers;
 import com.google.firebase.database.core.Path;
 import com.google.firebase.database.core.Repo;
@@ -40,7 +40,7 @@ public void run() {
             semaphore.release(1);
           }
         });
-    TestHelpers.waitFor(semaphore);
+    IntegrationTestHelpers.waitFor(semaphore);
     conns.get(0);
     List<List<String>> pathList = new ArrayList<>();
     List<Map<String, Object>> queryParamList = new ArrayList<>();
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
index f2a80841a..620889044 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/AndroidPlatformTest.java
@@ -19,7 +19,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 import com.google.firebase.database.FirebaseDatabase;
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import org.junit.Test;
 
 @org.junit.runner.RunWith(AndroidJUnit4.class)
@@ -27,7 +27,7 @@
 
   @Test
   public void userAgentHasCorrectParts() {
-    Context cfg = TestHelpers.getContext(0);
+    Context cfg = IntegrationTestHelpers.getContext(0);
     cfg.freeze();
     String userAgent = cfg.getUserAgent();
     String[] parts = userAgent.split("/");
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/SynchronousConnection.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/SynchronousConnection.java
index bb90cb610..260c65059 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/SynchronousConnection.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/SynchronousConnection.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.core;
 
-import static com.google.firebase.database.TestHelpers.newFrozenTestConfig;
+import static com.google.firebase.database.IntegrationTestHelpers.newFrozenTestConfig;
 import static com.google.firebase.database.core.utilities.Utilities.hardAssert;
 
 import com.google.firebase.database.DatabaseError;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/ZombieVerifier.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/ZombieVerifier.java
index 43386ed54..6310acada 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/ZombieVerifier.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/ZombieVerifier.java
@@ -18,7 +18,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.firebase.database.DatabaseReference;
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.core.view.View;
 import com.google.firebase.database.core.view.ViewAccess;
 import java.util.HashMap;
@@ -55,7 +55,7 @@ static void verifyRepoZombies(final Repo repo) throws InterruptedException {
     final Semaphore wait = new Semaphore(0);
 
     verifyRepoZombies(repo, wait);
-    TestHelpers.waitFor(wait);
+    IntegrationTestHelpers.waitFor(wait);
   }
 
   // To verify our state, we:
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
index 25bb1b25b..dd4baf477 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/KeepSyncedTest.java
@@ -19,10 +19,10 @@
 import android.support.test.runner.AndroidJUnit4;
 import com.google.firebase.database.DatabaseReference;
 import com.google.firebase.database.EventRecord;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.MapBuilder;
 import com.google.firebase.database.Query;
 import com.google.firebase.database.RetryRule;
-import com.google.firebase.database.TestHelpers;
 import com.google.firebase.database.future.ReadFuture;
 import com.google.firebase.database.future.WriteFuture;
 import java.util.List;
@@ -38,7 +38,7 @@
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    IntegrationTestHelpers.failOnFirstUncaughtException();
   }
 
   static long globalKeepSyncedTestCounter = 0;
@@ -109,7 +109,7 @@ public boolean isComplete(List<EventRecord> events) {
 
   @Test
   public void keepSynced() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.keepSynced(true);
     assertIsKeptSynced(ref);
 
@@ -120,7 +120,7 @@ public void keepSynced() throws Exception {
   // NOTE: This is not ideal behavior and should be fixed in a future release
   @Test
   public void keepSyncedAffectsQueries() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     ref.keepSynced(true);
     Query query = ref.limitToFirst(5);
     query.keepSynced(true);
@@ -135,7 +135,7 @@ public void keepSyncedAffectsQueries() throws Exception {
 
   @Test
   public void manyKeepSyncedCallsDontAccumulate() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.keepSynced(true);
     ref.keepSynced(true);
@@ -160,7 +160,7 @@ public void manyKeepSyncedCallsDontAccumulate() throws Exception {
 
   @Test
   public void removeSingleListenerDoesNotAffectKeepSynced() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.keepSynced(true);
     assertIsKeptSynced(ref);
@@ -183,7 +183,7 @@ public boolean isComplete(List<EventRecord> events) {
 
   @Test
   public void keepSyncedNoDoesNotAffectExistingListener() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
 
     ref.keepSynced(true);
     assertIsKeptSynced(ref);
@@ -208,7 +208,7 @@ public boolean isComplete(List<EventRecord> events) {
 
   @Test
   public void differentQueriesAreIndependent() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     Query query1 = ref.limitToFirst(1);
     Query query2 = ref.limitToFirst(2);
 
@@ -231,7 +231,7 @@ public void differentQueriesAreIndependent() throws Exception {
 
   @Test
   public void childIsKeptSynced() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode();
     DatabaseReference child = ref.child("random-child");
 
     ref.keepSynced(true);
@@ -243,7 +243,7 @@ public void childIsKeptSynced() throws Exception {
 
   @Test
   public void rootIsKeptSynced() throws Exception {
-    DatabaseReference ref = TestHelpers.getRandomNode().getRoot();
+    DatabaseReference ref = IntegrationTestHelpers.getRandomNode().getRoot();
 
     ref.keepSynced(true);
     assertIsKeptSynced(ref);
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
index 76f5da632..ac7467043 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PersistenceTest.java
@@ -14,18 +14,18 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.childKeySet;
-import static com.google.firebase.database.TestHelpers.defaultQueryAt;
-import static com.google.firebase.database.TestHelpers.failOnFirstUncaughtException;
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
-import static com.google.firebase.database.TestHelpers.goOffline;
-import static com.google.firebase.database.TestHelpers.goOnline;
-import static com.google.firebase.database.TestHelpers.newFrozenTestConfig;
-import static com.google.firebase.database.TestHelpers.path;
-import static com.google.firebase.database.TestHelpers.rootWithConfig;
-import static com.google.firebase.database.TestHelpers.setForcedPersistentCache;
-import static com.google.firebase.database.TestHelpers.waitFor;
-import static com.google.firebase.database.TestHelpers.waitForQueue;
+import static com.google.firebase.database.IntegrationTestHelpers.childKeySet;
+import static com.google.firebase.database.IntegrationTestHelpers.defaultQueryAt;
+import static com.google.firebase.database.IntegrationTestHelpers.failOnFirstUncaughtException;
+import static com.google.firebase.database.IntegrationTestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.IntegrationTestHelpers.goOffline;
+import static com.google.firebase.database.IntegrationTestHelpers.goOnline;
+import static com.google.firebase.database.IntegrationTestHelpers.newFrozenTestConfig;
+import static com.google.firebase.database.IntegrationTestHelpers.path;
+import static com.google.firebase.database.IntegrationTestHelpers.rootWithConfig;
+import static com.google.firebase.database.IntegrationTestHelpers.setForcedPersistentCache;
+import static com.google.firebase.database.IntegrationTestHelpers.waitFor;
+import static com.google.firebase.database.IntegrationTestHelpers.waitForQueue;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
index cf18a1180..555e5d885 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/PruningTest.java
@@ -14,10 +14,10 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.asSet;
-import static com.google.firebase.database.TestHelpers.leafNodeOfSize;
-import static com.google.firebase.database.TestHelpers.node;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.IntegrationTestHelpers.asSet;
+import static com.google.firebase.database.IntegrationTestHelpers.leafNodeOfSize;
+import static com.google.firebase.database.IntegrationTestHelpers.node;
+import static com.google.firebase.database.IntegrationTestHelpers.path;
 import static org.junit.Assert.assertEquals;
 
 import android.support.test.InstrumentationRegistry;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
index 336ba2dd3..db264ef38 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/core/persistence/SqlPersistenceStorageEngineTest.java
@@ -14,13 +14,13 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.asSet;
-import static com.google.firebase.database.TestHelpers.childKeySet;
-import static com.google.firebase.database.TestHelpers.compoundWrite;
-import static com.google.firebase.database.TestHelpers.defaultQueryAt;
-import static com.google.firebase.database.TestHelpers.leafNodeOfSize;
-import static com.google.firebase.database.TestHelpers.node;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.IntegrationTestHelpers.asSet;
+import static com.google.firebase.database.IntegrationTestHelpers.childKeySet;
+import static com.google.firebase.database.IntegrationTestHelpers.compoundWrite;
+import static com.google.firebase.database.IntegrationTestHelpers.defaultQueryAt;
+import static com.google.firebase.database.IntegrationTestHelpers.leafNodeOfSize;
+import static com.google.firebase.database.IntegrationTestHelpers.node;
+import static com.google.firebase.database.IntegrationTestHelpers.path;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
diff --git a/firebase-database/src/testUtil/java/com/google/firebase/database/future/ReadFuture.java b/firebase-database/src/androidTest/java/com/google/firebase/database/future/ReadFuture.java
similarity index 98%
rename from firebase-database/src/testUtil/java/com/google/firebase/database/future/ReadFuture.java
rename to firebase-database/src/androidTest/java/com/google/firebase/database/future/ReadFuture.java
index b462cddb4..376d15b9a 100644
--- a/firebase-database/src/testUtil/java/com/google/firebase/database/future/ReadFuture.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/future/ReadFuture.java
@@ -17,9 +17,9 @@
 import com.google.firebase.database.DataSnapshot;
 import com.google.firebase.database.DatabaseError;
 import com.google.firebase.database.EventRecord;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.Query;
 import com.google.firebase.database.TestFailure;
-import com.google.firebase.database.TestHelpers;
 import com.google.firebase.database.TestValues;
 import com.google.firebase.database.ValueEventListener;
 import com.google.firebase.database.core.view.Event;
@@ -200,7 +200,7 @@ public void timedWait() throws InterruptedException, TimeoutException, TestFailu
   public void timedWait(long timeout, TimeUnit timeoutUnit)
       throws InterruptedException, TimeoutException, TestFailure {
     if (!semaphore.tryAcquire(1, timeout, timeoutUnit)) {
-      TestHelpers.failOnFirstUncaughtException();
+      IntegrationTestHelpers.failOnFirstUncaughtException();
       throw new TimeoutException();
     }
     if (exception != null) {
diff --git a/firebase-database/src/testUtil/java/com/google/firebase/database/future/WriteFuture.java b/firebase-database/src/androidTest/java/com/google/firebase/database/future/WriteFuture.java
similarity index 96%
rename from firebase-database/src/testUtil/java/com/google/firebase/database/future/WriteFuture.java
rename to firebase-database/src/androidTest/java/com/google/firebase/database/future/WriteFuture.java
index c32f64967..e84c456fe 100644
--- a/firebase-database/src/testUtil/java/com/google/firebase/database/future/WriteFuture.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/future/WriteFuture.java
@@ -17,8 +17,8 @@
 import com.google.firebase.database.DatabaseError;
 import com.google.firebase.database.DatabaseException;
 import com.google.firebase.database.DatabaseReference;
+import com.google.firebase.database.IntegrationTestHelpers;
 import com.google.firebase.database.TestFailure;
-import com.google.firebase.database.TestHelpers;
 import com.google.firebase.database.TestValues;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
@@ -106,7 +106,7 @@ public DatabaseError get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     boolean success = semaphore.tryAcquire(1, timeout, unit);
     if (!success) {
-      TestHelpers.failOnFirstUncaughtException();
+      IntegrationTestHelpers.failOnFirstUncaughtException();
       throw new TimeoutException();
     }
     return error;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
index d33be2eb8..8a0b50e5e 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/snapshot/CompoundHashTest.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.database.snapshot;
 
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.IntegrationTestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.IntegrationTestHelpers.path;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/FirebaseClient.java b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/FirebaseClient.java
index 942749782..7f9a75770 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/FirebaseClient.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/FirebaseClient.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.tubesock;
 
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import java.net.URI;
 import java.util.concurrent.Semaphore;
 
@@ -55,7 +55,7 @@ public void onLogMessage(String msg) {
   public void start() throws WebSocketException, InterruptedException {
     semaphore = new Semaphore(0);
     URI uri = URI.create("wss://gsoltis.firebaseio-demo.com/.ws?v=5");
-    client = new WebSocket(TestHelpers.getContext(0).getConnectionContext(), uri);
+    client = new WebSocket(IntegrationTestHelpers.getContext(0).getConnectionContext(), uri);
     client.setEventHandler(new Handler());
     client.connect();
     semaphore.acquire(1);
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/TestClient.java b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/TestClient.java
index e54da9281..257f6e2f9 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/TestClient.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/TestClient.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.tubesock;
 
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import java.net.URI;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -66,7 +66,7 @@ public void startTest(String testNum) throws WebSocketException, InterruptedExce
     URI uri = URI.create("ws://localhost:9001/runCase?case=" + testNum + "&agent=tubesock");
     inTest = new AtomicBoolean(true);
     testLatch = new Semaphore(0);
-    client = new WebSocket(TestHelpers.getContext(0).getConnectionContext(), uri);
+    client = new WebSocket(IntegrationTestHelpers.getContext(0).getConnectionContext(), uri);
     client.setEventHandler(new Handler());
     client.connect();
     testLatch.acquire(1);
diff --git a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/UpdateClient.java b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/UpdateClient.java
index 7f93a7474..a15c74aa3 100644
--- a/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/UpdateClient.java
+++ b/firebase-database/src/androidTest/java/com/google/firebase/database/tubesock/UpdateClient.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.tubesock;
 
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.IntegrationTestHelpers;
 import java.net.URI;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -53,7 +53,8 @@ public void update() throws WebSocketException, InterruptedException {
     URI uri = URI.create("ws://localhost:9001/updateReports?agent=tubesock");
     completed = new AtomicBoolean(false);
     completionLatch = semaphore;
-    WebSocket client = new WebSocket(TestHelpers.getContext(0).getConnectionContext(), uri);
+    WebSocket client =
+        new WebSocket(IntegrationTestHelpers.getContext(0).getConnectionContext(), uri);
     client.setEventHandler(new Handler());
     client.connect();
     semaphore.acquire(1);
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
index bf50a5234..37a788435 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseError.java
@@ -15,6 +15,7 @@
 package com.google.firebase.database;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.RestrictTo;
 import com.google.firebase.annotations.PublicApi;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -120,6 +121,7 @@
    * @param status The status string
    * @return An error corresponding the to the status
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public static DatabaseError fromStatus(String status) {
     return fromStatus(status, null);
   }
@@ -132,6 +134,7 @@ public static DatabaseError fromStatus(String status) {
    * @param reason The reason for the error
    * @return An error corresponding the to the status
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public static DatabaseError fromStatus(String status, String reason) {
     return fromStatus(status, reason, null);
   }
@@ -143,6 +146,7 @@ public static DatabaseError fromStatus(String status, String reason) {
    * @param code The error code
    * @return An error corresponding the to the code
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public static DatabaseError fromCode(int code) {
     if (!errorReasons.containsKey(code)) {
       throw new IllegalArgumentException("Invalid Firebase Database error code: " + code);
@@ -160,6 +164,7 @@ public static DatabaseError fromCode(int code) {
    * @param details Additional details or null
    * @return An error corresponding the to the status
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public static DatabaseError fromStatus(String status, String reason, String details) {
     Integer code = errorCodes.get(status.toLowerCase());
     if (code == null) {
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
index dbb117062..1d9992ab6 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseException.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.database;
 
+import android.support.annotation.RestrictTo;
 import com.google.firebase.annotations.PublicApi;
 
 /**
@@ -29,6 +30,7 @@
    * @hide
    * @param message A human readable description of the error
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public DatabaseException(String message) {
     super(message);
   }
@@ -40,6 +42,7 @@ public DatabaseException(String message) {
    * @param message A human readable description of the error
    * @param cause The underlying cause for this error
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public DatabaseException(String message, Throwable cause) {
     super(message, cause);
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java b/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
index 530a66fb7..32a67e369 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/DatabaseRegistrar.java
@@ -15,18 +15,31 @@
 package com.google.firebase.database;
 
 import android.support.annotation.Keep;
+import android.support.annotation.RestrictTo;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
 import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
 import com.google.firebase.platforminfo.LibraryVersionComponent;
-import java.util.Collections;
+import java.util.Arrays;
 import java.util.List;
 
 /** @hide */
 @Keep
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public class DatabaseRegistrar implements ComponentRegistrar {
   @Override
   public List<Component<?>> getComponents() {
-    return Collections.singletonList(
+    return Arrays.asList(
+        Component.builder(FirebaseDatabaseComponent.class)
+            .add(Dependency.required(FirebaseApp.class))
+            .add(Dependency.optional(InternalAuthProvider.class))
+            .factory(
+                c ->
+                    new FirebaseDatabaseComponent(
+                        c.get(FirebaseApp.class), c.get(InternalAuthProvider.class)))
+            .build(),
         LibraryVersionComponent.create("fire-rtdb", BuildConfig.VERSION_NAME));
   }
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
index 3419af6cc..84b6a1f9c 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabase.java
@@ -14,6 +14,8 @@
 
 package com.google.firebase.database;
 
+import static com.google.android.gms.common.internal.Preconditions.checkNotNull;
+
 import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import com.google.firebase.FirebaseApp;
@@ -27,8 +29,6 @@
 import com.google.firebase.database.core.utilities.ParsedUrl;
 import com.google.firebase.database.core.utilities.Utilities;
 import com.google.firebase.database.core.utilities.Validation;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * The entry point for accessing a Firebase Database. You can get an instance by calling {@link
@@ -40,17 +40,6 @@
 
   private static final String SDK_VERSION = "3.0.0";
 
-  /**
-   * A static map of FirebaseApp and RepoInfo to FirebaseDatabase instance. To ensure thread-
-   * safety, it should only be accessed in getInstance(), which is a synchronized method.
-   *
-   * <p>TODO: This serves a duplicate purpose as RepoManager. We should clean up. TODO: We should
-   * maybe be conscious of leaks and make this a weak map or similar but we have a lot of work to do
-   * to allow FirebaseDatabase/Repo etc. to be GC'd.
-   */
-  private static final Map<String /* App name */, Map<RepoInfo, FirebaseDatabase>>
-      databaseInstances = new HashMap<>();
-
   private final FirebaseApp app;
   private final RepoInfo repoInfo;
   private final DatabaseConfig config;
@@ -116,13 +105,6 @@ public static synchronized FirebaseDatabase getInstance(
               + "FirebaseApp or from your getInstance() call.");
     }
 
-    Map<RepoInfo, FirebaseDatabase> instances = databaseInstances.get(app.getName());
-
-    if (instances == null) {
-      instances = new HashMap<>();
-      databaseInstances.put(app.getName(), instances);
-    }
-
     ParsedUrl parsedUrl = Utilities.parseUrl(url);
     if (!parsedUrl.path.isEmpty()) {
       throw new DatabaseException(
@@ -133,23 +115,10 @@ public static synchronized FirebaseDatabase getInstance(
               + parsedUrl.path.toString());
     }
 
-    FirebaseDatabase database = instances.get(parsedUrl.repoInfo);
-
-    if (database == null) {
-      DatabaseConfig config = new DatabaseConfig();
-      // If this is the default app, don't set the session persistence key so that we use our
-      // default ("default") instead of the FirebaseApp default ("[DEFAULT]") so that we
-      // preserve the default location used by the legacy Firebase SDK.
-      if (!app.isDefaultApp()) {
-        config.setSessionPersistenceKey(app.getName());
-      }
-      config.setFirebaseApp(app);
-
-      database = new FirebaseDatabase(app, parsedUrl.repoInfo, config);
-      instances.put(parsedUrl.repoInfo, database);
-    }
-
-    return database;
+    checkNotNull(app, "Provided FirebaseApp must not be null.");
+    FirebaseDatabaseComponent component = app.get(FirebaseDatabaseComponent.class);
+    checkNotNull(component, "Firebase Database component is not present.");
+    return component.get(parsedUrl.repoInfo);
   }
 
   /** This exists so Repo can create FirebaseDatabase objects to keep legacy tests working. */
@@ -160,7 +129,7 @@ static FirebaseDatabase createForTests(
     return db;
   }
 
-  private FirebaseDatabase(FirebaseApp app, RepoInfo repoInfo, DatabaseConfig config) {
+  FirebaseDatabase(FirebaseApp app, RepoInfo repoInfo, DatabaseConfig config) {
     this.app = app;
     this.repoInfo = repoInfo;
     this.config = config;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java
new file mode 100644
index 000000000..eee2681a2
--- /dev/null
+++ b/firebase-database/src/main/java/com/google/firebase/database/FirebaseDatabaseComponent.java
@@ -0,0 +1,71 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.database;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.auth.internal.InternalAuthProvider;
+import com.google.firebase.database.android.AndroidAuthTokenProvider;
+import com.google.firebase.database.core.AuthTokenProvider;
+import com.google.firebase.database.core.DatabaseConfig;
+import com.google.firebase.database.core.RepoInfo;
+import java.util.HashMap;
+import java.util.Map;
+
+class FirebaseDatabaseComponent {
+  /**
+   * A map of RepoInfo to FirebaseDatabase instance.
+   *
+   * <p>TODO: This serves a duplicate purpose as RepoManager. We should clean up. TODO: We should
+   * maybe be conscious of leaks and make this a weak map or similar but we have a lot of work to do
+   * to allow FirebaseDatabase/Repo etc. to be GC'd.
+   */
+  private final Map<RepoInfo, FirebaseDatabase> instances = new HashMap<>();
+
+  private final FirebaseApp app;
+  private final AuthTokenProvider authProvider;
+
+  FirebaseDatabaseComponent(@NonNull FirebaseApp app, @Nullable InternalAuthProvider authProvider) {
+    this.app = app;
+
+    if (authProvider != null) {
+      this.authProvider = AndroidAuthTokenProvider.forAuthenticatedAccess(authProvider);
+    } else {
+      this.authProvider = AndroidAuthTokenProvider.forUnauthenticatedAccess();
+    }
+  }
+
+  /** Provides instances of Firebase Database for the given RepoInfo */
+  @NonNull
+  synchronized FirebaseDatabase get(RepoInfo repo) {
+    FirebaseDatabase database = instances.get(repo);
+    if (database == null) {
+      DatabaseConfig config = new DatabaseConfig();
+      // If this is the default app, don't set the session persistence key so that we use our
+      // default ("default") instead of the FirebaseApp default ("[DEFAULT]") so that we
+      // preserve the default location used by the legacy Firebase SDK.
+      if (!app.isDefaultApp()) {
+        config.setSessionPersistenceKey(app.getName());
+      }
+      config.setFirebaseApp(app);
+      config.setAuthTokenProvider(authProvider);
+
+      database = new FirebaseDatabase(app, repo, config);
+      instances.put(repo, database);
+    }
+    return database;
+  }
+}
diff --git a/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java b/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
index f8ad05616..05ae4f9d2 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/InternalHelpers.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.database;
 
+import android.support.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.Path;
@@ -27,6 +28,7 @@
  *
  * @hide
  */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public class InternalHelpers {
 
   /** So Repo, etc. can create DatabaseReference instances. */
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Query.java b/firebase-database/src/main/java/com/google/firebase/database/Query.java
index e791193c8..d3f61fe04 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Query.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Query.java
@@ -18,6 +18,7 @@
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RestrictTo;
 import com.google.android.gms.common.internal.Objects;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.core.ChildEventRegistration;
@@ -701,6 +702,7 @@ public DatabaseReference getRef() {
    * @hide
    * @return The path to this location
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public Path getPath() {
     return path;
   }
@@ -711,6 +713,7 @@ public Path getPath() {
    * @hide
    * @return The repo
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public Repo getRepo() {
     return repo;
   }
@@ -721,6 +724,7 @@ public Repo getRepo() {
    * @hide
    * @return The constraints
    */
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public QuerySpec getSpec() {
     return new QuerySpec(path, params);
   }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/Transaction.java b/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
index e04e18893..13c984d97 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/Transaction.java
@@ -16,6 +16,7 @@
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RestrictTo;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.database.snapshot.Node;
 
@@ -67,6 +68,7 @@ public boolean isSuccess() {
      * @hide
      * @return The data
      */
+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
     public Node getNode() {
       return data;
     }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
index 445617e48..5d98d1d4b 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidAuthTokenProvider.java
@@ -15,89 +15,79 @@
 package com.google.firebase.database.android;
 
 import android.support.annotation.NonNull;
-import com.google.android.gms.tasks.OnFailureListener;
-import com.google.android.gms.tasks.OnSuccessListener;
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.FirebaseApiNotAvailableException;
-import com.google.firebase.FirebaseApp;
-import com.google.firebase.FirebaseApp.IdTokenListener;
 import com.google.firebase.auth.GetTokenResult;
+import com.google.firebase.auth.internal.IdTokenListener;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.database.core.AuthTokenProvider;
-import com.google.firebase.internal.InternalTokenResult;
 import com.google.firebase.internal.api.FirebaseNoSignedInUserException;
-import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ExecutorService;
 
-public class AndroidAuthTokenProvider implements AuthTokenProvider {
-  private final ScheduledExecutorService executorService;
-  private final FirebaseApp firebaseApp;
+public abstract class AndroidAuthTokenProvider implements AuthTokenProvider {
 
-  public AndroidAuthTokenProvider(
-      @NonNull FirebaseApp firebaseApp, @NonNull ScheduledExecutorService executorService) {
-    this.firebaseApp = firebaseApp;
-    this.executorService = executorService;
-  }
-
-  @Override
-  public void getToken(boolean forceRefresh, @NonNull final GetTokenCompletionListener listener) {
-    Task<GetTokenResult> getTokenResult = firebaseApp.getToken(forceRefresh);
+  public static AuthTokenProvider forAuthenticatedAccess(
+      @NonNull final InternalAuthProvider authProvider) {
+    return new AuthTokenProvider() {
+      @Override
+      public void getToken(
+          boolean forceRefresh, @NonNull final GetTokenCompletionListener listener) {
+        Task<GetTokenResult> getTokenResult = authProvider.getAccessToken(forceRefresh);
 
-    getTokenResult
-        .addOnSuccessListener(
-            executorService,
-            new OnSuccessListener<GetTokenResult>() {
-              @Override
-              public void onSuccess(GetTokenResult result) {
-                listener.onSuccess(result.getToken());
-              }
-            })
-        .addOnFailureListener(
-            executorService,
-            new OnFailureListener() {
-              @Override
-              public void onFailure(@NonNull Exception e) {
-                if (isUnauthenticatedUsage(e)) {
-                  listener.onSuccess(null);
-                } else {
-                  // TODO: Figure out how to plumb errors through in a sane
-                  // way.
-                  listener.onError(e.getMessage());
-                }
-              }
+        getTokenResult
+            .addOnSuccessListener(result -> listener.onSuccess(result.getToken()))
+            .addOnFailureListener(
+                e -> {
+                  if (isUnauthenticatedUsage(e)) {
+                    listener.onSuccess(null);
+                  } else {
+                    // TODO: Figure out how to plumb errors through in a sane way.
+                    listener.onError(e.getMessage());
+                  }
+                });
+      }
 
-              private boolean isUnauthenticatedUsage(Exception e) {
-                if (e instanceof FirebaseApiNotAvailableException
-                    || e instanceof FirebaseNoSignedInUserException) {
-                  return true;
-                }
+      @Override
+      public void addTokenChangeListener(
+          final ExecutorService executorService, final TokenChangeListener tokenListener) {
+        IdTokenListener idTokenListener =
+            tokenResult ->
+                executorService.execute(
+                    () -> tokenListener.onTokenChange(/* nullable */ tokenResult.getToken()));
+        authProvider.addIdTokenListener(idTokenListener);
+      }
 
-                return false;
-              }
-            });
+      @Override
+      public void removeTokenChangeListener(TokenChangeListener tokenListener) {
+        // TODO Implement removeIdTokenListener.
+      }
+    };
   }
 
-  @Override
-  public void addTokenChangeListener(final TokenChangeListener tokenListener) {
-    IdTokenListener idTokenListener = produceIdTokenListener(tokenListener);
-    firebaseApp.addIdTokenListener(idTokenListener);
-  }
+  public static AuthTokenProvider forUnauthenticatedAccess() {
+    return new AuthTokenProvider() {
+      @Override
+      public void getToken(boolean forceRefresh, GetTokenCompletionListener listener) {
+        listener.onSuccess(null);
+      }
 
-  private IdTokenListener produceIdTokenListener(final TokenChangeListener tokenListener) {
-    return new FirebaseApp.IdTokenListener() {
       @Override
-      public void onIdTokenChanged(@NonNull final InternalTokenResult tokenResult) {
-        executorService.execute(
-            new Runnable() {
-              @Override
-              public void run() {
-                tokenListener.onTokenChange(/* nullable */ tokenResult.getToken());
-              }
-            });
+      public void addTokenChangeListener(
+          ExecutorService executorService, TokenChangeListener listener) {
+        executorService.execute(() -> listener.onTokenChange(null));
       }
+
+      @Override
+      public void removeTokenChangeListener(TokenChangeListener listener) {}
     };
   }
 
-  @Override
-  public void removeTokenChangeListener(TokenChangeListener tokenListener) {
-    // TODO Implement removeIdTokenListener.
+  private static boolean isUnauthenticatedUsage(Exception e) {
+    if (e instanceof FirebaseApiNotAvailableException
+        || e instanceof FirebaseNoSignedInUserException) {
+      return true;
+    }
+
+    return false;
   }
 }
diff --git a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidPlatform.java b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidPlatform.java
index 263c43677..d4e900dd9 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/android/AndroidPlatform.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/android/AndroidPlatform.java
@@ -26,7 +26,6 @@
 import com.google.firebase.database.connection.HostInfo;
 import com.google.firebase.database.connection.PersistentConnection;
 import com.google.firebase.database.connection.PersistentConnectionImpl;
-import com.google.firebase.database.core.AuthTokenProvider;
 import com.google.firebase.database.core.EventTarget;
 import com.google.firebase.database.core.Platform;
 import com.google.firebase.database.core.RunLoop;
@@ -42,7 +41,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.ScheduledExecutorService;
 
 public class AndroidPlatform implements Platform {
 
@@ -107,11 +105,6 @@ public void run() {
     };
   }
 
-  @Override
-  public AuthTokenProvider newAuthTokenProvider(ScheduledExecutorService executorService) {
-    return new AndroidAuthTokenProvider(firebaseApp, executorService);
-  }
-
   @Override
   public PersistentConnection newPersistentConnection(
       com.google.firebase.database.core.Context context,
diff --git a/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
index 47d768712..7d630d98f 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/android/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.android;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.android;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
index d55a8e50b..c34cad31e 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/annotations/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.annotations;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.annotations;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
index 5d21febe7..77c4f5650 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/connection/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.connection;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.connection;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
index 037c70820..9ae55cc22 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/connection/util/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.connection.util;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.connection.util;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/AuthTokenProvider.java b/firebase-database/src/main/java/com/google/firebase/database/core/AuthTokenProvider.java
index 83dd12627..6057a8259 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/AuthTokenProvider.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/AuthTokenProvider.java
@@ -14,6 +14,8 @@
 
 package com.google.firebase.database.core;
 
+import java.util.concurrent.ExecutorService;
+
 /** */
 public interface AuthTokenProvider {
   /** */
@@ -61,7 +63,8 @@
    *
    * @param listener Listener to be added.
    */
-  public void addTokenChangeListener(TokenChangeListener listener);
+  public void addTokenChangeListener(
+      final ExecutorService executorService, TokenChangeListener listener);
 
   /**
    * Removes a previously-registered TokenChangeListener.
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/Context.java b/firebase-database/src/main/java/com/google/firebase/database/core/Context.java
index 8ccd2b86d..a313d3a20 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/Context.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/Context.java
@@ -14,6 +14,7 @@
 
 package com.google.firebase.database.core;
 
+import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.database.DatabaseException;
 import com.google.firebase.database.FirebaseDatabase;
@@ -139,7 +140,7 @@ public LogWrapper getLogger(String component, String prefix) {
   public ConnectionContext getConnectionContext() {
     return new ConnectionContext(
         this.getLogger(),
-        wrapAuthTokenProvider(this.getAuthTokenProvider()),
+        wrapAuthTokenProvider(this.getAuthTokenProvider(), this.getExecutorService()),
         this.getExecutorService(),
         this.isPersistenceEnabled(),
         FirebaseDatabase.getSdkVersion(),
@@ -242,9 +243,8 @@ private void ensureUserAgent() {
   }
 
   private void ensureAuthTokenProvider() {
-    if (authTokenProvider == null) {
-      authTokenProvider = getPlatform().newAuthTokenProvider(this.getExecutorService());
-    }
+    Preconditions.checkNotNull(
+        authTokenProvider, "You must register an authTokenProvider before initializing Context.");
   }
 
   private void ensureSessionIdentifier() {
@@ -266,25 +266,21 @@ private String buildUserAgent(String platformAgent) {
   }
 
   private static ConnectionAuthTokenProvider wrapAuthTokenProvider(
-      final AuthTokenProvider provider) {
-    return new ConnectionAuthTokenProvider() {
-      @Override
-      public void getToken(boolean forceRefresh, final GetTokenCallback callback) {
+      final AuthTokenProvider provider, ScheduledExecutorService executorService) {
+    return (forceRefresh, callback) ->
         provider.getToken(
             forceRefresh,
             new AuthTokenProvider.GetTokenCompletionListener() {
               @Override
               public void onSuccess(String token) {
-                callback.onSuccess(token);
+                executorService.execute(() -> callback.onSuccess(token));
               }
 
               @Override
               public void onError(String error) {
-                callback.onError(error);
+                executorService.execute(() -> callback.onError(error));
               }
             });
-      }
-    };
   }
 
   public File getSSLCacheDirectory() {
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/Platform.java b/firebase-database/src/main/java/com/google/firebase/database/core/Platform.java
index e64642e68..20cb19c86 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/Platform.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/Platform.java
@@ -21,7 +21,6 @@
 import com.google.firebase.database.logging.Logger;
 import java.io.File;
 import java.util.List;
-import java.util.concurrent.ScheduledExecutorService;
 
 public interface Platform {
   public Logger newLogger(Context ctx, Logger.Level level, List<String> components);
@@ -30,8 +29,6 @@
 
   public RunLoop newRunLoop(Context ctx);
 
-  public AuthTokenProvider newAuthTokenProvider(ScheduledExecutorService executorService);
-
   public PersistentConnection newPersistentConnection(
       Context context,
       ConnectionContext connectionContext,
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/Repo.java b/firebase-database/src/main/java/com/google/firebase/database/core/Repo.java
index 05666d51b..188a2ea77 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/Repo.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/Repo.java
@@ -33,6 +33,7 @@
 import com.google.firebase.database.core.persistence.NoopPersistenceManager;
 import com.google.firebase.database.core.persistence.PersistenceManager;
 import com.google.firebase.database.core.utilities.DefaultClock;
+import com.google.firebase.database.core.utilities.DefaultRunLoop;
 import com.google.firebase.database.core.utilities.OffsetClock;
 import com.google.firebase.database.core.utilities.Tree;
 import com.google.firebase.database.core.view.Event;
@@ -107,6 +108,7 @@ private void deferredInitialization() {
     this.ctx
         .getAuthTokenProvider()
         .addTokenChangeListener(
+            ((DefaultRunLoop) ctx.getRunLoop()).getExecutorService(),
             new AuthTokenProvider.TokenChangeListener() {
               // TODO: Remove this once AndroidAuthTokenProvider is updated to call the
               // other overload.
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
index 92b0a54f6..3e9a203a2 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/operation/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.operation;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.operation;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
index 679fcbe78..22de4242a 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
index a2e358837..267d1dfdc 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/persistence/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.persistence;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.persistence;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/CustomClassMapper.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/CustomClassMapper.java
index 9696d709d..442cab5ec 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/CustomClassMapper.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/CustomClassMapper.java
@@ -118,13 +118,13 @@ public static Object convertToPlainJavaTypes(Object object) {
           return ((Number) o).longValue();
         }
         return doubleValue;
-      } else if (o instanceof Short) {
-        throw new DatabaseException("Shorts are not supported, please use int or long");
-      } else if (o instanceof Byte) {
-        throw new DatabaseException("Bytes are not supported, please use int or long");
-      } else {
-        // Long, Integer
+      } else if (o instanceof Long || o instanceof Integer) {
         return o;
+      } else {
+        throw new DatabaseException(
+            String.format(
+                "Numbers of type %s are not supported, please use an int, long, float or double",
+                o.getClass().getSimpleName()));
       }
     } else if (o instanceof String) {
       return o;
@@ -278,14 +278,9 @@ public static Object convertToPlainJavaTypes(Object object) {
       return (T) convertLong(o);
     } else if (Float.class.isAssignableFrom(clazz) || float.class.isAssignableFrom(clazz)) {
       return (T) (Float) convertDouble(o).floatValue();
-    } else if (Short.class.isAssignableFrom(clazz) || short.class.isAssignableFrom(clazz)) {
-      throw new DatabaseException("Deserializing to shorts is not supported");
-    } else if (Byte.class.isAssignableFrom(clazz) || byte.class.isAssignableFrom(clazz)) {
-      throw new DatabaseException("Deserializing to bytes is not supported");
-    } else if (Character.class.isAssignableFrom(clazz) || char.class.isAssignableFrom(clazz)) {
-      throw new DatabaseException("Deserializing to char is not supported");
     } else {
-      throw new IllegalArgumentException("Unknown primitive type: " + clazz);
+      throw new DatabaseException(
+          String.format("Deserializing values to %s is not supported", clazz.getSimpleName()));
     }
   }
 
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
index 9da8a1615..444de4155 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/encoding/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.utilities.encoding;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.utilities.encoding;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
index 53be2dc4b..a41d53077 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.utilities;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.utilities;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
index cb3c71c7c..c8005c372 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/utilities/tuple/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.utilities.tuple;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.utilities.tuple;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java
new file mode 100644
index 000000000..62bf7dbaa
--- /dev/null
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/view/filter/package-info.java
@@ -0,0 +1,19 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.view.filter;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
index 354ed2b11..9249b4d04 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/core/view/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.core.view;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.core.view;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
index fbbacfb7f..af2f867b1 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/logging/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.logging;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.logging;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
index e1df61c52..4f4ee7a5a 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/snapshot/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.snapshot;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.snapshot;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
index c234bad4a..6bec8c0ef 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/tubesock/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.tubesock;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.tubesock;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java b/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
index b558f328a..477bb7085 100644
--- a/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
+++ b/firebase-database/src/main/java/com/google/firebase/database/util/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.database.util;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.database.util;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/DataSnapshotTest.java b/firebase-database/src/test/java/com/google/firebase/database/DataSnapshotTest.java
index 9d49c7c95..af8a78641 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/DataSnapshotTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/DataSnapshotTest.java
@@ -34,7 +34,7 @@
 
   @Before
   public void setUp() {
-    TestHelpers.ensureAppInitialized();
+    UnitTestHelpers.ensureAppInitialized();
   }
 
   private DataSnapshot snapFor(Object data, DatabaseReference ref) {
@@ -44,7 +44,7 @@ private DataSnapshot snapFor(Object data, DatabaseReference ref) {
 
   @Test
   public void basicIterationWorks() {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = UnitTestHelpers.getRandomNode();
     DataSnapshot snap1 = snapFor(null, ref);
 
     assertFalse(snap1.hasChildren());
@@ -71,7 +71,7 @@ public void basicIterationWorks() {
   @Test
   @SuppressWarnings("rawtypes")
   public void existsWorks() {
-    DatabaseReference ref = TestHelpers.getRandomNode();
+    DatabaseReference ref = UnitTestHelpers.getRandomNode();
     DataSnapshot snap;
 
     snap = snapFor(new HashMap(), ref);
diff --git a/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java b/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
index 235d321fd..324fb2500 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/MapperTest.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database;
 
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.UnitTestHelpers.fromSingleQuotedString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/MutableDataTest.java b/firebase-database/src/test/java/com/google/firebase/database/MutableDataTest.java
index 3dc75bced..1c7d322e7 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/MutableDataTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/MutableDataTest.java
@@ -187,23 +187,23 @@ public void validatesPaths() {
 
     List<String> goodKeys =
         Arrays.asList(
-            TestHelpers.repeatedString("k", maxPathLengthBytes - 1),
-            TestHelpers.repeatedString(fire, maxPathLengthBytes / 4 - 1),
-            TestHelpers.repeatedString(base, maxPathLengthBytes / 3 - 1),
-            TestHelpers.repeatedString("key/", maxPathDepth - 1) + "key");
+            UnitTestHelpers.repeatedString("k", maxPathLengthBytes - 1),
+            UnitTestHelpers.repeatedString(fire, maxPathLengthBytes / 4 - 1),
+            UnitTestHelpers.repeatedString(base, maxPathLengthBytes / 3 - 1),
+            UnitTestHelpers.repeatedString("key/", maxPathDepth - 1) + "key");
 
     List<String> badKeys =
         Arrays.asList(
-            TestHelpers.repeatedString("k", maxPathLengthBytes),
-            TestHelpers.repeatedString(fire, maxPathLengthBytes / 4),
-            TestHelpers.repeatedString(base, maxPathLengthBytes / 3),
-            TestHelpers.repeatedString("key/", maxPathDepth) + "key");
+            UnitTestHelpers.repeatedString("k", maxPathLengthBytes),
+            UnitTestHelpers.repeatedString(fire, maxPathLengthBytes / 4),
+            UnitTestHelpers.repeatedString(base, maxPathLengthBytes / 3),
+            UnitTestHelpers.repeatedString("key/", maxPathDepth) + "key");
 
     // Large but legal paths should all work for manipulating MutableData.
     for (String key : goodKeys) {
       Path path = new Path(key);
-      MutableData data = dataFor(TestHelpers.buildObjFromPath(path, "test_value"));
-      assertEquals("test_value", TestHelpers.applyPath(data.getValue(), path));
+      MutableData data = dataFor(UnitTestHelpers.buildObjFromPath(path, "test_value"));
+      assertEquals("test_value", UnitTestHelpers.applyPath(data.getValue(), path));
 
       data = dataForPath("scalar_value", key);
       assertEquals("scalar_value", data.getValue());
@@ -212,7 +212,7 @@ public void validatesPaths() {
     for (String key : badKeys) {
       Path path = new Path(key);
       try {
-        dataFor(TestHelpers.buildObjFromPath(path, "test_value"));
+        dataFor(UnitTestHelpers.buildObjFromPath(path, "test_value"));
         fail("Invalid path did not throw exception.");
       } catch (DatabaseException e) {
         // expected
diff --git a/firebase-database/src/test/java/com/google/firebase/database/TestHelpers.java b/firebase-database/src/test/java/com/google/firebase/database/UnitTestHelpers.java
similarity index 65%
rename from firebase-database/src/test/java/com/google/firebase/database/TestHelpers.java
rename to firebase-database/src/test/java/com/google/firebase/database/UnitTestHelpers.java
index c574b736a..b896bc54b 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/TestHelpers.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/UnitTestHelpers.java
@@ -14,7 +14,6 @@
 
 package com.google.firebase.database;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -22,20 +21,16 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
+import com.google.firebase.database.android.AndroidAuthTokenProvider;
 import com.google.firebase.database.core.Context;
 import com.google.firebase.database.core.CoreTestHelpers;
 import com.google.firebase.database.core.DatabaseConfig;
 import com.google.firebase.database.core.EventTarget;
 import com.google.firebase.database.core.Path;
-import com.google.firebase.database.core.persistence.PersistenceManager;
 import com.google.firebase.database.core.utilities.DefaultRunLoop;
 import com.google.firebase.database.core.view.QuerySpec;
-import com.google.firebase.database.future.WriteFuture;
 import com.google.firebase.database.snapshot.ChildKey;
 import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -44,7 +39,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -56,10 +50,9 @@
 import java.util.concurrent.atomic.AtomicReference;
 import org.robolectric.RuntimeEnvironment;
 
-public class TestHelpers {
+public class UnitTestHelpers {
 
   private static List<DatabaseConfig> contexts = new ArrayList<DatabaseConfig>();
-  private static String testSecret = null;
   private static boolean appInitialized = false;
 
   private static class TestEventTarget implements EventTarget {
@@ -140,26 +133,10 @@ public static DatabaseConfig getContext(int i) {
     return contexts.get(i);
   }
 
-  public static DatabaseReference rootWithNewContext() throws DatabaseException {
-    return rootWithConfig(newTestConfig());
-  }
-
-  public static DatabaseReference rootWithConfig(DatabaseConfig config) {
-    return new DatabaseReference(TestValues.TEST_NAMESPACE, config);
-  }
-
   public static DatabaseReference getRandomNode() throws DatabaseException {
     return getRandomNode(1).get(0);
   }
 
-  public static void goOffline(DatabaseConfig cfg) {
-    DatabaseReference.goOffline(cfg);
-  }
-
-  public static void goOnline(DatabaseConfig cfg) {
-    DatabaseReference.goOnline(cfg);
-  }
-
   public static List<DatabaseReference> getRandomNode(int count) throws DatabaseException {
     ensureContexts(count);
 
@@ -182,7 +159,7 @@ public static DatabaseConfig newFrozenTestConfig() {
   }
 
   public static DatabaseConfig newTestConfig() {
-    TestHelpers.ensureAppInitialized();
+    UnitTestHelpers.ensureAppInitialized();
 
     TestRunLoop runLoop = new TestRunLoop();
     DatabaseConfig config = new DatabaseConfig();
@@ -190,7 +167,7 @@ public static DatabaseConfig newTestConfig() {
     config.setEventTarget(new TestEventTarget());
     config.setRunLoop(runLoop);
     config.setFirebaseApp(FirebaseApp.getInstance());
-    config.setAuthTokenProvider(new TestTokenProvider(runLoop.getExecutorService()));
+    config.setAuthTokenProvider(AndroidAuthTokenProvider.forUnauthenticatedAccess());
     return config;
   }
 
@@ -199,17 +176,6 @@ public static ScheduledExecutorService getExecutorService(DatabaseConfig config)
     return runLoop.getExecutorService();
   }
 
-  public static void setForcedPersistentCache(Context ctx, PersistenceManager manager) {
-    try {
-      Method method =
-          Context.class.getDeclaredMethod("forcePersistenceManager", PersistenceManager.class);
-      method.setAccessible(true);
-      method.invoke(ctx, manager);
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   public static void setLogger(
       DatabaseConfig ctx, com.google.firebase.database.logging.Logger logger) {
     ctx.setLogger(logger);
@@ -221,21 +187,6 @@ private static void ensureContexts(int count) {
     }
   }
 
-  public static String getTestSecret() {
-    if (testSecret == null) {
-      try {
-        InputStream response =
-            new URL(TestValues.TEST_NAMESPACE + "/.nsadmin/.json?key=1234").openStream();
-        TypeReference<Map<String, Object>> t = new TypeReference<Map<String, Object>>() {};
-        Map<String, Object> data = new ObjectMapper().readValue(response, t);
-        testSecret = (String) ((List) data.get("secrets")).get(0);
-      } catch (Throwable e) {
-        fail("Could not get test secret.");
-      }
-    }
-    return testSecret;
-  }
-
   public static void waitFor(Semaphore semaphore) throws InterruptedException {
     waitFor(semaphore, 1);
   }
@@ -251,62 +202,6 @@ public static void waitFor(Semaphore semaphore, int count, long timeout, TimeUni
     assertTrue("Operation timed out", success);
   }
 
-  public static DataSnapshot getSnap(Query ref) throws InterruptedException {
-
-    final Semaphore semaphore = new Semaphore(0);
-
-    // Hack to get around final reference issue
-    final List<DataSnapshot> snapshotList = new ArrayList<DataSnapshot>(1);
-
-    ref.addListenerForSingleValueEvent(
-        new ValueEventListener() {
-          @Override
-          public void onDataChange(DataSnapshot snapshot) {
-            snapshotList.add(snapshot);
-            semaphore.release(1);
-          }
-
-          @Override
-          public void onCancelled(DatabaseError error) {
-            semaphore.release(1);
-          }
-        });
-
-    semaphore.tryAcquire(1, TestValues.TEST_TIMEOUT, TimeUnit.MILLISECONDS);
-    return snapshotList.get(0);
-  }
-
-  public static void assertSuccessfulAuth(
-      DatabaseReference ref, TestTokenProvider provider, String credential) {
-    DatabaseReference authRef = ref.getRoot().child(".info/authenticated");
-    final Semaphore semaphore = new Semaphore(0);
-    final List<Boolean> authStates = new ArrayList<>();
-    ValueEventListener listener =
-        authRef.addValueEventListener(
-            new ValueEventListener() {
-              @Override
-              public void onDataChange(DataSnapshot snapshot) {
-                authStates.add(snapshot.getValue(Boolean.class));
-                semaphore.release();
-              }
-
-              @Override
-              public void onCancelled(DatabaseError error) {
-                throw new RuntimeException("Should not happen");
-              }
-            });
-
-    provider.setToken(credential);
-
-    try {
-      TestHelpers.waitFor(semaphore, 2);
-      assertEquals(Arrays.asList(false, true), authStates);
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
-    authRef.removeEventListener(listener);
-  }
-
   public static Map<String, Object> fromJsonString(String json) {
     try {
       ObjectMapper mapper = new ObjectMapper();
@@ -320,51 +215,6 @@ public void onCancelled(DatabaseError error) {
     return fromJsonString(json.replace("'", "\""));
   }
 
-  public static void waitForRoundtrip(DatabaseReference reader) {
-    try {
-      new WriteFuture(reader.getRoot().child(UUID.randomUUID().toString()), null, null).timedGet();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static void waitForQueue(DatabaseReference ref) {
-    try {
-      final Semaphore semaphore = new Semaphore(0);
-      ref.getRepo()
-          .scheduleNow(
-              new Runnable() {
-                @Override
-                public void run() {
-                  semaphore.release();
-                }
-              });
-      semaphore.acquire();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static void waitForEvents(DatabaseReference ref) {
-    try {
-      // Make sure queue is done and all events are queued
-      TestHelpers.waitForQueue(ref);
-      // Next, all events were queued, make sure all events are done raised
-      final Semaphore semaphore = new Semaphore(0);
-      ref.getRepo()
-          .postEvent(
-              new Runnable() {
-                @Override
-                public void run() {
-                  semaphore.release();
-                }
-              });
-      semaphore.acquire();
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   public static String repeatedString(String s, int n) {
     String result = "";
 
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/RangeMergeTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/RangeMergeTest.java
index 3a729856b..34aa838a6 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/RangeMergeTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/RangeMergeTest.java
@@ -14,8 +14,8 @@
 
 package com.google.firebase.database.core;
 
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.UnitTestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.UnitTestHelpers.path;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static org.junit.Assert.assertEquals;
 
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/SyncPointTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/SyncPointTest.java
index 7faf89402..354f3d6fd 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/SyncPointTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/SyncPointTest.java
@@ -20,7 +20,7 @@
 import com.google.firebase.database.DatabaseReference;
 import com.google.firebase.database.InternalHelpers;
 import com.google.firebase.database.Query;
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.UnitTestHelpers;
 import com.google.firebase.database.annotations.NotNull;
 import com.google.firebase.database.connection.ListenHashProvider;
 import com.google.firebase.database.core.persistence.NoopPersistenceManager;
@@ -412,8 +412,8 @@ private static Tag parseTag(Object tag) {
 
   @SuppressWarnings("unchecked")
   private static void runTest(Map<String, Object> testSpec, String basePath) {
-    DatabaseConfig config = TestHelpers.newTestConfig();
-    TestHelpers.setLogger(config, new DefaultLogger(Logger.Level.DEBUG, null));
+    DatabaseConfig config = UnitTestHelpers.newTestConfig();
+    UnitTestHelpers.setLogger(config, new DefaultLogger(Logger.Level.DEBUG, null));
     LogWrapper logger = config.getLogger("SyncPointTest");
 
     logger.info("Running \"" + testSpec.get("name") + '"');
@@ -519,7 +519,7 @@ private static void runTest(Map<String, Object> testSpec, String basePath) {
 
   @After
   public void tearDown() {
-    TestHelpers.failOnFirstUncaughtException();
+    UnitTestHelpers.failOnFirstUncaughtException();
   }
 
   @SuppressWarnings("unchecked")
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/DefaultPersistenceManagerTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/DefaultPersistenceManagerTest.java
index f0946ca07..04419b626 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/DefaultPersistenceManagerTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/DefaultPersistenceManagerTest.java
@@ -14,11 +14,11 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.childKeySet;
-import static com.google.firebase.database.TestHelpers.defaultQueryAt;
-import static com.google.firebase.database.TestHelpers.fromSingleQuotedString;
-import static com.google.firebase.database.TestHelpers.newFrozenTestConfig;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.UnitTestHelpers.childKeySet;
+import static com.google.firebase.database.UnitTestHelpers.defaultQueryAt;
+import static com.google.firebase.database.UnitTestHelpers.fromSingleQuotedString;
+import static com.google.firebase.database.UnitTestHelpers.newFrozenTestConfig;
+import static com.google.firebase.database.UnitTestHelpers.path;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/PruneForestTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/PruneForestTest.java
index aa7c4a180..702f48fa7 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/PruneForestTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/PruneForestTest.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.ck;
+import static com.google.firebase.database.UnitTestHelpers.ck;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/RandomPersistenceTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/RandomPersistenceTest.java
index 195e3a810..b2cb61243 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/RandomPersistenceTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/RandomPersistenceTest.java
@@ -18,7 +18,7 @@
 import static junit.framework.Assert.assertTrue;
 
 import com.google.firebase.database.DatabaseError;
-import com.google.firebase.database.TestHelpers;
+import com.google.firebase.database.UnitTestHelpers;
 import com.google.firebase.database.annotations.NotNull;
 import com.google.firebase.database.connection.ListenHashProvider;
 import com.google.firebase.database.core.CompoundWrite;
@@ -213,7 +213,7 @@ public void randomOperations() {
       currentWriteId = 0;
       currentUnackedWriteId = 0;
 
-      DatabaseConfig cfg = TestHelpers.newFrozenTestConfig();
+      DatabaseConfig cfg = UnitTestHelpers.newFrozenTestConfig();
       MockPersistenceStorageEngine storageEngine = new MockPersistenceStorageEngine();
       DefaultPersistenceManager manager =
           new DefaultPersistenceManager(cfg, storageEngine, CachePolicy.NONE);
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/TrackedQueryManagerTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/TrackedQueryManagerTest.java
index 6442371d4..9b3ba4893 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/persistence/TrackedQueryManagerTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/persistence/TrackedQueryManagerTest.java
@@ -14,10 +14,10 @@
 
 package com.google.firebase.database.core.persistence;
 
-import static com.google.firebase.database.TestHelpers.asSet;
-import static com.google.firebase.database.TestHelpers.ck;
-import static com.google.firebase.database.TestHelpers.defaultQueryAt;
-import static com.google.firebase.database.TestHelpers.path;
+import static com.google.firebase.database.UnitTestHelpers.asSet;
+import static com.google.firebase.database.UnitTestHelpers.ck;
+import static com.google.firebase.database.UnitTestHelpers.defaultQueryAt;
+import static com.google.firebase.database.UnitTestHelpers.path;
 import static com.google.firebase.database.snapshot.NodeUtilities.NodeFromJSON;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
diff --git a/firebase-database/src/test/java/com/google/firebase/database/core/view/QueryParamsTest.java b/firebase-database/src/test/java/com/google/firebase/database/core/view/QueryParamsTest.java
index f68dd75d3..5f926e058 100644
--- a/firebase-database/src/test/java/com/google/firebase/database/core/view/QueryParamsTest.java
+++ b/firebase-database/src/test/java/com/google/firebase/database/core/view/QueryParamsTest.java
@@ -14,7 +14,7 @@
 
 package com.google.firebase.database.core.view;
 
-import static com.google.firebase.database.TestHelpers.ck;
+import static com.google.firebase.database.UnitTestHelpers.ck;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
diff --git a/firebase-database/src/testUtil/java/com/google/firebase/database/TestTokenProvider.java b/firebase-database/src/testUtil/java/com/google/firebase/database/TestTokenProvider.java
deleted file mode 100644
index 5dd23cbe0..000000000
--- a/firebase-database/src/testUtil/java/com/google/firebase/database/TestTokenProvider.java
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright 2018 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.google.firebase.database;
-
-import com.google.firebase.database.core.AuthTokenProvider;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.Future;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-
-class TestTokenProvider implements AuthTokenProvider {
-
-  private String token;
-  private String nextToken;
-  private Set<AuthTokenProvider.TokenChangeListener> listeners = new HashSet<>();
-  private ScheduledExecutorService executorService;
-
-  public TestTokenProvider(ScheduledExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public void setToken(String token) {
-    this.token = token;
-    for (final TokenChangeListener listener : this.listeners) {
-      this.executorService.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              listener.onTokenChange();
-            }
-          });
-    }
-  }
-
-  public void setNextToken(String token) {
-    this.nextToken = token;
-  }
-
-  @Override
-  public void getToken(boolean forceRefresh, final GetTokenCompletionListener listener) {
-    if (forceRefresh && this.nextToken != null) {
-      this.token = nextToken;
-    }
-    final String currentToken = this.token;
-    // Make sure to delay the callback by a short delay to test there are no race
-    // conditions through reordering of other operations after getToken call.
-    @SuppressWarnings({"unused", "nullness"}) // go/futurereturn-lsc
-    Future<?> possiblyIgnoredError =
-        this.executorService.schedule(
-            new Runnable() {
-              @Override
-              public void run() {
-                listener.onSuccess(currentToken);
-              }
-            },
-            10,
-            TimeUnit.MILLISECONDS);
-  }
-
-  @Override
-  public void addTokenChangeListener(TokenChangeListener listener) {
-    this.listeners.add(listener);
-  }
-
-  @Override
-  public void removeTokenChangeListener(TokenChangeListener listener) {
-    this.listeners.remove(listener);
-  }
-}
diff --git a/firebase-firestore-ktx/firebase-firestore-ktx.gradle b/firebase-firestore-ktx/firebase-firestore-ktx.gradle
new file mode 100644
index 000000000..b36331176
--- /dev/null
+++ b/firebase-firestore-ktx/firebase-firestore-ktx.gradle
@@ -0,0 +1,53 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+android {
+    compileSdkVersion project.targetSdkVersion
+    defaultConfig {
+        minSdkVersion project.minSdkVersion
+        multiDexEnabled true
+        targetSdkVersion project.targetSdkVersion
+        versionName version
+    }
+    sourceSets {
+        main.java.srcDirs += 'src/main/kotlin'
+        test.java {
+            srcDir 'src/test/kotlin'
+            srcDir '../firebase-firestore/src/testUtil/java'
+            srcDir '../firebase-firestore/src/roboUtil/java'
+        }
+    }
+    testOptions.unitTests.includeAndroidResources = true
+}
+
+dependencies {
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
+
+    implementation project(':firebase-common')
+    implementation project(':firebase-common-ktx')
+    implementation project(':firebase-firestore')
+    implementation 'com.android.support:support-annotations:28.0.0'
+
+    testImplementation project(':firebase-database-collection')
+    testImplementation 'org.mockito:mockito-core:2.21.0'
+    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.6'
+    testImplementation 'com.google.android.gms:play-services-tasks:16.0.1'
+    testImplementation 'com.google.protobuf:protobuf-lite:3.0.1'
+    testImplementation "org.robolectric:robolectric:$robolectricVersion"
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+}
diff --git a/firebase-firestore-ktx/gradle.properties b/firebase-firestore-ktx/gradle.properties
new file mode 100644
index 000000000..ddfcce23e
--- /dev/null
+++ b/firebase-firestore-ktx/gradle.properties
@@ -0,0 +1,3 @@
+version=18.2.0
+android.enableUnitTestBinaryResources=true
+
diff --git a/firebase-firestore-ktx/src/main/AndroidManifest.xml b/firebase-firestore-ktx/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..3dd0e5a4f
--- /dev/null
+++ b/firebase-firestore-ktx/src/main/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.google.firebase.firestore.ktx">
+    <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+    <!--<uses-sdk android:minSdkVersion="14"/>-->
+    <application>
+        <service android:name="com.google.firebase.components.ComponentDiscoveryService">
+            <meta-data android:name="com.google.firebase.components:com.google.firebase.firestore.ktx.FirebaseFirestoreKtxRegistrar"
+                android:value="com.google.firebase.components.ComponentRegistrar" />
+        </service>
+    </application>
+</manifest>
diff --git a/firebase-firestore-ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt b/firebase-firestore-ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt
new file mode 100644
index 000000000..a552954b1
--- /dev/null
+++ b/firebase-firestore-ktx/src/main/kotlin/com/google/firebase/firestore/ktx/Firestore.kt
@@ -0,0 +1,157 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.ktx
+
+import android.support.annotation.Keep
+import com.google.firebase.FirebaseApp
+import com.google.firebase.components.Component
+import com.google.firebase.components.ComponentRegistrar
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FieldPath
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.QueryDocumentSnapshot
+import com.google.firebase.firestore.QuerySnapshot
+
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.platforminfo.LibraryVersionComponent
+
+/** Returns the [FirebaseFirestore] instance of the default [FirebaseApp]. */
+val Firebase.firestore: FirebaseFirestore
+    get() = FirebaseFirestore.getInstance()
+
+/** Returns the [FirebaseFirestore] instance of a given [FirebaseApp]. */
+fun Firebase.firestore(app: FirebaseApp): FirebaseFirestore = FirebaseFirestore.getInstance(app)
+
+/**
+ * Returns the contents of the document converted to a POJO or null if the document doesn't exist.
+ *
+ * @param T The type of the object to create.
+ * @return The contents of the document in an object of type T or null if the document doesn't
+ *     exist.
+ */
+inline fun <reified T> DocumentSnapshot.toObject(): T? = toObject(T::class.java)
+
+/**
+ * Returns the contents of the document converted to a POJO or null if the document doesn't exist.
+ *
+ * @param T The type of the object to create.
+ * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
+ *     been set to their final value.
+ * @return The contents of the document in an object of type T or null if the document doesn't
+ *     exist.
+ */
+inline fun <reified T> DocumentSnapshot.toObject(
+    serverTimestampBehavior: DocumentSnapshot.ServerTimestampBehavior
+): T? =
+        toObject(T::class.java, serverTimestampBehavior)
+
+/**
+ * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
+ * exist.
+ *
+ * @param field The path to the field.
+ * @param T The type to convert the field value to.
+ * @return The value at the given field or null.
+ */
+inline fun <reified T> DocumentSnapshot.getField(field: String): T? = get(field, T::class.java)
+
+/**
+ * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
+ * exist.
+ *
+ * @param field The path to the field.
+ * @param T The type to convert the field value to.
+ * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
+ *     been set to their final value.
+ * @return The value at the given field or null.
+ */
+inline fun <reified T> DocumentSnapshot.getField(
+    field: String,
+    serverTimestampBehavior: DocumentSnapshot.ServerTimestampBehavior
+): T? =
+        get(field, T::class.java, serverTimestampBehavior)
+
+/**
+ * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
+ * exist.
+ *
+ * @param fieldPath The path to the field.
+ * @param T The type to convert the field value to.
+ * @return The value at the given field or null.
+ */
+inline fun <reified T> DocumentSnapshot.getField(fieldPath: FieldPath): T? = get(fieldPath, T::class.java)
+
+/**
+ * Returns the value at the field, converted to a POJO, or null if the field or document doesn't
+ * exist.
+ *
+ * @param fieldPath The path to the field.
+ * @param T The type to convert the field value to.
+ * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
+ *     been set to their final value.
+ * @return The value at the given field or null.
+ */
+inline fun <reified T> DocumentSnapshot.getField(
+    fieldPath: FieldPath,
+    serverTimestampBehavior: DocumentSnapshot.ServerTimestampBehavior
+): T? =
+        get(fieldPath, T::class.java, serverTimestampBehavior)
+
+/**
+ * Returns the contents of the document converted to a POJO.
+ *
+ * @param T The type of the object to create.
+ * @return The contents of the document in an object of type T.
+ */
+inline fun <reified T : Any> QueryDocumentSnapshot.toObject(): T = toObject(T::class.java)
+
+/**
+ * Returns the contents of the document converted to a POJO.
+ *
+ * @param T The type of the object to create.
+ * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
+ *     been set to their final value.
+ * @return The contents of the document in an object of type T.
+ */
+inline fun <reified T : Any> QueryDocumentSnapshot.toObject(serverTimestampBehavior: DocumentSnapshot.ServerTimestampBehavior): T =
+        toObject(T::class.java, serverTimestampBehavior)
+
+/**
+ * Returns the contents of the documents in the QuerySnapshot, converted to the provided class, as
+ * a list.
+ *
+ * @param T The POJO type used to convert the documents in the list.
+ */
+inline fun <reified T : Any> QuerySnapshot.toObjects(): List<T> = toObjects(T::class.java)
+
+/**
+ * Returns the contents of the documents in the QuerySnapshot, converted to the provided class, as
+ * a list.
+ *
+ * @param T The POJO type used to convert the documents in the list.
+ * @param serverTimestampBehavior Configures the behavior for server timestamps that have not yet
+ *     been set to their final value.
+ */
+inline fun <reified T : Any> QuerySnapshot.toObjects(serverTimestampBehavior: DocumentSnapshot.ServerTimestampBehavior): List<T> =
+        toObjects(T::class.java, serverTimestampBehavior)
+
+internal const val LIBRARY_NAME: String = "fire-fst-ktx"
+
+/** @suppress */
+@Keep
+class FirebaseFirestoreKtxRegistrar : ComponentRegistrar {
+    override fun getComponents(): List<Component<*>> =
+            listOf(LibraryVersionComponent.create(LIBRARY_NAME, BuildConfig.VERSION_NAME))
+}
diff --git a/firebase-firestore-ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt b/firebase-firestore-ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt
new file mode 100644
index 000000000..ffb44440c
--- /dev/null
+++ b/firebase-firestore-ktx/src/test/kotlin/com/google/firebase/firestore/ktx/FirestoreTests.kt
@@ -0,0 +1,164 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.ktx
+
+import com.google.common.truth.Truth.assertThat
+import com.google.firebase.FirebaseApp
+import com.google.firebase.FirebaseOptions
+import com.google.firebase.firestore.DocumentSnapshot
+import com.google.firebase.firestore.FieldPath
+import com.google.firebase.firestore.FirebaseFirestore
+import com.google.firebase.firestore.FirebaseFirestoreSettings
+import com.google.firebase.firestore.TestUtil
+import com.google.firebase.firestore.model.value.IntegerValue
+import com.google.firebase.firestore.model.value.ObjectValue
+import com.google.firebase.ktx.Firebase
+import com.google.firebase.ktx.app
+import com.google.firebase.ktx.initialize
+import com.google.firebase.platforminfo.UserAgentPublisher
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito
+import org.robolectric.RobolectricTestRunner
+import org.robolectric.RuntimeEnvironment
+
+const val APP_ID = "APP_ID"
+const val API_KEY = "API_KEY"
+
+const val EXISTING_APP = "existing"
+
+abstract class BaseTestCase {
+    @Before
+    fun setUp() {
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build()
+        )
+
+        Firebase.initialize(
+                RuntimeEnvironment.application,
+                FirebaseOptions.Builder()
+                        .setApplicationId(APP_ID)
+                        .setApiKey(API_KEY)
+                        .setProjectId("123")
+                        .build(),
+                EXISTING_APP
+        )
+    }
+
+    @After
+    fun cleanUp() {
+        FirebaseApp.clearInstancesForTest()
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class FirestoreTests : BaseTestCase() {
+
+    @Test
+    fun `firestore should delegate to FirebaseFirestore#getInstance()`() {
+        assertThat(Firebase.firestore).isSameAs(FirebaseFirestore.getInstance())
+    }
+
+    @Test
+    fun `FirebaseApp#firestore should delegate to FirebaseFirestore#getInstance(FirebaseApp)`() {
+        val app = Firebase.app(EXISTING_APP)
+        assertThat(Firebase.firestore(app)).isSameAs(FirebaseFirestore.getInstance(app))
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class LibraryVersionTest : BaseTestCase() {
+    @Test
+    fun `library version should be registered with runtime`() {
+        val publisher = Firebase.app.get(UserAgentPublisher::class.java)
+        assertThat(publisher.userAgent).contains(LIBRARY_NAME)
+    }
+}
+
+data class Room(var a: Int = 0, var b: Int = 0)
+
+@RunWith(RobolectricTestRunner::class)
+class DocumentSnapshotTests {
+    @Before
+    fun setup() {
+        Mockito.`when`(TestUtil.firestore().firestoreSettings).thenReturn(FirebaseFirestoreSettings.Builder().build())
+    }
+
+    @After
+    fun cleanup() {
+        Mockito.reset(TestUtil.firestore())
+    }
+
+    @Test
+    fun `reified getField delegates to get()`() {
+        val ds = TestUtil.documentSnapshot("rooms/foo", mapOf("a" to 1, "b" to 2), false)
+
+        assertThat(ds.getField<Int>("a")).isEqualTo(ds.get("a", Int::class.java))
+        assertThat(ds.getField<Int>(FieldPath.of("a")))
+                .isEqualTo(ds.get(FieldPath.of("a"), Int::class.java))
+
+        assertThat(ds.getField<Int>("a", DocumentSnapshot.ServerTimestampBehavior.ESTIMATE))
+                .isEqualTo(ds.get("a", Int::class.java, DocumentSnapshot.ServerTimestampBehavior.ESTIMATE))
+        assertThat(ds.getField<Int>(FieldPath.of("a"), DocumentSnapshot.ServerTimestampBehavior.ESTIMATE))
+                .isEqualTo(ds.get(FieldPath.of("a"), Int::class.java))
+    }
+
+    @Test
+    fun `reified toObject delegates to toObject(Class)`() {
+        val ds = TestUtil.documentSnapshot("rooms/foo", mapOf("a" to 1, "b" to 2), false)
+
+        var room = ds.toObject<Room>()
+        assertThat(room).isEqualTo(Room(1, 2))
+        assertThat(room).isEqualTo(ds.toObject(Room::class.java))
+
+        room = ds.toObject<Room>(DocumentSnapshot.ServerTimestampBehavior.ESTIMATE)
+        assertThat(room).isEqualTo(Room(1, 2))
+        assertThat(room)
+                .isEqualTo(ds.toObject(Room::class.java, DocumentSnapshot.ServerTimestampBehavior.ESTIMATE))
+    }
+}
+
+@RunWith(RobolectricTestRunner::class)
+class QuerySnapshotTests {
+    @Before
+    fun setup() {
+        Mockito.`when`(TestUtil.firestore().firestoreSettings).thenReturn(FirebaseFirestoreSettings.Builder().build())
+    }
+
+    @After
+    fun cleanup() {
+        Mockito.reset(TestUtil.firestore())
+    }
+
+    @Test
+    fun `reified toObjects delegates to toObjects(Class)`() {
+        val qs = TestUtil.querySnapshot(
+                "rooms",
+                mapOf(),
+                mapOf("id" to ObjectValue.fromMap(mapOf("a" to IntegerValue.valueOf(1), "b" to IntegerValue.valueOf(2)))),
+                false,
+                false)
+
+        assertThat(qs.toObjects<Room>()).containsExactly(Room(1, 2))
+        assertThat(qs.toObjects<Room>(DocumentSnapshot.ServerTimestampBehavior.ESTIMATE)).containsExactly(Room(1, 2))
+    }
+}
diff --git a/firebase-firestore/CHANGELOG.md b/firebase-firestore/CHANGELOG.md
index 97e4545cf..753197e40 100644
--- a/firebase-firestore/CHANGELOG.md
+++ b/firebase-firestore/CHANGELOG.md
@@ -1,7 +1,18 @@
 # Unreleased
+- [feature] Added `FieldValue.increment()`, which can be used in `update()`
+  and `set(..., SetOptions.merge())` to increment or decrement numeric field
+  values safely without transactions.
 - [fixed] Fixed calculation of SQLite database size on Android 9 Pie devices.
   Previous method could be off by a few MBs on these devices, potentially
   delaying garbage collection.
+- [changed] Prepared the persistence layer to support collection group queries.
+  While this feature is not yet available, all schema changes are included
+  in this release.
+- [changed] Added `@RestrictTo` annotations to discourage the use of APIs that
+  are not public. This affects internal APIs that were previously obfuscated
+  and are not mentioned in our documentation.
+- [changed] Improved error messages for certain Number types that are not
+  supported by our serialization layer (#272).
 
 # 18.0.1
 - [fixed] Fixed an issue where Firestore would crash if handling write batches
diff --git a/firebase-firestore/firebase-firestore.gradle b/firebase-firestore/firebase-firestore.gradle
index 720ccce7a..fe780365d 100644
--- a/firebase-firestore/firebase-firestore.gradle
+++ b/firebase-firestore/firebase-firestore.gradle
@@ -14,6 +14,7 @@
 
 apply plugin: 'com.android.library'
 apply plugin: 'com.google.protobuf'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 protobuf {
     // Configure the protoc executable
@@ -71,6 +72,7 @@ android {
         test {
             java {
                 srcDir 'src/testUtil/java'
+                srcDir 'src/roboUtil/java'
             }
         }
         androidTest {
@@ -105,7 +107,7 @@ dependencies {
     implementation 'com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava'
 
     implementation 'com.squareup.okhttp:okhttp:2.7.5'
-    implementation ('com.google.firebase:firebase-auth-interop:16.0.1') {
+    implementation('com.google.firebase:firebase-auth-interop:16.0.1') {
         exclude group: "com.google.firebase", module: "firebase-common"
     }
 
diff --git a/firebase-firestore/gradle.properties b/firebase-firestore/gradle.properties
index d8acaf637..63d27242e 100644
--- a/firebase-firestore/gradle.properties
+++ b/firebase-firestore/gradle.properties
@@ -1,2 +1,2 @@
-version=18.1.0
-latestReleasedVersion=18.0.1
+version=18.2.0
+latestReleasedVersion=18.1.0
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java
new file mode 100644
index 000000000..83f41e810
--- /dev/null
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/NumericTransformsTest.java
@@ -0,0 +1,158 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore;
+
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testDocument;
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
+import static com.google.firebase.firestore.testutil.TestUtil.map;
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+
+import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.firestore.testutil.EventAccumulator;
+import com.google.firebase.firestore.testutil.IntegrationTestUtil;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class NumericTransformsTest {
+  private static final double DOUBLE_EPSILON = 0.000001;
+
+  // A document reference to read and write to.
+  private DocumentReference docRef;
+
+  // Accumulator used to capture events during the test.
+  private EventAccumulator<DocumentSnapshot> accumulator;
+
+  // Listener registration for a listener maintained during the course of the test.
+  private ListenerRegistration listenerRegistration;
+
+  @Before
+  public void setUp() {
+    docRef = testDocument();
+    accumulator = new EventAccumulator<>();
+    listenerRegistration =
+        docRef.addSnapshotListener(MetadataChanges.INCLUDE, accumulator.listener());
+
+    // Wait for initial null snapshot to avoid potential races.
+    DocumentSnapshot initialSnapshot = accumulator.await();
+    assertFalse(initialSnapshot.exists());
+  }
+
+  @After
+  public void tearDown() {
+    listenerRegistration.remove();
+    IntegrationTestUtil.tearDown();
+  }
+
+  /** Writes some initialData and consumes the events generated. */
+  private void writeInitialData(Map<String, Object> initialData) {
+    waitFor(docRef.set(initialData));
+    accumulator.awaitRemoteEvent();
+  }
+
+  private void expectLocalAndRemoteValue(double expectedSum) {
+    DocumentSnapshot snap = accumulator.awaitLocalEvent();
+    assertEquals(expectedSum, snap.getDouble("sum"), DOUBLE_EPSILON);
+    snap = accumulator.awaitRemoteEvent();
+    assertEquals(expectedSum, snap.getDouble("sum"), DOUBLE_EPSILON);
+  }
+
+  private void expectLocalAndRemoteValue(long expectedSum) {
+    DocumentSnapshot snap = accumulator.awaitLocalEvent();
+    assertEquals(expectedSum, (long) snap.getLong("sum"));
+    snap = accumulator.awaitRemoteEvent();
+    assertEquals(expectedSum, (long) snap.getLong("sum"));
+  }
+
+  @Test
+  public void createDocumentWithIncrement() {
+    waitFor(docRef.set(map("sum", FieldValue.increment(1337))));
+    expectLocalAndRemoteValue(1337L);
+  }
+
+  @Test
+  public void mergeOnNonExistingDocumentWithIncrement() {
+    waitFor(docRef.set(map("sum", FieldValue.increment(1337)), SetOptions.merge()));
+    expectLocalAndRemoteValue(1337L);
+  }
+
+  @Test
+  public void integerIncrementWithExistingInteger() {
+    writeInitialData(map("sum", 1337L));
+    waitFor(docRef.update("sum", FieldValue.increment(1)));
+    expectLocalAndRemoteValue(1338L);
+  }
+
+  @Test
+  public void doubleIncrementWithExistingDouble() {
+    writeInitialData(map("sum", 13.37D));
+    waitFor(docRef.update("sum", FieldValue.increment(0.1)));
+    expectLocalAndRemoteValue(13.47D);
+  }
+
+  @Test
+  public void integerIncrementWithExistingDouble() {
+    writeInitialData(map("sum", 13.37D));
+    waitFor(docRef.update("sum", FieldValue.increment(1)));
+    expectLocalAndRemoteValue(14.37D);
+  }
+
+  @Test
+  public void doubleIncrementWithExistingInteger() {
+    writeInitialData(map("sum", 1337L));
+    waitFor(docRef.update("sum", FieldValue.increment(0.1)));
+    expectLocalAndRemoteValue(1337.1D);
+  }
+
+  @Test
+  public void integerIncrementWithExistingString() {
+    writeInitialData(map("sum", "overwrite"));
+    waitFor(docRef.update("sum", FieldValue.increment(1337)));
+    expectLocalAndRemoteValue(1337L);
+  }
+
+  @Test
+  public void doubleIncrementWithExistingString() {
+    writeInitialData(map("sum", "overwrite"));
+    waitFor(docRef.update("sum", FieldValue.increment(13.37)));
+    expectLocalAndRemoteValue(13.37D);
+  }
+
+  @Test
+  public void multipleDoubleIncrements() throws ExecutionException, InterruptedException {
+    writeInitialData(map("sum", 0.0D));
+
+    Tasks.await(docRef.getFirestore().disableNetwork());
+
+    docRef.update("sum", FieldValue.increment(0.1D));
+    docRef.update("sum", FieldValue.increment(0.01D));
+    docRef.update("sum", FieldValue.increment(0.001D));
+
+    DocumentSnapshot snap = accumulator.awaitLocalEvent();
+    assertEquals(0.1D, snap.getDouble("sum"), DOUBLE_EPSILON);
+    snap = accumulator.awaitLocalEvent();
+    assertEquals(0.11D, snap.getDouble("sum"), DOUBLE_EPSILON);
+    snap = accumulator.awaitLocalEvent();
+    assertEquals(0.111D, snap.getDouble("sum"), DOUBLE_EPSILON);
+
+    Tasks.await(docRef.getFirestore().enableNetwork());
+
+    snap = accumulator.awaitRemoteEvent();
+    assertEquals(0.111D, snap.getDouble("sum"), DOUBLE_EPSILON);
+  }
+}
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
index bb60af5f7..6bbf00fb6 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/POJOTest.java
@@ -26,8 +26,12 @@
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.testutil.IntegrationTestUtil;
+import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import javax.annotation.Nullable;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -164,6 +168,39 @@ public int hashCode() {
     }
   }
 
+  public static class InvalidPOJO {
+    @Nullable BigInteger bigIntegerValue = null;
+    @Nullable Byte byteValue = null;
+    @Nullable Short shortValue = null;
+
+    @Nullable
+    public BigInteger getBigIntegerValue() {
+      return bigIntegerValue;
+    }
+
+    public void setBigIntegerValue(@Nullable BigInteger bigIntegerValue) {
+      this.bigIntegerValue = bigIntegerValue;
+    }
+
+    @Nullable
+    public Byte getByteValue() {
+      return byteValue;
+    }
+
+    public void setByteValue(@Nullable Byte byteValue) {
+      this.byteValue = byteValue;
+    }
+
+    @Nullable
+    public Short getShortValue() {
+      return shortValue;
+    }
+
+    public void setShortValue(@Nullable Short shortValue) {
+      this.shortValue = shortValue;
+    }
+  }
+
   @After
   public void tearDown() {
     IntegrationTestUtil.tearDown();
@@ -253,4 +290,61 @@ public void setFieldMaskMustHaveCorrespondingValue() {
         () -> reference.set(new POJO(), SetOptions.mergeFields("str", "missing")),
         "Field 'missing' is specified in your field mask but not in your input data.");
   }
+
+  @Test
+  public void testCantWriteNonStandardNumberTypes() {
+    DocumentReference ref = testDocument();
+
+    Map<InvalidPOJO, String> expectedErrorMessages = new HashMap<>();
+
+    InvalidPOJO pojo = new InvalidPOJO();
+    pojo.bigIntegerValue = new BigInteger("0");
+    expectedErrorMessages.put(
+        pojo,
+        "Could not serialize object. Numbers of type BigInteger are not supported, please use an int, long, float or double (found in field 'bigIntegerValue')");
+
+    pojo = new InvalidPOJO();
+    pojo.byteValue = 0;
+    expectedErrorMessages.put(
+        pojo,
+        "Could not serialize object. Numbers of type Byte are not supported, please use an int, long, float or double (found in field 'byteValue')");
+
+    pojo = new InvalidPOJO();
+    pojo.shortValue = 0;
+    expectedErrorMessages.put(
+        pojo,
+        "Could not serialize object. Numbers of type Short are not supported, please use an int, long, float or double (found in field 'shortValue')");
+
+    for (Map.Entry<InvalidPOJO, String> testCase : expectedErrorMessages.entrySet()) {
+      expectError(() -> ref.set(testCase.getKey()), testCase.getValue());
+    }
+  }
+
+  @Test
+  public void testCantReadBigInteger() {
+    DocumentReference ref = testDocument();
+
+    Map<String, Object> invalidData =
+        map(
+            "bigIntegerValue",
+            map("bigIntegerValue", 0),
+            "byteValue",
+            map("byteValue", 0),
+            "shortValue",
+            map("shortValue", 0));
+    waitFor(ref.set(invalidData));
+    DocumentSnapshot snap = waitFor(ref.get());
+
+    expectError(
+        () -> snap.get("bigIntegerValue", InvalidPOJO.class),
+        "Could not deserialize object. Deserializing values to BigInteger is not supported (found in field 'bigIntegerValue')");
+
+    expectError(
+        () -> snap.get("byteValue", InvalidPOJO.class),
+        "Could not deserialize object. Deserializing values to Byte is not supported (found in field 'byteValue')");
+
+    expectError(
+        () -> snap.get("shortValue", InvalidPOJO.class),
+        "Could not deserialize object. Deserializing values to Short is not supported (found in field 'shortValue')");
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
index 9500d2255..09c02ec58 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/QueryTest.java
@@ -18,6 +18,7 @@
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.querySnapshotToValues;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollection;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testCollectionWithDocs;
+import static com.google.firebase.firestore.testutil.IntegrationTestUtil.testFirestore;
 import static com.google.firebase.firestore.testutil.IntegrationTestUtil.waitFor;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
 import static java.util.Arrays.asList;
@@ -425,4 +426,119 @@ public void testQueriesCanUseArrayContainsFilters() {
     // NOTE: The backend doesn't currently support null, NaN, objects, or arrays, so there isn't
     // much of anything else interesting to test.
   }
+
+  @Test
+  public void testCollectionGroupQueries() {
+    FirebaseFirestore db = testFirestore();
+    // Use .document() to get a random collection group name to use but ensure it starts with 'b'
+    // for predictable ordering.
+    String collectionGroup = "b" + db.collection("foo").document().getId();
+
+    String[] docPaths =
+        new String[] {
+          "abc/123/${collectionGroup}/cg-doc1",
+          "abc/123/${collectionGroup}/cg-doc2",
+          "${collectionGroup}/cg-doc3",
+          "${collectionGroup}/cg-doc4",
+          "def/456/${collectionGroup}/cg-doc5",
+          "${collectionGroup}/virtual-doc/nested-coll/not-cg-doc",
+          "x${collectionGroup}/not-cg-doc",
+          "${collectionGroup}x/not-cg-doc",
+          "abc/123/${collectionGroup}x/not-cg-doc",
+          "abc/123/x${collectionGroup}/not-cg-doc",
+          "abc/${collectionGroup}"
+        };
+    WriteBatch batch = db.batch();
+    for (String path : docPaths) {
+      batch.set(db.document(path.replace("${collectionGroup}", collectionGroup)), map("x", 1));
+    }
+    waitFor(batch.commit());
+
+    QuerySnapshot querySnapshot = waitFor(db.collectionGroup(collectionGroup).get());
+    assertEquals(
+        asList("cg-doc1", "cg-doc2", "cg-doc3", "cg-doc4", "cg-doc5"),
+        querySnapshotToIds(querySnapshot));
+  }
+
+  @Test
+  public void testCollectionGroupQueriesWithStartAtEndAtWithArbitraryDocumentIds() {
+    FirebaseFirestore db = testFirestore();
+    // Use .document() to get a random collection group name to use but ensure it starts with 'b'
+    // for predictable ordering.
+    String collectionGroup = "b" + db.collection("foo").document().getId();
+
+    String[] docPaths =
+        new String[] {
+          "a/a/${collectionGroup}/cg-doc1",
+          "a/b/a/b/${collectionGroup}/cg-doc2",
+          "a/b/${collectionGroup}/cg-doc3",
+          "a/b/c/d/${collectionGroup}/cg-doc4",
+          "a/c/${collectionGroup}/cg-doc5",
+          "${collectionGroup}/cg-doc6",
+          "a/b/nope/nope"
+        };
+    WriteBatch batch = db.batch();
+    for (String path : docPaths) {
+      batch.set(db.document(path.replace("${collectionGroup}", collectionGroup)), map("x", 1));
+    }
+    waitFor(batch.commit());
+
+    QuerySnapshot querySnapshot =
+        waitFor(
+            db.collectionGroup(collectionGroup)
+                .orderBy(FieldPath.documentId())
+                .startAt("a/b")
+                .endAt("a/b0")
+                .get());
+    assertEquals(asList("cg-doc2", "cg-doc3", "cg-doc4"), querySnapshotToIds(querySnapshot));
+
+    querySnapshot =
+        waitFor(
+            db.collectionGroup(collectionGroup)
+                .orderBy(FieldPath.documentId())
+                .startAfter("a/b")
+                .endBefore("a/b/" + collectionGroup + "/cg-doc3")
+                .get());
+    assertEquals(asList("cg-doc2"), querySnapshotToIds(querySnapshot));
+  }
+
+  @Test
+  public void testCollectionGroupQueriesWithWhereFiltersOnArbitraryDocumentIds() {
+    FirebaseFirestore db = testFirestore();
+    // Use .document() to get a random collection group name to use but ensure it starts with 'b'
+    // for predictable ordering.
+    String collectionGroup = "b" + db.collection("foo").document().getId();
+
+    String[] docPaths =
+        new String[] {
+          "a/a/${collectionGroup}/cg-doc1",
+          "a/b/a/b/${collectionGroup}/cg-doc2",
+          "a/b/${collectionGroup}/cg-doc3",
+          "a/b/c/d/${collectionGroup}/cg-doc4",
+          "a/c/${collectionGroup}/cg-doc5",
+          "${collectionGroup}/cg-doc6",
+          "a/b/nope/nope"
+        };
+    WriteBatch batch = db.batch();
+    for (String path : docPaths) {
+      batch.set(db.document(path.replace("${collectionGroup}", collectionGroup)), map("x", 1));
+    }
+    waitFor(batch.commit());
+
+    QuerySnapshot querySnapshot =
+        waitFor(
+            db.collectionGroup(collectionGroup)
+                .whereGreaterThanOrEqualTo(FieldPath.documentId(), "a/b")
+                .whereLessThanOrEqualTo(FieldPath.documentId(), "a/b0")
+                .get());
+    assertEquals(asList("cg-doc2", "cg-doc3", "cg-doc4"), querySnapshotToIds(querySnapshot));
+
+    querySnapshot =
+        waitFor(
+            db.collectionGroup(collectionGroup)
+                .whereGreaterThan(FieldPath.documentId(), "a/b")
+                .whereLessThan(FieldPath.documentId(), "a/b/" + collectionGroup + "/cg-doc3")
+                .get());
+    assertEquals(asList("cg-doc2"), querySnapshotToIds(querySnapshot));
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
index 1c526440a..87dc07b70 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java
@@ -499,14 +499,21 @@ public void queriesMustNotHaveMoreComponentsThanOrderBy() {
 
   @Test
   public void queryOrderByKeyBoundsMustBeStringsWithoutSlashes() {
-    CollectionReference collection = testCollection();
-    Query query = collection.orderBy(FieldPath.documentId());
+    Query query = testFirestore().collection("collection").orderBy(FieldPath.documentId());
+    Query cgQuery = testFirestore().collectionGroup("collection").orderBy(FieldPath.documentId());
     expectError(
         () -> query.startAt(1),
         "Invalid query. Expected a string for document ID in startAt(), but got 1.");
     expectError(
         () -> query.startAt("foo/bar"),
-        "Invalid query. Document ID 'foo/bar' contains a slash in startAt().");
+        "Invalid query. When querying a collection and ordering by "
+            + "FieldPath.documentId(), the value passed to startAt() must be a plain "
+            + "document ID, but 'foo/bar' contains a slash.");
+    expectError(
+        () -> cgQuery.startAt("foo"),
+        "Invalid query. When querying a collection group and ordering by "
+            + "FieldPath.documentId(), the value passed to startAt() must result in a valid "
+            + "document path, but 'foo' is not because it contains an odd number of segments.");
   }
 
   @Test
@@ -548,7 +555,7 @@ public void queriesMustNotSpecifyStartingOrEndingPointAfterOrderBy() {
     expectError(() -> query.startAt(1).orderBy("bar"), reason);
     expectError(() -> query.startAfter(1).orderBy("bar"), reason);
     reason =
-        "Invalid query. You must not call Query.endAt() or Query.endAfter() "
+        "Invalid query. You must not call Query.endAt() or Query.endBefore() "
             + "before calling Query.orderBy().";
     expectError(() -> query.endAt(1).orderBy("bar"), reason);
     expectError(() -> query.endBefore(1).orderBy("bar"), reason);
@@ -563,8 +570,8 @@ public void queriesFilteredByDocumentIDMustUseStringsOrDocumentReferences() {
     expectError(() -> collection.whereGreaterThanOrEqualTo(FieldPath.documentId(), ""), reason);
 
     reason =
-        "Invalid query. When querying with FieldPath.documentId() you must provide "
-            + "a valid document ID, but 'foo/bar/baz' contains a '/' character.";
+        "Invalid query. When querying a collection by FieldPath.documentId() you must provide "
+            + "a plain document ID, but 'foo/bar/baz' contains a '/' character.";
     expectError(
         () -> collection.whereGreaterThanOrEqualTo(FieldPath.documentId(), "foo/bar/baz"), reason);
 
@@ -573,6 +580,17 @@ public void queriesFilteredByDocumentIDMustUseStringsOrDocumentReferences() {
             + "a valid String or DocumentReference, but it was of type: java.lang.Integer";
     expectError(() -> collection.whereGreaterThanOrEqualTo(FieldPath.documentId(), 1), reason);
 
+    reason =
+        "Invalid query. When querying a collection group by FieldPath.documentId(), the value "
+            + "provided must result in a valid document path, but 'foo' is not because it has "
+            + "an odd number of segments (1).";
+    expectError(
+        () ->
+            testFirestore()
+                .collectionGroup("collection")
+                .whereGreaterThanOrEqualTo(FieldPath.documentId(), "foo"),
+        reason);
+
     reason =
         "Invalid query. You can't perform array-contains queries on FieldPath.documentId() since "
             + "document IDs are not arrays.";
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
index 10544e735..51ecefcf3 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/WriteBatchTest.java
@@ -291,4 +291,19 @@ public void testCanWriteVeryLargeBatches() {
     DocumentSnapshot snap = waitFor(doc.get());
     assertEquals(values, snap.getData());
   }
+
+  @Test
+  public void testRunBatch() {
+    DocumentReference doc = testDocument();
+    waitFor(doc.set(map("foo", "bar")));
+    waitFor(
+        doc.getFirestore()
+            .runBatch(
+                batch -> {
+                  batch.update(doc, map("baz", 42));
+                }));
+    DocumentSnapshot snapshot = waitFor(doc.get());
+    assertTrue(snapshot.exists());
+    assertEquals(map("foo", "bar", "baz", 42L), snapshot.getData());
+  }
 }
diff --git a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
index 8bc407a78..cf7c2be30 100644
--- a/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
+++ b/firebase-firestore/src/androidTest/java/com/google/firebase/firestore/testutil/IntegrationTestUtil.java
@@ -20,6 +20,7 @@
 import static junit.framework.Assert.fail;
 
 import android.content.Context;
+import android.net.SSLCertificateSocketFactory;
 import android.support.test.InstrumentationRegistry;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
@@ -38,10 +39,12 @@
 import com.google.firebase.firestore.local.Persistence;
 import com.google.firebase.firestore.local.SQLitePersistence;
 import com.google.firebase.firestore.model.DatabaseId;
+import com.google.firebase.firestore.remote.Datastore;
 import com.google.firebase.firestore.testutil.provider.FirestoreProvider;
 import com.google.firebase.firestore.util.AsyncQueue;
 import com.google.firebase.firestore.util.Logger;
 import com.google.firebase.firestore.util.Logger.Level;
+import io.grpc.okhttp.OkHttpChannelBuilder;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -56,6 +59,14 @@
 /** A set of helper methods for tests */
 public class IntegrationTestUtil {
 
+  // Whether the integration tests should run against a local Firestore emulator instead of the
+  // Production environment. Note that the Android Emulator treats "10.0.2.2" as its host machine.
+  // TODO(mrschmidt): Support multiple envrionments (Emulator, QA, Nightly, Production)
+  private static final boolean CONNECT_TO_EMULATOR = false;
+
+  private static final String EMULATOR_HOST = "10.0.2.2";
+  private static final int EMULATOR_PORT = 8081;
+
   // Alternate project ID for creating "bad" references. Doesn't actually need to work.
   public static final String BAD_PROJECT_ID = "test-project-2";
 
@@ -80,11 +91,19 @@ public static FirestoreProvider provider() {
   }
 
   public static DatabaseInfo testEnvDatabaseInfo() {
-    return new DatabaseInfo(
-        DatabaseId.forProject(provider.projectId()),
-        "test-persistenceKey",
-        provider.firestoreHost(),
-        /*sslEnabled=*/ true);
+    if (CONNECT_TO_EMULATOR) {
+      return new DatabaseInfo(
+          DatabaseId.forProject(provider.projectId()),
+          "test-persistenceKey",
+          String.format("%s:%d", EMULATOR_HOST, EMULATOR_PORT),
+          /*sslEnabled=*/ true);
+    } else {
+      return new DatabaseInfo(
+          DatabaseId.forProject(provider.projectId()),
+          "test-persistenceKey",
+          provider.firestoreHost(),
+          /*sslEnabled=*/ true);
+    }
   }
 
   public static FirebaseFirestoreSettings newTestSettings() {
@@ -94,11 +113,37 @@ public static FirebaseFirestoreSettings newTestSettings() {
   @SuppressWarnings("deprecation") // for setTimestampsInSnapshotsEnabled()
   public static FirebaseFirestoreSettings newTestSettingsWithSnapshotTimestampsEnabled(
       boolean enabled) {
-    return new FirebaseFirestoreSettings.Builder()
-        .setHost(provider.firestoreHost())
-        .setPersistenceEnabled(true)
-        .setTimestampsInSnapshotsEnabled(enabled)
-        .build();
+    FirebaseFirestoreSettings.Builder settings = new FirebaseFirestoreSettings.Builder();
+
+    if (CONNECT_TO_EMULATOR) {
+      settings.setHost(String.format("%s:%d", EMULATOR_HOST, EMULATOR_PORT));
+
+      // The `sslEnabled` flag in DatabaseInfo currently does not in fact disable all SSL checks.
+      // Instead, we manually disable the SSL certificate check and the hostname verification for
+      // connections to the emulator.
+      // TODO(mrschmidt): Update the client to respect the `sslEnabled` flag and remove these
+      // channel overrides.
+      OkHttpChannelBuilder channelBuilder =
+          new OkHttpChannelBuilder(EMULATOR_HOST, EMULATOR_PORT) {
+            @Override
+            protected String checkAuthority(String authority) {
+              return authority;
+            }
+          };
+      channelBuilder.hostnameVerifier((hostname, session) -> true);
+      SSLCertificateSocketFactory insecureFactory =
+          (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getInsecure(0, null);
+      channelBuilder.sslSocketFactory(insecureFactory);
+
+      Datastore.overrideChannelBuilder(() -> channelBuilder);
+    } else {
+      settings.setHost(provider.firestoreHost());
+    }
+
+    settings.setPersistenceEnabled(true);
+    settings.setTimestampsInSnapshotsEnabled(enabled);
+
+    return settings.build();
   }
 
   /** Initializes a new Firestore instance that uses the default project. */
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
index 1b45ce148..3de2959ea 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java
@@ -16,9 +16,9 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import android.support.annotation.Keep;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RestrictTo;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.util.Util;
 import com.google.protobuf.ByteString;
@@ -38,8 +38,8 @@ private Blob(ByteString bytes) {
    * @param bytes The bytes to use for this Blob instance.
    * @return The new Blob instance
    */
-  @Keep
   @NonNull
+  @PublicApi
   public static Blob fromBytes(@NonNull byte[] bytes) {
     checkNotNull(bytes, "Provided bytes array must not be null.");
     return new Blob(ByteString.copyFrom(bytes));
@@ -47,14 +47,15 @@ public static Blob fromBytes(@NonNull byte[] bytes) {
 
   /** @hide */
   @NonNull
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public static Blob fromByteString(@NonNull ByteString bytes) {
     checkNotNull(bytes, "Provided ByteString must not be null.");
     return new Blob(bytes);
   }
 
   /** @return The bytes of this blob as a new byte[] array. */
-  @Keep
   @NonNull
+  @PublicApi
   public byte[] toBytes() {
     return bytes.toByteArray();
   }
@@ -67,6 +68,7 @@ public String toString() {
 
   /** @hide */
   @NonNull
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public ByteString toByteString() {
     return bytes;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
index 44c29e88e..1d54149a6 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentReference.java
@@ -26,7 +26,10 @@
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
+import com.google.firebase.firestore.core.ActivityScope;
+import com.google.firebase.firestore.core.AsyncEventListener;
 import com.google.firebase.firestore.core.EventManager.ListenOptions;
+import com.google.firebase.firestore.core.ListenerRegistrationImpl;
 import com.google.firebase.firestore.core.QueryListener;
 import com.google.firebase.firestore.core.UserData.ParsedSetData;
 import com.google.firebase.firestore.core.UserData.ParsedUpdateData;
@@ -37,9 +40,7 @@
 import com.google.firebase.firestore.model.mutation.DeleteMutation;
 import com.google.firebase.firestore.model.mutation.Precondition;
 import com.google.firebase.firestore.util.Assert;
-import com.google.firebase.firestore.util.ExecutorEventListener;
 import com.google.firebase.firestore.util.Executors;
-import com.google.firebase.firestore.util.ListenerRegistrationImpl;
 import com.google.firebase.firestore.util.Util;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -71,7 +72,7 @@
   }
 
   /** @hide */
-  public static DocumentReference forPath(ResourcePath path, FirebaseFirestore firestore) {
+  static DocumentReference forPath(ResourcePath path, FirebaseFirestore firestore) {
     if (path.length() % 2 != 0) {
       throw new IllegalArgumentException(
           "Invalid document reference. Document references must have an even number "
@@ -284,7 +285,7 @@ public CollectionReference collection(@NonNull String collectionPath) {
    */
   @NonNull
   @PublicApi
-  public Task<DocumentSnapshot> get(Source source) {
+  public Task<DocumentSnapshot> get(@NonNull Source source) {
     if (source == Source.CACHE) {
       return firestore
           .getClient()
@@ -311,6 +312,7 @@ public CollectionReference collection(@NonNull String collectionPath) {
     options.includeDocumentMetadataChanges = true;
     options.includeQueryMetadataChanges = true;
     options.waitForSyncWhenOnline = true;
+
     ListenerRegistration listenerRegistration =
         addSnapshotListenerInternal(
             // No need to schedule, we just set the task result directly
@@ -479,49 +481,58 @@ public ListenerRegistration addSnapshotListener(
    *
    * <p>Will be Activity scoped if the activity parameter is non-null.
    *
-   * @param executor The executor to use to call the listener.
+   * @param userExecutor The executor to use to call the listener.
    * @param options The options to use for this listen.
    * @param activity Optional activity this listener is scoped to.
-   * @param listener The event listener that will be called with the snapshots.
+   * @param userListener The user-supplied event listener that will be called with document
+   *     snapshots.
    * @return A registration object that can be used to remove the listener.
    */
   private ListenerRegistration addSnapshotListenerInternal(
-      Executor executor,
+      Executor userExecutor,
       ListenOptions options,
       @Nullable Activity activity,
-      EventListener<DocumentSnapshot> listener) {
-    ExecutorEventListener<ViewSnapshot> wrappedListener =
-        new ExecutorEventListener<>(
-            executor,
-            (snapshot, error) -> {
-              if (snapshot != null) {
-                Assert.hardAssert(
-                    snapshot.getDocuments().size() <= 1,
-                    "Too many documents returned on a document query");
-                Document document = snapshot.getDocuments().getDocument(key);
-                DocumentSnapshot documentSnapshot;
-                if (document != null) {
-                  boolean hasPendingWrites = snapshot.getMutatedKeys().contains(document.getKey());
-                  documentSnapshot =
-                      DocumentSnapshot.fromDocument(
-                          firestore, document, snapshot.isFromCache(), hasPendingWrites);
-                } else {
-                  // We don't raise `hasPendingWrites` for deleted documents.
-                  boolean hasPendingWrites = false;
-                  documentSnapshot =
-                      DocumentSnapshot.fromNoDocument(
-                          firestore, key, snapshot.isFromCache(), hasPendingWrites);
-                }
-                listener.onEvent(documentSnapshot, null);
-              } else {
-                Assert.hardAssert(error != null, "Got event without value or error set");
-                listener.onEvent(null, error);
-              }
-            });
+      EventListener<DocumentSnapshot> userListener) {
+
+    // Convert from ViewSnapshots to DocumentSnapshots.
+    EventListener<ViewSnapshot> viewListener =
+        (snapshot, error) -> {
+          if (error != null) {
+            userListener.onEvent(null, error);
+            return;
+          }
+
+          Assert.hardAssert(snapshot != null, "Got event without value or error set");
+          Assert.hardAssert(
+              snapshot.getDocuments().size() <= 1,
+              "Too many documents returned on a document query");
+
+          Document document = snapshot.getDocuments().getDocument(key);
+          DocumentSnapshot documentSnapshot;
+          if (document != null) {
+            boolean hasPendingWrites = snapshot.getMutatedKeys().contains(document.getKey());
+            documentSnapshot =
+                DocumentSnapshot.fromDocument(
+                    firestore, document, snapshot.isFromCache(), hasPendingWrites);
+          } else {
+            // We don't raise `hasPendingWrites` for deleted documents.
+            documentSnapshot =
+                DocumentSnapshot.fromNoDocument(
+                    firestore, key, snapshot.isFromCache(), /* hasPendingWrites= */ false);
+          }
+          userListener.onEvent(documentSnapshot, null);
+        };
+
+    // Call the viewListener on the userExecutor.
+    AsyncEventListener<ViewSnapshot> asyncListener =
+        new AsyncEventListener<>(userExecutor, viewListener);
+
     com.google.firebase.firestore.core.Query query = asQuery();
-    QueryListener queryListener = firestore.getClient().listen(query, options, wrappedListener);
-    return new ListenerRegistrationImpl(
-        firestore.getClient(), queryListener, activity, wrappedListener);
+    QueryListener queryListener = firestore.getClient().listen(query, options, asyncListener);
+
+    return ActivityScope.bind(
+        activity,
+        new ListenerRegistrationImpl(firestore.getClient(), queryListener, asyncListener));
   }
 
   @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
index 4a13eefd9..b5ec5fab5 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/DocumentSnapshot.java
@@ -298,6 +298,7 @@ public Object get(
    * @return The value at the given field or null.
    */
   @Nullable
+  @PublicApi
   public <T> T get(@NonNull String field, @NonNull Class<T> valueType) {
     return get(FieldPath.fromDotSeparatedPath(field), valueType, ServerTimestampBehavior.DEFAULT);
   }
@@ -313,6 +314,7 @@ public Object get(
    * @return The value at the given field or null.
    */
   @Nullable
+  @PublicApi
   public <T> T get(
       @NonNull String field,
       @NonNull Class<T> valueType,
@@ -329,6 +331,7 @@ public Object get(
    * @return The value at the given field or null.
    */
   @Nullable
+  @PublicApi
   public <T> T get(@NonNull FieldPath fieldPath, @NonNull Class<T> valueType) {
     return get(fieldPath, valueType, ServerTimestampBehavior.DEFAULT);
   }
@@ -344,6 +347,7 @@ public Object get(
    * @return The value at the given field or null.
    */
   @Nullable
+  @PublicApi
   public <T> T get(
       @NonNull FieldPath fieldPath,
       @NonNull Class<T> valueType,
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
index 0eb7780ef..d65788ecb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FieldValue.java
@@ -61,7 +61,7 @@ String getMethodName() {
     }
 
     List<Object> getElements() {
-      return this.elements;
+      return elements;
     }
   }
 
@@ -79,7 +79,25 @@ String getMethodName() {
     }
 
     List<Object> getElements() {
-      return this.elements;
+      return elements;
+    }
+  }
+
+  /* FieldValue class for increment() transforms. */
+  static class NumericIncrementFieldValue extends FieldValue {
+    private final Number operand;
+
+    NumericIncrementFieldValue(Number operand) {
+      this.operand = operand;
+    }
+
+    @Override
+    String getMethodName() {
+      return "FieldValue.increment";
+    }
+
+    Number getOperand() {
+      return operand;
     }
   }
 
@@ -134,4 +152,39 @@ public static FieldValue arrayUnion(@NonNull Object... elements) {
   public static FieldValue arrayRemove(@NonNull Object... elements) {
     return new ArrayRemoveFieldValue(Arrays.asList(elements));
   }
+
+  /**
+   * Returns a special value that can be used with set() or update() that tells the server to
+   * increment the field's current value by the given value.
+   *
+   * <p>If the current field value is an integer, possible integer overflows are resolved to
+   * Long.MAX_VALUE or Long.MIN_VALUE. If the current field value is a double, both values will be
+   * interpreted as doubles and the arithmetic will follow IEEE 754 semantics.
+   *
+   * <p>If the current field is not an integer or double, or if the field does not yet exist, the
+   * transformation will set the field to the given value.
+   *
+   * @return The FieldValue sentinel for use in a call to set() or update().
+   */
+  @NonNull
+  @PublicApi
+  public static FieldValue increment(long l) {
+    return new NumericIncrementFieldValue(l);
+  }
+
+  /**
+   * Returns a special value that can be used with set() or update() that tells the server to
+   * increment the field's current value by the given value.
+   *
+   * <p>If the current value is an integer or a double, both the current and the given value will be
+   * interpreted as doubles and all arithmetic will follow IEEE 754 semantics. Otherwise, the
+   * transformation will set the field to the given value.
+   *
+   * @return The FieldValue sentinel for use in a call to set() or update().
+   */
+  @NonNull
+  @PublicApi
+  public static FieldValue increment(double l) {
+    return new NumericIncrementFieldValue(l);
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
index 20ace7fbc..41ef54186 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirebaseFirestore.java
@@ -235,6 +235,30 @@ public DocumentReference document(@NonNull String documentPath) {
     return DocumentReference.forPath(ResourcePath.fromString(documentPath), this);
   }
 
+  // TODO(b/116617988): Expose API publicly once backend support is ready (and add to CHANGELOG.md).
+  /**
+   * Creates and returns a new @link{Query} that includes all documents in the database that are
+   * contained in a collection or subcollection with the given @code{collectionId}.
+   *
+   * @param collectionId Identifies the collections to query over. Every collection or subcollection
+   *     with this ID as the last segment of its path will be included. Cannot contain a slash.
+   * @return The created Query.
+   */
+  @NonNull
+  // @PublicApi
+  /* public */ Query collectionGroup(@NonNull String collectionId) {
+    checkNotNull(collectionId, "Provided collection ID must not be null.");
+    if (collectionId.contains("/")) {
+      throw new IllegalArgumentException(
+          String.format(
+              "Invalid collectionId '%s'. Collection IDs must not contain '/'.", collectionId));
+    }
+
+    ensureClientConfigured();
+    return new Query(
+        new com.google.firebase.firestore.core.Query(ResourcePath.EMPTY, collectionId), this);
+  }
+
   /**
    * Executes the given updateFunction and then attempts to commit the changes applied within the
    * transaction. If any document read within the transaction has changed, the updateFunction will
@@ -293,6 +317,21 @@ public WriteBatch batch() {
     return new WriteBatch(this);
   }
 
+  /**
+   * Executes a batchFunction on a newly created {@link WriteBatch} and then commits all of the
+   * writes made by the batchFunction as a single atomic unit.
+   *
+   * @param batchFunction The function to execute within the batch context.
+   * @return A Task that will be resolved when the batch has been committed.
+   */
+  @NonNull
+  @PublicApi
+  public Task<Void> runBatch(@NonNull WriteBatch.Function batchFunction) {
+    WriteBatch batch = batch();
+    batchFunction.apply(batch);
+    return batch.commit();
+  }
+
   @VisibleForTesting
   Task<Void> shutdown() {
     if (client == null) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
index 47f064eda..6d551ee7b 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/FirestoreRegistrar.java
@@ -16,6 +16,7 @@
 
 import android.content.Context;
 import android.support.annotation.Keep;
+import android.support.annotation.RestrictTo;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
@@ -31,6 +32,7 @@
  * @hide
  */
 @Keep
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public class FirestoreRegistrar implements ComponentRegistrar {
   @Override
   @Keep
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
index 16957d93c..633789d7f 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/Query.java
@@ -19,17 +19,19 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.app.Activity;
-import android.support.annotation.Keep;
 import android.support.annotation.NonNull;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.FirebaseFirestoreException.Code;
+import com.google.firebase.firestore.core.ActivityScope;
+import com.google.firebase.firestore.core.AsyncEventListener;
 import com.google.firebase.firestore.core.Bound;
 import com.google.firebase.firestore.core.EventManager.ListenOptions;
 import com.google.firebase.firestore.core.Filter;
 import com.google.firebase.firestore.core.Filter.Operator;
+import com.google.firebase.firestore.core.ListenerRegistrationImpl;
 import com.google.firebase.firestore.core.OrderBy;
 import com.google.firebase.firestore.core.QueryListener;
 import com.google.firebase.firestore.core.RelationFilter;
@@ -40,9 +42,7 @@
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ReferenceValue;
 import com.google.firebase.firestore.model.value.ServerTimestampValue;
-import com.google.firebase.firestore.util.ExecutorEventListener;
 import com.google.firebase.firestore.util.Executors;
-import com.google.firebase.firestore.util.ListenerRegistrationImpl;
 import com.google.firebase.firestore.util.Util;
 import java.util.ArrayList;
 import java.util.List;
@@ -65,8 +65,7 @@
   final FirebaseFirestore firestore;
 
   /** An enum for the direction of a sort. */
-  // TODO: Remove this annotation once our proguard issues are sorted out.
-  @Keep
+  @PublicApi
   public enum Direction {
     ASCENDING,
     DESCENDING
@@ -324,20 +323,28 @@ private Query whereHelper(@NonNull FieldPath fieldPath, Operator op, Object valu
       }
       if (value instanceof String) {
         String documentKey = (String) value;
-        if (documentKey.contains("/")) {
-          // TODO: Allow slashes once ancestor queries are supported
+        if (documentKey.isEmpty()) {
           throw new IllegalArgumentException(
               "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
-                  + "document ID, but '"
+                  + "document ID, but it was an empty string.");
+        }
+        if (!query.isCollectionGroupQuery() && documentKey.contains("/")) {
+          throw new IllegalArgumentException(
+              "Invalid query. When querying a collection by FieldPath.documentId() you must "
+                  + "provide a plain document ID, but '"
                   + documentKey
                   + "' contains a '/' character.");
-        } else if (documentKey.isEmpty()) {
+        }
+        ResourcePath path = query.getPath().append(ResourcePath.fromString(documentKey));
+        if (!DocumentKey.isDocumentKey(path)) {
           throw new IllegalArgumentException(
-              "Invalid query. When querying with FieldPath.documentId() you must provide a valid "
-                  + "document ID, but it was an empty string.");
+              "Invalid query. When querying a collection group by FieldPath.documentId(), the "
+                  + "value provided must result in a valid document path, but '"
+                  + path
+                  + "' is not because it has an odd number of segments ("
+                  + path.length()
+                  + ").");
         }
-        ResourcePath path = this.query.getPath().append(documentKey);
-        hardAssert(path.length() % 2 == 0, "Path should be a document key");
         fieldValue =
             ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), DocumentKey.fromPath(path));
       } else if (value instanceof DocumentReference) {
@@ -430,7 +437,7 @@ private Query orderBy(
     }
     if (query.getEndAt() != null) {
       throw new IllegalArgumentException(
-          "Invalid query. You must not call Query.endAt() or Query.endAfter() before "
+          "Invalid query. You must not call Query.endAt() or Query.endBefore() before "
               + "calling Query.orderBy().");
     }
     validateOrderByField(fieldPath);
@@ -655,15 +662,26 @@ private Bound boundFromFields(String methodName, Object[] values, boolean before
                   + ".");
         }
         String documentId = (String) rawValue;
-        if (documentId.contains("/")) {
+        if (!query.isCollectionGroupQuery() && documentId.contains("/")) {
           throw new IllegalArgumentException(
-              "Invalid query. Document ID '"
+              "Invalid query. When querying a collection and ordering by FieldPath.documentId(), "
+                  + "the value passed to "
+                  + methodName
+                  + "() must be a plain document ID, but '"
                   + documentId
-                  + "' contains a slash in "
+                  + "' contains a slash.");
+        }
+        ResourcePath path = query.getPath().append(ResourcePath.fromString(documentId));
+        if (!DocumentKey.isDocumentKey(path)) {
+          throw new IllegalArgumentException(
+              "Invalid query. When querying a collection group and ordering by "
+                  + "FieldPath.documentId(), the value passed to "
                   + methodName
-                  + "().");
+                  + "() must result in a valid document path, but '"
+                  + path
+                  + "' is not because it contains an odd number of segments.");
         }
-        DocumentKey key = DocumentKey.fromPath(query.getPath().append(documentId));
+        DocumentKey key = DocumentKey.fromPath(path);
         components.add(ReferenceValue.valueOf(firestore.getDatabaseId(), key));
       } else {
         FieldValue wrapped = firestore.getDataConverter().parseQueryValue(rawValue);
@@ -874,30 +892,37 @@ public ListenerRegistration addSnapshotListener(
    * @param executor The executor to use to call the listener.
    * @param options The options to use for this listen.
    * @param activity Optional activity this listener is scoped to.
-   * @param listener The event listener that will be called with the snapshots.
+   * @param userListener The user-supplied event listener that will be called with the snapshots.
    * @return A registration object that can be used to remove the listener.
    */
   private ListenerRegistration addSnapshotListenerInternal(
       Executor executor,
       ListenOptions options,
       @Nullable Activity activity,
-      EventListener<QuerySnapshot> listener) {
-    ExecutorEventListener<ViewSnapshot> wrappedListener =
-        new ExecutorEventListener<>(
-            executor,
-            (@Nullable ViewSnapshot snapshot, @Nullable FirebaseFirestoreException error) -> {
-              if (snapshot != null) {
-                QuerySnapshot querySnapshot = new QuerySnapshot(this, snapshot, firestore);
-                listener.onEvent(querySnapshot, null);
-              } else {
-                hardAssert(error != null, "Got event without value or error set");
-                listener.onEvent(null, error);
-              }
-            });
-
-    QueryListener queryListener = firestore.getClient().listen(query, options, wrappedListener);
-    return new ListenerRegistrationImpl(
-        firestore.getClient(), queryListener, activity, wrappedListener);
+      EventListener<QuerySnapshot> userListener) {
+
+    // Convert from ViewSnapshots to QuerySnapshots.
+    EventListener<ViewSnapshot> viewListener =
+        (@Nullable ViewSnapshot snapshot, @Nullable FirebaseFirestoreException error) -> {
+          if (error != null) {
+            userListener.onEvent(null, error);
+            return;
+          }
+
+          hardAssert(snapshot != null, "Got event without value or error set");
+
+          QuerySnapshot querySnapshot = new QuerySnapshot(this, snapshot, firestore);
+          userListener.onEvent(querySnapshot, null);
+        };
+
+    // Call the viewListener on the userExecutor.
+    AsyncEventListener<ViewSnapshot> asyncListener =
+        new AsyncEventListener<>(executor, viewListener);
+
+    QueryListener queryListener = firestore.getClient().listen(query, options, asyncListener);
+    return ActivityScope.bind(
+        activity,
+        new ListenerRegistrationImpl(firestore.getClient(), queryListener, asyncListener));
   }
 
   @Override
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
index 2b65f613d..fbb841d52 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/QuerySnapshot.java
@@ -116,7 +116,7 @@ public SnapshotMetadata getMetadata() {
    */
   @NonNull
   @PublicApi
-  public List<DocumentChange> getDocumentChanges(MetadataChanges metadataChanges) {
+  public List<DocumentChange> getDocumentChanges(@NonNull MetadataChanges metadataChanges) {
     if (MetadataChanges.INCLUDE.equals(metadataChanges) && snapshot.excludesMetadataChanges()) {
       throw new IllegalArgumentException(
           "To include metadata changes with your document changes, you must also pass MetadataChanges.INCLUDE to addSnapshotListener().");
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
index adde45259..273c6b056 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/SetOptions.java
@@ -18,6 +18,7 @@
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RestrictTo;
 import com.google.firebase.annotations.PublicApi;
 import com.google.firebase.firestore.model.mutation.FieldMask;
 import java.util.HashSet;
@@ -46,12 +47,13 @@ private SetOptions(boolean merge, @Nullable FieldMask fieldMask) {
   }
 
   /** @hide */
-  public boolean isMerge() {
+  boolean isMerge() {
     return merge;
   }
 
   /** @hide */
   @Nullable
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public FieldMask getFieldMask() {
     return fieldMask;
   }
@@ -78,7 +80,7 @@ public static SetOptions merge() {
    */
   @NonNull
   @PublicApi
-  public static SetOptions mergeFields(List<String> fields) {
+  public static SetOptions mergeFields(@NonNull List<String> fields) {
     Set<com.google.firebase.firestore.model.FieldPath> fieldPaths = new HashSet<>();
 
     for (String field : fields) {
@@ -121,7 +123,7 @@ public static SetOptions mergeFields(String... fields) {
    */
   @NonNull
   @PublicApi
-  public static SetOptions mergeFieldPaths(List<FieldPath> fields) {
+  public static SetOptions mergeFieldPaths(@NonNull List<FieldPath> fields) {
     Set<com.google.firebase.firestore.model.FieldPath> fieldPaths = new HashSet<>();
 
     for (FieldPath field : fields) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
index 898a189fa..15726d97d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/UserDataConverter.java
@@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
+import android.support.annotation.RestrictTo;
 import com.google.firebase.Timestamp;
 import com.google.firebase.firestore.FieldValue.ArrayRemoveFieldValue;
 import com.google.firebase.firestore.FieldValue.ArrayUnionFieldValue;
@@ -31,6 +32,7 @@
 import com.google.firebase.firestore.model.FieldPath;
 import com.google.firebase.firestore.model.mutation.ArrayTransformOperation;
 import com.google.firebase.firestore.model.mutation.FieldMask;
+import com.google.firebase.firestore.model.mutation.NumericIncrementTransformOperation;
 import com.google.firebase.firestore.model.mutation.ServerTimestampOperation;
 import com.google.firebase.firestore.model.value.ArrayValue;
 import com.google.firebase.firestore.model.value.BlobValue;
@@ -40,6 +42,7 @@
 import com.google.firebase.firestore.model.value.GeoPointValue;
 import com.google.firebase.firestore.model.value.IntegerValue;
 import com.google.firebase.firestore.model.value.NullValue;
+import com.google.firebase.firestore.model.value.NumberValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.model.value.ReferenceValue;
 import com.google.firebase.firestore.model.value.StringValue;
@@ -61,6 +64,7 @@
  *
  * @hide
  */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public final class UserDataConverter {
 
   private final DatabaseId databaseId;
@@ -349,6 +353,16 @@ private void parseSentinelFieldValue(
       ArrayTransformOperation arrayRemove = new ArrayTransformOperation.Remove(parsedElements);
       context.addToFieldTransforms(context.getPath(), arrayRemove);
 
+    } else if (value
+        instanceof com.google.firebase.firestore.FieldValue.NumericIncrementFieldValue) {
+      com.google.firebase.firestore.FieldValue.NumericIncrementFieldValue
+          numericIncrementFieldValue =
+              (com.google.firebase.firestore.FieldValue.NumericIncrementFieldValue) value;
+      NumberValue operand = (NumberValue) parseQueryValue(numericIncrementFieldValue.getOperand());
+      NumericIncrementTransformOperation incrementOperation =
+          new NumericIncrementTransformOperation(operand);
+      context.addToFieldTransforms(context.getPath(), incrementOperation);
+
     } else {
       throw Assert.fail("Unknown FieldValue type: %s", Util.typeName(value));
     }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
index ec0fdd23c..21e368ef8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/WriteBatch.java
@@ -212,4 +212,15 @@ private void verifyNotCommitted() {
           "A write batch can no longer be used after commit() has been called.");
     }
   }
+
+  /**
+   * An interface for providing code to be executed within a {@link WriteBatch} context.
+   *
+   * @see FirebaseFirestore#runBatch(WriteBatch.Function)
+   */
+  @PublicApi
+  public interface Function {
+    @PublicApi
+    void apply(@NonNull WriteBatch batch);
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
index ce0a729eb..b7f9539ac 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/auth/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.auth;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ListenerRegistrationImpl.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
similarity index 81%
rename from firebase-firestore/src/main/java/com/google/firebase/firestore/util/ListenerRegistrationImpl.java
rename to firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
index d42e41a29..37633325c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ListenerRegistrationImpl.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ActivityScope.java
@@ -12,22 +12,19 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package com.google.firebase.firestore.util;
+package com.google.firebase.firestore.core;
 
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import android.app.Activity;
 import android.support.v4.app.FragmentActivity;
 import com.google.firebase.firestore.ListenerRegistration;
-import com.google.firebase.firestore.core.FirestoreClient;
-import com.google.firebase.firestore.core.QueryListener;
-import com.google.firebase.firestore.core.ViewSnapshot;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
 
 /**
- * Implements the ListenerRegistration interface by removing a query from the listener.
+ * Scopes the lifetime of a ListenerRegistration to an Activity.
  *
  * <p>Regarding activity-scoped listeners, Android provides lifecycle callbacks (eg onStop()) that
  * custom `Activity`s can implement via subclassing. But we can't take advantage of that, since we
@@ -48,17 +45,9 @@
  *       for lifecycle callbacks instead of creating/attaching a Fragment.
  * </ol>
  */
-public class ListenerRegistrationImpl implements ListenerRegistration {
+public class ActivityScope {
 
-  private final FirestoreClient client;
-
-  /** The internal query listener object that is used to unlisten from the query. */
-  private final QueryListener queryListener;
-
-  /** The event listener for the query that raises events asynchronously. */
-  private final ExecutorEventListener<ViewSnapshot> asyncEventListener;
-
-  static class CallbackList {
+  private static class CallbackList {
     void run() {
       for (Runnable callback : callbacks) {
         if (callback != null) {
@@ -142,7 +131,7 @@ public void onStop() {
    * everything in this function is deprecated.
    */
   @SuppressWarnings("deprecation")
-  private void onActivityStopCallOnce(Activity activity, Runnable callback) {
+  private static void onActivityStopCallOnce(Activity activity, Runnable callback) {
     hardAssert(
         !(activity instanceof FragmentActivity),
         "onActivityStopCallOnce must be called with a *non*-FragmentActivity Activity.");
@@ -170,7 +159,7 @@ private void onActivityStopCallOnce(Activity activity, Runnable callback) {
         });
   }
 
-  private void onFragmentActivityStopCallOnce(FragmentActivity activity, Runnable callback) {
+  private static void onFragmentActivityStopCallOnce(FragmentActivity activity, Runnable callback) {
     activity.runOnUiThread(
         () -> {
           StopListenerSupportFragment fragment =
@@ -194,28 +183,16 @@ private void onFragmentActivityStopCallOnce(FragmentActivity activity, Runnable
         });
   }
 
-  /** Creates a new ListenerRegistration. Is activity-scoped if and only if activity is non-null. */
-  public ListenerRegistrationImpl(
-      FirestoreClient client,
-      QueryListener queryListener,
-      @Nullable Activity activity,
-      ExecutorEventListener<ViewSnapshot> asyncEventListener) {
-    this.client = client;
-    this.queryListener = queryListener;
-    this.asyncEventListener = asyncEventListener;
-
+  /** Binds the given registration to the lifetime of the activity. */
+  public static ListenerRegistration bind(
+      @Nullable Activity activity, ListenerRegistration registration) {
     if (activity != null) {
       if (activity instanceof FragmentActivity) {
-        onFragmentActivityStopCallOnce((FragmentActivity) activity, this::remove);
+        onFragmentActivityStopCallOnce((FragmentActivity) activity, registration::remove);
       } else {
-        onActivityStopCallOnce(activity, this::remove);
+        onActivityStopCallOnce(activity, registration::remove);
       }
     }
-  }
-
-  @Override
-  public void remove() {
-    asyncEventListener.mute();
-    client.stopListening(queryListener);
+    return registration;
   }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExecutorEventListener.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
similarity index 88%
rename from firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExecutorEventListener.java
rename to firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
index 7a18a7c8b..536e075d6 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/ExecutorEventListener.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/AsyncEventListener.java
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package com.google.firebase.firestore.util;
+package com.google.firebase.firestore.core;
 
 import com.google.firebase.firestore.EventListener;
 import com.google.firebase.firestore.FirebaseFirestoreException;
@@ -23,13 +23,13 @@
  * A wrapper event listener that uses an Executor to dispatch events. Exposes a mute() call to
  * immediately silence the event listener when events are dispatched on different threads.
  */
-public class ExecutorEventListener<T> implements EventListener<T> {
+public class AsyncEventListener<T> implements EventListener<T> {
   private final Executor executor;
   private final EventListener<T> eventListener;
 
   private volatile boolean muted = false;
 
-  public ExecutorEventListener(Executor executor, EventListener<T> eventListener) {
+  public AsyncEventListener(Executor executor, EventListener<T> eventListener) {
     this.executor = executor;
     this.eventListener = eventListener;
   }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ListenerRegistrationImpl.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ListenerRegistrationImpl.java
new file mode 100644
index 000000000..b94931996
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/ListenerRegistrationImpl.java
@@ -0,0 +1,44 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.core;
+
+import com.google.firebase.firestore.ListenerRegistration;
+
+/** Implements the ListenerRegistration interface by removing a query from the listener. */
+public class ListenerRegistrationImpl implements ListenerRegistration {
+
+  private final FirestoreClient client;
+
+  /** The internal query listener object that is used to unlisten from the query. */
+  private final QueryListener queryListener;
+
+  /** The event listener for the query that raises events asynchronously. */
+  private final AsyncEventListener<ViewSnapshot> asyncEventListener;
+
+  public ListenerRegistrationImpl(
+      FirestoreClient client,
+      QueryListener queryListener,
+      AsyncEventListener<ViewSnapshot> asyncEventListener) {
+    this.client = client;
+    this.queryListener = queryListener;
+    this.asyncEventListener = asyncEventListener;
+  }
+
+  @Override
+  public void remove() {
+    asyncEventListener.mute();
+    client.stopListening(queryListener);
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
index 41b542bad..9dac58d9c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/Query.java
@@ -41,7 +41,7 @@
    * @return A new instance of the Query.
    */
   public static Query atPath(ResourcePath path) {
-    return new Query(path, Collections.emptyList(), Collections.emptyList(), NO_LIMIT, null, null);
+    return new Query(path, /*collectionGroup=*/ null);
   }
 
   private static final OrderBy KEY_ORDERING_ASC =
@@ -57,6 +57,8 @@ public static Query atPath(ResourcePath path) {
 
   private final ResourcePath path;
 
+  private final @Nullable String collectionGroup;
+
   private final long limit;
 
   private final @Nullable Bound startAt;
@@ -65,12 +67,14 @@ public static Query atPath(ResourcePath path) {
   /** Initializes a Query with all of its components directly. */
   public Query(
       ResourcePath path,
+      @Nullable String collectionGroup,
       List<Filter> filters,
       List<OrderBy> explicitSortOrder,
       long limit,
       @Nullable Bound startAt,
       @Nullable Bound endAt) {
     this.path = path;
+    this.collectionGroup = collectionGroup;
     this.explicitSortOrder = explicitSortOrder;
     this.filters = filters;
     this.limit = limit;
@@ -78,14 +82,39 @@ public Query(
     this.endAt = endAt;
   }
 
+  /**
+   * Initializes a Query with a path and (optional) collectionGroup. Path must currently be empty in
+   * the case of a collection group query.
+   */
+  public Query(ResourcePath path, @Nullable String collectionGroup) {
+    this(
+        path,
+        collectionGroup,
+        Collections.emptyList(),
+        Collections.emptyList(),
+        NO_LIMIT,
+        null,
+        null);
+  }
+
   /** The base path of the query. */
   public ResourcePath getPath() {
     return path;
   }
 
+  /** An optional collection group within which to query. */
+  public @Nullable String getCollectionGroup() {
+    return collectionGroup;
+  }
+
   /** Returns true if this Query is for a specific document. */
   public boolean isDocumentQuery() {
-    return DocumentKey.isDocumentKey(path) && filters.isEmpty();
+    return DocumentKey.isDocumentKey(path) && collectionGroup == null && filters.isEmpty();
+  }
+
+  /** Returns true if this is a collection group query. */
+  public boolean isCollectionGroupQuery() {
+    return collectionGroup != null;
   }
 
   /** The filters on the documents returned by the query. */
@@ -157,8 +186,7 @@ public boolean hasArrayContainsFilter() {
    * @return the new Query.
    */
   public Query filter(Filter filter) {
-    Assert.hardAssert(!DocumentKey.isDocumentKey(path), "No filter is allowed for document query");
-
+    hardAssert(!isDocumentQuery(), "No filter is allowed for document query");
     FieldPath newInequalityField = null;
     if (filter instanceof RelationFilter && ((RelationFilter) filter).isInequality()) {
       newInequalityField = filter.getField();
@@ -179,7 +207,8 @@ public Query filter(Filter filter) {
 
     List<Filter> updatedFilter = new ArrayList<>(filters);
     updatedFilter.add(filter);
-    return new Query(path, updatedFilter, explicitSortOrder, limit, startAt, endAt);
+    return new Query(
+        path, collectionGroup, updatedFilter, explicitSortOrder, limit, startAt, endAt);
   }
 
   /**
@@ -189,9 +218,7 @@ public Query filter(Filter filter) {
    * @return the new Query.
    */
   public Query orderBy(OrderBy order) {
-    if (DocumentKey.isDocumentKey(path)) {
-      throw Assert.fail("No ordering is allowed for document query");
-    }
+    hardAssert(!isDocumentQuery(), "No ordering is allowed for document query");
     if (explicitSortOrder.isEmpty()) {
       FieldPath inequality = inequalityField();
       if (inequality != null && !inequality.equals(order.field)) {
@@ -200,7 +227,7 @@ public Query orderBy(OrderBy order) {
     }
     List<OrderBy> updatedSortOrder = new ArrayList<>(explicitSortOrder);
     updatedSortOrder.add(order);
-    return new Query(path, filters, updatedSortOrder, limit, startAt, endAt);
+    return new Query(path, collectionGroup, filters, updatedSortOrder, limit, startAt, endAt);
   }
 
   /**
@@ -210,7 +237,7 @@ public Query orderBy(OrderBy order) {
    *     limit is applied. Otherwise, if {@code limit <= 0}, behavior is unspecified.
    */
   public Query limit(long limit) {
-    return new Query(path, filters, explicitSortOrder, limit, startAt, endAt);
+    return new Query(path, collectionGroup, filters, explicitSortOrder, limit, startAt, endAt);
   }
 
   /**
@@ -220,7 +247,7 @@ public Query limit(long limit) {
    * @return the new Query.
    */
   public Query startAt(Bound bound) {
-    return new Query(path, filters, explicitSortOrder, limit, bound, endAt);
+    return new Query(path, collectionGroup, filters, explicitSortOrder, limit, bound, endAt);
   }
 
   /**
@@ -230,7 +257,17 @@ public Query startAt(Bound bound) {
    * @return the new Query.
    */
   public Query endAt(Bound bound) {
-    return new Query(path, filters, explicitSortOrder, limit, startAt, bound);
+    return new Query(path, collectionGroup, filters, explicitSortOrder, limit, startAt, bound);
+  }
+
+  /**
+   * Helper to convert a collection group query into a collection query at a specific path. This is
+   * used when executing collection group queries, since we have to split the query into a set of
+   * collection queries at multiple paths.
+   */
+  public Query asCollectionQueryAtPath(ResourcePath path) {
+    return new Query(
+        path, /*collectionGroup=*/ null, filters, explicitSortOrder, limit, startAt, endAt);
   }
 
   /**
@@ -288,9 +325,13 @@ public Query endAt(Bound bound) {
     return memoizedOrderBy;
   }
 
-  private boolean matchesPath(Document doc) {
+  private boolean matchesPathAndCollectionGroup(Document doc) {
     ResourcePath docPath = doc.getKey().getPath();
-    if (DocumentKey.isDocumentKey(path)) {
+    if (collectionGroup != null) {
+      // NOTE: this.path is currently always empty since we don't expose Collection
+      // Group queries rooted at a document path yet.
+      return doc.getKey().hasCollectionId(collectionGroup) && path.isPrefixOf(docPath);
+    } else if (DocumentKey.isDocumentKey(path)) {
       return path.equals(docPath);
     } else {
       return path.isPrefixOf(docPath) && path.length() == docPath.length() - 1;
@@ -330,7 +371,10 @@ private boolean matchesBounds(Document doc) {
 
   /** Returns true if the document matches the constraints of this query. */
   public boolean matches(Document doc) {
-    return matchesPath(doc) && matchesOrderBy(doc) && matchesFilters(doc) && matchesBounds(doc);
+    return matchesPathAndCollectionGroup(doc)
+        && matchesOrderBy(doc)
+        && matchesFilters(doc)
+        && matchesBounds(doc);
   }
 
   /** Returns a comparator that will sort documents according to this Query's sort order. */
@@ -373,6 +417,11 @@ public String getCanonicalId() {
     StringBuilder builder = new StringBuilder();
     builder.append(getPath().canonicalString());
 
+    if (collectionGroup != null) {
+      builder.append("|cg:");
+      builder.append(collectionGroup);
+    }
+
     // Add filters.
     builder.append("|f:");
     for (Filter filter : getFilters()) {
@@ -416,6 +465,11 @@ public boolean equals(Object o) {
 
     Query query = (Query) o;
 
+    if (collectionGroup != null
+        ? !collectionGroup.equals(query.collectionGroup)
+        : query.collectionGroup != null) {
+      return false;
+    }
     if (limit != query.limit) {
       return false;
     }
@@ -437,6 +491,7 @@ public boolean equals(Object o) {
   @Override
   public int hashCode() {
     int result = getOrderBy().hashCode();
+    result = 31 * result + (collectionGroup != null ? collectionGroup.hashCode() : 0);
     result = 31 * result + filters.hashCode();
     result = 31 * result + path.hashCode();
     result = 31 * result + (int) (limit ^ (limit >>> 32));
@@ -450,6 +505,10 @@ public String toString() {
     StringBuilder builder = new StringBuilder();
     builder.append("Query(");
     builder.append(path.canonicalString());
+    if (collectionGroup != null) {
+      builder.append(" collectionGroup=");
+      builder.append(collectionGroup);
+    }
     if (!filters.isEmpty()) {
       builder.append(" where ");
       for (int i = 0; i < filters.size(); i++) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
index 35353f691..5964e75c0 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/core/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.core;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexManager.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexManager.java
new file mode 100644
index 000000000..b4b8b3558
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/IndexManager.java
@@ -0,0 +1,42 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import com.google.firebase.firestore.model.ResourcePath;
+import java.util.List;
+
+/**
+ * Represents a set of indexes that are used to execute queries efficiently.
+ *
+ * <p>Currently the only index is a [collection id] => [parent path] index, used to execute
+ * Collection Group queries.
+ */
+public interface IndexManager {
+  /**
+   * Creates an index entry mapping the collectionId (last segment of the path) to the parent path
+   * (either the containing document location or the empty path for root-level collections). Index
+   * entries can be retrieved via getCollectionParents().
+   *
+   * <p>NOTE: Currently we don't remove index entries. If this ends up being an issue we can devise
+   * some sort of GC strategy.
+   */
+  void addToCollectionParentIndex(ResourcePath collectionPath);
+
+  /**
+   * Retrieves all parent locations containing the given collectionId, as a set of paths (each path
+   * being either a document location or the empty path for a root-level collection).
+   */
+  List<ResourcePath> getCollectionParents(String collectionId);
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
index 8db4d4b1a..e718129e5 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalDocumentsView.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.model.DocumentCollections.emptyDocumentMap;
 import static com.google.firebase.firestore.model.DocumentCollections.emptyMaybeDocumentMap;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
@@ -41,10 +42,15 @@
 
   private final RemoteDocumentCache remoteDocumentCache;
   private final MutationQueue mutationQueue;
+  private final IndexManager indexManager;
 
-  LocalDocumentsView(RemoteDocumentCache remoteDocumentCache, MutationQueue mutationQueue) {
+  LocalDocumentsView(
+      RemoteDocumentCache remoteDocumentCache,
+      MutationQueue mutationQueue,
+      IndexManager indexManager) {
     this.remoteDocumentCache = remoteDocumentCache;
     this.mutationQueue = mutationQueue;
+    this.indexManager = indexManager;
   }
 
   /**
@@ -126,8 +132,10 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
   /** Performs a query against the local view of all documents. */
   ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingQuery(Query query) {
     ResourcePath path = query.getPath();
-    if (DocumentKey.isDocumentKey(path)) {
+    if (query.isDocumentQuery()) {
       return getDocumentsMatchingDocumentQuery(path);
+    } else if (query.isCollectionGroupQuery()) {
+      return getDocumentsMatchingCollectionGroupQuery(query);
     } else {
       return getDocumentsMatchingCollectionQuery(query);
     }
@@ -145,6 +153,28 @@ private MaybeDocument getDocument(DocumentKey key, List<MutationBatch> inBatches
     return result;
   }
 
+  private ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingCollectionGroupQuery(
+      Query query) {
+    hardAssert(
+        query.getPath().isEmpty(),
+        "Currently we only support collection group queries at the root.");
+    String collectionId = query.getCollectionGroup();
+    ImmutableSortedMap<DocumentKey, Document> results = emptyDocumentMap();
+    List<ResourcePath> parents = indexManager.getCollectionParents(collectionId);
+
+    // Perform a collection query against each parent that contains the collectionId and
+    // aggregate the results.
+    for (ResourcePath parent : parents) {
+      Query collectionQuery = query.asCollectionQueryAtPath(parent.append(collectionId));
+      ImmutableSortedMap<DocumentKey, Document> collectionResults =
+          getDocumentsMatchingCollectionQuery(collectionQuery);
+      for (Map.Entry<DocumentKey, Document> docEntry : collectionResults) {
+        results = results.insert(docEntry.getKey(), docEntry.getValue());
+      }
+    }
+    return results;
+  }
+
   /** Queries the remote documents and overlays mutations. */
   private ImmutableSortedMap<DocumentKey, Document> getDocumentsMatchingCollectionQuery(
       Query query) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
index 77880f007..5a07249ac 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalSerializer.java
@@ -165,6 +165,9 @@ private UnknownDocument decodeUnknownDocument(
 
     result.setBatchId(batch.getBatchId());
     result.setLocalWriteTime(rpcSerializer.encodeTimestamp(batch.getLocalWriteTime()));
+    for (Mutation mutation : batch.getBaseMutations()) {
+      result.addBaseWrites(rpcSerializer.encodeMutation(mutation));
+    }
     for (Mutation mutation : batch.getMutations()) {
       result.addWrites(rpcSerializer.encodeMutation(mutation));
     }
@@ -176,13 +179,17 @@ MutationBatch decodeMutationBatch(com.google.firebase.firestore.proto.WriteBatch
     int batchId = batch.getBatchId();
     Timestamp localWriteTime = rpcSerializer.decodeTimestamp(batch.getLocalWriteTime());
 
-    int count = batch.getWritesCount();
-    List<Mutation> mutations = new ArrayList<>(count);
-    for (int i = 0; i < count; i++) {
+    int baseMutationsCount = batch.getBaseWritesCount();
+    List<Mutation> baseMutations = new ArrayList<>(baseMutationsCount);
+    for (int i = 0; i < baseMutationsCount; i++) {
+      baseMutations.add(rpcSerializer.decodeMutation(batch.getBaseWrites(i)));
+    }
+    int mutationsCount = batch.getWritesCount();
+    List<Mutation> mutations = new ArrayList<>(mutationsCount);
+    for (int i = 0; i < mutationsCount; i++) {
       mutations.add(rpcSerializer.decodeMutation(batch.getWrites(i)));
     }
-
-    return new MutationBatch(batchId, localWriteTime, mutations);
+    return new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
   }
 
   com.google.firebase.firestore.proto.Target encodeQueryData(QueryData queryData) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
index dae56aafe..8406483bb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/LocalStore.java
@@ -28,13 +28,18 @@
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
+import com.google.firebase.firestore.model.mutation.FieldMask;
 import com.google.firebase.firestore.model.mutation.Mutation;
 import com.google.firebase.firestore.model.mutation.MutationBatch;
 import com.google.firebase.firestore.model.mutation.MutationBatchResult;
+import com.google.firebase.firestore.model.mutation.PatchMutation;
+import com.google.firebase.firestore.model.mutation.Precondition;
+import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.remote.RemoteEvent;
 import com.google.firebase.firestore.remote.TargetChange;
 import com.google.firebase.firestore.util.Logger;
 import com.google.protobuf.ByteString;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -128,7 +133,8 @@ public LocalStore(Persistence persistence, User initialUser) {
     targetIdGenerator = TargetIdGenerator.forQueryCache(queryCache.getHighestTargetId());
     mutationQueue = persistence.getMutationQueue(initialUser);
     remoteDocuments = persistence.getRemoteDocumentCache();
-    localDocuments = new LocalDocumentsView(remoteDocuments, mutationQueue);
+    localDocuments =
+        new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
     // TODO: Use IndexedQueryEngine as appropriate.
     queryEngine = new SimpleQueryEngine(localDocuments);
 
@@ -162,7 +168,8 @@ private void startMutationQueue() {
     List<MutationBatch> newBatches = mutationQueue.getAllMutationBatches();
 
     // Recreate our LocalDocumentsView using the new MutationQueue.
-    localDocuments = new LocalDocumentsView(remoteDocuments, mutationQueue);
+    localDocuments =
+        new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
     // TODO: Use IndexedQueryEngine as appropriate.
     queryEngine = new SimpleQueryEngine(localDocuments);
 
@@ -183,16 +190,55 @@ private void startMutationQueue() {
   /** Accepts locally generated Mutations and commits them to storage. */
   public LocalWriteResult writeLocally(List<Mutation> mutations) {
     Timestamp localWriteTime = Timestamp.now();
+
     // TODO: Call queryEngine.handleDocumentChange() appropriately.
-    MutationBatch batch =
-        persistence.runTransaction(
-            "Locally write mutations",
-            () -> mutationQueue.addMutationBatch(localWriteTime, mutations));
-
-    Set<DocumentKey> keys = batch.getKeys();
-    ImmutableSortedMap<DocumentKey, MaybeDocument> changedDocuments =
-        localDocuments.getDocuments(keys);
-    return new LocalWriteResult(batch.getBatchId(), changedDocuments);
+
+    Set<DocumentKey> keys = new HashSet<>();
+    for (Mutation mutation : mutations) {
+      keys.add(mutation.getKey());
+    }
+
+    return persistence.runTransaction(
+        "Locally write mutations",
+        () -> {
+          // Load and apply all existing mutations. This lets us compute the current base state for
+          // all non-idempotent transforms before applying any additional user-provided writes.
+          ImmutableSortedMap<DocumentKey, MaybeDocument> existingDocuments =
+              localDocuments.getDocuments(keys);
+
+          // For non-idempotent mutations (such as `FieldValue.increment()`), we record the base
+          // state in a separate patch mutation. This is later used to guarantee consistent values
+          // and prevents flicker even if the backend sends us an update that already includes our
+          // transform.
+          List<Mutation> baseMutations = new ArrayList<>();
+          for (Mutation mutation : mutations) {
+            MaybeDocument maybeDocument = existingDocuments.get(mutation.getKey());
+            if (!mutation.isIdempotent()) {
+              // Theoretically, we should only include non-idempotent fields in this field mask as
+              // this mask is used to populate the base state for all DocumentTransforms.  By
+              // including all fields, we incorrectly prevent rebasing of idempotent transforms
+              // (such as `arrayUnion()`) when any non-idempotent transforms are present.
+              FieldMask fieldMask = mutation.getFieldMask();
+              if (fieldMask != null) {
+                ObjectValue baseValues =
+                    (maybeDocument instanceof Document)
+                        ? fieldMask.applyTo(((Document) maybeDocument).getData())
+                        : ObjectValue.emptyObject();
+                // NOTE: The base state should only be applied if there's some existing
+                // document to override, so use a Precondition of exists=true
+                baseMutations.add(
+                    new PatchMutation(
+                        mutation.getKey(), baseValues, fieldMask, Precondition.exists(true)));
+              }
+            }
+          }
+
+          MutationBatch batch =
+              mutationQueue.addMutationBatch(localWriteTime, baseMutations, mutations);
+          ImmutableSortedMap<DocumentKey, MaybeDocument> changedDocuments =
+              batch.applyToLocalDocumentSet(existingDocuments);
+          return new LocalWriteResult(batch.getBatchId(), changedDocuments);
+        });
   }
 
   /**
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryIndexManager.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryIndexManager.java
new file mode 100644
index 000000000..3c4e7a8be
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryIndexManager.java
@@ -0,0 +1,66 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+package com.google.firebase.firestore.local;
+
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import com.google.firebase.firestore.model.ResourcePath;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+
+/** An in-memory implementation of IndexManager. */
+class MemoryIndexManager implements IndexManager {
+  private final MemoryCollectionParentIndex collectionParentsIndex =
+      new MemoryCollectionParentIndex();
+
+  @Override
+  public void addToCollectionParentIndex(ResourcePath collectionPath) {
+    collectionParentsIndex.add(collectionPath);
+  }
+
+  @Override
+  public List<ResourcePath> getCollectionParents(String collectionId) {
+    return collectionParentsIndex.getEntries(collectionId);
+  }
+
+  /**
+   * Internal implementation of the collection-parent index. Also used for in-memory caching by
+   * SQLiteIndexManager and initial index population in SQLiteSchema.
+   */
+  static class MemoryCollectionParentIndex {
+    private final HashMap<String, HashSet<ResourcePath>> index = new HashMap<>();
+
+    // Returns false if the entry already existed.
+    boolean add(ResourcePath collectionPath) {
+      hardAssert(collectionPath.length() % 2 == 1, "Expected a collection path.");
+
+      String collectionId = collectionPath.getLastSegment();
+      ResourcePath parentPath = collectionPath.popLast();
+      HashSet<ResourcePath> existingParents = index.get(collectionId);
+      if (existingParents == null) {
+        existingParents = new HashSet<>();
+        index.put(collectionId, existingParents);
+      }
+      return existingParents.add(parentPath);
+    }
+
+    List<ResourcePath> getEntries(String collectionId) {
+      HashSet<ResourcePath> existingParents = index.get(collectionId);
+      return existingParents != null ? new ArrayList<>(existingParents) : Collections.emptyList();
+    }
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
index f4b549a08..82f734467 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryMutationQueue.java
@@ -127,7 +127,8 @@ public void setLastStreamToken(ByteString streamToken) {
   }
 
   @Override
-  public MutationBatch addMutationBatch(Timestamp localWriteTime, List<Mutation> mutations) {
+  public MutationBatch addMutationBatch(
+      Timestamp localWriteTime, List<Mutation> baseMutations, List<Mutation> mutations) {
     hardAssert(!mutations.isEmpty(), "Mutation batches should not be empty");
 
     int batchId = nextBatchId;
@@ -140,13 +141,17 @@ public MutationBatch addMutationBatch(Timestamp localWriteTime, List<Mutation> m
           prior.getBatchId() < batchId, "Mutation batchIds must be monotonically increasing order");
     }
 
-    MutationBatch batch = new MutationBatch(batchId, localWriteTime, mutations);
+    MutationBatch batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
     queue.add(batch);
 
-    // Track references by document key.
+    // Track references by document key and index collection parents.
     for (Mutation mutation : mutations) {
       batchesByDocumentKey =
           batchesByDocumentKey.insert(new DocumentReference(mutation.getKey(), batchId));
+
+      persistence
+          .getIndexManager()
+          .addToCollectionParentIndex(mutation.getKey().getPath().popLast());
     }
 
     return batch;
@@ -224,6 +229,10 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
 
   @Override
   public List<MutationBatch> getAllMutationBatchesAffectingQuery(Query query) {
+    hardAssert(
+        !query.isCollectionGroupQuery(),
+        "CollectionGroup queries should be handled in LocalDocumentsView");
+
     // Use the query path as a prefix for testing if a document matches the query.
     ResourcePath prefix = query.getPath();
     int immediateChildrenPathLength = prefix.length() + 1;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
index 0f7698c4f..f43a3a71a 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryPersistence.java
@@ -32,6 +32,7 @@
   // LocalStore wrapping this Persistence instance and this will make the in-memory persistence
   // layer behave as if it were actually persisting values.
   private final Map<User, MemoryMutationQueue> mutationQueues;
+  private final MemoryIndexManager indexManager;
   private final MemoryQueryCache queryCache;
   private final MemoryRemoteDocumentCache remoteDocumentCache;
   private ReferenceDelegate referenceDelegate;
@@ -55,8 +56,9 @@ public static MemoryPersistence createLruGcMemoryPersistence(
   /** Use static helpers to instantiate */
   private MemoryPersistence() {
     mutationQueues = new HashMap<>();
+    indexManager = new MemoryIndexManager();
     queryCache = new MemoryQueryCache(this);
-    remoteDocumentCache = new MemoryRemoteDocumentCache();
+    remoteDocumentCache = new MemoryRemoteDocumentCache(this);
   }
 
   @Override
@@ -111,6 +113,11 @@ MemoryRemoteDocumentCache getRemoteDocumentCache() {
     return remoteDocumentCache;
   }
 
+  @Override
+  IndexManager getIndexManager() {
+    return indexManager;
+  }
+
   @Override
   void runTransaction(String action, Runnable operation) {
     referenceDelegate.onTransactionStarted();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
index 9bed5c2dd..4bdf0b6dc 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MemoryRemoteDocumentCache.java
@@ -16,6 +16,7 @@
 
 import static com.google.firebase.firestore.model.DocumentCollections.emptyDocumentMap;
 import static com.google.firebase.firestore.model.DocumentCollections.emptyMaybeDocumentMap;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
@@ -34,13 +35,18 @@
   /** Underlying cache of documents. */
   private ImmutableSortedMap<DocumentKey, MaybeDocument> docs;
 
-  MemoryRemoteDocumentCache() {
+  private final MemoryPersistence persistence;
+
+  MemoryRemoteDocumentCache(MemoryPersistence persistence) {
     docs = emptyMaybeDocumentMap();
+    this.persistence = persistence;
   }
 
   @Override
   public void add(MaybeDocument document) {
     docs = docs.insert(document.getKey(), document);
+
+    persistence.getIndexManager().addToCollectionParentIndex(document.getKey().getPath().popLast());
   }
 
   @Override
@@ -69,6 +75,9 @@ public MaybeDocument get(DocumentKey key) {
 
   @Override
   public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(Query query) {
+    hardAssert(
+        !query.isCollectionGroupQuery(),
+        "CollectionGroup queries should be handled in LocalDocumentsView");
     ImmutableSortedMap<DocumentKey, Document> result = emptyDocumentMap();
 
     // Documents are ordered by key, so we can use a prefix scan to narrow down the documents
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
index c9fbbcdeb..0dbab22b1 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/MutationQueue.java
@@ -43,8 +43,17 @@
   /** Sets the stream token for this mutation queue. */
   void setLastStreamToken(ByteString streamToken);
 
-  /** Creates a new mutation batch and adds it to this mutation queue. */
-  MutationBatch addMutationBatch(Timestamp localWriteTime, List<Mutation> mutations);
+  /**
+   * Creates a new mutation batch and adds it to this mutation queue.
+   *
+   * @param localWriteTime The original write time of this mutation.
+   * @param baseMutations Mutations that are used to populate the base values when this mutation is
+   *     applied locally. These mutations are used to locally overwrite values that are persisted in
+   *     the remote document cache.
+   * @param mutations The user-provided mutations in this mutation batch.
+   */
+  MutationBatch addMutationBatch(
+      Timestamp localWriteTime, List<Mutation> baseMutations, List<Mutation> mutations);
 
   /** Loads the mutation batch with the given batchId. */
   @Nullable
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/Persistence.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/Persistence.java
index aeb994700..32266253c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/Persistence.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/Persistence.java
@@ -86,6 +86,9 @@
   /** Creates a RemoteDocumentCache representing the persisted cache of remote documents. */
   abstract RemoteDocumentCache getRemoteDocumentCache();
 
+  /** Creates an IndexManager that manages our persisted query indexes. */
+  abstract IndexManager getIndexManager();
+
   /**
    * Performs an operation inside a persistence transaction. Any reads or writes against persistence
    * must be performed within a transaction. Writes will be committed atomically once the
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteIndexManager.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteIndexManager.java
new file mode 100644
index 000000000..aff7e8ce4
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteIndexManager.java
@@ -0,0 +1,68 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import static com.google.firebase.firestore.util.Assert.hardAssert;
+
+import com.google.firebase.firestore.model.ResourcePath;
+import java.util.ArrayList;
+import java.util.List;
+
+/** A persisted implementation of IndexManager. */
+final class SQLiteIndexManager implements IndexManager {
+  /**
+   * An in-memory copy of the index entries we've already written since the SDK launched. Used to
+   * avoid re-writing the same entry repeatedly.
+   *
+   * <p>This is *NOT* a complete cache of what's in persistence and so can never be used to satisfy
+   * reads.
+   */
+  private final MemoryIndexManager.MemoryCollectionParentIndex collectionParentsCache =
+      new MemoryIndexManager.MemoryCollectionParentIndex();
+
+  private final SQLitePersistence db;
+
+  SQLiteIndexManager(SQLitePersistence persistence) {
+    db = persistence;
+  }
+
+  @Override
+  public void addToCollectionParentIndex(ResourcePath collectionPath) {
+    hardAssert(collectionPath.length() % 2 == 1, "Expected a collection path.");
+
+    if (collectionParentsCache.add(collectionPath)) {
+      String collectionId = collectionPath.getLastSegment();
+      ResourcePath parentPath = collectionPath.popLast();
+      db.execute(
+          "INSERT OR REPLACE INTO collection_parents "
+              + "(collection_id, parent) "
+              + "VALUES (?, ?)",
+          collectionId,
+          EncodedPath.encode(parentPath));
+    }
+  }
+
+  @Override
+  public List<ResourcePath> getCollectionParents(String collectionId) {
+    ArrayList<ResourcePath> parentPaths = new ArrayList<>();
+    db.query("SELECT parent FROM collection_parents WHERE collection_id = ?")
+        .binding(collectionId)
+        .forEach(
+            row -> {
+              parentPaths.add(EncodedPath.decodeResourcePath(row.getString(0)));
+            });
+    return parentPaths;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
index 9c41c101a..951442b34 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteMutationQueue.java
@@ -179,11 +179,12 @@ private void writeMutationQueueMetadata() {
   }
 
   @Override
-  public MutationBatch addMutationBatch(Timestamp localWriteTime, List<Mutation> mutations) {
+  public MutationBatch addMutationBatch(
+      Timestamp localWriteTime, List<Mutation> baseMutations, List<Mutation> mutations) {
     int batchId = nextBatchId;
     nextBatchId += 1;
 
-    MutationBatch batch = new MutationBatch(batchId, localWriteTime, mutations);
+    MutationBatch batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
     MessageLite proto = serializer.encodeMutationBatch(batch);
 
     db.execute(
@@ -207,6 +208,8 @@ public MutationBatch addMutationBatch(Timestamp localWriteTime, List<Mutation> m
 
       String path = EncodedPath.encode(key.getPath());
       db.execute(indexInserter, uid, path, batchId);
+
+      db.getIndexManager().addToCollectionParentIndex(key.getPath().popLast());
     }
 
     return batch;
@@ -314,6 +317,9 @@ public MutationBatch getNextMutationBatchAfterBatchId(int batchId) {
 
   @Override
   public List<MutationBatch> getAllMutationBatchesAffectingQuery(Query query) {
+    hardAssert(
+        !query.isCollectionGroupQuery(),
+        "CollectionGroup queries should be handled in LocalDocumentsView");
     // Use the query path as a prefix for testing if a document matches the query.
     ResourcePath prefix = query.getPath();
     int immediateChildrenPathLength = prefix.length() + 1;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
index d143e5cfb..ca59f76f6 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLitePersistence.java
@@ -78,6 +78,7 @@ public static String databaseName(String persistenceKey, DatabaseId databaseId)
   private SQLiteDatabase db;
   private boolean started;
   private final SQLiteQueryCache queryCache;
+  private final SQLiteIndexManager indexManager;
   private final SQLiteRemoteDocumentCache remoteDocumentCache;
   private final SQLiteLruReferenceDelegate referenceDelegate;
   private final SQLiteTransactionListener transactionListener =
@@ -106,6 +107,7 @@ public SQLitePersistence(
     this.opener = new OpenHelper(context, databaseName);
     this.serializer = serializer;
     this.queryCache = new SQLiteQueryCache(this, this.serializer);
+    this.indexManager = new SQLiteIndexManager(this);
     this.remoteDocumentCache = new SQLiteRemoteDocumentCache(this, this.serializer);
     this.referenceDelegate = new SQLiteLruReferenceDelegate(this, params);
   }
@@ -160,6 +162,11 @@ SQLiteQueryCache getQueryCache() {
     return queryCache;
   }
 
+  @Override
+  IndexManager getIndexManager() {
+    return indexManager;
+  }
+
   @Override
   RemoteDocumentCache getRemoteDocumentCache() {
     return remoteDocumentCache;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
index 67f1524cb..79fb238e0 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteRemoteDocumentCache.java
@@ -15,6 +15,7 @@
 package com.google.firebase.firestore.local;
 
 import static com.google.firebase.firestore.util.Assert.fail;
+import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.core.Query;
@@ -49,6 +50,8 @@ public void add(MaybeDocument maybeDocument) {
         "INSERT OR REPLACE INTO remote_documents (path, contents) VALUES (?, ?)",
         path,
         message.toByteArray());
+
+    db.getIndexManager().addToCollectionParentIndex(maybeDocument.getKey().getPath().popLast());
   }
 
   @Override
@@ -104,6 +107,10 @@ public MaybeDocument get(DocumentKey documentKey) {
 
   @Override
   public ImmutableSortedMap<DocumentKey, Document> getAllDocumentsMatchingQuery(Query query) {
+    hardAssert(
+        !query.isCollectionGroupQuery(),
+        "CollectionGroup queries should be handled in LocalDocumentsView");
+
     // Use the query path as a prefix for testing if a document matches the query.
     ResourcePath prefix = query.getPath();
     int immediateChildrenPathLength = prefix.length() + 1;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
index 109ab3645..4bab543a9 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/SQLiteSchema.java
@@ -25,6 +25,8 @@
 import android.text.TextUtils;
 import android.util.Log;
 import com.google.common.base.Preconditions;
+import com.google.firebase.firestore.model.ResourcePath;
+import com.google.firebase.firestore.util.Consumer;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -44,7 +46,7 @@
    * The version of the schema. Increase this by one for each migration added to runMigrations
    * below.
    */
-  static final int VERSION = 7;
+  static final int VERSION = 8;
   // Remove this constant and increment VERSION to enable indexing support
   static final int INDEXING_SUPPORT_VERSION = VERSION + 1;
 
@@ -112,6 +114,10 @@ void runMigrations(int fromVersion, int toVersion) {
       ensureSequenceNumbers();
     }
 
+    if (fromVersion < 8 && toVersion >= 8) {
+      createV8CollectionParentsIndex();
+    }
+
     /*
      * Adding a new migration? READ THIS FIRST!
      *
@@ -366,6 +372,58 @@ private void ensureSequenceNumbers() {
         });
   }
 
+  private void createV8CollectionParentsIndex() {
+    ifTablesDontExist(
+        new String[] {"collection_parents"},
+        () -> {
+          // A table storing associations between a Collection ID (e.g. 'messages') to a parent path
+          // (e.g. '/chats/123') that contains it as a (sub)collection. This is used to efficiently
+          // find all collections to query when performing a Collection Group query. Note that the
+          // parent path will be an empty path in the case of root-level collections.
+          db.execSQL(
+              "CREATE TABLE collection_parents ("
+                  + "collection_id TEXT, "
+                  + "parent TEXT, "
+                  + "PRIMARY KEY(collection_id, parent))");
+        });
+
+    // Helper to add an index entry iff we haven't already written it.
+    MemoryIndexManager.MemoryCollectionParentIndex cache =
+        new MemoryIndexManager.MemoryCollectionParentIndex();
+    SQLiteStatement addIndexEntry =
+        db.compileStatement(
+            "INSERT OR REPLACE INTO collection_parents (collection_id, parent) VALUES (?, ?)");
+    Consumer<ResourcePath> addEntry =
+        collectionPath -> {
+          if (cache.add(collectionPath)) {
+            String collectionId = collectionPath.getLastSegment();
+            ResourcePath parentPath = collectionPath.popLast();
+            addIndexEntry.clearBindings();
+            addIndexEntry.bindString(1, collectionId);
+            addIndexEntry.bindString(2, EncodedPath.encode(parentPath));
+            addIndexEntry.execute();
+          }
+        };
+
+    // Index existing remote documents.
+    SQLitePersistence.Query remoteDocumentsQuery =
+        new SQLitePersistence.Query(db, "SELECT path FROM remote_documents");
+    remoteDocumentsQuery.forEach(
+        row -> {
+          ResourcePath path = EncodedPath.decodeResourcePath(row.getString(0));
+          addEntry.accept(path.popLast());
+        });
+
+    // Index existing mutations.
+    SQLitePersistence.Query documentMutationsQuery =
+        new SQLitePersistence.Query(db, "SELECT path FROM document_mutations");
+    documentMutationsQuery.forEach(
+        row -> {
+          ResourcePath path = EncodedPath.decodeResourcePath(row.getString(0));
+          addEntry.accept(path.popLast());
+        });
+  }
+
   private boolean tableContainsColumn(String table, String column) {
     List<String> columns = getTableColumns(table);
     return columns.indexOf(column) != -1;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
index be54d8f0b..d9b77cfa6 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/local/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.local;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
index 173edfaf9..8edd053f7 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/DocumentKey.java
@@ -95,6 +95,11 @@ public ResourcePath getPath() {
     return path;
   }
 
+  /** Returns true if the document is in the specified collectionId. */
+  public boolean hasCollectionId(String collectionId) {
+    return path.length() >= 2 && path.segments.get(path.length() - 2).equals(collectionId);
+  }
+
   @Override
   public int compareTo(@NonNull DocumentKey another) {
     return path.compareTo(another.path);
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
index f8f1c7abd..c781129e9 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ArrayTransformOperation.java
@@ -88,6 +88,11 @@ public int hashCode() {
     }
   }
 
+  @Override
+  public boolean isIdempotent() {
+    return true;
+  }
+
   /** An array union transform operation. */
   public static class Union extends ArrayTransformOperation {
     public Union(List<FieldValue> elements) {
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
index fb46cb8d6..b7a00c257 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/DeleteMutation.java
@@ -82,4 +82,15 @@ public MaybeDocument applyToLocalView(
 
     return new NoDocument(getKey(), SnapshotVersion.NONE, /*hasCommittedMutations=*/ false);
   }
+
+  @Nullable
+  @Override
+  public FieldMask getFieldMask() {
+    return null;
+  }
+
+  @Override
+  public boolean isIdempotent() {
+    return true;
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
index 7b0f8ee9f..16573090f 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldMask.java
@@ -15,6 +15,8 @@
 package com.google.firebase.firestore.model.mutation;
 
 import com.google.firebase.firestore.model.FieldPath;
+import com.google.firebase.firestore.model.value.FieldValue;
+import com.google.firebase.firestore.model.value.ObjectValue;
 import java.util.Set;
 
 /**
@@ -69,6 +71,25 @@ public boolean covers(FieldPath fieldPath) {
     return false;
   }
 
+  /**
+   * Applies this field mask to the provided object value and returns an object that only contains
+   * fields that are specified in both the input object and this field mask.
+   */
+  public ObjectValue applyTo(ObjectValue data) {
+    ObjectValue filteredObject = ObjectValue.emptyObject();
+    for (FieldPath path : mask) {
+      if (path.isEmpty()) {
+        return data;
+      } else {
+        FieldValue newValue = data.get(path);
+        if (newValue != null) {
+          filteredObject = filteredObject.set(path, newValue);
+        }
+      }
+    }
+    return filteredObject;
+  }
+
   @Override
   public int hashCode() {
     return mask.hashCode();
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
index d6739a9f8..831f79e07 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/FieldTransform.java
@@ -58,4 +58,8 @@ public int hashCode() {
     result = 31 * result + operation.hashCode();
     return result;
   }
+
+  public boolean isIdempotent() {
+    return operation.isIdempotent();
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
index 93fbaac2e..fb56493a8 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/Mutation.java
@@ -148,4 +148,15 @@ static SnapshotVersion getPostMutationVersion(@Nullable MaybeDocument maybeDoc)
       return SnapshotVersion.NONE;
     }
   }
+
+  /**
+   * If applicable, returns the field mask for this mutation. Fields that are not included in this
+   * field mask are not modified when this mutation is applied. Mutations that replace all document
+   * values return 'null'.
+   */
+  @Nullable
+  public abstract FieldMask getFieldMask();
+
+  /** Returns whether all operations in the mutation are idempotent. */
+  public abstract boolean isIdempotent();
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
index a2b7d3567..0c68de215 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/MutationBatch.java
@@ -17,6 +17,7 @@
 import static com.google.firebase.firestore.util.Assert.hardAssert;
 
 import com.google.firebase.Timestamp;
+import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.firestore.model.DocumentKey;
 import com.google.firebase.firestore.model.MaybeDocument;
 import java.util.HashSet;
@@ -39,14 +40,34 @@
    */
   public static final int UNKNOWN = -1;
 
+  /** The unique ID of this mutation batch. */
   private final int batchId;
+
+  /** The original write time of this mutation. */
   private final Timestamp localWriteTime;
+
+  /**
+   * Mutations that are used to populate the base values when this mutation is applied locally. This
+   * can be used to locally overwrite values that are persisted in the remote document cache. Base
+   * mutations are never sent to the backend.
+   */
+  private final List<Mutation> baseMutations;
+
+  /**
+   * The user-provided mutations in this mutation batch. User-provided mutations are applied both
+   * locally and remotely on the backend.
+   */
   private final List<Mutation> mutations;
 
-  public MutationBatch(int batchId, Timestamp localWriteTime, List<Mutation> mutations) {
+  public MutationBatch(
+      int batchId,
+      Timestamp localWriteTime,
+      List<Mutation> baseMutations,
+      List<Mutation> mutations) {
     hardAssert(!mutations.isEmpty(), "Cannot create an empty mutation batch");
     this.batchId = batchId;
     this.localWriteTime = localWriteTime;
+    this.baseMutations = baseMutations;
     this.mutations = mutations;
   }
 
@@ -98,8 +119,18 @@ public MaybeDocument applyToLocalView(DocumentKey documentKey, @Nullable MaybeDo
           maybeDoc.getKey());
     }
 
+    // First, apply the base state. This allows us to apply non-idempotent transform against a
+    // consistent set of values.
+    for (int i = 0; i < baseMutations.size(); i++) {
+      Mutation mutation = baseMutations.get(i);
+      if (mutation.getKey().equals(documentKey)) {
+        maybeDoc = mutation.applyToLocalView(maybeDoc, maybeDoc, localWriteTime);
+      }
+    }
+
     MaybeDocument baseDoc = maybeDoc;
 
+    // Second, apply all user-provided mutations.
     for (int i = 0; i < mutations.size(); i++) {
       Mutation mutation = mutations.get(i);
       if (mutation.getKey().equals(documentKey)) {
@@ -109,6 +140,23 @@ public MaybeDocument applyToLocalView(DocumentKey documentKey, @Nullable MaybeDo
     return maybeDoc;
   }
 
+  /** Computes the local view for all provided documents given the mutations in this batch. */
+  public ImmutableSortedMap<DocumentKey, MaybeDocument> applyToLocalDocumentSet(
+      ImmutableSortedMap<DocumentKey, MaybeDocument> maybeDocumentMap) {
+    // TODO(mrschmidt): This implementation is O(n^2). If we iterate through the mutations first
+    // (as done in `applyToLocalView(DocumentKey k, MaybeDoc d)`), we can reduce the complexity to
+    // O(n).
+
+    ImmutableSortedMap<DocumentKey, MaybeDocument> mutatedDocuments = maybeDocumentMap;
+    for (DocumentKey key : getKeys()) {
+      MaybeDocument mutatedDocument = applyToLocalView(key, mutatedDocuments.get(key));
+      if (mutatedDocument != null) {
+        mutatedDocuments = mutatedDocuments.insert(mutatedDocument.getKey(), mutatedDocument);
+      }
+    }
+    return mutatedDocuments;
+  }
+
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -121,6 +169,7 @@ public boolean equals(Object o) {
     MutationBatch that = (MutationBatch) o;
     return batchId == that.batchId
         && localWriteTime.equals(that.localWriteTime)
+        && baseMutations.equals(that.baseMutations)
         && mutations.equals(that.mutations);
   }
 
@@ -128,6 +177,7 @@ public boolean equals(Object o) {
   public int hashCode() {
     int result = batchId;
     result = 31 * result + localWriteTime.hashCode();
+    result = 31 * result + baseMutations.hashCode();
     result = 31 * result + mutations.hashCode();
     return result;
   }
@@ -138,6 +188,8 @@ public String toString() {
         + batchId
         + ", localWriteTime="
         + localWriteTime
+        + ", baseMutations="
+        + baseMutations
         + ", mutations="
         + mutations
         + ')';
@@ -164,7 +216,16 @@ public Timestamp getLocalWriteTime() {
     return localWriteTime;
   }
 
+  /** @return The user-provided mutations in this mutation batch. */
   public List<Mutation> getMutations() {
     return mutations;
   }
+
+  /**
+   * @return The mutations that are used to populate the base values when this mutation batch is
+   *     applied locally.
+   */
+  public List<Mutation> getBaseMutations() {
+    return baseMutations;
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java
new file mode 100644
index 000000000..baf922945
--- /dev/null
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/NumericIncrementTransformOperation.java
@@ -0,0 +1,111 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.model.mutation;
+
+import static com.google.firebase.firestore.util.Assert.fail;
+
+import com.google.firebase.Timestamp;
+import com.google.firebase.firestore.model.value.DoubleValue;
+import com.google.firebase.firestore.model.value.FieldValue;
+import com.google.firebase.firestore.model.value.IntegerValue;
+import com.google.firebase.firestore.model.value.NumberValue;
+
+/**
+ * Implements the backend semantics for locally computed NUMERIC_ADD (increment) transforms.
+ * Converts all field values to longs or doubles and resolves overflows to
+ * Long.MAX_VALUE/Long.MIN_VALUE.
+ */
+public class NumericIncrementTransformOperation implements TransformOperation {
+  private NumberValue operand;
+
+  public NumericIncrementTransformOperation(NumberValue operand) {
+    this.operand = operand;
+  }
+
+  @Override
+  public FieldValue applyToLocalView(FieldValue previousValue, Timestamp localWriteTime) {
+    // Return an integer value only if the previous value and the operand is an integer.
+    if (previousValue instanceof IntegerValue && operand instanceof IntegerValue) {
+      long sum = safeIncrement(((IntegerValue) previousValue).getInternalValue(), operandAsLong());
+      return IntegerValue.valueOf(sum);
+    } else if (previousValue instanceof IntegerValue) {
+      double sum = ((IntegerValue) previousValue).getInternalValue() + operandAsDouble();
+      return DoubleValue.valueOf(sum);
+    } else if (previousValue instanceof DoubleValue) {
+      double sum = ((DoubleValue) previousValue).getInternalValue() + operandAsDouble();
+      return DoubleValue.valueOf(sum);
+    }
+
+    // If the existing value is not a number, use the value of the transform as the new base value.
+    return operand;
+  }
+
+  /**
+   * Implementation of Java 8's `addExact()` that resolves positive and negative numeric overflows
+   * to Long.MAX_VALUE or Long.MIN_VALUE respectively (instead of throwing an ArithmeticException).
+   */
+  private long safeIncrement(long x, long y) {
+    long r = x + y;
+
+    // See "Hacker's Delight" 2-12: Overflow if both arguments have the opposite sign of the result
+    if (((x ^ r) & (y ^ r)) >= 0) {
+      return r;
+    }
+
+    if (r >= 0L) {
+      return Long.MIN_VALUE;
+    } else {
+      return Long.MAX_VALUE;
+    }
+  }
+
+  private double operandAsDouble() {
+    if (operand instanceof DoubleValue) {
+      return ((DoubleValue) operand).getInternalValue();
+    } else if (operand instanceof IntegerValue) {
+      return ((IntegerValue) operand).getInternalValue();
+    } else {
+      throw fail(
+          "Expected 'operand' to be of Number type, but was "
+              + operand.getClass().getCanonicalName());
+    }
+  }
+
+  private long operandAsLong() {
+    if (operand instanceof DoubleValue) {
+      return (long) ((DoubleValue) operand).getInternalValue();
+    } else if (operand instanceof IntegerValue) {
+      return ((IntegerValue) operand).getInternalValue();
+    } else {
+      throw fail(
+          "Expected 'operand' to be of Number type, but was "
+              + operand.getClass().getCanonicalName());
+    }
+  }
+
+  @Override
+  public FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult) {
+    return transformResult;
+  }
+
+  public FieldValue getOperand() {
+    return operand;
+  }
+
+  @Override
+  public boolean isIdempotent() {
+    return false;
+  }
+}
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
index 3f119ea66..ade731ba1 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/PatchMutation.java
@@ -130,6 +130,12 @@ public MaybeDocument applyToLocalView(
     return new Document(getKey(), version, newData, Document.DocumentState.LOCAL_MUTATIONS);
   }
 
+  @Nullable
+  @Override
+  public FieldMask getFieldMask() {
+    return mask;
+  }
+
   /**
    * Patches the data of document if available or creates a new document. Note that this does not
    * check whether or not the precondition of this patch holds.
@@ -157,4 +163,9 @@ private ObjectValue patchObject(ObjectValue obj) {
     }
     return obj;
   }
+
+  @Override
+  public boolean isIdempotent() {
+    return true;
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
index 4d0eabd12..0f75a9430 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/ServerTimestampOperation.java
@@ -38,6 +38,11 @@ public FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue tra
     return transformResult;
   }
 
+  @Override
+  public boolean isIdempotent() {
+    return true;
+  }
+
   // NOTE: Since we've guaranteed a singleton instance, we can rely on Object's default
   // implementation of equals() / hashCode().
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
index dc0fa550e..f4fd44fe1 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/SetMutation.java
@@ -89,8 +89,19 @@ public MaybeDocument applyToLocalView(
     return new Document(getKey(), version, value, Document.DocumentState.LOCAL_MUTATIONS);
   }
 
+  @Nullable
+  @Override
+  public FieldMask getFieldMask() {
+    return null;
+  }
+
   /** Returns the object value to use when setting the document. */
   public ObjectValue getValue() {
     return value;
   }
+
+  @Override
+  public boolean isIdempotent() {
+    return true;
+  }
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
index f925017fa..abe82a999 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformMutation.java
@@ -25,7 +25,9 @@
 import com.google.firebase.firestore.model.value.FieldValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
@@ -121,6 +123,25 @@ public MaybeDocument applyToLocalView(
         getKey(), doc.getVersion(), newData, Document.DocumentState.LOCAL_MUTATIONS);
   }
 
+  @Override
+  public FieldMask getFieldMask() {
+    Set<FieldPath> fieldMask = new HashSet<>();
+    for (FieldTransform transform : fieldTransforms) {
+      fieldMask.add(transform.getFieldPath());
+    }
+    return FieldMask.fromSet(fieldMask);
+  }
+
+  @Override
+  public boolean isIdempotent() {
+    for (FieldTransform transform : fieldTransforms) {
+      if (!transform.isIdempotent()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * Asserts that the given MaybeDocument is actually a Document and verifies that it matches the
    * key for this mutation. Since we only support transformations with precondition exists this
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
index 7e9bcf506..22bda140c 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/TransformOperation.java
@@ -30,4 +30,7 @@
    * potentially using the server-provided transformResult.
    */
   FieldValue applyToRemoteDocument(FieldValue previousValue, FieldValue transformResult);
+
+  /** Returns whether this field transform is idempotent. */
+  boolean isIdempotent();
 }
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
index 9fda81ac0..a736e4521 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/mutation/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model.mutation;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
index efcc2f1c8..5a9166dd5 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
index 3b84023bc..d4a89aad3 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.model.value;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
index 11b550066..9c72064eb 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/RemoteSerializer.java
@@ -45,6 +45,7 @@
 import com.google.firebase.firestore.model.mutation.FieldTransform;
 import com.google.firebase.firestore.model.mutation.Mutation;
 import com.google.firebase.firestore.model.mutation.MutationResult;
+import com.google.firebase.firestore.model.mutation.NumericIncrementTransformOperation;
 import com.google.firebase.firestore.model.mutation.PatchMutation;
 import com.google.firebase.firestore.model.mutation.Precondition;
 import com.google.firebase.firestore.model.mutation.ServerTimestampOperation;
@@ -59,6 +60,7 @@
 import com.google.firebase.firestore.model.value.GeoPointValue;
 import com.google.firebase.firestore.model.value.IntegerValue;
 import com.google.firebase.firestore.model.value.NullValue;
+import com.google.firebase.firestore.model.value.NumberValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.model.value.ReferenceValue;
 import com.google.firebase.firestore.model.value.StringValue;
@@ -556,6 +558,13 @@ private FieldMask decodeDocumentMask(DocumentMask mask) {
           .setFieldPath(fieldTransform.getFieldPath().canonicalString())
           .setRemoveAllFromArray(encodeArrayTransformElements(remove.getElements()))
           .build();
+    } else if (transform instanceof NumericIncrementTransformOperation) {
+      NumericIncrementTransformOperation incrementOperation =
+          (NumericIncrementTransformOperation) transform;
+      return DocumentTransform.FieldTransform.newBuilder()
+          .setFieldPath(fieldTransform.getFieldPath().canonicalString())
+          .setIncrement(encodeValue(incrementOperation.getOperand()))
+          .build();
     } else {
       throw fail("Unknown transform: %s", transform);
     }
@@ -592,6 +601,18 @@ private FieldTransform decodeFieldTransform(DocumentTransform.FieldTransform fie
             FieldPath.fromServerFormat(fieldTransform.getFieldPath()),
             new ArrayTransformOperation.Remove(
                 decodeArrayTransformElements(fieldTransform.getRemoveAllFromArray())));
+      case INCREMENT:
+        {
+          FieldValue operand = decodeValue(fieldTransform.getIncrement());
+          hardAssert(
+              operand instanceof NumberValue,
+              "Expected NUMERIC_ADD transform to be of number type, but was %s",
+              operand.getClass().getCanonicalName());
+          return new FieldTransform(
+              FieldPath.fromServerFormat(fieldTransform.getFieldPath()),
+              new NumericIncrementTransformOperation(
+                  (NumberValue) decodeValue(fieldTransform.getIncrement())));
+        }
       default:
         throw fail("Unknown FieldTransform proto: %s", fieldTransform);
     }
@@ -691,10 +712,17 @@ public QueryTarget encodeQueryTarget(Query query) {
     // Dissect the path into parent, collectionId, and optional key filter.
     QueryTarget.Builder builder = QueryTarget.newBuilder();
     StructuredQuery.Builder structuredQueryBuilder = StructuredQuery.newBuilder();
-    if (query.getPath().length() == 0) {
-      builder.setParent(encodeQueryPath(ResourcePath.EMPTY));
+    ResourcePath path = query.getPath();
+    if (query.getCollectionGroup() != null) {
+      Assert.hardAssert(
+          path.length() % 2 == 0,
+          "Collection Group queries should be within a document path or root.");
+      builder.setParent(encodeQueryPath(path));
+      CollectionSelector.Builder from = CollectionSelector.newBuilder();
+      from.setCollectionId(query.getCollectionGroup());
+      from.setAllDescendants(true);
+      structuredQueryBuilder.addFrom(from);
     } else {
-      ResourcePath path = query.getPath();
       Assert.hardAssert(path.length() % 2 != 0, "Document queries with filters are not supported.");
       builder.setParent(encodeQueryPath(path.popLast()));
       CollectionSelector.Builder from = CollectionSelector.newBuilder();
@@ -733,13 +761,19 @@ public Query decodeQueryTarget(QueryTarget target) {
     ResourcePath path = decodeQueryPath(target.getParent());
 
     StructuredQuery query = target.getStructuredQuery();
+
+    String collectionGroup = null;
     int fromCount = query.getFromCount();
     if (fromCount > 0) {
       hardAssert(
           fromCount == 1, "StructuredQuery.from with more than one collection is not supported.");
 
       CollectionSelector from = query.getFrom(0);
-      path = path.append(from.getCollectionId());
+      if (from.getAllDescendants()) {
+        collectionGroup = from.getCollectionId();
+      } else {
+        path = path.append(from.getCollectionId());
+      }
     }
 
     List<Filter> filterBy;
@@ -775,7 +809,7 @@ public Query decodeQueryTarget(QueryTarget target) {
       endAt = decodeBound(query.getEndAt());
     }
 
-    return new Query(path, filterBy, orderBy, limit, startAt, endAt);
+    return new Query(path, collectionGroup, filterBy, orderBy, limit, startAt, endAt);
   }
 
   // Filters
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
index 78a3b7d3a..35a4ae14d 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/remote/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.remote;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
index bb3ce3c0f..a8abd7e36 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/CustomClassMapper.java
@@ -113,22 +113,21 @@ public static Object convertToPlainJavaTypes(Object object) {
     if (o == null) {
       return null;
     } else if (o instanceof Number) {
-      if (o instanceof Float) {
-        return ((Float) o).doubleValue();
-      } else if (o instanceof Short) {
-        throw serializeError(path, "Shorts are not supported, please use int or long");
-      } else if (o instanceof Byte) {
-        throw serializeError(path, "Bytes are not supported, please use int or long");
-      } else {
-        // Long, Integer, Double
+      if (o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof Float) {
         return o;
+      } else {
+        throw serializeError(
+            path,
+            String.format(
+                "Numbers of type %s are not supported, please use an int, long, float or double",
+                o.getClass().getSimpleName()));
       }
     } else if (o instanceof String) {
       return o;
     } else if (o instanceof Boolean) {
       return o;
     } else if (o instanceof Character) {
-      throw serializeError(path, "Characters are not supported, please use Strings.");
+      throw serializeError(path, "Characters are not supported, please use Strings");
     } else if (o instanceof Map) {
       Map<String, Object> result = new HashMap<>();
       for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) o).entrySet()) {
@@ -313,14 +312,10 @@ public static Object convertToPlainJavaTypes(Object object) {
       return (T) convertLong(o, path);
     } else if (Float.class.isAssignableFrom(clazz) || float.class.isAssignableFrom(clazz)) {
       return (T) (Float) convertDouble(o, path).floatValue();
-    } else if (Short.class.isAssignableFrom(clazz) || short.class.isAssignableFrom(clazz)) {
-      throw deserializeError(path, "Deserializing to shorts is not supported");
-    } else if (Byte.class.isAssignableFrom(clazz) || byte.class.isAssignableFrom(clazz)) {
-      throw deserializeError(path, "Deserializing to bytes is not supported");
-    } else if (Character.class.isAssignableFrom(clazz) || char.class.isAssignableFrom(clazz)) {
-      throw deserializeError(path, "Deserializing to chars is not supported");
     } else {
-      throw new IllegalArgumentException("Unknown primitive type: " + clazz);
+      throw deserializeError(
+          path,
+          String.format("Deserializing values to %s is not supported", clazz.getSimpleName()));
     }
   }
 
diff --git a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
index 66755e593..108a6ae51 100644
--- a/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
+++ b/firebase-firestore/src/main/java/com/google/firebase/firestore/util/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 package com.google.firebase.firestore.util;
+
+import android.support.annotation.RestrictTo;
diff --git a/firebase-firestore/src/proto/google/firebase/firestore/proto/mutation.proto b/firebase-firestore/src/proto/google/firebase/firestore/proto/mutation.proto
index 8f3d6e7ef..23d4b66b6 100644
--- a/firebase-firestore/src/proto/google/firebase/firestore/proto/mutation.proto
+++ b/firebase-firestore/src/proto/google/firebase/firestore/proto/mutation.proto
@@ -55,4 +55,16 @@ message WriteBatch {
 
   // The local time at which the write batch was initiated.
   google.protobuf.Timestamp local_write_time = 3;
+
+  // A list of pseudo-writes that represent a partial base state from when this
+  // write batch was initially created. When computing the local view batch,
+  // these base_writes are applied prior to the real writes in order to
+  // override certain document fields from the remote document cache. This is
+  // necessary in the case of non-idempotent writes (e.g. increment
+  // transforms) to make sure that the local view of the modified documents
+  // doesn't flicker if the remote document cache receives the result of the
+  // non-idempotent write before the write is removed from the queue.
+  //
+  // These writes are never sent to the backend.
+  repeated google.firestore.v1.Write base_writes = 4;
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/TestUtil.java b/firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java
similarity index 100%
rename from firebase-firestore/src/test/java/com/google/firebase/firestore/TestUtil.java
rename to firebase-firestore/src/roboUtil/java/com/google/firebase/firestore/TestUtil.java
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexManagerTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexManagerTestCase.java
new file mode 100644
index 000000000..b4bcdf74c
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexManagerTestCase.java
@@ -0,0 +1,84 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import static com.google.firebase.firestore.testutil.TestUtil.path;
+import static org.junit.Assert.assertEquals;
+
+import com.google.firebase.firestore.model.ResourcePath;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+
+/**
+ * These are tests for any implementation of the IndexManager interface.
+ *
+ * <p>To test a specific implementation of IndexManager:
+ *
+ * <ol>
+ *   <li>Subclass IndexManagerTestCase.
+ *   <li>Override {@link #getPersistence}, creating a new implementation of Persistence.
+ * </ol>
+ */
+public abstract class IndexManagerTestCase {
+  @Rule public TestName name = new TestName();
+
+  private Persistence persistence;
+  private IndexManager indexManager;
+
+  @Before
+  public void setUp() {
+    persistence = getPersistence();
+    indexManager = persistence.getIndexManager();
+  }
+
+  @After
+  public void tearDown() {
+    persistence.shutdown();
+  }
+
+  abstract Persistence getPersistence();
+
+  @Test
+  public void testCanAddAndReadCollectionParentIndexEntries() {
+    indexManager.addToCollectionParentIndex(path("messages"));
+    indexManager.addToCollectionParentIndex(path("messages"));
+    indexManager.addToCollectionParentIndex(path("rooms/foo/messages"));
+    indexManager.addToCollectionParentIndex(path("rooms/bar/messages"));
+    indexManager.addToCollectionParentIndex(path("rooms/foo/messages2"));
+
+    assertParents(indexManager, "messages", Arrays.asList("", "rooms/bar", "rooms/foo"));
+    assertParents(indexManager, "messages2", Arrays.asList("rooms/foo"));
+    assertParents(indexManager, "messages3", Collections.emptyList());
+  }
+
+  private void assertParents(
+      IndexManager indexManager, String collectionId, List<String> expected) {
+    List<ResourcePath> actualPaths = indexManager.getCollectionParents(collectionId);
+    List<String> actual = new ArrayList<String>();
+    for (ResourcePath actualPath : actualPaths) {
+      actual.add(actualPath.toString());
+    }
+    expected.sort(String::compareTo);
+    actual.sort(String::compareTo);
+    assertEquals(expected, actual);
+  }
+}
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
index d45524c81..8cf85f301 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/IndexedQueryEngineTest.java
@@ -67,7 +67,8 @@ public void setUp() {
     SQLiteCollectionIndex index = new SQLiteCollectionIndex(persistence, User.UNAUTHENTICATED);
     MutationQueue mutationQueue = persistence.getMutationQueue(User.UNAUTHENTICATED);
     remoteDocuments = persistence.getRemoteDocumentCache();
-    LocalDocumentsView localDocuments = new LocalDocumentsView(remoteDocuments, mutationQueue);
+    LocalDocumentsView localDocuments =
+        new LocalDocumentsView(remoteDocuments, mutationQueue, persistence.getIndexManager());
     queryEngine = new IndexedQueryEngine(localDocuments, index);
   }
 
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
index 41d5f745e..c97f3637f 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalSerializerTest.java
@@ -17,6 +17,7 @@
 import static com.google.firebase.firestore.testutil.TestUtil.deleteMutation;
 import static com.google.firebase.firestore.testutil.TestUtil.deletedDoc;
 import static com.google.firebase.firestore.testutil.TestUtil.doc;
+import static com.google.firebase.firestore.testutil.TestUtil.field;
 import static com.google.firebase.firestore.testutil.TestUtil.fieldMask;
 import static com.google.firebase.firestore.testutil.TestUtil.key;
 import static com.google.firebase.firestore.testutil.TestUtil.map;
@@ -33,6 +34,7 @@
 import com.google.firebase.firestore.model.NoDocument;
 import com.google.firebase.firestore.model.SnapshotVersion;
 import com.google.firebase.firestore.model.UnknownDocument;
+import com.google.firebase.firestore.model.mutation.FieldMask;
 import com.google.firebase.firestore.model.mutation.Mutation;
 import com.google.firebase.firestore.model.mutation.MutationBatch;
 import com.google.firebase.firestore.model.mutation.PatchMutation;
@@ -43,6 +45,7 @@
 import com.google.firestore.v1.Value;
 import com.google.firestore.v1.Write;
 import com.google.protobuf.ByteString;
+import java.util.Collections;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -65,6 +68,12 @@ public void setUp() {
 
   @Test
   public void testEncodesMutationBatch() {
+    Mutation baseWrite =
+        new PatchMutation(
+            key("foo/bar"),
+            TestUtil.wrapObject(map("a", "b")),
+            FieldMask.fromSet(Collections.singleton(field("a"))),
+            com.google.firebase.firestore.model.mutation.Precondition.NONE);
     Mutation set = setMutation("foo/bar", map("a", "b", "num", 1));
     Mutation patch =
         new PatchMutation(
@@ -74,7 +83,18 @@ public void testEncodesMutationBatch() {
             com.google.firebase.firestore.model.mutation.Precondition.exists(true));
     Mutation del = deleteMutation("baz/quux");
     Timestamp writeTime = Timestamp.now();
-    MutationBatch model = new MutationBatch(42, writeTime, asList(set, patch, del));
+    MutationBatch model =
+        new MutationBatch(
+            42, writeTime, Collections.singletonList(baseWrite), asList(set, patch, del));
+
+    Write baseWriteProto =
+        Write.newBuilder()
+            .setUpdate(
+                com.google.firestore.v1.Document.newBuilder()
+                    .setName("projects/p/databases/d/documents/foo/bar")
+                    .putFields("a", Value.newBuilder().setStringValue("b").build()))
+            .setUpdateMask(DocumentMask.newBuilder().addFieldPaths("a"))
+            .build();
 
     Write setProto =
         Write.newBuilder()
@@ -108,6 +128,7 @@ public void testEncodesMutationBatch() {
     com.google.firebase.firestore.proto.WriteBatch batchProto =
         com.google.firebase.firestore.proto.WriteBatch.newBuilder()
             .setBatchId(42)
+            .addBaseWrites(baseWriteProto)
             .addAllWrites(asList(setProto, patchProto, delProto))
             .setLocalWriteTime(writeTimeProto)
             .build();
@@ -117,6 +138,7 @@ public void testEncodesMutationBatch() {
     assertEquals(model.getBatchId(), decoded.getBatchId());
     assertEquals(model.getLocalWriteTime(), decoded.getLocalWriteTime());
     assertEquals(model.getMutations(), decoded.getMutations());
+    assertEquals(model.getBaseMutations(), decoded.getBaseMutations());
     assertEquals(model.getKeys(), decoded.getKeys());
   }
 
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
index 5144a91e6..0d7617c17 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LocalStoreTestCase.java
@@ -25,11 +25,13 @@
 import static com.google.firebase.firestore.testutil.TestUtil.query;
 import static com.google.firebase.firestore.testutil.TestUtil.resumeToken;
 import static com.google.firebase.firestore.testutil.TestUtil.setMutation;
+import static com.google.firebase.firestore.testutil.TestUtil.transformMutation;
 import static com.google.firebase.firestore.testutil.TestUtil.unknownDoc;
 import static com.google.firebase.firestore.testutil.TestUtil.updateRemoteEvent;
 import static com.google.firebase.firestore.testutil.TestUtil.values;
 import static com.google.firebase.firestore.testutil.TestUtil.version;
 import static com.google.firebase.firestore.testutil.TestUtil.viewChanges;
+import static com.google.firebase.firestore.testutil.TestUtil.wrap;
 import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.singletonList;
@@ -43,6 +45,7 @@
 import com.google.firebase.Timestamp;
 import com.google.firebase.database.collection.ImmutableSortedMap;
 import com.google.firebase.database.collection.ImmutableSortedSet;
+import com.google.firebase.firestore.FieldValue;
 import com.google.firebase.firestore.TestUtil.TestTargetMetadataProvider;
 import com.google.firebase.firestore.auth.User;
 import com.google.firebase.firestore.core.Query;
@@ -66,6 +69,8 @@
 import com.google.firebase.firestore.testutil.TestUtil;
 import com.google.protobuf.ByteString;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -118,7 +123,9 @@ private void writeMutation(Mutation mutation) {
 
   private void writeMutations(List<Mutation> mutations) {
     LocalWriteResult result = localStore.writeLocally(mutations);
-    batches.add(new MutationBatch(result.getBatchId(), Timestamp.now(), mutations));
+    batches.add(
+        new MutationBatch(
+            result.getBatchId(), Timestamp.now(), Collections.emptyList(), mutations));
     lastChanges = result.getChanges();
   }
 
@@ -130,16 +137,23 @@ private void notifyLocalViewChanges(LocalViewChanges changes) {
     localStore.notifyLocalViewChanges(asList(changes));
   }
 
-  private void acknowledgeMutation(long documentVersion) {
+  private void acknowledgeMutation(long documentVersion, @Nullable Object transformResult) {
     MutationBatch batch = batches.remove(0);
     SnapshotVersion version = version(documentVersion);
-    MutationResult mutationResult = new MutationResult(version, /*transformResults=*/ null);
+    MutationResult mutationResult =
+        new MutationResult(
+            version,
+            transformResult != null ? Collections.singletonList(wrap(transformResult)) : null);
     MutationBatchResult result =
         MutationBatchResult.create(
             batch, version, singletonList(mutationResult), WriteStream.EMPTY_STREAM_TOKEN);
     lastChanges = localStore.acknowledgeBatch(result);
   }
 
+  private void acknowledgeMutation(long documentVersion) {
+    acknowledgeMutation(documentVersion, null);
+  }
+
   private void rejectMutation() {
     MutationBatch batch = batches.get(0);
     batches.remove(0);
@@ -203,7 +217,8 @@ private void assertNotContains(String keyPathString) {
   public void testMutationBatchKeys() {
     SetMutation set1 = setMutation("foo/bar", map("foo", "bar"));
     SetMutation set2 = setMutation("foo/baz", map("foo", "baz"));
-    MutationBatch batch = new MutationBatch(1, Timestamp.now(), asList(set1, set2));
+    MutationBatch batch =
+        new MutationBatch(1, Timestamp.now(), Collections.emptyList(), asList(set1, set2));
     Set<DocumentKey> keys = batch.getKeys();
     assertEquals(2, keys.size());
   }
@@ -934,4 +949,189 @@ public void testRemoteDocumentKeysForTarget() {
     keys = localStore.getRemoteDocumentKeys(2);
     assertSetEquals(asList(key("foo/bar"), key("foo/baz")), keys);
   }
+
+  // TODO(mrschmidt): The FieldValue.increment() field transform tests below would probably be
+  // better implemented as spec tests but currently they don't support transforms.
+
+  @Test
+  public void testHandlesSetMutationThenTransformMutationThenTransformMutation() {
+    writeMutation(setMutation("foo/bar", map("sum", 0)));
+    assertContains(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(1))));
+    assertContains(doc("foo/bar", 0, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 0, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(2))));
+    assertContains(doc("foo/bar", 0, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 0, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+  }
+
+  @Test
+  public void testHandlesSetMutationThenAckThenTransformMutationThenAckThenTransformMutation() {
+    if (garbageCollectorIsEager()) {
+      // Since this test doesn't start a listen, Eager GC removes the documents from the cache as
+      // soon as the mutation is applied. This creates a lot of special casing in this unit test but
+      // does not expand its test coverage.
+      return;
+    }
+
+    writeMutation(setMutation("foo/bar", map("sum", 0)));
+    assertContains(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+
+    acknowledgeMutation(1);
+    assertChanged(doc("foo/bar", 1, map("sum", 0), Document.DocumentState.COMMITTED_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("sum", 0), Document.DocumentState.COMMITTED_MUTATIONS));
+
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(1))));
+    assertContains(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+
+    acknowledgeMutation(2, 1);
+    assertChanged(doc("foo/bar", 2, map("sum", 1), Document.DocumentState.COMMITTED_MUTATIONS));
+    assertContains(doc("foo/bar", 2, map("sum", 1), Document.DocumentState.COMMITTED_MUTATIONS));
+
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(2))));
+    assertContains(doc("foo/bar", 2, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+    assertChanged(doc("foo/bar", 2, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+  }
+
+  @Test
+  public void testHandlesSetMutationThenTransformMutationThenRemoteEventThenTransformMutation() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+    assertTargetId(2);
+
+    writeMutation(setMutation("foo/bar", map("sum", 0)));
+    assertChanged(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 0, map("sum", 0), Document.DocumentState.LOCAL_MUTATIONS));
+
+    applyRemoteEvent(addedRemoteEvent(doc("foo/bar", 1, map("sum", 0)), asList(2), emptyList()));
+    acknowledgeMutation(1);
+    assertChanged(doc("foo/bar", 1, map("sum", 0), Document.DocumentState.SYNCED));
+    assertContains(doc("foo/bar", 1, map("sum", 0), Document.DocumentState.SYNCED));
+
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(1))));
+    assertChanged(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+
+    // The value in this remote event gets ignored since we still have a pending transform mutation.
+    applyRemoteEvent(addedRemoteEvent(doc("foo/bar", 2, map("sum", 1337)), asList(2), emptyList()));
+    assertChanged(doc("foo/bar", 2, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 2, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+
+    // Add another increment. Note that we still compute the increment based on the local value.
+    writeMutation(transformMutation("foo/bar", map("sum", FieldValue.increment(2))));
+    assertChanged(doc("foo/bar", 2, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 2, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+
+    acknowledgeMutation(3, 1);
+    assertChanged(doc("foo/bar", 3, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 3, map("sum", 3), Document.DocumentState.LOCAL_MUTATIONS));
+
+    acknowledgeMutation(4, 1339);
+    assertChanged(doc("foo/bar", 4, map("sum", 1339), Document.DocumentState.COMMITTED_MUTATIONS));
+    assertContains(doc("foo/bar", 4, map("sum", 1339), Document.DocumentState.COMMITTED_MUTATIONS));
+  }
+
+  @Test
+  public void testHoldsBackOnlyNonIdempotentTransforms() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+    assertTargetId(2);
+
+    writeMutation(setMutation("foo/bar", map("sum", 0, "array_union", new ArrayList<>())));
+    assertChanged(
+        doc(
+            "foo/bar",
+            0,
+            map("sum", 0, "array_union", new ArrayList<>()),
+            Document.DocumentState.LOCAL_MUTATIONS));
+
+    acknowledgeMutation(1);
+    assertChanged(
+        doc(
+            "foo/bar",
+            1,
+            map("sum", 0, "array_union", new ArrayList<>()),
+            Document.DocumentState.COMMITTED_MUTATIONS));
+
+    applyRemoteEvent(
+        addedRemoteEvent(
+            doc("foo/bar", 1, map("sum", 0, "array_union", new ArrayList<>())),
+            asList(2),
+            emptyList()));
+    assertChanged(
+        doc(
+            "foo/bar",
+            1,
+            map("sum", 0, "array_union", new ArrayList<>()),
+            Document.DocumentState.SYNCED));
+
+    writeMutations(
+        Arrays.asList(
+            transformMutation("foo/bar", map("sum", FieldValue.increment(1))),
+            transformMutation("foo/bar", map("array_union", FieldValue.arrayUnion("foo")))));
+    assertChanged(
+        doc(
+            "foo/bar",
+            1,
+            map("sum", 1, "array_union", Collections.singletonList("foo")),
+            Document.DocumentState.LOCAL_MUTATIONS));
+
+    // The sum transform is not idempotent and the backend's updated value is ignored. The
+    // ArrayUnion transform is recomputed and includes the backend value.
+    applyRemoteEvent(
+        addedRemoteEvent(
+            doc("foo/bar", 2, map("sum", 1337, "array_union", Collections.singletonList("bar"))),
+            asList(2),
+            emptyList()));
+    assertChanged(
+        doc(
+            "foo/bar",
+            2,
+            map("sum", 1, "array_union", Arrays.asList("bar", "foo")),
+            Document.DocumentState.LOCAL_MUTATIONS));
+  }
+
+  @Test
+  public void testHandlesMergeMutationWithTransformThenRemoteEvent() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+    assertTargetId(2);
+
+    writeMutations(
+        asList(
+            patchMutation("foo/bar", map(), Collections.emptyList()),
+            transformMutation("foo/bar", map("sum", FieldValue.increment(1)))));
+    assertChanged(doc("foo/bar", 0, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 0, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+
+    applyRemoteEvent(addedRemoteEvent(doc("foo/bar", 1, map("sum", 1337)), asList(2), emptyList()));
+    assertChanged(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+  }
+
+  @Test
+  public void testHandlesPatchMutationWithTransformThenRemoteEvent() {
+    Query query = Query.atPath(ResourcePath.fromString("foo"));
+    allocateQuery(query);
+    assertTargetId(2);
+
+    writeMutations(
+        asList(
+            patchMutation("foo/bar", map()),
+            transformMutation("foo/bar", map("sum", FieldValue.increment(1)))));
+    assertChanged(deletedDoc("foo/bar", 0));
+    assertNotContains("foo/bar");
+
+    // Note: This test reflects the current behavior, but it may be preferable to replay the
+    // mutation once we receive the first value from the remote event.
+
+    applyRemoteEvent(addedRemoteEvent(doc("foo/bar", 1, map("sum", 1337)), asList(2), emptyList()));
+    assertChanged(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+    assertContains(doc("foo/bar", 1, map("sum", 1), Document.DocumentState.LOCAL_MUTATIONS));
+  }
 }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
index e53a1389f..63889dfb6 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/LruGarbageCollectorTestCase.java
@@ -40,6 +40,7 @@
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.protobuf.ByteString;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -365,7 +366,7 @@ public void testRemoveOrphanedDocuments() {
         "actually register the mutations",
         () -> {
           Timestamp writeTime = Timestamp.now();
-          mutationQueue.addMutationBatch(writeTime, mutations);
+          mutationQueue.addMutationBatch(writeTime, Collections.emptyList(), mutations);
         });
 
     // Mark 5 documents eligible for GC. This simulates documents that were mutated then ack'd.
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryIndexManagerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryIndexManagerTest.java
new file mode 100644
index 000000000..19b1236e8
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MemoryIndexManagerTest.java
@@ -0,0 +1,28 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class MemoryIndexManagerTest extends IndexManagerTestCase {
+  @Override
+  Persistence getPersistence() {
+    return PersistenceTestHelpers.createEagerGCMemoryPersistence();
+  }
+}
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MutationQueueTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MutationQueueTestCase.java
index ccbbc7f0e..77e8d58b9 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MutationQueueTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/MutationQueueTestCase.java
@@ -40,6 +40,7 @@
 import com.google.firebase.firestore.remote.WriteStream;
 import com.google.protobuf.ByteString;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import org.junit.After;
@@ -190,7 +191,9 @@ public void testAllMutationBatchesAffectingDocumentKey() {
         "New mutation batch",
         () -> {
           for (Mutation mutation : mutations) {
-            batches.add(mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));
+            batches.add(
+                mutationQueue.addMutationBatch(
+                    Timestamp.now(), Collections.emptyList(), asList(mutation)));
           }
         });
 
@@ -218,7 +221,9 @@ public void testAllMutationBatchesAffectingDocumentKeys() {
         "New mutation batch",
         () -> {
           for (Mutation mutation : mutations) {
-            batches.add(mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));
+            batches.add(
+                mutationQueue.addMutationBatch(
+                    Timestamp.now(), Collections.emptyList(), asList(mutation)));
           }
         });
 
@@ -247,7 +252,9 @@ public void testAllMutationBatchesAffectingDocumentLotsOfDocumentKeys() {
         "New mutation batch",
         () -> {
           for (Mutation mutation : mutations) {
-            batches.add(mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));
+            batches.add(
+                mutationQueue.addMutationBatch(
+                    Timestamp.now(), Collections.emptyList(), asList(mutation)));
           }
         });
 
@@ -283,7 +290,9 @@ public void testAllMutationBatchesAffectingQuery() {
         "New mutation batch",
         () -> {
           for (Mutation mutation : mutations) {
-            batches.add(mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));
+            batches.add(
+                mutationQueue.addMutationBatch(
+                    Timestamp.now(), Collections.emptyList(), asList(mutation)));
           }
         });
 
@@ -307,10 +316,12 @@ public void testAllMutationBatchesAffectingQuery_withCompoundBatches() {
           batches.add(
               mutationQueue.addMutationBatch(
                   Timestamp.now(),
+                  Collections.emptyList(),
                   asList(setMutation("foo/bar", value), setMutation("foo/bar/baz/quux", value))));
           batches.add(
               mutationQueue.addMutationBatch(
                   Timestamp.now(),
+                  Collections.emptyList(),
                   asList(setMutation("foo/bar", value), setMutation("foo/baz", value))));
         });
 
@@ -401,7 +412,9 @@ private MutationBatch addMutationBatch(String key) {
 
     return persistence.runTransaction(
         "New mutation batch",
-        () -> mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));
+        () ->
+            mutationQueue.addMutationBatch(
+                Timestamp.now(), Collections.emptyList(), asList(mutation)));
   }
 
   /**
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteIndexManagerTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteIndexManagerTest.java
new file mode 100644
index 000000000..3ea18b5a3
--- /dev/null
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteIndexManagerTest.java
@@ -0,0 +1,28 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.firestore.local;
+
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class SQLiteIndexManagerTest extends IndexManagerTestCase {
+  @Override
+  Persistence getPersistence() {
+    return PersistenceTestHelpers.createSQLitePersistence();
+  }
+}
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
index 17060be2e..5964d94ea 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/local/SQLiteSchemaTest.java
@@ -14,6 +14,11 @@
 
 package com.google.firebase.firestore.local;
 
+import static com.google.firebase.firestore.local.EncodedPath.decodeResourcePath;
+import static com.google.firebase.firestore.local.EncodedPath.encode;
+import static com.google.firebase.firestore.testutil.TestUtil.map;
+import static com.google.firebase.firestore.testutil.TestUtil.path;
+import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -27,8 +32,10 @@
 import com.google.firebase.firestore.proto.WriteBatch;
 import com.google.firestore.v1.Document;
 import com.google.firestore.v1.Write;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.junit.After;
@@ -243,7 +250,7 @@ private void addMutationBatch(SQLiteDatabase db, int batchId, String uid, String
     for (String doc : docs) {
       db.execSQL(
           "INSERT INTO document_mutations (uid, path, batch_id) VALUES (?, ?, ?)",
-          new Object[] {uid, EncodedPath.encode(ResourcePath.fromString(doc)), batchId});
+          new Object[] {uid, encode(ResourcePath.fromString(doc)), batchId});
 
       write.addWrites(
           Write.newBuilder()
@@ -300,6 +307,57 @@ public void addsSentinelRows() {
             });
   }
 
+  @Test
+  public void canCreateCollectionParentsIndex() {
+    // This test creates a database with schema version 7 that has a few
+    // mutations and a few remote documents and then ensures that appropriate
+    // entries are written to the collectionParentIndex.
+    List<String> writePaths = asList("cg1/x", "cg1/y", "cg1/x/cg1/x", "cg2/x", "cg1/x/cg2/x");
+    List<String> remoteDocPaths =
+        asList("cg1/z", "cg1/y/cg1/x", "cg2/x/cg3/x", "blah/x/blah/x/cg3/x");
+    Map<String, List<String>> expectedParents =
+        map(
+            "cg1", asList("", "cg1/x", "cg1/y"),
+            "cg2", asList("", "cg1/x"),
+            "cg3", asList("blah/x/blah/x", "cg2/x"));
+
+    schema.runMigrations(0, 7);
+    // Write mutations.
+    int batchId = 1;
+    for (String writePath : writePaths) {
+      addMutationBatch(db, batchId++, "user", writePath);
+    }
+    // Write remote document entries.
+    for (String remoteDocPath : remoteDocPaths) {
+      db.execSQL(
+          "INSERT INTO remote_documents (path) VALUES (?)",
+          new String[] {encode(path(remoteDocPath))});
+    }
+
+    // Migrate to v8 and verify index entries.
+    schema.runMigrations(7, 8);
+    Map<String, List<String>> actualParents = new HashMap<>();
+    new SQLitePersistence.Query(db, "SELECT collection_id, parent FROM collection_parents")
+        .forEach(
+            row -> {
+              String collectionId = row.getString(0);
+              String parent = decodeResourcePath(row.getString(1)).toString();
+              List<String> parents = actualParents.get(collectionId);
+              if (parents == null) {
+                parents = new ArrayList<>();
+                actualParents.put(collectionId, parents);
+              }
+              parents.add(parent);
+            });
+
+    // Sort results.
+    for (List<String> parents : actualParents.values()) {
+      parents.sort(String::compareTo);
+    }
+
+    assertEquals(expectedParents, actualParents);
+  }
+
   private void assertNoResultsForQuery(String query, String[] args) {
     Cursor cursor = null;
     try {
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
index 67c1fba0a..03733eed4 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/model/MutationTest.java
@@ -41,12 +41,14 @@
 import com.google.firebase.firestore.model.mutation.PatchMutation;
 import com.google.firebase.firestore.model.mutation.Precondition;
 import com.google.firebase.firestore.model.mutation.TransformMutation;
+import com.google.firebase.firestore.model.value.IntegerValue;
 import com.google.firebase.firestore.model.value.ObjectValue;
 import com.google.firebase.firestore.model.value.ServerTimestampValue;
 import com.google.firebase.firestore.model.value.StringValue;
 import com.google.firebase.firestore.model.value.TimestampValue;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -167,6 +169,138 @@ public void testAppliesLocalServerTimestampTransformsToDocuments() {
     assertEquals(expectedDoc, transformedDoc);
   }
 
+  @Test
+  public void testAppliesIncrementTransformToDocument() {
+    Map<String, Object> baseDoc =
+        map(
+            "longPlusLong",
+            1,
+            "longPlusDouble",
+            2,
+            "doublePlusLong",
+            3.3,
+            "doublePlusDouble",
+            4.0,
+            "longPlusNan",
+            5,
+            "doublePlusNan",
+            6.6,
+            "longPlusInfinity",
+            7,
+            "doublePlusInfinity",
+            8.8);
+    Map<String, Object> transform =
+        map(
+            "longPlusLong",
+            FieldValue.increment(1),
+            "longPlusDouble",
+            FieldValue.increment(2.2),
+            "doublePlusLong",
+            FieldValue.increment(3),
+            "doublePlusDouble",
+            FieldValue.increment(4.4),
+            "longPlusNan",
+            FieldValue.increment(Double.NaN),
+            "doublePlusNan",
+            FieldValue.increment(Double.NaN),
+            "longPlusInfinity",
+            FieldValue.increment(Double.POSITIVE_INFINITY),
+            "doublePlusInfinity",
+            FieldValue.increment(Double.POSITIVE_INFINITY));
+    Map<String, Object> expected =
+        map(
+            "longPlusLong",
+            2L,
+            "longPlusDouble",
+            4.2D,
+            "doublePlusLong",
+            6.3D,
+            "doublePlusDouble",
+            8.4D,
+            "longPlusNan",
+            Double.NaN,
+            "doublePlusNan",
+            Double.NaN,
+            "longPlusInfinity",
+            Double.POSITIVE_INFINITY,
+            "doublePlusInfinity",
+            Double.POSITIVE_INFINITY);
+
+    verifyTransform(baseDoc, transform, expected);
+  }
+
+  @Test
+  public void testAppliesIncrementTransformToUnexpectedType() {
+    Map<String, Object> baseDoc = map("string", "zero");
+    Map<String, Object> transform = map("string", FieldValue.increment(1));
+    Map<String, Object> expected = map("string", 1);
+    verifyTransform(baseDoc, transform, expected);
+  }
+
+  @Test
+  public void testAppliesIncrementTransformToMissingField() {
+    Map<String, Object> baseDoc = map();
+    Map<String, Object> transform = map("missing", FieldValue.increment(1));
+    Map<String, Object> expected = map("missing", 1);
+    verifyTransform(baseDoc, transform, expected);
+  }
+
+  @Test
+  public void testAppliesIncrementTransformsConsecutively() {
+    Map<String, Object> baseDoc = map("number", 1);
+    Map<String, Object> transform1 = map("number", FieldValue.increment(2));
+    Map<String, Object> transform2 = map("number", FieldValue.increment(3));
+    Map<String, Object> transform3 = map("number", FieldValue.increment(4));
+    Map<String, Object> expected = map("number", 10);
+    verifyTransform(baseDoc, Arrays.asList(transform1, transform2, transform3), expected);
+  }
+
+  @Test
+  public void testAppliesIncrementWithoutOverflow() {
+    Map<String, Object> baseDoc =
+        map(
+            "a",
+            Long.MAX_VALUE - 1,
+            "b",
+            Long.MAX_VALUE - 1,
+            "c",
+            Long.MAX_VALUE,
+            "d",
+            Long.MAX_VALUE);
+    Map<String, Object> transform =
+        map(
+            "a", FieldValue.increment(1),
+            "b", FieldValue.increment(Long.MAX_VALUE),
+            "c", FieldValue.increment(1),
+            "d", FieldValue.increment(Long.MAX_VALUE));
+    Map<String, Object> expected =
+        map("a", Long.MAX_VALUE, "b", Long.MAX_VALUE, "c", Long.MAX_VALUE, "d", Long.MAX_VALUE);
+    verifyTransform(baseDoc, transform, expected);
+  }
+
+  @Test
+  public void testAppliesIncrementWithoutUnderflow() {
+    Map<String, Object> baseDoc =
+        map(
+            "a",
+            Long.MIN_VALUE + 1,
+            "b",
+            Long.MIN_VALUE + 1,
+            "c",
+            Long.MIN_VALUE,
+            "d",
+            Long.MIN_VALUE);
+    Map<String, Object> transform =
+        map(
+            "a", FieldValue.increment(-1),
+            "b", FieldValue.increment(Long.MIN_VALUE),
+            "c", FieldValue.increment(-1),
+            "d", FieldValue.increment(Long.MIN_VALUE));
+    Map<String, Object> expected =
+        map("a", Long.MIN_VALUE, "b", Long.MIN_VALUE, "c", Long.MIN_VALUE, "d", Long.MIN_VALUE);
+    verifyTransform(baseDoc, transform, expected);
+  }
+
   // NOTE: This is more a test of UserDataConverter code than Mutation code but we don't have unit
   // tests for it currently. We could consider removing this test once we have integration tests.
   @Test
@@ -325,15 +459,42 @@ public void testAppliesLocalArrayRemoveTransformWithNonPrimitiveElements() {
 
   private void verifyTransform(
       Map<String, Object> baseData,
-      Map<String, Object> transformData,
+      List<Map<String, Object>> transforms,
       Map<String, Object> expectedData) {
-    Document baseDoc = doc("collection/key", 0, baseData);
-    TransformMutation transform = transformMutation("collection/key", transformData);
-    MaybeDocument transformedDoc = transform.applyToLocalView(baseDoc, baseDoc, Timestamp.now());
+    MaybeDocument currentDoc = doc("collection/key", 0, baseData);
+
+    for (Map<String, Object> transformData : transforms) {
+      TransformMutation transform = transformMutation("collection/key", transformData);
+      currentDoc = transform.applyToLocalView(currentDoc, currentDoc, Timestamp.now());
+    }
 
     Document expectedDoc =
         doc("collection/key", 0, expectedData, Document.DocumentState.LOCAL_MUTATIONS);
-    assertEquals(expectedDoc, transformedDoc);
+    assertEquals(expectedDoc, currentDoc);
+  }
+
+  private void verifyTransform(
+      Map<String, Object> baseData,
+      Map<String, Object> transformData,
+      Map<String, Object> expectedData) {
+    verifyTransform(baseData, Collections.singletonList(transformData), expectedData);
+  }
+
+  @Test
+  public void testAppliesServerAckedIncrementTransformToDocuments() {
+    Map<String, Object> data = map("sum", 1);
+    Document baseDoc = doc("collection/key", 0, data);
+
+    Mutation transform = transformMutation("collection/key", map("sum", FieldValue.increment(2)));
+    MutationResult mutationResult =
+        new MutationResult(version(1), Collections.singletonList(IntegerValue.valueOf(3L)));
+
+    MaybeDocument transformedDoc = transform.applyToRemoteDocument(baseDoc, mutationResult);
+
+    Map<String, Object> expectedData = map("sum", 3L);
+    assertEquals(
+        doc("collection/key", 1, expectedData, Document.DocumentState.COMMITTED_MUTATIONS),
+        transformedDoc);
   }
 
   @Test
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
index 24a9ec75d..74427d95c 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/spec/SpecTestCase.java
@@ -323,7 +323,9 @@ private Query parseQuery(Object querySpec) throws JSONException {
     } else if (querySpec instanceof JSONObject) {
       JSONObject queryDict = (JSONObject) querySpec;
       String path = queryDict.getString("path");
-      Query query = Query.atPath(ResourcePath.fromString(path));
+      String collectionGroup =
+          queryDict.has("collectionGroup") ? queryDict.getString("collectionGroup") : null;
+      Query query = new Query(ResourcePath.fromString(path), collectionGroup);
       if (queryDict.has("limit")) {
         query = query.limit(queryDict.getLong("limit"));
       }
diff --git a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
index 53afbeec0..ce62718a4 100644
--- a/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
+++ b/firebase-firestore/src/test/java/com/google/firebase/firestore/util/MapperTest.java
@@ -1442,7 +1442,9 @@ public void serializeBooleanBean() {
   public void serializeFloatBean() {
     FloatBean bean = new FloatBean();
     bean.value = 0.5f;
-    assertJson("{'value': 0.5}", serialize(bean));
+
+    // We don't use assertJson as it converts all floating point numbers to Double.
+    assertEquals(map("value", 0.5f), serialize(bean));
   }
 
   @Test
@@ -1696,7 +1698,7 @@ public void shortsCantBeSerialized() {
     ShortBean bean = new ShortBean();
     bean.value = 1;
     assertExceptionContains(
-        "Shorts are not supported, please use int or long (found in field 'value')",
+        "Numbers of type Short are not supported, please use an int, long, float or double (found in field 'value')",
         () -> serialize(bean));
   }
 
@@ -1705,7 +1707,7 @@ public void bytesCantBeSerialized() {
     ByteBean bean = new ByteBean();
     bean.value = 1;
     assertExceptionContains(
-        "Bytes are not supported, please use int or long (found in field 'value')",
+        "Numbers of type Byte are not supported, please use an int, long, float or double (found in field 'value')",
         () -> serialize(bean));
   }
 
@@ -1714,7 +1716,7 @@ public void charsCantBeSerialized() {
     CharBean bean = new CharBean();
     bean.value = 1;
     assertExceptionContains(
-        "Characters are not supported, please use Strings. (found in field 'value')",
+        "Characters are not supported, please use Strings (found in field 'value')",
         () -> serialize(bean));
   }
 
@@ -1741,21 +1743,21 @@ public void objectArraysCantBeSerialized() {
   @Test
   public void shortsCantBeDeserialized() {
     assertExceptionContains(
-        "Deserializing to shorts is not supported (found in field 'value')",
+        "Deserializing values to short is not supported (found in field 'value')",
         () -> deserialize("{'value': 1}", ShortBean.class));
   }
 
   @Test
   public void bytesCantBeDeserialized() {
     assertExceptionContains(
-        "Deserializing to bytes is not supported (found in field 'value')",
+        "Deserializing values to byte is not supported (found in field 'value')",
         () -> deserialize("{'value': 1}", ByteBean.class));
   }
 
   @Test
   public void charsCantBeDeserialized() {
     assertExceptionContains(
-        "Deserializing to chars is not supported (found in field 'value')",
+        "Deserializing values to char is not supported (found in field 'value')",
         () -> deserialize("{'value': '1'}", CharBean.class));
   }
 
@@ -1862,21 +1864,21 @@ public void passingInMapTopLevelThrows() {
   @Test
   public void passingInCharacterTopLevelThrows() {
     assertExceptionContains(
-        "Deserializing to chars is not supported",
+        "Deserializing values to Character is not supported",
         () -> CustomClassMapper.convertToCustomClass('1', Character.class));
   }
 
   @Test
   public void passingInShortTopLevelThrows() {
     assertExceptionContains(
-        "Deserializing to shorts is not supported",
+        "Deserializing values to Short is not supported",
         () -> CustomClassMapper.convertToCustomClass(1, Short.class));
   }
 
   @Test
   public void passingInByteTopLevelThrows() {
     assertExceptionContains(
-        "Deserializing to bytes is not supported",
+        "Deserializing values to Byte is not supported",
         () -> CustomClassMapper.convertToCustomClass(1, Byte.class));
   }
 
@@ -2220,8 +2222,8 @@ public void serializationFailureIncludesPath() {
       fail("should have thrown");
     } catch (RuntimeException e) {
       assertEquals(
-          "Could not serialize object. Shorts are not supported, please use int or "
-              + "long (found in field 'value.inner.value.short')",
+          "Could not serialize object. Numbers of type Short are not supported, please use an int, "
+              + "long, float or double (found in field 'value.inner.value.short')",
           e.getMessage());
     }
   }
@@ -2235,7 +2237,7 @@ public void deserializationFailureIncludesPath() {
       fail("should have thrown");
     } catch (RuntimeException e) {
       assertEquals(
-          "Could not deserialize object. Deserializing to shorts is not supported "
+          "Could not deserialize object. Deserializing values to short is not supported "
               + "(found in field 'value')",
           e.getMessage());
     }
diff --git a/firebase-firestore/src/test/resources/json/query_spec_test.json b/firebase-firestore/src/test/resources/json/query_spec_test.json
new file mode 100644
index 000000000..4ca89f24c
--- /dev/null
+++ b/firebase-firestore/src/test/resources/json/query_spec_test.json
@@ -0,0 +1,1170 @@
+{
+  "Collection Group query": {
+    "describeName": "Queries:",
+    "itName": "Collection Group query",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "cg/1",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "cg/1",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "cg/1",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "cg/2",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "cg/2",
+              "version": 1000,
+              "value": {
+                "val": 2
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "cg/2",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/2",
+                "version": 1000,
+                "value": {
+                  "val": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          6,
+          {
+            "path": "not-cg/nope/cg/3",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "not-cg/nope/cg/3",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          6
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "not-cg/nope/cg/3",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            6
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            6
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "not-cg/nope/cg/3",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "not-cg/nope/cg/3",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          8,
+          {
+            "path": "not-cg/nope",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "not-cg/nope/cg/3",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "8": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          8
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "not-cg/nope",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            8
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            8
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "not-cg/nope",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "not-cg/nope",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          10,
+          {
+            "path": "cg/1/not-cg/nope",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "not-cg/nope/cg/3",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "8": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "10": {
+              "query": {
+                "path": "cg/1/not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          10
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "cg/1/not-cg/nope",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            10
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            10
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "cg/1/not-cg/nope",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1/not-cg/nope",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          12,
+          {
+            "path": "",
+            "collectionGroup": "cg",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "not-cg/nope/cg/3",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "8": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "10": {
+              "query": {
+                "path": "cg/1/not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "12": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "",
+              "collectionGroup": "cg",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "cg/2",
+                "version": 1000,
+                "value": {
+                  "val": 2
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "not-cg/nope/cg/3",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          14,
+          {
+            "path": "",
+            "collectionGroup": "cg",
+            "filters": [
+              [
+                "val",
+                "==",
+                1
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "cg/2",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "not-cg/nope/cg/3",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "8": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "10": {
+              "query": {
+                "path": "cg/1/not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "12": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "14": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [
+                  [
+                    "val",
+                    "==",
+                    1
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "",
+              "collectionGroup": "cg",
+              "filters": [
+                [
+                  "val",
+                  "==",
+                  1
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "not-cg/nope/cg/3",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": false
+          }
+        ]
+      }
+    ]
+  },
+  "Collection Group query with mutations": {
+    "describeName": "Queries:",
+    "itName": "Collection Group query with mutations",
+    "tags": [],
+    "config": {
+      "useGarbageCollection": true,
+      "numClients": 1
+    },
+    "steps": [
+      {
+        "userListen": [
+          2,
+          {
+            "path": "cg/1",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          2
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "cg/1",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            2
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            2
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "cg/1",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userListen": [
+          4,
+          {
+            "path": "not-cg/nope",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        }
+      },
+      {
+        "watchAck": [
+          4
+        ]
+      },
+      {
+        "watchEntity": {
+          "docs": [
+            {
+              "key": "not-cg/nope",
+              "version": 1000,
+              "value": {
+                "val": 1
+              },
+              "options": {
+                "hasLocalMutations": false,
+                "hasCommittedMutations": false
+              }
+            }
+          ],
+          "targets": [
+            4
+          ]
+        }
+      },
+      {
+        "watchCurrent": [
+          [
+            4
+          ],
+          "resume-token-1000"
+        ]
+      },
+      {
+        "watchSnapshot": {
+          "version": 1000,
+          "targetIds": []
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "not-cg/nope",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "not-cg/nope",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": false,
+            "hasPendingWrites": false
+          }
+        ]
+      },
+      {
+        "userSet": [
+          "cg/2",
+          {
+            "val": 2
+          }
+        ]
+      },
+      {
+        "userSet": [
+          "not-cg/nope/cg/3",
+          {
+            "val": 1
+          }
+        ]
+      },
+      {
+        "userSet": [
+          "not-cg2/nope",
+          {
+            "val": 1
+          }
+        ]
+      },
+      {
+        "userListen": [
+          6,
+          {
+            "path": "",
+            "collectionGroup": "cg",
+            "filters": [],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "",
+              "collectionGroup": "cg",
+              "filters": [],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "cg/2",
+                "version": 0,
+                "value": {
+                  "val": 2
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "not-cg/nope/cg/3",
+                "version": 0,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": true
+          }
+        ]
+      },
+      {
+        "userListen": [
+          8,
+          {
+            "path": "",
+            "collectionGroup": "cg",
+            "filters": [
+              [
+                "val",
+                "==",
+                1
+              ]
+            ],
+            "orderBys": []
+          }
+        ],
+        "stateExpect": {
+          "activeTargets": {
+            "2": {
+              "query": {
+                "path": "cg/1",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "4": {
+              "query": {
+                "path": "not-cg/nope",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "6": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            },
+            "8": {
+              "query": {
+                "path": "",
+                "collectionGroup": "cg",
+                "filters": [
+                  [
+                    "val",
+                    "==",
+                    1
+                  ]
+                ],
+                "orderBys": []
+              },
+              "resumeToken": ""
+            }
+          }
+        },
+        "expect": [
+          {
+            "query": {
+              "path": "",
+              "collectionGroup": "cg",
+              "filters": [
+                [
+                  "val",
+                  "==",
+                  1
+                ]
+              ],
+              "orderBys": []
+            },
+            "added": [
+              {
+                "key": "cg/1",
+                "version": 1000,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": false,
+                  "hasCommittedMutations": false
+                }
+              },
+              {
+                "key": "not-cg/nope/cg/3",
+                "version": 0,
+                "value": {
+                  "val": 1
+                },
+                "options": {
+                  "hasLocalMutations": true,
+                  "hasCommittedMutations": false
+                }
+              }
+            ],
+            "errorCode": 0,
+            "fromCache": true,
+            "hasPendingWrites": true
+          }
+        ]
+      }
+    ]
+  }
+}
diff --git a/firebase-functions/proguard.txt b/firebase-functions/proguard.txt
index 4fd680982..fdf55edd5 100644
--- a/firebase-functions/proguard.txt
+++ b/firebase-functions/proguard.txt
@@ -1 +1,17 @@
 -dontwarn okio.**
+
+# These rules come from:
+# https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
+
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
+
diff --git a/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle b/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
index d17875974..5b3a0779a 100644
--- a/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
+++ b/firebase-inappmessaging-display/firebase-inappmessaging-display.gradle
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 apply plugin: "com.android.library"
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
     compileSdkVersion project.targetSdkVersion
diff --git a/firebase-storage/CHANGELOG.md b/firebase-storage/CHANGELOG.md
new file mode 100644
index 000000000..e44a20234
--- /dev/null
+++ b/firebase-storage/CHANGELOG.md
@@ -0,0 +1,6 @@
+# Unreleased
+- [changed] Added `@RestrictTo` annotations to discourage the use of APIs that
+  are not public. This affects internal APIs that were previously obfuscated
+  and are not mentioned in our documentation.
+- [internal] Updated the SDK initialization process and removed usages of
+  deprecated methods.
diff --git a/firebase-storage/firebase-storage.gradle b/firebase-storage/firebase-storage.gradle
index a1b5f9391..aa4482f37 100644
--- a/firebase-storage/firebase-storage.gradle
+++ b/firebase-storage/firebase-storage.gradle
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 apply plugin: 'com.android.library'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
 
 android {
     adbOptions {
@@ -69,6 +70,9 @@ dependencies {
 
     implementation "com.google.android.gms:play-services-base:$playServicesVersion"
     implementation "com.google.android.gms:play-services-tasks:$playServicesVersion"
+    implementation('com.google.firebase:firebase-auth-interop:16.0.1') {
+        exclude group: "com.google.firebase", module: "firebase-common"
+    }
 
     androidTestImplementation "com.android.support:support-annotations:$supportAnnotationsVersion"
     androidTestImplementation 'com.android.support.test:rules:1.0.2'
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
index 5920f9e80..5d863cf5f 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/DeleteStorageTask.java
@@ -15,6 +15,7 @@
 package com.google.firebase.storage;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.RestrictTo;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.tasks.TaskCompletionSource;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
@@ -34,16 +35,20 @@
   private TaskCompletionSource<Void> mPendingResult;
   private ExponentialBackoffSender mSender;
 
+  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
   public DeleteStorageTask(
       @NonNull StorageReference storageRef, @NonNull TaskCompletionSource<Void> pendingResult) {
     Preconditions.checkNotNull(storageRef);
     Preconditions.checkNotNull(pendingResult);
     this.mStorageRef = storageRef;
     this.mPendingResult = pendingResult;
+
+    FirebaseStorage storage = mStorageRef.getStorage();
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getStorage().getApp(),
-            mStorageRef.getStorage().getMaxOperationRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxDownloadRetryTimeMillis());
   }
 
   @Override
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
index 1434d88b0..59d20f403 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FileDownloadTask.java
@@ -49,10 +49,13 @@
   /*package*/ FileDownloadTask(@NonNull StorageReference storageRef, @NonNull Uri destinationFile) {
     mStorageRef = storageRef;
     mDestinationFile = destinationFile;
+
+    FirebaseStorage storage = mStorageRef.getStorage();
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getStorage().getApp(),
-            mStorageRef.getStorage().getMaxDownloadRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxDownloadRetryTimeMillis());
   }
 
   /** @return the number of bytes downloaded so far into the file. */
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
index 9fbe41bb6..367b5aaeb 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorage.java
@@ -21,14 +21,13 @@
 import android.text.format.DateUtils;
 import android.util.Log;
 import com.google.android.gms.common.internal.Preconditions;
-import com.google.android.gms.common.util.VisibleForTesting;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
 import com.google.firebase.annotations.PublicApi;
+import com.google.firebase.auth.internal.InternalAuthProvider;
+import com.google.firebase.inject.Provider;
 import com.google.firebase.storage.internal.Util;
 import java.io.UnsupportedEncodingException;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * FirebaseStorage is a service that supports uploading and downloading large objects to Google
@@ -44,20 +43,23 @@
 @PublicApi
 public class FirebaseStorage {
   private static final String TAG = "FirebaseStorage";
-  private static final Map<String /* App name */, Map<String /* StorageBucket */, FirebaseStorage>>
-      mStorageMap = new HashMap<>();
   private static final String STORAGE_URI_PARSE_EXCEPTION = "The storage Uri could not be parsed.";
   private static final String STORAGE_BUCKET_WITH_PATH_EXCEPTION =
       "The storage Uri cannot contain a path element.";
   @NonNull private final FirebaseApp mApp;
+  @Nullable private final Provider<InternalAuthProvider> mAuthProvider;
   @Nullable private final String mBucketName;
   private long sMaxUploadRetry = 10 * DateUtils.MINUTE_IN_MILLIS; //  10 * 60 * 1000
   private long sMaxDownloadRetry = 10 * DateUtils.MINUTE_IN_MILLIS; //  10 * 60 * 1000
   private long sMaxQueryRetry = 2 * DateUtils.MINUTE_IN_MILLIS; //  2 * 60 * 1000
 
-  private FirebaseStorage(@Nullable String bucketName, @NonNull FirebaseApp app) {
+  FirebaseStorage(
+      @Nullable String bucketName,
+      @NonNull FirebaseApp app,
+      @Nullable Provider<InternalAuthProvider> authProvider) {
     mBucketName = bucketName;
     mApp = app;
+    mAuthProvider = authProvider;
   }
 
   private static FirebaseStorage getInstanceImpl(@NonNull FirebaseApp app, @Nullable Uri url) {
@@ -67,19 +69,10 @@ private static FirebaseStorage getInstanceImpl(@NonNull FirebaseApp app, @Nullab
       throw new IllegalArgumentException(STORAGE_BUCKET_WITH_PATH_EXCEPTION);
     }
 
-    synchronized (mStorageMap) {
-      Map<String, FirebaseStorage> storageBuckets = mStorageMap.get(app.getName());
-      if (storageBuckets == null) {
-        storageBuckets = new HashMap<>();
-        mStorageMap.put(app.getName(), storageBuckets);
-      }
-      FirebaseStorage storage = storageBuckets.get(bucketName);
-      if (storage == null) {
-        storage = new FirebaseStorage(bucketName, app);
-        storageBuckets.put(bucketName, storage);
-      }
-      return storage;
-    }
+    Preconditions.checkNotNull(app, "Provided FirebaseApp must not be null.");
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    Preconditions.checkNotNull(component, "Firebase Storage component is not present.");
+    return component.get(bucketName);
   }
 
   /**
@@ -151,6 +144,8 @@ public static FirebaseStorage getInstance(@NonNull FirebaseApp app) {
   public static FirebaseStorage getInstance(@NonNull FirebaseApp app, @NonNull String url) {
     // noinspection ConstantConditions
     Preconditions.checkArgument(app != null, "Null is not a valid value for the FirebaseApp.");
+    Preconditions.checkArgument(
+        url != null, "Null is not a valid value for the Firebase Storage URL.");
 
     if (!url.toLowerCase().startsWith("gs://")) {
       throw new IllegalArgumentException(
@@ -165,14 +160,6 @@ public static FirebaseStorage getInstance(@NonNull FirebaseApp app, @NonNull Str
     }
   }
 
-  /** @hide */
-  @VisibleForTesting
-  static void clearInstancesForTest() {
-    synchronized (mStorageMap) {
-      mStorageMap.clear();
-    }
-  }
-
   /**
    * Returns the maximum time to retry a download if a failure occurs.
    *
@@ -331,4 +318,9 @@ private StorageReference getReference(@NonNull Uri uri) {
   public FirebaseApp getApp() {
     return mApp;
   }
+
+  @Nullable
+  InternalAuthProvider getAuthProvider() {
+    return mAuthProvider != null ? mAuthProvider.get() : null;
+  }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java
new file mode 100644
index 000000000..4f9c47bb8
--- /dev/null
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/FirebaseStorageComponent.java
@@ -0,0 +1,54 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.firebase.storage;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.auth.internal.InternalAuthProvider;
+import com.google.firebase.inject.Provider;
+import java.util.HashMap;
+import java.util.Map;
+
+class FirebaseStorageComponent {
+  /** A map from storage buckets to Firebase Storage instances. */
+  private final Map<String, FirebaseStorage> instances = new HashMap<>();
+
+  private final FirebaseApp app;
+  @Nullable private final Provider<InternalAuthProvider> authProvider;
+
+  FirebaseStorageComponent(
+      @NonNull FirebaseApp app, @Nullable Provider<InternalAuthProvider> authProvider) {
+    this.app = app;
+    this.authProvider = authProvider;
+  }
+
+  /** Provides instances of Firebase Storage for given bucket names. */
+  @NonNull
+  synchronized FirebaseStorage get(@Nullable String bucketName) {
+    FirebaseStorage storage = instances.get(bucketName);
+    if (storage == null) {
+      storage = new FirebaseStorage(bucketName, app, authProvider);
+      instances.put(bucketName, storage);
+    }
+    return storage;
+  }
+
+  @VisibleForTesting
+  synchronized void clearInstancesForTesting() {
+    instances.clear();
+  }
+}
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
index 172948cc8..d68783745 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/GetDownloadUrlTask.java
@@ -44,10 +44,13 @@
 
     this.storageRef = storageRef;
     this.pendingResult = pendingResult;
+
+    FirebaseStorage storage = this.storageRef.getStorage();
     sender =
         new ExponentialBackoffSender(
-            this.storageRef.getApp(),
-            this.storageRef.getStorage().getMaxOperationRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxOperationRetryTimeMillis());
   }
 
   private Uri extractDownloadUrl(JSONObject response) {
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
index ac4c5c1dd..03ca42f98 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/GetMetadataTask.java
@@ -42,9 +42,13 @@
 
     this.mStorageRef = storageRef;
     this.mPendingResult = pendingResult;
+
+    FirebaseStorage storage = mStorageRef.getStorage();
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxOperationRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxDownloadRetryTimeMillis());
   }
 
   @Override
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
index 03e811670..09aa27c5e 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageRegistrar.java
@@ -15,18 +15,31 @@
 package com.google.firebase.storage;
 
 import android.support.annotation.Keep;
+import android.support.annotation.RestrictTo;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.components.Component;
 import com.google.firebase.components.ComponentRegistrar;
+import com.google.firebase.components.Dependency;
 import com.google.firebase.platforminfo.LibraryVersionComponent;
-import java.util.Collections;
+import java.util.Arrays;
 import java.util.List;
 
 /** @hide */
 @Keep
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public class StorageRegistrar implements ComponentRegistrar {
   @Override
   public List<Component<?>> getComponents() {
-    return Collections.singletonList(
+    return Arrays.asList(
+        Component.builder(FirebaseStorageComponent.class)
+            .add(Dependency.required(FirebaseApp.class))
+            .add(Dependency.optionalProvider(InternalAuthProvider.class))
+            .factory(
+                c ->
+                    new FirebaseStorageComponent(
+                        c.get(FirebaseApp.class), c.getProvider(InternalAuthProvider.class)))
+            .build(),
         LibraryVersionComponent.create("fire-gcs", BuildConfig.VERSION_NAME));
   }
 }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
index d8343b39a..e604404e0 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StorageTaskScheduler.java
@@ -15,6 +15,7 @@
 package com.google.firebase.storage;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.RestrictTo;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadFactory;
@@ -29,6 +30,7 @@
  * @hide
  */
 @SuppressWarnings("JavaDoc")
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
 public class StorageTaskScheduler {
   public static StorageTaskScheduler sInstance = new StorageTaskScheduler();
 
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
index bf9eda48b..5b11fb988 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/StreamDownloadTask.java
@@ -53,9 +53,13 @@
 
   /*package*/ StreamDownloadTask(@NonNull StorageReference storageRef) {
     mStorageRef = storageRef;
+
+    FirebaseStorage storage = mStorageRef.getStorage();
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxDownloadRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxDownloadRetryTimeMillis());
   }
 
   /**
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
index cf62dc3f5..451428f68 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/UpdateMetadataTask.java
@@ -39,9 +39,13 @@ public UpdateMetadataTask(
     this.mStorageRef = storageRef;
     this.mPendingResult = pendingResult;
     mNewMetadata = newMetadata;
+
+    FirebaseStorage storage = mStorageRef.getStorage();
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxOperationRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxOperationRetryTimeMillis());
   }
 
   @Override
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java b/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
index 3a02f0a2f..9a76e0fd3 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/UploadTask.java
@@ -26,6 +26,7 @@
 import com.google.android.gms.common.api.Status;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.firebase.annotations.PublicApi;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.storage.internal.AdaptiveStreamBuffer;
 import com.google.firebase.storage.internal.ExponentialBackoffSender;
 import com.google.firebase.storage.internal.Util;
@@ -61,6 +62,7 @@
   private final AdaptiveStreamBuffer mStreamBuffer;
   // Active, current mutable state.
   private final AtomicLong mBytesUploaded = new AtomicLong(0);
+  @Nullable private final InternalAuthProvider mAuthProvider;
   private int mCurrentChunkSize = PREFERRED_CHUNK_SIZE;
   private ExponentialBackoffSender mSender;
   private boolean mIsStreamOwned;
@@ -74,29 +76,42 @@
   UploadTask(StorageReference targetRef, StorageMetadata metadata, byte[] bytes) {
     Preconditions.checkNotNull(targetRef);
     Preconditions.checkNotNull(bytes);
+
+    FirebaseStorage storage = targetRef.getStorage();
+
     this.mTotalByteCount = bytes.length;
     this.mStorageRef = targetRef;
     this.mMetadata = metadata;
+    this.mAuthProvider = storage.getAuthProvider();
     this.mUri = null;
     this.mStreamBuffer =
         new AdaptiveStreamBuffer(new ByteArrayInputStream(bytes), PREFERRED_CHUNK_SIZE);
     this.mIsStreamOwned = true;
+
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxUploadRetryTimeMillis());
+            storage.getApp().getApplicationContext(),
+            storage.getAuthProvider(),
+            storage.getMaxDownloadRetryTimeMillis());
   }
 
   UploadTask(
       StorageReference targetRef, StorageMetadata metadata, Uri file, Uri existingUploadUri) {
     Preconditions.checkNotNull(targetRef);
     Preconditions.checkNotNull(file);
+
+    FirebaseStorage storage = targetRef.getStorage();
+
     this.mStorageRef = targetRef;
     this.mMetadata = metadata;
+    this.mAuthProvider = storage.getAuthProvider();
     this.mUri = file;
     InputStream inputStream = null;
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxUploadRetryTimeMillis());
+            mStorageRef.getApp().getApplicationContext(),
+            mAuthProvider,
+            storage.getMaxUploadRetryTimeMillis());
     long size = -1;
     try {
       ContentResolver resolver =
@@ -144,15 +159,20 @@
     Preconditions.checkNotNull(targetRef);
     Preconditions.checkNotNull(stream);
 
+    FirebaseStorage storage = targetRef.getStorage();
+
     this.mTotalByteCount = -1;
     this.mStorageRef = targetRef;
     this.mMetadata = metadata;
+    this.mAuthProvider = storage.getAuthProvider();
     this.mStreamBuffer = new AdaptiveStreamBuffer(stream, PREFERRED_CHUNK_SIZE);
     this.mIsStreamOwned = false;
     this.mUri = null;
     mSender =
         new ExponentialBackoffSender(
-            mStorageRef.getApp(), mStorageRef.getStorage().getMaxUploadRetryTimeMillis());
+            mStorageRef.getApp().getApplicationContext(),
+            mAuthProvider,
+            mStorageRef.getStorage().getMaxUploadRetryTimeMillis());
   }
 
   /** @return the target of the upload. */
@@ -448,8 +468,7 @@ private boolean isValidHttpResponseCode(int code) {
 
   private boolean send(NetworkRequest request) {
     request.performRequest(
-        Util.getCurrentAuthToken(mStorageRef.getApp()),
-        mStorageRef.getApp().getApplicationContext());
+        Util.getCurrentAuthToken(mAuthProvider), mStorageRef.getApp().getApplicationContext());
     return processResultValid(request);
   }
 
@@ -485,7 +504,7 @@ protected void onCanceled() {
                 @Override
                 public void run() {
                   finalCancelRequest.performRequest(
-                      Util.getCurrentAuthToken(mStorageRef.getApp()),
+                      Util.getCurrentAuthToken(mAuthProvider),
                       mStorageRef.getApp().getApplicationContext());
                 }
               });
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
index 29e93bd1d..820ba5527 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/ExponentialBackoffSender.java
@@ -14,12 +14,14 @@
 
 package com.google.firebase.storage.internal;
 
+import android.content.Context;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.google.android.gms.common.internal.Preconditions;
 import com.google.android.gms.common.util.Clock;
 import com.google.android.gms.common.util.DefaultClock;
-import com.google.firebase.FirebaseApp;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.storage.network.NetworkRequest;
 import java.util.Random;
 
@@ -34,15 +36,18 @@
   public static final int RND_MAX = 250;
   private static final int NETWORK_STATUS_POLL_INTERVAL = 1000;
   private static final int MAXIMUM_WAIT_TIME_MILLI = 30000;
+  private static final Random random = new Random();
   /*package*/ static Sleeper sleeper = new SleeperImpl();
   /*package*/ static Clock clock = DefaultClock.getInstance();
-  private static Random random = new Random();
-  private FirebaseApp app;
+  private final Context context;
+  @Nullable private final InternalAuthProvider authProvider;
   private long retryTime;
   private volatile boolean canceled;
 
-  public ExponentialBackoffSender(FirebaseApp app, long retryTime) {
-    this.app = app;
+  public ExponentialBackoffSender(
+      Context context, @Nullable InternalAuthProvider authProvider, long retryTime) {
+    this.context = context;
+    this.authProvider = authProvider;
     this.retryTime = retryTime;
   }
 
@@ -62,9 +67,9 @@ public void sendWithExponentialBackoff(
     Preconditions.checkNotNull(request);
     long deadLine = clock.elapsedRealtime() + retryTime;
     if (closeRequest) {
-      request.performRequest(Util.getCurrentAuthToken(app), app.getApplicationContext());
+      request.performRequest(Util.getCurrentAuthToken(authProvider), context);
     } else {
-      request.performRequestStart(Util.getCurrentAuthToken(app));
+      request.performRequestStart(Util.getCurrentAuthToken(authProvider));
     }
 
     int currentSleepTime = NETWORK_STATUS_POLL_INTERVAL;
@@ -95,9 +100,9 @@ public void sendWithExponentialBackoff(
       }
       request.reset();
       if (closeRequest) {
-        request.performRequest(Util.getCurrentAuthToken(app), app.getApplicationContext());
+        request.performRequest(Util.getCurrentAuthToken(authProvider), context);
       } else {
-        request.performRequestStart(Util.getCurrentAuthToken(app));
+        request.performRequestStart(Util.getCurrentAuthToken(authProvider));
       }
     }
   }
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
index 44e26aba7..cbb496a12 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/Util.java
@@ -26,6 +26,7 @@
 import com.google.android.gms.tasks.Tasks;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.auth.GetTokenResult;
+import com.google.firebase.auth.internal.InternalAuthProvider;
 import com.google.firebase.storage.network.NetworkRequest;
 import java.io.UnsupportedEncodingException;
 import java.text.ParseException;
@@ -144,12 +145,17 @@ public static Uri normalize(@NonNull FirebaseApp app, @Nullable String s)
   }
 
   @Nullable
-  public static String getCurrentAuthToken(FirebaseApp app) {
-    Task<GetTokenResult> pendingResult = app.getToken(false);
-    GetTokenResult result;
+  public static String getCurrentAuthToken(@Nullable InternalAuthProvider authProvider) {
     try {
-      result = Tasks.await(pendingResult, MAXIMUM_TOKEN_WAIT_TIME_MS, TimeUnit.MILLISECONDS);
-      String token = result.getToken();
+      String token = null;
+
+      if (authProvider != null) {
+        Task<GetTokenResult> pendingResult = authProvider.getAccessToken(false);
+        GetTokenResult result =
+            Tasks.await(pendingResult, MAXIMUM_TOKEN_WAIT_TIME_MS, TimeUnit.MILLISECONDS);
+        token = result.getToken();
+      }
+
       if (!TextUtils.isEmpty(token)) {
         return token;
       } else {
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
index 5fe4b3654..cd3f36cc0 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/internal/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.storage.internal;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.storage.internal;
+
+import android.support.annotation.RestrictTo;
\ No newline at end of file
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
index 87400aa82..6000a4b34 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/connection/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.storage.network.connection;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.storage.network.connection;
+
+import android.support.annotation.RestrictTo;
\ No newline at end of file
diff --git a/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java b/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
index 5b5c1c2b5..91379e86f 100644
--- a/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
+++ b/firebase-storage/src/main/java/com/google/firebase/storage/network/package-info.java
@@ -13,4 +13,7 @@
 // limitations under the License.
 
 /** @hide */
-package com.google.firebase.storage.network;
\ No newline at end of file
+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+package com.google.firebase.storage.network;
+
+import android.support.annotation.RestrictTo;
\ No newline at end of file
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/DeleteTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/DeleteTest.java
index 76ac10728..2f54a8040 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/DeleteTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/DeleteTest.java
@@ -16,6 +16,8 @@
 
 import android.os.Build;
 import com.google.android.gms.tasks.Task;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.storage.internal.MockClockHelper;
 import com.google.firebase.storage.internal.RobolectricThreadFix;
 import com.google.firebase.storage.network.MockConnectionFactory;
 import com.google.firebase.storage.network.NetworkLayerMock;
@@ -38,15 +40,19 @@
 
   @Rule public FirebaseAppRule firebaseAppRule = new FirebaseAppRule();
 
+  FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    TestUtil.setup();
+    MockClockHelper.install();
+    app = TestUtil.createApp();
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @SuppressWarnings("ConstantConditions")
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/DownloadTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/DownloadTest.java
index 5343d4a1a..8555b0a08 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/DownloadTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/DownloadTest.java
@@ -22,7 +22,9 @@
 import android.net.Uri;
 import android.os.Build;
 import com.google.android.gms.tasks.Task;
+import com.google.firebase.FirebaseApp;
 import com.google.firebase.storage.TestDownloadHelper.StreamDownloadResponse;
+import com.google.firebase.storage.internal.MockClockHelper;
 import com.google.firebase.storage.internal.RobolectricThreadFix;
 import com.google.firebase.storage.network.MockConnectionFactory;
 import com.google.firebase.storage.network.NetworkLayerMock;
@@ -53,15 +55,19 @@
 
   @Rule public TemporaryFolder folder = new TemporaryFolder();
 
+  private FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    TestUtil.setup();
+    MockClockHelper.install();
+    app = TestUtil.createApp();
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @Test
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/MetadataTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/MetadataTest.java
index 93ec78113..2c83cd51b 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/MetadataTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/MetadataTest.java
@@ -16,6 +16,8 @@
 
 import android.os.Build;
 import com.google.android.gms.tasks.Task;
+import com.google.firebase.FirebaseApp;
+import com.google.firebase.storage.internal.MockClockHelper;
 import com.google.firebase.storage.internal.RobolectricThreadFix;
 import com.google.firebase.storage.network.MockConnectionFactory;
 import com.google.firebase.storage.network.NetworkLayerMock;
@@ -38,15 +40,19 @@
   @Rule public RetryRule retryRule = new RetryRule(3);
   @Rule public FirebaseAppRule firebaseAppRule = new FirebaseAppRule();
 
+  private FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    TestUtil.setup();
+    MockClockHelper.install();
+    app = TestUtil.createApp();
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @SuppressWarnings("ConstantConditions")
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/PathingTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/PathingTest.java
index 2719059a3..a334cb036 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/PathingTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/PathingTest.java
@@ -30,7 +30,6 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -43,22 +42,25 @@
   @Rule public RetryRule retryRule = new RetryRule(3);
   @Rule public FirebaseAppRule firebaseAppRule = new FirebaseAppRule();
 
+  FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    FirebaseApp.initializeApp(
-        RuntimeEnvironment.application.getApplicationContext(),
-        new FirebaseOptions.Builder()
-            .setApiKey("AIzaSyCkEhVjf3pduRDt6d1yKOMitrUEke8agEM")
-            .setApplicationId("fooey")
-            .build());
     MockClockHelper.install();
-    MockitoAnnotations.initMocks(this);
+    app =
+        FirebaseApp.initializeApp(
+            RuntimeEnvironment.application.getApplicationContext(),
+            new FirebaseOptions.Builder()
+                .setApiKey("AIzaSyCkEhVjf3pduRDt6d1yKOMitrUEke8agEM")
+                .setApplicationId("fooey")
+                .build());
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @Test
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/StorageReferenceTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/StorageReferenceTest.java
index 8437fcbc6..132a87daa 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/StorageReferenceTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/StorageReferenceTest.java
@@ -20,6 +20,7 @@
 import com.google.android.gms.tasks.Task;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
+import com.google.firebase.storage.internal.MockClockHelper;
 import com.google.firebase.storage.internal.RobolectricThreadFix;
 import com.google.firebase.storage.network.MockConnectionFactory;
 import com.google.firebase.storage.network.NetworkLayerMock;
@@ -43,15 +44,19 @@
   @Rule public RetryRule retryRule = new RetryRule(3);
   @Rule public FirebaseAppRule firebaseAppRule = new FirebaseAppRule();
 
+  private FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    TestUtil.setup();
+    MockClockHelper.install();
+    app = TestUtil.createApp();
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @Test
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java b/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
index 11de7cb07..388aec0aa 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/TestUtil.java
@@ -17,7 +17,6 @@
 import android.support.annotation.Nullable;
 import com.google.firebase.FirebaseApp;
 import com.google.firebase.FirebaseOptions;
-import com.google.firebase.storage.internal.MockClockHelper;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,24 +27,19 @@
 
 /** Test helpers. */
 public class TestUtil {
-  static void setup() throws Exception {
-    FirebaseApp.initializeApp(
+
+  static FirebaseApp createApp() {
+    return FirebaseApp.initializeApp(
         RuntimeEnvironment.application.getApplicationContext(),
         new FirebaseOptions.Builder()
             .setApiKey("AIzaSyCkEhVjf3pduRDt6d1yKOMitrUEke8agEM")
             .setApplicationId("fooey")
             .setStorageBucket("project-5516366556574091405.appspot.com")
             .build());
-    // point to staging.
+    // Point to staging:
     // NetworkRequest.sNetworkRequestUrl = "https://staging-firebasestorage.sandbox.googleapis"
     // + ".com/v0";
     // NetworkRequest.sUploadUrl = "https://staging-firebasestorage.sandbox.googleapis.com/v0/b/";
-
-    MockClockHelper.install();
-  }
-
-  static void unInit() {
-    FirebaseStorage.clearInstancesForTest();
   }
 
   static void verifyTaskStateChanges(
diff --git a/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java b/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
index 33b38e107..a35ff0b89 100644
--- a/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
+++ b/firebase-storage/src/test/java/com/google/firebase/storage/UploadTest.java
@@ -28,6 +28,7 @@
 import com.google.android.gms.tasks.RuntimeExecutionException;
 import com.google.android.gms.tasks.Task;
 import com.google.android.gms.tasks.Tasks;
+import com.google.firebase.FirebaseApp;
 import com.google.firebase.storage.UploadTask.TaskSnapshot;
 import com.google.firebase.storage.internal.MockClockHelper;
 import com.google.firebase.storage.internal.RobolectricThreadFix;
@@ -71,15 +72,19 @@
 
   @Rule public TemporaryFolder folder = new TemporaryFolder();
 
+  private FirebaseApp app;
+
   @Before
   public void setUp() throws Exception {
     RobolectricThreadFix.install();
-    TestUtil.setup();
+    MockClockHelper.install();
+    app = TestUtil.createApp();
   }
 
   @After
   public void tearDown() {
-    TestUtil.unInit();
+    FirebaseStorageComponent component = app.get(FirebaseStorageComponent.class);
+    component.clearInstancesForTesting();
   }
 
   @Test
diff --git a/gradle/googleServices.gradle b/gradle/googleServices.gradle
index 84b5cdb7a..4d41fe2b9 100644
--- a/gradle/googleServices.gradle
+++ b/gradle/googleServices.gradle
@@ -44,11 +44,11 @@ afterEvaluate {
 // somewhere in the task graph (for instance if you ran
 // ./gradlew test at the root project).
 def isTesting = getGradle().getStartParameter().getTaskNames().any({ String taskName ->
-    def hasProjectTestTask = taskName.contains("$name") &&  ['AndroidTest', 'connectedCheck'].any({ taskName.contains(it)})
-    return hasProjectTestTask || taskName.contains('connectedCheck')
+    def hasProjectTestTask = taskName.contains("$name") &&  ['AndroidTest', 'connectedCheck', 'deviceCheck'].any({ taskName.contains(it)})
+    return hasProjectTestTask || taskName.contains('connectedCheck') || taskName.contains('deviceCheck')
 })
 
 if (isTesting) {
     println '[test] applying google-services plugin'
     apply plugin: 'com.google.gms.google-services'
-}
\ No newline at end of file
+}
diff --git a/root-project.gradle b/root-project.gradle
index c7a942d6a..daa31bd21 100644
--- a/root-project.gradle
+++ b/root-project.gradle
@@ -35,6 +35,7 @@ buildscript {
         classpath 'me.tatarka:gradle-retrolambda:3.7.0'
         classpath 'digital.wup:android-maven-publish:3.6.2'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
+        classpath 'org.jlleitschuh.gradle:ktlint-gradle:7.1.0'
     }
 }
 
@@ -121,6 +122,8 @@ configure(subprojects) {
         options.errorprone.excludedPaths = '.*/build/generated/.*'
     }
 
+    apply plugin: "org.jlleitschuh.gradle.ktlint"
+
     // Adds firebase custom errorprone checks to the annotation processor classpath.
     configurations.whenObjectAdded {
         if (it.name == 'annotationProcessor' && project != project(':tools:errorprone')) {
diff --git a/subprojects.cfg b/subprojects.cfg
index 17c46bd55..5302938fb 100644
--- a/subprojects.cfg
+++ b/subprojects.cfg
@@ -3,11 +3,17 @@ firebase-common-ktx
 firebase-database
 firebase-database-collection
 firebase-firestore
+firebase-firestore-ktx
 firebase-functions
 firebase-inappmessaging-display
 fiamui-app
 firebase-storage
 protolite-well-known-types
 
+transport:transport-api
+transport:transport-runtime
+transport:transport-backend-cct
+
+
 tools:apksize
 tools:errorprone
diff --git a/test-apps/functions-test-app/proguard-rules.pro b/test-apps/functions-test-app/proguard-rules.pro
index 6a936373b..0464076e9 100644
--- a/test-apps/functions-test-app/proguard-rules.pro
+++ b/test-apps/functions-test-app/proguard-rules.pro
@@ -2,3 +2,4 @@
 
 -keep class android.support.test.espresso.IdlingResource { *; }
 -keep class android.support.test.espresso.IdlingRegistry { *; }
+
diff --git a/tools/errorprone/src/main/java/com/google/firebase/errorprone/ComponentsAppGetCheck.java b/tools/errorprone/src/main/java/com/google/firebase/errorprone/ComponentsAppGetCheck.java
index 435458bbe..b42c5dbfa 100644
--- a/tools/errorprone/src/main/java/com/google/firebase/errorprone/ComponentsAppGetCheck.java
+++ b/tools/errorprone/src/main/java/com/google/firebase/errorprone/ComponentsAppGetCheck.java
@@ -21,6 +21,7 @@
 import static com.google.errorprone.matchers.Matchers.hasAnnotation;
 import static com.google.errorprone.matchers.Matchers.instanceMethod;
 import static com.google.errorprone.matchers.Matchers.isStatic;
+import static com.google.errorprone.matchers.Matchers.methodHasVisibility;
 import static com.google.errorprone.matchers.Matchers.methodInvocation;
 import static com.google.errorprone.matchers.Matchers.methodIsNamed;
 import static com.google.errorprone.matchers.Matchers.methodReturns;
@@ -34,6 +35,7 @@
 import com.google.errorprone.matchers.AbstractTypeMatcher;
 import com.google.errorprone.matchers.Description;
 import com.google.errorprone.matchers.Matcher;
+import com.google.errorprone.matchers.MethodVisibility;
 import com.google.errorprone.suppliers.Supplier;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.ClassTree;
@@ -85,11 +87,34 @@
                   isSupertypeOf(
                       state -> ASTHelpers.getType(state.findEnclosing(ClassTree.class))))));
 
+  /**
+   * This matches methods of the forms:
+   *
+   * <pre>{@code
+   * class Foo {
+   *     private static Foo getInstanceImpl(/* any number of parameters * /);
+   * }
+   *
+   * class Foo extends/implements Bar {
+   *     private static Bar getInstanceImpl(/* any number of parameters * /);
+   * }
+   * }</pre>
+   */
+  private static final Matcher<ExpressionTree> WITHIN_GET_INSTANCE_IMPL =
+      enclosingMethod(
+          allOf(
+              isStatic(),
+              methodHasVisibility(MethodVisibility.Visibility.PRIVATE),
+              methodIsNamed("getInstanceImpl"),
+              methodReturns(
+                  isSupertypeOf(
+                      state -> ASTHelpers.getType(state.findEnclosing(ClassTree.class))))));
+
   private static final Matcher<ExpressionTree> WITHIN_JUNIT_TEST =
       enclosingClass(hasAnnotation("org.junit.runner.RunWith"));
 
   private static final Matcher<ExpressionTree> ALLOWED_USAGES =
-      anyOf(WITHIN_GET_INSTANCE, WITHIN_JUNIT_TEST);
+      anyOf(WITHIN_GET_INSTANCE, WITHIN_GET_INSTANCE_IMPL, WITHIN_JUNIT_TEST);
 
   @Override
   public Description matchMethodInvocation(MethodInvocationTree tree, VisitorState state) {
diff --git a/transport/transport-api/gradle.properties b/transport/transport-api/gradle.properties
new file mode 100644
index 000000000..e71c90bfe
--- /dev/null
+++ b/transport/transport-api/gradle.properties
@@ -0,0 +1,15 @@
+# Copyright 2018 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+version=16.0.0
\ No newline at end of file
diff --git a/transport/transport-api/src/main/AndroidManifest.xml b/transport/transport-api/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..a78162ff8
--- /dev/null
+++ b/transport/transport-api/src/main/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<!-- Copyright 2018 Google LLC -->
+<!-- -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License"); -->
+<!-- you may not use this file except in compliance with the License. -->
+<!-- You may obtain a copy of the License at -->
+<!-- -->
+<!--      http://www.apache.org/licenses/LICENSE-2.0 -->
+<!-- -->
+<!-- Unless required by applicable law or agreed to in writing, software -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS, -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. -->
+<!-- See the License for the specific language governing permissions and -->
+<!-- limitations under the License. -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+
+    package="com.google.android.datatransport">
+  <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+  <!--<uses-sdk android:minSdkVersion="14"/>-->
+</manifest>
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java b/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java
new file mode 100644
index 000000000..27d5cd152
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/Event.java
@@ -0,0 +1,32 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport;
+
+import com.google.auto.value.AutoValue;
+
+@AutoValue
+public abstract class Event<T> {
+  public abstract T getPayload();
+
+  public abstract Priority getPriority();
+
+  public static <T> Event<T> ofData(T payload, Priority priority) {
+    return new AutoValue_Event<>(payload, priority);
+  }
+
+  public static <T> Event<T> ofTelemetry(T value) {
+    return new AutoValue_Event<>(value, Priority.DEFAULT);
+  }
+}
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/Priority.java b/transport/transport-api/src/main/java/com/google/android/datatransport/Priority.java
new file mode 100644
index 000000000..2b740be5c
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/Priority.java
@@ -0,0 +1,20 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport;
+
+public enum Priority {
+  /** Quality of the service is within an hour. */
+  DEFAULT
+} // TODO add more priorities
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/Transformer.java b/transport/transport-api/src/main/java/com/google/android/datatransport/Transformer.java
new file mode 100644
index 000000000..534d23f57
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/Transformer.java
@@ -0,0 +1,19 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport;
+
+public interface Transformer<T, U> {
+  U apply(T value);
+}
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/Transport.java b/transport/transport-api/src/main/java/com/google/android/datatransport/Transport.java
new file mode 100644
index 000000000..ca6fa6ee6
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/Transport.java
@@ -0,0 +1,29 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport;
+
+/**
+ * Provides means of recording events of interest.
+ *
+ * <p>Event destination is unspecified and depends on concrete implementations of this interface.
+ */
+public interface Transport<T> {
+  /**
+   * Sends the event of type T.
+   *
+   * @param event The event with the payload that needs to be sent.
+   */
+  void send(Event<T> event);
+}
diff --git a/transport/transport-api/src/main/java/com/google/android/datatransport/TransportFactory.java b/transport/transport-api/src/main/java/com/google/android/datatransport/TransportFactory.java
new file mode 100644
index 000000000..c10e1a67b
--- /dev/null
+++ b/transport/transport-api/src/main/java/com/google/android/datatransport/TransportFactory.java
@@ -0,0 +1,28 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport;
+
+/** Each factory is backed by a single transport backend. */
+public interface TransportFactory {
+  /**
+   * Returns a named transport instance that can be used to send values of type T.
+   *
+   * @param name name of the transport.
+   * @param payloadType The type that is sendable by the returned {@link Transport}.
+   * @param payloadTransformer Transformer that converts values of T to byte arrays.
+   */
+  <T> Transport<T> getTransport(
+      String name, Class<T> payloadType, Transformer<T, byte[]> payloadTransformer);
+}
diff --git a/transport/transport-api/transport-api.gradle b/transport/transport-api/transport-api.gradle
new file mode 100644
index 000000000..5d43040b2
--- /dev/null
+++ b/transport/transport-api/transport-api.gradle
@@ -0,0 +1,32 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 28
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 28
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+}
+
+dependencies {
+    api "com.google.auto.value:auto-value-annotations:1.6.2"
+    annotationProcessor "com.google.auto.value:auto-value:1.6.2"
+    testImplementation 'junit:junit:4.12'
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
diff --git a/transport/transport-backend-cct/gradle.properties b/transport/transport-backend-cct/gradle.properties
new file mode 100644
index 000000000..8efae6fc0
--- /dev/null
+++ b/transport/transport-backend-cct/gradle.properties
@@ -0,0 +1,16 @@
+# Copyright 2019 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+version=16.0.0
+firebaseSkipPreguard=false
\ No newline at end of file
diff --git a/transport/transport-backend-cct/preguard.txt b/transport/transport-backend-cct/preguard.txt
new file mode 100644
index 000000000..7b60487ec
--- /dev/null
+++ b/transport/transport-backend-cct/preguard.txt
@@ -0,0 +1,4 @@
+-keep class com.google.android.datatransport.cct.GoogleTransportBackend {
+  public *;
+}
+
diff --git a/transport/transport-backend-cct/src/main/AndroidManifest.xml b/transport/transport-backend-cct/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..d243bd512
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<!-- Copyright 2018 Google LLC -->
+<!-- -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License"); -->
+<!-- you may not use this file except in compliance with the License. -->
+<!-- You may obtain a copy of the License at -->
+<!-- -->
+<!--      http://www.apache.org/licenses/LICENSE-2.0 -->
+<!-- -->
+<!-- Unless required by applicable law or agreed to in writing, software -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS, -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. -->
+<!-- See the License for the specific language governing permissions and -->
+<!-- limitations under the License. -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.datatransport.backend.cct">
+  <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+  <!--<uses-sdk android:minSdkVersion="14"/>-->
+
+  <uses-permission android:name="android.permission.INTERNET" />
+</manifest>
diff --git a/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/GoogleTransportBackend.java b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/GoogleTransportBackend.java
new file mode 100644
index 000000000..ade2f8efe
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/java/com/google/android/datatransport/cct/GoogleTransportBackend.java
@@ -0,0 +1,205 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+import android.os.Build;
+import android.support.annotation.VisibleForTesting;
+import com.google.android.datatransport.cct.proto.AndroidClientInfo;
+import com.google.android.datatransport.cct.proto.BatchedLogRequest;
+import com.google.android.datatransport.cct.proto.ClientInfo;
+import com.google.android.datatransport.cct.proto.LogEvent;
+import com.google.android.datatransport.cct.proto.LogRequest;
+import com.google.android.datatransport.cct.proto.LogResponse;
+import com.google.android.datatransport.cct.proto.QosTierConfiguration;
+import com.google.android.datatransport.runtime.BackendRequest;
+import com.google.android.datatransport.runtime.BackendResponse;
+import com.google.android.datatransport.runtime.BackendResponse.Status;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.TransportBackend;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.UptimeClock;
+import com.google.android.datatransport.runtime.time.WallTimeClock;
+import com.google.protobuf.ByteString;
+import com.google.protobuf.InvalidProtocolBufferException;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.WritableByteChannel;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.GZIPOutputStream;
+
+public class GoogleTransportBackend implements TransportBackend {
+
+  private static final Logger LOGGER = Logger.getLogger(GoogleTransportBackend.class.getName());
+  private static final int CONNECTION_TIME_OUT = 30000;
+  private static final int READ_TIME_OUT = 40000;
+  private static final String CONTENT_ENCODING_HEADER_KEY = "Content-Encoding";
+  private static final String GZIP_CONTENT_ENCODING = "gzip";
+  private static final String CONTENT_TYPE_HEADER_KEY = "Content-Type";
+  private static final String PROTOBUF_CONTENT_TYPE = "application/x-protobuf";
+  private static final String SDK_VERSION_KEY = "SDK Version";
+  private static final String MODEL_KEY = "Model";
+  private static final String HARDWARE_KEY = "Hardware";
+  private static final String DEVICE_KEY = "Device";
+  private static final String PRODUCT_KEY = "Product";
+  private static final String OS_BUILD_KEY = "OS Build";
+  private static final String MANUFACTURER_KEY = "Manufacturer";
+  private static final String FINGERPRINT_KEY = "Fingerprint";
+
+  private final URL endPoint;
+  private final Clock uptimeClock;
+  private final Clock wallTimeClock;
+
+  private static URL parseUrlOrThrow(String url) {
+    try {
+      return new URL(url);
+    } catch (MalformedURLException e) {
+      throw new IllegalArgumentException("Invalid url: " + url, e);
+    }
+  }
+
+  @VisibleForTesting
+  GoogleTransportBackend(String url, Clock wallTimeClock, Clock uptimeClock) {
+    this.endPoint = parseUrlOrThrow(url);
+    this.uptimeClock = uptimeClock;
+    this.wallTimeClock = wallTimeClock;
+  }
+
+  public GoogleTransportBackend() {
+    this("https://play.googleapis.com/log/batch", new WallTimeClock(), new UptimeClock());
+  }
+
+  @Override
+  public EventInternal decorate(EventInternal eventInternal) {
+    return eventInternal
+        .toBuilder()
+        .addMetadata(SDK_VERSION_KEY, String.valueOf(Build.VERSION.SDK_INT))
+        .addMetadata(MODEL_KEY, Build.MODEL)
+        .addMetadata(HARDWARE_KEY, Build.HARDWARE)
+        .addMetadata(DEVICE_KEY, Build.DEVICE)
+        .addMetadata(PRODUCT_KEY, Build.PRODUCT)
+        .addMetadata(OS_BUILD_KEY, Build.ID)
+        .addMetadata(MANUFACTURER_KEY, Build.MANUFACTURER)
+        .addMetadata(FINGERPRINT_KEY, Build.FINGERPRINT)
+        .build();
+  }
+
+  private BatchedLogRequest getRequestBody(BackendRequest backendRequest) {
+    HashMap<String, List<EventInternal>> eventInternalMap = new HashMap<>();
+    for (EventInternal eventInternal : backendRequest.getEvents()) {
+      String key = eventInternal.getTransportName();
+      if (!eventInternalMap.containsKey(key)) {
+        List<EventInternal> eventInternalList = new ArrayList<EventInternal>();
+        eventInternalList.add(eventInternal);
+        eventInternalMap.put(key, eventInternalList);
+      } else {
+        eventInternalMap.get(key).add(eventInternal);
+      }
+    }
+    BatchedLogRequest.Builder batchedRequestBuilder = BatchedLogRequest.newBuilder();
+    for (Map.Entry<String, List<EventInternal>> entry : eventInternalMap.entrySet()) {
+      Map<String, String> metadata = entry.getValue().get(0).getMetadata();
+      LogRequest.Builder requestBuilder =
+          LogRequest.newBuilder()
+              .setLogSource(Integer.valueOf(entry.getKey()))
+              .setQosTier(QosTierConfiguration.QosTier.DEFAULT)
+              .setRequestTimeMs(wallTimeClock.getTime())
+              .setRequestUptimeMs(uptimeClock.getTime())
+              .setClientInfo(
+                  ClientInfo.newBuilder()
+                      .setClientType(ClientInfo.ClientType.ANDROID)
+                      .setAndroidClientInfo(
+                          AndroidClientInfo.newBuilder()
+                              .setSdkVersion(Integer.valueOf(metadata.get(SDK_VERSION_KEY)))
+                              .setModel(metadata.get(MODEL_KEY))
+                              .setHardware(metadata.get(HARDWARE_KEY))
+                              .setDevice(metadata.get(DEVICE_KEY))
+                              .setProduct(metadata.get(PRODUCT_KEY))
+                              .setOsBuild(metadata.get(OS_BUILD_KEY))
+                              .setManufacturer(metadata.get(MANUFACTURER_KEY))
+                              .setFingerprint(metadata.get(FINGERPRINT_KEY))
+                              .build())
+                      .build());
+      for (EventInternal eventInternal : entry.getValue()) {
+        LogEvent event =
+            LogEvent.newBuilder()
+                .setEventTimeMs(eventInternal.getEventMillis())
+                .setEventUptimeMs(eventInternal.getUptimeMillis())
+                // .setTimezoneOffsetSeconds(0) TODO set the time zone offset.
+                .setSourceExtension(ByteString.copyFrom(eventInternal.getPayload()))
+                .build();
+        requestBuilder.addLogEvent(event);
+      }
+      batchedRequestBuilder.addLogRequest(requestBuilder.build());
+    }
+    return batchedRequestBuilder.build();
+  }
+
+  private BackendResponse doSend(BatchedLogRequest requestBody) throws IOException {
+    long nextRequestMillis = -1;
+    HttpURLConnection connection = (HttpURLConnection) endPoint.openConnection();
+    connection.setConnectTimeout(CONNECTION_TIME_OUT);
+    connection.setReadTimeout(READ_TIME_OUT);
+    connection.setDoOutput(true);
+    connection.setInstanceFollowRedirects(false);
+    connection.setRequestMethod("POST");
+    connection.setRequestProperty(CONTENT_ENCODING_HEADER_KEY, GZIP_CONTENT_ENCODING);
+    connection.setRequestProperty(CONTENT_TYPE_HEADER_KEY, PROTOBUF_CONTENT_TYPE);
+    try (WritableByteChannel channel = Channels.newChannel(connection.getOutputStream())) {
+      ByteArrayOutputStream output = new ByteArrayOutputStream();
+      try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(output)) {
+        requestBody.writeTo(gzipOutputStream);
+      }
+      channel.write(ByteBuffer.wrap(output.toByteArray()));
+      int responseCode = connection.getResponseCode();
+      LOGGER.info("Status Code: " + responseCode);
+      try (InputStream inputStream = connection.getInputStream()) {
+        try {
+          nextRequestMillis = LogResponse.parseFrom(inputStream).getNextRequestWaitMillis();
+        } catch (InvalidProtocolBufferException e) {
+          return BackendResponse.create(Status.NONTRANSIENT_ERROR, -1);
+        }
+      }
+      if (responseCode == 200) {
+        return BackendResponse.create(Status.OK, nextRequestMillis);
+      } else if (responseCode >= 500 || responseCode == 404) {
+        return BackendResponse.create(Status.TRANSIENT_ERROR, -1);
+      } else {
+        return BackendResponse.create(Status.NONTRANSIENT_ERROR, -1);
+      }
+    }
+  }
+
+  @Override
+  public BackendResponse send(BackendRequest request) {
+    BatchedLogRequest requestBody = getRequestBody(request);
+    try {
+      return doSend(requestBody);
+    } catch (IOException e) {
+      LOGGER.log(Level.SEVERE, "Could not make request to the backend", e);
+      return BackendResponse.create(Status.TRANSIENT_ERROR, -1);
+    }
+  }
+}
diff --git a/transport/transport-backend-cct/src/main/proto/google/cct/google_cct.proto b/transport/transport-backend-cct/src/main/proto/google/cct/google_cct.proto
new file mode 100644
index 000000000..de1e8d78b
--- /dev/null
+++ b/transport/transport-backend-cct/src/main/proto/google/cct/google_cct.proto
@@ -0,0 +1,260 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package google_cct;
+
+option java_package = "com.google.android.datatransport.cct.proto";
+option java_multiple_files = true;
+
+message LogEvent {
+    int64 event_time_ms = 1;
+
+    int64 event_uptime_ms = 17;
+
+    bytes source_extension = 6;
+
+    string source_extension_js = 8;
+
+    string source_extension_json = 13;
+
+    sint64 timezone_offset_seconds = 15;
+
+    NetworkConnectionInfo network_connection_info = 23;
+}
+
+message NetworkConnectionInfo {
+    enum NetworkType {
+        MOBILE = 0;
+        WIFI = 1;
+        MOBILE_MMS = 2;
+        MOBILE_SUPL = 3;
+        MOBILE_DUN = 4;
+        MOBILE_HIPRI = 5;
+        WIMAX = 6;
+        BLUETOOTH = 7;
+        DUMMY = 8;
+        ETHERNET = 9;
+        MOBILE_FOTA = 10;
+        MOBILE_IMS = 11;
+        MOBILE_CBS = 12;
+        WIFI_P2P = 13;
+        MOBILE_IA = 14;
+        MOBILE_EMERGENCY = 15;
+        PROXY = 16;
+        VPN = 17;
+
+        NONE = -1;
+    }
+
+    enum MobileSubtype {
+        UNKNOWN_MOBILE_SUBTYPE = 0;
+        GPRS = 1;
+        EDGE = 2;
+        UMTS = 3;
+        CDMA = 4;
+        EVDO_0 = 5;
+        EVDO_A = 6;
+        RTT = 7;
+        HSDPA = 8;
+        HSUPA = 9;
+        HSPA = 10;
+        IDEN = 11;
+        EVDO_B = 12;
+        LTE = 13;
+        EHRPD = 14;
+        HSPAP = 15;
+        GSM = 16;
+        TD_SCDMA = 17;
+        IWLAN = 18;
+        LTE_CA = 19;
+
+        // COMBINED has value -1 in NetworkIdentity.java, but is given the value
+        // 100 here to save (disk) space. The value -1 takes up the full 10 bytes in
+        // a varint for enums, but the value 100 only takes up 1 byte.
+        COMBINED = 100;
+    }
+
+    NetworkType network_type = 1;
+
+    MobileSubtype mobile_subtype = 2;
+}
+
+message AndroidClientInfo {
+
+    // This comes from android.os.Build.VERSION.SDK_INT.
+    int32 sdk_version = 3;
+
+    // Textual description of the client platform.  e.g., "Nexus 4".
+    // This comes from android.os.Build.MODEL.
+    string model = 4;
+
+    // The name of the overall product. e.g., "occam".
+    // This comes from android.os.Build.Product.
+    string product = 5;
+
+    // The name of the hardware (from the kernel command line or /proc).
+    // This comes from android.os.Build.Hardware.  e.g., "mako".
+    string hardware = 8;
+
+    // The name of the industrial design.  e.g., "mako".
+    // This comes from android.os.Build.Device.
+    string device = 9;
+
+    // This comes from android.os.Build.ID.  e.g., something like "JRN54F".
+    string os_build = 6;
+
+    // The client application version. The java int version in the android package
+    // converted to string.
+    string application_build = 7;
+
+    // The mobile country code / mobile network code (MCC/MNC).
+    // e.g., 310004 for Verizon USA.
+    string mcc_mnc = 10;
+
+    // The chosen locale from the client. e.g., "en_US", "ko_KR", "en_GB".
+    // NB: Often set as just locale-derived language; e.g., "en", "ko".
+    string locale = 11;
+
+    // Locale-derived country, chosen by the user; e.g., "US", "KR", "JP".
+    string country = 12;
+
+    // The manufacturer of the hardware.
+    // This comes from android.os.Build.MANUFACTURER
+    string manufacturer = 13;
+
+    // The brand the software is customized for, if any.  Often a carrier name.
+    // e.g. "google"
+    // from http://developer.android.com/reference/android/os/Build.html#BRAND
+    string brand = 14;
+
+    // The name of the underlying board
+    // e.g. "tuna"
+    // from http://developer.android.com/reference/android/os/Build.html#BOARD
+    string board = 15;
+
+    // Radio version as reported by device, if available at reporting time
+    // e.g. "I9250XXLJ1"
+    // from
+    // http://developer.android.com/reference/android/os/Build.html#getRadioVersion()
+    string radio_version = 16;
+
+    // Device model/build fingerprint.
+    // This comes from android.os.Build.FINGERPRINT.
+    string fingerprint = 17;
+
+    // The type of build, like "user" or "eng".
+    // This comes from android.os.Build.TYPE
+    string type = 26;
+
+    // The "ro.oem.key1" system property.
+    string ro_oem_key1 = 27;
+
+    // List of native platforms (CPU types) supported by the device, e.g.
+    // "armeabi".
+    //
+    // On L+ devices, this is Build.SUPPORTED_ABIS. On older devices, it is
+    // [Build.CPU_ABI] or, if Build.CPU_ABI2 is present, [Build.CPU_ABI,
+    // Build.CPU_ABI2]. In any case, the device's preference order is maintained.
+    repeated string native_platform = 31;
+}
+
+message ClientInfo {
+
+    enum ClientType {
+        UNKNOWN = 0;
+        ANDROID = 4; // TODO(haneym): Change to FIRELOG_ANDROID.
+    }
+
+    // The client type for this client. One of the enum values defined above.
+    ClientType client_type = 1;
+
+    AndroidClientInfo android_client_info = 2;
+}
+
+message BatchedLogRequest {
+    repeated LogRequest log_request = 1;
+}
+
+message LogRequest {
+
+    int64 request_time_ms = 4;
+
+    // Current time since boot in milliseconds, including time spent in sleep,
+    // according to the same clock as the one used to set
+    // the 'event_uptime_ms' values in the LogEvent protos above.
+    int64 request_uptime_ms = 8;
+
+    // The ClientInfo at log time.
+    ClientInfo client_info = 1;
+
+    int32 log_source = 2;
+
+    repeated LogEvent log_event = 3;
+
+    repeated bytes serialized_log_events = 5;
+
+    QosTierConfiguration.QosTier qos_tier = 9;
+
+    // Different types schedulers for log upload.
+    enum SchedulerType {
+        UNKNOWN_SCHEDULER = 0;
+        ASAP = 1;  // As soon as possible used when log store is full.
+        DEFAULT_PERIODIC = 2;
+        QOS_FAST_ONEOFF = 3;
+        QOS_DEFAULT_PERIODIC = 4;
+        QOS_UNMETERED_PERIODIC = 5;
+    }
+}
+
+message QosTierConfiguration {
+
+    enum QosTier {
+        DEFAULT = 0;
+
+        UNMETERED_ONLY = 1;
+
+        UNMETERED_OR_DAILY = 2;
+
+        FAST_IF_RADIO_AWAKE = 3;
+
+        NEVER = 4;
+    }
+
+    // For Android, please use log_source_name.
+    string log_source_name = 1;
+    QosTier qos_tier = 2;
+    int32 log_source = 3;
+}
+
+message QosTiersOverride {
+    // Quality of Service tiers enforced by server for overriding client
+    // qos_tier setting in event logging.
+    // This usually happens when server is burdened with fast qos tiers.
+    repeated QosTierConfiguration qos_tier_configuration = 1;
+
+    // The fingerprint of the qos_tier_configuration field.
+    int64 qos_tier_fingerprint = 2;
+}
+
+message LogResponse {
+    // Client should wait for next_request_wait_millis before sending the next
+    // log request.
+    int64 next_request_wait_millis = 1;
+
+    // Quality of Service tiers enforced by server for overriding client
+    // qos_tier setting in event logging.
+    QosTiersOverride qos_tier = 3;
+}
\ No newline at end of file
diff --git a/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/GoogleTransportBackendTest.java b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/GoogleTransportBackendTest.java
new file mode 100644
index 000000000..554bcb335
--- /dev/null
+++ b/transport/transport-backend-cct/src/test/java/com/google/android/datatransport/cct/GoogleTransportBackendTest.java
@@ -0,0 +1,132 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.cct;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
+import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;
+import static com.github.tomakehurst.wiremock.client.WireMock.post;
+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;
+import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;
+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
+import static com.github.tomakehurst.wiremock.client.WireMock.verify;
+import static org.junit.Assert.assertEquals;
+
+import com.github.tomakehurst.wiremock.junit.WireMockRule;
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.cct.proto.LogResponse;
+import com.google.android.datatransport.runtime.BackendRequest;
+import com.google.android.datatransport.runtime.BackendResponse;
+import com.google.android.datatransport.runtime.BackendResponse.Status;
+import com.google.android.datatransport.runtime.EventInternal;
+import java.util.Collections;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class GoogleTransportBackendTest {
+
+  private static String TEST_ENDPOINT = "http://localhost:8999/api";
+  private static GoogleTransportBackend BACKEND =
+      new GoogleTransportBackend(TEST_ENDPOINT, () -> 3, () -> 1);
+  private static String TRANSPORT_NAME = "3";
+
+  @Rule public WireMockRule wireMockRule = new WireMockRule(8999);
+
+  private BackendRequest getBackendRequest() {
+    return BackendRequest.create(
+        Collections.singleton(
+            BACKEND.decorate(
+                EventInternal.builder()
+                    .setEventMillis(3)
+                    .setUptimeMillis(1)
+                    .setTransportName(TRANSPORT_NAME)
+                    .setPriority(Priority.DEFAULT)
+                    .setPayload("TelemetryData".getBytes())
+                    .build())));
+  }
+
+  @Test
+  public void testSuccessLoggingRequest() {
+    stubFor(
+        post(urlEqualTo("/api"))
+            .willReturn(
+                aResponse()
+                    .withStatus(200)
+                    .withHeader("Content-Type", "application/x-protobuf;charset=UTF8;hello=world")
+                    .withBody(
+                        LogResponse.newBuilder()
+                            .setNextRequestWaitMillis(3)
+                            .build()
+                            .toByteArray())));
+    BackendResponse response = BACKEND.send(getBackendRequest());
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+    assertEquals(response.getStatus(), Status.OK);
+    assertEquals(response.getNextRequestWaitMillis(), 3);
+  }
+
+  @Test
+  public void testUnsuccessfulLoggingRequest() {
+    stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(404)));
+    BackendResponse response = BACKEND.send(getBackendRequest());
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+    assertEquals(response.getStatus(), Status.TRANSIENT_ERROR);
+    assertEquals(response.getNextRequestWaitMillis(), -1);
+  }
+
+  @Test
+  public void testServerErrorLoggingRequest() {
+    stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(500)));
+    BackendResponse response = BACKEND.send(getBackendRequest());
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+    assertEquals(response.getStatus(), Status.TRANSIENT_ERROR);
+    assertEquals(response.getNextRequestWaitMillis(), -1);
+  }
+
+  @Test
+  public void testGarbageFromServer() {
+    stubFor(
+        post(urlEqualTo("/api"))
+            .willReturn(
+                aResponse()
+                    .withStatus(200)
+                    .withHeader("Content-Type", "application/x-protobuf;charset=UTF8;hello=world")
+                    .withBody("{\"status\":\"Error\",\"message\":\"Endpoint not found\"}")));
+    BackendResponse response = BACKEND.send(getBackendRequest());
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+    assertEquals(response.getStatus(), Status.NONTRANSIENT_ERROR);
+    assertEquals(response.getNextRequestWaitMillis(), -1);
+  }
+
+  @Test
+  public void testNonHandledResponseCode() {
+    stubFor(post(urlEqualTo("/api")).willReturn(aResponse().withStatus(300)));
+    BackendResponse response = BACKEND.send(getBackendRequest());
+    verify(
+        postRequestedFor(urlEqualTo("/api"))
+            .withHeader("Content-Type", equalTo("application/x-protobuf")));
+    assertEquals(response.getStatus(), Status.NONTRANSIENT_ERROR);
+    assertEquals(response.getNextRequestWaitMillis(), -1);
+  }
+}
diff --git a/transport/transport-backend-cct/transport-backend-cct.gradle b/transport/transport-backend-cct/transport-backend-cct.gradle
new file mode 100644
index 000000000..df2d4b2d8
--- /dev/null
+++ b/transport/transport-backend-cct/transport-backend-cct.gradle
@@ -0,0 +1,83 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+apply plugin: 'com.android.library'
+apply plugin: 'com.google.protobuf'
+
+protobuf {
+    // Configure the protoc executable
+    protoc {
+        // Download from repositories
+        artifact = 'com.google.protobuf:protoc:3.4.0'
+    }
+    plugins {
+        javalite {
+            // The codegen for lite comes as a separate artifact
+            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'
+        }
+    }
+    generateProtoTasks {
+        all().each { task ->
+            task.builtins {
+                // In most cases you don't need the full Java output
+                // if you use the lite output.
+                remove java
+            }
+            task.plugins {
+                javalite {}
+            }
+        }
+    }
+}
+
+android {
+    compileSdkVersion 28
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 28
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+    compileOptions {
+        sourceCompatibility = '1.8'
+        targetCompatibility = '1.8'
+    }
+}
+
+dependencies {
+    implementation project(':transport:transport-api')
+    implementation project(':transport:transport-runtime')
+    implementation 'com.google.protobuf:protobuf-lite:3.0.1'
+
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation("com.github.tomakehurst:wiremock-jre8:2.21.0") {
+        //Allows us to use the Android version of Apache httpclient instead
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+
+        //Resolves the Duplicate Class Exception
+        //duplicate entry: org/objectweb/asm/AnnotationVisitor.class
+        exclude group: 'asm', module: 'asm'
+
+        //Fixes Warning conflict with Android's version of org.json
+        //org.json:json:20090211 is ignored for debugAndroidTest as it may be conflicting with the internal version provided by Android.
+        exclude group: 'org.json', module: 'json'
+    }
+    //Android compatible version of Apache httpclient.
+    testImplementation 'org.apache.httpcomponents:httpclient-android:4.3.5.1'
+    testImplementation 'org.robolectric:robolectric:4.2'
+
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    implementation 'com.android.support:support-annotations:28.0.0'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
diff --git a/transport/transport-runtime/gradle.properties b/transport/transport-runtime/gradle.properties
new file mode 100644
index 000000000..e71c90bfe
--- /dev/null
+++ b/transport/transport-runtime/gradle.properties
@@ -0,0 +1,15 @@
+# Copyright 2018 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+version=16.0.0
\ No newline at end of file
diff --git a/transport/transport-runtime/src/androidTest/AndroidManifest.xml b/transport/transport-runtime/src/androidTest/AndroidManifest.xml
new file mode 100644
index 000000000..942b5613d
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.datatransport.runtime.androidTest">
+    <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+    <!--<uses-sdk android:minSdkVersion="14"/>-->
+    <application>
+        <service
+            android:name="com.google.android.datatransport.runtime.scheduling.TestService$Local"
+            android:exported="false" />
+        <service
+            android:name="com.google.android.datatransport.runtime.scheduling.TestService$Remote"
+            android:exported="false" android:process=".another" />
+    </application>
+</manifest>
diff --git a/transport/transport-runtime/src/androidTest/aidl/com/google/android/datatransport/runtime/ITestRemoteLockRpc.aidl b/transport/transport-runtime/src/androidTest/aidl/com/google/android/datatransport/runtime/ITestRemoteLockRpc.aidl
new file mode 100644
index 000000000..e90304622
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/aidl/com/google/android/datatransport/runtime/ITestRemoteLockRpc.aidl
@@ -0,0 +1,14 @@
+package com.google.android.datatransport.runtime;
+
+/** RPC for manipulating SynchronizationGuard locking across process boundary. */
+interface ITestRemoteLockRpc {
+
+    /** Try to acuire lock or timeout. */
+    boolean tryAcquireLock(long lockTimeoutMs);
+
+    /** Release held lock. If lock is not held - undefined behavior. */
+    void releaseLock();
+
+    /** Return PID of the process this service is running on. */
+    long getPid();
+}
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/Locker.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/Locker.java
new file mode 100644
index 000000000..5597b4e7e
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/Locker.java
@@ -0,0 +1,45 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+
+/** Simple locking mechanism that supports results to the waiting/blocked side. */
+class Locker<T> {
+  private final BlockingQueue<T> queue;
+
+  Locker() {
+    queue = new SynchronousQueue<>(true);
+  }
+
+  T await() {
+    try {
+      return queue.take();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      throw new RuntimeException(e);
+    }
+  }
+
+  void setResult(T result) {
+    try {
+      queue.put(result);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java
new file mode 100644
index 000000000..b957251ee
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/MultiProcessSynchronizationGuardTest.java
@@ -0,0 +1,160 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.ServiceTestRule;
+import android.support.test.runner.AndroidJUnit4;
+import com.google.android.datatransport.runtime.ITestRemoteLockRpc;
+import com.google.android.datatransport.runtime.scheduling.persistence.SQLiteEventStore;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class MultiProcessSynchronizationGuardTest {
+  private ServiceTestRule rule = new ServiceTestRule();
+
+  private ITestRemoteLockRpc process1;
+  private ITestRemoteLockRpc process2;
+
+  @Before
+  public void setUp() throws TimeoutException, RemoteException {
+    process1 = bindTestingRpc(TestService.Local.class);
+
+    process2 = bindTestingRpc(TestService.Remote.class);
+
+    assertThat(process1.getPid()).isNotEqualTo(process2.getPid());
+  }
+
+  @Test
+  public void locking_whenDbConnectionsNotOpenAndLocalProcessLockedFirst_shouldWorkAsExpected()
+      throws RemoteException {
+    doTest_whenConnectionsNotOpen(process1, process2);
+  }
+
+  @Test
+  public void locking_whenDbConnectionsNotOpenAndRemoteProcessLockedFirst_shouldWorkAsExpected()
+      throws RemoteException {
+    doTest_whenConnectionsNotOpen(process2, process1);
+  }
+
+  @Test
+  public void locking_whenDbConnectionsAreOpenAndLocalProcessLockedFirst_shouldWorkAsExpected()
+      throws RemoteException {
+    doTest_whenConnectionsAreOpen(process1, process2);
+  }
+
+  @Test
+  public void locking_whenDbConnectionsAreOpenAndRemoteProcessLockedFirst_shouldWorkAsExpected()
+      throws RemoteException {
+    doTest_whenConnectionsAreOpen(process2, process1);
+  }
+
+  private static void doTest_whenConnectionsNotOpen(
+      ITestRemoteLockRpc process1, ITestRemoteLockRpc process2) throws RemoteException {
+    lockAndRunOrFail(process1, () -> assertCanLock(process2, false));
+
+    assertCanLock(process2, true);
+  }
+
+  private static void doTest_whenConnectionsAreOpen(
+      ITestRemoteLockRpc process1, ITestRemoteLockRpc process2) throws RemoteException {
+    // initialize db connections before contending for lock.
+    assertCanLock(process1, true);
+    assertCanLock(process2, true);
+
+    lockAndRunOrFail(process1, () -> assertCanLock(process2, false));
+
+    assertCanLock(process2, true);
+  }
+
+  private static void lockAndRunOrFail(ITestRemoteLockRpc rpc, ThrowingRunnable runnable)
+      throws RemoteException {
+    assertThat(rpc.tryAcquireLock(0)).isTrue();
+    try {
+      runnable.run();
+    } finally {
+      rpc.releaseLock();
+    }
+  }
+
+  private static void assertCanLock(ITestRemoteLockRpc rpc, boolean can) throws RemoteException {
+    boolean locked = rpc.tryAcquireLock(0);
+
+    try {
+      if (locked) {
+        rpc.releaseLock();
+      }
+    } finally {
+      if (locked != can) {
+        fail(String.format("Expected %sto be able to acquire the lock.", can ? "" : "not "));
+      }
+    }
+  }
+
+  private interface ThrowingRunnable {
+    void run() throws RemoteException;
+  }
+
+  private ITestRemoteLockRpc bindTestingRpc(Class<? extends Service> serviceClass)
+      throws TimeoutException {
+    ITestRemoteLockRpc rpc =
+        ITestRemoteLockRpc.Stub.asInterface(
+            rule.bindService(new Intent(InstrumentationRegistry.getTargetContext(), serviceClass)));
+    return new WaitingRpc(rpc);
+  }
+
+  class WaitingRpc implements ITestRemoteLockRpc {
+    private final ITestRemoteLockRpc delegate;
+
+    WaitingRpc(ITestRemoteLockRpc delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public boolean tryAcquireLock(long timeout) throws RemoteException {
+      boolean result = delegate.tryAcquireLock(timeout);
+      if (!result) {
+        SystemClock.sleep(SQLiteEventStore.LOCK_RETRY_BACK_OFF_MILLIS * 2);
+      }
+      return result;
+    }
+
+    @Override
+    public void releaseLock() throws RemoteException {
+      delegate.releaseLock();
+    }
+
+    @Override
+    public long getPid() throws RemoteException {
+      return delegate.getPid();
+    }
+
+    @Override
+    public IBinder asBinder() {
+      return delegate.asBinder();
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/RemoteLockRpc.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/RemoteLockRpc.java
new file mode 100644
index 000000000..26e38a704
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/RemoteLockRpc.java
@@ -0,0 +1,71 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import android.os.Process;
+import com.google.android.datatransport.runtime.ITestRemoteLockRpc;
+import com.google.android.datatransport.runtime.TransportRuntime;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationException;
+import java.util.concurrent.Executor;
+
+/**
+ * Implementation of {@link ITestRemoteLockRpc} that uses {@link
+ * com.google.android.datatransport.runtime.synchronization.SynchronizationGuard}.
+ */
+class RemoteLockRpc extends ITestRemoteLockRpc.Stub {
+  private final Executor executor;
+  private final Locker<Boolean> acquireReleaseLocker = new Locker<>();
+
+  RemoteLockRpc(Executor executor) {
+    this.executor = executor;
+  }
+
+  @Override
+  public boolean tryAcquireLock(long lockTimeoutMs) {
+    Locker<Boolean> sectionEnteredLocker = new Locker<>();
+    executor.execute(
+        () -> {
+          try {
+            TransportRuntime.getInstance()
+                .getSynchronizationGuard()
+                .runCriticalSection(
+                    lockTimeoutMs,
+                    () -> {
+                      sectionEnteredLocker.setResult(true);
+                      acquireReleaseLocker.await();
+                      return null;
+                    });
+            acquireReleaseLocker.setResult(true);
+          } catch (SynchronizationException ex) {
+            sectionEnteredLocker.setResult(false);
+          }
+        });
+    Boolean result = sectionEnteredLocker.await();
+    return result == null ? false : result;
+  }
+
+  @Override
+  public void releaseLock() {
+    // signal thread to release lock
+    acquireReleaseLocker.setResult(true);
+    // wait for lock to be released
+    acquireReleaseLocker.await();
+  }
+
+  @Override
+  public long getPid() {
+    return Process.myPid();
+  }
+}
diff --git a/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/TestService.java b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/TestService.java
new file mode 100644
index 000000000..3f7475633
--- /dev/null
+++ b/transport/transport-runtime/src/androidTest/java/com/google/android/datatransport/runtime/scheduling/TestService.java
@@ -0,0 +1,38 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+import android.util.Log;
+import com.google.android.datatransport.runtime.TransportRuntime;
+import java.util.concurrent.Executors;
+
+/** Base class fore the rpc test service. */
+public abstract class TestService extends Service {
+  @Override
+  public IBinder onBind(Intent intent) {
+    Log.i("TransportService", "My Pid: " + android.os.Process.myPid());
+    TransportRuntime.initialize(getApplicationContext());
+    return new RemoteLockRpc(Executors.newCachedThreadPool());
+  }
+
+  /** Service instance that runs in the main process of the Android application. */
+  public static class Local extends TestService {}
+
+  /** Service instance that runs in a dedicated process of the Android application. */
+  public static class Remote extends TestService {}
+}
diff --git a/transport/transport-runtime/src/main/AndroidManifest.xml b/transport/transport-runtime/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..ca3514c1c
--- /dev/null
+++ b/transport/transport-runtime/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!-- Copyright 2018 Google LLC -->
+<!-- -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License"); -->
+<!-- you may not use this file except in compliance with the License. -->
+<!-- You may obtain a copy of the License at -->
+<!-- -->
+<!--      http://www.apache.org/licenses/LICENSE-2.0 -->
+<!-- -->
+<!-- Unless required by applicable law or agreed to in writing, software -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS, -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. -->
+<!-- See the License for the specific language governing permissions and -->
+<!-- limitations under the License. -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.datatransport.runtime">
+  <!--Although the *SdkVersion is captured in gradle build files, this is required for non gradle builds-->
+  <!--<uses-sdk android:minSdkVersion="14"/>-->
+</manifest>
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRegistry.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRegistry.java
new file mode 100644
index 000000000..67cb8b793
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRegistry.java
@@ -0,0 +1,41 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/** Container for registered {@link TransportBackend}s. */
+@Singleton
+public class BackendRegistry {
+  private final Map<String, TransportBackend> backends = new HashMap<>();
+
+  @Inject
+  public BackendRegistry() {}
+
+  void register(String name, TransportBackend backend) {
+    synchronized (backends) {
+      backends.put(name, backend);
+    }
+  }
+
+  public TransportBackend get(String name) {
+    synchronized (backends) {
+      return backends.get(name);
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRequest.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRequest.java
new file mode 100644
index 000000000..099bcc3d9
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendRequest.java
@@ -0,0 +1,29 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.auto.value.AutoValue;
+
+/** Encapsulates a send request made to an individual {@link TransportBackend}. */
+@AutoValue
+public abstract class BackendRequest {
+  /** Events to be sent to the backend. */
+  public abstract Iterable<EventInternal> getEvents();
+
+  /** Creates a new instance of the request. */
+  public static BackendRequest create(Iterable<EventInternal> events) {
+    return new AutoValue_BackendRequest(events);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendResponse.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendResponse.java
new file mode 100644
index 000000000..2c82ec0fe
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/BackendResponse.java
@@ -0,0 +1,42 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.auto.value.AutoValue;
+
+/**
+ * Represents a response from a {@link TransportBackend}.
+ *
+ * <p>It contains the response status and time to wait before trying to send another request to it.
+ */
+@AutoValue
+public abstract class BackendResponse {
+  public enum Status {
+    OK,
+    TRANSIENT_ERROR,
+    NONTRANSIENT_ERROR,
+  }
+
+  /** Status result of the backend call */
+  public abstract Status getStatus();
+
+  /** Time in millis to wait before attempting another request. */
+  public abstract long getNextRequestWaitMillis();
+
+  /** Create a new instance of {@link BackendResponse}. */
+  public static BackendResponse create(Status status, long nextRequestMillis) {
+    return new AutoValue_BackendResponse(status, nextRequestMillis);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java
new file mode 100644
index 000000000..ddb9d17a1
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/EventInternal.java
@@ -0,0 +1,79 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.android.datatransport.Priority;
+import com.google.auto.value.AutoValue;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+@AutoValue
+public abstract class EventInternal {
+  // send source
+  public abstract String getTransportName();
+
+  public abstract byte[] getPayload();
+
+  public abstract Priority getPriority();
+
+  public abstract long getEventMillis();
+
+  public abstract long getUptimeMillis();
+
+  protected abstract Map<String, String> getAutoMetadata();
+
+  public final Map<String, String> getMetadata() {
+    return Collections.unmodifiableMap(getAutoMetadata());
+  }
+
+  public Builder toBuilder() {
+    return new AutoValue_EventInternal.Builder()
+        .setTransportName(getTransportName())
+        .setPayload(getPayload())
+        .setPriority(getPriority())
+        .setEventMillis(getEventMillis())
+        .setUptimeMillis(getUptimeMillis())
+        .setAutoMetadata(new HashMap<>(getAutoMetadata()));
+  }
+
+  public static Builder builder() {
+    return new AutoValue_EventInternal.Builder().setAutoMetadata(new HashMap<>());
+  }
+
+  @AutoValue.Builder
+  public abstract static class Builder {
+    public abstract Builder setTransportName(String value);
+
+    public abstract Builder setPayload(byte[] value);
+
+    public abstract Builder setPriority(Priority value);
+
+    public abstract Builder setEventMillis(long value);
+
+    public abstract Builder setUptimeMillis(long value);
+
+    protected abstract Builder setAutoMetadata(Map<String, String> metadata);
+
+    protected abstract Map<String, String> getAutoMetadata();
+
+    public final Builder addMetadata(String key, String value) {
+      getAutoMetadata().put(key, value);
+      return this;
+    }
+
+    public abstract EventInternal build();
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/SendRequest.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/SendRequest.java
new file mode 100644
index 000000000..697150331
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/SendRequest.java
@@ -0,0 +1,57 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.android.datatransport.Event;
+import com.google.android.datatransport.Transformer;
+import com.google.auto.value.AutoValue;
+
+@AutoValue
+public abstract class SendRequest {
+  public abstract String getBackendName();
+
+  public abstract String getTransportName();
+
+  abstract Event<?> getEvent();
+
+  abstract Transformer<?, byte[]> getTransformer();
+
+  public byte[] getPayload() {
+    return ((Transformer<Object, byte[]>) getTransformer()).apply(getEvent().getPayload());
+  }
+
+  public static Builder builder() {
+    return new AutoValue_SendRequest.Builder();
+  }
+
+  @AutoValue.Builder
+  public abstract static class Builder {
+    public abstract Builder setBackendName(String name);
+
+    public abstract Builder setTransportName(String name);
+
+    abstract Builder setEvent(Event<?> event);
+
+    abstract Builder setTransformer(Transformer<?, byte[]> transformer);
+
+    public abstract SendRequest build();
+
+    public <T> Builder setEvent(Event<T> event, Transformer<T, byte[]> transformer) {
+      setEvent(event);
+      setTransformer(transformer);
+      return this;
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportBackend.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportBackend.java
new file mode 100644
index 000000000..40e07179d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportBackend.java
@@ -0,0 +1,21 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+public interface TransportBackend {
+  EventInternal decorate(EventInternal event);
+
+  BackendResponse send(BackendRequest backendRequest);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportFactoryImpl.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportFactoryImpl.java
new file mode 100644
index 000000000..fbed7a81b
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportFactoryImpl.java
@@ -0,0 +1,35 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.android.datatransport.Transformer;
+import com.google.android.datatransport.Transport;
+import com.google.android.datatransport.TransportFactory;
+
+final class TransportFactoryImpl implements TransportFactory {
+  private final String backendName;
+  private final TransportInternal transportInternal;
+
+  TransportFactoryImpl(String backendName, TransportInternal transportInternal) {
+    this.backendName = backendName;
+    this.transportInternal = transportInternal;
+  }
+
+  @Override
+  public <T> Transport<T> getTransport(
+      String name, Class<T> payloadType, Transformer<T, byte[]> payloadTransformer) {
+    return new TransportImpl<>(backendName, name, payloadTransformer, transportInternal);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportImpl.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportImpl.java
new file mode 100644
index 000000000..a5df2687d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportImpl.java
@@ -0,0 +1,48 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import com.google.android.datatransport.Event;
+import com.google.android.datatransport.Transformer;
+import com.google.android.datatransport.Transport;
+
+class TransportImpl<T> implements Transport<T> {
+  private final String backendName;
+  private final String name;
+  private final Transformer<T, byte[]> transformer;
+  private final TransportInternal transportInternal;
+
+  TransportImpl(
+      String backendName,
+      String name,
+      Transformer<T, byte[]> transformer,
+      TransportInternal transportInternal) {
+    this.backendName = backendName;
+    this.name = name;
+    this.transformer = transformer;
+    this.transportInternal = transportInternal;
+  }
+
+  @Override
+  public void send(Event<T> event) {
+    transportInternal.send(
+        SendRequest.builder()
+            .setBackendName(backendName)
+            .setEvent(event)
+            .setTransportName(name)
+            .setTransformer(transformer)
+            .build());
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportInternal.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportInternal.java
new file mode 100644
index 000000000..6eeb6931d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportInternal.java
@@ -0,0 +1,19 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+public interface TransportInternal {
+  void send(SendRequest request);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java
new file mode 100644
index 000000000..3fe684066
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntime.java
@@ -0,0 +1,130 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import android.content.Context;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.VisibleForTesting;
+import com.google.android.datatransport.TransportFactory;
+import com.google.android.datatransport.runtime.scheduling.Scheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.Monotonic;
+import com.google.android.datatransport.runtime.time.WallTime;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * The central entry point to the event transport infrastructure.
+ *
+ * <p>Handles event scheduling, persistence and batching. Default {@link TransportFactory}
+ * implementations delegate to this class.
+ */
+@Singleton
+@SuppressWarnings("WeakerAccess")
+public class TransportRuntime implements TransportInternal {
+
+  private static volatile TransportRuntimeComponent INSTANCE = null;
+
+  private final BackendRegistry backendRegistry;
+  private final Clock eventClock;
+  private final Clock uptimeClock;
+  private final Scheduler scheduler;
+  private final SynchronizationGuard guard;
+  private final Uploader uploader;
+
+  @Inject
+  TransportRuntime(
+      BackendRegistry backendRegistry,
+      @WallTime Clock eventClock,
+      @Monotonic Clock uptimeClock,
+      Scheduler scheduler,
+      SynchronizationGuard guard,
+      Uploader uploader) {
+    this.backendRegistry = backendRegistry;
+    this.eventClock = eventClock;
+    this.uptimeClock = uptimeClock;
+    this.scheduler = scheduler;
+    this.guard = guard;
+    this.uploader = uploader;
+  }
+
+  /**
+   * Initializes transport runtime with an application context.
+   *
+   * <p>This method must be called before {@link #getInstance()}.
+   */
+  public static void initialize(Context applicationContext) {
+    if (INSTANCE == null) {
+      synchronized (TransportRuntime.class) {
+        INSTANCE =
+            DaggerTransportRuntimeComponent.builder()
+                .setApplicationContext(applicationContext)
+                .build();
+      }
+    }
+    // send warning
+  }
+
+  /**
+   * Returns the global singleton instance of {@link TransportRuntime}.
+   *
+   * @throws IllegalStateException if {@link #initialize(Context)} is not called before this method.
+   */
+  public static TransportRuntime getInstance() {
+    TransportRuntimeComponent localRef = INSTANCE;
+    if (localRef == null) {
+      throw new IllegalStateException("Not initialized!");
+    }
+    return localRef.getTransportRuntime();
+  }
+
+  /** Register a {@link TransportBackend}. */
+  public void register(String name, TransportBackend backend) {
+    backendRegistry.register(name, backend);
+  }
+
+  /** Returns a {@link TransportFactory} for a given {@code backendName}. */
+  public TransportFactory newFactory(String backendName) {
+    return new TransportFactoryImpl(backendName, this);
+  }
+
+  @RestrictTo(RestrictTo.Scope.LIBRARY)
+  public Uploader getUploader() {
+    return uploader;
+  }
+
+  @Override
+  public void send(SendRequest request) {
+    scheduler.schedule(request.getBackendName(), convert(request));
+  }
+
+  private EventInternal convert(SendRequest request) {
+    return EventInternal.builder()
+        .setEventMillis(eventClock.getTime())
+        .setUptimeMillis(uptimeClock.getTime())
+        .setTransportName(request.getTransportName())
+        .setPriority(request.getEvent().getPriority())
+        .setPayload(request.getPayload())
+        .build();
+  }
+
+  @VisibleForTesting
+  @RestrictTo(RestrictTo.Scope.TESTS)
+  public SynchronizationGuard getSynchronizationGuard() {
+    return guard;
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeComponent.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeComponent.java
new file mode 100644
index 000000000..34074b05a
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeComponent.java
@@ -0,0 +1,34 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import android.content.Context;
+import dagger.BindsInstance;
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = {TransportRuntimeModule.class})
+@Singleton
+interface TransportRuntimeComponent {
+  TransportRuntime getTransportRuntime();
+
+  @Component.Builder
+  interface Builder {
+    @BindsInstance
+    Builder setApplicationContext(Context applicationContext);
+
+    TransportRuntimeComponent build();
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeModule.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeModule.java
new file mode 100644
index 000000000..e1cf374db
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/TransportRuntimeModule.java
@@ -0,0 +1,82 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import android.content.Context;
+import android.os.Build;
+import com.google.android.datatransport.runtime.scheduling.ImmediateScheduler;
+import com.google.android.datatransport.runtime.scheduling.Scheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.AlarmManagerScheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.JobInfoScheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkScheduler;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.scheduling.persistence.SQLiteEventStore;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.Monotonic;
+import com.google.android.datatransport.runtime.time.UptimeClock;
+import com.google.android.datatransport.runtime.time.WallTime;
+import com.google.android.datatransport.runtime.time.WallTimeClock;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+@Module
+abstract class TransportRuntimeModule {
+  @Provides
+  static Executor executor() {
+    return Executors.newSingleThreadExecutor();
+  }
+
+  @Provides
+  @WallTime
+  static Clock eventClock() {
+    return new WallTimeClock();
+  }
+
+  @Provides
+  @Monotonic
+  static Clock uptimeClock() {
+    return new UptimeClock();
+  }
+
+  @Provides
+  static WorkScheduler workScheduler(
+      Context context, EventStore eventStore, @WallTime Clock eventClock) {
+    if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+      return new JobInfoScheduler(context, eventStore, eventClock);
+    } else {
+      return new AlarmManagerScheduler(context, eventStore, eventClock);
+    }
+  }
+
+  @Provides
+  static Scheduler scheduler(
+      Executor executor,
+      BackendRegistry registry,
+      WorkScheduler workScheduler,
+      EventStore eventStore,
+      SynchronizationGuard guard) {
+    return new ImmediateScheduler(executor, registry);
+  }
+
+  @Binds
+  abstract EventStore eventStore(SQLiteEventStore store);
+
+  @Binds
+  abstract SynchronizationGuard synchronizationGuard(SQLiteEventStore store);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/DefaultScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/DefaultScheduler.java
new file mode 100644
index 000000000..1d1aa6eb1
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/DefaultScheduler.java
@@ -0,0 +1,81 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import com.google.android.datatransport.runtime.BackendRegistry;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.TransportBackend;
+import com.google.android.datatransport.runtime.TransportRuntime;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.WorkScheduler;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import java.util.concurrent.Executor;
+import java.util.logging.Logger;
+import javax.inject.Inject;
+
+/**
+ * Scheduler which persists the events, schedules the services which ultimately logs these events to
+ * the corresponding backends. This respects network conditions and QoS.
+ */
+public class DefaultScheduler implements Scheduler {
+
+  private static final Logger LOGGER = Logger.getLogger(TransportRuntime.class.getName());
+  private final WorkScheduler workScheduler;
+  private final Executor executor;
+  private final BackendRegistry backendRegistry;
+  private final EventStore eventStore;
+  private final SynchronizationGuard guard;
+  private final int LOCK_TIME_OUT = 10000; // 10 seconds lock timeout
+
+  @Inject
+  public DefaultScheduler(
+      Executor executor,
+      BackendRegistry backendRegistry,
+      WorkScheduler workScheduler,
+      EventStore eventStore,
+      SynchronizationGuard guard) {
+    this.executor = executor;
+    this.backendRegistry = backendRegistry;
+    this.workScheduler = workScheduler;
+    this.eventStore = eventStore;
+    this.guard = guard;
+  }
+
+  /**
+   * Schedules the events to be eventually logged to the backend.
+   *
+   * @param backendName The backend to which the event needs to be logged.
+   * @param event The event itself which needs to be logged with additional information.
+   */
+  @Override
+  public void schedule(String backendName, EventInternal event) {
+    executor.execute(
+        () -> {
+          TransportBackend transportBackend = backendRegistry.get(backendName);
+          if (transportBackend == null) {
+            LOGGER.warning(String.format("Logger backend '%s' is not registered", backendName));
+            return;
+          }
+          EventInternal decoratedEvent = transportBackend.decorate(event);
+          guard.runCriticalSection(
+              LOCK_TIME_OUT,
+              () -> {
+                eventStore.persist(backendName, decoratedEvent);
+                workScheduler.schedule(backendName, 0);
+                return null;
+              });
+        });
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/ImmediateScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/ImmediateScheduler.java
new file mode 100644
index 000000000..7032b1b0b
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/ImmediateScheduler.java
@@ -0,0 +1,56 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import com.google.android.datatransport.runtime.BackendRegistry;
+import com.google.android.datatransport.runtime.BackendRequest;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.TransportBackend;
+import com.google.android.datatransport.runtime.TransportRuntime;
+import java.util.Collections;
+import java.util.concurrent.Executor;
+import java.util.logging.Logger;
+import javax.inject.Inject;
+
+/**
+ * Simple scheduler implementation that tries to transmit event immediately.
+ *
+ * <p>It does not respect QoS of the event, network conditions, backend wait time millis.
+ */
+public class ImmediateScheduler implements Scheduler {
+  private static final Logger LOGGER = Logger.getLogger(TransportRuntime.class.getName());
+
+  private final Executor executor;
+  private final BackendRegistry backendRegistry;
+
+  @Inject
+  public ImmediateScheduler(Executor executor, BackendRegistry backendRegistry) {
+    this.executor = executor;
+    this.backendRegistry = backendRegistry;
+  }
+
+  @Override
+  public void schedule(String backendName, EventInternal event) {
+    executor.execute(
+        () -> {
+          TransportBackend backend = backendRegistry.get(backendName);
+          if (backend == null) {
+            LOGGER.warning(String.format("Transport backend '%s' is not registered", backendName));
+            return;
+          }
+          backend.send(BackendRequest.create(Collections.singleton(backend.decorate(event))));
+        });
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/Scheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/Scheduler.java
new file mode 100644
index 000000000..e54bfbe0d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/Scheduler.java
@@ -0,0 +1,27 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling;
+
+import com.google.android.datatransport.runtime.EventInternal;
+
+/**
+ * Responsible for scheduling an event to be transmitted to a backend.
+ *
+ * <p>The precise timing of when the event is transmitted is unspecified and implementation
+ * dependent.
+ */
+public interface Scheduler {
+  void schedule(String backendName, EventInternal event);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java
new file mode 100644
index 000000000..3a07259d3
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/AlarmManagerScheduler.java
@@ -0,0 +1,42 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import android.content.Context;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.time.Clock;
+import javax.inject.Inject;
+
+/**
+ * Schedules the AlarmManager service based on the backendname. Used for Api levels 20 and below.
+ */
+public class AlarmManagerScheduler implements WorkScheduler {
+
+  private final Context context;
+
+  private final EventStore eventStore;
+
+  private final Clock clock;
+
+  @Inject
+  public AlarmManagerScheduler(Context applicationContext, EventStore eventStore, Clock clock) {
+    this.context = applicationContext;
+    this.eventStore = eventStore;
+    this.clock = clock;
+  }
+
+  @Override
+  public void schedule(String backendName, int attemptNumber) {}
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java
new file mode 100644
index 000000000..810853124
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoScheduler.java
@@ -0,0 +1,96 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.Build;
+import android.os.PersistableBundle;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.time.Clock;
+import java.util.zip.Adler32;
+import javax.inject.Inject;
+
+/**
+ * Schedules the service {@link JobInfoSchedulerService} based on the backendname. Used for Apis 21
+ * and above.
+ */
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+public class JobInfoScheduler implements WorkScheduler {
+
+  private final Context context;
+
+  private final EventStore eventStore;
+
+  private final Clock clock;
+
+  private final int DELTA = 30000; // 30 seconds delta
+
+  @Inject
+  public JobInfoScheduler(Context applicationContext, EventStore eventStore, Clock clock) {
+    this.context = applicationContext;
+    this.eventStore = eventStore;
+    this.clock = clock;
+  }
+
+  @VisibleForTesting
+  int getJobId(String backendName) {
+    Adler32 checksum = new Adler32();
+    checksum.update(backendName.getBytes());
+    return (int) checksum.getValue();
+  }
+
+  private boolean isJobServiceOn(JobScheduler scheduler, int jobId) {
+    for (JobInfo jobInfo : scheduler.getAllPendingJobs()) {
+      if (jobInfo.getId() == jobId) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Schedules the JobScheduler service.
+   *
+   * @param backendName The backend to where the events are logged.
+   * @param attemptNumber Number of times the JobScheduler has tried to log for this backend.
+   */
+  @Override
+  public void schedule(String backendName, int attemptNumber) {
+    ComponentName serviceComponent = new ComponentName(context, JobInfoSchedulerService.class);
+    JobScheduler jobScheduler =
+        (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+    int jobId = getJobId(backendName);
+    // Check if there exists a job scheduled for this backend name.
+    if (isJobServiceOn(jobScheduler, jobId)) return;
+    // Obtain the next available call time for the backend.
+    long timeDiff = eventStore.getNextCallTime(backendName) - clock.getTime();
+    // Schedule the build.
+    PersistableBundle bundle = new PersistableBundle();
+    bundle.putInt(SchedulerUtil.ATTEMPT_NUMBER, attemptNumber);
+    bundle.putString(SchedulerUtil.BACKEND_NAME, backendName);
+    JobInfo.Builder builder = new JobInfo.Builder(jobId, serviceComponent);
+    builder.setMinimumLatency(
+        clock.getTime()
+            + SchedulerUtil.getScheduleDelay(timeDiff, DELTA, attemptNumber)); // wait at least
+    builder.setExtras(bundle);
+    builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);
+    jobScheduler.schedule(builder.build());
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java
new file mode 100644
index 000000000..2654a4475
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerService.java
@@ -0,0 +1,42 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import com.google.android.datatransport.runtime.TransportRuntime;
+
+/** The service responsible for uploading information to the backend. */
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+public class JobInfoSchedulerService extends JobService {
+
+  @Override
+  public boolean onStartJob(JobParameters params) {
+    String backendName = params.getExtras().getString(SchedulerUtil.BACKEND_NAME);
+    int attemptNumber = params.getExtras().getInt(SchedulerUtil.ATTEMPT_NUMBER);
+    TransportRuntime.initialize(getApplicationContext());
+    TransportRuntime.getInstance()
+        .getUploader()
+        .upload(backendName, attemptNumber, () -> this.jobFinished(params, false));
+    return true;
+  }
+
+  @Override
+  public boolean onStopJob(JobParameters params) {
+    return true;
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerUtil.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerUtil.java
new file mode 100644
index 000000000..b5a83a27c
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/SchedulerUtil.java
@@ -0,0 +1,36 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+/** Used by the schedulers for some basic constants and utility methods. */
+final class SchedulerUtil {
+
+  static final String ATTEMPT_NUMBER = "attemptNumber";
+
+  static final String BACKEND_NAME = "backendName";
+
+  static final String APPLICATION_BUNDLE_ID = "appBundleId";
+
+  static final int MAX_ALLOWED_TIME = 100000000;
+
+  private SchedulerUtil() {};
+
+  static long getScheduleDelay(long backendTimeDiff, int delta, int attemptNumber) {
+    if (attemptNumber > 11) {
+      return MAX_ALLOWED_TIME;
+    }
+    return Math.max((long) (Math.pow(2, attemptNumber)) * delta, backendTimeDiff);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java
new file mode 100644
index 000000000..24ce2962a
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/Uploader.java
@@ -0,0 +1,26 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import javax.inject.Inject;
+
+/** Handles upload of all the events corresponding to a backend. */
+public class Uploader {
+
+  @Inject
+  public Uploader() {}
+
+  void upload(String backendName, int attemptNumber, Runnable callback) {}
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkScheduler.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkScheduler.java
new file mode 100644
index 000000000..f0298365d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/WorkScheduler.java
@@ -0,0 +1,20 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+/** Schedules the services to be able to eventually log events to their respective backends. */
+public interface WorkScheduler {
+  void schedule(String backendName, int attemptNumber);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java
new file mode 100644
index 000000000..01056142f
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/EventStore.java
@@ -0,0 +1,50 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import android.support.annotation.Nullable;
+import android.support.annotation.WorkerThread;
+import com.google.android.datatransport.runtime.EventInternal;
+
+/**
+ * Persistence layer.
+ *
+ * <p>Responsible for storing events and backend-specific metadata.
+ */
+@WorkerThread
+public interface EventStore {
+
+  /** Persist a new event. */
+  PersistedEvent persist(String backendName, EventInternal event);
+
+  /** Communicate to the store that events have failed to get sent. */
+  void recordFailure(Iterable<PersistedEvent> events);
+
+  /** Communicate to the store that events have been sent successfully. */
+  void recordSuccess(Iterable<PersistedEvent> events);
+
+  /** Returns the timestamp when the backend is allowed to be called next time or null. */
+  @Nullable
+  Long getNextCallTime(String backendName);
+
+  /** Record the timestamp when the backend is allowed to be called next time. */
+  void recordNextCallTime(String backendName, long timestampMs);
+
+  /** Returns true if the store contains any pending events for a give backend. */
+  boolean hasPendingEventsFor(String backendName);
+
+  /** Load all pending events for a given backend. */
+  Iterable<PersistedEvent> loadAll(String backendName);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/PersistedEvent.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/PersistedEvent.java
new file mode 100644
index 000000000..fd923460d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/PersistedEvent.java
@@ -0,0 +1,32 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.auto.value.AutoValue;
+
+/** Holds an {@link EventInternal} with additional information. */
+@AutoValue
+public abstract class PersistedEvent {
+  public abstract long getId();
+
+  public abstract String getBackendName();
+
+  public abstract EventInternal getEvent();
+
+  public static PersistedEvent create(long id, String backendName, EventInternal object) {
+    return new AutoValue_PersistedEvent(id, backendName, object);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java
new file mode 100644
index 000000000..76470b35d
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStore.java
@@ -0,0 +1,444 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabaseLockedException;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.os.Build;
+import android.os.SystemClock;
+import android.support.annotation.Nullable;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.VisibleForTesting;
+import android.support.annotation.WorkerThread;
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationException;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import com.google.android.datatransport.runtime.time.Clock;
+import com.google.android.datatransport.runtime.time.Monotonic;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/** {@link EventStore} implementation backed by a SQLite database. */
+@Singleton
+@WorkerThread
+public class SQLiteEventStore implements EventStore, SynchronizationGuard {
+
+  static final int MAX_RETRIES = 10;
+
+  private static final Priority[] ALL_PRIORITIES = Priority.values();
+
+  @VisibleForTesting
+  @RestrictTo(RestrictTo.Scope.TESTS)
+  public static final int LOCK_RETRY_BACK_OFF_MILLIS = 50;
+
+  private final OpenHelper openHelper;
+  private final Clock monotonicClock;
+  private SQLiteDatabase db;
+
+  @Inject
+  SQLiteEventStore(Context applicationContext, @Monotonic Clock clock) {
+    this.openHelper = new OpenHelper(applicationContext);
+    this.monotonicClock = clock;
+  }
+
+  private SQLiteDatabase getDb() {
+    if (db == null) {
+      db =
+          retryIfDbLocked(
+              1000,
+              openHelper::getWritableDatabase,
+              ex -> {
+                throw new SynchronizationException("Timed out while trying to open db.", ex);
+              });
+    }
+    return db;
+  }
+
+  @Override
+  public PersistedEvent persist(String backendName, EventInternal event) {
+    ContentValues values = new ContentValues();
+    values.put("backend_id", backendName);
+    values.put("transport_name", event.getTransportName());
+    values.put("priority", event.getPriority().ordinal());
+    values.put("timestamp_ms", event.getEventMillis());
+    values.put("uptime_ms", event.getUptimeMillis());
+    values.put("payload", event.getPayload());
+    values.put("num_attempts", 0);
+
+    long newRowId =
+        inTransaction(
+            db -> {
+              long newEventId = db.insert("events", null, values);
+
+              // TODO: insert all with one sql query.
+              for (Map.Entry<String, String> entry : event.getMetadata().entrySet()) {
+                ContentValues metadata = new ContentValues();
+                metadata.put("event_id", newEventId);
+                metadata.put("name", entry.getKey());
+                metadata.put("value", entry.getValue());
+                db.insert("event_metadata", null, metadata);
+              }
+              return newEventId;
+            });
+
+    return PersistedEvent.create(newRowId, backendName, event);
+  }
+
+  @Override
+  public void recordFailure(Iterable<PersistedEvent> events) {
+    if (!events.iterator().hasNext()) {
+      return;
+    }
+    String query =
+        "UPDATE events SET num_attempts = num_attempts + 1 WHERE _id in " + toIdList(events);
+
+    inTransaction(
+        db -> {
+          db.compileStatement(query).execute();
+          db.compileStatement("DELETE FROM events WHERE num_attempts >= " + MAX_RETRIES).execute();
+          return null;
+        });
+  }
+
+  @Override
+  public void recordSuccess(Iterable<PersistedEvent> events) {
+    if (!events.iterator().hasNext()) {
+      return;
+    }
+
+    String query = "DELETE FROM events WHERE _id in " + toIdList(events);
+    getDb().compileStatement(query).execute();
+  }
+
+  private static String toIdList(Iterable<PersistedEvent> events) {
+    StringBuilder idList = new StringBuilder("(");
+    Iterator<PersistedEvent> iterator = events.iterator();
+    while (iterator.hasNext()) {
+      idList.append(iterator.next().getId());
+      if (iterator.hasNext()) {
+        idList.append(',');
+      }
+    }
+    idList.append(')');
+    return idList.toString();
+  }
+
+  @Override
+  @Nullable
+  public Long getNextCallTime(String backendName) {
+    try (Cursor cursor =
+        getDb()
+            .rawQuery(
+                "SELECT next_request_ms FROM backends WHERE name = ?",
+                new String[] {backendName})) {
+      if (cursor.moveToNext()) {
+        return cursor.getLong(0);
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public boolean hasPendingEventsFor(String backendName) {
+    try (Cursor cursor =
+        getDb()
+            .rawQuery(
+                "SELECT 1 FROM events WHERE backend_id = ? LIMIT 1", new String[] {backendName})) {
+      return cursor.moveToNext();
+    }
+  }
+
+  @Override
+  public void recordNextCallTime(String backendName, long timestampMs) {
+    inTransaction(
+        db -> {
+          ContentValues values = new ContentValues();
+          values.put("next_request_ms", timestampMs);
+          int rowsUpdated = db.update("backends", values, "name = ?", new String[] {backendName});
+
+          if (rowsUpdated < 1) {
+            values.put("name", backendName);
+            db.insert("backends", null, values);
+          }
+          return null;
+        });
+  }
+
+  @Override
+  public Iterable<PersistedEvent> loadAll(String backendName) {
+    return inTransaction(
+        db -> {
+          List<PersistedEvent> events = loadEvents(db, backendName);
+          return join(events, loadMetadata(db, events));
+        });
+  }
+
+  /** Loads all events for a backend. */
+  private List<PersistedEvent> loadEvents(SQLiteDatabase db, String backendName) {
+    List<PersistedEvent> events = new ArrayList<>();
+    try (Cursor cursor =
+        db.query(
+            "events",
+            new String[] {
+              "_id", "transport_name", "priority", "timestamp_ms", "uptime_ms", "payload"
+            },
+            "backend_id = ?",
+            new String[] {backendName},
+            null,
+            null,
+            null)) {
+      while (cursor.moveToNext()) {
+        long id = cursor.getLong(0);
+        EventInternal event =
+            EventInternal.builder()
+                .setTransportName(cursor.getString(1))
+                .setPriority(toPriority(cursor.getInt(2)))
+                .setEventMillis(cursor.getLong(3))
+                .setUptimeMillis(cursor.getLong(4))
+                .setPayload(cursor.getBlob(5))
+                .build();
+        events.add(PersistedEvent.create(id, backendName, event));
+      }
+    }
+    return events;
+  }
+
+  /** Loads metadata pairs for given events. */
+  private Map<Long, Set<Metadata>> loadMetadata(SQLiteDatabase db, List<PersistedEvent> events) {
+    Map<Long, Set<Metadata>> metadataIndex = new HashMap<>();
+    StringBuilder whereClause = new StringBuilder("event_id IN (");
+    for (int i = 0; i < events.size(); i++) {
+      whereClause.append(events.get(i).getId());
+      if (i < events.size() - 1) {
+        whereClause.append(',');
+      }
+    }
+    whereClause.append(')');
+
+    try (Cursor cursor =
+        db.query(
+            "event_metadata",
+            new String[] {"event_id", "name", "value"},
+            whereClause.toString(),
+            null,
+            null,
+            null,
+            null)) {
+      while (cursor.moveToNext()) {
+        long eventId = cursor.getLong(0);
+        Set<Metadata> currentSet = metadataIndex.get(eventId);
+        if (currentSet == null) {
+          currentSet = new HashSet<>();
+          metadataIndex.put(eventId, currentSet);
+        }
+        currentSet.add(new Metadata(cursor.getString(1), cursor.getString(2)));
+      }
+    }
+    return metadataIndex;
+  }
+
+  /** Populate metadata into the events. */
+  private List<PersistedEvent> join(
+      List<PersistedEvent> events, Map<Long, Set<Metadata>> metadataIndex) {
+    ListIterator<PersistedEvent> iterator = events.listIterator();
+    while (iterator.hasNext()) {
+      PersistedEvent current = iterator.next();
+      if (!metadataIndex.containsKey(current.getId())) {
+        continue;
+      }
+      EventInternal.Builder newEvent = current.getEvent().toBuilder();
+
+      for (Metadata metadata : metadataIndex.get(current.getId())) {
+        newEvent.addMetadata(metadata.key, metadata.value);
+      }
+      iterator.set(
+          PersistedEvent.create(current.getId(), current.getBackendName(), newEvent.build()));
+    }
+    return events;
+  }
+
+  private <T> T retryIfDbLocked(
+      long lockTimeoutMs, Producer<T> retriable, Function<Throwable, T> failureHandler) {
+    long startTime = monotonicClock.getTime();
+    do {
+      try {
+        return retriable.produce();
+      } catch (SQLiteDatabaseLockedException ex) {
+        if (monotonicClock.getTime() >= startTime + lockTimeoutMs) {
+          return failureHandler.apply(ex);
+        }
+        SystemClock.sleep(LOCK_RETRY_BACK_OFF_MILLIS);
+      }
+    } while (true);
+  }
+
+  interface Producer<T> {
+    T produce();
+  }
+
+  interface Function<T, U> {
+    U apply(T input);
+  }
+
+  /** Tries to start a transaction until it succeeds or times out. */
+  private void ensureBeginTransaction(SQLiteDatabase db, long lockTimeoutMs) {
+    retryIfDbLocked(
+        lockTimeoutMs,
+        () -> {
+          db.beginTransaction();
+          return null;
+        },
+        ex -> {
+          throw new SynchronizationException("Timed out while trying to acquire the lock.", ex);
+        });
+  }
+
+  @Override
+  public <T> T runCriticalSection(long lockTimeoutMs, CriticalSection<T> criticalSection) {
+    SQLiteDatabase db = getDb();
+    ensureBeginTransaction(db, lockTimeoutMs);
+    try {
+      T result = criticalSection.execute();
+      db.setTransactionSuccessful();
+      return result;
+    } finally {
+      db.endTransaction();
+    }
+  }
+
+  private <T> T inTransaction(Function<SQLiteDatabase, T> function) {
+    SQLiteDatabase db = getDb();
+    db.beginTransaction();
+    try {
+      T result = function.apply(db);
+      db.setTransactionSuccessful();
+      return result;
+    } finally {
+      db.endTransaction();
+    }
+  }
+
+  private static class Metadata {
+    final String key;
+    final String value;
+
+    private Metadata(String key, String value) {
+      this.key = key;
+      this.value = value;
+    }
+  }
+
+  private static Priority toPriority(int value) {
+    if (value < 0 || value >= ALL_PRIORITIES.length) {
+      return Priority.DEFAULT;
+    }
+    return ALL_PRIORITIES[value];
+  }
+
+  private static class OpenHelper extends SQLiteOpenHelper {
+    // TODO: when we do schema upgrades in the future we need to make sure both downgrades and
+    // upgrades work as expected, e.g. `up+down+up` is equivalent to `up`.
+    private static int SCHEMA_VERSION = 1;
+    private static String DB_NAME = "com.google.android.datatransport.events";
+    private static String CREATE_EVENTS_SQL =
+        "CREATE TABLE events "
+            + "(_id INTEGER PRIMARY KEY,"
+            + " backend_id TEXT NOT NULL,"
+            + " transport_name TEXT NOT NULL,"
+            + " priority INTEGER NOT NULL,"
+            + " timestamp_ms INTEGER NOT NULL,"
+            + " uptime_ms INTEGER NOT NULL,"
+            + " payload BLOB NOT NULL,"
+            + " num_attempts INTEGER NOT NULL)";
+
+    private static String CREATE_EVENT_METADATA_SQL =
+        "CREATE TABLE event_metadata "
+            + "(_id INTEGER PRIMARY KEY,"
+            + " event_id INTEGER NOT NULL,"
+            + " name TEXT NOT NULL,"
+            + " value TEXT NOT NULL,"
+            + "FOREIGN KEY (event_id) REFERENCES events(_id) ON DELETE CASCADE)";
+
+    private static String CREATE_BACKENDS_SQL =
+        "CREATE TABLE backends "
+            + "(name TEXT PRIMARY KEY NOT NULL,"
+            + " next_request_ms INTEGER NOT NULL)";
+
+    private static String CREATE_EVENT_BACKEND_INDEX =
+        "CREATE INDEX events_backend_id on events(backend_id)";
+
+    private boolean configured = false;
+
+    private OpenHelper(Context context) {
+      super(context, DB_NAME, null, SCHEMA_VERSION);
+    }
+
+    @Override
+    public void onConfigure(SQLiteDatabase db) {
+      // Note that this is only called automatically by the SQLiteOpenHelper base class on Jelly
+      // Bean and above.
+      configured = true;
+
+      db.rawQuery("PRAGMA busy_timeout=0;", new String[0]).close();
+
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+        db.setForeignKeyConstraintsEnabled(true);
+      }
+    }
+
+    private void ensureConfigured(SQLiteDatabase db) {
+      if (!configured) {
+        onConfigure(db);
+      }
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+      ensureConfigured(db);
+      db.execSQL(CREATE_EVENTS_SQL);
+      db.execSQL(CREATE_EVENT_METADATA_SQL);
+      db.execSQL(CREATE_BACKENDS_SQL);
+      db.execSQL(CREATE_EVENT_BACKEND_INDEX);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+      ensureConfigured(db);
+    }
+
+    @Override
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+      ensureConfigured(db);
+    }
+
+    @Override
+    public void onOpen(SQLiteDatabase db) {
+      ensureConfigured(db);
+    }
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationException.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationException.java
new file mode 100644
index 000000000..6eb74bbb5
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationException.java
@@ -0,0 +1,22 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.synchronization;
+
+/** Exception thrown by {@link SynchronizationGuard} upon failure. */
+public class SynchronizationException extends RuntimeException {
+  public SynchronizationException(String message, Throwable cause) {
+    super(message, cause);
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java
new file mode 100644
index 000000000..6c5ab4c39
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/synchronization/SynchronizationGuard.java
@@ -0,0 +1,44 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.synchronization;
+
+import android.support.annotation.WorkerThread;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+
+@WorkerThread
+public interface SynchronizationGuard {
+  interface CriticalSection<T> {
+    T execute();
+  }
+
+  /**
+   * All operations against the {@link EventStore} will be done as one atomic unit of work.
+   *
+   * <p>Example usage:
+   *
+   * <pre>{@code
+   * store.atomically(() -> {
+   *   store.persist("foo", event);
+   *   store.recordSuccess(Collections.singleton(event));
+   * });
+   * }</pre>
+   *
+   * @param lockTimeoutMs how long to wait to acquire the lock before throwing {@link
+   *     SynchronizationException}.
+   * @param criticalSection Critical section to run while holding the lock.
+   * @throws SynchronizationException if unable to enter critical section.
+   */
+  <T> T runCriticalSection(long lockTimeoutMs, CriticalSection<T> criticalSection);
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Clock.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Clock.java
new file mode 100644
index 000000000..9c97b0531
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Clock.java
@@ -0,0 +1,19 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.time;
+
+public interface Clock {
+  long getTime();
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Monotonic.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Monotonic.java
new file mode 100644
index 000000000..fbfc91d5f
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/Monotonic.java
@@ -0,0 +1,23 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.time;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.inject.Qualifier;
+
+@Retention(RetentionPolicy.SOURCE)
+@Qualifier
+public @interface Monotonic {}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/UptimeClock.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/UptimeClock.java
new file mode 100644
index 000000000..61a3a266e
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/UptimeClock.java
@@ -0,0 +1,25 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.time;
+
+import android.os.SystemClock;
+
+public class UptimeClock implements Clock {
+
+  @Override
+  public long getTime() {
+    return SystemClock.elapsedRealtime();
+  }
+}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTime.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTime.java
new file mode 100644
index 000000000..c78d914cb
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTime.java
@@ -0,0 +1,23 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.time;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.inject.Qualifier;
+
+@Retention(RetentionPolicy.SOURCE)
+@Qualifier
+public @interface WallTime {}
diff --git a/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTimeClock.java b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTimeClock.java
new file mode 100644
index 000000000..38195525c
--- /dev/null
+++ b/transport/transport-runtime/src/main/java/com/google/android/datatransport/runtime/time/WallTimeClock.java
@@ -0,0 +1,22 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.time;
+
+public class WallTimeClock implements Clock {
+  @Override
+  public long getTime() {
+    return System.currentTimeMillis();
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java
new file mode 100644
index 000000000..59183cc8b
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/TransportRuntimeTest.java
@@ -0,0 +1,118 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.google.android.datatransport.Event;
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.Transformer;
+import com.google.android.datatransport.Transport;
+import com.google.android.datatransport.TransportFactory;
+import com.google.android.datatransport.runtime.scheduling.ImmediateScheduler;
+import com.google.android.datatransport.runtime.scheduling.jobscheduling.Uploader;
+import com.google.android.datatransport.runtime.synchronization.SynchronizationGuard;
+import java.util.Collections;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public class TransportRuntimeTest {
+  private static final String TEST_KEY = "test";
+  private static final String TEST_VALUE = "test-value";
+  private TransportInternal transportInternalMock = mock(TransportInternal.class);
+  private TransportBackend mockBackend = mock(TransportBackend.class);
+
+  @Test
+  public void testTransportInternalSend() {
+    String mockBackendName = "backendMock";
+    String testTransport = "testTransport";
+    TransportFactory factory = new TransportFactoryImpl(mockBackendName, transportInternalMock);
+    Event<String> event = Event.ofTelemetry("TelemetryData");
+    Transformer<String, byte[]> transformer = String::getBytes;
+    Transport<String> transport = factory.getTransport(testTransport, String.class, transformer);
+    transport.send(event);
+    SendRequest request =
+        SendRequest.builder()
+            .setBackendName(mockBackendName)
+            .setEvent(event, transformer)
+            .setTransportName(testTransport)
+            .build();
+    verify(transportInternalMock, times(1)).send(request);
+  }
+
+  @Test
+  public void testTransportRuntimeRegistration() {
+    int eventMillis = 3;
+    int uptimeMillis = 1;
+    String mockBackendName = "backend";
+    String testTransport = "testTransport";
+    BackendRegistry registry = new BackendRegistry();
+    TransportRuntime runtime =
+        new TransportRuntime(
+            registry,
+            () -> eventMillis,
+            () -> uptimeMillis,
+            new ImmediateScheduler(Runnable::run, registry),
+            new SynchronizationGuard() {
+              @Override
+              public <T> T runCriticalSection(
+                  long lockTimeoutMs, CriticalSection<T> criticalSection) {
+                return criticalSection.execute();
+              }
+            },
+            new Uploader());
+    Assert.assertNotNull(runtime);
+    runtime.register(mockBackendName, mockBackend);
+
+    when(mockBackend.decorate(any()))
+        .thenAnswer(
+            (Answer<EventInternal>)
+                invocation ->
+                    invocation
+                        .<EventInternal>getArgument(0)
+                        .toBuilder()
+                        .addMetadata(TEST_KEY, TEST_VALUE)
+                        .build());
+    TransportFactory factory = runtime.newFactory(mockBackendName);
+    Transport<String> transport =
+        factory.getTransport(testTransport, String.class, String::getBytes);
+    Event<String> stringEvent = Event.ofTelemetry("TelemetryData");
+    EventInternal expectedEvent =
+        EventInternal.builder()
+            .setEventMillis(eventMillis)
+            .setUptimeMillis(uptimeMillis)
+            .setTransportName(testTransport)
+            .setPriority(Priority.DEFAULT)
+            .setPayload("TelemetryData".getBytes())
+            .build();
+    transport.send(stringEvent);
+    verify(mockBackend, times(1)).decorate(eq(expectedEvent));
+    verify(mockBackend, times(1))
+        .send(
+            eq(
+                BackendRequest.create(
+                    Collections.singleton(
+                        expectedEvent.toBuilder().addMetadata(TEST_KEY, TEST_VALUE).build()))));
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java
new file mode 100644
index 000000000..7e44493f7
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/jobscheduling/JobInfoSchedulerTest.java
@@ -0,0 +1,106 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.jobscheduling;
+
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.content.Context;
+import android.os.PersistableBundle;
+import com.google.android.datatransport.runtime.scheduling.persistence.EventStore;
+import com.google.android.datatransport.runtime.scheduling.persistence.InMemoryEventStore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@Config(sdk = {LOLLIPOP})
+@RunWith(RobolectricTestRunner.class)
+public class JobInfoSchedulerTest {
+  private final String BACKEND_NAME = "backend1";
+  private final Context context = RuntimeEnvironment.application;
+  private final EventStore store = new InMemoryEventStore();
+  private final JobScheduler jobScheduler =
+      (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+  private final JobInfoScheduler scheduler = new JobInfoScheduler(context, store, () -> 0);
+
+  @Test
+  public void schedule_longWaitTimeFirstAttempt() {
+    store.recordNextCallTime(BACKEND_NAME, 1000000);
+    scheduler.schedule(BACKEND_NAME, 1);
+    int jobId = scheduler.getJobId(BACKEND_NAME);
+    assertThat(jobScheduler.getAllPendingJobs()).isNotEmpty();
+    assertThat(jobScheduler.getAllPendingJobs().size()).isEqualTo(1);
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(jobInfo.getId()).isEqualTo(jobId);
+    assertThat(bundle.get(SchedulerUtil.BACKEND_NAME)).isEqualTo(BACKEND_NAME);
+    assertThat(bundle.get(SchedulerUtil.ATTEMPT_NUMBER)).isEqualTo(1);
+    assertThat(jobInfo.getMinLatencyMillis()).isEqualTo(1000000);
+  }
+
+  @Test
+  public void schedule_smallWaitTImeFirstAttempt() {
+    store.recordNextCallTime(BACKEND_NAME, 5);
+    scheduler.schedule(BACKEND_NAME, 1);
+    int jobId = scheduler.getJobId(BACKEND_NAME);
+    assertThat(jobScheduler.getAllPendingJobs()).isNotEmpty();
+    assertThat(jobScheduler.getAllPendingJobs().size()).isEqualTo(1);
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(jobInfo.getId()).isEqualTo(jobId);
+    assertThat(bundle.get(SchedulerUtil.BACKEND_NAME)).isEqualTo(BACKEND_NAME);
+    assertThat(bundle.get(SchedulerUtil.ATTEMPT_NUMBER)).isEqualTo(1);
+    assertThat(jobInfo.getMinLatencyMillis()).isEqualTo(60000); // 2^1*DELTA
+  }
+
+  @Test
+  public void schedule_longWaitTimeTenthAttempt() {
+    store.recordNextCallTime(BACKEND_NAME, 1000000);
+    scheduler.schedule(BACKEND_NAME, 10);
+    int jobId = scheduler.getJobId(BACKEND_NAME);
+    assertThat(jobScheduler.getAllPendingJobs()).isNotEmpty();
+    assertThat(jobScheduler.getAllPendingJobs().size()).isEqualTo(1);
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(jobInfo.getId()).isEqualTo(jobId);
+    assertThat(bundle.get(SchedulerUtil.BACKEND_NAME)).isEqualTo(BACKEND_NAME);
+    assertThat(bundle.get(SchedulerUtil.ATTEMPT_NUMBER)).isEqualTo(10);
+    assertThat(jobInfo.getMinLatencyMillis()).isGreaterThan((long) 1000000);
+  }
+
+  @Test
+  public void schedule_twoJobs() {
+    store.recordNextCallTime(BACKEND_NAME, 5);
+    int jobId = scheduler.getJobId(BACKEND_NAME);
+    // Schedule first job
+    scheduler.schedule(BACKEND_NAME, 1);
+    assertThat(jobScheduler.getAllPendingJobs()).isNotEmpty();
+    assertThat(jobScheduler.getAllPendingJobs().size()).isEqualTo(1);
+    // Schedule another job
+    scheduler.schedule(BACKEND_NAME, 2);
+    assertThat(jobScheduler.getAllPendingJobs()).isNotEmpty();
+    assertThat(jobScheduler.getAllPendingJobs().size()).isEqualTo(1);
+    // The job should be the first job.
+    JobInfo jobInfo = jobScheduler.getAllPendingJobs().get(0);
+    PersistableBundle bundle = jobInfo.getExtras();
+    assertThat(jobInfo.getId()).isEqualTo(jobId);
+    assertThat(bundle.get(SchedulerUtil.ATTEMPT_NUMBER)).isEqualTo(1);
+    assertThat(bundle.get(SchedulerUtil.BACKEND_NAME)).isEqualTo(BACKEND_NAME);
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java
new file mode 100644
index 000000000..bdc7348ea
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStore.java
@@ -0,0 +1,94 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import com.google.android.datatransport.runtime.EventInternal;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+
+/** In memory implementation used for development/testing. */
+public class InMemoryEventStore implements EventStore {
+  private final AtomicLong idCounter = new AtomicLong();
+  private final Map<String, Map<Long, EventInternal>> store = new HashMap<>();
+  private final Map<String, Long> backendCallTime = new HashMap<>();
+
+  @Override
+  public synchronized PersistedEvent persist(String backendName, EventInternal event) {
+    long newId = idCounter.incrementAndGet();
+    getOrCreateBackendStore(backendName).put(newId, event);
+
+    return PersistedEvent.create(newId, backendName, event);
+  }
+
+  private Map<Long, EventInternal> getOrCreateBackendStore(String backendName) {
+    if (!store.containsKey(backendName)) {
+      store.put(backendName, new HashMap<>());
+    }
+    return store.get(backendName);
+  }
+
+  @Override
+  public synchronized void recordFailure(Iterable<PersistedEvent> events) {
+    // discard failed events.
+    recordSuccess(events);
+  }
+
+  @Override
+  public synchronized void recordSuccess(Iterable<PersistedEvent> events) {
+    for (PersistedEvent event : events) {
+      Map<Long, EventInternal> backendStore = store.get(event.getBackendName());
+      if (backendStore == null) {
+        return;
+      }
+      backendStore.remove(event.getId());
+    }
+  }
+
+  @Override
+  public Long getNextCallTime(String backendName) {
+    return backendCallTime.get(backendName);
+  }
+
+  @Override
+  public void recordNextCallTime(String backendName, long timestampMs) {
+    backendCallTime.put(backendName, timestampMs);
+  }
+
+  @Override
+  public synchronized boolean hasPendingEventsFor(String backendName) {
+    Map<Long, EventInternal> backendStore = store.get(backendName);
+    if (backendStore == null) {
+      return false;
+    }
+    return !backendStore.isEmpty();
+  }
+
+  @Override
+  public synchronized Iterable<PersistedEvent> loadAll(String backendName) {
+    Map<Long, EventInternal> backendStore = store.get(backendName);
+    if (backendStore == null) {
+      return Collections.emptyList();
+    }
+    List<PersistedEvent> events = new ArrayList<>();
+    for (Map.Entry<Long, EventInternal> entry : backendStore.entrySet()) {
+      events.add(PersistedEvent.create(entry.getKey(), backendName, entry.getValue()));
+    }
+    return events;
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStoreTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStoreTest.java
new file mode 100644
index 000000000..4c91cc122
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/InMemoryEventStoreTest.java
@@ -0,0 +1,72 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.runtime.EventInternal;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class InMemoryEventStoreTest {
+  private static final String BACKEND_NAME = "backend1";
+
+  private static final EventInternal TEST_EVENT =
+      EventInternal.builder()
+          .setTransportName("transport")
+          .setPriority(Priority.DEFAULT)
+          .setEventMillis(1)
+          .setUptimeMillis(2)
+          .setPayload("hello".getBytes())
+          .build();
+  private static final PersistedEvent TEST_PERSISTED_EVENT =
+      PersistedEvent.create(1, BACKEND_NAME, TEST_EVENT);
+
+  private final EventStore store = new InMemoryEventStore();
+
+  @Test
+  public void test_emptyStore_shouldReturnNothingUponLoadAll() {
+    assertThat(store.loadAll("foo")).isEmpty();
+  }
+
+  @Test
+  public void test_nonEmptyStore_shouldReturnItsStoredEvents() {
+    store.persist(BACKEND_NAME, TEST_EVENT);
+
+    assertThat(store.loadAll(BACKEND_NAME)).containsExactly(TEST_PERSISTED_EVENT);
+  }
+
+  @Test
+  public void recordSuccess_shouldRemoveEventsFromStorage() {
+    store.persist(BACKEND_NAME, TEST_EVENT);
+
+    store.recordSuccess(Collections.singleton(TEST_PERSISTED_EVENT));
+
+    assertThat(store.loadAll(BACKEND_NAME)).isEmpty();
+  }
+
+  @Test
+  public void recordFailure_shouldRemoveEventsFromStorage() {
+    store.persist(BACKEND_NAME, TEST_EVENT);
+
+    store.recordFailure(Collections.singleton(TEST_PERSISTED_EVENT));
+
+    assertThat(store.loadAll(BACKEND_NAME)).isEmpty();
+  }
+}
diff --git a/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java
new file mode 100644
index 000000000..b2fca61a3
--- /dev/null
+++ b/transport/transport-runtime/src/test/java/com/google/android/datatransport/runtime/scheduling/persistence/SQLiteEventStoreTest.java
@@ -0,0 +1,138 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.android.datatransport.runtime.scheduling.persistence;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.datatransport.Priority;
+import com.google.android.datatransport.runtime.EventInternal;
+import com.google.android.datatransport.runtime.time.UptimeClock;
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(RobolectricTestRunner.class)
+public class SQLiteEventStoreTest {
+
+  private static final String BACKEND_NAME = "backend1";
+  private static final String ANOTHER_BACKEND_NAME = "backend2";
+  private static final EventInternal EVENT =
+      EventInternal.builder()
+          .setTransportName("42")
+          .setPriority(Priority.DEFAULT)
+          .setEventMillis(1)
+          .setUptimeMillis(2)
+          .setPayload("Hello".getBytes())
+          .addMetadata("key1", "value1")
+          .addMetadata("key2", "value2")
+          .build();
+
+  private final SQLiteEventStore store =
+      new SQLiteEventStore(RuntimeEnvironment.application, new UptimeClock());
+
+  @Test
+  public void persist_correctlyRoundTrips() {
+    PersistedEvent newEvent = store.persist(BACKEND_NAME, EVENT);
+    Iterable<PersistedEvent> events = store.loadAll(BACKEND_NAME);
+
+    assertThat(events).containsExactly(newEvent);
+  }
+
+  @Test
+  public void recordSuccess_deletesEvents() {
+    PersistedEvent newEvent1 = store.persist(BACKEND_NAME, EVENT);
+    PersistedEvent newEvent2 = store.persist(BACKEND_NAME, EVENT);
+
+    store.recordSuccess(Collections.singleton(newEvent1));
+    assertThat(store.loadAll(BACKEND_NAME)).containsExactly(newEvent2);
+    store.recordSuccess(Collections.singleton(newEvent2));
+    assertThat(store.loadAll(BACKEND_NAME)).isEmpty();
+  }
+
+  @Test
+  public void recordSuccess_withMultipleEvents_deletesEvents() {
+    PersistedEvent newEvent1 = store.persist(BACKEND_NAME, EVENT);
+    PersistedEvent newEvent2 = store.persist(BACKEND_NAME, EVENT);
+
+    store.recordSuccess(Arrays.asList(newEvent1, newEvent2));
+    assertThat(store.loadAll(BACKEND_NAME)).isEmpty();
+  }
+
+  @Test
+  public void recordFailure_eventuallyDeletesEvents() {
+    PersistedEvent newEvent1 = store.persist(BACKEND_NAME, EVENT);
+    PersistedEvent newEvent2 = store.persist(BACKEND_NAME, EVENT);
+
+    for (int i = 0; i < SQLiteEventStore.MAX_RETRIES; i++) {
+      Iterable<PersistedEvent> events = store.loadAll(BACKEND_NAME);
+      assertThat(events).containsExactly(newEvent1, newEvent2);
+      store.recordFailure(Collections.singleton(newEvent1));
+    }
+    assertThat(store.loadAll(BACKEND_NAME)).containsExactly(newEvent2);
+  }
+
+  @Test
+  public void recordFailure_withMultipleEvents_eventuallyDeletesEvents() {
+    PersistedEvent newEvent1 = store.persist(BACKEND_NAME, EVENT);
+    PersistedEvent newEvent2 = store.persist(BACKEND_NAME, EVENT);
+
+    for (int i = 0; i < SQLiteEventStore.MAX_RETRIES; i++) {
+      Iterable<PersistedEvent> events = store.loadAll(BACKEND_NAME);
+      assertThat(events).containsExactly(newEvent1, newEvent2);
+      store.recordFailure(Arrays.asList(newEvent1, newEvent2));
+    }
+    assertThat(store.loadAll(BACKEND_NAME)).isEmpty();
+  }
+
+  @Test
+  public void getNextCallTime_doesNotReturnUnknownBackends() {
+    assertThat(store.getNextCallTime(BACKEND_NAME)).isNull();
+  }
+
+  @Test
+  public void recordNextCallTime_correctlyRecordsTimestamp() {
+    store.recordNextCallTime(BACKEND_NAME, 1);
+    store.recordNextCallTime(ANOTHER_BACKEND_NAME, 2);
+
+    assertThat(store.getNextCallTime(BACKEND_NAME)).isEqualTo(1);
+    assertThat(store.getNextCallTime(ANOTHER_BACKEND_NAME)).isEqualTo(2);
+  }
+
+  @Test
+  public void recordNextCallTime_correctlyUpdatesTimestamp() {
+    long timestamp1 = 1;
+    long timestamp2 = 2;
+    store.recordNextCallTime(BACKEND_NAME, timestamp1);
+
+    assertThat(store.getNextCallTime(BACKEND_NAME)).isEqualTo(timestamp1);
+
+    store.recordNextCallTime(BACKEND_NAME, timestamp2);
+
+    assertThat(store.getNextCallTime(BACKEND_NAME)).isEqualTo(timestamp2);
+  }
+
+  @Test
+  public void hasPendingEventsFor_whenEventsExist_shouldReturnTrue() {
+    assertThat(store.hasPendingEventsFor(BACKEND_NAME)).isFalse();
+
+    store.persist(BACKEND_NAME, EVENT);
+
+    assertThat(store.hasPendingEventsFor(BACKEND_NAME)).isTrue();
+    assertThat(store.hasPendingEventsFor(ANOTHER_BACKEND_NAME)).isFalse();
+  }
+}
diff --git a/transport/transport-runtime/transport-runtime.gradle b/transport/transport-runtime/transport-runtime.gradle
new file mode 100644
index 000000000..ecaba0ed3
--- /dev/null
+++ b/transport/transport-runtime/transport-runtime.gradle
@@ -0,0 +1,70 @@
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+apply plugin: 'com.android.library'
+apply plugin: com.google.firebase.gradle.plugins.ci.device.FirebaseTestLabPlugin
+
+android {
+    compileSdkVersion 28
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 28
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+    compileOptions {
+        sourceCompatibility = '1.8'
+        targetCompatibility = '1.8'
+    }
+    sourceSets {
+        androidTest {
+            aidl {
+                srcDir 'src/androidTest/aidl'
+            }
+        }
+    }
+}
+
+firebaseTestLab {
+    devices = [
+            'model=Pixel2,version=28,locale=en,orientation=portrait',
+            'model=Pixel2,version=27,locale=en,orientation=portrait',
+            'model=victara,version=19,locale=en,orientation=portrait',
+            'model=Nexus4,version=22,locale=en,orientation=portrait',
+            'model=Nexus7,version=21,locale=en,orientation=portrait',
+            'model=Nexus4,version=19,locale=en,orientation=portrait',
+    ]
+}
+
+dependencies {
+    implementation project(':transport:transport-api')
+    implementation 'com.google.dagger:dagger:2.13'
+    implementation 'com.android.support:support-annotations:28.0.0'
+
+    compileOnly "com.google.auto.value:auto-value-annotations:1.6.2"
+
+    annotationProcessor "com.google.auto.value:auto-value:1.6.2"
+    annotationProcessor 'com.google.dagger:dagger-compiler:2.13'
+
+    testImplementation 'junit:junit:4.12'
+    testImplementation "com.google.truth:truth:$googleTruthVersion"
+    testImplementation 'androidx.test:core:1.1.0'
+    testImplementation 'org.robolectric:robolectric:4.1'
+    testImplementation 'org.mockito:mockito-core:2.21.0'
+
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation "com.google.truth:truth:$googleTruthVersion"
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'com.android.support.test:rules:1.0.2'
+    androidTestImplementation 'org.mockito:mockito-core:2.21.0'
+}
diff --git a/transport/transport.gradle b/transport/transport.gradle
new file mode 100644
index 000000000..9f0ff053c
--- /dev/null
+++ b/transport/transport.gradle
@@ -0,0 +1,19 @@
+// Copyright 2018 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+
+configure(subprojects) {
+    group = 'com.google.android.datatransport'
+}
+
